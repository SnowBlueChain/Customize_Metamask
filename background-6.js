LavaPack.loadBundle([
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\minimal.js", {"./longbits":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\longbits.js","@protobufjs/aspromise":"F:\\metamask-extension\\node_modules\\@protobufjs\\aspromise\\index.js","@protobufjs/base64":"F:\\metamask-extension\\node_modules\\@protobufjs\\base64\\index.js","@protobufjs/eventemitter":"F:\\metamask-extension\\node_modules\\@protobufjs\\eventemitter\\index.js","@protobufjs/float":"F:\\metamask-extension\\node_modules\\@protobufjs\\float\\index.js","@protobufjs/inquire":"F:\\metamask-extension\\node_modules\\@protobufjs\\inquire\\index.js","@protobufjs/pool":"F:\\metamask-extension\\node_modules\\@protobufjs\\pool\\index.js","@protobufjs/utf8":"F:\\metamask-extension\\node_modules\\@protobufjs\\utf8\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cutil%5Cminimal.js
      return function (require, module, exports) {
"use strict";
var util = exports;

// used to return a Promise where callback is omitted
util.asPromise = require("@protobufjs/aspromise");

// converts to / from base64 encoded strings
util.base64 = require("@protobufjs/base64");

// base class of rpc.Service
util.EventEmitter = require("@protobufjs/eventemitter");

// float handling accross browsers
util.float = require("@protobufjs/float");

// requires modules optionally and hides the call from bundlers
util.inquire = require("@protobufjs/inquire");

// converts to / from utf8 encoded strings
util.utf8 = require("@protobufjs/utf8");

// provides a node-like buffer pool in the browser
util.pool = require("@protobufjs/pool");

// utility to work with the low and high bits of a 64 bit value
util.LongBits = require("./longbits");

/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */
util.isNode = Boolean(typeof global !== "undefined"
                   && global
                   && global.process
                   && global.process.versions
                   && global.process.versions.node);

/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */
util.global = util.isNode && global
           || typeof window !== "undefined" && window
           || typeof self   !== "undefined" && self
           || this; // eslint-disable-line no-invalid-this

/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */
util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes

/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */
util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes

/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */
util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};

/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */
util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};

/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */
util.isObject = function isObject(value) {
    return value && typeof value === "object";
};

/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isset =

/**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */
util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};

/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */

/**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */
util.Buffer = (function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */
        return null;
    }
})();

// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;

// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;

/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */
util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */
    return typeof sizeOrArray === "number"
        ? util.Buffer
            ? util._Buffer_allocUnsafe(sizeOrArray)
            : new util.Array(sizeOrArray)
        : util.Buffer
            ? util._Buffer_from(sizeOrArray)
            : typeof Uint8Array === "undefined"
                ? sizeOrArray
                : new Uint8Array(sizeOrArray);
};

/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */
util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */ : Array;

/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */

/**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */
util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long
         || /* istanbul ignore next */ util.global.Long
         || util.inquire("long");

/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */
util.key2Re = /^true|false|0|1$/;

/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;

/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */
util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;

/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */
util.longToHash = function longToHash(value) {
    return value
        ? util.LongBits.from(value).toHash()
        : util.LongBits.zeroHash;
};

/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */
util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};

/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */
function merge(dst, src, ifNotSet) { // used by converters
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === undefined || !ifNotSet)
            dst[keys[i]] = src[keys[i]];
    return dst;
}

util.merge = merge;

/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */
util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};

/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */
function newError(name) {

    function CustomError(message, properties) {

        if (!(this instanceof CustomError))
            return new CustomError(message, properties);

        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function

        Object.defineProperty(this, "message", { get: function() { return message; } });

        /* istanbul ignore next */
        if (Error.captureStackTrace) // node
            Error.captureStackTrace(this, CustomError);
        else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });

        if (properties)
            merge(this, properties);
    }

    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;

    Object.defineProperty(CustomError.prototype, "name", { get: function() { return name; } });

    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };

    return CustomError;
}

util.newError = newError;

/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */
util.ProtocolError = newError("ProtocolError");

/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */

/**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */

/**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */
util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;

    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */
    return function() { // eslint-disable-line consistent-return
        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)
            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)
                return keys[i];
    };
};

/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */

/**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */
util.oneOfSetter = function setOneOf(fieldNames) {

    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */
    return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
                delete this[fieldNames[i]];
    };
};

/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */
util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};

// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */
    if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||
        /* istanbul ignore next */
        function Buffer_from(value, encoding) {
            return new Buffer(value, encoding);
        };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||
        /* istanbul ignore next */
        function Buffer_allocUnsafe(size) {
            return new Buffer(size);
        };
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\util\\minimal.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\verifier.js", {"./enum":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\enum.js","./util":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cverifier.js
      return function (require, module, exports) {
"use strict";
module.exports = verifier;

var Enum      = require("./enum"),
    util      = require("./util");

function invalid(field, expected) {
    return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:"+field.keyType+"}" : "") + " expected";
}

/**
 * Generates a partial value verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {number} fieldIndex Field index
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyValue(gen, field, fieldIndex, ref) {
    /* eslint-disable no-unexpected-multiline */
    if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) { gen
            ("switch(%s){", ref)
                ("default:")
                    ("return%j", invalid(field, "enum value"));
            for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen
                ("case %i:", field.resolvedType.values[keys[j]]);
            gen
                    ("break")
            ("}");
        } else {
            gen
            ("{")
                ("var e=types[%i].verify(%s);", fieldIndex, ref)
                ("if(e)")
                    ("return%j+e", field.name + ".")
            ("}");
        }
    } else {
        switch (field.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32": gen
                ("if(!util.isInteger(%s))", ref)
                    ("return%j", invalid(field, "integer"));
                break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64": gen
                ("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)
                    ("return%j", invalid(field, "integer|Long"));
                break;
            case "float":
            case "double": gen
                ("if(typeof %s!==\"number\")", ref)
                    ("return%j", invalid(field, "number"));
                break;
            case "bool": gen
                ("if(typeof %s!==\"boolean\")", ref)
                    ("return%j", invalid(field, "boolean"));
                break;
            case "string": gen
                ("if(!util.isString(%s))", ref)
                    ("return%j", invalid(field, "string"));
                break;
            case "bytes": gen
                ("if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))", ref, ref, ref)
                    ("return%j", invalid(field, "buffer"));
                break;
        }
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a partial key verifier.
 * @param {Codegen} gen Codegen instance
 * @param {Field} field Reflected field
 * @param {string} ref Variable reference
 * @returns {Codegen} Codegen instance
 * @ignore
 */
function genVerifyKey(gen, field, ref) {
    /* eslint-disable no-unexpected-multiline */
    switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32": gen
            ("if(!util.key32Re.test(%s))", ref)
                ("return%j", invalid(field, "integer key"));
            break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64": gen
            ("if(!util.key64Re.test(%s))", ref) // see comment above: x is ok, d is not
                ("return%j", invalid(field, "integer|Long key"));
            break;
        case "bool": gen
            ("if(!util.key2Re.test(%s))", ref)
                ("return%j", invalid(field, "boolean key"));
            break;
    }
    return gen;
    /* eslint-enable no-unexpected-multiline */
}

/**
 * Generates a verifier specific to the specified message type.
 * @param {Type} mtype Message type
 * @returns {Codegen} Codegen instance
 */
function verifier(mtype) {
    /* eslint-disable no-unexpected-multiline */

    var gen = util.codegen(["m"], mtype.name + "$verify")
    ("if(typeof m!==\"object\"||m===null)")
        ("return%j", "object expected");
    var oneofs = mtype.oneofsArray,
        seenFirstField = {};
    if (oneofs.length) gen
    ("var p={}");

    for (var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(),
            ref   = "m" + util.safeProp(field.name);

        if (field.optional) gen
        ("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name); // !== undefined && !== null

        // map fields
        if (field.map) { gen
            ("if(!util.isObject(%s))", ref)
                ("return%j", invalid(field, "object"))
            ("var k=Object.keys(%s)", ref)
            ("for(var i=0;i<k.length;++i){");
                genVerifyKey(gen, field, "k[i]");
                genVerifyValue(gen, field, i, ref + "[k[i]]")
            ("}");

        // repeated fields
        } else if (field.repeated) { gen
            ("if(!Array.isArray(%s))", ref)
                ("return%j", invalid(field, "array"))
            ("for(var i=0;i<%s.length;++i){", ref);
                genVerifyValue(gen, field, i, ref + "[i]")
            ("}");

        // required or present fields
        } else {
            if (field.partOf) {
                var oneofProp = util.safeProp(field.partOf.name);
                if (seenFirstField[field.partOf.name] === 1) gen
            ("if(p%s===1)", oneofProp)
                ("return%j", field.partOf.name + ": multiple values");
                seenFirstField[field.partOf.name] = 1;
                gen
            ("p%s=1", oneofProp);
            }
            genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen
        ("}");
    }
    return gen
    ("return null");
    /* eslint-enable no-unexpected-multiline */
}
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\verifier.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\wrappers.js", {"./message":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\message.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cwrappers.js
      return function (require, module, exports) {
"use strict";

/**
 * Wrappers for common types.
 * @type {Object.<string,IWrapper>}
 * @const
 */
var wrappers = exports;

var Message = require("./message");

/**
 * From object converter part of an {@link IWrapper}.
 * @typedef WrapperFromObjectConverter
 * @type {function}
 * @param {Object.<string,*>} object Plain object
 * @returns {Message<{}>} Message instance
 * @this Type
 */

/**
 * To object converter part of an {@link IWrapper}.
 * @typedef WrapperToObjectConverter
 * @type {function}
 * @param {Message<{}>} message Message instance
 * @param {IConversionOptions} [options] Conversion options
 * @returns {Object.<string,*>} Plain object
 * @this Type
 */

/**
 * Common type wrapper part of {@link wrappers}.
 * @interface IWrapper
 * @property {WrapperFromObjectConverter} [fromObject] From object converter
 * @property {WrapperToObjectConverter} [toObject] To object converter
 */

// Custom wrapper for Any
wrappers[".google.protobuf.Any"] = {

    fromObject: function(object) {

        // unwrap value type if mapped
        if (object && object["@type"]) {
             // Only use fully qualified type name after the last '/'
            var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type) {
                // type_url does not accept leading "."
                var type_url = object["@type"].charAt(0) === "." ?
                    object["@type"].substr(1) : object["@type"];
                // type_url prefix is optional, but path seperator is required
                if (type_url.indexOf("/") === -1) {
                    type_url = "/" + type_url;
                }
                return this.create({
                    type_url: type_url,
                    value: type.encode(type.fromObject(object)).finish()
                });
            }
        }

        return this.fromObject(object);
    },

    toObject: function(message, options) {

        // Default prefix
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";

        // decode value if requested and unmapped
        if (options && options.json && message.type_url && message.value) {
            // Only use fully qualified type name after the last '/'
            name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
            // Separate the prefix used
            prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
            var type = this.lookup(name);
            /* istanbul ignore else */
            if (type)
                message = type.decode(message.value);
        }

        // wrap value if unmapped
        if (!(message instanceof this.ctor) && message instanceof Message) {
            var object = message.$type.toObject(message, options);
            var messageName = message.$type.fullName[0] === "." ?
                message.$type.fullName.substr(1) : message.$type.fullName;
            // Default to type.googleapis.com prefix if no prefix is used
            if (prefix === "") {
                prefix = googleApi;
            }
            name = prefix + messageName;
            object["@type"] = name;
            return object;
        }

        return this.toObject(message, options);
    }
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\wrappers.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\writer.js", {"./util/minimal":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\minimal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cwriter.js
      return function (require, module, exports) {
"use strict";
module.exports = Writer;

var util      = require("./util/minimal");

var BufferWriter; // cyclic

var LongBits  = util.LongBits,
    base64    = util.base64,
    utf8      = util.utf8;

/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */
function Op(fn, len, val) {

    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */
    this.fn = fn;

    /**
     * Value byte length.
     * @type {number}
     */
    this.len = len;

    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */
    this.next = undefined;

    /**
     * Value to write.
     * @type {*}
     */
    this.val = val; // type varies
}

/* istanbul ignore next */
function noop() {} // eslint-disable-line no-empty-function

/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */
function State(writer) {

    /**
     * Current head.
     * @type {Writer.Op}
     */
    this.head = writer.head;

    /**
     * Current tail.
     * @type {Writer.Op}
     */
    this.tail = writer.tail;

    /**
     * Current buffer length.
     * @type {number}
     */
    this.len = writer.len;

    /**
     * Next state.
     * @type {State|null}
     */
    this.next = writer.states;
}

/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */
function Writer() {

    /**
     * Current length.
     * @type {number}
     */
    this.len = 0;

    /**
     * Operations head.
     * @type {Object}
     */
    this.head = new Op(noop, 0, 0);

    /**
     * Operations tail
     * @type {Object}
     */
    this.tail = this.head;

    /**
     * Linked forked states.
     * @type {Object|null}
     */
    this.states = null;

    // When a value is written, the writer calculates its byte length and puts it into a linked
    // list of operations to perform when finish() is called. This both allows us to allocate
    // buffers of the exact required size and reduces the amount of work we have to do compared
    // to first calculating over objects and then encoding over objects. In our case, the encoding
    // part is just a linked list walk calling operations with already prepared values.
}

var create = function create() {
    return util.Buffer
        ? function create_buffer_setup() {
            return (Writer.create = function create_buffer() {
                return new BufferWriter();
            })();
        }
        /* istanbul ignore next */
        : function create_array() {
            return new Writer();
        };
};

/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */
Writer.create = create();

/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */
Writer.alloc = function alloc(size) {
    return new util.Array(size);
};

// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */
if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);

/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */
Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};

function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}

function writeVarint32(val, buf, pos) {
    while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}

/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */
function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}

VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;

/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0)
                < 128       ? 1
        : value < 16384     ? 2
        : value < 2097152   ? 3
        : value < 268435456 ? 4
        :                     5,
    value)).len;
    return this;
};

/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.int32 = function write_int32(value) {
    return value < 0
        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
        : this.uint32(value);
};

/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};

function writeVarint64(val, buf, pos) {
    while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}

/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.int64 = Writer.prototype.uint64;

/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};

/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};

function writeFixed32(val, buf, pos) {
    buf[pos    ] =  val         & 255;
    buf[pos + 1] =  val >>> 8   & 255;
    buf[pos + 2] =  val >>> 16  & 255;
    buf[pos + 3] =  val >>> 24;
}

/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};

/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.sfixed32 = Writer.prototype.fixed32;

/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};

/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */
Writer.prototype.sfixed64 = Writer.prototype.fixed64;

/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};

/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};

var writeBytes = util.Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos); // also works for plain array values
    }
    /* istanbul ignore next */
    : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
            buf[pos + i] = val[i];
    };

/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */
Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
        return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};

/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */
Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len
        ? this.uint32(len)._push(utf8.write, len, value)
        : this._push(writeByte, 1, 0);
};

/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */
Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};

/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */
Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head   = this.states.head;
        this.tail   = this.states.tail;
        this.len    = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len  = 0;
    }
    return this;
};

/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */
Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
        tail = this.tail,
        len  = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};

/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */
Writer.prototype.finish = function finish() {
    var head = this.head.next, // skip noop
        buf  = this.constructor.alloc(this.len),
        pos  = 0;
    while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};

Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\writer.js",}],
["F:\\metamask-extension\\node_modules\\protobufjs\\src\\writer_buffer.js", {"./util/minimal":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\util\\minimal.js","./writer":"F:\\metamask-extension\\node_modules\\protobufjs\\src\\writer.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cprotobufjs%5Csrc%5Cwriter_buffer.js
      return function (require, module, exports) {
"use strict";
module.exports = BufferWriter;

// extends Writer
var Writer = require("./writer");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

var util = require("./util/minimal");

/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */
function BufferWriter() {
    Writer.call(this);
}

BufferWriter._configure = function () {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */
    BufferWriter.alloc = util._Buffer_allocUnsafe;

    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set"
        ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
          // also works for plain array values
        }
        /* istanbul ignore next */
        : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy) // Buffer values
            val.copy(buf, pos, 0, val.length);
          else for (var i = 0; i < val.length;) // plain array values
            buf[pos++] = val[i++];
        };
};


/**
 * @override
 */
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
        value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};

function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)
        util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
        buf.utf8Write(val, pos);
    else
        buf.write(val, pos);
}

/**
 * @override
 */
BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
        this._push(writeStringBuffer, len, value);
    return this;
};


/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */

BufferWriter._configure();

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/transport>protobufjs",file:"node_modules\\protobufjs\\src\\writer_buffer.js",}],
["F:\\metamask-extension\\node_modules\\pushdata-bitcoin\\index.js", {"bitcoin-ops":"F:\\metamask-extension\\node_modules\\bitcoin-ops\\index.json"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cpushdata-bitcoin%5Cindex.js
      return function (require, module, exports) {
var OPS = require('bitcoin-ops')

function encodingLength (i) {
  return i < OPS.OP_PUSHDATA1 ? 1
  : i <= 0xff ? 2
  : i <= 0xffff ? 3
  : 5
}

function encode (buffer, number, offset) {
  var size = encodingLength(number)

  // ~6 bit
  if (size === 1) {
    buffer.writeUInt8(number, offset)

  // 8 bit
  } else if (size === 2) {
    buffer.writeUInt8(OPS.OP_PUSHDATA1, offset)
    buffer.writeUInt8(number, offset + 1)

  // 16 bit
  } else if (size === 3) {
    buffer.writeUInt8(OPS.OP_PUSHDATA2, offset)
    buffer.writeUInt16LE(number, offset + 1)

  // 32 bit
  } else {
    buffer.writeUInt8(OPS.OP_PUSHDATA4, offset)
    buffer.writeUInt32LE(number, offset + 1)
  }

  return size
}

function decode (buffer, offset) {
  var opcode = buffer.readUInt8(offset)
  var number, size

  // ~6 bit
  if (opcode < OPS.OP_PUSHDATA1) {
    number = opcode
    size = 1

  // 8 bit
  } else if (opcode === OPS.OP_PUSHDATA1) {
    if (offset + 2 > buffer.length) return null
    number = buffer.readUInt8(offset + 1)
    size = 2

  // 16 bit
  } else if (opcode === OPS.OP_PUSHDATA2) {
    if (offset + 3 > buffer.length) return null
    number = buffer.readUInt16LE(offset + 1)
    size = 3

  // 32 bit
  } else {
    if (offset + 5 > buffer.length) return null
    if (opcode !== OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode')

    number = buffer.readUInt32LE(offset + 1)
    size = 5
  }

  return {
    opcode: opcode,
    number: number,
    size: size
  }
}

module.exports = {
  encodingLength: encodingLength,
  encode: encode,
  decode: decode
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>pushdata-bitcoin",file:"node_modules\\pushdata-bitcoin\\index.js",}],
["F:\\metamask-extension\\node_modules\\remove-trailing-slash\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cremove-trailing-slash%5Cindex.js
      return function (require, module, exports) {

/**
 * Remove trailing slashes from the given `str`
 *
 * @api public
 * @param {String} str
 * @return {String}
 */
exports = module.exports = function (str) {
  return String(str).replace(exports.expr, '');
};

/**
 * Expose the regex
 *
 * @api private
 * @type {RegExp}
 */
exports.expr = /\/+$/;

      };
    };
  }
  }
}, {package:"remove-trailing-slash",file:"node_modules\\remove-trailing-slash\\index.js",}],
["F:\\metamask-extension\\node_modules\\rfdc\\index.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Crfdc%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'
module.exports = rfdc

function copyBuffer (cur) {
  if (cur instanceof Buffer) {
    return Buffer.from(cur)
  }

  return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length)
}

function rfdc (opts) {
  opts = opts || {}

  if (opts.circles) return rfdcCircles(opts)
  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    var keys = Object.keys(a)
    var a2 = new Array(keys.length)
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i]
      var cur = a[k]
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur
      } else if (cur instanceof Date) {
        a2[k] = new Date(cur)
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur)
      } else {
        a2[k] = fn(cur)
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, clone)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))
    var o2 = {}
    for (var k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), clone))
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), clone))
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        o2[k] = clone(cur)
      }
    }
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))
    var o2 = {}
    for (var k in o) {
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        o2[k] = cloneProto(cur)
      }
    }
    return o2
  }
}

function rfdcCircles (opts) {
  var refs = []
  var refsNew = []

  return opts.proto ? cloneProto : clone

  function cloneArray (a, fn) {
    var keys = Object.keys(a)
    var a2 = new Array(keys.length)
    for (var i = 0; i < keys.length; i++) {
      var k = keys[i]
      var cur = a[k]
      if (typeof cur !== 'object' || cur === null) {
        a2[k] = cur
      } else if (cur instanceof Date) {
        a2[k] = new Date(cur)
      } else if (ArrayBuffer.isView(cur)) {
        a2[k] = copyBuffer(cur)
      } else {
        var index = refs.indexOf(cur)
        if (index !== -1) {
          a2[k] = refsNew[index]
        } else {
          a2[k] = fn(cur)
        }
      }
    }
    return a2
  }

  function clone (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, clone)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), clone))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), clone))
    var o2 = {}
    refs.push(o)
    refsNew.push(o2)
    for (var k in o) {
      if (Object.hasOwnProperty.call(o, k) === false) continue
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), clone))
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), clone))
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        var i = refs.indexOf(cur)
        if (i !== -1) {
          o2[k] = refsNew[i]
        } else {
          o2[k] = clone(cur)
        }
      }
    }
    refs.pop()
    refsNew.pop()
    return o2
  }

  function cloneProto (o) {
    if (typeof o !== 'object' || o === null) return o
    if (o instanceof Date) return new Date(o)
    if (Array.isArray(o)) return cloneArray(o, cloneProto)
    if (o instanceof Map) return new Map(cloneArray(Array.from(o), cloneProto))
    if (o instanceof Set) return new Set(cloneArray(Array.from(o), cloneProto))
    var o2 = {}
    refs.push(o)
    refsNew.push(o2)
    for (var k in o) {
      var cur = o[k]
      if (typeof cur !== 'object' || cur === null) {
        o2[k] = cur
      } else if (cur instanceof Date) {
        o2[k] = new Date(cur)
      } else if (cur instanceof Map) {
        o2[k] = new Map(cloneArray(Array.from(cur), cloneProto))
      } else if (cur instanceof Set) {
        o2[k] = new Set(cloneArray(Array.from(cur), cloneProto))
      } else if (ArrayBuffer.isView(cur)) {
        o2[k] = copyBuffer(cur)
      } else {
        var i = refs.indexOf(cur)
        if (i !== -1) {
          o2[k] = refsNew[i]
        } else {
          o2[k] = cloneProto(cur)
        }
      }
    }
    refs.pop()
    refsNew.pop()
    return o2
  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/snaps-utils>rfdc",file:"node_modules\\rfdc\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js", {"./xrp-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\xrp-codec.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-address-codec%5Cdist%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidXAddress = exports.decodeXAddress = exports.xAddressToClassicAddress = exports.encodeXAddress = exports.classicAddressToXAddress = exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.decodeNodePublic = exports.encodeNodePublic = exports.decodeAccountID = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
const assert = require("assert");
const xrp_codec_1 = require("./xrp-codec");
Object.defineProperty(exports, "codec", { enumerable: true, get: function () { return xrp_codec_1.codec; } });
Object.defineProperty(exports, "encodeSeed", { enumerable: true, get: function () { return xrp_codec_1.encodeSeed; } });
Object.defineProperty(exports, "decodeSeed", { enumerable: true, get: function () { return xrp_codec_1.decodeSeed; } });
Object.defineProperty(exports, "encodeAccountID", { enumerable: true, get: function () { return xrp_codec_1.encodeAccountID; } });
Object.defineProperty(exports, "decodeAccountID", { enumerable: true, get: function () { return xrp_codec_1.decodeAccountID; } });
Object.defineProperty(exports, "encodeNodePublic", { enumerable: true, get: function () { return xrp_codec_1.encodeNodePublic; } });
Object.defineProperty(exports, "decodeNodePublic", { enumerable: true, get: function () { return xrp_codec_1.decodeNodePublic; } });
Object.defineProperty(exports, "encodeAccountPublic", { enumerable: true, get: function () { return xrp_codec_1.encodeAccountPublic; } });
Object.defineProperty(exports, "decodeAccountPublic", { enumerable: true, get: function () { return xrp_codec_1.decodeAccountPublic; } });
Object.defineProperty(exports, "isValidClassicAddress", { enumerable: true, get: function () { return xrp_codec_1.isValidClassicAddress; } });
const PREFIX_BYTES = {
    // 5, 68
    MAIN: Buffer.from([0x05, 0x44]),
    // 4, 147
    TEST: Buffer.from([0x04, 0x93]),
};
const MAX_32_BIT_UNSIGNED_INT = 4294967295;
function classicAddressToXAddress(classicAddress, tag, test) {
    const accountId = (0, xrp_codec_1.decodeAccountID)(classicAddress);
    return encodeXAddress(accountId, tag, test);
}
exports.classicAddressToXAddress = classicAddressToXAddress;
function encodeXAddress(accountId, tag, test) {
    if (accountId.length !== 20) {
        // RIPEMD160 is 160 bits = 20 bytes
        throw new Error('Account ID must be 20 bytes');
    }
    if (tag > MAX_32_BIT_UNSIGNED_INT) {
        throw new Error('Invalid tag');
    }
    const theTag = tag === false ? 0 : tag;
    const flag = tag === false ? 0 : 1;
    /* eslint-disable no-bitwise ---
     * need to use bitwise operations here */
    const bytes = Buffer.concat([
        test ? PREFIX_BYTES.TEST : PREFIX_BYTES.MAIN,
        accountId,
        Buffer.from([
            // 0x00 if no tag, 0x01 if 32-bit tag
            flag,
            // first byte
            theTag & 0xff,
            // second byte
            (theTag >> 8) & 0xff,
            // third byte
            (theTag >> 16) & 0xff,
            // fourth byte
            (theTag >> 24) & 0xff,
            0,
            0,
            0,
            // four zero bytes (reserved for 64-bit tags)
            0,
        ]),
    ]);
    /* eslint-enable no-bitwise */
    return xrp_codec_1.codec.encodeChecked(bytes);
}
exports.encodeXAddress = encodeXAddress;
function xAddressToClassicAddress(xAddress) {
    const { accountId, tag, test } = decodeXAddress(xAddress);
    const classicAddress = (0, xrp_codec_1.encodeAccountID)(accountId);
    return {
        classicAddress,
        tag,
        test,
    };
}
exports.xAddressToClassicAddress = xAddressToClassicAddress;
function decodeXAddress(xAddress) {
    const decoded = xrp_codec_1.codec.decodeChecked(xAddress);
    const test = isBufferForTestAddress(decoded);
    const accountId = decoded.slice(2, 22);
    const tag = tagFromBuffer(decoded);
    return {
        accountId,
        tag,
        test,
    };
}
exports.decodeXAddress = decodeXAddress;
function isBufferForTestAddress(buf) {
    const decodedPrefix = buf.slice(0, 2);
    if (PREFIX_BYTES.MAIN.equals(decodedPrefix)) {
        return false;
    }
    if (PREFIX_BYTES.TEST.equals(decodedPrefix)) {
        return true;
    }
    throw new Error('Invalid X-address: bad prefix');
}
function tagFromBuffer(buf) {
    const flag = buf[22];
    if (flag >= 2) {
        // No support for 64-bit tags at this time
        throw new Error('Unsupported X-address');
    }
    if (flag === 1) {
        // Little-endian to big-endian
        return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000;
    }
    assert.strictEqual(flag, 0, 'flag must be zero to indicate no tag');
    assert.ok(Buffer.from('0000000000000000', 'hex').equals(buf.slice(23, 23 + 8)), 'remaining bytes must be zero');
    return false;
}
function isValidXAddress(xAddress) {
    try {
        decodeXAddress(xAddress);
    }
    catch (_error) {
        return false;
    }
    return true;
}
exports.isValidXAddress = isValidXAddress;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-address-codec",file:"node_modules\\ripple-address-codec\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\utils.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-address-codec%5Cdist%5Cutils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.concatArgs = exports.seqEqual = void 0;
/**
 * Check whether two sequences (e.g. Arrays of numbers) are equal.
 *
 * @param arr1 - One of the arrays to compare.
 * @param arr2 - The other array to compare.
 */
function seqEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (let i = 0; i < arr1.length; i++) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}
exports.seqEqual = seqEqual;
/**
 * Check whether a value is a sequence (e.g. Array of numbers).
 *
 * @param val - The value to check.
 */
function isSequence(val) {
    return val.length !== undefined;
}
/**
 * Concatenate all `arguments` into a single array. Each argument can be either
 * a single element or a sequence, which has a `length` property and supports
 * element retrieval via sequence[ix].
 *
 * > concatArgs(1, [2, 3], Buffer.from([4,5]), new Uint8Array([6, 7]));
 * [1,2,3,4,5,6,7]
 *
 * @returns Array of concatenated arguments
 */
function concatArgs(...args) {
    const ret = [];
    args.forEach((arg) => {
        if (isSequence(arg)) {
            for (const j of arg) {
                ret.push(j);
            }
        }
        else {
            ret.push(arg);
        }
    });
    return ret;
}
exports.concatArgs = concatArgs;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-address-codec",file:"node_modules\\ripple-address-codec\\dist\\utils.js",}],
["F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\xrp-codec.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\utils.js","base-x":"F:\\metamask-extension\\node_modules\\base-x\\src\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","create-hash":"F:\\metamask-extension\\node_modules\\create-hash\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-address-codec%5Cdist%5Cxrp-codec.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
/**
 * Codec class
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidClassicAddress = exports.decodeAccountPublic = exports.encodeAccountPublic = exports.encodeNodePublic = exports.decodeNodePublic = exports.decodeAddress = exports.decodeAccountID = exports.encodeAddress = exports.encodeAccountID = exports.decodeSeed = exports.encodeSeed = exports.codec = void 0;
const baseCodec = require("base-x");
const createHash = require("create-hash");
const utils_1 = require("./utils");
class Codec {
    constructor(options) {
        this.sha256 = options.sha256;
        this.alphabet = options.alphabet;
        this.codec = baseCodec(this.alphabet);
        this.base = this.alphabet.length;
    }
    /**
     * Encoder.
     *
     * @param bytes - Buffer of data to encode.
     * @param opts - Options object including the version bytes and the expected length of the data to encode.
     */
    encode(bytes, opts) {
        const versions = opts.versions;
        return this.encodeVersioned(bytes, versions, opts.expectedLength);
    }
    encodeVersioned(bytes, versions, expectedLength) {
        if (expectedLength && bytes.length !== expectedLength) {
            throw new Error('unexpected_payload_length: bytes.length does not match expectedLength.' +
                ' Ensure that the bytes are a Buffer.');
        }
        return this.encodeChecked(Buffer.from((0, utils_1.concatArgs)(versions, bytes)));
    }
    encodeChecked(buffer) {
        const check = this.sha256(this.sha256(buffer)).slice(0, 4);
        return this.encodeRaw(Buffer.from((0, utils_1.concatArgs)(buffer, check)));
    }
    encodeRaw(bytes) {
        return this.codec.encode(bytes);
    }
    /**
     * Decoder.
     *
     * @param base58string - Base58Check-encoded string to decode.
     * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.
     */
    /* eslint-disable max-lines-per-function --
     * TODO refactor */
    decode(base58string, opts) {
        const versions = opts.versions;
        const types = opts.versionTypes;
        const withoutSum = this.decodeChecked(base58string);
        if (versions.length > 1 && !opts.expectedLength) {
            throw new Error('expectedLength is required because there are >= 2 possible versions');
        }
        const versionLengthGuess = typeof versions[0] === 'number' ? 1 : versions[0].length;
        const payloadLength = opts.expectedLength || withoutSum.length - versionLengthGuess;
        const versionBytes = withoutSum.slice(0, -payloadLength);
        const payload = withoutSum.slice(-payloadLength);
        for (let i = 0; i < versions.length; i++) {
            const version = Array.isArray(versions[i])
                ? versions[i]
                : [versions[i]];
            if ((0, utils_1.seqEqual)(versionBytes, version)) {
                return {
                    version,
                    bytes: payload,
                    type: types ? types[i] : null,
                };
            }
        }
        throw new Error('version_invalid: version bytes do not match any of the provided version(s)');
    }
    /* eslint-enable max-lines-per-function */
    decodeChecked(base58string) {
        const buffer = this.decodeRaw(base58string);
        if (buffer.length < 5) {
            throw new Error('invalid_input_size: decoded data must have length >= 5');
        }
        if (!this.verifyCheckSum(buffer)) {
            throw new Error('checksum_invalid');
        }
        return buffer.slice(0, -4);
    }
    decodeRaw(base58string) {
        return this.codec.decode(base58string);
    }
    verifyCheckSum(bytes) {
        const computed = this.sha256(this.sha256(bytes.slice(0, -4))).slice(0, 4);
        const checksum = bytes.slice(-4);
        return (0, utils_1.seqEqual)(computed, checksum);
    }
}
/**
 * XRP codec
 */
// base58 encodings: https://xrpl.org/base58-encodings.html
// Account address (20 bytes)
const ACCOUNT_ID = 0;
// Account public key (33 bytes)
const ACCOUNT_PUBLIC_KEY = 0x23;
// 33; Seed value (for secret keys) (16 bytes)
const FAMILY_SEED = 0x21;
// 28; Validation public key (33 bytes)
const NODE_PUBLIC = 0x1c;
// [1, 225, 75]
const ED25519_SEED = [0x01, 0xe1, 0x4b];
const codecOptions = {
    sha256(bytes) {
        return createHash('sha256').update(Buffer.from(bytes)).digest();
    },
    alphabet: 'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz',
};
const codecWithXrpAlphabet = new Codec(codecOptions);
exports.codec = codecWithXrpAlphabet;
// entropy is a Buffer of size 16
// type is 'ed25519' or 'secp256k1'
function encodeSeed(entropy, type) {
    if (entropy.length !== 16) {
        throw new Error('entropy must have length 16');
    }
    const opts = {
        expectedLength: 16,
        // for secp256k1, use `FAMILY_SEED`
        versions: type === 'ed25519' ? ED25519_SEED : [FAMILY_SEED],
    };
    // prefixes entropy with version bytes
    return codecWithXrpAlphabet.encode(entropy, opts);
}
exports.encodeSeed = encodeSeed;
function decodeSeed(seed, opts = {
    versionTypes: ['ed25519', 'secp256k1'],
    versions: [ED25519_SEED, FAMILY_SEED],
    expectedLength: 16,
}) {
    return codecWithXrpAlphabet.decode(seed, opts);
}
exports.decodeSeed = decodeSeed;
function encodeAccountID(bytes) {
    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
    return codecWithXrpAlphabet.encode(bytes, opts);
}
exports.encodeAccountID = encodeAccountID;
/* eslint-disable import/no-unused-modules ---
 * unclear why this is aliased but we should keep it in case someone else is
 * importing it with the aliased name */
exports.encodeAddress = encodeAccountID;
/* eslint-enable import/no-unused-modules */
function decodeAccountID(accountId) {
    const opts = { versions: [ACCOUNT_ID], expectedLength: 20 };
    return codecWithXrpAlphabet.decode(accountId, opts).bytes;
}
exports.decodeAccountID = decodeAccountID;
/* eslint-disable import/no-unused-modules ---
 * unclear why this is aliased but we should keep it in case someone else is
 * importing it with the aliased name */
exports.decodeAddress = decodeAccountID;
/* eslint-enable import/no-unused-modules */
function decodeNodePublic(base58string) {
    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
    return codecWithXrpAlphabet.decode(base58string, opts).bytes;
}
exports.decodeNodePublic = decodeNodePublic;
function encodeNodePublic(bytes) {
    const opts = { versions: [NODE_PUBLIC], expectedLength: 33 };
    return codecWithXrpAlphabet.encode(bytes, opts);
}
exports.encodeNodePublic = encodeNodePublic;
function encodeAccountPublic(bytes) {
    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
    return codecWithXrpAlphabet.encode(bytes, opts);
}
exports.encodeAccountPublic = encodeAccountPublic;
function decodeAccountPublic(base58string) {
    const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 };
    return codecWithXrpAlphabet.decode(base58string, opts).bytes;
}
exports.decodeAccountPublic = decodeAccountPublic;
function isValidClassicAddress(address) {
    try {
        decodeAccountID(address);
    }
    catch (_error) {
        return false;
    }
    return true;
}
exports.isValidClassicAddress = isValidClassicAddress;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-address-codec",file:"node_modules\\ripple-address-codec\\dist\\xrp-codec.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\binary.js", {"./hash-prefixes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hash-prefixes.js","./hashes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hashes.js","./serdes/binary-parser":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-parser.js","./serdes/binary-serializer":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-serializer.js","./types":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\index.js","big-integer":"F:\\metamask-extension\\node_modules\\big-integer\\BigInteger.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Cbinary.js
      return function (require, module, exports) {
"use strict";
/* eslint-disable func-style */
Object.defineProperty(exports, "__esModule", { value: true });
exports.transactionID = exports.sha512Half = exports.binaryToJSON = exports.signingClaimData = exports.signingData = exports.multiSigningData = exports.readJSON = exports.serializeObject = exports.makeParser = exports.BytesList = exports.BinarySerializer = exports.BinaryParser = void 0;
var types_1 = require("./types");
var binary_parser_1 = require("./serdes/binary-parser");
Object.defineProperty(exports, "BinaryParser", { enumerable: true, get: function () { return binary_parser_1.BinaryParser; } });
var hash_prefixes_1 = require("./hash-prefixes");
var binary_serializer_1 = require("./serdes/binary-serializer");
Object.defineProperty(exports, "BinarySerializer", { enumerable: true, get: function () { return binary_serializer_1.BinarySerializer; } });
Object.defineProperty(exports, "BytesList", { enumerable: true, get: function () { return binary_serializer_1.BytesList; } });
var hashes_1 = require("./hashes");
Object.defineProperty(exports, "sha512Half", { enumerable: true, get: function () { return hashes_1.sha512Half; } });
Object.defineProperty(exports, "transactionID", { enumerable: true, get: function () { return hashes_1.transactionID; } });
var bigInt = require("big-integer");
/**
 * Construct a BinaryParser
 *
 * @param bytes hex-string to construct BinaryParser from
 * @returns A BinaryParser
 */
var makeParser = function (bytes) { return new binary_parser_1.BinaryParser(bytes); };
exports.makeParser = makeParser;
/**
 * Parse BinaryParser into JSON
 *
 * @param parser BinaryParser object
 * @returns JSON for the bytes in the BinaryParser
 */
var readJSON = function (parser) {
    return parser.readType(types_1.coreTypes.STObject).toJSON();
};
exports.readJSON = readJSON;
/**
 * Parse a hex-string into its JSON interpretation
 *
 * @param bytes hex-string to parse into JSON
 * @returns JSON
 */
var binaryToJSON = function (bytes) { return readJSON(makeParser(bytes)); };
exports.binaryToJSON = binaryToJSON;
/**
 * Function to serialize JSON object representing a transaction
 *
 * @param object JSON object to serialize
 * @param opts options for serializing, including optional prefix, suffix, and signingFieldOnly
 * @returns A Buffer containing the serialized object
 */
function serializeObject(object, opts) {
    if (opts === void 0) { opts = {}; }
    var prefix = opts.prefix, suffix = opts.suffix, _a = opts.signingFieldsOnly, signingFieldsOnly = _a === void 0 ? false : _a;
    var bytesList = new binary_serializer_1.BytesList();
    if (prefix) {
        bytesList.put(prefix);
    }
    var filter = signingFieldsOnly
        ? function (f) { return f.isSigningField; }
        : undefined;
    types_1.coreTypes.STObject.from(object, filter).toBytesSink(bytesList);
    if (suffix) {
        bytesList.put(suffix);
    }
    return bytesList.toBytes();
}
exports.serializeObject = serializeObject;
/**
 * Serialize an object for signing
 *
 * @param transaction Transaction to serialize
 * @param prefix Prefix bytes to put before the serialized object
 * @returns A Buffer with the serialized object
 */
function signingData(transaction, prefix) {
    if (prefix === void 0) { prefix = hash_prefixes_1.HashPrefix.transactionSig; }
    return serializeObject(transaction, { prefix: prefix, signingFieldsOnly: true });
}
exports.signingData = signingData;
/**
 * Serialize a signingClaim
 *
 * @param claim A claim object to serialize
 * @returns the serialized object with appropriate prefix
 */
function signingClaimData(claim) {
    var num = bigInt(String(claim.amount));
    var prefix = hash_prefixes_1.HashPrefix.paymentChannelClaim;
    var channel = types_1.coreTypes.Hash256.from(claim.channel).toBytes();
    var amount = types_1.coreTypes.UInt64.from(num).toBytes();
    var bytesList = new binary_serializer_1.BytesList();
    bytesList.put(prefix);
    bytesList.put(channel);
    bytesList.put(amount);
    return bytesList.toBytes();
}
exports.signingClaimData = signingClaimData;
/**
 * Serialize a transaction object for multiSigning
 *
 * @param transaction transaction to serialize
 * @param signingAccount Account to sign the transaction with
 * @returns serialized transaction with appropriate prefix and suffix
 */
function multiSigningData(transaction, signingAccount) {
    var prefix = hash_prefixes_1.HashPrefix.transactionMultiSig;
    var suffix = types_1.coreTypes.AccountID.from(signingAccount).toBytes();
    return serializeObject(transaction, {
        prefix: prefix,
        suffix: suffix,
        signingFieldsOnly: true,
    });
}
exports.multiSigningData = multiSigningData;
//# sourceMappingURL=binary.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\binary.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\coretypes.js", {"./binary":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\binary.js","./enums":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\enums\\index.js","./hash-prefixes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hash-prefixes.js","./hashes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hashes.js","./ledger-hashes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\ledger-hashes.js","./quality":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\quality.js","./shamap":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\shamap.js","./types":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ccoretypes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.types = exports.ShaMap = exports.HashPrefix = exports.quality = exports.TransactionResult = exports.Type = exports.LedgerEntryType = exports.TransactionType = exports.Field = exports.ledgerHashes = exports.binary = exports.hashes = void 0;
var enums_1 = require("./enums");
Object.defineProperty(exports, "Field", { enumerable: true, get: function () { return enums_1.Field; } });
Object.defineProperty(exports, "TransactionType", { enumerable: true, get: function () { return enums_1.TransactionType; } });
Object.defineProperty(exports, "LedgerEntryType", { enumerable: true, get: function () { return enums_1.LedgerEntryType; } });
Object.defineProperty(exports, "Type", { enumerable: true, get: function () { return enums_1.Type; } });
Object.defineProperty(exports, "TransactionResult", { enumerable: true, get: function () { return enums_1.TransactionResult; } });
var types = require("./types");
exports.types = types;
var binary = require("./binary");
exports.binary = binary;
var shamap_1 = require("./shamap");
Object.defineProperty(exports, "ShaMap", { enumerable: true, get: function () { return shamap_1.ShaMap; } });
var ledgerHashes = require("./ledger-hashes");
exports.ledgerHashes = ledgerHashes;
var hashes = require("./hashes");
exports.hashes = hashes;
var quality_1 = require("./quality");
Object.defineProperty(exports, "quality", { enumerable: true, get: function () { return quality_1.quality; } });
var hash_prefixes_1 = require("./hash-prefixes");
Object.defineProperty(exports, "HashPrefix", { enumerable: true, get: function () { return hash_prefixes_1.HashPrefix; } });
//# sourceMappingURL=coretypes.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\coretypes.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\enums\\definitions.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Cenums%5Cdefinitions.json
      return function (require, module, exports) {
module.exports={
  "TYPES": {
    "Validation": 10003,
    "Done": -1,
    "Hash128": 4,
    "Blob": 7,
    "AccountID": 8,
    "Amount": 6,
    "Hash256": 5,
    "UInt8": 16,
    "Vector256": 19,
    "STObject": 14,
    "Unknown": -2,
    "Transaction": 10001,
    "Hash160": 17,
    "PathSet": 18,
    "LedgerEntry": 10002,
    "UInt16": 1,
    "NotPresent": 0,
    "UInt64": 3,
    "UInt32": 2,
    "STArray": 15
  },
  "LEDGER_ENTRY_TYPES": {
    "Any": -3,
    "Child": -2,
    "Invalid": -1,
    "AccountRoot": 97,
    "DirectoryNode": 100,
    "RippleState": 114,
    "Ticket": 84,
    "SignerList": 83,
    "Offer": 111,
    "LedgerHashes": 104,
    "Amendments": 102,
    "FeeSettings": 115,
    "Escrow": 117,
    "PayChannel": 120,
    "DepositPreauth": 112,
    "Check": 67,
    "Nickname": 110,
    "Contract": 99,
    "NFTokenPage": 80,
    "NFTokenOffer": 55,
    "NegativeUNL": 78
  },
  "FIELDS": [
    [
      "Generic",
      {
        "nth": 0,
        "isVLEncoded": false,
        "isSerialized": false,
        "isSigningField": false,
        "type": "Unknown"
      }
    ],
    [
      "Invalid",
      {
        "nth": -1,
        "isVLEncoded": false,
        "isSerialized": false,
        "isSigningField": false,
        "type": "Unknown"
      }
    ],
    [
      "LedgerEntryType",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt16"
      }
    ],
    [
      "TransactionType",
      {
        "nth": 2,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt16"
      }
    ],
    [
      "SignerWeight",
      {
        "nth": 3,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt16"
      }
    ],
    [
      "TransferFee",
      {
        "nth": 4,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt16"
      }
    ],
    [
      "Flags",
      {
        "nth": 2,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "SourceTag",
      {
        "nth": 3,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "Sequence",
      {
        "nth": 4,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "PreviousTxnLgrSeq",
      {
        "nth": 5,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "LedgerSequence",
      {
        "nth": 6,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "CloseTime",
      {
        "nth": 7,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "ParentCloseTime",
      {
        "nth": 8,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "SigningTime",
      {
        "nth": 9,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "Expiration",
      {
        "nth": 10,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "TransferRate",
      {
        "nth": 11,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "WalletSize",
      {
        "nth": 12,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "OwnerCount",
      {
        "nth": 13,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "DestinationTag",
      {
        "nth": 14,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "HighQualityIn",
      {
        "nth": 16,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "HighQualityOut",
      {
        "nth": 17,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "LowQualityIn",
      {
        "nth": 18,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "LowQualityOut",
      {
        "nth": 19,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "QualityIn",
      {
        "nth": 20,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "QualityOut",
      {
        "nth": 21,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "StampEscrow",
      {
        "nth": 22,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "BondAmount",
      {
        "nth": 23,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "LoadFee",
      {
        "nth": 24,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "OfferSequence",
      {
        "nth": 25,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "FirstLedgerSequence",
      {
        "nth": 26,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "LastLedgerSequence",
      {
        "nth": 27,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "TransactionIndex",
      {
        "nth": 28,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "OperationLimit",
      {
        "nth": 29,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "ReferenceFeeUnits",
      {
        "nth": 30,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "ReserveBase",
      {
        "nth": 31,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "ReserveIncrement",
      {
        "nth": 32,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "SetFlag",
      {
        "nth": 33,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "ClearFlag",
      {
        "nth": 34,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "SignerQuorum",
      {
        "nth": 35,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "CancelAfter",
      {
        "nth": 36,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "FinishAfter",
      {
        "nth": 37,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "IndexNext",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "IndexPrevious",
      {
        "nth": 2,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "BookNode",
      {
        "nth": 3,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "OwnerNode",
      {
        "nth": 4,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "BaseFee",
      {
        "nth": 5,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "ExchangeRate",
      {
        "nth": 6,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "LowNode",
      {
        "nth": 7,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "HighNode",
      {
        "nth": 8,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "EmailHash",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash128"
      }
    ],
    [
      "LedgerHash",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "ParentHash",
      {
        "nth": 2,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "TransactionHash",
      {
        "nth": 3,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "AccountHash",
      {
        "nth": 4,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "PreviousTxnID",
      {
        "nth": 5,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "LedgerIndex",
      {
        "nth": 6,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "WalletLocator",
      {
        "nth": 7,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "RootIndex",
      {
        "nth": 8,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "AccountTxnID",
      {
        "nth": 9,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "TokenID",
      {
        "nth": 10,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "BookDirectory",
      {
        "nth": 16,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "InvoiceID",
      {
        "nth": 17,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "Nickname",
      {
        "nth": 18,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "Amendment",
      {
        "nth": 19,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "TicketID",
      {
        "nth": 20,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "Digest",
      {
        "nth": 21,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "hash",
      {
        "nth": 257,
        "isVLEncoded": false,
        "isSerialized": false,
        "isSigningField": false,
        "type": "Hash256"
      }
    ],
    [
      "index",
      {
        "nth": 258,
        "isVLEncoded": false,
        "isSerialized": false,
        "isSigningField": false,
        "type": "Hash256"
      }
    ],
    [
      "Amount",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "Balance",
      {
        "nth": 2,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "LimitAmount",
      {
        "nth": 3,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "TakerPays",
      {
        "nth": 4,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "TakerGets",
      {
        "nth": 5,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "LowLimit",
      {
        "nth": 6,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "HighLimit",
      {
        "nth": 7,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "Fee",
      {
        "nth": 8,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "SendMax",
      {
        "nth": 9,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "DeliverMin",
      {
        "nth": 10,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "MinimumOffer",
      {
        "nth": 16,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "RippleEscrow",
      {
        "nth": 17,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "DeliveredAmount",
      {
        "nth": 18,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "BrokerFee",
      {
        "nth": 19,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Amount"
      }
    ],
    [
      "taker_gets_funded",
      {
        "nth": 258,
        "isVLEncoded": false,
        "isSerialized": false,
        "isSigningField": false,
        "type": "Amount"
      }
    ],
    [
      "taker_pays_funded",
      {
        "nth": 259,
        "isVLEncoded": false,
        "isSerialized": false,
        "isSigningField": false,
        "type": "Amount"
      }
    ],
    [
      "PublicKey",
      {
        "nth": 1,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "MessageKey",
      {
        "nth": 2,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "SigningPubKey",
      {
        "nth": 3,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "TxnSignature",
      {
        "nth": 4,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": false,
        "type": "Blob"
      }
    ],
    [
      "URI",
      {
        "nth": 5,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "Signature",
      {
        "nth": 6,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": false,
        "type": "Blob"
      }
    ],
    [
      "Domain",
      {
        "nth": 7,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "FundCode",
      {
        "nth": 8,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "RemoveCode",
      {
        "nth": 9,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "ExpireCode",
      {
        "nth": 10,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "CreateCode",
      {
        "nth": 11,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "MemoType",
      {
        "nth": 12,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "MemoData",
      {
        "nth": 13,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "MemoFormat",
      {
        "nth": 14,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "Fulfillment",
      {
        "nth": 16,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "Condition",
      {
        "nth": 17,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "MasterSignature",
      {
        "nth": 18,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": false,
        "type": "Blob"
      }
    ],
    [
      "UNLModifyValidator",
      {
        "nth": 19,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "ValidatorToDisable",
      {
        "nth": 20,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "ValidatorToReEnable",
      {
        "nth": 21,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Blob"
      }
    ],
    [
      "Account",
      {
        "nth": 1,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "AccountID"
      }
    ],
    [
      "Owner",
      {
        "nth": 2,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "AccountID"
      }
    ],
    [
      "Destination",
      {
        "nth": 3,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "AccountID"
      }
    ],
    [
      "Issuer",
      {
        "nth": 4,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "AccountID"
      }
    ],
    [
      "Authorize",
      {
        "nth": 5,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "AccountID"
      }
    ],
    [
      "Unauthorize",
      {
        "nth": 6,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "AccountID"
      }
    ],
    [
      "Target",
      {
        "nth": 7,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "AccountID"
      }
    ],
    [
      "RegularKey",
      {
        "nth": 8,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "AccountID"
      }
    ],
    [
      "Minter",
      {
        "nth": 9,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "AccountID"
      }
    ],
    [
      "ObjectEndMarker",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "TransactionMetaData",
      {
        "nth": 2,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "CreatedNode",
      {
        "nth": 3,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "DeletedNode",
      {
        "nth": 4,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "ModifiedNode",
      {
        "nth": 5,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "PreviousFields",
      {
        "nth": 6,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "FinalFields",
      {
        "nth": 7,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "NewFields",
      {
        "nth": 8,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "TemplateEntry",
      {
        "nth": 9,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "Memo",
      {
        "nth": 10,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "SignerEntry",
      {
        "nth": 11,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "NonFungibleToken",
      {
        "nth": 12,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "Signer",
      {
        "nth": 16,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "Majority",
      {
        "nth": 18,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "DisabledValidator",
      {
        "nth": 19,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STObject"
      }
    ],
    [
      "ArrayEndMarker",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STArray"
      }
    ],
    [
      "Signers",
      {
        "nth": 3,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": false,
        "type": "STArray"
      }
    ],
    [
      "SignerEntries",
      {
        "nth": 4,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STArray"
      }
    ],
    [
      "Template",
      {
        "nth": 5,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STArray"
      }
    ],
    [
      "Necessary",
      {
        "nth": 6,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STArray"
      }
    ],
    [
      "Sufficient",
      {
        "nth": 7,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STArray"
      }
    ],
    [
      "AffectedNodes",
      {
        "nth": 8,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STArray"
      }
    ],
    [
      "Memos",
      {
        "nth": 9,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STArray"
      }
    ],
    [
      "NonFungibleTokens",
      {
        "nth": 10,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STArray"
      }
    ],
    [
      "Majorities",
      {
        "nth": 16,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STArray"
      }
    ],
    [
      "DisabledValidators",
      {
        "nth": 17,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "STArray"
      }
    ],
    [
      "CloseResolution",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt8"
      }
    ],
    [
      "Method",
      {
        "nth": 2,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt8"
      }
    ],
    [
      "TransactionResult",
      {
        "nth": 3,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt8"
      }
    ],
    [
      "TakerPaysCurrency",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash160"
      }
    ],
    [
      "TakerPaysIssuer",
      {
        "nth": 2,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash160"
      }
    ],
    [
      "TakerGetsCurrency",
      {
        "nth": 3,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash160"
      }
    ],
    [
      "TakerGetsIssuer",
      {
        "nth": 4,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash160"
      }
    ],
    [
      "Paths",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "PathSet"
      }
    ],
    [
      "Indexes",
      {
        "nth": 1,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Vector256"
      }
    ],
    [
      "Hashes",
      {
        "nth": 2,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Vector256"
      }
    ],
    [
      "Amendments",
      {
        "nth": 3,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Vector256"
      }
    ],
    [
      "TokenOffers",
      {
        "nth": 4,
        "isVLEncoded": true,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Vector256"
      }
    ],
    [
      "Transaction",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": false,
        "isSigningField": false,
        "type": "Transaction"
      }
    ],
    [
      "LedgerEntry",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": false,
        "isSigningField": false,
        "type": "LedgerEntry"
      }
    ],
    [
      "Validation",
      {
        "nth": 1,
        "isVLEncoded": false,
        "isSerialized": false,
        "isSigningField": false,
        "type": "Validation"
      }
    ],
    [
      "SignerListID",
      {
        "nth": 38,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "SettleDelay",
      {
        "nth": 39,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "TicketCount",
      {
        "nth": 40,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "TicketSequence",
      {
        "nth": 41,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "TokenTaxon",
      {
        "nth": 42,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "MintedTokens",
      {
        "nth": 43,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "BurnedTokens",
      {
        "nth": 44,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt32"
      }
    ],
    [
      "Channel",
      {
        "nth": 22,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "ConsensusHash",
      {
        "nth": 23,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "CheckID",
      {
        "nth": 24,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "ValidatedHash",
      {
        "nth": 25,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "PreviousPageMin",
      {
        "nth": 26,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "NextPageMin",
      {
        "nth": 27,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "BuyOffer",
      {
        "nth": 28,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "SellOffer",
      {
        "nth": 29,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "Hash256"
      }
    ],
    [
      "TickSize",
      {
        "nth": 16,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt8"
      }
    ],
    [
      "UNLModifyDisabling",
      {
        "nth": 17,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt8"
      }
    ],
    [
      "DestinationNode",
      {
        "nth": 9,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "Cookie",
      {
        "nth": 10,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "ServerVersion",
      {
        "nth": 11,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ],
    [
      "OfferNode",
      {
        "nth": 12,
        "isVLEncoded": false,
        "isSerialized": true,
        "isSigningField": true,
        "type": "UInt64"
      }
    ]
  ],
  "TRANSACTION_RESULTS": {
    "telLOCAL_ERROR": -399,
    "telBAD_DOMAIN": -398,
    "telBAD_PATH_COUNT": -397,
    "telBAD_PUBLIC_KEY": -396,
    "telFAILED_PROCESSING": -395,
    "telINSUF_FEE_P": -394,
    "telNO_DST_PARTIAL": -393,
    "telCAN_NOT_QUEUE": -392,
    "telCAN_NOT_QUEUE_BALANCE": -391,
    "telCAN_NOT_QUEUE_BLOCKS": -390,
    "telCAN_NOT_QUEUE_BLOCKED": -389,
    "telCAN_NOT_QUEUE_FEE": -388,
    "telCAN_NOT_QUEUE_FULL": -387,

    "temMALFORMED": -299,
    "temBAD_AMOUNT": -298,
    "temBAD_CURRENCY": -297,
    "temBAD_EXPIRATION": -296,
    "temBAD_FEE": -295,
    "temBAD_ISSUER": -294,
    "temBAD_LIMIT": -293,
    "temBAD_OFFER": -292,
    "temBAD_PATH": -291,
    "temBAD_PATH_LOOP": -290,
    "temBAD_REGKEY": -289,
    "temBAD_SEND_XRP_LIMIT": -288,
    "temBAD_SEND_XRP_MAX": -287,
    "temBAD_SEND_XRP_NO_DIRECT": -286,
    "temBAD_SEND_XRP_PARTIAL": -285,
    "temBAD_SEND_XRP_PATHS": -284,
    "temBAD_SEQUENCE": -283,
    "temBAD_SIGNATURE": -282,
    "temBAD_SRC_ACCOUNT": -281,
    "temBAD_TRANSFER_RATE": -280,
    "temDST_IS_SRC": -279,
    "temDST_NEEDED": -278,
    "temINVALID": -277,
    "temINVALID_FLAG": -276,
    "temREDUNDANT": -275,
    "temRIPPLE_EMPTY": -274,
    "temDISABLED": -273,
    "temBAD_SIGNER": -272,
    "temBAD_QUORUM": -271,
    "temBAD_WEIGHT": -270,
    "temBAD_TICK_SIZE": -269,
    "temINVALID_ACCOUNT_ID": -268,
    "temCANNOT_PREAUTH_SELF": -267,
    "temUNCERTAIN": -266,
    "temUNKNOWN": -265,

    "tefFAILURE": -199,
    "tefALREADY": -198,
    "tefBAD_ADD_AUTH": -197,
    "tefBAD_AUTH": -196,
    "tefBAD_LEDGER": -195,
    "tefCREATED": -194,
    "tefEXCEPTION": -193,
    "tefINTERNAL": -192,
    "tefNO_AUTH_REQUIRED": -191,
    "tefPAST_SEQ": -190,
    "tefWRONG_PRIOR": -189,
    "tefMASTER_DISABLED": -188,
    "tefMAX_LEDGER": -187,
    "tefBAD_SIGNATURE": -186,
    "tefBAD_QUORUM": -185,
    "tefNOT_MULTI_SIGNING": -184,
    "tefBAD_AUTH_MASTER": -183,
    "tefINVARIANT_FAILED": -182,
    "tefTOO_BIG": -181,
    "tefNO_TICKET": -180,
    "tefTOKEN_IS_NOT_TRANSFERABLE": -179,

    "terRETRY": -99,
    "terFUNDS_SPENT": -98,
    "terINSUF_FEE_B": -97,
    "terNO_ACCOUNT": -96,
    "terNO_AUTH": -95,
    "terNO_LINE": -94,
    "terOWNERS": -93,
    "terPRE_SEQ": -92,
    "terLAST": -91,
    "terNO_RIPPLE": -90,
    "terQUEUED": -89,

    "tesSUCCESS": 0,

    "tecCLAIM": 100,
    "tecPATH_PARTIAL": 101,
    "tecUNFUNDED_ADD": 102,
    "tecUNFUNDED_OFFER": 103,
    "tecUNFUNDED_PAYMENT": 104,
    "tecFAILED_PROCESSING": 105,
    "tecDIR_FULL": 121,
    "tecINSUF_RESERVE_LINE": 122,
    "tecINSUF_RESERVE_OFFER": 123,
    "tecNO_DST": 124,
    "tecNO_DST_INSUF_XRP": 125,
    "tecNO_LINE_INSUF_RESERVE": 126,
    "tecNO_LINE_REDUNDANT": 127,
    "tecPATH_DRY": 128,
    "tecUNFUNDED": 129,
    "tecNO_ALTERNATIVE_KEY": 130,
    "tecNO_REGULAR_KEY": 131,
    "tecOWNERS": 132,
    "tecNO_ISSUER": 133,
    "tecNO_AUTH": 134,
    "tecNO_LINE": 135,
    "tecINSUFF_FEE": 136,
    "tecFROZEN": 137,
    "tecNO_TARGET": 138,
    "tecNO_PERMISSION": 139,
    "tecNO_ENTRY": 140,
    "tecINSUFFICIENT_RESERVE": 141,
    "tecNEED_MASTER_KEY": 142,
    "tecDST_TAG_NEEDED": 143,
    "tecINTERNAL": 144,
    "tecOVERSIZE": 145,
    "tecCRYPTOCONDITION_ERROR": 146,
    "tecINVARIANT_FAILED": 147,
    "tecEXPIRED": 148,
    "tecDUPLICATE": 149,
    "tecKILLED": 150,
    "tecHAS_OBLIGATIONS": 151,
    "tecTOO_SOON": 152,

    "tecMAX_SEQUENCE_REACHED": 154,
    "tecNO_SUITABLE_PAGE": 155,
    "tecBUY_SELL_MISMATCH": 156,
    "tecOFFER_TYPE_MISMATCH": 157,
    "tecCANT_ACCEPT_OWN_OFFER": 158,
    "tecINSUFFICIENT_FUNDS": 159,
    "tecOBJECT_NOT_FOUND": 160,
    "tecINSUFFICIENT_PAYMENT": 161,
    "tecINCORRECT_ASSET": 162,
    "tecTOO_MANY": 163
  },
  "TRANSACTION_TYPES": {
    "Invalid": -1,

    "Payment": 0,
    "EscrowCreate": 1,
    "EscrowFinish": 2,
    "AccountSet": 3,
    "EscrowCancel": 4,
    "SetRegularKey": 5,
    "NickNameSet": 6,
    "OfferCreate": 7,
    "OfferCancel": 8,
    "Contract": 9,
    "TicketCreate": 10,
    "TicketCancel": 11,
    "SignerListSet": 12,
    "PaymentChannelCreate": 13,
    "PaymentChannelFund": 14,
    "PaymentChannelClaim": 15,
    "CheckCreate": 16,
    "CheckCash": 17,
    "CheckCancel": 18,
    "DepositPreauth": 19,
    "TrustSet": 20,
    "AccountDelete": 21,
    "NFTokenMint": 25,
    "NFTokenBurn": 26,
    "NFTokenCreateOffer": 27,
    "NFTokenCancelOffer": 28,
    "NFTokenAcceptOffer": 29,
    "EnableAmendment": 100,
    "SetFee": 101,
    "UNLModify": 102
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\enums\\definitions.json",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\enums\\index.js", {"../types/serialized-type":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js","./definitions.json":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\enums\\definitions.json","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Cenums%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionType = exports.TransactionResult = exports.LedgerEntryType = exports.Type = exports.Field = exports.Bytes = exports.TRANSACTION_TYPES = void 0;
var enums = require("./definitions.json");
var serialized_type_1 = require("../types/serialized-type");
var buffer_1 = require("buffer/");
/*
 * @brief: All valid transaction types
 */
exports.TRANSACTION_TYPES = Object.entries(enums.TRANSACTION_TYPES)
    .filter(function (_a) {
    var _key = _a[0], value = _a[1];
    return value >= 0;
})
    .map(function (_a) {
    var key = _a[0], _value = _a[1];
    return key;
});
var TYPE_WIDTH = 2;
var LEDGER_ENTRY_WIDTH = 2;
var TRANSACTION_TYPE_WIDTH = 2;
var TRANSACTION_RESULT_WIDTH = 1;
/*
 * @brief: Serialize a field based on type_code and Field.nth
 */
function fieldHeader(type, nth) {
    var header = [];
    if (type < 16) {
        if (nth < 16) {
            header.push((type << 4) | nth);
        }
        else {
            header.push(type << 4, nth);
        }
    }
    else if (nth < 16) {
        header.push(nth, type);
    }
    else {
        header.push(0, type, nth);
    }
    return buffer_1.Buffer.from(header);
}
/*
 * @brief: Bytes, name, and ordinal representing one type, ledger_type, transaction type, or result
 */
var Bytes = /** @class */ (function () {
    function Bytes(name, ordinal, ordinalWidth) {
        this.name = name;
        this.ordinal = ordinal;
        this.ordinalWidth = ordinalWidth;
        this.bytes = buffer_1.Buffer.alloc(ordinalWidth);
        for (var i = 0; i < ordinalWidth; i++) {
            this.bytes[ordinalWidth - i - 1] = (ordinal >>> (i * 8)) & 0xff;
        }
    }
    Bytes.prototype.toJSON = function () {
        return this.name;
    };
    Bytes.prototype.toBytesSink = function (sink) {
        sink.put(this.bytes);
    };
    Bytes.prototype.toBytes = function () {
        return this.bytes;
    };
    return Bytes;
}());
exports.Bytes = Bytes;
/*
 * @brief: Collection of Bytes objects, mapping bidirectionally
 */
var BytesLookup = /** @class */ (function () {
    function BytesLookup(types, ordinalWidth) {
        var _this = this;
        this.ordinalWidth = ordinalWidth;
        Object.entries(types).forEach(function (_a) {
            var k = _a[0], v = _a[1];
            _this[k] = new Bytes(k, v, ordinalWidth);
            _this[v.toString()] = _this[k];
        });
    }
    BytesLookup.prototype.from = function (value) {
        return value instanceof Bytes ? value : this[value];
    };
    BytesLookup.prototype.fromParser = function (parser) {
        return this.from(parser.readUIntN(this.ordinalWidth).toString());
    };
    return BytesLookup;
}());
function buildField(_a) {
    var name = _a[0], info = _a[1];
    var typeOrdinal = enums.TYPES[info.type];
    var field = fieldHeader(typeOrdinal, info.nth);
    return {
        name: name,
        nth: info.nth,
        isVariableLengthEncoded: info.isVLEncoded,
        isSerialized: info.isSerialized,
        isSigningField: info.isSigningField,
        ordinal: (typeOrdinal << 16) | info.nth,
        type: new Bytes(info.type, typeOrdinal, TYPE_WIDTH),
        header: field,
        associatedType: serialized_type_1.SerializedType, // For later assignment in ./types/index.js
    };
}
/*
 * @brief: The collection of all fields as defined in definitions.json
 */
var FieldLookup = /** @class */ (function () {
    function FieldLookup(fields) {
        var _this = this;
        fields.forEach(function (_a) {
            var k = _a[0], v = _a[1];
            _this[k] = buildField([k, v]);
            _this[_this[k].ordinal.toString()] = _this[k];
        });
    }
    FieldLookup.prototype.fromString = function (value) {
        return this[value];
    };
    return FieldLookup;
}());
var Type = new BytesLookup(enums.TYPES, TYPE_WIDTH);
exports.Type = Type;
var LedgerEntryType = new BytesLookup(enums.LEDGER_ENTRY_TYPES, LEDGER_ENTRY_WIDTH);
exports.LedgerEntryType = LedgerEntryType;
var TransactionType = new BytesLookup(enums.TRANSACTION_TYPES, TRANSACTION_TYPE_WIDTH);
exports.TransactionType = TransactionType;
var TransactionResult = new BytesLookup(enums.TRANSACTION_RESULTS, TRANSACTION_RESULT_WIDTH);
exports.TransactionResult = TransactionResult;
var Field = new FieldLookup(enums.FIELDS);
exports.Field = Field;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\enums\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hash-prefixes.js", {"buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Chash-prefixes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashPrefix = void 0;
var buffer_1 = require("buffer/");
/**
 * Write a 32 bit integer to a Buffer
 *
 * @param uint32 32 bit integer to write to buffer
 * @returns a buffer with the bytes representation of uint32
 */
function bytes(uint32) {
    var result = buffer_1.Buffer.alloc(4);
    result.writeUInt32BE(uint32, 0);
    return result;
}
/**
 * Maps HashPrefix names to their byte representation
 */
var HashPrefix = {
    transactionID: bytes(0x54584e00),
    // transaction plus metadata
    transaction: bytes(0x534e4400),
    // account state
    accountStateEntry: bytes(0x4d4c4e00),
    // inner node in tree
    innerNode: bytes(0x4d494e00),
    // ledger master data for signing
    ledgerHeader: bytes(0x4c575200),
    // inner transaction to sign
    transactionSig: bytes(0x53545800),
    // inner transaction to sign
    transactionMultiSig: bytes(0x534d5400),
    // validation for signing
    validation: bytes(0x56414c00),
    // proposal for signing
    proposal: bytes(0x50525000),
    // payment channel claim
    paymentChannelClaim: bytes(0x434c4d00),
};
exports.HashPrefix = HashPrefix;
//# sourceMappingURL=hash-prefixes.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\hash-prefixes.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hashes.js", {"./hash-prefixes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hash-prefixes.js","./serdes/binary-serializer":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-serializer.js","./types/hash-256":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-256.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js","create-hash":"F:\\metamask-extension\\node_modules\\create-hash\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Chashes.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.transactionID = exports.sha512Half = exports.Sha512Half = void 0;
var hash_prefixes_1 = require("./hash-prefixes");
var createHash = require("create-hash");
var hash_256_1 = require("./types/hash-256");
var binary_serializer_1 = require("./serdes/binary-serializer");
var buffer_1 = require("buffer/");
/**
 * Class for hashing with SHA512
 * @extends BytesList So SerializedTypes can write bytes to a Sha512Half
 */
var Sha512Half = /** @class */ (function (_super) {
    __extends(Sha512Half, _super);
    function Sha512Half() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hash = createHash('sha512');
        return _this;
    }
    /**
     * Construct a new Sha512Hash and write bytes this.hash
     *
     * @param bytes bytes to write to this.hash
     * @returns the new Sha512Hash object
     */
    Sha512Half.put = function (bytes) {
        return new Sha512Half().put(bytes);
    };
    /**
     * Write bytes to an existing Sha512Hash
     *
     * @param bytes bytes to write to object
     * @returns the Sha512 object
     */
    Sha512Half.prototype.put = function (bytes) {
        this.hash.update(bytes);
        return this;
    };
    /**
     * Compute SHA512 hash and slice in half
     *
     * @returns half of a SHA512 hash
     */
    Sha512Half.prototype.finish256 = function () {
        return buffer_1.Buffer.from(this.hash.digest().slice(0, 32));
    };
    /**
     * Constructs a Hash256 from the Sha512Half object
     *
     * @returns a Hash256 object
     */
    Sha512Half.prototype.finish = function () {
        return new hash_256_1.Hash256(this.finish256());
    };
    return Sha512Half;
}(binary_serializer_1.BytesList));
exports.Sha512Half = Sha512Half;
/**
 * compute SHA512 hash of a list of bytes
 *
 * @param args zero or more arguments to hash
 * @returns the sha512half hash of the arguments.
 */
function sha512Half() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var hash = new Sha512Half();
    args.forEach(function (a) { return hash.put(a); });
    return hash.finish256();
}
exports.sha512Half = sha512Half;
/**
 * Construct a transactionID from a Serialized Transaction
 *
 * @param serialized bytes to hash
 * @returns a Hash256 object
 */
function transactionID(serialized) {
    return new hash_256_1.Hash256(sha512Half(hash_prefixes_1.HashPrefix.transactionID, serialized));
}
exports.transactionID = transactionID;
//# sourceMappingURL=hashes.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\hashes.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\index.js", {"./coretypes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\coretypes.js","./enums":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\enums\\index.js","./ledger-hashes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\ledger-hashes.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var assert = require("assert");
var coretypes_1 = require("./coretypes");
var ledger_hashes_1 = require("./ledger-hashes");
var enums_1 = require("./enums");
var signingData = coretypes_1.binary.signingData, signingClaimData = coretypes_1.binary.signingClaimData, multiSigningData = coretypes_1.binary.multiSigningData, binaryToJSON = coretypes_1.binary.binaryToJSON, serializeObject = coretypes_1.binary.serializeObject;
/**
 * Decode a transaction
 *
 * @param binary hex-string of the encoded transaction
 * @returns the JSON representation of the transaction
 */
function decode(binary) {
    assert.ok(typeof binary === 'string', 'binary must be a hex string');
    return binaryToJSON(binary);
}
/**
 * Encode a transaction
 *
 * @param json The JSON representation of a transaction
 * @returns A hex-string of the encoded transaction
 */
function encode(json) {
    assert.ok(typeof json === 'object');
    return serializeObject(json)
        .toString('hex')
        .toUpperCase();
}
/**
 * Encode a transaction and prepare for signing
 *
 * @param json JSON object representing the transaction
 * @param signer string representing the account to sign the transaction with
 * @returns a hex string of the encoded transaction
 */
function encodeForSigning(json) {
    assert.ok(typeof json === 'object');
    return signingData(json)
        .toString('hex')
        .toUpperCase();
}
/**
 * Encode a transaction and prepare for signing with a claim
 *
 * @param json JSON object representing the transaction
 * @param signer string representing the account to sign the transaction with
 * @returns a hex string of the encoded transaction
 */
function encodeForSigningClaim(json) {
    assert.ok(typeof json === 'object');
    return signingClaimData(json)
        .toString('hex')
        .toUpperCase();
}
/**
 * Encode a transaction and prepare for multi-signing
 *
 * @param json JSON object representing the transaction
 * @param signer string representing the account to sign the transaction with
 * @returns a hex string of the encoded transaction
 */
function encodeForMultisigning(json, signer) {
    assert.ok(typeof json === 'object');
    assert.equal(json['SigningPubKey'], '');
    return multiSigningData(json, signer)
        .toString('hex')
        .toUpperCase();
}
/**
 * Encode a quality value
 *
 * @param value string representation of a number
 * @returns a hex-string representing the quality
 */
function encodeQuality(value) {
    assert.ok(typeof value === 'string');
    return coretypes_1.quality.encode(value).toString('hex').toUpperCase();
}
/**
 * Decode a quality value
 *
 * @param value hex-string of a quality
 * @returns a string representing the quality
 */
function decodeQuality(value) {
    assert.ok(typeof value === 'string');
    return coretypes_1.quality.decode(value).toString();
}
module.exports = {
    decode: decode,
    encode: encode,
    encodeForSigning: encodeForSigning,
    encodeForSigningClaim: encodeForSigningClaim,
    encodeForMultisigning: encodeForMultisigning,
    encodeQuality: encodeQuality,
    decodeQuality: decodeQuality,
    decodeLedgerData: ledger_hashes_1.decodeLedgerData,
    TRANSACTION_TYPES: enums_1.TRANSACTION_TYPES,
};
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\ledger-hashes.js", {"./binary":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\binary.js","./hash-prefixes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hash-prefixes.js","./hashes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hashes.js","./serdes/binary-parser":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-parser.js","./shamap":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\shamap.js","./types/hash-256":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-256.js","./types/st-object":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\st-object.js","./types/uint-32":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-32.js","./types/uint-64":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-64.js","./types/uint-8":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-8.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","big-integer":"F:\\metamask-extension\\node_modules\\big-integer\\BigInteger.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Cledger-hashes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeLedgerData = exports.ledgerHash = exports.transactionTreeHash = exports.accountStateHash = void 0;
var assert = require("assert");
var shamap_1 = require("./shamap");
var hash_prefixes_1 = require("./hash-prefixes");
var hashes_1 = require("./hashes");
var binary_1 = require("./binary");
var hash_256_1 = require("./types/hash-256");
var st_object_1 = require("./types/st-object");
var uint_64_1 = require("./types/uint-64");
var uint_32_1 = require("./types/uint-32");
var uint_8_1 = require("./types/uint-8");
var binary_parser_1 = require("./serdes/binary-parser");
var bigInt = require("big-integer");
/**
 * Computes the hash of a list of objects
 *
 * @param itemizer Converts an item into a format that can be added to SHAMap
 * @param itemsJson Array of items to add to a SHAMap
 * @returns the hash of the SHAMap
 */
function computeHash(itemizer, itemsJson) {
    var map = new shamap_1.ShaMap();
    itemsJson.forEach(function (item) { return map.addItem.apply(map, itemizer(item)); });
    return map.hash();
}
/**
 * Convert a transaction into an index and an item
 *
 * @param json transaction with metadata
 * @returns a tuple of index and item to be added to SHAMap
 */
function transactionItemizer(json) {
    assert.ok(json.hash);
    var index = hash_256_1.Hash256.from(json.hash);
    var item = {
        hashPrefix: function () {
            return hash_prefixes_1.HashPrefix.transaction;
        },
        toBytesSink: function (sink) {
            var serializer = new binary_1.BinarySerializer(sink);
            serializer.writeLengthEncoded(st_object_1.STObject.from(json));
            serializer.writeLengthEncoded(st_object_1.STObject.from(json.metaData));
        },
    };
    return [index, item, undefined];
}
/**
 * Convert an entry to a pair Hash256 and ShaMapNode
 *
 * @param json JSON describing a ledger entry item
 * @returns a tuple of index and item to be added to SHAMap
 */
function entryItemizer(json) {
    var index = hash_256_1.Hash256.from(json.index);
    var bytes = (0, binary_1.serializeObject)(json);
    var item = {
        hashPrefix: function () {
            return hash_prefixes_1.HashPrefix.accountStateEntry;
        },
        toBytesSink: function (sink) {
            sink.put(bytes);
        },
    };
    return [index, item, undefined];
}
/**
 * Function computing the hash of a transaction tree
 *
 * @param param An array of transaction objects to hash
 * @returns A Hash256 object
 */
function transactionTreeHash(param) {
    var itemizer = transactionItemizer;
    return computeHash(itemizer, param);
}
exports.transactionTreeHash = transactionTreeHash;
/**
 * Function computing the hash of accountState
 *
 * @param param A list of accountStates hash
 * @returns A Hash256 object
 */
function accountStateHash(param) {
    var itemizer = entryItemizer;
    return computeHash(itemizer, param);
}
exports.accountStateHash = accountStateHash;
/**
 * Serialize and hash a ledger header
 *
 * @param header a ledger header
 * @returns the hash of header
 */
function ledgerHash(header) {
    var hash = new hashes_1.Sha512Half();
    hash.put(hash_prefixes_1.HashPrefix.ledgerHeader);
    assert.ok(header.parent_close_time !== undefined);
    assert.ok(header.close_flags !== undefined);
    uint_32_1.UInt32.from(header.ledger_index).toBytesSink(hash);
    uint_64_1.UInt64.from(bigInt(String(header.total_coins))).toBytesSink(hash);
    hash_256_1.Hash256.from(header.parent_hash).toBytesSink(hash);
    hash_256_1.Hash256.from(header.transaction_hash).toBytesSink(hash);
    hash_256_1.Hash256.from(header.account_hash).toBytesSink(hash);
    uint_32_1.UInt32.from(header.parent_close_time).toBytesSink(hash);
    uint_32_1.UInt32.from(header.close_time).toBytesSink(hash);
    uint_8_1.UInt8.from(header.close_time_resolution).toBytesSink(hash);
    uint_8_1.UInt8.from(header.close_flags).toBytesSink(hash);
    return hash.finish();
}
exports.ledgerHash = ledgerHash;
/**
 * Decodes a serialized ledger header
 *
 * @param binary A serialized ledger header
 * @returns A JSON object describing a ledger header
 */
function decodeLedgerData(binary) {
    assert.ok(typeof binary === 'string', 'binary must be a hex string');
    var parser = new binary_parser_1.BinaryParser(binary);
    return {
        ledger_index: parser.readUInt32(),
        total_coins: parser.readType(uint_64_1.UInt64).valueOf().toString(),
        parent_hash: parser.readType(hash_256_1.Hash256).toHex(),
        transaction_hash: parser.readType(hash_256_1.Hash256).toHex(),
        account_hash: parser.readType(hash_256_1.Hash256).toHex(),
        parent_close_time: parser.readUInt32(),
        close_time: parser.readUInt32(),
        close_time_resolution: parser.readUInt8(),
        close_flags: parser.readUInt8(),
    };
}
exports.decodeLedgerData = decodeLedgerData;
//# sourceMappingURL=ledger-hashes.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\ledger-hashes.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\quality.js", {"./types":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\index.js","big-integer":"F:\\metamask-extension\\node_modules\\big-integer\\BigInteger.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js","decimal.js":"F:\\metamask-extension\\node_modules\\decimal.js\\decimal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Cquality.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.quality = void 0;
var types_1 = require("./types");
var decimal_js_1 = require("decimal.js");
var bigInt = require("big-integer");
var buffer_1 = require("buffer/");
/**
 * class for encoding and decoding quality
 */
var quality = /** @class */ (function () {
    function quality() {
    }
    /**
     * Encode quality amount
     *
     * @param arg string representation of an amount
     * @returns Serialized quality
     */
    quality.encode = function (quality) {
        var decimal = new decimal_js_1.Decimal(quality);
        var exponent = decimal.e - 15;
        var qualityString = decimal.times("1e".concat(-exponent)).abs().toString();
        var bytes = types_1.coreTypes.UInt64.from(bigInt(qualityString)).toBytes();
        bytes[0] = exponent + 100;
        return bytes;
    };
    /**
     * Decode quality amount
     *
     * @param arg hex-string denoting serialized quality
     * @returns deserialized quality
     */
    quality.decode = function (quality) {
        var bytes = buffer_1.Buffer.from(quality, 'hex').slice(-8);
        var exponent = bytes[0] - 100;
        var mantissa = new decimal_js_1.Decimal("0x".concat(bytes.slice(1).toString('hex')));
        return mantissa.times("1e".concat(exponent));
    };
    return quality;
}());
exports.quality = quality;
//# sourceMappingURL=quality.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\quality.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-parser.js", {"../enums":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\enums\\index.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Cserdes%5Cbinary-parser.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinaryParser = void 0;
var assert = require("assert");
var enums_1 = require("../enums");
var buffer_1 = require("buffer/");
/**
 * BinaryParser is used to compute fields and values from a HexString
 */
var BinaryParser = /** @class */ (function () {
    /**
     * Initialize bytes to a hex string
     *
     * @param hexBytes a hex string
     */
    function BinaryParser(hexBytes) {
        this.bytes = buffer_1.Buffer.from(hexBytes, 'hex');
    }
    /**
     * Peek the first byte of the BinaryParser
     *
     * @returns The first byte of the BinaryParser
     */
    BinaryParser.prototype.peek = function () {
        assert.ok(this.bytes.byteLength !== 0);
        return this.bytes[0];
    };
    /**
     * Consume the first n bytes of the BinaryParser
     *
     * @param n the number of bytes to skip
     */
    BinaryParser.prototype.skip = function (n) {
        assert.ok(n <= this.bytes.byteLength);
        this.bytes = this.bytes.slice(n);
    };
    /**
     * read the first n bytes from the BinaryParser
     *
     * @param n The number of bytes to read
     * @return The bytes
     */
    BinaryParser.prototype.read = function (n) {
        assert.ok(n <= this.bytes.byteLength);
        var slice = this.bytes.slice(0, n);
        this.skip(n);
        return slice;
    };
    /**
     * Read an integer of given size
     *
     * @param n The number of bytes to read
     * @return The number represented by those bytes
     */
    BinaryParser.prototype.readUIntN = function (n) {
        assert.ok(0 < n && n <= 4, 'invalid n');
        return this.read(n).reduce(function (a, b) { return (a << 8) | b; }) >>> 0;
    };
    BinaryParser.prototype.readUInt8 = function () {
        return this.readUIntN(1);
    };
    BinaryParser.prototype.readUInt16 = function () {
        return this.readUIntN(2);
    };
    BinaryParser.prototype.readUInt32 = function () {
        return this.readUIntN(4);
    };
    BinaryParser.prototype.size = function () {
        return this.bytes.byteLength;
    };
    BinaryParser.prototype.end = function (customEnd) {
        var length = this.bytes.byteLength;
        return length === 0 || (customEnd !== undefined && length <= customEnd);
    };
    /**
     * Reads variable length encoded bytes
     *
     * @return The variable length bytes
     */
    BinaryParser.prototype.readVariableLength = function () {
        return this.read(this.readVariableLengthLength());
    };
    /**
     * Reads the length of the variable length encoded bytes
     *
     * @return The length of the variable length encoded bytes
     */
    BinaryParser.prototype.readVariableLengthLength = function () {
        var b1 = this.readUInt8();
        if (b1 <= 192) {
            return b1;
        }
        else if (b1 <= 240) {
            var b2 = this.readUInt8();
            return 193 + (b1 - 193) * 256 + b2;
        }
        else if (b1 <= 254) {
            var b2 = this.readUInt8();
            var b3 = this.readUInt8();
            return 12481 + (b1 - 241) * 65536 + b2 * 256 + b3;
        }
        throw new Error('Invalid variable length indicator');
    };
    /**
     * Reads the field ordinal from the BinaryParser
     *
     * @return Field ordinal
     */
    BinaryParser.prototype.readFieldOrdinal = function () {
        var type = this.readUInt8();
        var nth = type & 15;
        type >>= 4;
        if (type === 0) {
            type = this.readUInt8();
            if (type === 0 || type < 16) {
                throw new Error('Cannot read FieldOrdinal, type_code out of range');
            }
        }
        if (nth === 0) {
            nth = this.readUInt8();
            if (nth === 0 || nth < 16) {
                throw new Error('Cannot read FieldOrdinal, field_code out of range');
            }
        }
        return (type << 16) | nth;
    };
    /**
     * Read the field from the BinaryParser
     *
     * @return The field represented by the bytes at the head of the BinaryParser
     */
    BinaryParser.prototype.readField = function () {
        return enums_1.Field.fromString(this.readFieldOrdinal().toString());
    };
    /**
     * Read a given type from the BinaryParser
     *
     * @param type The type that you want to read from the BinaryParser
     * @return The instance of that type read from the BinaryParser
     */
    BinaryParser.prototype.readType = function (type) {
        return type.fromParser(this);
    };
    /**
     * Get the type associated with a given field
     *
     * @param field The field that you wan to get the type of
     * @return The type associated with the given field
     */
    BinaryParser.prototype.typeForField = function (field) {
        return field.associatedType;
    };
    /**
     * Read value of the type specified by field from the BinaryParser
     *
     * @param field The field that you want to get the associated value for
     * @return The value associated with the given field
     */
    BinaryParser.prototype.readFieldValue = function (field) {
        var type = this.typeForField(field);
        if (!type) {
            throw new Error("unsupported: (".concat(field.name, ", ").concat(field.type.name, ")"));
        }
        var sizeHint = field.isVariableLengthEncoded
            ? this.readVariableLengthLength()
            : undefined;
        var value = type.fromParser(this, sizeHint);
        if (value === undefined) {
            throw new Error("fromParser for (".concat(field.name, ", ").concat(field.type.name, ") -> undefined "));
        }
        return value;
    };
    /**
     * Get the next field and value from the BinaryParser
     *
     * @return The field and value
     */
    BinaryParser.prototype.readFieldAndValue = function () {
        var field = this.readField();
        return [field, this.readFieldValue(field)];
    };
    return BinaryParser;
}());
exports.BinaryParser = BinaryParser;
//# sourceMappingURL=binary-parser.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\serdes\\binary-parser.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-serializer.js", {"assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Cserdes%5Cbinary-serializer.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BinarySerializer = exports.BytesList = void 0;
var assert = require("assert");
var buffer_1 = require("buffer/");
/**
 * Bytes list is a collection of buffer objects
 */
var BytesList = /** @class */ (function () {
    function BytesList() {
        this.bytesArray = [];
    }
    /**
     * Get the total number of bytes in the BytesList
     *
     * @return the number of bytes
     */
    BytesList.prototype.getLength = function () {
        return buffer_1.Buffer.concat(this.bytesArray).byteLength;
    };
    /**
     * Put bytes in the BytesList
     *
     * @param bytesArg A Buffer
     * @return this BytesList
     */
    BytesList.prototype.put = function (bytesArg) {
        var bytes = buffer_1.Buffer.from(bytesArg); // Temporary, to catch instances of Uint8Array being passed in
        this.bytesArray.push(bytes);
        return this;
    };
    /**
     * Write this BytesList to the back of another bytes list
     *
     *  @param list The BytesList to write to
     */
    BytesList.prototype.toBytesSink = function (list) {
        list.put(this.toBytes());
    };
    BytesList.prototype.toBytes = function () {
        return buffer_1.Buffer.concat(this.bytesArray);
    };
    BytesList.prototype.toHex = function () {
        return this.toBytes().toString('hex').toUpperCase();
    };
    return BytesList;
}());
exports.BytesList = BytesList;
/**
 * BinarySerializer is used to write fields and values to buffers
 */
var BinarySerializer = /** @class */ (function () {
    function BinarySerializer(sink) {
        this.sink = new BytesList();
        this.sink = sink;
    }
    /**
     * Write a value to this BinarySerializer
     *
     * @param value a SerializedType value
     */
    BinarySerializer.prototype.write = function (value) {
        value.toBytesSink(this.sink);
    };
    /**
     * Write bytes to this BinarySerializer
     *
     * @param bytes the bytes to write
     */
    BinarySerializer.prototype.put = function (bytes) {
        this.sink.put(bytes);
    };
    /**
     * Write a value of a given type to this BinarySerializer
     *
     * @param type the type to write
     * @param value a value of that type
     */
    BinarySerializer.prototype.writeType = function (type, value) {
        this.write(type.from(value));
    };
    /**
     * Write BytesList to this BinarySerializer
     *
     * @param bl BytesList to write to BinarySerializer
     */
    BinarySerializer.prototype.writeBytesList = function (bl) {
        bl.toBytesSink(this.sink);
    };
    /**
     * Calculate the header of Variable Length encoded bytes
     *
     * @param length the length of the bytes
     */
    BinarySerializer.prototype.encodeVariableLength = function (length) {
        var lenBytes = buffer_1.Buffer.alloc(3);
        if (length <= 192) {
            lenBytes[0] = length;
            return lenBytes.slice(0, 1);
        }
        else if (length <= 12480) {
            length -= 193;
            lenBytes[0] = 193 + (length >>> 8);
            lenBytes[1] = length & 0xff;
            return lenBytes.slice(0, 2);
        }
        else if (length <= 918744) {
            length -= 12481;
            lenBytes[0] = 241 + (length >>> 16);
            lenBytes[1] = (length >> 8) & 0xff;
            lenBytes[2] = length & 0xff;
            return lenBytes.slice(0, 3);
        }
        throw new Error('Overflow error');
    };
    /**
     * Write field and value to BinarySerializer
     *
     * @param field field to write to BinarySerializer
     * @param value value to write to BinarySerializer
     */
    BinarySerializer.prototype.writeFieldAndValue = function (field, value, isUnlModifyWorkaround) {
        if (isUnlModifyWorkaround === void 0) { isUnlModifyWorkaround = false; }
        var associatedValue = field.associatedType.from(value);
        assert.ok(associatedValue.toBytesSink !== undefined);
        assert.ok(field.name !== undefined);
        this.sink.put(field.header);
        if (field.isVariableLengthEncoded) {
            this.writeLengthEncoded(associatedValue, isUnlModifyWorkaround);
        }
        else {
            associatedValue.toBytesSink(this.sink);
        }
    };
    /**
     * Write a variable length encoded value to the BinarySerializer
     *
     * @param value length encoded value to write to BytesList
     */
    BinarySerializer.prototype.writeLengthEncoded = function (value, isUnlModifyWorkaround) {
        if (isUnlModifyWorkaround === void 0) { isUnlModifyWorkaround = false; }
        var bytes = new BytesList();
        if (!isUnlModifyWorkaround) {
            // this part doesn't happen for the Account field in a UNLModify transaction
            value.toBytesSink(bytes);
        }
        this.put(this.encodeVariableLength(bytes.getLength()));
        this.writeBytesList(bytes);
    };
    return BinarySerializer;
}());
exports.BinarySerializer = BinarySerializer;
//# sourceMappingURL=binary-serializer.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\serdes\\binary-serializer.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\shamap.js", {"./hash-prefixes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hash-prefixes.js","./hashes":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\hashes.js","./types":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\index.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Cshamap.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShaMapLeaf = exports.ShaMapNode = exports.ShaMap = void 0;
var assert_1 = require("assert");
var types_1 = require("./types");
var hash_prefixes_1 = require("./hash-prefixes");
var hashes_1 = require("./hashes");
var buffer_1 = require("buffer/");
/**
 * Abstract class describing a SHAMapNode
 */
var ShaMapNode = /** @class */ (function () {
    function ShaMapNode() {
    }
    return ShaMapNode;
}());
exports.ShaMapNode = ShaMapNode;
/**
 * Class describing a Leaf of SHAMap
 */
var ShaMapLeaf = /** @class */ (function (_super) {
    __extends(ShaMapLeaf, _super);
    function ShaMapLeaf(index, item) {
        var _this = _super.call(this) || this;
        _this.index = index;
        _this.item = item;
        return _this;
    }
    /**
     * @returns true as ShaMapLeaf is a leaf node
     */
    ShaMapLeaf.prototype.isLeaf = function () {
        return true;
    };
    /**
     * @returns false as ShaMapLeaf is not an inner node
     */
    ShaMapLeaf.prototype.isInner = function () {
        return false;
    };
    /**
     * Get the prefix of the this.item
     *
     * @returns The hash prefix, unless this.item is undefined, then it returns an empty Buffer
     */
    ShaMapLeaf.prototype.hashPrefix = function () {
        return this.item === undefined ? buffer_1.Buffer.alloc(0) : this.item.hashPrefix();
    };
    /**
     * Hash the bytes representation of this
     *
     * @returns hash of this.item concatenated with this.index
     */
    ShaMapLeaf.prototype.hash = function () {
        var hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
    };
    /**
     * Write the bytes representation of this to a BytesList
     * @param list BytesList to write bytes to
     */
    ShaMapLeaf.prototype.toBytesSink = function (list) {
        if (this.item !== undefined) {
            this.item.toBytesSink(list);
        }
        this.index.toBytesSink(list);
    };
    return ShaMapLeaf;
}(ShaMapNode));
exports.ShaMapLeaf = ShaMapLeaf;
/**
 * Class defining an Inner Node of a SHAMap
 */
var ShaMapInner = /** @class */ (function (_super) {
    __extends(ShaMapInner, _super);
    function ShaMapInner(depth) {
        if (depth === void 0) { depth = 0; }
        var _this = _super.call(this) || this;
        _this.depth = depth;
        _this.slotBits = 0;
        _this.branches = Array(16);
        return _this;
    }
    /**
     * @returns true as ShaMapInner is an inner node
     */
    ShaMapInner.prototype.isInner = function () {
        return true;
    };
    /**
     * @returns false as ShaMapInner is not a leaf node
     */
    ShaMapInner.prototype.isLeaf = function () {
        return false;
    };
    /**
     * Get the hash prefix for this node
     *
     * @returns hash prefix describing an inner node
     */
    ShaMapInner.prototype.hashPrefix = function () {
        return hash_prefixes_1.HashPrefix.innerNode;
    };
    /**
     * Set a branch of this node to be another node
     *
     * @param slot Slot to add branch to this.branches
     * @param branch Branch to add
     */
    ShaMapInner.prototype.setBranch = function (slot, branch) {
        this.slotBits = this.slotBits | (1 << slot);
        this.branches[slot] = branch;
    };
    /**
     * @returns true if node is empty
     */
    ShaMapInner.prototype.empty = function () {
        return this.slotBits === 0;
    };
    /**
     * Compute the hash of this node
     *
     * @returns The hash of this node
     */
    ShaMapInner.prototype.hash = function () {
        if (this.empty()) {
            return types_1.coreTypes.Hash256.ZERO_256;
        }
        var hash = hashes_1.Sha512Half.put(this.hashPrefix());
        this.toBytesSink(hash);
        return hash.finish();
    };
    /**
     * Writes the bytes representation of this node to a BytesList
     *
     * @param list BytesList to write bytes to
     */
    ShaMapInner.prototype.toBytesSink = function (list) {
        for (var i = 0; i < this.branches.length; i++) {
            var branch = this.branches[i];
            var hash = branch ? branch.hash() : types_1.coreTypes.Hash256.ZERO_256;
            hash.toBytesSink(list);
        }
    };
    /**
     * Add item to the SHAMap
     *
     * @param index Hash of the index of the item being inserted
     * @param item Item to insert in the map
     * @param leaf Leaf node to insert when branch doesn't exist
     */
    ShaMapInner.prototype.addItem = function (index, item, leaf) {
        assert_1.strict.ok(index !== undefined);
        var nibble = index.nibblet(this.depth);
        var existing = this.branches[nibble];
        if (existing === undefined) {
            this.setBranch(nibble, leaf || new ShaMapLeaf(index, item));
        }
        else if (existing instanceof ShaMapLeaf) {
            var newInner = new ShaMapInner(this.depth + 1);
            newInner.addItem(existing.index, undefined, existing);
            newInner.addItem(index, item, leaf);
            this.setBranch(nibble, newInner);
        }
        else if (existing instanceof ShaMapInner) {
            existing.addItem(index, item, leaf);
        }
        else {
            throw new Error('invalid ShaMap.addItem call');
        }
    };
    return ShaMapInner;
}(ShaMapNode));
var ShaMap = /** @class */ (function (_super) {
    __extends(ShaMap, _super);
    function ShaMap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ShaMap;
}(ShaMapInner));
exports.ShaMap = ShaMap;
//# sourceMappingURL=shamap.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\shamap.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\account-id.js", {"./hash-160":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-160.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Caccount-id.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountID = void 0;
var ripple_address_codec_1 = require("ripple-address-codec");
var hash_160_1 = require("./hash-160");
var buffer_1 = require("buffer/");
var HEX_REGEX = /^[A-F0-9]{40}$/;
/**
 * Class defining how to encode and decode an AccountID
 */
var AccountID = /** @class */ (function (_super) {
    __extends(AccountID, _super);
    function AccountID(bytes) {
        return _super.call(this, bytes !== null && bytes !== void 0 ? bytes : AccountID.defaultAccountID.bytes) || this;
    }
    /**
     * Defines how to construct an AccountID
     *
     * @param value either an existing AccountID, a hex-string, or a base58 r-Address
     * @returns an AccountID object
     */
    AccountID.from = function (value) {
        if (value instanceof AccountID) {
            return value;
        }
        if (typeof value === 'string') {
            if (value === '') {
                return new AccountID();
            }
            return HEX_REGEX.test(value)
                ? new AccountID(buffer_1.Buffer.from(value, 'hex'))
                : this.fromBase58(value);
        }
        throw new Error('Cannot construct AccountID from value given');
    };
    /**
     * Defines how to build an AccountID from a base58 r-Address
     *
     * @param value a base58 r-Address
     * @returns an AccountID object
     */
    AccountID.fromBase58 = function (value) {
        if ((0, ripple_address_codec_1.isValidXAddress)(value)) {
            var classic = (0, ripple_address_codec_1.xAddressToClassicAddress)(value);
            if (classic.tag !== false)
                throw new Error('Only allowed to have tag on Account or Destination');
            value = classic.classicAddress;
        }
        return new AccountID(buffer_1.Buffer.from((0, ripple_address_codec_1.decodeAccountID)(value)));
    };
    /**
     * Overload of toJSON
     *
     * @returns the base58 string for this AccountID
     */
    AccountID.prototype.toJSON = function () {
        return this.toBase58();
    };
    /**
     * Defines how to encode AccountID into a base58 address
     *
     * @returns the base58 string defined by this.bytes
     */
    AccountID.prototype.toBase58 = function () {
        /* eslint-disable @typescript-eslint/no-explicit-any */
        return (0, ripple_address_codec_1.encodeAccountID)(this.bytes);
        /* eslint-enable @typescript-eslint/no-explicit-any */
    };
    AccountID.defaultAccountID = new AccountID(buffer_1.Buffer.alloc(20));
    return AccountID;
}(hash_160_1.Hash160));
exports.AccountID = AccountID;
//# sourceMappingURL=account-id.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\account-id.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\amount.js", {"../serdes/binary-parser":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-parser.js","./account-id":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\account-id.js","./currency":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\currency.js","./serialized-type":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js","big-integer":"F:\\metamask-extension\\node_modules\\big-integer\\BigInteger.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js","decimal.js":"F:\\metamask-extension\\node_modules\\decimal.js\\decimal.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Camount.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Amount = void 0;
var decimal_js_1 = require("decimal.js");
var binary_parser_1 = require("../serdes/binary-parser");
var account_id_1 = require("./account-id");
var currency_1 = require("./currency");
var serialized_type_1 = require("./serialized-type");
var bigInt = require("big-integer");
var buffer_1 = require("buffer/");
/**
 * Constants for validating amounts
 */
var MIN_IOU_EXPONENT = -96;
var MAX_IOU_EXPONENT = 80;
var MAX_IOU_PRECISION = 16;
var MAX_DROPS = new decimal_js_1.Decimal('1e17');
var MIN_XRP = new decimal_js_1.Decimal('1e-6');
var mask = bigInt(0x00000000ffffffff);
/**
 * decimal.js configuration for Amount IOUs
 */
decimal_js_1.Decimal.config({
    toExpPos: MAX_IOU_EXPONENT + MAX_IOU_PRECISION,
    toExpNeg: MIN_IOU_EXPONENT - MAX_IOU_PRECISION,
});
/**
 * Type guard for AmountObject
 */
function isAmountObject(arg) {
    var keys = Object.keys(arg).sort();
    return (keys.length === 3 &&
        keys[0] === 'currency' &&
        keys[1] === 'issuer' &&
        keys[2] === 'value');
}
/**
 * Class for serializing/Deserializing Amounts
 */
var Amount = /** @class */ (function (_super) {
    __extends(Amount, _super);
    function Amount(bytes) {
        return _super.call(this, bytes !== null && bytes !== void 0 ? bytes : Amount.defaultAmount.bytes) || this;
    }
    /**
     * Construct an amount from an IOU or string amount
     *
     * @param value An Amount, object representing an IOU, or a string
     *     representing an integer amount
     * @returns An Amount object
     */
    Amount.from = function (value) {
        if (value instanceof Amount) {
            return value;
        }
        var amount = buffer_1.Buffer.alloc(8);
        if (typeof value === 'string') {
            Amount.assertXrpIsValid(value);
            var number = bigInt(value);
            var intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
            intBuf[0].writeUInt32BE(Number(number.shiftRight(32)), 0);
            intBuf[1].writeUInt32BE(Number(number.and(mask)), 0);
            amount = buffer_1.Buffer.concat(intBuf);
            amount[0] |= 0x40;
            return new Amount(amount);
        }
        if (isAmountObject(value)) {
            var number = new decimal_js_1.Decimal(value.value);
            Amount.assertIouIsValid(number);
            if (number.isZero()) {
                amount[0] |= 0x80;
            }
            else {
                var integerNumberString = number
                    .times("1e".concat(-(number.e - 15)))
                    .abs()
                    .toString();
                var num = bigInt(integerNumberString);
                var intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
                intBuf[0].writeUInt32BE(Number(num.shiftRight(32)), 0);
                intBuf[1].writeUInt32BE(Number(num.and(mask)), 0);
                amount = buffer_1.Buffer.concat(intBuf);
                amount[0] |= 0x80;
                if (number.gt(new decimal_js_1.Decimal(0))) {
                    amount[0] |= 0x40;
                }
                var exponent = number.e - 15;
                var exponentByte = 97 + exponent;
                amount[0] |= exponentByte >>> 2;
                amount[1] |= (exponentByte & 0x03) << 6;
            }
            var currency = currency_1.Currency.from(value.currency).toBytes();
            var issuer = account_id_1.AccountID.from(value.issuer).toBytes();
            return new Amount(buffer_1.Buffer.concat([amount, currency, issuer]));
        }
        throw new Error('Invalid type to construct an Amount');
    };
    /**
     * Read an amount from a BinaryParser
     *
     * @param parser BinaryParser to read the Amount from
     * @returns An Amount object
     */
    Amount.fromParser = function (parser) {
        var isXRP = parser.peek() & 0x80;
        var numBytes = isXRP ? 48 : 8;
        return new Amount(parser.read(numBytes));
    };
    /**
     * Get the JSON representation of this Amount
     *
     * @returns the JSON interpretation of this.bytes
     */
    Amount.prototype.toJSON = function () {
        if (this.isNative()) {
            var bytes = this.bytes;
            var isPositive = bytes[0] & 0x40;
            var sign = isPositive ? '' : '-';
            bytes[0] &= 0x3f;
            var msb = bigInt(bytes.slice(0, 4).readUInt32BE(0));
            var lsb = bigInt(bytes.slice(4).readUInt32BE(0));
            var num = msb.shiftLeft(32).or(lsb);
            return "".concat(sign).concat(num.toString());
        }
        else {
            var parser = new binary_parser_1.BinaryParser(this.toString());
            var mantissa = parser.read(8);
            var currency = currency_1.Currency.fromParser(parser);
            var issuer = account_id_1.AccountID.fromParser(parser);
            var b1 = mantissa[0];
            var b2 = mantissa[1];
            var isPositive = b1 & 0x40;
            var sign = isPositive ? '' : '-';
            var exponent = ((b1 & 0x3f) << 2) + ((b2 & 0xff) >> 6) - 97;
            mantissa[0] = 0;
            mantissa[1] &= 0x3f;
            var value = new decimal_js_1.Decimal("".concat(sign, "0x").concat(mantissa.toString('hex'))).times("1e".concat(exponent));
            Amount.assertIouIsValid(value);
            return {
                value: value.toString(),
                currency: currency.toJSON(),
                issuer: issuer.toJSON(),
            };
        }
    };
    /**
     * Validate XRP amount
     *
     * @param amount String representing XRP amount
     * @returns void, but will throw if invalid amount
     */
    Amount.assertXrpIsValid = function (amount) {
        if (amount.indexOf('.') !== -1) {
            throw new Error("".concat(amount.toString(), " is an illegal amount"));
        }
        var decimal = new decimal_js_1.Decimal(amount);
        if (!decimal.isZero()) {
            if (decimal.lt(MIN_XRP) || decimal.gt(MAX_DROPS)) {
                throw new Error("".concat(amount.toString(), " is an illegal amount"));
            }
        }
    };
    /**
     * Validate IOU.value amount
     *
     * @param decimal Decimal.js object representing IOU.value
     * @returns void, but will throw if invalid amount
     */
    Amount.assertIouIsValid = function (decimal) {
        if (!decimal.isZero()) {
            var p = decimal.precision();
            var e = decimal.e - 15;
            if (p > MAX_IOU_PRECISION ||
                e > MAX_IOU_EXPONENT ||
                e < MIN_IOU_EXPONENT) {
                throw new Error('Decimal precision out of range');
            }
            this.verifyNoDecimal(decimal);
        }
    };
    /**
     * Ensure that the value after being multiplied by the exponent does not
     * contain a decimal.
     *
     * @param decimal a Decimal object
     * @returns a string of the object without a decimal
     */
    Amount.verifyNoDecimal = function (decimal) {
        var integerNumberString = decimal
            .times("1e".concat(-(decimal.e - 15)))
            .abs()
            .toString();
        if (integerNumberString.indexOf('.') !== -1) {
            throw new Error('Decimal place found in integerNumberString');
        }
    };
    /**
     * Test if this amount is in units of Native Currency(XRP)
     *
     * @returns true if Native (XRP)
     */
    Amount.prototype.isNative = function () {
        return (this.bytes[0] & 0x80) === 0;
    };
    Amount.defaultAmount = new Amount(buffer_1.Buffer.from('4000000000000000', 'hex'));
    return Amount;
}(serialized_type_1.SerializedType));
exports.Amount = Amount;
//# sourceMappingURL=amount.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\amount.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\blob.js", {"./serialized-type":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cblob.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blob = void 0;
var serialized_type_1 = require("./serialized-type");
var buffer_1 = require("buffer/");
/**
 * Variable length encoded type
 */
var Blob = /** @class */ (function (_super) {
    __extends(Blob, _super);
    function Blob(bytes) {
        return _super.call(this, bytes) || this;
    }
    /**
     * Defines how to read a Blob from a BinaryParser
     *
     * @param parser The binary parser to read the Blob from
     * @param hint The length of the blob, computed by readVariableLengthLength() and passed in
     * @returns A Blob object
     */
    Blob.fromParser = function (parser, hint) {
        return new Blob(parser.read(hint));
    };
    /**
     * Create a Blob object from a hex-string
     *
     * @param value existing Blob object or a hex-string
     * @returns A Blob object
     */
    Blob.from = function (value) {
        if (value instanceof Blob) {
            return value;
        }
        if (typeof value === 'string') {
            return new Blob(buffer_1.Buffer.from(value, 'hex'));
        }
        throw new Error('Cannot construct Blob from value given');
    };
    return Blob;
}(serialized_type_1.SerializedType));
exports.Blob = Blob;
//# sourceMappingURL=blob.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\blob.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\currency.js", {"./hash-160":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-160.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Ccurrency.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Currency = void 0;
var hash_160_1 = require("./hash-160");
var buffer_1 = require("buffer/");
var ISO_REGEX = /^[A-Z0-9]{3}$/;
var HEX_REGEX = /^[A-F0-9]{40}$/;
/**
 * Convert an ISO code to a currency bytes representation
 */
function isoToBytes(iso) {
    var bytes = buffer_1.Buffer.alloc(20);
    if (iso !== 'XRP') {
        var isoBytes = iso.split('').map(function (c) { return c.charCodeAt(0); });
        bytes.set(isoBytes, 12);
    }
    return bytes;
}
/**
 * Tests if ISO is a valid iso code
 */
function isIsoCode(iso) {
    return ISO_REGEX.test(iso);
}
function isoCodeFromHex(code) {
    var iso = code.toString();
    if (iso === 'XRP') {
        throw new Error('Disallowed currency code: to indicate the currency XRP you must use 20 bytes of 0s');
    }
    if (isIsoCode(iso)) {
        return iso;
    }
    return null;
}
/**
 * Tests if hex is a valid hex-string
 */
function isHex(hex) {
    return HEX_REGEX.test(hex);
}
/**
 * Tests if a string is a valid representation of a currency
 */
function isStringRepresentation(input) {
    return input.length === 3 || isHex(input);
}
/**
 * Tests if a Buffer is a valid representation of a currency
 */
function isBytesArray(bytes) {
    return bytes.byteLength === 20;
}
/**
 * Ensures that a value is a valid representation of a currency
 */
function isValidRepresentation(input) {
    return input instanceof buffer_1.Buffer
        ? isBytesArray(input)
        : isStringRepresentation(input);
}
/**
 * Generate bytes from a string or buffer representation of a currency
 */
function bytesFromRepresentation(input) {
    if (!isValidRepresentation(input)) {
        throw new Error("Unsupported Currency representation: ".concat(input));
    }
    return input.length === 3 ? isoToBytes(input) : buffer_1.Buffer.from(input, 'hex');
}
/**
 * Class defining how to encode and decode Currencies
 */
var Currency = /** @class */ (function (_super) {
    __extends(Currency, _super);
    function Currency(byteBuf) {
        var _this = _super.call(this, byteBuf !== null && byteBuf !== void 0 ? byteBuf : Currency.XRP.bytes) || this;
        var code = _this.bytes.slice(12, 15);
        if (_this.bytes[0] !== 0) {
            _this._iso = null;
        }
        else if (/^0*$/.test(_this.bytes.toString('hex'))) {
            _this._iso = 'XRP';
        }
        else {
            _this._iso = isoCodeFromHex(code);
        }
        return _this;
    }
    /**
     * Return the ISO code of this currency
     *
     * @returns ISO code if it exists, else null
     */
    Currency.prototype.iso = function () {
        return this._iso;
    };
    /**
     * Constructs a Currency object
     *
     * @param val Currency object or a string representation of a currency
     */
    Currency.from = function (value) {
        if (value instanceof Currency) {
            return value;
        }
        if (typeof value === 'string') {
            return new Currency(bytesFromRepresentation(value));
        }
        throw new Error('Cannot construct Currency from value given');
    };
    /**
     * Gets the JSON representation of a currency
     *
     * @returns JSON representation
     */
    Currency.prototype.toJSON = function () {
        var iso = this.iso();
        if (iso !== null) {
            return iso;
        }
        return this.bytes.toString('hex').toUpperCase();
    };
    Currency.XRP = new Currency(buffer_1.Buffer.alloc(20));
    return Currency;
}(hash_160_1.Hash160));
exports.Currency = Currency;
//# sourceMappingURL=currency.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\currency.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-128.js", {"./hash":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Chash-128.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hash128 = void 0;
var hash_1 = require("./hash");
var buffer_1 = require("buffer/");
/**
 * Hash with a width of 128 bits
 */
var Hash128 = /** @class */ (function (_super) {
    __extends(Hash128, _super);
    function Hash128(bytes) {
        return _super.call(this, bytes !== null && bytes !== void 0 ? bytes : Hash128.ZERO_128.bytes) || this;
    }
    Hash128.width = 16;
    Hash128.ZERO_128 = new Hash128(buffer_1.Buffer.alloc(Hash128.width));
    return Hash128;
}(hash_1.Hash));
exports.Hash128 = Hash128;
//# sourceMappingURL=hash-128.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\hash-128.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-160.js", {"./hash":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Chash-160.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hash160 = void 0;
var hash_1 = require("./hash");
var buffer_1 = require("buffer/");
/**
 * Hash with a width of 160 bits
 */
var Hash160 = /** @class */ (function (_super) {
    __extends(Hash160, _super);
    function Hash160(bytes) {
        var _this = this;
        if (bytes && bytes.byteLength === 0) {
            bytes = Hash160.ZERO_160.bytes;
        }
        _this = _super.call(this, bytes !== null && bytes !== void 0 ? bytes : Hash160.ZERO_160.bytes) || this;
        return _this;
    }
    Hash160.width = 20;
    Hash160.ZERO_160 = new Hash160(buffer_1.Buffer.alloc(Hash160.width));
    return Hash160;
}(hash_1.Hash));
exports.Hash160 = Hash160;
//# sourceMappingURL=hash-160.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\hash-160.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-256.js", {"./hash":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Chash-256.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hash256 = void 0;
var hash_1 = require("./hash");
var buffer_1 = require("buffer/");
/**
 * Hash with a width of 256 bits
 */
var Hash256 = /** @class */ (function (_super) {
    __extends(Hash256, _super);
    function Hash256(bytes) {
        return _super.call(this, bytes !== null && bytes !== void 0 ? bytes : Hash256.ZERO_256.bytes) || this;
    }
    Hash256.width = 32;
    Hash256.ZERO_256 = new Hash256(buffer_1.Buffer.alloc(Hash256.width));
    return Hash256;
}(hash_1.Hash));
exports.Hash256 = Hash256;
//# sourceMappingURL=hash-256.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\hash-256.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash.js", {"./serialized-type":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Chash.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hash = void 0;
var serialized_type_1 = require("./serialized-type");
var buffer_1 = require("buffer/");
/**
 * Base class defining how to encode and decode hashes
 */
var Hash = /** @class */ (function (_super) {
    __extends(Hash, _super);
    function Hash(bytes) {
        var _this = _super.call(this, bytes) || this;
        if (_this.bytes.byteLength !== _this.constructor.width) {
            throw new Error("Invalid Hash length ".concat(_this.bytes.byteLength));
        }
        return _this;
    }
    /**
     * Construct a Hash object from an existing Hash object or a hex-string
     *
     * @param value A hash object or hex-string of a hash
     */
    Hash.from = function (value) {
        if (value instanceof this) {
            return value;
        }
        if (typeof value === 'string') {
            return new this(buffer_1.Buffer.from(value, 'hex'));
        }
        throw new Error('Cannot construct Hash from given value');
    };
    /**
     * Read a Hash object from a BinaryParser
     *
     * @param parser BinaryParser to read the hash from
     * @param hint length of the bytes to read, optional
     */
    Hash.fromParser = function (parser, hint) {
        return new this(parser.read(hint !== null && hint !== void 0 ? hint : this.width));
    };
    /**
     * Overloaded operator for comparing two hash objects
     *
     * @param other The Hash to compare this to
     */
    Hash.prototype.compareTo = function (other) {
        return this.bytes.compare(this.constructor.from(other).bytes);
    };
    /**
     * @returns the hex-string representation of this Hash
     */
    Hash.prototype.toString = function () {
        return this.toHex();
    };
    /**
     * Returns four bits at the specified depth within a hash
     *
     * @param depth The depth of the four bits
     * @returns The number represented by the four bits
     */
    Hash.prototype.nibblet = function (depth) {
        var byteIx = depth > 0 ? (depth / 2) | 0 : 0;
        var b = this.bytes[byteIx];
        if (depth % 2 === 0) {
            b = (b & 0xf0) >>> 4;
        }
        else {
            b = b & 0x0f;
        }
        return b;
    };
    return Hash;
}(serialized_type_1.Comparable));
exports.Hash = Hash;
//# sourceMappingURL=hash.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\hash.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\index.js", {"../enums":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\enums\\index.js","./account-id":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\account-id.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\amount.js","./blob":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\blob.js","./currency":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\currency.js","./hash-128":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-128.js","./hash-160":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-160.js","./hash-256":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-256.js","./path-set":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\path-set.js","./st-array":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\st-array.js","./st-object":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\st-object.js","./uint-16":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-16.js","./uint-32":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-32.js","./uint-64":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-64.js","./uint-8":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-8.js","./vector-256":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\vector-256.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.coreTypes = void 0;
var enums_1 = require("../enums");
var account_id_1 = require("./account-id");
var amount_1 = require("./amount");
var blob_1 = require("./blob");
var currency_1 = require("./currency");
var hash_128_1 = require("./hash-128");
var hash_160_1 = require("./hash-160");
var hash_256_1 = require("./hash-256");
var path_set_1 = require("./path-set");
var st_array_1 = require("./st-array");
var st_object_1 = require("./st-object");
var uint_16_1 = require("./uint-16");
var uint_32_1 = require("./uint-32");
var uint_64_1 = require("./uint-64");
var uint_8_1 = require("./uint-8");
var vector_256_1 = require("./vector-256");
var coreTypes = {
    AccountID: account_id_1.AccountID,
    Amount: amount_1.Amount,
    Blob: blob_1.Blob,
    Currency: currency_1.Currency,
    Hash128: hash_128_1.Hash128,
    Hash160: hash_160_1.Hash160,
    Hash256: hash_256_1.Hash256,
    PathSet: path_set_1.PathSet,
    STArray: st_array_1.STArray,
    STObject: st_object_1.STObject,
    UInt8: uint_8_1.UInt8,
    UInt16: uint_16_1.UInt16,
    UInt32: uint_32_1.UInt32,
    UInt64: uint_64_1.UInt64,
    Vector256: vector_256_1.Vector256,
};
exports.coreTypes = coreTypes;
Object.values(enums_1.Field).forEach(function (field) {
    field.associatedType = coreTypes[field.type.name];
});
enums_1.Field['TransactionType'].associatedType = enums_1.TransactionType;
enums_1.Field['TransactionResult'].associatedType = enums_1.TransactionResult;
enums_1.Field['LedgerEntryType'].associatedType = enums_1.LedgerEntryType;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\path-set.js", {"../serdes/binary-parser":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-parser.js","./account-id":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\account-id.js","./currency":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\currency.js","./serialized-type":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cpath-set.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathSet = void 0;
var account_id_1 = require("./account-id");
var currency_1 = require("./currency");
var binary_parser_1 = require("../serdes/binary-parser");
var serialized_type_1 = require("./serialized-type");
var buffer_1 = require("buffer/");
/**
 * Constants for separating Paths in a PathSet
 */
var PATHSET_END_BYTE = 0x00;
var PATH_SEPARATOR_BYTE = 0xff;
/**
 * Constant for masking types of a Hop
 */
var TYPE_ACCOUNT = 0x01;
var TYPE_CURRENCY = 0x10;
var TYPE_ISSUER = 0x20;
/**
 * TypeGuard for HopObject
 */
function isHopObject(arg) {
    return (arg.issuer !== undefined ||
        arg.account !== undefined ||
        arg.currency !== undefined);
}
/**
 * TypeGuard for PathSet
 */
function isPathSet(arg) {
    return ((Array.isArray(arg) && arg.length === 0) ||
        (Array.isArray(arg) && Array.isArray(arg[0]) && arg[0].length === 0) ||
        (Array.isArray(arg) && Array.isArray(arg[0]) && isHopObject(arg[0][0])));
}
/**
 * Serialize and Deserialize a Hop
 */
var Hop = /** @class */ (function (_super) {
    __extends(Hop, _super);
    function Hop() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a Hop from a HopObject
     *
     * @param value Either a hop or HopObject to create a hop with
     * @returns a Hop
     */
    Hop.from = function (value) {
        if (value instanceof Hop) {
            return value;
        }
        var bytes = [buffer_1.Buffer.from([0])];
        if (value.account) {
            bytes.push(account_id_1.AccountID.from(value.account).toBytes());
            bytes[0][0] |= TYPE_ACCOUNT;
        }
        if (value.currency) {
            bytes.push(currency_1.Currency.from(value.currency).toBytes());
            bytes[0][0] |= TYPE_CURRENCY;
        }
        if (value.issuer) {
            bytes.push(account_id_1.AccountID.from(value.issuer).toBytes());
            bytes[0][0] |= TYPE_ISSUER;
        }
        return new Hop(buffer_1.Buffer.concat(bytes));
    };
    /**
     * Construct a Hop from a BinaryParser
     *
     * @param parser BinaryParser to read the Hop from
     * @returns a Hop
     */
    Hop.fromParser = function (parser) {
        var type = parser.readUInt8();
        var bytes = [buffer_1.Buffer.from([type])];
        if (type & TYPE_ACCOUNT) {
            bytes.push(parser.read(account_id_1.AccountID.width));
        }
        if (type & TYPE_CURRENCY) {
            bytes.push(parser.read(currency_1.Currency.width));
        }
        if (type & TYPE_ISSUER) {
            bytes.push(parser.read(account_id_1.AccountID.width));
        }
        return new Hop(buffer_1.Buffer.concat(bytes));
    };
    /**
     * Get the JSON interpretation of this hop
     *
     * @returns a HopObject, an JS object with optional account, issuer, and currency
     */
    Hop.prototype.toJSON = function () {
        var hopParser = new binary_parser_1.BinaryParser(this.bytes.toString('hex'));
        var type = hopParser.readUInt8();
        var account, currency, issuer;
        if (type & TYPE_ACCOUNT) {
            account = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_CURRENCY) {
            currency = currency_1.Currency.fromParser(hopParser).toJSON();
        }
        if (type & TYPE_ISSUER) {
            issuer = account_id_1.AccountID.fromParser(hopParser).toJSON();
        }
        var result = {};
        if (account) {
            result.account = account;
        }
        if (issuer) {
            result.issuer = issuer;
        }
        if (currency) {
            result.currency = currency;
        }
        return result;
    };
    /**
     * get a number representing the type of this hop
     *
     * @returns a number to be bitwise and-ed with TYPE_ constants to describe the types in the hop
     */
    Hop.prototype.type = function () {
        return this.bytes[0];
    };
    return Hop;
}(serialized_type_1.SerializedType));
/**
 * Class for serializing/deserializing Paths
 */
var Path = /** @class */ (function (_super) {
    __extends(Path, _super);
    function Path() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * construct a Path from an array of Hops
     *
     * @param value Path or array of HopObjects to construct a Path
     * @returns the Path
     */
    Path.from = function (value) {
        if (value instanceof Path) {
            return value;
        }
        var bytes = [];
        value.forEach(function (hop) {
            bytes.push(Hop.from(hop).toBytes());
        });
        return new Path(buffer_1.Buffer.concat(bytes));
    };
    /**
     * Read a Path from a BinaryParser
     *
     * @param parser BinaryParser to read Path from
     * @returns the Path represented by the bytes read from the BinaryParser
     */
    Path.fromParser = function (parser) {
        var bytes = [];
        while (!parser.end()) {
            bytes.push(Hop.fromParser(parser).toBytes());
            if (parser.peek() === PATHSET_END_BYTE ||
                parser.peek() === PATH_SEPARATOR_BYTE) {
                break;
            }
        }
        return new Path(buffer_1.Buffer.concat(bytes));
    };
    /**
     * Get the JSON representation of this Path
     *
     * @returns an Array of HopObject constructed from this.bytes
     */
    Path.prototype.toJSON = function () {
        var json = [];
        var pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
            json.push(Hop.fromParser(pathParser).toJSON());
        }
        return json;
    };
    return Path;
}(serialized_type_1.SerializedType));
/**
 * Deserialize and Serialize the PathSet type
 */
var PathSet = /** @class */ (function (_super) {
    __extends(PathSet, _super);
    function PathSet() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Construct a PathSet from an Array of Arrays representing paths
     *
     * @param value A PathSet or Array of Array of HopObjects
     * @returns the PathSet constructed from value
     */
    PathSet.from = function (value) {
        if (value instanceof PathSet) {
            return value;
        }
        if (isPathSet(value)) {
            var bytes_1 = [];
            value.forEach(function (path) {
                bytes_1.push(Path.from(path).toBytes());
                bytes_1.push(buffer_1.Buffer.from([PATH_SEPARATOR_BYTE]));
            });
            bytes_1[bytes_1.length - 1] = buffer_1.Buffer.from([PATHSET_END_BYTE]);
            return new PathSet(buffer_1.Buffer.concat(bytes_1));
        }
        throw new Error('Cannot construct PathSet from given value');
    };
    /**
     * Construct a PathSet from a BinaryParser
     *
     * @param parser A BinaryParser to read PathSet from
     * @returns the PathSet read from parser
     */
    PathSet.fromParser = function (parser) {
        var bytes = [];
        while (!parser.end()) {
            bytes.push(Path.fromParser(parser).toBytes());
            bytes.push(parser.read(1));
            if (bytes[bytes.length - 1][0] == PATHSET_END_BYTE) {
                break;
            }
        }
        return new PathSet(buffer_1.Buffer.concat(bytes));
    };
    /**
     * Get the JSON representation of this PathSet
     *
     * @returns an Array of Array of HopObjects, representing this PathSet
     */
    PathSet.prototype.toJSON = function () {
        var json = [];
        var pathParser = new binary_parser_1.BinaryParser(this.toString());
        while (!pathParser.end()) {
            json.push(Path.fromParser(pathParser).toJSON());
            pathParser.skip(1);
        }
        return json;
    };
    return PathSet;
}(serialized_type_1.SerializedType));
exports.PathSet = PathSet;
//# sourceMappingURL=path-set.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\path-set.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js", {"../serdes/binary-serializer":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-serializer.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cserialized-type.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Comparable = exports.SerializedType = void 0;
var binary_serializer_1 = require("../serdes/binary-serializer");
var buffer_1 = require("buffer/");
/**
 * The base class for all binary-codec types
 */
var SerializedType = /** @class */ (function () {
    function SerializedType(bytes) {
        this.bytes = buffer_1.Buffer.alloc(0);
        this.bytes = bytes !== null && bytes !== void 0 ? bytes : buffer_1.Buffer.alloc(0);
    }
    SerializedType.fromParser = function (parser, hint) {
        throw new Error('fromParser not implemented');
        return this.fromParser(parser, hint);
    };
    SerializedType.from = function (value) {
        throw new Error('from not implemented');
        return this.from(value);
    };
    /**
     * Write the bytes representation of a SerializedType to a BytesList
     *
     * @param list The BytesList to write SerializedType bytes to
     */
    SerializedType.prototype.toBytesSink = function (list) {
        list.put(this.bytes);
    };
    /**
     * Get the hex representation of a SerializedType's bytes
     *
     * @returns hex String of this.bytes
     */
    SerializedType.prototype.toHex = function () {
        return this.toBytes().toString('hex').toUpperCase();
    };
    /**
     * Get the bytes representation of a SerializedType
     *
     * @returns A buffer of the bytes
     */
    SerializedType.prototype.toBytes = function () {
        if (this.bytes) {
            return this.bytes;
        }
        var bytes = new binary_serializer_1.BytesList();
        this.toBytesSink(bytes);
        return bytes.toBytes();
    };
    /**
     * Return the JSON representation of a SerializedType
     *
     * @returns any type, if not overloaded returns hexString representation of bytes
     */
    SerializedType.prototype.toJSON = function () {
        return this.toHex();
    };
    /**
     * @returns hexString representation of this.bytes
     */
    SerializedType.prototype.toString = function () {
        return this.toHex();
    };
    return SerializedType;
}());
exports.SerializedType = SerializedType;
/**
 * Base class for SerializedTypes that are comparable
 */
var Comparable = /** @class */ (function (_super) {
    __extends(Comparable, _super);
    function Comparable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Comparable.prototype.lt = function (other) {
        return this.compareTo(other) < 0;
    };
    Comparable.prototype.eq = function (other) {
        return this.compareTo(other) === 0;
    };
    Comparable.prototype.gt = function (other) {
        return this.compareTo(other) > 0;
    };
    Comparable.prototype.gte = function (other) {
        return this.compareTo(other) > -1;
    };
    Comparable.prototype.lte = function (other) {
        return this.compareTo(other) < 1;
    };
    /**
     * Overload this method to define how two Comparable SerializedTypes are compared
     *
     * @param other The comparable object to compare this to
     * @returns A number denoting the relationship of this and other
     */
    Comparable.prototype.compareTo = function (other) {
        throw new Error("cannot compare ".concat(this.toString(), " and ").concat(other.toString()));
    };
    return Comparable;
}(SerializedType));
exports.Comparable = Comparable;
//# sourceMappingURL=serialized-type.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\st-array.js", {"../serdes/binary-parser":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-parser.js","./serialized-type":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js","./st-object":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\st-object.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cst-array.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.STArray = void 0;
var serialized_type_1 = require("./serialized-type");
var st_object_1 = require("./st-object");
var binary_parser_1 = require("../serdes/binary-parser");
var buffer_1 = require("buffer/");
var ARRAY_END_MARKER = buffer_1.Buffer.from([0xf1]);
var ARRAY_END_MARKER_NAME = 'ArrayEndMarker';
var OBJECT_END_MARKER = buffer_1.Buffer.from([0xe1]);
/**
 * TypeGuard for Array<JsonObject>
 */
function isObjects(args) {
    return (Array.isArray(args) && (args.length === 0 || typeof args[0] === 'object'));
}
/**
 * Class for serializing and deserializing Arrays of Objects
 */
var STArray = /** @class */ (function (_super) {
    __extends(STArray, _super);
    function STArray() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Construct an STArray from a BinaryParser
     *
     * @param parser BinaryParser to parse an STArray from
     * @returns An STArray Object
     */
    STArray.fromParser = function (parser) {
        var bytes = [];
        while (!parser.end()) {
            var field = parser.readField();
            if (field.name === ARRAY_END_MARKER_NAME) {
                break;
            }
            bytes.push(field.header, parser.readFieldValue(field).toBytes(), OBJECT_END_MARKER);
        }
        bytes.push(ARRAY_END_MARKER);
        return new STArray(buffer_1.Buffer.concat(bytes));
    };
    /**
     * Construct an STArray from an Array of JSON Objects
     *
     * @param value STArray or Array of Objects to parse into an STArray
     * @returns An STArray object
     */
    STArray.from = function (value) {
        if (value instanceof STArray) {
            return value;
        }
        if (isObjects(value)) {
            var bytes_1 = [];
            value.forEach(function (obj) {
                bytes_1.push(st_object_1.STObject.from(obj).toBytes());
            });
            bytes_1.push(ARRAY_END_MARKER);
            return new STArray(buffer_1.Buffer.concat(bytes_1));
        }
        throw new Error('Cannot construct STArray from value given');
    };
    /**
     * Return the JSON representation of this.bytes
     *
     * @returns An Array of JSON objects
     */
    STArray.prototype.toJSON = function () {
        var result = [];
        var arrayParser = new binary_parser_1.BinaryParser(this.toString());
        while (!arrayParser.end()) {
            var field = arrayParser.readField();
            if (field.name === ARRAY_END_MARKER_NAME) {
                break;
            }
            var outer = {};
            outer[field.name] = st_object_1.STObject.fromParser(arrayParser).toJSON();
            result.push(outer);
        }
        return result;
    };
    return STArray;
}(serialized_type_1.SerializedType));
exports.STArray = STArray;
//# sourceMappingURL=st-array.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\st-array.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\st-object.js", {"../enums":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\enums\\index.js","../serdes/binary-parser":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-parser.js","../serdes/binary-serializer":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-serializer.js","./serialized-type":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cst-object.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.STObject = void 0;
var enums_1 = require("../enums");
var serialized_type_1 = require("./serialized-type");
var ripple_address_codec_1 = require("ripple-address-codec");
var binary_parser_1 = require("../serdes/binary-parser");
var binary_serializer_1 = require("../serdes/binary-serializer");
var buffer_1 = require("buffer/");
var OBJECT_END_MARKER_BYTE = buffer_1.Buffer.from([0xe1]);
var OBJECT_END_MARKER = 'ObjectEndMarker';
var ST_OBJECT = 'STObject';
var DESTINATION = 'Destination';
var ACCOUNT = 'Account';
var SOURCE_TAG = 'SourceTag';
var DEST_TAG = 'DestinationTag';
/**
 * Break down an X-Address into an account and a tag
 *
 * @param field Name of field
 * @param xAddress X-Address corresponding to the field
 */
function handleXAddress(field, xAddress) {
    var _a, _b;
    var decoded = (0, ripple_address_codec_1.xAddressToClassicAddress)(xAddress);
    var tagName;
    if (field === DESTINATION)
        tagName = DEST_TAG;
    else if (field === ACCOUNT)
        tagName = SOURCE_TAG;
    else if (decoded.tag !== false)
        throw new Error("".concat(field, " cannot have an associated tag"));
    return decoded.tag !== false
        ? (_a = {}, _a[field] = decoded.classicAddress, _a[tagName] = decoded.tag, _a) : (_b = {}, _b[field] = decoded.classicAddress, _b);
}
/**
 * Validate that two objects don't both have the same tag fields
 *
 * @param obj1 First object to check for tags
 * @param obj2 Second object to check for tags
 * @throws When both objects have SourceTag or DestinationTag
 */
function checkForDuplicateTags(obj1, obj2) {
    if (!(obj1[SOURCE_TAG] === undefined || obj2[SOURCE_TAG] === undefined))
        throw new Error('Cannot have Account X-Address and SourceTag');
    if (!(obj1[DEST_TAG] === undefined || obj2[DEST_TAG] === undefined))
        throw new Error('Cannot have Destination X-Address and DestinationTag');
}
/**
 * Class for Serializing/Deserializing objects
 */
var STObject = /** @class */ (function (_super) {
    __extends(STObject, _super);
    function STObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Construct a STObject from a BinaryParser
     *
     * @param parser BinaryParser to read STObject from
     * @returns A STObject object
     */
    STObject.fromParser = function (parser) {
        var list = new binary_serializer_1.BytesList();
        var bytes = new binary_serializer_1.BinarySerializer(list);
        while (!parser.end()) {
            var field = parser.readField();
            if (field.name === OBJECT_END_MARKER) {
                break;
            }
            var associatedValue = parser.readFieldValue(field);
            bytes.writeFieldAndValue(field, associatedValue);
            if (field.type.name === ST_OBJECT) {
                bytes.put(OBJECT_END_MARKER_BYTE);
            }
        }
        return new STObject(list.toBytes());
    };
    /**
     * Construct a STObject from a JSON object
     *
     * @param value An object to include
     * @param filter optional, denote which field to include in serialized object
     * @returns a STObject object
     */
    STObject.from = function (value, filter) {
        if (value instanceof STObject) {
            return value;
        }
        var list = new binary_serializer_1.BytesList();
        var bytes = new binary_serializer_1.BinarySerializer(list);
        var isUnlModify = false;
        var xAddressDecoded = Object.entries(value).reduce(function (acc, _a) {
            var _b;
            var key = _a[0], val = _a[1];
            var handled = undefined;
            if (val && (0, ripple_address_codec_1.isValidXAddress)(val.toString())) {
                handled = handleXAddress(key, val.toString());
                checkForDuplicateTags(handled, value);
            }
            return Object.assign(acc, handled !== null && handled !== void 0 ? handled : (_b = {}, _b[key] = val, _b));
        }, {});
        var sorted = Object.keys(xAddressDecoded)
            .map(function (f) { return enums_1.Field[f]; })
            .filter(function (f) {
            return f !== undefined &&
                xAddressDecoded[f.name] !== undefined &&
                f.isSerialized;
        })
            .sort(function (a, b) {
            return a.ordinal - b.ordinal;
        });
        if (filter !== undefined) {
            sorted = sorted.filter(filter);
        }
        sorted.forEach(function (field) {
            var associatedValue = field.associatedType.from(xAddressDecoded[field.name]);
            if (associatedValue.name === 'UNLModify') {
                // triggered when the TransactionType field has a value of 'UNLModify'
                isUnlModify = true;
            }
            // true when in the UNLModify pseudotransaction (after the transaction type has been processed) and working with the
            // Account field
            // The Account field must not be a part of the UNLModify pseudotransaction encoding, due to a bug in rippled
            var isUnlModifyWorkaround = field.name == 'Account' && isUnlModify;
            bytes.writeFieldAndValue(field, associatedValue, isUnlModifyWorkaround);
            if (field.type.name === ST_OBJECT) {
                bytes.put(OBJECT_END_MARKER_BYTE);
            }
        });
        return new STObject(list.toBytes());
    };
    /**
     * Get the JSON interpretation of this.bytes
     *
     * @returns a JSON object
     */
    STObject.prototype.toJSON = function () {
        var objectParser = new binary_parser_1.BinaryParser(this.toString());
        var accumulator = {};
        while (!objectParser.end()) {
            var field = objectParser.readField();
            if (field.name === OBJECT_END_MARKER) {
                break;
            }
            accumulator[field.name] = objectParser.readFieldValue(field).toJSON();
        }
        return accumulator;
    };
    return STObject;
}(serialized_type_1.SerializedType));
exports.STObject = STObject;
//# sourceMappingURL=st-object.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\st-object.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-16.js", {"./uint":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cuint-16.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.UInt16 = void 0;
var uint_1 = require("./uint");
var buffer_1 = require("buffer/");
/**
 * Derived UInt class for serializing/deserializing 16 bit UInt
 */
var UInt16 = /** @class */ (function (_super) {
    __extends(UInt16, _super);
    function UInt16(bytes) {
        return _super.call(this, bytes !== null && bytes !== void 0 ? bytes : UInt16.defaultUInt16.bytes) || this;
    }
    UInt16.fromParser = function (parser) {
        return new UInt16(parser.read(UInt16.width));
    };
    /**
     * Construct a UInt16 object from a number
     *
     * @param val UInt16 object or number
     */
    UInt16.from = function (val) {
        if (val instanceof UInt16) {
            return val;
        }
        if (typeof val === 'number') {
            var buf = buffer_1.Buffer.alloc(UInt16.width);
            buf.writeUInt16BE(val, 0);
            return new UInt16(buf);
        }
        throw new Error('Can not construct UInt16 with given value');
    };
    /**
     * get the value of a UInt16 object
     *
     * @returns the number represented by this.bytes
     */
    UInt16.prototype.valueOf = function () {
        return this.bytes.readUInt16BE(0);
    };
    UInt16.width = 16 / 8; // 2
    UInt16.defaultUInt16 = new UInt16(buffer_1.Buffer.alloc(UInt16.width));
    return UInt16;
}(uint_1.UInt));
exports.UInt16 = UInt16;
//# sourceMappingURL=uint-16.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\uint-16.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-32.js", {"./uint":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cuint-32.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.UInt32 = void 0;
var uint_1 = require("./uint");
var buffer_1 = require("buffer/");
/**
 * Derived UInt class for serializing/deserializing 32 bit UInt
 */
var UInt32 = /** @class */ (function (_super) {
    __extends(UInt32, _super);
    function UInt32(bytes) {
        return _super.call(this, bytes !== null && bytes !== void 0 ? bytes : UInt32.defaultUInt32.bytes) || this;
    }
    UInt32.fromParser = function (parser) {
        return new UInt32(parser.read(UInt32.width));
    };
    /**
     * Construct a UInt32 object from a number
     *
     * @param val UInt32 object or number
     */
    UInt32.from = function (val) {
        if (val instanceof UInt32) {
            return val;
        }
        var buf = buffer_1.Buffer.alloc(UInt32.width);
        if (typeof val === 'string') {
            var num = Number.parseInt(val);
            buf.writeUInt32BE(num, 0);
            return new UInt32(buf);
        }
        if (typeof val === 'number') {
            buf.writeUInt32BE(val, 0);
            return new UInt32(buf);
        }
        throw new Error('Cannot construct UInt32 from given value');
    };
    /**
     * get the value of a UInt32 object
     *
     * @returns the number represented by this.bytes
     */
    UInt32.prototype.valueOf = function () {
        return this.bytes.readUInt32BE(0);
    };
    UInt32.width = 32 / 8; // 4
    UInt32.defaultUInt32 = new UInt32(buffer_1.Buffer.alloc(UInt32.width));
    return UInt32;
}(uint_1.UInt));
exports.UInt32 = UInt32;
//# sourceMappingURL=uint-32.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\uint-32.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-64.js", {"./uint":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint.js","big-integer":"F:\\metamask-extension\\node_modules\\big-integer\\BigInteger.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cuint-64.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.UInt64 = void 0;
var uint_1 = require("./uint");
var bigInt = require("big-integer");
var big_integer_1 = require("big-integer");
var buffer_1 = require("buffer/");
var HEX_REGEX = /^[a-fA-F0-9]{1,16}$/;
var mask = bigInt(0x00000000ffffffff);
/**
 * Derived UInt class for serializing/deserializing 64 bit UInt
 */
var UInt64 = /** @class */ (function (_super) {
    __extends(UInt64, _super);
    function UInt64(bytes) {
        return _super.call(this, bytes !== null && bytes !== void 0 ? bytes : UInt64.defaultUInt64.bytes) || this;
    }
    UInt64.fromParser = function (parser) {
        return new UInt64(parser.read(UInt64.width));
    };
    /**
     * Construct a UInt64 object
     *
     * @param val A UInt64, hex-string, bigInt, or number
     * @returns A UInt64 object
     */
    UInt64.from = function (val) {
        if (val instanceof UInt64) {
            return val;
        }
        var buf = buffer_1.Buffer.alloc(UInt64.width);
        if (typeof val === 'number') {
            if (val < 0) {
                throw new Error('value must be an unsigned integer');
            }
            var number = bigInt(val);
            var intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
            intBuf[0].writeUInt32BE(Number(number.shiftRight(32)), 0);
            intBuf[1].writeUInt32BE(Number(number.and(mask)), 0);
            return new UInt64(buffer_1.Buffer.concat(intBuf));
        }
        if (typeof val === 'string') {
            if (!HEX_REGEX.test(val)) {
                throw new Error("".concat(val, " is not a valid hex-string"));
            }
            var strBuf = val.padStart(16, '0');
            buf = buffer_1.Buffer.from(strBuf, 'hex');
            return new UInt64(buf);
        }
        if ((0, big_integer_1.isInstance)(val)) {
            var intBuf = [buffer_1.Buffer.alloc(4), buffer_1.Buffer.alloc(4)];
            intBuf[0].writeUInt32BE(Number(val.shiftRight(bigInt(32))), 0);
            intBuf[1].writeUInt32BE(Number(val.and(mask)), 0);
            return new UInt64(buffer_1.Buffer.concat(intBuf));
        }
        throw new Error('Cannot construct UInt64 from given value');
    };
    /**
     * The JSON representation of a UInt64 object
     *
     * @returns a hex-string
     */
    UInt64.prototype.toJSON = function () {
        return this.bytes.toString('hex').toUpperCase();
    };
    /**
     * Get the value of the UInt64
     *
     * @returns the number represented buy this.bytes
     */
    UInt64.prototype.valueOf = function () {
        var msb = bigInt(this.bytes.slice(0, 4).readUInt32BE(0));
        var lsb = bigInt(this.bytes.slice(4).readUInt32BE(0));
        return msb.shiftLeft(bigInt(32)).or(lsb);
    };
    /**
     * Get the bytes representation of the UInt64 object
     *
     * @returns 8 bytes representing the UInt64
     */
    UInt64.prototype.toBytes = function () {
        return this.bytes;
    };
    UInt64.width = 64 / 8; // 8
    UInt64.defaultUInt64 = new UInt64(buffer_1.Buffer.alloc(UInt64.width));
    return UInt64;
}(uint_1.UInt));
exports.UInt64 = UInt64;
//# sourceMappingURL=uint-64.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\uint-64.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint-8.js", {"./uint":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint.js","buffer/":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cuint-8.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.UInt8 = void 0;
var uint_1 = require("./uint");
var buffer_1 = require("buffer/");
/**
 * Derived UInt class for serializing/deserializing 8 bit UInt
 */
var UInt8 = /** @class */ (function (_super) {
    __extends(UInt8, _super);
    function UInt8(bytes) {
        return _super.call(this, bytes !== null && bytes !== void 0 ? bytes : UInt8.defaultUInt8.bytes) || this;
    }
    UInt8.fromParser = function (parser) {
        return new UInt8(parser.read(UInt8.width));
    };
    /**
     * Construct a UInt8 object from a number
     *
     * @param val UInt8 object or number
     */
    UInt8.from = function (val) {
        if (val instanceof UInt8) {
            return val;
        }
        if (typeof val === 'number') {
            var buf = buffer_1.Buffer.alloc(UInt8.width);
            buf.writeUInt8(val, 0);
            return new UInt8(buf);
        }
        throw new Error('Cannot construct UInt8 from given value');
    };
    /**
     * get the value of a UInt8 object
     *
     * @returns the number represented by this.bytes
     */
    UInt8.prototype.valueOf = function () {
        return this.bytes.readUInt8(0);
    };
    UInt8.width = 8 / 8; // 1
    UInt8.defaultUInt8 = new UInt8(buffer_1.Buffer.alloc(UInt8.width));
    return UInt8;
}(uint_1.UInt));
exports.UInt8 = UInt8;
//# sourceMappingURL=uint-8.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\uint-8.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\uint.js", {"./serialized-type":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cuint.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.UInt = void 0;
var serialized_type_1 = require("./serialized-type");
/**
 * Compare numbers and bigInts n1 and n2
 *
 * @param n1 First object to compare
 * @param n2 Second object to compare
 * @returns -1, 0, or 1, depending on how the two objects compare
 */
function compare(n1, n2) {
    return n1 < n2 ? -1 : n1 == n2 ? 0 : 1;
}
/**
 * Base class for serializing and deserializing unsigned integers.
 */
var UInt = /** @class */ (function (_super) {
    __extends(UInt, _super);
    function UInt(bytes) {
        return _super.call(this, bytes) || this;
    }
    /**
     * Overload of compareTo for Comparable
     *
     * @param other other UInt to compare this to
     * @returns -1, 0, or 1 depending on how the objects relate to each other
     */
    UInt.prototype.compareTo = function (other) {
        return compare(this.valueOf(), other.valueOf());
    };
    /**
     * Convert a UInt object to JSON
     *
     * @returns number or string represented by this.bytes
     */
    UInt.prototype.toJSON = function () {
        var val = this.valueOf();
        return typeof val === 'number' ? val : val.toString();
    };
    return UInt;
}(serialized_type_1.Comparable));
exports.UInt = UInt;
//# sourceMappingURL=uint.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\uint.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\vector-256.js", {"../serdes/binary-serializer":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\serdes\\binary-serializer.js","./hash-256":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\hash-256.js","./serialized-type":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\types\\serialized-type.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cdist%5Ctypes%5Cvector-256.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Vector256 = void 0;
var serialized_type_1 = require("./serialized-type");
var hash_256_1 = require("./hash-256");
var binary_serializer_1 = require("../serdes/binary-serializer");
/**
 * TypeGuard for Array<string>
 */
function isStrings(arg) {
    return Array.isArray(arg) && (arg.length === 0 || typeof arg[0] === 'string');
}
/**
 * Class for serializing and deserializing vectors of Hash256
 */
var Vector256 = /** @class */ (function (_super) {
    __extends(Vector256, _super);
    function Vector256(bytes) {
        return _super.call(this, bytes) || this;
    }
    /**
     * Construct a Vector256 from a BinaryParser
     *
     * @param parser BinaryParser to
     * @param hint length of the vector, in bytes, optional
     * @returns a Vector256 object
     */
    Vector256.fromParser = function (parser, hint) {
        var bytesList = new binary_serializer_1.BytesList();
        var bytes = hint !== null && hint !== void 0 ? hint : parser.size();
        var hashes = bytes / 32;
        for (var i = 0; i < hashes; i++) {
            hash_256_1.Hash256.fromParser(parser).toBytesSink(bytesList);
        }
        return new Vector256(bytesList.toBytes());
    };
    /**
     * Construct a Vector256 object from an array of hashes
     *
     * @param value A Vector256 object or array of hex-strings representing Hash256's
     * @returns a Vector256 object
     */
    Vector256.from = function (value) {
        if (value instanceof Vector256) {
            return value;
        }
        if (isStrings(value)) {
            var bytesList_1 = new binary_serializer_1.BytesList();
            value.forEach(function (hash) {
                hash_256_1.Hash256.from(hash).toBytesSink(bytesList_1);
            });
            return new Vector256(bytesList_1.toBytes());
        }
        throw new Error('Cannot construct Vector256 from given value');
    };
    /**
     * Return an Array of hex-strings represented by this.bytes
     *
     * @returns An Array of strings representing the Hash256 objects
     */
    Vector256.prototype.toJSON = function () {
        if (this.bytes.byteLength % 32 !== 0) {
            throw new Error('Invalid bytes for Vector256');
        }
        var result = [];
        for (var i = 0; i < this.bytes.byteLength; i += 32) {
            result.push(this.bytes
                .slice(i, i + 32)
                .toString('hex')
                .toUpperCase());
        }
        return result;
    };
    return Vector256;
}(serialized_type_1.SerializedType));
exports.Vector256 = Vector256;
//# sourceMappingURL=vector-256.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec",file:"node_modules\\ripple-binary-codec\\dist\\types\\vector-256.js",}],
["F:\\metamask-extension\\node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js", {"base64-js":"F:\\metamask-extension\\node_modules\\base64-js\\index.js","ieee754":"F:\\metamask-extension\\node_modules\\ieee754\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-binary-codec%5Cnode_modules%5Cbuffer%5Cindex.js
      return function (require, module, exports) {
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-binary-codec>buffer",file:"node_modules\\ripple-binary-codec\\node_modules\\buffer\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\Sha512.js", {"bn.js":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\node_modules\\bn.js\\lib\\bn.js","hash.js":"F:\\metamask-extension\\node_modules\\hash.js\\lib\\hash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-keypairs%5Cdist%5CSha512.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-bitwise --
 * lots of bitwise operators necessary for this */
const hashjs = require("hash.js");
const BigNum = require("bn.js");
class Sha512 {
    constructor() {
        this.hash = hashjs.sha512();
    }
    add(bytes) {
        this.hash.update(bytes);
        return this;
    }
    addU32(i) {
        return this.add([
            (i >>> 24) & 0xff,
            (i >>> 16) & 0xff,
            (i >>> 8) & 0xff,
            i & 0xff,
        ]);
    }
    finish() {
        return this.hash.digest();
    }
    first256() {
        return this.finish().slice(0, 32);
    }
    first256BN() {
        return new BigNum(this.first256());
    }
}
exports.default = Sha512;
//# sourceMappingURL=Sha512.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-keypairs",file:"node_modules\\ripple-keypairs\\dist\\Sha512.js",}],
["F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\index.js", {"./secp256k1":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\secp256k1.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","brorand":"F:\\metamask-extension\\node_modules\\brorand\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","elliptic":"F:\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js","hash.js":"F:\\metamask-extension\\node_modules\\hash.js\\lib\\hash.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-keypairs%5Cdist%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
const assert = require("assert");
const brorand = require("brorand");
const hashjs = require("hash.js");
const elliptic = require("elliptic");
const addressCodec = require("ripple-address-codec");
const secp256k1_1 = require("./secp256k1");
const utils = require("./utils");
const Ed25519 = elliptic.eddsa('ed25519');
const Secp256k1 = elliptic.ec('secp256k1');
const { hexToBytes } = utils;
const { bytesToHex } = utils;
function generateSeed(options = {}) {
    assert.ok(!options.entropy || options.entropy.length >= 16, 'entropy too short');
    const entropy = options.entropy ? options.entropy.slice(0, 16) : brorand(16);
    const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1';
    return addressCodec.encodeSeed(Buffer.from(entropy), type);
}
function hash(message) {
    return hashjs.sha512().update(message).digest().slice(0, 32);
}
const secp256k1 = {
    deriveKeypair(entropy, options) {
        const prefix = '00';
        const privateKey = prefix + (0, secp256k1_1.derivePrivateKey)(entropy, options).toString(16, 64).toUpperCase();
        const publicKey = bytesToHex(Secp256k1.keyFromPrivate(privateKey.slice(2))
            .getPublic()
            .encodeCompressed());
        return { privateKey, publicKey };
    },
    sign(message, privateKey) {
        return bytesToHex(Secp256k1.sign(hash(message), hexToBytes(privateKey), {
            canonical: true,
        }).toDER());
    },
    verify(message, signature, publicKey) {
        return Secp256k1.verify(hash(message), signature, hexToBytes(publicKey));
    },
};
const ed25519 = {
    deriveKeypair(entropy) {
        const prefix = 'ED';
        const rawPrivateKey = hash(entropy);
        const privateKey = prefix + bytesToHex(rawPrivateKey);
        const publicKey = prefix + bytesToHex(Ed25519.keyFromSecret(rawPrivateKey).pubBytes());
        return { privateKey, publicKey };
    },
    sign(message, privateKey) {
        // caution: Ed25519.sign interprets all strings as hex, stripping
        // any non-hex characters without warning
        assert.ok(Array.isArray(message), 'message must be array of octets');
        return bytesToHex(Ed25519.sign(message, hexToBytes(privateKey).slice(1)).toBytes());
    },
    verify(message, signature, publicKey) {
        return Ed25519.verify(message, hexToBytes(signature), hexToBytes(publicKey).slice(1));
    },
};
function select(algorithm) {
    const methods = { 'ecdsa-secp256k1': secp256k1, ed25519 };
    return methods[algorithm];
}
function deriveKeypair(seed, options) {
    const decoded = addressCodec.decodeSeed(seed);
    const algorithm = decoded.type === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1';
    const method = select(algorithm);
    const keypair = method.deriveKeypair(decoded.bytes, options);
    const messageToVerify = hash('This test message should verify.');
    const signature = method.sign(messageToVerify, keypair.privateKey);
    /* istanbul ignore if */
    if (method.verify(messageToVerify, signature, keypair.publicKey) !== true) {
        throw new Error('derived keypair did not generate verifiable signature');
    }
    return keypair;
}
function getAlgorithmFromKey(key) {
    const bytes = hexToBytes(key);
    return bytes.length === 33 && bytes[0] === 0xed
        ? 'ed25519'
        : 'ecdsa-secp256k1';
}
function sign(messageHex, privateKey) {
    const algorithm = getAlgorithmFromKey(privateKey);
    return select(algorithm).sign(hexToBytes(messageHex), privateKey);
}
function verify(messageHex, signature, publicKey) {
    const algorithm = getAlgorithmFromKey(publicKey);
    return select(algorithm).verify(hexToBytes(messageHex), signature, publicKey);
}
function deriveAddressFromBytes(publicKeyBytes) {
    return addressCodec.encodeAccountID(utils.computePublicKeyHash(publicKeyBytes));
}
function deriveAddress(publicKey) {
    return deriveAddressFromBytes(Buffer.from(hexToBytes(publicKey)));
}
function deriveNodeAddress(publicKey) {
    const generatorBytes = addressCodec.decodeNodePublic(publicKey);
    const accountPublicBytes = (0, secp256k1_1.accountPublicFromPublicGenerator)(generatorBytes);
    return deriveAddressFromBytes(accountPublicBytes);
}
const { decodeSeed } = addressCodec;
module.exports = {
    generateSeed,
    deriveKeypair,
    sign,
    verify,
    deriveAddress,
    deriveNodeAddress,
    decodeSeed,
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-keypairs",file:"node_modules\\ripple-keypairs\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\secp256k1.js", {"./Sha512":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\Sha512.js","elliptic":"F:\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-keypairs%5Cdist%5Csecp256k1.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountPublicFromPublicGenerator = exports.derivePrivateKey = void 0;
const elliptic = require("elliptic");
const Sha512_1 = require("./Sha512");
const secp256k1 = elliptic.ec('secp256k1');
function deriveScalar(bytes, discrim) {
    const order = secp256k1.curve.n;
    for (let i = 0; i <= 0xffffffff; i++) {
        // We hash the bytes to find a 256 bit number, looping until we are sure it
        // is less than the order of the curve.
        const hasher = new Sha512_1.default().add(bytes);
        // If the optional discriminator index was passed in, update the hash.
        if (discrim !== undefined) {
            hasher.addU32(discrim);
        }
        hasher.addU32(i);
        const key = hasher.first256BN();
        /* istanbul ignore else */
        if (key.cmpn(0) > 0 && key.cmp(order) < 0) {
            return key;
        }
    }
    // This error is practically impossible to reach.
    // The order of the curve describes the (finite) amount of points on the curve
    // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182
    // How often will an (essentially) random number generated by Sha512 be larger than that?
    // There's 2^32 chances (the for loop) to get a number smaller than the order,
    // and it's rare that you'll even get past the first loop iteration.
    // Note that in TypeScript we actually need the throw, otherwise the function signature would be BN | undefined
    //
    /* istanbul ignore next */
    throw new Error('impossible unicorn ;)');
}
/**
 * @param seed - Bytes.
 * @param [opts] - Object.
 * @param [opts.accountIndex=0] - The account number to generate.
 * @param [opts.validator=false] - Generate root key-pair,
 *                                              as used by validators.
 * @returns {bn.js} 256 bit scalar value.
 *
 */
function derivePrivateKey(seed, opts = {}) {
    const root = opts.validator;
    const order = secp256k1.curve.n;
    // This private generator represents the `root` private key, and is what's
    // used by validators for signing when a keypair is generated from a seed.
    const privateGen = deriveScalar(seed);
    if (root) {
        // As returned by validation_create for a given seed
        return privateGen;
    }
    const publicGen = secp256k1.g.mul(privateGen);
    // A seed can generate many keypairs as a function of the seed and a uint32.
    // Almost everyone just uses the first account, `0`.
    const accountIndex = opts.accountIndex || 0;
    return deriveScalar(publicGen.encodeCompressed(), accountIndex)
        .add(privateGen)
        .mod(order);
}
exports.derivePrivateKey = derivePrivateKey;
function accountPublicFromPublicGenerator(publicGenBytes) {
    const rootPubPoint = secp256k1.curve.decodePoint(publicGenBytes);
    const scalar = deriveScalar(publicGenBytes, 0);
    const point = secp256k1.g.mul(scalar);
    const offset = rootPubPoint.add(point);
    return offset.encodeCompressed();
}
exports.accountPublicFromPublicGenerator = accountPublicFromPublicGenerator;
//# sourceMappingURL=secp256k1.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-keypairs",file:"node_modules\\ripple-keypairs\\dist\\secp256k1.js",}],
["F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\utils.js", {"assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","bn.js":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\node_modules\\bn.js\\lib\\bn.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hash.js":"F:\\metamask-extension\\node_modules\\hash.js\\lib\\hash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-keypairs%5Cdist%5Cutils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computePublicKeyHash = exports.hexToBytes = exports.bytesToHex = void 0;
const assert = require("assert");
const hashjs = require("hash.js");
const BN = require("bn.js");
function bytesToHex(a) {
    return a
        .map((byteValue) => {
        const hex = byteValue.toString(16).toUpperCase();
        return hex.length > 1 ? hex : `0${hex}`;
    })
        .join('');
}
exports.bytesToHex = bytesToHex;
function hexToBytes(a) {
    assert.ok(a.length % 2 === 0);
    return new BN(a, 16).toArray(null, a.length / 2);
}
exports.hexToBytes = hexToBytes;
function computePublicKeyHash(publicKeyBytes) {
    const hash256 = hashjs.sha256().update(publicKeyBytes).digest();
    const hash160 = hashjs.ripemd160().update(hash256).digest();
    return Buffer.from(hash160);
}
exports.computePublicKeyHash = computePublicKeyHash;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-keypairs",file:"node_modules\\ripple-keypairs\\dist\\utils.js",}],
["F:\\metamask-extension\\node_modules\\ripple-keypairs\\node_modules\\bn.js\\lib\\bn.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-keypairs%5Cnode_modules%5Cbn.js%5Clib%5Cbn.js
      return function (require, module, exports) {
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-keypairs>bn.js",file:"node_modules\\ripple-keypairs\\node_modules\\bn.js\\lib\\bn.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\node_modules\\bignumber.js\\bignumber.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib-transactionparser%5Cnode_modules%5Cbignumber.js%5Cbignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.1.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i = xcL;
        xcL = ycL;
        ycL = i;
      }

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) {
        t = yc;
        yc = xc;
        xc = t;
        b = a;
      }

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-lib-transactionparser>bignumber.js",file:"node_modules\\ripple-lib-transactionparser\\node_modules\\bignumber.js\\bignumber.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\balancechanges.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\node_modules\\bignumber.js\\bignumber.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib-transactionparser%5Csrc%5Cbalancechanges.js
      return function (require, module, exports) {
'use strict'

var _ = require('lodash')
var BigNumber = require('bignumber.js')
var normalizeNodes = require('./utils').normalizeNodes
var dropsToXRP = require('./utils').dropsToXRP

function groupByAddress(balanceChanges) {
  var grouped = _.groupBy(balanceChanges, function(node) {
    return node.address
  })
  return _.mapValues(grouped, function(group) {
    return _.map(group, function(node) {
      return node.balance
    })
  })
}

function parseValue(value) {
  return new BigNumber(value.value || value)
}

function computeBalanceChange(node) {
  var value = null
  if (node.newFields.Balance) {
    value = parseValue(node.newFields.Balance)
  } else if (node.previousFields.Balance && node.finalFields.Balance) {
    value = parseValue(node.finalFields.Balance).minus(
      parseValue(node.previousFields.Balance))
  }
  return value === null ? null : value.isZero() ? null : value
}

function parseFinalBalance(node) {
  if (node.newFields.Balance) {
    return parseValue(node.newFields.Balance)
  } else if (node.finalFields.Balance) {
    return parseValue(node.finalFields.Balance)
  }
  return null
}


function parseXRPQuantity(node, valueParser) {
  var value = valueParser(node)

  if (value === null) {
    return null
  }

  return {
    address: node.finalFields.Account || node.newFields.Account,
    balance: {
      counterparty: '',
      currency: 'XRP',
      value: dropsToXRP(value).toString()
    }
  }
}

function flipTrustlinePerspective(quantity) {
  var negatedBalance = (new BigNumber(quantity.balance.value)).negated()
  return {
    address: quantity.balance.counterparty,
    balance: {
      counterparty: quantity.address,
      currency: quantity.balance.currency,
      value: negatedBalance.toString()
    }
  }
}

function parseTrustlineQuantity(node, valueParser) {
  var value = valueParser(node)

  if (value === null) {
    return null
  }

  /*
   * A trustline can be created with a non-zero starting balance
   * If an offer is placed to acquire an asset with no existing trustline,
   * the trustline can be created when the offer is taken.
   */
  var fields = _.isEmpty(node.newFields) ? node.finalFields : node.newFields

  // the balance is always from low node's perspective
  var result = {
    address: fields.LowLimit.issuer,
    balance: {
      counterparty: fields.HighLimit.issuer,
      currency: fields.Balance.currency,
      value: value.toString()
    }
  }
  return [result, flipTrustlinePerspective(result)]
}

function parseQuantities(metadata, valueParser) {
  var values = normalizeNodes(metadata).map(function(node) {
    if (node.entryType === 'AccountRoot') {
      return [parseXRPQuantity(node, valueParser)]
    } else if (node.entryType === 'RippleState') {
      return parseTrustlineQuantity(node, valueParser)
    }
    return []
  })
  return groupByAddress(_.compact(_.flatten(values)))
}

/**
 *  Computes the complete list of every balance that changed in the ledger
 *  as a result of the given transaction.
 *
 *  @param {Object} metadata Transaction metada
 *  @returns {Object} parsed balance changes
 */
function parseBalanceChanges(metadata) {
  return parseQuantities(metadata, computeBalanceChange)
}


/**
 *  Computes the complete list of every final balance in the ledger
 *  as a result of the given transaction.
 *
 *  @param {Object} metadata Transaction metada
 *  @returns {Object} parsed balances
 */
function parseFinalBalances(metadata) {
  return parseQuantities(metadata, parseFinalBalance)
}

module.exports.parseBalanceChanges = parseBalanceChanges
module.exports.parseFinalBalances = parseFinalBalances

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-lib-transactionparser",file:"node_modules\\ripple-lib-transactionparser\\src\\balancechanges.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\channelchanges.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib-transactionparser%5Csrc%5Cchannelchanges.js
      return function (require, module, exports) {
'use strict'

const normalizeNodes = require('./utils').normalizeNodes
const BigNumber = require('bignumber.js')

function parsePaymentChannelStatus(node) {
  if (node.diffType === 'CreatedNode') {
    return 'created'
  }

  if (node.diffType === 'ModifiedNode') {
    return 'modified'
  }

  if (node.diffType === 'DeletedNode') {
    return 'deleted'
  }
  return undefined
}

function summarizePaymentChannel(node) {

  const final = (node.diffType === 'CreatedNode') ?
    node.newFields : node.finalFields
  const prev = node.previousFields || {}

  const summary = {
    // Status may be 'created', 'modified', or 'deleted'.
    status: parsePaymentChannelStatus(node),

    // The LedgerIndex indicates the Channel ID,
    // which is necessary to sign claims.
    channelId: node.ledgerIndex,

    // The source address that owns this payment channel.
    // This comes from the sending address of the
    // transaction that created the channel.
    source: final.Account,

    // The destination address for this payment channel.
    // While the payment channel is open, this address is the only one that can receive
    // XRP from the channel. This comes from the Destination field of the transaction
    // that created the channel.
    destination: final.Destination,

    // Total XRP, in drops, that has been allocated to this channel.
    // This includes XRP that has been paid to the destination address.
    // This is initially set by the transaction that created the channel and
    // can be increased if the source address sends a PaymentChannelFund transaction.
    channelAmountDrops:
          new BigNumber(final.Amount || 0).toString(10),

    // Total XRP, in drops, already paid out by the channel.
    // The difference between this value and the Amount field is how much XRP can still
    // be paid to the destination address with PaymentChannelClaim transactions.
    // If the channel closes, the remaining difference is returned to the source address.
    channelBalanceDrops:
          new BigNumber(final.Balance || 0).toString(10)
  }

  if (prev.Amount) {
    // The change in the number of XRP drops allocated to this channel.
    // This is positive if this is a PaymentChannelFund transaction.
    summary.channelAmountChangeDrops = new BigNumber(final.Amount)
      .minus(new BigNumber(prev.Amount || 0))
      .toString(10)
  }

  if (prev.Balance) {
    // The change in the number of XRP drops already paid out by the channel.
    summary.channelBalanceChangeDrops = new BigNumber(final.Balance)
      .minus(new BigNumber(prev.Balance || 0))
      .toString(10)
  }

  if (node.PreviousTxnID) {
    // The identifying hash of the transaction that
    // most recently modified this payment channel object.
    // You can use this to retrieve the object's history.
    summary.previousTxnId = node.PreviousTxnID
  }

  return summary
}

function parseChannelChanges(metadata) {
  const paymentChannels = normalizeNodes(metadata)
    .filter(n => {
      return n.entryType === 'PayChannel'
    })

  return (paymentChannels.length === 1) ?
    summarizePaymentChannel(paymentChannels[0]) :
    undefined
}

module.exports.parseChannelChanges = parseChannelChanges

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-lib-transactionparser",file:"node_modules\\ripple-lib-transactionparser\\src\\channelchanges.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\index.js", {"./balancechanges":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\balancechanges.js","./channelchanges":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\channelchanges.js","./orderbookchanges":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\orderbookchanges.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib-transactionparser%5Csrc%5Cindex.js
      return function (require, module, exports) {
'use strict'

module.exports.parseBalanceChanges =
  require('./balancechanges').parseBalanceChanges
module.exports.parseFinalBalances =
  require('./balancechanges').parseFinalBalances
module.exports.parseOrderbookChanges =
  require('./orderbookchanges').parseOrderbookChanges
module.exports.getAffectedAccounts =
  require('./utils').getAffectedAccounts
module.exports.parseChannelChanges =
  require('./channelchanges').parseChannelChanges

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-lib-transactionparser",file:"node_modules\\ripple-lib-transactionparser\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\orderbookchanges.js", {"./quality":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\quality.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\node_modules\\bignumber.js\\bignumber.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib-transactionparser%5Csrc%5Corderbookchanges.js
      return function (require, module, exports) {
'use strict'
var _ = require('lodash')
var utils = require('./utils')
var GlobalBigNumber = require('bignumber.js')
var BigNumber = GlobalBigNumber.clone({DECIMAL_PLACES: 40})
var parseQuality = require('./quality')

var lsfSell = 0x00020000 // see "lsfSell" flag in rippled source code

function removeUndefined(obj) {
  return _.omitBy(obj, _.isUndefined)
}

function convertOrderChange(order) {
  var takerGets = order.taker_gets
  var takerPays = order.taker_pays
  var direction = order.sell ? 'sell' : 'buy'
  var quantity = (direction === 'buy') ? takerPays : takerGets
  var totalPrice = (direction === 'buy') ? takerGets : takerPays
  return removeUndefined({
    direction: direction,
    quantity: quantity,
    totalPrice: totalPrice,
    sequence: order.sequence,
    status: order.status,
    makerExchangeRate: order.quality,
    expirationTime: order.expiration
  })
}

function rippleToUnixTimestamp(rpepoch) {
  return (rpepoch + 0x386D4380) * 1000
}

function getExpirationTime(node) {
  var expirationTime = node.finalFields.Expiration || node.newFields.Expiration
  if (expirationTime === undefined) {
    return undefined
  }
  return (new Date(rippleToUnixTimestamp(expirationTime))).toISOString()
}

function getQuality(node) {
  var takerGets = node.finalFields.TakerGets || node.newFields.TakerGets
  var takerPays = node.finalFields.TakerPays || node.newFields.TakerPays
  var takerGetsCurrency = takerGets.currency || 'XRP'
  var takerPaysCurrency = takerPays.currency || 'XRP'
  var bookDirectory = node.finalFields.BookDirectory
    || node.newFields.BookDirectory
  var qualityHex = bookDirectory.substring(bookDirectory.length - 16)
  return parseQuality(qualityHex, takerGetsCurrency, takerPaysCurrency)
}

function parseOrderStatus(node) {
  if (node.diffType === 'CreatedNode') {
    // "submitted" is more conventional, but could be confusing in the
    // context of Ripple
    return 'created'
  }

  if (node.diffType === 'ModifiedNode') {
    return 'partially-filled'
  }

  if (node.diffType === 'DeletedNode') {
    // A filled order has previous fields
    if (node.previousFields.hasOwnProperty('TakerPays')) {
      return 'filled'
    }

    // A cancelled order has no previous fields
    // google search for "cancelled order" shows 5x more results than
    // "canceled order", even though both spellings are correct
    return 'cancelled'
  }
  return undefined
}

function calculateDelta(finalAmount, previousAmount) {
  if (previousAmount) {
    var finalValue = new BigNumber(finalAmount.value)
    var previousValue = new BigNumber(previousAmount.value)
    return finalValue.minus(previousValue).abs().toString()
  }
  return '0'
}

function parseChangeAmount(node, type) {
  var status = parseOrderStatus(node)

  if (status === 'cancelled') {
    // Canceled orders do not have PreviousFields; FinalFields
    // have positive values
    return utils.parseCurrencyAmount(node.finalFields[type])
  } else if (status === 'created') {
    return utils.parseCurrencyAmount(node.newFields[type])
  }
  var finalAmount = utils.parseCurrencyAmount(node.finalFields[type])
  var previousAmount = utils.parseCurrencyAmount(node.previousFields[type])
  var value = calculateDelta(finalAmount, previousAmount)
  return _.assign({}, finalAmount, {value: value})
}

function parseOrderChange(node) {
  var orderChange = convertOrderChange({
    taker_pays: parseChangeAmount(node, 'TakerPays'),
    taker_gets: parseChangeAmount(node, 'TakerGets'),
    sell: (node.finalFields.Flags & lsfSell) !== 0,
    sequence: node.finalFields.Sequence || node.newFields.Sequence,
    status: parseOrderStatus(node),
    quality: getQuality(node),
    expiration: getExpirationTime(node)
  })

  Object.defineProperty(orderChange, 'account', {
    value: node.finalFields.Account || node.newFields.Account
  })

  return orderChange
}

function groupByAddress(orderChanges) {
  return _.groupBy(orderChanges, function(change) {
    return change.account
  })
}

/**
 * Computes the complete list of every Offer that changed in the ledger
 * as a result of the given transaction.
 * Returns changes grouped by Ripple account.
 *
 *  @param {Object} metadata - Transaction metadata as return by ripple-lib
 *  @returns {Object} - Orderbook changes grouped by Ripple account
 *
 */
exports.parseOrderbookChanges = function parseOrderbookChanges(metadata) {
  var nodes = utils.normalizeNodes(metadata)

  var orderChanges = _.map(_.filter(nodes, function(node) {
    return node.entryType === 'Offer'
  }), parseOrderChange)

  return groupByAddress(orderChanges)
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-lib-transactionparser",file:"node_modules\\ripple-lib-transactionparser\\src\\orderbookchanges.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\quality.js", {"assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib-transactionparser%5Csrc%5Cquality.js
      return function (require, module, exports) {
'use strict'
var assert = require('assert')
var BigNumber = require('bignumber.js')

/*
The quality, as stored in the last 64 bits of a directory index, is stored as
the quotient of TakerPays/TakerGets. It uses drops (1e-6 XRP) for XRP values.
*/

function adjustQualityForXRP(quality, takerGetsCurrency, takerPaysCurrency) {
  var numeratorShift = (takerPaysCurrency === 'XRP' ? -6 : 0)
  var denominatorShift = (takerGetsCurrency === 'XRP' ? -6 : 0)
  var shift = numeratorShift - denominatorShift
  return shift === 0 ? (new BigNumber(quality)).toString() :
    (new BigNumber(quality)).shiftedBy(shift).toString()
}

function parseQuality(qualityHex, takerGetsCurrency, takerPaysCurrency) {
  assert(qualityHex.length === 16)
  var mantissa = new BigNumber(qualityHex.substring(2), 16)
  var offset = parseInt(qualityHex.substring(0, 2), 16) - 100
  var quality = mantissa.toString() + 'e' + offset.toString()
  return adjustQualityForXRP(quality, takerGetsCurrency, takerPaysCurrency)
}

module.exports = parseQuality

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-lib-transactionparser",file:"node_modules\\ripple-lib-transactionparser\\src\\quality.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\utils.js", {"bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\node_modules\\bignumber.js\\bignumber.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib-transactionparser%5Csrc%5Cutils.js
      return function (require, module, exports) {
'use strict'
var _ = require('lodash')
var BigNumber = require('bignumber.js')

// drops is a bignumber.js BigNumber
function dropsToXRP(drops) {
  return drops.dividedBy(1000000)
}

function normalizeNode(affectedNode) {
  var diffType = Object.keys(affectedNode)[0]
  var node = affectedNode[diffType]
  return Object.assign({}, node, {
    diffType: diffType,
    entryType: node.LedgerEntryType,
    ledgerIndex: node.LedgerIndex,
    newFields: node.NewFields || {},
    finalFields: node.FinalFields || {},
    previousFields: node.PreviousFields || {}
  })
}

function normalizeNodes(metadata) {
  if (!metadata.AffectedNodes) {
    return []
  }
  return metadata.AffectedNodes.map(normalizeNode)
}

function parseCurrencyAmount(currencyAmount) {
  if (currencyAmount === undefined) {
    return undefined
  }
  if (typeof currencyAmount === 'string') {
    return {
      currency: 'XRP',
      value: dropsToXRP(new BigNumber(currencyAmount)).toString()
    }
  }

  return {
    currency: currencyAmount.currency,
    counterparty: currencyAmount.issuer,
    value: currencyAmount.value
  }
}

function isAccountField(fieldName) {
  var fieldNames = ['Account', 'Owner', 'Destination', 'Issuer', 'Target']
  return _.includes(fieldNames, fieldName)
}

function isAmountFieldAffectingIssuer(fieldName) {
  var fieldNames = ['LowLimit', 'HighLimit', 'TakerPays', 'TakerGets']
  return _.includes(fieldNames, fieldName)
}

function getAffectedAccounts(metadata) {
  var accounts = []
  _.forEach(normalizeNodes(metadata), function(node) {
    var fields = node.diffType === 'CreatedNode' ?
      node.newFields : node.finalFields
    _.forEach(fields, function(fieldValue, fieldName) {
      if (isAccountField(fieldName)) {
        accounts.push(fieldValue)
      } else if (isAmountFieldAffectingIssuer(fieldName) && fieldValue.issuer) {
        accounts.push(fieldValue.issuer)
      }
    })
  })
  return _.uniq(accounts)
}


module.exports = {
  dropsToXRP: dropsToXRP,
  normalizeNodes: normalizeNodes,
  parseCurrencyAmount: parseCurrencyAmount,
  getAffectedAccounts: getAffectedAccounts
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>ripple-lib-transactionparser",file:"node_modules\\ripple-lib-transactionparser\\src\\utils.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\api.js", {"./common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./common/hashes":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\index.js","./common/rangeset":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\rangeset.js","./common/schema-validator":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schema-validator.js","./common/serverinfo":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\serverinfo.js","./ledger/accountinfo":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\accountinfo.js","./ledger/accountobjects":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\accountobjects.js","./ledger/balance-sheet":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\balance-sheet.js","./ledger/balances":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\balances.js","./ledger/ledger":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\ledger.js","./ledger/orderbook":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\orderbook.js","./ledger/orders":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\orders.js","./ledger/pathfind":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\pathfind.js","./ledger/payment-channel":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\payment-channel.js","./ledger/settings":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\settings.js","./ledger/transaction":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\transaction.js","./ledger/transactions":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\transactions.js","./ledger/trustlines":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\trustlines.js","./ledger/utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\utils.js","./offline/derive":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\derive.js","./offline/ledgerhash":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\ledgerhash.js","./offline/sign-payment-channel-claim":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\sign-payment-channel-claim.js","./offline/utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\utils.js","./offline/verify-payment-channel-claim":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\verify-payment-channel-claim.js","./server/server":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\server\\server.js","./transaction/check-cancel":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\check-cancel.js","./transaction/check-cash":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\check-cash.js","./transaction/check-create":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\check-create.js","./transaction/combine":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\combine.js","./transaction/escrow-cancellation":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\escrow-cancellation.js","./transaction/escrow-creation":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\escrow-creation.js","./transaction/escrow-execution":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\escrow-execution.js","./transaction/order":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\order.js","./transaction/ordercancellation":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\ordercancellation.js","./transaction/payment":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\payment.js","./transaction/payment-channel-claim":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\payment-channel-claim.js","./transaction/payment-channel-create":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\payment-channel-create.js","./transaction/payment-channel-fund":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\payment-channel-fund.js","./transaction/settings":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\settings.js","./transaction/sign":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\sign.js","./transaction/submit":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\submit.js","./transaction/ticket":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\ticket.js","./transaction/trustline":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\trustline.js","./transaction/utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js","./wallet/wallet-generation":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\wallet\\wallet-generation.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Capi.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RippleAPI = void 0;
const events_1 = require("events");
const common_1 = require("./common");
const server_1 = require("./server/server");
const transaction_1 = __importDefault(require("./ledger/transaction"));
const transactions_1 = __importDefault(require("./ledger/transactions"));
const trustlines_1 = __importDefault(require("./ledger/trustlines"));
const balances_1 = __importDefault(require("./ledger/balances"));
const balance_sheet_1 = __importDefault(require("./ledger/balance-sheet"));
const pathfind_1 = __importDefault(require("./ledger/pathfind"));
const orders_1 = __importDefault(require("./ledger/orders"));
const orderbook_1 = require("./ledger/orderbook");
const settings_1 = require("./ledger/settings");
const accountinfo_1 = __importDefault(require("./ledger/accountinfo"));
const accountobjects_1 = __importDefault(require("./ledger/accountobjects"));
const payment_channel_1 = __importDefault(require("./ledger/payment-channel"));
const payment_1 = __importDefault(require("./transaction/payment"));
const trustline_1 = __importDefault(require("./transaction/trustline"));
const order_1 = __importDefault(require("./transaction/order"));
const ordercancellation_1 = __importDefault(require("./transaction/ordercancellation"));
const escrow_creation_1 = __importDefault(require("./transaction/escrow-creation"));
const escrow_execution_1 = __importDefault(require("./transaction/escrow-execution"));
const escrow_cancellation_1 = __importDefault(require("./transaction/escrow-cancellation"));
const payment_channel_create_1 = __importDefault(require("./transaction/payment-channel-create"));
const payment_channel_fund_1 = __importDefault(require("./transaction/payment-channel-fund"));
const payment_channel_claim_1 = __importDefault(require("./transaction/payment-channel-claim"));
const check_create_1 = __importDefault(require("./transaction/check-create"));
const check_cancel_1 = __importDefault(require("./transaction/check-cancel"));
const check_cash_1 = __importDefault(require("./transaction/check-cash"));
const settings_2 = __importDefault(require("./transaction/settings"));
const ticket_1 = __importDefault(require("./transaction/ticket"));
const sign_1 = __importDefault(require("./transaction/sign"));
const combine_1 = __importDefault(require("./transaction/combine"));
const submit_1 = __importDefault(require("./transaction/submit"));
const utils_1 = require("./offline/utils");
const derive_1 = require("./offline/derive");
const ledgerhash_1 = __importDefault(require("./offline/ledgerhash"));
const sign_payment_channel_claim_1 = __importDefault(require("./offline/sign-payment-channel-claim"));
const verify_payment_channel_claim_1 = __importDefault(require("./offline/verify-payment-channel-claim"));
const ledger_1 = __importDefault(require("./ledger/ledger"));
const rangeset_1 = __importDefault(require("./common/rangeset"));
const ledgerUtils = __importStar(require("./ledger/utils"));
const transactionUtils = __importStar(require("./transaction/utils"));
const schemaValidator = __importStar(require("./common/schema-validator"));
const serverinfo_1 = require("./common/serverinfo");
const utils_2 = require("./ledger/utils");
const ripple_address_codec_1 = require("ripple-address-codec");
const hashes_1 = require("./common/hashes");
const wallet_generation_1 = __importDefault(require("./wallet/wallet-generation"));
function getCollectKeyFromCommand(command) {
    switch (command) {
        case 'account_offers':
        case 'book_offers':
            return 'offers';
        case 'account_lines':
            return 'lines';
        default:
            return undefined;
    }
}
class RippleAPI extends events_1.EventEmitter {
    constructor(options = {}) {
        super();
        this.generateAddress = utils_1.generateAddress;
        this.generateXAddress = utils_1.generateXAddress;
        this.connect = server_1.connect;
        this.disconnect = server_1.disconnect;
        this.isConnected = server_1.isConnected;
        this.getServerInfo = serverinfo_1.getServerInfo;
        this.getFee = serverinfo_1.getFee;
        this.getLedgerVersion = server_1.getLedgerVersion;
        this.getTransaction = transaction_1.default;
        this.getTransactions = transactions_1.default;
        this.getTrustlines = trustlines_1.default;
        this.getBalances = balances_1.default;
        this.getBalanceSheet = balance_sheet_1.default;
        this.getPaths = pathfind_1.default;
        this.getOrderbook = orderbook_1.getOrderbook;
        this.getOrders = orders_1.default;
        this.getSettings = settings_1.getSettings;
        this.getAccountInfo = accountinfo_1.default;
        this.getAccountObjects = accountobjects_1.default;
        this.getPaymentChannel = payment_channel_1.default;
        this.getLedger = ledger_1.default;
        this.parseAccountFlags = settings_1.parseAccountFlags;
        this.preparePayment = payment_1.default;
        this.prepareTrustline = trustline_1.default;
        this.prepareOrder = order_1.default;
        this.prepareOrderCancellation = ordercancellation_1.default;
        this.prepareEscrowCreation = escrow_creation_1.default;
        this.prepareEscrowExecution = escrow_execution_1.default;
        this.prepareEscrowCancellation = escrow_cancellation_1.default;
        this.preparePaymentChannelCreate = payment_channel_create_1.default;
        this.preparePaymentChannelFund = payment_channel_fund_1.default;
        this.preparePaymentChannelClaim = payment_channel_claim_1.default;
        this.prepareCheckCreate = check_create_1.default;
        this.prepareCheckCash = check_cash_1.default;
        this.prepareCheckCancel = check_cancel_1.default;
        this.prepareTicketCreate = ticket_1.default;
        this.prepareSettings = settings_2.default;
        this.sign = sign_1.default;
        this.combine = combine_1.default;
        this.submit = submit_1.default;
        this.deriveKeypair = derive_1.deriveKeypair;
        this.deriveAddress = derive_1.deriveAddress;
        this.computeLedgerHash = ledgerhash_1.default;
        this.signPaymentChannelClaim = sign_payment_channel_claim_1.default;
        this.verifyPaymentChannelClaim = verify_payment_channel_claim_1.default;
        this.generateFaucetWallet = wallet_generation_1.default;
        this.errors = common_1.errors;
        this.xrpToDrops = common_1.xrpToDrops;
        this.dropsToXrp = common_1.dropsToXrp;
        this.rippleTimeToISO8601 = common_1.rippleTimeToISO8601;
        this.iso8601ToRippleTime = common_1.iso8601ToRippleTime;
        this.txFlags = common_1.txFlags;
        this.accountSetFlags = common_1.constants.AccountSetFlags;
        this.isValidAddress = schemaValidator.isValidAddress;
        this.isValidSecret = schemaValidator.isValidSecret;
        common_1.validate.apiOptions(options);
        this._feeCushion = options.feeCushion || 1.2;
        this._maxFeeXRP = options.maxFeeXRP || '2';
        const serverURL = options.server;
        if (serverURL != null) {
            this.connection = new common_1.Connection(serverURL, options);
            this.connection.on('ledgerClosed', (message) => {
                this.emit('ledger', server_1.formatLedgerClose(message));
            });
            this.connection.on('error', (errorCode, errorMessage, data) => {
                this.emit('error', errorCode, errorMessage, data);
            });
            this.connection.on('connected', () => {
                this.emit('connected');
            });
            this.connection.on('disconnected', (code) => {
                let finalCode = code;
                if (finalCode === 1005 || finalCode === 4000) {
                    finalCode = 1000;
                }
                this.emit('disconnected', finalCode);
            });
        }
        else {
            this.connection = new common_1.Connection(null, options);
        }
    }
    request(command, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.connection.request(Object.assign(Object.assign({}, params), { command, account: params.account ? common_1.ensureClassicAddress(params.account) : undefined }));
        });
    }
    hasNextPage(currentResponse) {
        return !!currentResponse.marker;
    }
    requestNextPage(command, params = {}, currentResponse) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!currentResponse.marker) {
                return Promise.reject(new common_1.errors.NotFoundError('response does not have a next page'));
            }
            const nextPageParams = Object.assign({}, params, {
                marker: currentResponse.marker
            });
            return this.request(command, nextPageParams);
        });
    }
    prepareTransaction(txJSON, instructions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return transactionUtils.prepareTransaction(txJSON, this, instructions);
        });
    }
    convertStringToHex(string) {
        return transactionUtils.convertStringToHex(string);
    }
    _requestAll(command, params = {}, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const collectKey = options.collect || getCollectKeyFromCommand(command);
            if (!collectKey) {
                throw new common_1.errors.ValidationError(`no collect key for command ${command}`);
            }
            const countTo = params.limit != null ? params.limit : Infinity;
            let count = 0;
            let marker = params.marker;
            let lastBatchLength;
            const results = [];
            do {
                const countRemaining = utils_2.clamp(countTo - count, 10, 400);
                const repeatProps = Object.assign(Object.assign({}, params), { limit: countRemaining, marker });
                const singleResult = yield this.request(command, repeatProps);
                const collectedData = singleResult[collectKey];
                marker = singleResult['marker'];
                results.push(singleResult);
                const isExpectedFormat = Array.isArray(collectedData);
                if (isExpectedFormat) {
                    count += collectedData.length;
                    lastBatchLength = collectedData.length;
                }
                else {
                    lastBatchLength = 0;
                }
            } while (!!marker && count < countTo && lastBatchLength !== 0);
            return results;
        });
    }
}
exports.RippleAPI = RippleAPI;
RippleAPI._PRIVATE = {
    validate: common_1.validate,
    RangeSet: rangeset_1.default,
    ledgerUtils,
    schemaValidator
};
RippleAPI.renameCounterpartyToIssuer = utils_2.renameCounterpartyToIssuer;
RippleAPI.formatBidsAndAsks = orderbook_1.formatBidsAndAsks;
RippleAPI.deriveXAddress = derive_1.deriveXAddress;
RippleAPI.deriveClassicAddress = derive_1.deriveAddress;
RippleAPI.classicAddressToXAddress = ripple_address_codec_1.classicAddressToXAddress;
RippleAPI.xAddressToClassicAddress = ripple_address_codec_1.xAddressToClassicAddress;
RippleAPI.isValidXAddress = ripple_address_codec_1.isValidXAddress;
RippleAPI.isValidClassicAddress = ripple_address_codec_1.isValidClassicAddress;
RippleAPI.encodeSeed = ripple_address_codec_1.encodeSeed;
RippleAPI.decodeSeed = ripple_address_codec_1.decodeSeed;
RippleAPI.encodeAccountID = ripple_address_codec_1.encodeAccountID;
RippleAPI.decodeAccountID = ripple_address_codec_1.decodeAccountID;
RippleAPI.encodeNodePublic = ripple_address_codec_1.encodeNodePublic;
RippleAPI.decodeNodePublic = ripple_address_codec_1.decodeNodePublic;
RippleAPI.encodeAccountPublic = ripple_address_codec_1.encodeAccountPublic;
RippleAPI.decodeAccountPublic = ripple_address_codec_1.decodeAccountPublic;
RippleAPI.encodeXAddress = ripple_address_codec_1.encodeXAddress;
RippleAPI.decodeXAddress = ripple_address_codec_1.decodeXAddress;
RippleAPI.computeBinaryTransactionHash = hashes_1.computeBinaryTransactionHash;
RippleAPI.computeTransactionHash = hashes_1.computeTransactionHash;
RippleAPI.computeBinaryTransactionSigningHash = hashes_1.computeBinaryTransactionSigningHash;
RippleAPI.computeAccountLedgerObjectID = hashes_1.computeAccountLedgerObjectID;
RippleAPI.computeSignerListLedgerObjectID = hashes_1.computeSignerListLedgerObjectID;
RippleAPI.computeOrderID = hashes_1.computeOrderID;
RippleAPI.computeTrustlineHash = hashes_1.computeTrustlineHash;
RippleAPI.computeTransactionTreeHash = hashes_1.computeTransactionTreeHash;
RippleAPI.computeStateTreeHash = hashes_1.computeStateTreeHash;
RippleAPI.computeLedgerHash = ledgerhash_1.default;
RippleAPI.computeEscrowHash = hashes_1.computeEscrowHash;
RippleAPI.computePaymentChannelHash = hashes_1.computePaymentChannelHash;
RippleAPI.txFlags = common_1.txFlags;
RippleAPI.accountSetFlags = common_1.constants.AccountSetFlags;
//# sourceMappingURL=api.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\api.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\broadcast.js", {"./api":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\api.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cbroadcast.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RippleAPIBroadcast = void 0;
const api_1 = require("./api");
class RippleAPIBroadcast extends api_1.RippleAPI {
    constructor(servers, options = {}) {
        super(options);
        this.ledgerVersion = undefined;
        const apis = servers.map((server) => new api_1.RippleAPI(Object.assign({}, options, { server })));
        this._apis = apis;
        this.getMethodNames().forEach((name) => {
            this[name] = function () {
                return Promise.race(apis.map((api) => api[name](...arguments)));
            };
        });
        this.connect = function () {
            return __awaiter(this, void 0, void 0, function* () {
                yield Promise.all(apis.map((api) => api.connect()));
            });
        };
        this.disconnect = function () {
            return __awaiter(this, void 0, void 0, function* () {
                yield Promise.all(apis.map((api) => api.disconnect()));
            });
        };
        this.isConnected = function () {
            return apis.map((api) => api.isConnected()).every(Boolean);
        };
        const defaultAPI = apis[0];
        const syncMethods = ['sign', 'generateAddress', 'computeLedgerHash'];
        syncMethods.forEach((name) => {
            this[name] = defaultAPI[name].bind(defaultAPI);
        });
        apis.forEach((api) => {
            api.on('ledger', this.onLedgerEvent.bind(this));
            api.on('error', (errorCode, errorMessage, data) => this.emit('error', errorCode, errorMessage, data));
        });
    }
    onLedgerEvent(ledger) {
        if (ledger.ledgerVersion > this.ledgerVersion ||
            this.ledgerVersion == null) {
            this.ledgerVersion = ledger.ledgerVersion;
            this.emit('ledger', ledger);
        }
    }
    getMethodNames() {
        const methodNames = [];
        const rippleAPI = this._apis[0];
        for (const name of Object.getOwnPropertyNames(rippleAPI)) {
            if (typeof rippleAPI[name] === 'function') {
                methodNames.push(name);
            }
        }
        return methodNames;
    }
}
exports.RippleAPIBroadcast = RippleAPIBroadcast;
//# sourceMappingURL=broadcast.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\broadcast.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\backoff.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cbackoff.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExponentialBackoff = void 0;
class ExponentialBackoff {
    constructor(opts = {}) {
        this.factor = 2;
        this.jitter = 0;
        this.attempts = 0;
        this.ms = opts.min || 100;
        this.max = opts.max || 10000;
    }
    duration() {
        var ms = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
            var rand = Math.random();
            var deviation = Math.floor(rand * this.jitter * ms);
            ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
        }
        return Math.min(ms, this.max) | 0;
    }
    reset() {
        this.attempts = 0;
    }
}
exports.ExponentialBackoff = ExponentialBackoff;
//# sourceMappingURL=backoff.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\backoff.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\browser-hacks.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cbrowser-hacks.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setPrototypeOf = exports.getConstructorName = void 0;
function setPrototypeOf(object, prototype) {
    Object.setPrototypeOf
        ? Object.setPrototypeOf(object, prototype)
        :
            (object.__proto__ = prototype);
}
exports.setPrototypeOf = setPrototypeOf;
function getConstructorName(object) {
    if (object.constructor.name) {
        return object.constructor.name;
    }
    const constructorString = object.constructor.toString();
    const functionConstructor = constructorString.match(/^function\s+([^(]*)/);
    const classConstructor = constructorString.match(/^class\s([^\s]*)/);
    return functionConstructor ? functionConstructor[1] : classConstructor[1];
}
exports.getConstructorName = getConstructorName;
//# sourceMappingURL=browser-hacks.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\browser-hacks.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\connection.js", {"./backoff":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\backoff.js","./errors":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\errors.js","./rangeset":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\rangeset.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","https-proxy-agent":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js","url":"F:\\metamask-extension\\node_modules\\url\\url.js","ws":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\wswrapper.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cconnection.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connection = void 0;
const _ = __importStar(require("lodash"));
const events_1 = require("events");
const url_1 = require("url");
const ws_1 = __importDefault(require("ws"));
const rangeset_1 = __importDefault(require("./rangeset"));
const errors_1 = require("./errors");
const backoff_1 = require("./backoff");
const INTENTIONAL_DISCONNECT_CODE = 4000;
function createWebSocket(url, config) {
    const options = {};
    if (config.proxy != null) {
        const parsedURL = url_1.parse(url);
        const parsedProxyURL = url_1.parse(config.proxy);
        const proxyOverrides = _.omitBy({
            secureEndpoint: parsedURL.protocol === 'wss:',
            secureProxy: parsedProxyURL.protocol === 'https:',
            auth: config.proxyAuthorization,
            ca: config.trustedCertificates,
            key: config.key,
            passphrase: config.passphrase,
            cert: config.certificate
        }, (value) => value == null);
        const proxyOptions = Object.assign({}, parsedProxyURL, proxyOverrides);
        let HttpsProxyAgent;
        try {
            HttpsProxyAgent = require('https-proxy-agent');
        }
        catch (error) {
            throw new Error('"proxy" option is not supported in the browser');
        }
        options.agent = new HttpsProxyAgent(proxyOptions);
    }
    if (config.authorization != null) {
        const base64 = Buffer.from(config.authorization).toString('base64');
        options.headers = { Authorization: `Basic ${base64}` };
    }
    const optionsOverrides = _.omitBy({
        ca: config.trustedCertificates,
        key: config.key,
        passphrase: config.passphrase,
        cert: config.certificate
    }, (value) => value == null);
    const websocketOptions = Object.assign({}, options, optionsOverrides);
    const websocket = new ws_1.default(url, null, websocketOptions);
    if (typeof websocket.setMaxListeners === 'function') {
        websocket.setMaxListeners(Infinity);
    }
    return websocket;
}
function websocketSendAsync(ws, message) {
    return new Promise((resolve, reject) => {
        ws.send(message, undefined, (error) => {
            if (error) {
                reject(new errors_1.DisconnectedError(error.message, error));
            }
            else {
                resolve();
            }
        });
    });
}
class LedgerHistory {
    constructor() {
        this.feeBase = null;
        this.feeRef = null;
        this.latestVersion = null;
        this.reserveBase = null;
        this.availableVersions = new rangeset_1.default();
    }
    hasVersion(version) {
        return this.availableVersions.containsValue(version);
    }
    hasVersions(lowVersion, highVersion) {
        return this.availableVersions.containsRange(lowVersion, highVersion);
    }
    update(ledgerMessage) {
        this.feeBase = ledgerMessage.fee_base;
        this.feeRef = ledgerMessage.fee_ref;
        this.latestVersion = ledgerMessage.ledger_index;
        this.reserveBase = ledgerMessage.reserve_base;
        if (ledgerMessage.validated_ledgers) {
            this.availableVersions.reset();
            this.availableVersions.parseAndAddRanges(ledgerMessage.validated_ledgers);
        }
        else {
            this.availableVersions.addValue(this.latestVersion);
        }
    }
}
class ConnectionManager {
    constructor() {
        this.promisesAwaitingConnection = [];
    }
    resolveAllAwaiting() {
        this.promisesAwaitingConnection.map(({ resolve }) => resolve());
        this.promisesAwaitingConnection = [];
    }
    rejectAllAwaiting(error) {
        this.promisesAwaitingConnection.map(({ reject }) => reject(error));
        this.promisesAwaitingConnection = [];
    }
    awaitConnection() {
        return new Promise((resolve, reject) => {
            this.promisesAwaitingConnection.push({ resolve, reject });
        });
    }
}
class RequestManager {
    constructor() {
        this.nextId = 0;
        this.promisesAwaitingResponse = [];
    }
    cancel(id) {
        const { timer } = this.promisesAwaitingResponse[id];
        clearTimeout(timer);
        delete this.promisesAwaitingResponse[id];
    }
    resolve(id, data) {
        const { timer, resolve } = this.promisesAwaitingResponse[id];
        clearTimeout(timer);
        resolve(data);
        delete this.promisesAwaitingResponse[id];
    }
    reject(id, error) {
        const { timer, reject } = this.promisesAwaitingResponse[id];
        clearTimeout(timer);
        reject(error);
        delete this.promisesAwaitingResponse[id];
    }
    rejectAll(error) {
        this.promisesAwaitingResponse.forEach((_, id) => {
            this.reject(id, error);
        });
    }
    createRequest(data, timeout) {
        const newId = this.nextId++;
        const newData = JSON.stringify(Object.assign(Object.assign({}, data), { id: newId }));
        const timer = setTimeout(() => this.reject(newId, new errors_1.TimeoutError()), timeout);
        if (timer.unref) {
            timer.unref();
        }
        const newPromise = new Promise((resolve, reject) => {
            this.promisesAwaitingResponse[newId] = { resolve, reject, timer };
        });
        return [newId, newData, newPromise];
    }
    handleResponse(data) {
        if (!Number.isInteger(data.id) || data.id < 0) {
            throw new errors_1.ResponseFormatError('valid id not found in response', data);
        }
        if (!this.promisesAwaitingResponse[data.id]) {
            return;
        }
        if (data.status === 'error') {
            const error = new errors_1.RippledError(data.error_message || data.error, data);
            this.reject(data.id, error);
            return;
        }
        if (data.status !== 'success') {
            const error = new errors_1.ResponseFormatError(`unrecognized status: ${data.status}`, data);
            this.reject(data.id, error);
            return;
        }
        this.resolve(data.id, data.result);
    }
}
class Connection extends events_1.EventEmitter {
    constructor(url, options = {}) {
        super();
        this._ws = null;
        this._reconnectTimeoutID = null;
        this._heartbeatIntervalID = null;
        this._retryConnectionBackoff = new backoff_1.ExponentialBackoff({
            min: 100,
            max: 60 * 1000
        });
        this._trace = () => { };
        this._ledger = new LedgerHistory();
        this._requestManager = new RequestManager();
        this._connectionManager = new ConnectionManager();
        this._clearHeartbeatInterval = () => {
            clearInterval(this._heartbeatIntervalID);
        };
        this._startHeartbeatInterval = () => {
            this._clearHeartbeatInterval();
            this._heartbeatIntervalID = setInterval(() => this._heartbeat(), this._config.timeout);
        };
        this._heartbeat = () => {
            return this.request({ command: 'ping' }).catch(() => {
                return this.reconnect().catch((error) => {
                    this.emit('error', 'reconnect', error.message, error);
                });
            });
        };
        this._onConnectionFailed = (errorOrCode) => {
            if (this._ws) {
                this._ws.removeAllListeners();
                this._ws.on('error', () => {
                });
                this._ws.close();
                this._ws = null;
            }
            if (typeof errorOrCode === 'number') {
                this._connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(`Connection failed with code ${errorOrCode}.`, {
                    code: errorOrCode
                }));
            }
            else if (errorOrCode && errorOrCode.message) {
                this._connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError(errorOrCode.message, errorOrCode));
            }
            else {
                this._connectionManager.rejectAllAwaiting(new errors_1.NotConnectedError('Connection failed.'));
            }
        };
        this.setMaxListeners(Infinity);
        this._url = url;
        this._config = Object.assign({ timeout: 20 * 1000, connectionTimeout: 5 * 1000 }, options);
        if (typeof options.trace === 'function') {
            this._trace = options.trace;
        }
        else if (options.trace === true) {
            this._trace = console.log;
        }
    }
    _onMessage(message) {
        this._trace('receive', message);
        let data;
        try {
            data = JSON.parse(message);
        }
        catch (error) {
            this.emit('error', 'badMessage', error.message, message);
            return;
        }
        if (data.type == null && data.error) {
            this.emit('error', data.error, data.error_message, data);
            return;
        }
        if (data.type) {
            this.emit(data.type, data);
        }
        if (data.type === 'ledgerClosed') {
            this._ledger.update(data);
        }
        if (data.type === 'response') {
            try {
                this._requestManager.handleResponse(data);
            }
            catch (error) {
                this.emit('error', 'badMessage', error.message, message);
            }
        }
    }
    get _state() {
        return this._ws ? this._ws.readyState : ws_1.default.CLOSED;
    }
    get _shouldBeConnected() {
        return this._ws !== null;
    }
    _waitForReady() {
        return new Promise((resolve, reject) => {
            if (!this._shouldBeConnected) {
                reject(new errors_1.NotConnectedError());
            }
            else if (this._state === ws_1.default.OPEN) {
                resolve();
            }
            else {
                this.once('connected', () => resolve());
            }
        });
    }
    _subscribeToLedger() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield this.request({
                command: 'subscribe',
                streams: ['ledger']
            });
            if (_.isEmpty(data) || !data.ledger_index) {
                try {
                    yield this.disconnect();
                }
                catch (error) {
                }
                finally {
                    throw new errors_1.RippledNotInitializedError('Rippled not initialized');
                }
            }
            this._ledger.update(data);
        });
    }
    isConnected() {
        return this._state === ws_1.default.OPEN;
    }
    connect() {
        if (this.isConnected()) {
            return Promise.resolve();
        }
        if (this._state === ws_1.default.CONNECTING) {
            return this._connectionManager.awaitConnection();
        }
        if (!this._url) {
            return Promise.reject(new errors_1.ConnectionError('Cannot connect because no server was specified'));
        }
        if (this._ws) {
            return Promise.reject(new errors_1.RippleError('Websocket connection never cleaned up.', {
                state: this._state
            }));
        }
        const connectionTimeoutID = setTimeout(() => {
            this._onConnectionFailed(new errors_1.ConnectionError(`Error: connect() timed out after ${this._config.connectionTimeout} ms. ` +
                `If your internet connection is working, the rippled server may be blocked or inaccessible. ` +
                `You can also try setting the 'connectionTimeout' option in the RippleAPI constructor.`));
        }, this._config.connectionTimeout);
        this._ws = createWebSocket(this._url, this._config);
        this._ws.on('error', this._onConnectionFailed);
        this._ws.on('error', () => clearTimeout(connectionTimeoutID));
        this._ws.on('close', this._onConnectionFailed);
        this._ws.on('close', () => clearTimeout(connectionTimeoutID));
        this._ws.once('open', () => __awaiter(this, void 0, void 0, function* () {
            this._ws.removeAllListeners();
            clearTimeout(connectionTimeoutID);
            this._ws.on('message', (message) => this._onMessage(message));
            this._ws.on('error', (error) => this.emit('error', 'websocket', error.message, error));
            this._ws.once('close', (code) => {
                this._clearHeartbeatInterval();
                this._requestManager.rejectAll(new errors_1.DisconnectedError('websocket was closed'));
                this._ws.removeAllListeners();
                this._ws = null;
                this.emit('disconnected', code);
                if (code !== INTENTIONAL_DISCONNECT_CODE) {
                    const retryTimeout = this._retryConnectionBackoff.duration();
                    this._trace('reconnect', `Retrying connection in ${retryTimeout}ms.`);
                    this.emit('reconnecting', this._retryConnectionBackoff.attempts);
                    this._reconnectTimeoutID = setTimeout(() => {
                        this.reconnect().catch((error) => {
                            this.emit('error', 'reconnect', error.message, error);
                        });
                    }, retryTimeout);
                }
            });
            try {
                this._retryConnectionBackoff.reset();
                yield this._subscribeToLedger();
                this._startHeartbeatInterval();
                this._connectionManager.resolveAllAwaiting();
                this.emit('connected');
            }
            catch (error) {
                this._connectionManager.rejectAllAwaiting(error);
                yield this.disconnect().catch(() => { });
            }
        }));
        return this._connectionManager.awaitConnection();
    }
    disconnect() {
        clearTimeout(this._reconnectTimeoutID);
        this._reconnectTimeoutID = null;
        if (this._state === ws_1.default.CLOSED || !this._ws) {
            return Promise.resolve(undefined);
        }
        return new Promise((resolve) => {
            this._ws.once('close', (code) => resolve(code));
            if (this._state !== ws_1.default.CLOSING) {
                this._ws.close(INTENTIONAL_DISCONNECT_CODE);
            }
        });
    }
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            this.emit('reconnect');
            yield this.disconnect();
            yield this.connect();
        });
    }
    getFeeBase() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._waitForReady();
            return this._ledger.feeBase;
        });
    }
    getFeeRef() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._waitForReady();
            return this._ledger.feeRef;
        });
    }
    getLedgerVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._waitForReady();
            return this._ledger.latestVersion;
        });
    }
    getReserveBase() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._waitForReady();
            return this._ledger.reserveBase;
        });
    }
    hasLedgerVersions(lowLedgerVersion, highLedgerVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!highLedgerVersion) {
                return this.hasLedgerVersion(lowLedgerVersion);
            }
            yield this._waitForReady();
            return this._ledger.hasVersions(lowLedgerVersion, highLedgerVersion);
        });
    }
    hasLedgerVersion(ledgerVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._waitForReady();
            return this._ledger.hasVersion(ledgerVersion);
        });
    }
    request(request, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._shouldBeConnected) {
                throw new errors_1.NotConnectedError();
            }
            const [id, message, responsePromise] = this._requestManager.createRequest(request, timeout || this._config.timeout);
            this._trace('send', message);
            websocketSendAsync(this._ws, message).catch((error) => {
                this._requestManager.reject(id, error);
            });
            return responsePromise;
        });
    }
    getUrl() {
        return this._url;
    }
}
exports.Connection = Connection;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\connection.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\constants.js", {"./txflags":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\txflags.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cconstants.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountFlags = exports.AccountSetFlags = exports.AccountFields = void 0;
const txflags_1 = require("./txflags");
const accountRootFlags = {
    DefaultRipple: 0x00800000,
    DepositAuth: 0x01000000,
    DisableMaster: 0x00100000,
    DisallowXRP: 0x00080000,
    GlobalFreeze: 0x00400000,
    NoFreeze: 0x00200000,
    PasswordSpent: 0x00010000,
    RequireAuth: 0x00040000,
    RequireDestTag: 0x00020000
};
const AccountFlags = {
    passwordSpent: accountRootFlags.PasswordSpent,
    requireDestinationTag: accountRootFlags.RequireDestTag,
    requireAuthorization: accountRootFlags.RequireAuth,
    depositAuth: accountRootFlags.DepositAuth,
    disallowIncomingXRP: accountRootFlags.DisallowXRP,
    disableMasterKey: accountRootFlags.DisableMaster,
    noFreeze: accountRootFlags.NoFreeze,
    globalFreeze: accountRootFlags.GlobalFreeze,
    defaultRipple: accountRootFlags.DefaultRipple
};
exports.AccountFlags = AccountFlags;
const AccountSetFlags = {
    requireDestinationTag: txflags_1.txFlagIndices.AccountSet.asfRequireDest,
    requireAuthorization: txflags_1.txFlagIndices.AccountSet.asfRequireAuth,
    depositAuth: txflags_1.txFlagIndices.AccountSet.asfDepositAuth,
    disallowIncomingXRP: txflags_1.txFlagIndices.AccountSet.asfDisallowXRP,
    disableMasterKey: txflags_1.txFlagIndices.AccountSet.asfDisableMaster,
    enableTransactionIDTracking: txflags_1.txFlagIndices.AccountSet.asfAccountTxnID,
    noFreeze: txflags_1.txFlagIndices.AccountSet.asfNoFreeze,
    globalFreeze: txflags_1.txFlagIndices.AccountSet.asfGlobalFreeze,
    defaultRipple: txflags_1.txFlagIndices.AccountSet.asfDefaultRipple
};
exports.AccountSetFlags = AccountSetFlags;
const AccountFields = {
    EmailHash: {
        name: 'emailHash',
        encoding: 'hex',
        length: 32,
        defaults: '00000000000000000000000000000000'
    },
    WalletLocator: { name: 'walletLocator' },
    MessageKey: { name: 'messageKey' },
    Domain: { name: 'domain', encoding: 'hex' },
    TransferRate: { name: 'transferRate', defaults: 0, shift: 9 },
    TickSize: { name: 'tickSize', defaults: 0 }
};
exports.AccountFields = AccountFields;
//# sourceMappingURL=constants.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\constants.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\errors.js", {"./browser-hacks":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\browser-hacks.js","util":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cerrors.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XRPLFaucetError = exports.LedgerVersionError = exports.MissingLedgerHistoryError = exports.PendingLedgerVersionError = exports.NotFoundError = exports.ValidationError = exports.ResponseFormatError = exports.TimeoutError = exports.RippledNotInitializedError = exports.DisconnectedError = exports.NotConnectedError = exports.RippledError = exports.ConnectionError = exports.UnexpectedError = exports.RippleError = void 0;
const util_1 = require("util");
const browserHacks = __importStar(require("./browser-hacks"));
class RippleError extends Error {
    constructor(message = '', data) {
        super(message);
        this.name = browserHacks.getConstructorName(this);
        this.message = message;
        this.data = data;
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
    toString() {
        let result = '[' + this.name + '(' + this.message;
        if (this.data) {
            result += ', ' + util_1.inspect(this.data);
        }
        result += ')]';
        return result;
    }
    inspect() {
        return this.toString();
    }
}
exports.RippleError = RippleError;
class RippledError extends RippleError {
}
exports.RippledError = RippledError;
class UnexpectedError extends RippleError {
}
exports.UnexpectedError = UnexpectedError;
class LedgerVersionError extends RippleError {
}
exports.LedgerVersionError = LedgerVersionError;
class ConnectionError extends RippleError {
}
exports.ConnectionError = ConnectionError;
class NotConnectedError extends ConnectionError {
}
exports.NotConnectedError = NotConnectedError;
class DisconnectedError extends ConnectionError {
}
exports.DisconnectedError = DisconnectedError;
class RippledNotInitializedError extends ConnectionError {
}
exports.RippledNotInitializedError = RippledNotInitializedError;
class TimeoutError extends ConnectionError {
}
exports.TimeoutError = TimeoutError;
class ResponseFormatError extends ConnectionError {
}
exports.ResponseFormatError = ResponseFormatError;
class ValidationError extends RippleError {
}
exports.ValidationError = ValidationError;
class XRPLFaucetError extends RippleError {
}
exports.XRPLFaucetError = XRPLFaucetError;
class NotFoundError extends RippleError {
    constructor(message = 'Not found') {
        super(message);
    }
}
exports.NotFoundError = NotFoundError;
class MissingLedgerHistoryError extends RippleError {
    constructor(message) {
        super(message || 'Server is missing ledger history in the specified range');
    }
}
exports.MissingLedgerHistoryError = MissingLedgerHistoryError;
class PendingLedgerVersionError extends RippleError {
    constructor(message) {
        super(message ||
            "maxLedgerVersion is greater than server's most recent" +
                ' validated ledger');
    }
}
exports.PendingLedgerVersionError = PendingLedgerVersionError;
//# sourceMappingURL=errors.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\errors.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\hash-prefix.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Chashes%5Chash-prefix.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var HashPrefix;
(function (HashPrefix) {
    HashPrefix[HashPrefix["TRANSACTION_ID"] = 1415073280] = "TRANSACTION_ID";
    HashPrefix[HashPrefix["TRANSACTION_NODE"] = 1397638144] = "TRANSACTION_NODE";
    HashPrefix[HashPrefix["INNER_NODE"] = 1296649728] = "INNER_NODE";
    HashPrefix[HashPrefix["LEAF_NODE"] = 1296846336] = "LEAF_NODE";
    HashPrefix[HashPrefix["TRANSACTION_SIGN"] = 1398036480] = "TRANSACTION_SIGN";
    HashPrefix[HashPrefix["TRANSACTION_SIGN_TESTNET"] = 1937012736] = "TRANSACTION_SIGN_TESTNET";
    HashPrefix[HashPrefix["TRANSACTION_MULTISIGN"] = 1397576704] = "TRANSACTION_MULTISIGN";
    HashPrefix[HashPrefix["LEDGER"] = 1280791040] = "LEDGER";
})(HashPrefix || (HashPrefix = {}));
exports.default = HashPrefix;
//# sourceMappingURL=hash-prefix.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\hash-prefix.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\index.js", {"./hash-prefix":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\hash-prefix.js","./ledgerspaces":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\ledgerspaces.js","./sha512Half":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\sha512Half.js","./shamap":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\shamap.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js","ripple-binary-codec":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Chashes%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computePaymentChannelHash = exports.computeEscrowHash = exports.computeLedgerHash = exports.computeStateTreeHash = exports.computeTransactionTreeHash = exports.computeTrustlineHash = exports.computeOrderID = exports.computeSignerListLedgerObjectID = exports.computeAccountLedgerObjectID = exports.computeBinaryTransactionSigningHash = exports.computeTransactionHash = exports.computeBinaryTransactionHash = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ripple_address_codec_1 = require("ripple-address-codec");
const sha512Half_1 = __importDefault(require("./sha512Half"));
const hash_prefix_1 = __importDefault(require("./hash-prefix"));
const shamap_1 = require("./shamap");
const ripple_binary_codec_1 = require("ripple-binary-codec");
const ledgerspaces_1 = __importDefault(require("./ledgerspaces"));
const padLeftZero = (string, length) => {
    return Array(length - string.length + 1).join('0') + string;
};
const intToHex = (integer, byteLength) => {
    return padLeftZero(Number(integer).toString(16), byteLength * 2);
};
const bytesToHex = (bytes) => {
    return Buffer.from(bytes).toString('hex');
};
const bigintToHex = (integerString, byteLength) => {
    const hex = new bignumber_js_1.default(integerString).toString(16);
    return padLeftZero(hex, byteLength * 2);
};
const ledgerSpaceHex = (name) => {
    return intToHex(ledgerspaces_1.default[name].charCodeAt(0), 2);
};
const addressToHex = (address) => {
    return Buffer.from(ripple_address_codec_1.decodeAccountID(address)).toString('hex');
};
const currencyToHex = (currency) => {
    if (currency.length === 3) {
        const bytes = new Array(20 + 1).join('0').split('').map(parseFloat);
        bytes[12] = currency.charCodeAt(0) & 0xff;
        bytes[13] = currency.charCodeAt(1) & 0xff;
        bytes[14] = currency.charCodeAt(2) & 0xff;
        return bytesToHex(bytes);
    }
    return currency;
};
const addLengthPrefix = (hex) => {
    const length = hex.length / 2;
    if (length <= 192) {
        return bytesToHex([length]) + hex;
    }
    else if (length <= 12480) {
        const x = length - 193;
        return bytesToHex([193 + (x >>> 8), x & 0xff]) + hex;
    }
    else if (length <= 918744) {
        const x = length - 12481;
        return bytesToHex([241 + (x >>> 16), (x >>> 8) & 0xff, x & 0xff]) + hex;
    }
    throw new Error('Variable integer overflow.');
};
exports.computeBinaryTransactionHash = (txBlobHex) => {
    const prefix = hash_prefix_1.default.TRANSACTION_ID.toString(16).toUpperCase();
    return sha512Half_1.default(prefix + txBlobHex);
};
exports.computeTransactionHash = (txJSON) => {
    return exports.computeBinaryTransactionHash(ripple_binary_codec_1.encode(txJSON));
};
exports.computeBinaryTransactionSigningHash = (txBlobHex) => {
    const prefix = hash_prefix_1.default.TRANSACTION_SIGN.toString(16).toUpperCase();
    return sha512Half_1.default(prefix + txBlobHex);
};
exports.computeAccountLedgerObjectID = (address) => {
    return sha512Half_1.default(ledgerSpaceHex('account') + addressToHex(address));
};
exports.computeSignerListLedgerObjectID = (address) => {
    return sha512Half_1.default(ledgerSpaceHex('signerList') + addressToHex(address) + '00000000');
};
exports.computeOrderID = (address, sequence) => {
    const prefix = '00' + intToHex(ledgerspaces_1.default.offer.charCodeAt(0), 1);
    return sha512Half_1.default(prefix + addressToHex(address) + intToHex(sequence, 4));
};
exports.computeTrustlineHash = (address1, address2, currency) => {
    const address1Hex = addressToHex(address1);
    const address2Hex = addressToHex(address2);
    const swap = new bignumber_js_1.default(address1Hex, 16).isGreaterThan(new bignumber_js_1.default(address2Hex, 16));
    const lowAddressHex = swap ? address2Hex : address1Hex;
    const highAddressHex = swap ? address1Hex : address2Hex;
    const prefix = ledgerSpaceHex('rippleState');
    return sha512Half_1.default(prefix + lowAddressHex + highAddressHex + currencyToHex(currency));
};
exports.computeTransactionTreeHash = (transactions) => {
    const shamap = new shamap_1.SHAMap();
    transactions.forEach((txJSON) => {
        const txBlobHex = ripple_binary_codec_1.encode(txJSON);
        const metaHex = ripple_binary_codec_1.encode(txJSON.metaData);
        const txHash = exports.computeBinaryTransactionHash(txBlobHex);
        const data = addLengthPrefix(txBlobHex) + addLengthPrefix(metaHex);
        shamap.addItem(txHash, data, shamap_1.NodeType.TRANSACTION_METADATA);
    });
    return shamap.hash;
};
exports.computeStateTreeHash = (entries) => {
    const shamap = new shamap_1.SHAMap();
    entries.forEach((ledgerEntry) => {
        const data = ripple_binary_codec_1.encode(ledgerEntry);
        shamap.addItem(ledgerEntry.index, data, shamap_1.NodeType.ACCOUNT_STATE);
    });
    return shamap.hash;
};
exports.computeLedgerHash = (ledgerHeader) => {
    const prefix = hash_prefix_1.default.LEDGER.toString(16).toUpperCase();
    return sha512Half_1.default(prefix +
        intToHex(ledgerHeader.ledger_index, 4) +
        bigintToHex(ledgerHeader.total_coins, 8) +
        ledgerHeader.parent_hash +
        ledgerHeader.transaction_hash +
        ledgerHeader.account_hash +
        intToHex(ledgerHeader.parent_close_time, 4) +
        intToHex(ledgerHeader.close_time, 4) +
        intToHex(ledgerHeader.close_time_resolution, 1) +
        intToHex(ledgerHeader.close_flags, 1));
};
exports.computeEscrowHash = (address, sequence) => {
    return sha512Half_1.default(ledgerSpaceHex('escrow') + addressToHex(address) + intToHex(sequence, 4));
};
exports.computePaymentChannelHash = (address, dstAddress, sequence) => {
    return sha512Half_1.default(ledgerSpaceHex('paychan') +
        addressToHex(address) +
        addressToHex(dstAddress) +
        intToHex(sequence, 4));
};

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\ledgerspaces.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Chashes%5Cledgerspaces.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    account: 'a',
    dirNode: 'd',
    generatorMap: 'g',
    rippleState: 'r',
    offer: 'o',
    ownerDir: 'O',
    bookDir: 'B',
    contract: 'c',
    skipList: 's',
    escrow: 'u',
    amendment: 'f',
    feeSettings: 'e',
    ticket: 'T',
    signerList: 'S',
    paychan: 'x',
    check: 'C',
    depositPreauth: 'p'
};
//# sourceMappingURL=ledgerspaces.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\ledgerspaces.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\sha512Half.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","crypto":"F:\\metamask-extension\\node_modules\\crypto-browserify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Chashes%5Csha512Half.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const sha512Half = (hex) => {
    return crypto_1.createHash('sha512')
        .update(Buffer.from(hex, 'hex'))
        .digest('hex')
        .toUpperCase()
        .slice(0, 64);
};
exports.default = sha512Half;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\sha512Half.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\shamap.js", {"./hash-prefix":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\hash-prefix.js","./sha512Half":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\sha512Half.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Chashes%5Cshamap.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHAMap = exports.Leaf = exports.InnerNode = exports.Node = exports.NodeType = void 0;
const hash_prefix_1 = __importDefault(require("./hash-prefix"));
const sha512Half_1 = __importDefault(require("./sha512Half"));
const HEX_ZERO = '0000000000000000000000000000000000000000000000000000000000000000';
var NodeType;
(function (NodeType) {
    NodeType[NodeType["INNER"] = 1] = "INNER";
    NodeType[NodeType["TRANSACTION_NO_METADATA"] = 2] = "TRANSACTION_NO_METADATA";
    NodeType[NodeType["TRANSACTION_METADATA"] = 3] = "TRANSACTION_METADATA";
    NodeType[NodeType["ACCOUNT_STATE"] = 4] = "ACCOUNT_STATE";
})(NodeType = exports.NodeType || (exports.NodeType = {}));
class Node {
    constructor() { }
    addItem(_tag, _node) {
        throw new Error('Called unimplemented virtual method SHAMapTreeNode#addItem.');
    }
    get hash() {
        throw new Error('Called unimplemented virtual method SHAMapTreeNode#hash.');
    }
}
exports.Node = Node;
class InnerNode extends Node {
    constructor(depth = 0) {
        super();
        this.leaves = {};
        this.type = NodeType.INNER;
        this.depth = depth;
        this.empty = true;
    }
    addItem(tag, node) {
        const existingNode = this.getNode(parseInt(tag[this.depth], 16));
        if (existingNode) {
            if (existingNode instanceof InnerNode) {
                existingNode.addItem(tag, node);
            }
            else if (existingNode instanceof Leaf) {
                if (existingNode.tag === tag) {
                    throw new Error('Tried to add a node to a SHAMap that was already in there.');
                }
                else {
                    const newInnerNode = new InnerNode(this.depth + 1);
                    newInnerNode.addItem(existingNode.tag, existingNode);
                    newInnerNode.addItem(tag, node);
                    this.setNode(parseInt(tag[this.depth], 16), newInnerNode);
                }
            }
        }
        else {
            this.setNode(parseInt(tag[this.depth], 16), node);
        }
    }
    setNode(slot, node) {
        if (slot < 0 || slot > 15) {
            throw new Error('Invalid slot: slot must be between 0-15.');
        }
        this.leaves[slot] = node;
        this.empty = false;
    }
    getNode(slot) {
        if (slot < 0 || slot > 15) {
            throw new Error('Invalid slot: slot must be between 0-15.');
        }
        return this.leaves[slot];
    }
    get hash() {
        if (this.empty)
            return HEX_ZERO;
        let hex = '';
        for (let i = 0; i < 16; i++) {
            hex += this.leaves[i] ? this.leaves[i].hash : HEX_ZERO;
        }
        const prefix = hash_prefix_1.default.INNER_NODE.toString(16);
        return sha512Half_1.default(prefix + hex);
    }
}
exports.InnerNode = InnerNode;
class Leaf extends Node {
    constructor(tag, data, type) {
        super();
        this.tag = tag;
        this.type = type;
        this.data = data;
    }
    get hash() {
        switch (this.type) {
            case NodeType.ACCOUNT_STATE: {
                const leafPrefix = hash_prefix_1.default.LEAF_NODE.toString(16);
                return sha512Half_1.default(leafPrefix + this.data + this.tag);
            }
            case NodeType.TRANSACTION_NO_METADATA: {
                const txIDPrefix = hash_prefix_1.default.TRANSACTION_ID.toString(16);
                return sha512Half_1.default(txIDPrefix + this.data);
            }
            case NodeType.TRANSACTION_METADATA: {
                const txNodePrefix = hash_prefix_1.default.TRANSACTION_NODE.toString(16);
                return sha512Half_1.default(txNodePrefix + this.data + this.tag);
            }
            default:
                throw new Error('Tried to hash a SHAMap node of unknown type.');
        }
    }
}
exports.Leaf = Leaf;
class SHAMap {
    constructor() {
        this.root = new InnerNode(0);
    }
    addItem(tag, data, type) {
        this.root.addItem(tag, new Leaf(tag, data, type));
    }
    get hash() {
        return this.root.hash;
    }
}
exports.SHAMap = SHAMap;
//# sourceMappingURL=shamap.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\shamap.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js", {"./connection":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\connection.js","./constants":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\constants.js","./errors":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\errors.js","./serverinfo":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\serverinfo.js","./txflags":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\txflags.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\utils.js","./validate":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\validate.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serverInfo = exports.validate = exports.errors = exports.constants = exports.ensureClassicAddress = void 0;
const constants = __importStar(require("./constants"));
exports.constants = constants;
const errors = __importStar(require("./errors"));
exports.errors = errors;
const validate = __importStar(require("./validate"));
exports.validate = validate;
const serverInfo = __importStar(require("./serverinfo"));
exports.serverInfo = serverInfo;
const ripple_address_codec_1 = require("ripple-address-codec");
function ensureClassicAddress(account) {
    if (ripple_address_codec_1.isValidXAddress(account)) {
        const { classicAddress, tag } = ripple_address_codec_1.xAddressToClassicAddress(account);
        if (tag !== false) {
            throw new Error('This command does not support the use of a tag. Use an address without a tag.');
        }
        return classicAddress;
    }
    else {
        return account;
    }
}
exports.ensureClassicAddress = ensureClassicAddress;
var utils_1 = require("./utils");
Object.defineProperty(exports, "dropsToXrp", { enumerable: true, get: function () { return utils_1.dropsToXrp; } });
Object.defineProperty(exports, "xrpToDrops", { enumerable: true, get: function () { return utils_1.xrpToDrops; } });
Object.defineProperty(exports, "toRippledAmount", { enumerable: true, get: function () { return utils_1.toRippledAmount; } });
Object.defineProperty(exports, "removeUndefined", { enumerable: true, get: function () { return utils_1.removeUndefined; } });
Object.defineProperty(exports, "convertKeysFromSnakeCaseToCamelCase", { enumerable: true, get: function () { return utils_1.convertKeysFromSnakeCaseToCamelCase; } });
Object.defineProperty(exports, "iso8601ToRippleTime", { enumerable: true, get: function () { return utils_1.iso8601ToRippleTime; } });
Object.defineProperty(exports, "rippleTimeToISO8601", { enumerable: true, get: function () { return utils_1.rippleTimeToISO8601; } });
var connection_1 = require("./connection");
Object.defineProperty(exports, "Connection", { enumerable: true, get: function () { return connection_1.Connection; } });
var txflags_1 = require("./txflags");
Object.defineProperty(exports, "txFlags", { enumerable: true, get: function () { return txflags_1.txFlags; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\rangeset.js", {"assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Crangeset.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const assert = __importStar(require("assert"));
function mergeIntervals(intervals) {
    const stack = [[-Infinity, -Infinity]];
    _.sortBy(intervals, (x) => x[0]).forEach((interval) => {
        const lastInterval = stack.pop();
        if (interval[0] <= lastInterval[1] + 1) {
            stack.push([lastInterval[0], Math.max(interval[1], lastInterval[1])]);
        }
        else {
            stack.push(lastInterval);
            stack.push(interval);
        }
    });
    return stack.slice(1);
}
class RangeSet {
    constructor() {
        this.reset();
    }
    reset() {
        this.ranges = [];
    }
    serialize() {
        return this.ranges
            .map((range) => range[0].toString() + '-' + range[1].toString())
            .join(',');
    }
    addRange(start, end) {
        assert.ok(start <= end, `invalid range ${start} <= ${end}`);
        this.ranges = mergeIntervals(this.ranges.concat([[start, end]]));
    }
    addValue(value) {
        this.addRange(value, value);
    }
    parseAndAddRanges(rangesString) {
        const rangeStrings = rangesString.split(',');
        rangeStrings.forEach((rangeString) => {
            const range = rangeString.split('-').map(Number);
            this.addRange(range[0], range.length === 1 ? range[0] : range[1]);
        });
    }
    containsRange(start, end) {
        return this.ranges.some((range) => range[0] <= start && range[1] >= end);
    }
    containsValue(value) {
        return this.containsRange(value, value);
    }
}
exports.default = RangeSet;
//# sourceMappingURL=rangeset.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\rangeset.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schema-validator.js", {"./errors":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\errors.js","./schemas/input/api-options.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\api-options.json","./schemas/input/combine.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\combine.json","./schemas/input/compute-ledger-hash.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\compute-ledger-hash.json","./schemas/input/generate-address.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\generate-address.json","./schemas/input/get-account-info.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-account-info.json","./schemas/input/get-account-objects.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-account-objects.json","./schemas/input/get-balance-sheet.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-balance-sheet.json","./schemas/input/get-balances.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-balances.json","./schemas/input/get-ledger.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-ledger.json","./schemas/input/get-orderbook.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-orderbook.json","./schemas/input/get-orders.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-orders.json","./schemas/input/get-paths.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-paths.json","./schemas/input/get-payment-channel.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-payment-channel.json","./schemas/input/get-settings.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-settings.json","./schemas/input/get-transaction.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-transaction.json","./schemas/input/get-transactions.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-transactions.json","./schemas/input/get-trustlines.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-trustlines.json","./schemas/input/prepare-check-cancel.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-check-cancel.json","./schemas/input/prepare-check-cash.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-check-cash.json","./schemas/input/prepare-check-create.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-check-create.json","./schemas/input/prepare-escrow-cancellation.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-escrow-cancellation.json","./schemas/input/prepare-escrow-creation.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-escrow-creation.json","./schemas/input/prepare-escrow-execution.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-escrow-execution.json","./schemas/input/prepare-order-cancellation.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-order-cancellation.json","./schemas/input/prepare-order.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-order.json","./schemas/input/prepare-payment-channel-claim.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment-channel-claim.json","./schemas/input/prepare-payment-channel-create.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment-channel-create.json","./schemas/input/prepare-payment-channel-fund.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment-channel-fund.json","./schemas/input/prepare-payment.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment.json","./schemas/input/prepare-settings.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-settings.json","./schemas/input/prepare-ticket-create.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-ticket-create.json","./schemas/input/prepare-trustline.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-trustline.json","./schemas/input/sign-payment-channel-claim.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\sign-payment-channel-claim.json","./schemas/input/sign.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\sign.json","./schemas/input/submit.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\submit.json","./schemas/input/verify-payment-channel-claim.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\verify-payment-channel-claim.json","./schemas/objects/address.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\address.json","./schemas/objects/adjustment.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\adjustment.json","./schemas/objects/amount.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\amount.json","./schemas/objects/amountbase.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\amountbase.json","./schemas/objects/balance.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\balance.json","./schemas/objects/blob.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\blob.json","./schemas/objects/classic-address.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\classic-address.json","./schemas/objects/currency.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\currency.json","./schemas/objects/destination-address-tag.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\destination-address-tag.json","./schemas/objects/destination-adjustment.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\destination-adjustment.json","./schemas/objects/destination-exact-adjustment.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\destination-exact-adjustment.json","./schemas/objects/hash128.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\hash128.json","./schemas/objects/hash256.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\hash256.json","./schemas/objects/instructions.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\instructions.json","./schemas/objects/issue.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\issue.json","./schemas/objects/lax-amount.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\lax-amount.json","./schemas/objects/lax-lax-amount.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\lax-lax-amount.json","./schemas/objects/ledger-version.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\ledger-version.json","./schemas/objects/max-adjustment.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\max-adjustment.json","./schemas/objects/memo.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\memo.json","./schemas/objects/memos.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\memos.json","./schemas/objects/min-adjustment.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\min-adjustment.json","./schemas/objects/orderbook.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\orderbook.json","./schemas/objects/private-key.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\private-key.json","./schemas/objects/public-key.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\public-key.json","./schemas/objects/quality.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\quality.json","./schemas/objects/sequence.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\sequence.json","./schemas/objects/settings-plus-memos.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\settings-plus-memos.json","./schemas/objects/signature.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\signature.json","./schemas/objects/signed-value.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\signed-value.json","./schemas/objects/source-adjustment.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\source-adjustment.json","./schemas/objects/source-exact-adjustment.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\source-exact-adjustment.json","./schemas/objects/tag.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\tag.json","./schemas/objects/ticket-sequence.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\ticket-sequence.json","./schemas/objects/transaction-hash.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\transaction-hash.json","./schemas/objects/transaction-type.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\transaction-type.json","./schemas/objects/tx-json.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\tx-json.json","./schemas/objects/uint32.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\uint32.json","./schemas/objects/value.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\value.json","./schemas/objects/x-address.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\x-address.json","./schemas/output/get-account-info.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-account-info.json","./schemas/output/get-account-objects.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-account-objects.json","./schemas/output/get-balance-sheet.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-balance-sheet.json","./schemas/output/get-balances.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-balances.json","./schemas/output/get-ledger.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-ledger.json","./schemas/output/get-orderbook.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-orderbook.json","./schemas/output/get-orders.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-orders.json","./schemas/output/get-paths.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-paths.json","./schemas/output/get-payment-channel.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-payment-channel.json","./schemas/output/get-server-info.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-server-info.json","./schemas/output/get-settings.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-settings.json","./schemas/output/get-transaction.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-transaction.json","./schemas/output/get-transactions.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-transactions.json","./schemas/output/get-trustlines.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-trustlines.json","./schemas/output/ledger-event.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\ledger-event.json","./schemas/output/order-change.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\order-change.json","./schemas/output/orderbook-orders.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\orderbook-orders.json","./schemas/output/outcome.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\outcome.json","./schemas/output/prepare.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\prepare.json","./schemas/output/sign-payment-channel-claim.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\sign-payment-channel-claim.json","./schemas/output/sign.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\sign.json","./schemas/output/submit.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\submit.json","./schemas/output/verify-payment-channel-claim.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\verify-payment-channel-claim.json","./schemas/specifications/account-delete.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\account-delete.json","./schemas/specifications/check-cancel.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\check-cancel.json","./schemas/specifications/check-cash.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\check-cash.json","./schemas/specifications/check-create.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\check-create.json","./schemas/specifications/deposit-preauth.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\deposit-preauth.json","./schemas/specifications/escrow-cancellation.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\escrow-cancellation.json","./schemas/specifications/escrow-creation.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\escrow-creation.json","./schemas/specifications/escrow-execution.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\escrow-execution.json","./schemas/specifications/get-payment.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\get-payment.json","./schemas/specifications/order-cancellation.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\order-cancellation.json","./schemas/specifications/order.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\order.json","./schemas/specifications/payment-channel-claim.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment-channel-claim.json","./schemas/specifications/payment-channel-create.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment-channel-create.json","./schemas/specifications/payment-channel-fund.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment-channel-fund.json","./schemas/specifications/payment.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment.json","./schemas/specifications/settings.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\settings.json","./schemas/specifications/trustline.json":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\trustline.json","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","jsonschema":"F:\\metamask-extension\\node_modules\\jsonschema\\lib\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschema-validator.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidAddress = exports.isValidSecret = exports.schemaValidate = void 0;
const _ = __importStar(require("lodash"));
const assert = __importStar(require("assert"));
const { Validator } = require('jsonschema');
const errors_1 = require("./errors");
const ripple_address_codec_1 = require("ripple-address-codec");
const utils_1 = require("./utils");
Object.defineProperty(exports, "isValidSecret", { enumerable: true, get: function () { return utils_1.isValidSecret; } });
function loadSchemas() {
    const schemas = [
        require('./schemas/objects/tx-json.json'),
        require('./schemas/objects/transaction-type.json'),
        require('./schemas/objects/hash128.json'),
        require('./schemas/objects/hash256.json'),
        require('./schemas/objects/sequence.json'),
        require('./schemas/objects/ticket-sequence.json'),
        require('./schemas/objects/signature.json'),
        require('./schemas/objects/issue.json'),
        require('./schemas/objects/ledger-version.json'),
        require('./schemas/objects/max-adjustment.json'),
        require('./schemas/objects/memo.json'),
        require('./schemas/objects/memos.json'),
        require('./schemas/objects/public-key.json'),
        require('./schemas/objects/private-key.json'),
        require('./schemas/objects/uint32.json'),
        require('./schemas/objects/value.json'),
        require('./schemas/objects/source-adjustment.json'),
        require('./schemas/objects/destination-adjustment.json'),
        require('./schemas/objects/tag.json'),
        require('./schemas/objects/lax-amount.json'),
        require('./schemas/objects/lax-lax-amount.json'),
        require('./schemas/objects/min-adjustment.json'),
        require('./schemas/objects/source-exact-adjustment.json'),
        require('./schemas/objects/destination-exact-adjustment.json'),
        require('./schemas/objects/destination-address-tag.json'),
        require('./schemas/objects/transaction-hash.json'),
        require('./schemas/objects/address.json'),
        require('./schemas/objects/x-address.json'),
        require('./schemas/objects/classic-address.json'),
        require('./schemas/objects/adjustment.json'),
        require('./schemas/objects/quality.json'),
        require('./schemas/objects/amount.json'),
        require('./schemas/objects/amountbase.json'),
        require('./schemas/objects/balance.json'),
        require('./schemas/objects/blob.json'),
        require('./schemas/objects/currency.json'),
        require('./schemas/objects/signed-value.json'),
        require('./schemas/objects/orderbook.json'),
        require('./schemas/objects/instructions.json'),
        require('./schemas/objects/settings-plus-memos.json'),
        require('./schemas/specifications/settings.json'),
        require('./schemas/specifications/payment.json'),
        require('./schemas/specifications/get-payment.json'),
        require('./schemas/specifications/escrow-cancellation.json'),
        require('./schemas/specifications/order-cancellation.json'),
        require('./schemas/specifications/order.json'),
        require('./schemas/specifications/escrow-execution.json'),
        require('./schemas/specifications/escrow-creation.json'),
        require('./schemas/specifications/payment-channel-create.json'),
        require('./schemas/specifications/payment-channel-fund.json'),
        require('./schemas/specifications/payment-channel-claim.json'),
        require('./schemas/specifications/check-create.json'),
        require('./schemas/specifications/check-cash.json'),
        require('./schemas/specifications/check-cancel.json'),
        require('./schemas/specifications/trustline.json'),
        require('./schemas/specifications/deposit-preauth.json'),
        require('./schemas/specifications/account-delete.json'),
        require('./schemas/output/sign.json'),
        require('./schemas/output/submit.json'),
        require('./schemas/output/get-account-info.json'),
        require('./schemas/output/get-account-objects.json'),
        require('./schemas/output/get-balances.json'),
        require('./schemas/output/get-balance-sheet.json'),
        require('./schemas/output/get-ledger.json'),
        require('./schemas/output/get-orderbook.json'),
        require('./schemas/output/get-orders.json'),
        require('./schemas/output/order-change.json'),
        require('./schemas/output/get-payment-channel.json'),
        require('./schemas/output/prepare.json'),
        require('./schemas/output/ledger-event.json'),
        require('./schemas/output/get-paths.json'),
        require('./schemas/output/get-server-info.json'),
        require('./schemas/output/get-settings.json'),
        require('./schemas/output/orderbook-orders.json'),
        require('./schemas/output/outcome.json'),
        require('./schemas/output/get-transaction.json'),
        require('./schemas/output/get-transactions.json'),
        require('./schemas/output/get-trustlines.json'),
        require('./schemas/output/sign-payment-channel-claim.json'),
        require('./schemas/output/verify-payment-channel-claim.json'),
        require('./schemas/input/get-balances.json'),
        require('./schemas/input/get-balance-sheet.json'),
        require('./schemas/input/get-ledger.json'),
        require('./schemas/input/get-orders.json'),
        require('./schemas/input/get-orderbook.json'),
        require('./schemas/input/get-paths.json'),
        require('./schemas/input/get-payment-channel.json'),
        require('./schemas/input/api-options.json'),
        require('./schemas/input/get-settings.json'),
        require('./schemas/input/get-account-info.json'),
        require('./schemas/input/get-account-objects.json'),
        require('./schemas/input/get-transaction.json'),
        require('./schemas/input/get-transactions.json'),
        require('./schemas/input/get-trustlines.json'),
        require('./schemas/input/prepare-payment.json'),
        require('./schemas/input/prepare-order.json'),
        require('./schemas/input/prepare-trustline.json'),
        require('./schemas/input/prepare-order-cancellation.json'),
        require('./schemas/input/prepare-settings.json'),
        require('./schemas/input/prepare-escrow-creation.json'),
        require('./schemas/input/prepare-escrow-cancellation.json'),
        require('./schemas/input/prepare-escrow-execution.json'),
        require('./schemas/input/prepare-payment-channel-create.json'),
        require('./schemas/input/prepare-payment-channel-fund.json'),
        require('./schemas/input/prepare-payment-channel-claim.json'),
        require('./schemas/input/prepare-check-create.json'),
        require('./schemas/input/prepare-check-cash.json'),
        require('./schemas/input/prepare-check-cancel.json'),
        require('./schemas/input/prepare-ticket-create.json'),
        require('./schemas/input/compute-ledger-hash.json'),
        require('./schemas/input/sign.json'),
        require('./schemas/input/submit.json'),
        require('./schemas/input/generate-address.json'),
        require('./schemas/input/sign-payment-channel-claim.json'),
        require('./schemas/input/verify-payment-channel-claim.json'),
        require('./schemas/input/combine.json')
    ];
    const titles = schemas.map((schema) => schema.title);
    const duplicates = Object.keys(_.pickBy(_.countBy(titles), (count) => count > 1));
    assert.ok(duplicates.length === 0, 'Duplicate schemas for: ' + duplicates);
    const validator = new Validator();
    validator.customFormats.xAddress = function (instance) {
        if (instance == null) {
            return true;
        }
        return ripple_address_codec_1.isValidXAddress(instance);
    };
    validator.customFormats.classicAddress = function (instance) {
        if (instance == null) {
            return true;
        }
        return isValidAddress(instance);
    };
    validator.customFormats.secret = function (instance) {
        if (instance == null) {
            return true;
        }
        return utils_1.isValidSecret(instance);
    };
    schemas.forEach((schema) => validator.addSchema(schema, '/' + schema.title));
    return validator;
}
const schemaValidator = loadSchemas();
function schemaValidate(schemaName, object) {
    const schema = schemaValidator.getSchema('/' + schemaName);
    if (schema == null) {
        throw new errors_1.ValidationError('no schema for ' + schemaName);
    }
    const result = schemaValidator.validate(object, schema);
    if (!result.valid) {
        throw new errors_1.ValidationError(result.errors.join());
    }
}
exports.schemaValidate = schemaValidate;
function isValidAddress(address) {
    return ripple_address_codec_1.isValidXAddress(address) || ripple_address_codec_1.isValidClassicAddress(address);
}
exports.isValidAddress = isValidAddress;
//# sourceMappingURL=schema-validator.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schema-validator.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\api-options.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Capi-options.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "api-options",
  "type": "object",
  "properties": {
    "trace": {
      "type": "boolean",
      "description": "If true, log rippled requests and responses to stdout."
    },
    "feeCushion": {
      "type": "number",
      "minimum": 1,
      "description": "Factor to multiply estimated fee by to provide a cushion in case the required fee rises during submission of a transaction. Defaults to `1.2`."
    },
    "maxFeeXRP": {
      "type": "string",
      "description": "Maximum fee to use with transactions, in XRP. Must be a string-encoded number. Defaults to `'2'`."
    },
    "server": {
      "type": "string",
      "description": "URI for rippled websocket port to connect to. Must start with `wss://`, `ws://`, `wss+unix://`, or `ws+unix://`.",
      "format": "uri",
      "pattern": "^(wss?|wss?\\+unix)://"
    },
    "proxy": {
      "format": "uri",
      "description": "URI for HTTP/HTTPS proxy to use to connect to the rippled server."
    },
    "timeout": {
      "type": "integer",
      "description": "Request timeout in milliseconds before considering a request to have failed. See also: connectionTimeout.",
      "minimum": 1
    },
    "connectionTimeout": {
      "type": "integer",
      "description": "Connection timeout, in milliseconds, before considering connect() to have failed.",
      "minimum": 1
    },
    "proxyAuthorization": {
      "type": "string",
      "description": "Username and password for HTTP basic authentication to the proxy in the format **username:password**."
    },
    "authorization": {
      "type": "string",
      "description": "Username and password for HTTP basic authentication to the rippled server in the format **username:password**."
    },
    "trustedCertificates": {
      "type": "array",
      "description": "Array of PEM-formatted SSL certificates to trust when connecting to a proxy. This is useful if you want to use a self-signed certificate on the proxy server. Note: Each element must contain a single certificate; concatenated certificates are not valid.",
      "items": {
        "type": "string",
        "description": "A PEM-formatted SSL certificate to trust when connecting to a proxy."
      }
    },
    "key": {
      "type": "string",
      "description": "A string containing the private key of the client in PEM format. (Can be an array of keys)."
    },
    "passphrase": {
      "type": "string",
      "description": "The passphrase for the private key of the client."
    },
    "certificate": {
      "type": "string",
      "description": "A string containing the certificate key of the client in PEM format. (Can be an array of certificates)."
    }
  },
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\api-options.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\combine.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Ccombine.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "combineParameters",
  "type": "object",
  "properties": {
    "signedTransactions": {
      "type": "array",
      "description": "An array of signed transactions (from the output of [sign](#sign)) to combine.",
      "items": {
        "type": "string",
        "pattern": "^[A-F0-9]+$",
        "description": "A single-signed transaction represented as an uppercase hexadecimal string (from the output of [sign](#sign))"
      },
      "minLength": 1
    }
  },
  "additionalProperties": false,
  "required": ["signedTransactions"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\combine.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\compute-ledger-hash.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Ccompute-ledger-hash.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "computeLedgerHashParameters",
  "type": "object",
  "properties": {
    "ledger": {
      "$ref": "getLedger",
      "description": "The ledger header to hash."
    }
  },
  "additionalProperties": false,
  "required": ["ledger"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\compute-ledger-hash.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\generate-address.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cgenerate-address.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "generateAddressParameters",
  "type": "object",
  "properties": {
    "options": {
      "type": "object",
      "description": "Options to control how the address and secret are generated.",
      "properties": {
        "entropy": {
          "type": "array",
          "items": {
            "type": "integer",
            "minimum": 0,
            "maximum": 255
          },
          "description": "The entropy to use to generate the seed. Must be an array of length 16 with values from 0-255 (16 bytes of entropy)"
        },
        "algorithm": {
          "type": "string",
          "enum": ["ecdsa-secp256k1", "ed25519"],
          "description": "The digital signature algorithm to generate an address for. Can be `ecdsa-secp256k1` (default) or `ed25519`."
        },
        "test": {
          "type": "boolean",
          "description": "Specifies whether the address is intended for use on a test network such as Testnet or Devnet. If `true`, the address should only be used for testing, and starts with `T`. If `false`, the address should only be used on Mainnet, and starts with `X`."
        },
        "includeClassicAddress": {
          "type": "boolean",
          "description": "If `true`, also return the classic address."
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\generate-address.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-account-info.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-account-info.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getAccountInfoParameters",
  "description": "Parameters for getAccountInfo",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account to get the account info of."
    },
    "options": {
      "description": "Options that affect what to return.",
      "properties": {
        "ledgerVersion": {
          "$ref": "ledgerVersion",
          "description": "Get the account info as of this historical ledger version."
        }
      },
      "additionalProperties": false
    }
  },
  "required": ["address"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-account-info.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-account-objects.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-account-objects.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getAccountObjectsOptions",
  "description": "Request options for getAccountObjects",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account to get the account objects of."
    },
    "options": {
      "description": "Options that affect what to return.",
      "properties": {
        "type": {
          "type": "string",
          "enum": [
            "check",
            "escrow",
            "offer",
            "payment_channel",
            "signer_list",
            "state"
          ],
          "description":
            "(Optional) Filter results to include only this type of ledger object. The valid types are: `check`, `escrow`, `offer`, `payment_channel`, `signer_list`, and `state` (trust line)."
        },
        "ledgerHash": {
          "type": "string",
          "description":
            "(Optional) A 20-byte hex string for the ledger version to use."
        },
        "ledgerIndex": {
          "oneOf": [
            {
              "$ref": "ledgerVersion"
            },
            {
              "type": "string"
            }
          ],
          "description":
            "(Optional) The sequence number of the ledger to use, or a shortcut string to choose a ledger automatically."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "description":
            "(Optional) The maximum number of objects to include in the results."
        }
      },
      "additionalProperties": false
    }
  },
  "required": ["address"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-account-objects.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-balance-sheet.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-balance-sheet.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getBalanceSheetParameters",
  "description": "Parameters for getBalanceSheet",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The XRP Ledger address of the account to get the balance sheet of."
    },
    "options": {
      "properties": {
        "excludeAddresses": {
          "type": "array",
          "items": {"$ref": "address"},
          "uniqueItems": true,
          "description": "Addresses to exclude from the balance totals."
        },
        "ledgerVersion": {
          "$ref": "ledgerVersion",
          "description": "Get the balance sheet as of this historical ledger version."
        }
      },
      "description": "Options to determine how the balances are calculated.",
      "additionalProperties": false
    }
  },
  "additionalProperties": false,
  "required": ["address"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-balance-sheet.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-balances.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-balances.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getBalancesParameters",
  "description": "Parameters for getBalances",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account to get balances for."
    },
    "options": {
      "description": "Options to filter and determine which balances to return.",
      "properties": {
        "counterparty": {
          "$ref": "address",
          "description": "Only return balances with this counterparty."
        },
        "currency": {
          "$ref": "currency",
          "description": "Only return balances for this currency."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "description": "Return at most this many balances."
        },
        "ledgerVersion": {
          "$ref": "ledgerVersion",
          "description": "Return balances as they were in this historical ledger version."
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false,
  "required": ["address"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-balances.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-ledger.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-ledger.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getLedgerParameters",
  "description": "Parameters for getLedger",
  "type": "object",
  "properties": {
    "options": {
      "description": "Options affecting what ledger and how much data to return.",
      "properties": {
        "ledgerHash": {
          "type": "string",
          "description": "Get ledger data for this historical ledger hash."
        },
        "ledgerVersion": {
          "$ref": "ledgerVersion",
          "description": "Get ledger data for this historical ledger version."
        },
        "includeAllData": {
          "type": "boolean",
          "description": "Include the details of the transactions or state information if `includeTransactions` or `includeState` is set."
        },
        "includeTransactions": {
          "type": "boolean",
          "description": "Return an array of transactions in this ledger. By default, provides the identifying hashes for each transaction. If `includeAllData` is true, include the entire transaction JSON for each transaction instead."
        },
        "includeState": {
          "type": "boolean",
          "description": "Return an array of state data in this ledger. By default, provides the identifying hashes of state data. If `includeAllData` is true, return the state data in JSON form instead. **Admin required:** This is a very large amount of data."
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-ledger.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-orderbook.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-orderbook.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getOrderbookParameters",
  "description": "Parameters for getOrderbook",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "Address of an account to use as point-of-view. (This affects which unfunded offers are returned.)"
    },
    "orderbook": {
      "$ref": "orderbook",
      "description": "The order book to get."
    },
    "options": {
      "description": "Options to determine what to return.",
      "properties": {
        "limit": {
          "type": "integer",
          "minimum": 1,
          "description": "Return at most this many orders from the order book."
        },
        "ledgerVersion": {
          "$ref": "ledgerVersion",
          "description": "Return the order book as of this historical ledger version."
        }
      },
      "additionalProperties": false
    }
  },
  "required": ["address", "orderbook"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-orderbook.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-orders.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-orders.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getOrdersParameters",
  "description": "Parameters for getOrders",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The XRP Ledger address of the account to get open orders for."
    },
    "options": {
      "description": "Options that determine what orders to return.",
      "properties": {
        "limit": {
          "type": "integer",
          "minimum": 1,
          "description": "Return at most this many orders."
        },
        "ledgerVersion": {
          "$ref": "ledgerVersion",
          "description": "Return orders as of this historical ledger version."
        }
      },
      "additionalProperties": false
    }
  },
  "required": ["address"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-orders.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-paths.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-paths.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getPathsParameters",
  "type": "object",
  "properties": {
    "pathfind": {
      "description": "Specification of a pathfind request.",
      "properties": {
        "source": {
          "description": "Properties of the source of funds.",
          "type": "object",
          "properties": {
            "address": {
              "$ref": "address",
              "description": "The XRP Ledger address of the planned sender."
            },
            "amount": {
              "$ref": "laxAmount",
              "description": "The amount of funds to send."
            },
            "currencies": {
              "description": "An array of currencies (with optional counterparty) that may be used in the payment paths.",
              "type": "array",
              "items": {
                "description": "A currency with optional counterparty.",
                "type": "object",
                "properties": {
                  "currency": {"$ref": "currency"},
                  "counterparty": {
                    "$ref": "address",
                    "description": "The counterparty for the currency; if omitted any counterparty may be used."
                  }
                },
                "required": ["currency"],
                "additionalProperties": false
              },
              "uniqueItems": true
            }
          },
          "not": {
            "required": ["amount", "currencies"]
          },
          "additionalProperties": false,
          "required": ["address"]
        },
        "destination": {
          "description": "Properties of the destination of funds.",
          "type": "object",
          "properties": {
            "address": {
              "$ref": "address",
              "description": "An address representing the destination of the transaction."
            },
            "amount": {
              "$ref": "laxLaxAmount",
              "description": "The amount to be received by the receiver (`value` may be ommitted if a source amount is specified)."
            }
          },
          "required": ["address", "amount"],
          "additionalProperties": false
        }
      },
      "required": ["source", "destination"],
      "additionalProperties": false
    }
  },
  "additionalProperties": false,
  "required": ["pathfind"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-paths.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-payment-channel.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-payment-channel.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getPaymentChannelParameters",
  "description": "Parameters for getPaymentChannel",
  "type": "object",
  "properties": {
    "id": {
      "$ref": "hash256",
      "description": "256-bit hexadecimal channel identifier."
    }
  },
  "additionalProperties": false,
  "required": ["id"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-payment-channel.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-settings.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-settings.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getSettingsParameters",
  "description": "Parameters for getSettings",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account to get the settings of."
    },
    "options": {
      "description": "Options that affect what to return.",
      "properties": {
        "ledgerVersion": {
          "$ref": "ledgerVersion",
          "description": "Get the settings as of this historical ledger version."
        }
      },
      "additionalProperties": false
    }
  },
  "required": ["address"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-settings.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-transaction.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-transaction.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getTransactionParameters",
  "description": "Parameters for getTransaction",
  "type": "object",
  "properties": {
    "id": {"$ref": "transactionHash"},
    "options": {
      "description": "Options to limit the ledger versions to search or include raw transaction data.",
      "properties": {
        "minLedgerVersion": {
          "$ref": "ledgerVersion",
          "description": "The lowest ledger version to search. This must be an integer greater than 0, or one of the following strings: 'validated', 'closed', 'current'."
        },
        "maxLedgerVersion": {
          "$ref": "ledgerVersion",
          "description": "The highest ledger version to search. This must be an integer greater than 0, or one of the following strings: 'validated', 'closed', 'current'."
        },
        "includeRawTransaction": {
          "description": "Include raw transaction data. For advanced users; exercise caution when interpreting this data."
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false,
  "required": ["id"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-transaction.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-transactions.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-transactions.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getTransactionsParameters",
  "description": "Parameters for getTransactions",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account to get transactions for."
    },
    "options": {
      "description": "Options to filter the resulting transactions.",
      "properties": {
        "start": {
          "$ref": "hash256",
          "description": "If specified, start the results from this transaction. You cannot use `start` with `minLedgerVersion` or `maxLedgerVersion`. When `start` is specified, these ledger versions are determined internally."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "description": "If specified, return at most this many transactions."
        },
        "minLedgerVersion": {
          "$ref": "ledgerVersion",
          "description": "Return only transactions in this ledger version or higher."
        },
        "maxLedgerVersion": {
          "$ref": "ledgerVersion",
          "description": "Return only transactions in this ledger version or lower."
        },
        "earliestFirst": {
          "type": "boolean",
          "description": "If true, sort transactions so that the earliest ones come first. By default, the newest transactions come first."
        },
        "excludeFailures": {
          "type": "boolean",
          "description": "If true, the result omits transactions that did not succeed."
        },
        "initiated": {
          "type": "boolean",
          "description": "If true, return only transactions initiated by the account specified by `address`. If false, return only transactions not initiated by the account specified by `address`."
        },
        "counterparty": {
          "$ref": "address",
          "description": "If provided, only return transactions with this account as a counterparty to the transaction."
        },
        "types": {
          "type": "array",
          "items": {"$ref": "transactionType"},
          "description": "Only return transactions of the specified [Transaction Types](#transaction-types)."
        },
        "includeRawTransactions": {
          "description": "Include raw transaction data. For advanced users; exercise caution when interpreting this data. "
        },
        "binary": {
          "type": "boolean",
          "description": "If true, return transactions in binary format rather than JSON."
        }
      },
      "additionalProperties": false,
      "not": {
        "anyOf": [
          {"required": ["start", "minLedgerVersion"]},
          {"required": ["start", "maxLedgerVersion"]}
        ]
      }
    }
  },
  "additionalProperties": false,
  "required": ["address"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-transactions.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-trustlines.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cget-trustlines.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getTrustlinesParameters",
  "description": "Parameters for getTrustlines",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account to get trustlines for."
    },
    "options": {
      "description": "Options to filter and determine which trustlines to return.",
      "properties": {
        "counterparty": {
          "$ref": "address",
          "description": "Only return trustlines with this counterparty."
        },
        "currency": {
          "$ref": "currency",
          "description": "Only return trustlines for this currency."
        },
        "limit": {
          "type": "integer",
          "minimum": 1,
          "description": "Return at most this many trustlines."
        },
        "ledgerVersion": {
          "$ref": "ledgerVersion",
          "description": "Return trustlines as they were in this historical ledger version."
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false,
  "required": ["address"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\get-trustlines.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-check-cancel.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-check-cancel.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareCheckCancelParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "checkCancel": {
      "$ref": "checkCancel",
      "description": "The specification of the Check cancellation to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "checkCancel"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-check-cancel.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-check-cash.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-check-cash.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareCheckCashParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "checkCash": {
      "$ref": "checkCash",
      "description": "The specification of the Check cash to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "checkCash"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-check-cash.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-check-create.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-check-create.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareCheckCreateParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "checkCreate": {
      "$ref": "checkCreate",
      "description": "The specification of the Check create creation to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "checkCreate"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-check-create.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-escrow-cancellation.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-escrow-cancellation.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareEscrowCancellationParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "escrowCancellation": {
      "$ref": "escrowCancellation",
      "description": "The specification of the escrow cancellation to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "escrowCancellation"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-escrow-cancellation.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-escrow-creation.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-escrow-creation.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareEscrowCreationParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "escrowCreation": {
      "$ref": "escrowCreation",
      "description": "The specification of the escrow creation to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "escrowCreation"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-escrow-creation.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-escrow-execution.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-escrow-execution.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareEscrowExecutionParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "escrowExecution": {
      "$ref": "escrowExecution",
      "description": "The specification of the escrow execution to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "escrowExecution"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-escrow-execution.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-order-cancellation.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-order-cancellation.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareOrderCancellationParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "orderCancellation": {
      "$ref": "orderCancellation",
      "description": "The specification of the order cancellation to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "orderCancellation"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-order-cancellation.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-order.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-order.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareOrderParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "order": {
      "$ref": "order",
      "description": "The specification of the order to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "order"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-order.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment-channel-claim.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-payment-channel-claim.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "preparePaymentChannelClaimParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "paymentChannelClaim": {
      "$ref": "paymentChannelClaim",
      "description": "Details of the channel and claim."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "paymentChannelClaim"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment-channel-claim.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment-channel-create.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-payment-channel-create.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "preparePaymentChannelCreateParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "paymentChannelCreate": {
      "$ref": "paymentChannelCreate",
      "description": "The specification of the payment channel to create."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "paymentChannelCreate"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment-channel-create.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment-channel-fund.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-payment-channel-fund.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "preparePaymentChannelFundParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "paymentChannelFund": {
      "$ref": "paymentChannelFund",
      "description": "The channel to fund, and the details of how to fund it."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "paymentChannelFund"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment-channel-fund.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-payment.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "preparePaymentParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "payment": {
      "$ref": "payment",
      "description": "The specification of the payment to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "payment"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-payment.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-settings.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-settings.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareSettingsParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "settings": {
      "$ref": "settings",
      "description": "The specification of the settings to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "settings"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-settings.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-ticket-create.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-ticket-create.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareTicketParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "ticketCount": {
      "type": "number",
      "description": "The number of tickets to be created."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "ticketCount"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-ticket-create.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-trustline.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cprepare-trustline.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepareTrustlineParameters",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address of the account that is creating the transaction."
    },
    "trustline": {
      "$ref": "trustline",
      "description": "The specification of the trustline to prepare."
    },
    "instructions": {"$ref": "instructions"}
  },
  "additionalProperties": false,
  "required": ["address", "trustline"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\prepare-trustline.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\sign-payment-channel-claim.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Csign-payment-channel-claim.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "signPaymentChannelClaimParameters",
  "type": "object",
  "properties": {
    "channel": {
      "$ref": "hash256",
      "description": "256-bit hexadecimal channel identifier."
    },
    "amount": {
      "$ref": "value",
      "description": "Amount of XRP authorized by the claim."
    },
    "privateKey": {
      "$ref": "publicKey",
      "description": "The private key to sign the payment channel claim."
    }
  },
  "additionalProperties": false,
  "required": ["channel", "amount", "privateKey"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\sign-payment-channel-claim.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\sign.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Csign.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "signParameters",
  "type": "object",
  "properties": {
    "txJSON": {
      "type": "string",
      "description": "Transaction represented as a JSON string in rippled format."
    },
    "secret": {
      "type": "string",
      "format": "secret",
      "description": "The secret of the account that is initiating the transaction. (This field cannot be used with keypair)."
    },
    "keypair": {
      "type": "object",
      "properties": {
        "privateKey": {
          "type": "privateKey",
          "description": "The uppercase hexadecimal representation of the secp256k1 or Ed25519 private key. Ed25519 keys are prefixed with 0xED. You can read about how keys are derived [here](https://xrpl.org/cryptographic-keys.html)."
        },
        "publicKey": {
          "type": "publicKey",
          "description": "The uppercase hexadecimal representation of the secp256k1 or Ed25519 public key. Ed25519 keys are prefixed with 0xED. You can read about how keys are derived [here](https://xrpl.org/cryptographic-keys.html)."
        }
      },
      "description": "The private and public key of the account that is initiating the transaction. (This field cannot be used with secret).",
      "required": ["privateKey", "publicKey"],
      "additionalProperties": false
    },
    "options": {
      "type": "object",
      "description": "Options that control the type of signature to create.",
      "properties": {
        "signAs": {
          "$ref": "address",
          "description": "The account that the signature should count for in multisigning."
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false,
  "required": ["txJSON"],
  "oneOf": [
    {
      "required": ["secret"],
      "not": {"required": ["keypair"]}
    },
    {
      "required": ["keypair"],
      "not": {"required": ["secret"]}
    }
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\sign.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\submit.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Csubmit.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "submitParameters",
  "type": "object",
  "properties": {
    "signedTransaction": {
      "$ref": "blob",
      "description": "A signed transaction as returned by [sign](#sign)."
    },
    "failHard": {
      "type": "boolean",
      "description": "If `true`, and the transaction fails locally, do not retry or relay the transaction to other servers. Defaults to `false`."
    }
  },
  "additionalProperties": false,
  "required": ["signedTransaction"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\submit.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\verify-payment-channel-claim.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cinput%5Cverify-payment-channel-claim.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "verifyPaymentChannelClaimParameters",
  "type": "object",
  "properties": {
    "channel": {
      "$ref": "hash256",
      "description": "256-bit hexadecimal channel identifier."
    },
    "amount": {
      "$ref": "value",
      "description": "Amount of XRP authorized by the claim."
    },
    "signature": {
      "$ref": "signature",
      "description": "Signature of this claim."
    },
    "publicKey": {
      "$ref": "publicKey",
      "description": "Public key of the channel's sender"
    }
  },
  "additionalProperties": false,
  "required": ["channel", "amount", "signature", "publicKey"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\input\\verify-payment-channel-claim.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\address.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Caddress.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "address",
  "description": "An account address on the XRP Ledger",
  "type": "string",
  "format": "address",
  "link": "address",
  "oneOf": [
    {"$ref": "xAddress"},
    {"$ref": "classicAddress"}
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\address.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\adjustment.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cadjustment.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "adjustment",
  "type": "object",
  "properties": {
    "address": {"$ref": "address"},
    "amount": {"$ref": "amount"},
    "tag": {"$ref": "tag"}
  },
  "required": ["address", "amount"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\adjustment.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\amount.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Camount.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "amount",
  "link": "amount",
  "description": "An Amount on the XRP Ledger",
  "allOf": [
    {"$ref": "amountbase"},
    {"required": ["value"]}
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\amount.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\amountbase.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Camountbase.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "amountbase",
  "description": "Base class for amount and issue",
  "type": "object",
  "properties": {
    "value": {
      "description": "The quantity of the currency, denoted as a string so that it does not lose precision",
      "$ref": "value"
    },
    "currency": {
      "description": "The three-character code or hexadecimal string used to denote currencies, or \"drops\" for the smallest unit of XRP.",
      "$ref": "currency"
    },
    "counterparty": {
      "description": "The XRP Ledger address of the account that owes or is owed the funds (omitted if `currency` is \"XRP\" or \"drops\")",
      "$ref": "address"
    }
  },
  "additionalProperties": false,
  "required": ["currency"],
  "oneOf": [
    {
      "properties": {
        "currency": {
          "not": {
            "enum": ["XRP", "drops"]
          }
        }
      },
      "required": ["counterparty"]
    },
    {
      "properties": {
        "currency": {
          "enum": ["XRP", "drops"]
        }
      },
      "not": {
        "required": ["counterparty"]
      }
    }
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\amountbase.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\balance.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cbalance.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "balance",
  "description": "Balance amount",
  "link": "amount",
  "type": "object",
  "properties": {
    "value": {
      "description": "The balance on the trustline",
      "$ref": "signedValue"
    },
    "currency": {
      "description": "The three-character code or hexadecimal string used to denote currencies",
      "$ref": "currency"
    },
    "counterparty": {
      "description": "The XRP Ledger address of the account that owes or is owed the funds.",
      "$ref": "address"
    }
  },
  "additionalProperties": false,
  "required": ["currency", "value"],
  "oneOf": [
    {
      "properties": {
        "currency": {
          "not": {
            "enum": ["XRP"]
          }
        }
      },
      "required": ["counterparty"]
    },
    {
      "properties": {
        "currency": {
          "enum": ["XRP"]
        }
      },
      "not": {
        "required": ["counterparty"]
      }
    }
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\balance.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\blob.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cblob.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "blob",
  "description": "An uppercase hexadecimal string representation of a transaction",
  "type": "string",
  "minLength": 1,
  "pattern": "^[0-9A-F]*$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\blob.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\classic-address.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cclassic-address.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "classicAddress",
  "description": "A classic address (Account ID) for the XRP Ledger",
  "type": "string",
  "format": "classicAddress",
  "link": "classic-address",
  "pattern": "^r[1-9A-HJ-NP-Za-km-z]{24,34}$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\classic-address.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\currency.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Ccurrency.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "currency",
  "description": "The three-character code or hexadecimal string used to denote currencies",
  "type": "string",
  "link": "currency",
  "pattern": "^([a-zA-Z0-9<>(){}[\\]|?!@#$%^&*]{3}|[A-F0-9]{40}|drops)$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\currency.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\destination-address-tag.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cdestination-address-tag.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "destinationAddressTag",
  "description": "A destination address and optional tag, with no amount included. When parsing an incoming transaction, the original specification's amount is hidden to prevent misinterpretation. For the amount that the transaction delivered, see `outcome.deliveredAmount`.",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "An address representing the destination of the transaction."
    },
    "tag": {"$ref": "tag"}
  },
  "required": ["address"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\destination-address-tag.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\destination-adjustment.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cdestination-adjustment.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "destinationAdjustment",
  "type": "object",
  "oneOf": [
    {"$ref": "destinationExactAdjustment"},
    {"$ref": "minAdjustment"}
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\destination-adjustment.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\destination-exact-adjustment.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cdestination-exact-adjustment.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "destinationExactAdjustment",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "An address representing the destination of the transaction."
    },
    "amount": {
      "$ref": "laxAmount",
      "description": "An exact amount to deliver to the recipient. If the counterparty is not specified, amounts with any counterparty may be used. (This field cannot be used with `destination.minAmount`.)"
    },
    "tag": {"$ref": "tag"}
  },
  "required": ["address", "amount"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\destination-exact-adjustment.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\hash128.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Chash128.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "hash128",
  "description": "The hexadecimal representation of a 128-bit hash",
  "type": "string",
  "pattern": "^[A-F0-9]{32}$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\hash128.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\hash256.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Chash256.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "hash256",
  "description": "The hexadecimal representation of a 256-bit hash",
  "type": "string",
  "pattern": "^[A-F0-9]{64}$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\hash256.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\instructions.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cinstructions.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "instructions",
  "link": "transaction-instructions",
  "description": "Instructions for executing the transaction",
  "type": "object",
  "properties": {
    "sequence": {
      "description": "The initiating account's sequence number for this transaction. `sequence` and `ticketSequence` are mutually exclusive, only one of them can be set.",
      "$ref": "sequence"
    },
    "ticketSequence": {
      "description": "The ticket sequence to be used for this transaction. `sequence` and `ticketSequence` are mutually exclusive, only one of them can be set.",
      "$ref": "ticket-sequence"
    },
    "fee": {
      "description": "An exact fee to pay for the transaction, before multiplying for multi-signed transactions. See [Transaction Fees](#transaction-fees) for more information.",
      "$ref": "value"
    },
    "maxFee": {
      "description": "Deprecated: Use `maxFeeXRP` in the RippleAPI constructor instead. The maximum fee to pay for this transaction. If this exceeds `maxFeeXRP`, use `maxFeeXRP` instead. See [Transaction Fees](#transaction-fees) for more information.",
      "$ref": "value"
    },
    "maxLedgerVersion": {
      "description": "The highest ledger version that the transaction can be included in. If this option and `maxLedgerVersionOffset` are both omitted, the default is 3 greater than the current validated ledger version (equivalent to `maxLedgerVersionOffset=3`). Use `null` to not set a maximum ledger version. If not null, this must be an integer greater than 0, or one of the following strings: 'validated', 'closed', 'current'.",
      "oneOf": [
        {"$ref": "ledgerVersion"},
        {"type": "null"}
      ]
    },
    "maxLedgerVersionOffset": {
      "description": "Offset from current validated ledger version to highest ledger version that the transaction can be included in.",
      "type": "integer",
      "minimum": 0
    },
    "signersCount": {
      "description": "Number of signers that can multi-sign this transaction.",
      "type": "integer",
      "minimum": 1
    }
  },
  "additionalProperties": false,
  "not": {
    "anyOf": [
      {
        "description": "fee and maxFee are mutually exclusive",
        "required": ["fee", "maxFee"]
      },
      {
        "description": "maxLedgerVersion and maxLedgerVersionOffset are mutually exclusive",
        "required": ["maxLedgerVersion", "maxLedgerVersionOffset"]
      },
      {
        "description": "sequence and ticketSequence are mutually exclusive",
        "required": ["sequence", "ticketSequence"]
      }
    ]
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\instructions.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\issue.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cissue.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "issue",
  "description": "The currency code, and the counterparty if it's not XRP.",
  "allOf": [
    {"$ref": "amountbase"},
    {"not": {"required": ["value"]}}
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\issue.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\lax-amount.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Clax-amount.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "laxAmount",
  "description": "Amount where counterparty is optional",
  "link": "amount",
  "type": "object",
  "properties": {
    "currency": {"$ref": "currency"},
    "counterparty": {"$ref": "address"},
    "value": {"$ref": "value"}
  },
  "required": ["currency", "value"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\lax-amount.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\lax-lax-amount.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Clax-lax-amount.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "laxLaxAmount",
  "description": "Amount where counterparty and value are optional",
  "link": "amount",
  "type": "object",
  "properties": {
    "currency": {"$ref": "currency"},
    "counterparty": {"$ref": "address"},
    "value": {"$ref": "value"}
  },
  "required": ["currency"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\lax-lax-amount.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\ledger-version.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cledger-version.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "ledgerVersion",
  "description": "A ledger version number",
  "oneOf": [
    {
      "type": "integer",
      "minimum": 1
    },
    {
      "type": "string",
      "enum": ["validated", "closed", "current"]
    }
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\ledger-version.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\max-adjustment.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cmax-adjustment.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "maxAdjustment",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address to send from."
    },
    "maxAmount": {
      "$ref": "laxAmount",
      "description": "The maximum amount to send. (This field cannot be used with source.amount)"
    },
    "tag": {"$ref": "tag"}
  },
  "required": ["address", "maxAmount"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\max-adjustment.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\memo.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cmemo.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "memo",
  "description": "Memo objects represent arbitrary data that can be included in a transaction",
  "type": "object",
  "properties": {
    "type": {
      "pattern": "^[A-Za-z0-9\\-._~:/?#[\\]@!$&'()*+,;=%]*$",
      "description": "Conventionally, a unique relation (according to [RFC 5988](http://tools.ietf.org/html/rfc5988#section-4)) that defines the format of this memo. Only characters allowed in URLs are permitted."
    },
    "format": {
      "pattern": "^[A-Za-z0-9\\-._~:/?#[\\]@!$&'()*+,;=%]*$",
      "description": "Conventionally containing information on how the memo is encoded, for example as a [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml). Only characters allowed in URLs are permitted."
    },
    "data": {
      "type": "string",
      "description": "Arbitrary string, conventionally containing the content of the memo."
    }
  },
  "additionalProperties": false,
  "anyOf": [
    {"required": ["data"]},
    {"required": ["type"]}
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\memo.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\memos.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cmemos.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "memos",
  "link": "transaction-memos",
  "description": "Array of memos to attach to the transaction.",
  "type": "array",
  "items": {
    "$ref": "memo"
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\memos.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\min-adjustment.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cmin-adjustment.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "minAdjustment",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "An address representing the destination of the transaction."
    },
    "minAmount": {
      "$ref": "laxAmount",
      "description": "The minimum amount to be delivered. (This field cannot be used with destination.amount)"
    },
    "tag": {"$ref": "tag"}
  },
  "required": ["address", "minAmount"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\min-adjustment.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\orderbook.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Corderbook.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "orderbook",
  "type": "object",
  "properties": {
    "base": {"$ref": "issue"},
    "counter": {"$ref": "issue"}
  },
  "required": ["base", "counter"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\orderbook.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\private-key.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cprivate-key.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "privateKey",
  "description": "The hexadecimal representation of a secp256k1 or Ed25519 private key.",
  "type": "string",
  "pattern": "^[A-F0-9]+$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\private-key.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\public-key.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cpublic-key.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "publicKey",
  "description": "The hexadecimal representation of a secp256k1 or Ed25519 public key.",
  "type": "string",
  "pattern": "^[A-F0-9]+$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\public-key.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\quality.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cquality.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "quality",
  "description": "Ratio for incoming/outgoing transit fees.",
  "type": "number",
  "minimum": 0.000000001,
  "maximum": 4.294967295
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\quality.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\sequence.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Csequence.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "sequence",
  "link": "account-sequence-number",
  "description": "An account transaction sequence number",
  "type": "integer",
  "minimum": 0
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\sequence.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\settings-plus-memos.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Csettings-plus-memos.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "settingsPlusMemos",
  "type": "object",
  "properties": {
    "defaultRipple": {
      "type": "boolean",
      "description": "Enable [rippling](https://xrpl.org/rippling.html) on this accounts trust lines by default. Currency issuers should enable this setting; most others should not."
    },
    "depositAuth": {
      "type": "boolean",
      "description": "Enable [Deposit Authorization](https://xrpl.org/depositauth.html) on this account. If set, transactions cannot send value of any kind to this account unless the sender of those transactions is the account itself. (Requires the [DepositAuth amendment](https://xrpl.org/known-amendments.html#depositauth))"
    },
    "disableMasterKey": {
      "type": "boolean",
      "description": "Disallows use of the master key to sign transactions for this account. To disable the master key, you must authorize the transaction by signing it with the master key pair. You cannot use a regular key pair or a multi-signature. You can re-enable the master key pair using a regular key pair or multi-signature. See [AccountSet](https://xrpl.org/accountset.html)."
    },
    "disallowIncomingXRP": {
      "type": "boolean",
      "description": "Indicates that client applications should not send XRP to this account. Not enforced by rippled."
    },
    "domain": {
      "type": "string",
      "description": "The domain that owns this account, as a hexadecimal string representing the ASCII for the domain in lowercase."
    },
    "emailHash": {
      "description": "Hash of an email address to be used for generating an avatar image. Conventionally, clients use Gravatar to display this image. Use `null` to clear.",
      "oneOf": [
        {"type": "null"},
        {"$ref": "hash128"}
      ]
    },
    "walletLocator": {
      "description": "Transaction hash or any other 64 character hexadecimal string, that may or may not represent the result of a hash operation. Use `null` to clear.",
      "oneOf": [
        {"type": "null"},
        {"$ref": "hash256"}
      ]
    },
    "enableTransactionIDTracking": {
      "type": "boolean",
      "description": "Track the ID of this accounts most recent transaction."
    },
    "globalFreeze": {
      "type": "boolean",
      "description": "Freeze all assets issued by this account."
    },
    "memos": {"$ref": "memos"},
    "messageKey": {
      "type": "string",
      "description": "Public key for sending encrypted messages to this account. Conventionally, it should be a secp256k1 key, the same encryption that is used by the rest of Ripple."
    },
    "noFreeze": {
      "type": "boolean",
      "description": "Permanently give up the ability to freeze individual trust lines. This flag can never be disabled after being enabled."
    },
    "passwordSpent": {
      "type": "boolean",
      "description": "Indicates that the account has used its free SetRegularKey transaction."
    },
    "regularKey": {
      "oneOf": [
        {"$ref": "address"},
        {"type": "null"}
      ],
      "description": "The public key of a new keypair, to use as the regular key to this account, as a base-58-encoded string in the same format as an account address. Use `null` to remove the regular key."
    },
    "requireAuthorization": {
      "type": "boolean",
      "description": "If set, this account must individually give other users permission to hold this accounts issued tokens."
    },
    "requireDestinationTag": {
      "type": "boolean",
      "description": "Requires incoming payments to specify a destination tag."
    },
    "signers": {
      "type": "object",
      "description": "Settings that determine what sets of accounts can be used to sign a transaction on behalf of this account using multisigning.",
      "properties": {
        "threshold": {
          "$ref": "uint32",
          "description": "A target number for the signer weights. A multi-signature from this list is valid only if the sum weights of the signatures provided is equal or greater than this value. To delete the signers setting, use the value `0`."
        },
        "weights": {
          "type": "array",
          "description": "Weights of signatures for each signer.",
          "items": {
            "type": "object",
            "description": "An association of an address and a weight.",
            "properties": {
              "address": {"$ref": "address"},
              "weight": {
                "$ref": "uint32",
                "description": "The weight that the signature of this account counts as towards the threshold."
              }
            },
            "required": ["address", "weight"],
            "additionalProperties": false
          },
          "minItems": 1,
          "maxItems": 8
        }
      },
      "required": ["threshold"],
      "additionalProperties": false
    },
    "transferRate": {
      "description": "The fee to charge when users transfer this accounts issuances, as the decimal amount that must be sent to deliver 1 unit. Has precision up to 9 digits beyond the decimal point. Use `null` to set no fee.",
      "oneOf": [
        {"type": "null"},
        {"type": "number", "minimum": 1, "maximum": 4.294967295}
      ]
    },
    "tickSize": {
      "description": "Tick size to use for offers involving a currency issued by this address. The exchange rates of those offers is rounded to this many significant digits. Valid values are 3 to 15 inclusive, or 0 to disable.",
      "enum": [0, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
    }
  },
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\settings-plus-memos.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\signature.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Csignature.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "signature",
  "description": "The hexadecimal representation of a signature.",
  "type": "string",
  "pattern": "^[A-F0-9]+$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\signature.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\signed-value.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Csigned-value.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "signedValue",
  "description": "A string representation of a floating point number",
  "type": "string",
  "link": "value",
  "pattern": "^[-]?[0-9]*[.]?[0-9]+([eE][-+]?[0-9]+)?$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\signed-value.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\source-adjustment.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Csource-adjustment.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "sourceAdjustment",
  "type": "object",
  "oneOf": [
    {"$ref": "sourceExactAdjustment"},
    {"$ref": "maxAdjustment"}
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\source-adjustment.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\source-exact-adjustment.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Csource-exact-adjustment.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "sourceExactAdjustment",
  "type": "object",
  "properties": {
    "address": {
      "$ref": "address",
      "description": "The address to send from."
    },
    "amount": {
      "$ref": "laxAmount",
      "description": "An exact amount to send. If the counterparty is not specified, amounts with any counterparty may be used. (This field cannot be used with source.maxAmount)"
    },
    "tag": {"$ref": "tag"}
  },
  "required": ["address", "amount"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\source-exact-adjustment.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\tag.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Ctag.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "tag",
  "description": "An arbitrary 32-bit unsigned integer. It typically maps to an off-ledger account; for example, a hosted wallet or exchange account.",
  "type": "integer",
  "$ref": "uint32"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\tag.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\ticket-sequence.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cticket-sequence.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "ticket-sequence",
  "link": "account-sequence-number",
  "description": "An account transaction tickt sequence number",
  "type": "integer",
  "minimum": 1
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\ticket-sequence.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\transaction-hash.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Ctransaction-hash.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "transactionHash",
  "link": "transaction-id",
  "description": "A hash of a transaction used to identify the transaction, represented in hexadecimal.",
  "type": "string",
  "pattern": "^[A-F0-9]{64}$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\transaction-hash.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\transaction-type.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Ctransaction-type.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "transactionType",
  "link": "transaction-types",
  "description": "The type of the transaction.",
  "type": "string",
  "enum": [
    "payment",
    "order",
    "orderCancellation",
    "trustline",
    "settings",
    "escrowCreation",
    "escrowCancellation",
    "escrowExecution",
    "paymentChannelCreate",
    "paymentChannelFund",
    "paymentChannelClaim",
    "checkCreate",
    "checkCancel",
    "checkCash",
    "depositPreauth",
    "accountDelete"
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\transaction-type.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\tx-json.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Ctx-json.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "tx-json",
  "link": "https://xrpl.org/transaction-formats.html",
  "description": "An object in rippled txJSON format",
  "type": "object",
  "properties": {
    "Account": {"$ref": "address"},
    "TransactionType": {"type": "string"}
  },
  "required": ["Account", "TransactionType"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\tx-json.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\uint32.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cuint32.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "uint32",
  "description": "A 32-bit unsigned integer",
  "type": "integer",
  "minimum": 0,
  "maximum": 4294967295
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\uint32.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\value.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cvalue.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "value",
  "link": "value",
  "description": "A string representation of a non-negative floating point number",
  "type": "string",
  "pattern": "^[0-9]*[.]?[0-9]+([eE][-+]?[0-9]+)?$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\value.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\x-address.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cobjects%5Cx-address.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "xAddress",
  "description": "An XRP Ledger address in X-address format",
  "type": "string",
  "format": "xAddress",
  "link": "x-address",
  "pattern": "^[XT][1-9A-HJ-NP-Za-km-z]{46}$"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\objects\\x-address.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-account-info.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-account-info.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getAccountInfo",
  "type": "object",
  "properties": {
    "sequence": {
      "$ref": "sequence",
      "description": "The next (smallest unused) sequence number for this account."
    },
    "xrpBalance": {
      "$ref": "value",
      "description": "The XRP balance owned by the account."
    },
    "ownerCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Number of other ledger entries (specifically, trust lines and offers) attributed to this account. This is used to calculate the total reserve required to use the account."
    },
    "previousInitiatedTransactionID": {
      "$ref": "hash256",
      "description": "Hash value representing the most recent transaction that was initiated by this account."
    },
    "previousAffectingTransactionID": {
      "$ref": "hash256",
      "description": "Hash value representing the most recent transaction that affected this account node directly. **Note:** This does not include changes to the accounts trust lines and offers."
    },
    "previousAffectingTransactionLedgerVersion": {
      "$ref": "ledgerVersion",
      "description": "The ledger version that the transaction identified by the `previousAffectingTransactionID` was validated in."
    }
  },
  "required": [
    "sequence",
    "xrpBalance",
    "ownerCount",
    "previousAffectingTransactionID",
    "previousAffectingTransactionLedgerVersion"
  ],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-account-info.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-account-objects.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-account-objects.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "AccountObjectsResponse",
  "description": "Response format for account_objects",
  "type": "object",
  "properties": {
    "account": {
      "$ref": "address",
      "description":
        "Unique address of the account this request corresponds to."
    },
    "account_objects": {
      "type": "array",
      "items": {
        "type": "object"
      },
      "description":
        "Array of objects owned by this account. Each object is in its raw ledger format."
    },
    "ledger_hash": {
      "type": "string",
      "description":
        "(May be omitted) The identifying hash of the ledger that was used to generate this response."
    },
    "ledger_index": {
      "$ref": "ledgerVersion",
      "description":
        "(May be omitted) The sequence number of the ledger that was used to generate this response."
    },
    "ledger_current_index": {
      "$ref": "ledgerVersion",
      "description":
        "(May be omitted) The sequence number of the ledger that was used to generate this response."
    },
    "limit": {
      "type": "integer",
      "description":
        "(May be omitted) The limit that was used in this request, if any."
    },
    "validated": {
      "type": "boolean",
      "description":
        "If included and set to true, the information in this request comes from a validated ledger version. Otherwise, the information is subject to change."
    }
  },
  "required": ["account", "account_objects"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-account-objects.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-balance-sheet.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-balance-sheet.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getBalanceSheet",
  "description": "getBalanceSheet response",
  "type": "object",
  "properties": {
    "balances": {
      "type": "array",
      "items": {"$ref": "amount"},
      "description": "Amounts issued to the \"hotwallet\" accounts from the request. The keys are the accounts' addresses, and the values are arrays of currency amounts they hold. The issuer (omitted from the currency amounts) is the account from the request."
    },
    "assets": {
      "type": "array",
      "items": {"$ref": "amount"},
      "description": "Total amounts held that are issued by others. For the recommended gateway configuration, there should be none."
    },
    "obligations": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["currency", "value"],
        "additionalProperties": false,
        "properties": {
          "currency": {"$ref": "currency"},
          "value": {"$ref": "value"}
        },
        "description": "An amount that is owed."
      },
      "description": "Total amounts issued to accounts that are not hot wallets, as a map of currencies to the total value issued."
    }
  },
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-balance-sheet.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-balances.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-balances.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getBalances",
  "type": "array",
  "items": {"$ref": "balance"}
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-balances.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-ledger.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-ledger.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getLedger",
  "type": "object",
  "properties": {
    "stateHash": {
      "$ref": "hash256",
      "description": "Hash of all state information in this ledger."
    },
    "closeTime": {
      "type": "string",
      "format": "date-time",
      "description": "The approximate time when this ledger was closed. This number is rounded based on the `closeTimeResolution`. If it would have been rounded to the same time as a previous ledger, the close time is recorded as 1 second later instead."
    },
    "closeTimeResolution": {
      "type": "integer",
      "minimum": 1,
      "description": "A number of seconds, indicating how much the `closeTime` could be rounded. Ledger close times are approximate so that small differences in servers clocks don't hinder consensus."
    },
    "closeFlags": {
      "type": "integer",
      "minimum": 0,
      "description": "A bit-map of flags relating to the closing of this ledger. Currently, the ledger has only one flag defined for `closeFlags`: **sLCF_NoConsensusTime** (value 1). If this flag is enabled, it means that validators disagreed on the correct close time for the ledger, but built otherwise the same ledger, so they declared consensus while \"agreeing to disagree\" on the close time. In this case, the consensus ledger contains a `closeTime` value that is 1 second after that of the previous ledger. (In this case, there is no official close time, but the actual real-world close time is probably 3-6 seconds later than the specified `closeTime`.)"
    },
    "ledgerHash": {
      "$ref": "hash256",
      "description": "Unique identifying hash of the entire ledger."
    },
    "ledgerVersion": {
      "$ref": "ledgerVersion",
      "description": "The ledger version of this ledger."
    },
    "parentLedgerHash": {
      "$ref": "hash256",
      "description": "Unique identifying hash of the ledger that came immediately before this one."
    },
    "parentCloseTime": {
      "type": "string",
      "format": "date-time",
      "description": "The previous ledger's recorded close time."
    },
    "totalDrops": {
      "$ref": "value",
      "description": "Total number of drops (1/1,000,000th of an XRP) in the network, as a quoted integer. (This decreases as transaction fees cause XRP to be destroyed.)"
    },
    "transactionHash": {
      "$ref": "hash256",
      "description": "Hash of the transaction information included in this ledger."
    },
    "transactions": {
      "description": "Array of all transactions that were validated in this ledger. Transactions are represented in the same format as the return value of [getTransaction](#gettransaction).",
      "type": "array",
      "items": {
        "$ref": "getTransaction",
        "description": "A transaction in the same format as the return value of [getTransaction](#gettransaction)."
      }
    },
    "transactionHashes": {
      "description": "An array of hashes of all transactions that were validated in this ledger.",
      "type": "array",
      "items": {
        "$ref": "transactionHash"
      }
    },
    "rawState": {
      "type": "string",
      "description": "A JSON string containing all state data for this ledger in rippled JSON format."
    },
    "stateHashes": {
      "description": "An array of hashes of all state data in this ledger.",
      "type": "array",
      "items": {
        "$ref": "hash256"
      }
    }
  },
  "required": [
    "stateHash",
    "closeTime",
    "closeTimeResolution",
    "closeFlags",
    "ledgerHash",
    "ledgerVersion",
    "parentLedgerHash",
    "parentCloseTime",
    "totalDrops",
    "transactionHash"
  ],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-ledger.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-orderbook.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-orderbook.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getOrderbook",
  "type": "object",
  "properties": {
    "bids": {
      "$ref": "orderbookOrders",
      "description": "The buy orders in the order book."
    },
    "asks": {
      "$ref": "orderbookOrders",
      "description": "The sell orders in the order book."
    }
  },
  "required": ["bids", "asks"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-orderbook.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-orders.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-orders.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getOrders",
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "specification": {
        "$ref": "order",
        "description": "An order specification that would create an order equivalent to the current state of this order."
      },
      "properties": {
        "description": "Properties of the order not in the specification.",
        "type": "object",
        "properties": {
          "maker": {
            "$ref": "address",
            "description": "The address of the account that submitted the order."
          },
          "sequence": {
            "$ref": "sequence",
            "description": "The account sequence number of the transaction that created this order."
          },
          "makerExchangeRate": {
            "$ref": "value",
            "description": "The exchange rate from the point of view of the account that submitted the order (also known as \"quality\")."
          }
        },
        "required": ["maker", "sequence", "makerExchangeRate"],
        "addtionalProperties": false
      }
    },
    "required": ["specification", "properties"],
    "additionalProperties": false
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-orders.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-paths.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-paths.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getPaths",
  "type": "array",
  "items": {
    "type": "object",
    "properties": {
      "source": {
        "$ref": "sourceAdjustment",
        "description": "Properties of the source of the payment."
      },
      "destination": {
        "$ref": "destinationAdjustment",
        "description": "Properties of the destination of the payment."
      },
      "paths": {
        "type": "string",
        "description": "The paths of trustlines and orders to use in executing the payment."
      }
    },
    "required": ["source", "destination", "paths"],
    "additionalProperties": false
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-paths.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-payment-channel.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-payment-channel.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getPaymentChannel",
  "type": "object",
  "properties": {
    "account": {
      "$ref": "address",
      "description": "Address that created the payment channel."
    },
    "destination": {
      "$ref": "address",
      "description": "Address to receive XRP claims against this channel."
    },
    "amount": {
      "$ref": "value",
      "description": "The total amount of XRP funded in this channel."
    },
    "balance": {
      "$ref": "value",
      "description": "The total amount of XRP delivered by this channel."
    },
    "settleDelay": {
      "type": "number",
      "description": "Amount of seconds the source address must wait before closing the channel if it has unclaimed XRP."
    },
    "expiration": {
      "type": "string",
      "format": "date-time",
      "description": "Time when this channel expires."
    },
    "publicKey": {
      "$ref": "publicKey",
      "description": "Public key of the key pair the source uses to sign claims against this channel."
    },
    "cancelAfter": {
      "type": "string",
      "format": "date-time",
      "description": "Time when this channel expires as specified at creation."
    },
    "sourceTag": {
      "$ref": "tag",
      "description": "Source tag."
    },
    "destinationTag": {
      "$ref": "tag",
      "description": "Destination tag."
    },
    "previousAffectingTransactionID": {
      "$ref": "hash256",
      "description": "Hash value representing the most recent transaction that affected this payment channel."
    },
    "previousAffectingTransactionLedgerVersion": {
      "$ref": "ledgerVersion",
      "description": "The ledger version that the transaction identified by the `previousAffectingTransactionID` was validated in."
    }
  },
  "required": [
    "account",
    "destination",
    "amount",
    "balance",
    "settleDelay",
    "previousAffectingTransactionID",
    "previousAffectingTransactionLedgerVersion"
  ],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-payment-channel.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-server-info.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-server-info.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getServerInfo",
  "type": "object",
  "properties": {
    "buildVersion": {
      "type": "string",
      "description": "The version number of the running rippled version."
    },
    "completeLedgers": {
      "type": "string",
      "pattern": "[0-9,-]+",
      "description": "Range expression indicating the sequence numbers of the ledger versions the local rippled has in its database. It is possible to be a disjoint sequence, e.g. 2500-5000,32570-7695432."
    },
    "hostID": {
      "type": "string",
      "description": "On an admin request, returns the hostname of the server running the rippled instance; otherwise, returns a unique four letter word."
    },
    "ioLatencyMs": {
      "type": "number",
      "description": "Amount of time spent waiting for I/O operations, in milliseconds. If this number is not very, very low, then the rippled server is probably having serious load issues."
    },
    "load": {
      "type": "object",
      "description": "*(Admin only)* Detailed information about the current load state of the server.",
      "properties": {
        "jobTypes": {
          "type": "array",
          "description": "*(Admin only)* Information about the rate of different types of jobs the server is doing and how much time it spends on each.",
          "items": {"type": "object"}
        },
        "threads": {
          "type": "number",
          "description": "*(Admin only)* The number of threads in the servers main job pool, performing various operations."
        }
      },
      "required": ["jobTypes", "threads"]
    },
    "lastClose": {
      "type": "object",
      "description": "Information about the last time the server closed a ledger.",
      "properties": {
        "convergeTimeS": {
          "type": "number",
          "description": "The time it took to reach a consensus for the last ledger closing, in seconds."
        },
        "proposers": {
          "type": "integer",
          "minimum": 0,
          "description": "Number of trusted validators participating in the ledger closing."}
      },
      "required": ["convergeTimeS", "proposers"]
    },
    "loadFactor": {
      "type": "number",
      "description": "The load factor the server is currently enforcing, as a multiplier on the base transaction fee. The load factor is determined by the highest of the individual servers load factor, clusters load factor, and the overall networks load factor."
    },
    "peers": {
      "type": "integer",
      "minimum": 0,
      "description": "How many other rippled servers the node is currently connected to."
    },
    "pubkeyNode": {
      "type": "string",
      "description": "Public key used to verify this node for internal communications; this key is automatically generated by the server the first time it starts up."
    },
    "pubkeyValidator": {
      "type": "string",
      "description": "*(Admin only)* Public key used by this node to sign ledger validations."
    },
    "serverState": {
      "type": "string",
      "description": "A string indicating to what extent the server is participating in the network. See [Possible Server States](https://xrpl.org/rippled-server-states.html) for more details.",
      "enum": ["disconnected", "connected", "syncing", "tracking", "full", "validating", "proposing"]
    },
    "validatedLedger": {
      "type": "object",
      "description": "Information about the fully-validated ledger with the highest sequence number (the most recent).",
      "properties": {
        "age": {
          "type": "integer",
          "minimum": 0,
          "description": "The time since the ledger was closed, in seconds."
        },
        "baseFeeXRP": {
          "$ref": "value",
          "description": "Base fee, in XRP. This may be represented in scientific notation such as 1e-05 for 0.00005."
        },
        "hash": {
          "$ref": "hash256",
          "description": "Unique hash for the ledger, as an uppercase hexadecimal string."
        },
        "reserveBaseXRP": {
          "$ref": "value",
          "description": "Minimum amount of XRP necessary for every account to keep in reserve."
        },
        "reserveIncrementXRP": {
          "$ref": "value",
          "description": "Amount of XRP added to the account reserve for each object an account owns in the ledger."
        },
        "ledgerVersion": {
          "type": "integer",
          "minimum": 0,
          "description": "Identifying ledger index of this ledger version."
        }
      },
      "additionalProperties": false,
      "required": ["age", "baseFeeXRP", "hash", "reserveBaseXRP", "reserveIncrementXRP", "ledgerVersion"]
    },
    "validationQuorum": {
      "type": "number",
      "description": "Minimum number of trusted validations required to validate a ledger version. Some circumstances may cause the server to require more validations."
    }
  },
  "required": ["buildVersion", "completeLedgers", "hostID", "ioLatencyMs", "lastClose", "loadFactor", "peers", "pubkeyNode", "serverState", "validatedLedger", "validationQuorum"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-server-info.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-settings.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-settings.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getSettings",
  "$ref": "settingsPlusMemos",
  "not": {
    "required": ["memos"]
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-settings.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-transaction.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-transaction.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getTransaction",
  "description": "getTransaction response",
  "link": "gettransaction",
  "properties": {
    "type": {
      "$ref": "transactionType"
    },
    "specification": {
      "description": "A specification that would produce the same outcome as this transaction. *Exception:* For payment transactions, this omits the `destination.amount` field, to prevent misunderstanding. The structure of the specification depends on the value of the `type` field (see [Transaction Types](#transaction-types) for details). *Note:* This is **not** necessarily the same as the original specification."
    },
    "outcome": {
      "$ref": "outcome",
      "description": "The outcome of the transaction (what effects it had)."
    },
    "id": {
      "$ref": "transactionHash",
      "description": "A hash of the transaction that can be used to identify it."
    },
    "address": {
      "$ref": "address",
      "description": "The address of the account that initiated the transaction."
    },
    "sequence": {
      "$ref": "sequence",
      "description": "The account sequence number of the transaction for the account that initiated it."
    },
    "rawTransaction": {
      "description": "The raw transaction data as a JSON string. For advanced users only; exercise caution when interpreting this data.",
      "type": "string"
    }
  },
  "required": [
    "id",
    "address",
    "sequence",
    "type",
    "specification",
    "outcome"
  ],
  "additionalProperties": false,
  "oneOf": [
    {
      "properties": {
        "type": {
          "enum": [
            "payment"
          ]
        },
        "specification": {
          "$ref": "getPayment"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "order"
          ]
        },
        "specification": {
          "$ref": "order"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "orderCancellation"
          ]
        },
        "specification": {
          "$ref": "orderCancellation"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "trustline"
          ]
        },
        "specification": {
          "$ref": "trustline"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "settings"
          ]
        },
        "specification": {
          "$ref": "getSettings"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "checkCreate"
          ]
        },
        "specification": {
          "$ref": "checkCreate"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "checkCancel"
          ]
        },
        "specification": {
          "$ref": "checkCancel"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "checkCash"
          ]
        },
        "specification": {
          "$ref": "checkCash"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "escrowCreation"
          ]
        },
        "specification": {
          "$ref": "escrowCreation"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "escrowCancellation"
          ]
        },
        "specification": {
          "$ref": "escrowCancellation"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "escrowExecution"
          ]
        },
        "specification": {
          "$ref": "escrowExecution"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "paymentChannelCreate"
          ]
        },
        "specification": {
          "$ref": "paymentChannelCreate"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "paymentChannelFund"
          ]
        },
        "specification": {
          "$ref": "paymentChannelFund"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "paymentChannelClaim"
          ]
        },
        "specification": {
          "$ref": "paymentChannelClaim"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "depositPreauth"
          ]
        },
        "specification": {
          "$ref": "depositPreauth"
        }
      }
    },
    {
      "properties": {
        "type": {
          "enum": [
            "accountDelete"
          ]
        },
        "specification": {
          "$ref": "accountDelete"
        }
      }
    }
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-transaction.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-transactions.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-transactions.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getTransactions",
  "type": "array",
  "items": {
    "$ref": "getTransaction"
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-transactions.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-trustlines.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cget-trustlines.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getTrustlines",
  "type": "array",
  "items": {
    "properties": {
      "specification": {
        "$ref": "trustline",
        "description": "A trust line specification that would produce this trust line in its current state."
      },
      "counterparty": {
        "properties": {
          "limit": {
            "$ref": "value",
            "description": "The maximum amount that the counterparty can be owed through the trust line."
          },
          "ripplingDisabled": {
            "type": "boolean",
            "description": "If true, payments cannot ripple through this trustline."
          },
          "frozen": {
            "type": "boolean",
            "description": "If true, the trust line is frozen, which means that funds can only be sent directly to the counterparty."
          },
          "authorized": {
            "type": "boolean",
            "description": "If true, the counterparty authorizes this party to hold issuances from the counterparty."
          }
        },
        "description": "Properties of the trustline from the perspective of the counterparty.",
        "required": ["limit"],
        "additionalProperties": false
      },
      "state": {
        "properties": {
          "balance": {
            "$ref": "signedValue",
            "description": "The balance on the trust line, representing which party owes the other and by how much."
          }
        },
        "description": "Non-settings details of the trust line's state.",
        "required": ["balance"],
        "additionalProperties": false
      }
    },
    "required": ["specification", "counterparty", "state"],
    "additionalProperties": false
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\get-trustlines.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\ledger-event.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cledger-event.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "ledgerEvent",
  "description": "A ledger event message",
  "type": "object",
  "properties": {
    "baseFeeXRP": {
      "$ref": "value",
      "description": "Base fee, in XRP."
    },
    "ledgerHash": {
      "$ref": "hash256",
      "description": "Unique hash of the ledger that was closed, as hex."
    },
    "ledgerVersion": {
      "$ref": "ledgerVersion",
      "description": "Ledger version of the ledger that closed."
    },
    "ledgerTimestamp": {
      "type": "string",
      "format": "date-time",
      "description": "The time at which this ledger closed."
    },
    "reserveBaseXRP": {
      "$ref": "value",
      "description": "The minimum reserve, in XRP, that is required for an account."
    },
    "reserveIncrementXRP": {
      "$ref": "value",
      "description": "The increase in account reserve that is added for each item the account owns, such as offers or trust lines."
    },
    "transactionCount": {
      "type": "integer",
      "minimum": 0,
      "description": "Number of new transactions included in this ledger."
    },
    "validatedLedgerVersions": {
      "type": "string",
      "description": "Range of ledgers that the server has available. This may be discontiguous."
    }
  },
  "addtionalProperties": false,
  "required": ["baseFeeXRP", "ledgerHash", "ledgerTimestamp",
    "reserveBaseXRP", "reserveIncrementXRP", "transactionCount",
    "ledgerVersion", "validatedLedgerVersions"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\ledger-event.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\order-change.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Corder-change.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "orderChange",
  "type": "object",
  "description": "A change to an order.",
  "properties": {
    "direction": {
      "type": "string",
      "enum": ["buy", "sell"],
      "description": "Equal to \"buy\" for buy orders and \"sell\" for sell orders."
    },
    "quantity": {
      "$ref": "amount",
      "description": "The amount to be bought or sold by the maker."
    },
    "totalPrice": {
      "$ref": "amount",
      "description": "The total amount to be paid or received by the taker."
    },
    "makerExchangeRate": {
      "$ref": "value",
      "description": "The exchange rate between the `quantity` currency and the `totalPrice` currency from the point of view of the maker."
    },
    "sequence": {
      "$ref": "sequence",
      "description": "The order sequence number, used to identify the order for cancellation"
    },
    "status": {
      "enum": ["created", "filled", "partially-filled", "cancelled"],
      "description": "The status of the order. One of \"created\", \"filled\", \"partially-filled\", \"cancelled\"."
    },
    "expirationTime": {
      "type": "string",
      "format": "date-time",
      "description": "The time after which the order expires, if any."
    }
  },
  "required": ["direction", "quantity", "totalPrice", "sequence", "status"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\order-change.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\orderbook-orders.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Corderbook-orders.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "orderbookOrders",
  "type": "array",
  "items": {
    "description": "An order in the order book.",
    "type": "object",
    "properties": {
      "specification": {
        "$ref": "order",
        "description": "An order specification that would create an order equivalent to the current state of this order."
      },
      "properties": {
        "description": "Properties of the order not in the specification.",
        "type": "object",
        "properties": {
          "maker": {
            "$ref": "address",
            "description": "The address of the account that submitted the order."
          },
          "sequence": {
            "$ref": "sequence",
            "description": "The account sequence number of the transaction that created this order."
          },
          "makerExchangeRate": {
            "$ref": "value",
            "description": "The exchange rate from the point of view of the account that submitted the order (also known as \"quality\")."
          }
        },
        "required": ["maker", "sequence", "makerExchangeRate"],
        "addtionalProperties": false
      },
      "state": {
        "description": "The state of the order.",
        "type": "object",
        "properties": {
          "fundedAmount": {
            "$ref": "amount",
            "description": "How much of the amount the maker would have to pay that the maker currently holds."
          },
          "priceOfFundedAmount": {
            "$ref": "amount",
            "description": "How much the `fundedAmount` would convert to through the exchange rate of this order."
          }
        },
        "required": ["fundedAmount", "priceOfFundedAmount"],
        "additionalProperties": false
      },
      "data": {
        "description": "The raw order data. This may include `owner_funds`, `Flags`, and other fields.",
        "type": "object",
        "additionalProperties": true
      }
    },
    "required": ["specification", "properties", "data"],
    "additionalProperties": false
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\orderbook-orders.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\outcome.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Coutcome.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "outcome",
  "type": "object",
  "description": "The outcome of the transaction (what effects it had).",
  "properties": {
    "result": {
      "type": "string",
      "description": "Result code returned by rippled. See [Transaction Results](https://xrpl.org/transaction-results.html) for a complete list."
    },
    "timestamp": {
      "type": "string",
      "format": "date-time",
      "description": "The timestamp when the transaction was validated. (May be missing when requesting transactions in binary mode.)"
    },
    "fee": {
      "$ref": "value",
      "description": "The XRP fee that was charged for the transaction."
    },
    "deliveredAmount": {
      "$ref": "amount",
      "description": "For payment transactions, it is impossible to reliably compute the actual delivered amount from the balanceChanges due to fixed precision. If the payment is not a partial payment and the transaction succeeded, the deliveredAmount should always be considered to be the amount specified in the transaction."
    },
    "balanceChanges": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "description": "Key is the XRP Ledger address; value is an array of signed amounts representing changes of balances for that address.",
        "items": {"$ref": "balance"}
      }
    },
    "orderbookChanges": {
      "type": "object",
      "additionalProperties": {
        "type": "array",
        "description": "Key is the maker's XRP Ledger address; value is an array of changes",
        "items": {"$ref": "orderChange"}
      }
    },
    "channelChanges": {
      "type": "object",
      "description": "Properties reflecting the details of the payment channel."
    },
    "ledgerVersion": {
      "$ref": "ledgerVersion",
      "description": "The ledger version that the transaction was validated in."
    },
    "indexInLedger": {
      "type": "integer",
      "minimum": 0,
      "description": "The ordering index of the transaction in the ledger."
    }
  },
  "required": ["result", "fee", "balanceChanges",
    "orderbookChanges", "ledgerVersion", "indexInLedger"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\outcome.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\prepare.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cprepare.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "prepare",
  "description": "Result of prepare function",
  "type": "object",
  "properties": {
    "txJSON": {
      "type": "string",
      "description": "The prepared transaction in rippled JSON format."
    },
    "instructions": {
      "description": "The instructions for how to execute the transaction after adding automatic defaults.",
      "type": "object",
      "properties": {
        "fee": {
          "$ref": "value",
          "description": "The fee to pay for the transaction. See [Transaction Fees](#transaction-fees) for more information. For multi-signed transactions, this fee is multiplied by (N+1), where N is the number of signatures you plan to provide."
        },
        "sequence": {
          "$ref": "sequence",
          "description": "The initiating account's sequence number for this transaction. `sequence` and `ticketSequence` are mutually exclusive, only one of them can be set."
        },
        "ticketSequence": {
          "$ref": "ticket-sequence",
          "description": "The initiating account's ticket sequence number for this transaction. `sequence` and `ticketSequence` are mutually exclusive, only one of them can be set."
        },
        "maxLedgerVersion": {
          "oneOf": [
            {"$ref": "ledgerVersion"},
            {"type": "null"}
          ],
          "description": "The highest ledger version that the transaction can be included in. Set to `null` if there is no maximum. If not null, this must be an integer greater than 0, or one of the following strings: 'validated', 'closed', 'current'."
        }
      },
      "additionalProperties": false,
      "required": ["fee", "maxLedgerVersion"],
      "anyOf": [
          { "required":
            [ "sequence" ] },
          { "required":
            [ "ticketSequence" ] }
        ]
      }
  },
  "additionalProperties": false,
  "required": ["txJSON", "instructions"]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\prepare.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\sign-payment-channel-claim.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Csign-payment-channel-claim.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "signPaymentChannelClaim",
  "type": "string",
  "$ref": "signature",
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\sign-payment-channel-claim.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\sign.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Csign.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "sign",
  "type": "object",
  "properties": {
    "signedTransaction": {
      "type": "string",
      "pattern": "^[A-F0-9]+$",
      "description": "The signed transaction represented as an uppercase hexadecimal string."
    },
    "id": {
      "$ref": "transactionHash",
      "description": "The [Transaction ID](#transaction-id) of the signed transaction."
    }
  },
  "required": ["signedTransaction", "id"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\sign.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\submit.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Csubmit.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "submit",
  "type": "object",
  "properties": {
    "resultCode": {
      "type": "string",
      "description": "Deprecated: Use `engine_result` instead."
    },
    "resultMessage": {
      "type": "string",
      "description": "Deprecated: Use `engine_result_message` instead."
    },
    "engine_result": {
      "type": "string",
      "description": "Code indicating the preliminary result of the transaction, for example `tesSUCCESS`. [List of transaction responses](https://xrpl.org/transaction-results.html)"
    },
    "engine_result_code": {
      "type": "integer",
      "description": "Numeric code indicating the preliminary result of the transaction, directly correlated to `engine_result`"
    },
    "engine_result_message": {
      "type": "string",
      "description": "Human-readable explanation of the transaction's preliminary result."
    },
    "tx_blob": {
      "type": "string",
      "description": "The complete transaction in hex string format."
    },
    "tx_json": {
      "$ref": "tx-json",
      "description": "The complete transaction in JSON format."
    }
  },
  "required": ["resultCode", "resultMessage", "engine_result", "engine_result_code", "engine_result_message", "tx_blob", "tx_json"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\submit.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\verify-payment-channel-claim.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Coutput%5Cverify-payment-channel-claim.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "verifyPaymentChannelClaim",
  "type": "boolean",
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\output\\verify-payment-channel-claim.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\account-delete.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Caccount-delete.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "accountDelete",
  "link": "account-delete",
  "type": "object",
  "properties": {
    "destination": {
      "$ref": "address",
      "description": "Address of an account to receive any leftover XRP after deleting the sending account. Must be a funded account in the ledger, and must not be the sending account."
    },
    "destinationTag": {
      "$ref": "tag",
      "description": "(Optional) Arbitrary destination tag that identifies a hosted recipient or other information for the recipient of the deleted account's leftover XRP."
    },
    "destinationXAddress": {
      "$ref": "address",
      "description": "X-address of an account to receive any leftover XRP after deleting the sending account. Must be a funded account in the ledger, and must not be the sending account."
    },
    "memos": {"$ref": "memos"}
  },
  "anyOf": [
    {
      "required": ["destination"]
    },
    {
      "required": ["destinationXAddress"]
    }
  ],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\account-delete.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\check-cancel.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Ccheck-cancel.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "checkCancel",
  "link": "check-cancel",
  "type": "object",
  "properties": {
    "checkID": {
      "$ref": "hash256",
      "description": "The ID of the Check ledger object to cancel, as a 64-character hexadecimal string."
    },
    "memos": {"$ref": "memos"}
  },
  "required": ["checkID"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\check-cancel.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\check-cash.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Ccheck-cash.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "checkCash",
  "link": "check-cash",
  "type": "object",
  "properties": {
    "checkID": {
      "$ref": "hash256",
      "description": "The ID of the Check ledger object to cash, as a 64-character hexadecimal string."
    },
    "amount": {
      "$ref": "laxAmount",
      "description": "Redeem the Check for exactly this amount, if possible. The currency must match that of the sendMax of the corresponding CheckCreate transaction. You must provide either this field or deliverMin."
    },
    "deliverMin": {
      "$ref": "laxAmount",
      "description": "Redeem the Check for at least this amount and for as much as possible. The currency must match that of the sendMax of the corresponding CheckCreate transaction. You must provide either this field or amount."
    },
    "memos": {"$ref": "memos"}
  },
  "required": ["checkID"],
  "oneOf": [
    {"required": ["amount"]},
    {"required": ["deliverMin"]}
  ],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\check-cash.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\check-create.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Ccheck-create.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "checkCreate",
  "link": "check-create",
  "type": "object",
  "properties": {
    "destination": {
      "$ref": "address",
      "description": "Address of the account that can cash the check."
    },
    "sendMax": {
      "$ref": "laxAmount",
      "description": "Amount of source currency the check is allowed to debit the sender, including transfer fees on non-XRP currencies."
    },
    "destinationTag": {
      "$ref": "tag",
      "description": "Destination tag that identifies the reason for the check, or a hosted recipient to pay."
    },
    "expiration": {
      "type": "string",
      "format": "date-time",
      "description": "Time after which the check is no longer valid."
    },
    "invoiceID": {
      "$ref": "hash256",
      "description": "256-bit hash, as a 64-character hexadecimal string, representing a specific reason or identifier for this check."
    },
    "memos": {"$ref": "memos"}
  },
  "required": ["destination", "sendMax"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\check-create.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\deposit-preauth.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Cdeposit-preauth.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "depositPreauth",
  "link": "deposit-preauth",
  "type": "object",
  "properties": {
    "authorize": {
      "$ref": "address",
      "description": "Address of the account that can cash the check."
    },
    "unauthorize": {
      "$ref": "address",
      "description": "Address of the account that can cash the check."
    },
    "memos": {"$ref": "memos"}
  },
  "oneOf": [
    {"required": ["authorize"]},
    {"required": ["unauthorize"]}
  ],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\deposit-preauth.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\escrow-cancellation.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Cescrow-cancellation.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "escrowCancellation",
  "link": "escrow-cancellation",
  "type": "object",
  "properties": {
    "memos": {"$ref": "memos"},
    "owner": {
      "$ref": "address",
      "description": "The address of the owner of the escrow to cancel."
    },
    "escrowSequence": {
      "$ref": "sequence",
      "description": "The [account sequence number](#account-sequence-number) of the [Escrow Creation](#escrow-creation) transaction for the escrow to cancel."
    }
  },
  "required": ["owner", "escrowSequence"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\escrow-cancellation.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\escrow-creation.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Cescrow-creation.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "escrowCreation",
  "link": "escrow-creation",
  "type": "object",
  "properties": {
    "amount": {
      "$ref": "value",
      "description": "Amount of XRP for sender to escrow."
    },
    "destination": {
      "$ref": "address",
      "description": "Address to receive escrowed XRP."
    },
    "memos": {"$ref": "memos"},
    "condition": {
      "type": "string",
      "description": "A hex value representing a [PREIMAGE-SHA-256 crypto-condition](https://tools.ietf.org/html/draft-thomas-crypto-conditions-02#section-8.1). If present, `fulfillment` is required upon execution.",
      "pattern": "^[A-F0-9]{0,256}$"
    },
    "allowCancelAfter": {
      "type": "string",
      "format": "date-time",
      "description": "If present, the escrow may be cancelled after this time."
    },
    "allowExecuteAfter": {
      "type": "string",
      "format": "date-time",
      "description": "If present, the escrow can not be executed before this time."
    },
    "sourceTag": {
      "$ref": "tag",
      "description": "Source tag."
    },
    "destinationTag": {
      "$ref": "tag",
      "description": "Destination tag."
    }
  },
  "required": ["amount", "destination"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\escrow-creation.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\escrow-execution.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Cescrow-execution.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "escrowExecution",
  "link": "escrow-execution",
  "type": "object",
  "properties": {
    "memos": {"$ref": "memos"},
    "owner": {
      "$ref": "address",
      "description": "The address of the owner of the escrow to execute."
    },
    "escrowSequence": {
      "$ref": "sequence",
      "description": "The [account sequence number](#account-sequence-number) of the [Escrow Creation](#escrow-creation) transaction for the escrow to execute."
    },
    "condition": {
      "type": "string",
      "description": "A hex value representing a [PREIMAGE-SHA-256 crypto-condition](https://tools.ietf.org/html/draft-thomas-crypto-conditions-02#section-8.1). This must match the original `condition` from the escrow creation transaction.",
      "pattern": "^[A-F0-9]{0,256}$"
    },
    "fulfillment": {
      "type": "string",
      "description": "A hex value representing the [PREIMAGE-SHA-256 crypto-condition](https://tools.ietf.org/html/draft-thomas-crypto-conditions-02#section-8.1) fulfillment for `condition`.",
      "pattern": "^[A-F0-9]+$"
    }
  },
  "required": ["owner", "escrowSequence"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\escrow-execution.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\get-payment.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Cget-payment.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "getPayment",
  "description": "A specification of a payment in a response for getTransaction or getTransactions.",
  "type": "object",
  "properties": {
    "source": {
      "$ref": "sourceAdjustment",
      "description": "The source of the funds to be sent."
    },
    "destination": {
      "$ref": "destinationAddressTag",
      "description": "The destination of the funds to be sent. Since this is a payment response, the amount is not shown here. For the amount that the transaction delivered, see `outcome.deliveredAmount`."
    },
    "paths": {
      "type": "string",
      "description": "The paths of trustlines and orders to use in executing the payment."
    },
    "memos": {"$ref": "memos"},
    "invoiceID": {
      "description": "A 256-bit hash that can be used to identify a particular payment.",
      "$ref": "hash256"
    },
    "allowPartialPayment": {
      "description": "If true, this payment can deliver less than the full amount.",
      "type": "boolean"
    },
    "noDirectRipple": {
      "description": "If true and paths are specified, the sender would like the XRP Ledger to disregard any direct paths from the source account to the destination account. This may be used to take advantage of an arbitrage opportunity or by gateways wishing to issue balances from a hot wallet to a user who has mistakenly set a trustline directly to the hot wallet.",
      "type": "boolean"
    },
    "limitQuality": {
      "description": "Only take paths where all the conversions have an input:output ratio that is equal or better than the ratio of destination.amount:source.maxAmount.",
      "type": "boolean"
    }
  },
  "required": ["source", "destination"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\get-payment.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\order-cancellation.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Corder-cancellation.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "orderCancellation",
  "link": "order-cancellation",
  "type": "object",
  "properties": {
    "orderSequence": {
      "$ref": "sequence",
      "description": "The [account sequence number](#account-sequence-number) of the order to cancel."
    },
    "memos": {"$ref": "memos"}
  },
  "required": ["orderSequence"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\order-cancellation.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\order.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Corder.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "order",
  "link": "order",
  "type": "object",
  "properties": {
    "direction": {
      "type": "string",
      "enum": ["buy", "sell"],
      "description": "Equal to \"buy\" for buy orders and \"sell\" for sell orders."
    },
    "quantity": {
      "$ref": "amount",
      "description": "The amount of currency to buy or sell."
    },
    "totalPrice": {
      "$ref": "amount",
      "description": "The total price to be paid for the `quantity` to be bought or sold."
    },
    "immediateOrCancel": {
      "type": "boolean",
      "description": "Treat the offer as an [Immediate or Cancel order](http://en.wikipedia.org/wiki/Immediate_or_cancel). If enabled, do not create an object in the ledger that can be matched later: instead, only execute as much as can be fulfilled immediately. This cannot be used with `fillOrKill`."
    },
    "fillOrKill": {
      "type": "boolean",
      "description": "Treat the offer as a [Fill or Kill order](http://en.wikipedia.org/wiki/Fill_or_kill). Only attempt to match existing offers in the ledger, and only do so if the entire quantity can be exchanged. This cannot be used with `immediateOrCancel`."
    },
    "passive": {
      "description": "If enabled, the offer does not consume offers that exactly match it, and instead becomes an Offer node in the ledger. It still consumes offers that cross it.",
      "type": "boolean"
    },
    "expirationTime": {
      "type": "string",
      "format": "date-time",
      "description": "Time after which the offer is no longer active, as an [ISO 8601 date-time](https://en.wikipedia.org/wiki/ISO_8601)."
    },
    "orderToReplace": {
      "$ref": "sequence",
      "description": "The [account sequence number](#account-sequence-number) of an order to cancel before the new order is created, effectively replacing the old order."
    },
    "memos": {"$ref": "memos"}
  },
  "required": ["direction", "quantity", "totalPrice"],
  "additionalProperties": false,
  "not": {
    "description": "immediateOrCancel and fillOrKill are mutually exclusive",
    "required": ["immediateOrCancel", "fillOrKill"]
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\order.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment-channel-claim.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Cpayment-channel-claim.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "paymentChannelClaim",
  "link": "payment-channel-claim",
  "type": "object",
  "properties": {
    "channel": {
      "$ref": "hash256",
      "description": "256-bit hexadecimal channel identifier."
    },
    "amount": {
      "$ref": "value",
      "description": "Amount of XRP authorized by this signature."
    },
    "balance": {
      "$ref": "value",
      "description": "Total XRP balance delivered by this channel after claim is processed."
    },
    "signature": {
      "$ref": "signature",
      "description": "Signed claim authorizing withdrawal of XRP from the channel. (Required except from the channel's source address.)"
    },
    "publicKey": {
      "$ref": "publicKey",
      "description": "Public key of the channel. (For verifying the signature.)"
    },
    "renew": {
      "type": "boolean",
      "description": "Clear the channel's expiration time."
    },
    "close": {
      "type": "boolean",
      "description": "Request to close the channel. If the channel has no XRP remaining or the destination address requests it, closes the channel immediately (returning unclaimed XRP to the source address). Otherwise, sets the channel to expire after settleDelay seconds have passed."
    },
    "memos": {"$ref": "memos"}
  },
  "required": ["channel"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment-channel-claim.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment-channel-create.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Cpayment-channel-create.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "paymentChannelCreate",
  "link": "payment-channel-create",
  "type": "object",
  "properties": {
    "amount": {
      "$ref": "value",
      "description": "Amount of XRP for sender to set aside in this channel."
    },
    "destination": {
      "$ref": "address",
      "description": "Address to receive XRP claims against this channel."
    },
    "settleDelay": {
      "type": "number",
      "description": "Amount of seconds the source address must wait before closing the channel if it has unclaimed XRP."
    },
    "publicKey": {
      "$ref": "publicKey",
      "description": "Public key of the key pair the source may use to sign claims against this channel."
    },
    "cancelAfter": {
      "type": "string",
      "format": "date-time",
      "description": "Time when this channel expires. This expiration cannot be changed after creating the channel."
    },
    "sourceTag": {
      "$ref": "tag",
      "description": "Source tag."
    },
    "destinationTag": {
      "$ref": "tag",
      "description": "Destination tag."
    },
    "memos": {"$ref": "memos"}
  },
  "required": ["amount", "destination", "settleDelay", "publicKey"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment-channel-create.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment-channel-fund.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Cpayment-channel-fund.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "paymentChannelFund",
  "link": "payment-channel-fund",
  "type": "object",
  "properties": {
    "amount": {
      "$ref": "value",
      "description": "Amount of XRP to fund the channel with."
    },
    "channel": {
      "$ref": "hash256",
      "description": "256-bit hexadecimal channel identifier."
    },
    "expiration": {
      "type": "string",
      "format": "date-time",
      "description": "New expiration for this channel. (This does not change the cancelAfter expiration, if the channel has one.) Cannot move the expiration sooner than settleDelay seconds from time of the request."
    },
    "memos": {"$ref": "memos"}
  },
  "required": ["amount", "channel"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment-channel-fund.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Cpayment.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "payment",
  "link": "payment",
  "type": "object",
  "properties": {
    "source": {
      "$ref": "sourceAdjustment",
      "description": "The source of the funds to be sent."
    },
    "destination": {
      "$ref": "destinationAdjustment",
      "description": "The destination of the funds to be sent."
    },
    "paths": {
      "type": "string",
      "description": "The paths of trustlines and orders to use in executing the payment."
    },
    "memos": {"$ref": "memos"},
    "invoiceID": {
      "description": "A 256-bit hash that can be used to identify a particular payment.",
      "$ref": "hash256"
    },
    "allowPartialPayment": {
      "description": "If true, this payment can deliver less than the full amount.",
      "type": "boolean"
    },
    "noDirectRipple": {
      "description": "If true and paths are specified, the sender would like the XRP Ledger to disregard any direct paths from the source account to the destination account. This may be used to take advantage of an arbitrage opportunity or by gateways wishing to issue balances from a hot wallet to a user who has mistakenly set a trustline directly to the hot wallet.",
      "type": "boolean"
    },
    "limitQuality": {
      "description": "Only take paths where all the conversions have an input:output ratio that is equal or better than the ratio of destination.amount:source.maxAmount.",
      "type": "boolean"
    }
  },
  "required": ["source", "destination"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\payment.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\settings.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Csettings.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "settings",
  "link": "settings",
  "$ref": "settingsPlusMemos",
  "oneOf": [
    {
      "required": ["memos"],
      "minProperties": 2,
      "maxProperties": 2
    },
    {
      "not": {
        "required": ["memos"]
      },
      "minProperties": 1,
      "maxProperties": 1
    }
  ]
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\settings.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\trustline.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cschemas%5Cspecifications%5Ctrustline.json
      return function (require, module, exports) {
module.exports={
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "trustline",
  "link": "trustline",
  "type": "object",
  "properties": {
    "currency": {
      "$ref": "currency",
      "description": "The currency this trustline applies to."
    },
    "counterparty": {
      "$ref": "address",
      "description": "The address of the account this trustline extends trust to."
    },
    "limit": {
      "$ref": "value",
      "description": "The maximum amount that the owner of the trustline can be owed through the trustline."
    },
    "qualityIn": {
      "$ref": "quality",
      "description": "Incoming balances on this trustline are valued at this ratio."
    },
    "qualityOut": {
      "$ref": "quality",
      "description": "Outgoing balances on this trustline are valued at this ratio."
    },
    "ripplingDisabled": {
      "type": "boolean",
      "description": "If true, payments cannot ripple through this trustline."
    },
    "authorized": {
      "type": "boolean",
      "description": "If true, authorize the counterparty to hold issuances from this account."
    },
    "frozen": {
      "type": "boolean",
      "description": "If true, the trustline is frozen, which means that funds can only be sent to the owner."
    },
    "memos": {"$ref": "memos"}
  },
  "required": ["currency", "counterparty", "limit"],
  "additionalProperties": false
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\schemas\\specifications\\trustline.json",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\serverinfo.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cserverinfo.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFee = exports.getServerInfo = void 0;
const utils_1 = require("./utils");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
function renameKeys(object, mapping) {
    Object.entries(mapping).forEach(entry => {
        const [from, to] = entry;
        object[to] = object[from];
        delete object[from];
    });
}
function getServerInfo() {
    return this.request('server_info').then((response) => {
        const info = utils_1.convertKeysFromSnakeCaseToCamelCase(response.info);
        renameKeys(info, { hostid: 'hostID' });
        if (info.validatedLedger) {
            renameKeys(info.validatedLedger, {
                baseFeeXrp: 'baseFeeXRP',
                reserveBaseXrp: 'reserveBaseXRP',
                reserveIncXrp: 'reserveIncrementXRP',
                seq: 'ledgerVersion'
            });
            info.validatedLedger.baseFeeXRP = info.validatedLedger.baseFeeXRP.toString();
            info.validatedLedger.reserveBaseXRP = info.validatedLedger.reserveBaseXRP.toString();
            info.validatedLedger.reserveIncrementXRP = info.validatedLedger.reserveIncrementXRP.toString();
        }
        return info;
    });
}
exports.getServerInfo = getServerInfo;
function getFee(cushion) {
    return __awaiter(this, void 0, void 0, function* () {
        if (cushion == null) {
            cushion = this._feeCushion;
        }
        if (cushion == null) {
            cushion = 1.2;
        }
        const serverInfo = (yield this.request('server_info')).info;
        const baseFeeXrp = new bignumber_js_1.default(serverInfo.validated_ledger.base_fee_xrp);
        if (serverInfo.load_factor == null) {
            serverInfo.load_factor = 1;
        }
        let fee = baseFeeXrp.times(serverInfo.load_factor).times(cushion);
        fee = bignumber_js_1.default.min(fee, this._maxFeeXRP);
        return new bignumber_js_1.default(fee.toFixed(6)).toString(10);
    });
}
exports.getFee = getFee;
//# sourceMappingURL=serverinfo.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\serverinfo.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\txflags.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Ctxflags.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.txFlagIndices = exports.txFlags = void 0;
const txFlags = {
    Universal: {
        FullyCanonicalSig: 0x80000000
    },
    AccountSet: {
        RequireDestTag: 0x00010000,
        OptionalDestTag: 0x00020000,
        RequireAuth: 0x00040000,
        OptionalAuth: 0x00080000,
        DisallowXRP: 0x00100000,
        AllowXRP: 0x00200000
    },
    TrustSet: {
        SetAuth: 0x00010000,
        NoRipple: 0x00020000,
        SetNoRipple: 0x00020000,
        ClearNoRipple: 0x00040000,
        SetFreeze: 0x00100000,
        ClearFreeze: 0x00200000
    },
    OfferCreate: {
        Passive: 0x00010000,
        ImmediateOrCancel: 0x00020000,
        FillOrKill: 0x00040000,
        Sell: 0x00080000
    },
    Payment: {
        NoRippleDirect: 0x00010000,
        PartialPayment: 0x00020000,
        LimitQuality: 0x00040000
    },
    PaymentChannelClaim: {
        Renew: 0x00010000,
        Close: 0x00020000
    }
};
exports.txFlags = txFlags;
const txFlagIndices = {
    AccountSet: {
        asfRequireDest: 1,
        asfRequireAuth: 2,
        asfDisallowXRP: 3,
        asfDisableMaster: 4,
        asfAccountTxnID: 5,
        asfNoFreeze: 6,
        asfGlobalFreeze: 7,
        asfDefaultRipple: 8,
        asfDepositAuth: 9
    }
};
exports.txFlagIndices = txFlagIndices;
//# sourceMappingURL=txflags.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\txflags.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\types\\objects\\ledger.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Ctypes%5Cobjects%5Cledger.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=ledger.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\types\\objects\\ledger.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\utils.js", {"./errors":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\errors.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js","ripple-keypairs":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cutils.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidSecret = exports.iso8601ToRippleTime = exports.rippleTimeToISO8601 = exports.removeUndefined = exports.convertKeysFromSnakeCaseToCamelCase = exports.toRippledAmount = exports.xrpToDrops = exports.dropsToXrp = void 0;
const _ = __importStar(require("lodash"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ripple_keypairs_1 = require("ripple-keypairs");
const errors_1 = require("./errors");
const ripple_address_codec_1 = require("ripple-address-codec");
function isValidSecret(secret) {
    try {
        ripple_keypairs_1.deriveKeypair(secret);
        return true;
    }
    catch (err) {
        return false;
    }
}
exports.isValidSecret = isValidSecret;
function dropsToXrp(drops) {
    if (typeof drops === 'string') {
        if (!drops.match(/^-?[0-9]*\.?[0-9]*$/)) {
            throw new errors_1.ValidationError(`dropsToXrp: invalid value '${drops}',` +
                ` should be a number matching (^-?[0-9]*\\.?[0-9]*$).`);
        }
        else if (drops === '.') {
            throw new errors_1.ValidationError(`dropsToXrp: invalid value '${drops}',` +
                ` should be a BigNumber or string-encoded number.`);
        }
    }
    drops = new bignumber_js_1.default(drops).toString(10);
    if (drops.includes('.')) {
        throw new errors_1.ValidationError(`dropsToXrp: value '${drops}' has` + ` too many decimal places.`);
    }
    if (!drops.match(/^-?[0-9]+$/)) {
        throw new errors_1.ValidationError(`dropsToXrp: failed sanity check -` +
            ` value '${drops}',` +
            ` does not match (^-?[0-9]+$).`);
    }
    return new bignumber_js_1.default(drops).dividedBy(1000000.0).toString(10);
}
exports.dropsToXrp = dropsToXrp;
function xrpToDrops(xrp) {
    if (typeof xrp === 'string') {
        if (!xrp.match(/^-?[0-9]*\.?[0-9]*$/)) {
            throw new errors_1.ValidationError(`xrpToDrops: invalid value '${xrp}',` +
                ` should be a number matching (^-?[0-9]*\\.?[0-9]*$).`);
        }
        else if (xrp === '.') {
            throw new errors_1.ValidationError(`xrpToDrops: invalid value '${xrp}',` +
                ` should be a BigNumber or string-encoded number.`);
        }
    }
    xrp = new bignumber_js_1.default(xrp).toString(10);
    if (!xrp.match(/^-?[0-9.]+$/)) {
        throw new errors_1.ValidationError(`xrpToDrops: failed sanity check -` +
            ` value '${xrp}',` +
            ` does not match (^-?[0-9.]+$).`);
    }
    const components = xrp.split('.');
    if (components.length > 2) {
        throw new errors_1.ValidationError(`xrpToDrops: failed sanity check -` +
            ` value '${xrp}' has` +
            ` too many decimal points.`);
    }
    const fraction = components[1] || '0';
    if (fraction.length > 6) {
        throw new errors_1.ValidationError(`xrpToDrops: value '${xrp}' has` + ` too many decimal places.`);
    }
    return new bignumber_js_1.default(xrp)
        .times(1000000.0)
        .integerValue(bignumber_js_1.default.ROUND_FLOOR)
        .toString(10);
}
exports.xrpToDrops = xrpToDrops;
function toRippledAmount(amount) {
    if (typeof amount === 'string')
        return amount;
    if (amount.currency === 'XRP') {
        return xrpToDrops(amount.value);
    }
    if (amount.currency === 'drops') {
        return amount.value;
    }
    let issuer = amount.counterparty || amount.issuer;
    let tag = false;
    try {
        ({ classicAddress: issuer, tag } = ripple_address_codec_1.xAddressToClassicAddress(issuer));
    }
    catch (e) { }
    if (tag !== false) {
        throw new errors_1.ValidationError("Issuer X-address includes a tag");
    }
    return {
        currency: amount.currency,
        issuer,
        value: amount.value
    };
}
exports.toRippledAmount = toRippledAmount;
function convertKeysFromSnakeCaseToCamelCase(obj) {
    if (typeof obj === 'object') {
        const accumulator = Array.isArray(obj) ? [] : {};
        let newKey;
        return Object.entries(obj).reduce((result, [key, value]) => {
            newKey = key;
            const FINDSNAKE = /([a-zA-Z]_[a-zA-Z])/g;
            if (FINDSNAKE.test(key)) {
                newKey = key.replace(FINDSNAKE, (r) => r[0] + r[2].toUpperCase());
            }
            result[newKey] = convertKeysFromSnakeCaseToCamelCase(value);
            return result;
        }, accumulator);
    }
    return obj;
}
exports.convertKeysFromSnakeCaseToCamelCase = convertKeysFromSnakeCaseToCamelCase;
function removeUndefined(obj) {
    return _.omitBy(obj, value => value == null);
}
exports.removeUndefined = removeUndefined;
function rippleToUnixTimestamp(rpepoch) {
    return (rpepoch + 0x386d4380) * 1000;
}
function unixToRippleTimestamp(timestamp) {
    return Math.round(timestamp / 1000) - 0x386d4380;
}
function rippleTimeToISO8601(rippleTime) {
    return new Date(rippleToUnixTimestamp(rippleTime)).toISOString();
}
exports.rippleTimeToISO8601 = rippleTimeToISO8601;
function iso8601ToRippleTime(iso8601) {
    return unixToRippleTimestamp(Date.parse(iso8601));
}
exports.iso8601ToRippleTime = iso8601ToRippleTime;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\utils.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\validate.js", {"./errors":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\errors.js","./schema-validator":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schema-validator.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cvalidate.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tx_json = exports.instructions = exports.apiOptions = exports.verifyPaymentChannelClaim = exports.signPaymentChannelClaim = exports.generateAddress = exports.computeLedgerHash = exports.submit = exports.combine = exports.sign = exports.prepareTicketCreate = exports.prepareCheckCancel = exports.prepareCheckCash = exports.prepareCheckCreate = exports.preparePaymentChannelClaim = exports.preparePaymentChannelFund = exports.preparePaymentChannelCreate = exports.prepareEscrowExecution = exports.prepareEscrowCancellation = exports.prepareEscrowCreation = exports.prepareSettings = exports.prepareTrustline = exports.prepareOrderCancellation = exports.prepareOrder = exports.preparePayment = exports.getLedger = exports.getPaymentChannel = exports.getTransaction = exports.getOrderbook = exports.getOrders = exports.getBalanceSheet = exports.getBalances = exports.getTrustlines = exports.getAccountInfo = exports.getSettings = exports.getTransactions = exports.getPaths = void 0;
const _ = __importStar(require("lodash"));
const errors_1 = require("./errors");
const schema_validator_1 = require("./schema-validator");
function error(text) {
    return new errors_1.ValidationError(text);
}
function validateLedgerRange(options) {
    if (options != null &&
        options.minLedgerVersion != null &&
        options.maxLedgerVersion != null) {
        if (Number(options.minLedgerVersion) > Number(options.maxLedgerVersion)) {
            throw error('minLedgerVersion must not be greater than maxLedgerVersion');
        }
    }
}
function validateOptions(schema, instance) {
    schema_validator_1.schemaValidate(schema, instance);
    validateLedgerRange(instance.options);
}
exports.getPaths = _.partial(schema_validator_1.schemaValidate, 'getPathsParameters');
exports.getTransactions = _.partial(validateOptions, 'getTransactionsParameters');
exports.getSettings = _.partial(validateOptions, 'getSettingsParameters');
exports.getAccountInfo = _.partial(validateOptions, 'getAccountInfoParameters');
exports.getTrustlines = _.partial(validateOptions, 'getTrustlinesParameters');
exports.getBalances = _.partial(validateOptions, 'getBalancesParameters');
exports.getBalanceSheet = _.partial(validateOptions, 'getBalanceSheetParameters');
exports.getOrders = _.partial(validateOptions, 'getOrdersParameters');
exports.getOrderbook = _.partial(validateOptions, 'getOrderbookParameters');
exports.getTransaction = _.partial(validateOptions, 'getTransactionParameters');
exports.getPaymentChannel = _.partial(validateOptions, 'getPaymentChannelParameters');
exports.getLedger = _.partial(validateOptions, 'getLedgerParameters');
exports.preparePayment = _.partial(schema_validator_1.schemaValidate, 'preparePaymentParameters');
exports.prepareOrder = _.partial(schema_validator_1.schemaValidate, 'prepareOrderParameters');
exports.prepareOrderCancellation = _.partial(schema_validator_1.schemaValidate, 'prepareOrderCancellationParameters');
exports.prepareTrustline = _.partial(schema_validator_1.schemaValidate, 'prepareTrustlineParameters');
exports.prepareSettings = _.partial(schema_validator_1.schemaValidate, 'prepareSettingsParameters');
exports.prepareEscrowCreation = _.partial(schema_validator_1.schemaValidate, 'prepareEscrowCreationParameters');
exports.prepareEscrowCancellation = _.partial(schema_validator_1.schemaValidate, 'prepareEscrowCancellationParameters');
exports.prepareEscrowExecution = _.partial(schema_validator_1.schemaValidate, 'prepareEscrowExecutionParameters');
exports.preparePaymentChannelCreate = _.partial(schema_validator_1.schemaValidate, 'preparePaymentChannelCreateParameters');
exports.preparePaymentChannelFund = _.partial(schema_validator_1.schemaValidate, 'preparePaymentChannelFundParameters');
exports.preparePaymentChannelClaim = _.partial(schema_validator_1.schemaValidate, 'preparePaymentChannelClaimParameters');
exports.prepareCheckCreate = _.partial(schema_validator_1.schemaValidate, 'prepareCheckCreateParameters');
exports.prepareCheckCash = _.partial(schema_validator_1.schemaValidate, 'prepareCheckCashParameters');
exports.prepareCheckCancel = _.partial(schema_validator_1.schemaValidate, 'prepareCheckCancelParameters');
exports.prepareTicketCreate = _.partial(schema_validator_1.schemaValidate, 'prepareTicketParameters');
exports.sign = _.partial(schema_validator_1.schemaValidate, 'signParameters');
exports.combine = _.partial(schema_validator_1.schemaValidate, 'combineParameters');
exports.submit = _.partial(schema_validator_1.schemaValidate, 'submitParameters');
exports.computeLedgerHash = _.partial(schema_validator_1.schemaValidate, 'computeLedgerHashParameters');
exports.generateAddress = _.partial(schema_validator_1.schemaValidate, 'generateAddressParameters');
exports.signPaymentChannelClaim = _.partial(schema_validator_1.schemaValidate, 'signPaymentChannelClaimParameters');
exports.verifyPaymentChannelClaim = _.partial(schema_validator_1.schemaValidate, 'verifyPaymentChannelClaimParameters');
exports.apiOptions = _.partial(schema_validator_1.schemaValidate, 'api-options');
exports.instructions = _.partial(schema_validator_1.schemaValidate, 'instructions');
exports.tx_json = _.partial(schema_validator_1.schemaValidate, 'tx-json');
//# sourceMappingURL=validate.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\validate.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\wswrapper.js", {"events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ccommon%5Cwswrapper.js
      return function (require, module, exports) {
"use strict";
const events_1 = require("events");
class WSWrapper extends events_1.EventEmitter {
    constructor(url, _protocols, _websocketOptions) {
        super();
        this.setMaxListeners(Infinity);
        this._ws = new WebSocket(url);
        this._ws.onclose = () => {
            this.emit('close');
        };
        this._ws.onopen = () => {
            this.emit('open');
        };
        this._ws.onerror = (error) => {
            this.emit('error', error);
        };
        this._ws.onmessage = (message) => {
            this.emit('message', message.data);
        };
    }
    close() {
        if (this.readyState === 1) {
            this._ws.close();
        }
    }
    send(message) {
        this._ws.send(message);
    }
    get readyState() {
        return this._ws.readyState;
    }
}
WSWrapper.CONNECTING = 0;
WSWrapper.OPEN = 1;
WSWrapper.CLOSING = 2;
WSWrapper.CLOSED = 3;
module.exports = WSWrapper;
//# sourceMappingURL=wswrapper.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\common\\wswrapper.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\index.js", {"./api":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\api.js","./broadcast":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\broadcast.js","./common/types/objects/ledger":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\types\\objects\\ledger.js","./offline/utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\utils.js","./transaction/types":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\types.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./api"), exports);
__exportStar(require("./transaction/types"), exports);
__exportStar(require("./common/types/objects/ledger"), exports);
__exportStar(require("./offline/utils"), exports);
var broadcast_1 = require("./broadcast");
Object.defineProperty(exports, "RippleAPIBroadcast", { enumerable: true, get: function () { return broadcast_1.RippleAPIBroadcast; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\index.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\accountinfo.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Caccountinfo.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../common");
function formatAccountInfo(response) {
    const data = response.account_data;
    return common_1.removeUndefined({
        sequence: data.Sequence,
        xrpBalance: common_1.dropsToXrp(data.Balance),
        ownerCount: data.OwnerCount,
        previousInitiatedTransactionID: data.AccountTxnID,
        previousAffectingTransactionID: data.PreviousTxnID,
        previousAffectingTransactionLedgerVersion: data.PreviousTxnLgrSeq
    });
}
function getAccountInfo(address, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getAccountInfo({ address, options });
        address = common_1.ensureClassicAddress(address);
        const response = yield this.request('account_info', {
            account: address,
            ledger_index: options.ledgerVersion || 'validated'
        });
        return formatAccountInfo(response);
    });
}
exports.default = getAccountInfo;
//# sourceMappingURL=accountinfo.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\accountinfo.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\accountobjects.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Caccountobjects.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../common");
function getAccountObjects(address, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield this.request('account_objects', common_1.removeUndefined({
            account: address,
            type: options.type,
            ledger_hash: options.ledgerHash,
            ledger_index: options.ledgerIndex,
            limit: options.limit,
            marker: options.marker
        }));
        return response;
    });
}
exports.default = getAccountObjects;
//# sourceMappingURL=accountobjects.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\accountobjects.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\balance-sheet.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cbalance-sheet.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../common");
const utils_1 = require("./utils");
function formatBalanceSheet(balanceSheet) {
    const result = {};
    if (balanceSheet.balances != null) {
        result.balances = [];
        Object.entries(balanceSheet.balances).forEach(entry => {
            const [counterparty, balances] = entry;
            balances.forEach((balance) => {
                result.balances.push(Object.assign({ counterparty }, balance));
            });
        });
    }
    if (balanceSheet.assets != null) {
        result.assets = [];
        Object.entries(balanceSheet.assets).forEach(([counterparty, assets]) => {
            assets.forEach((balance) => {
                result.assets.push(Object.assign({ counterparty }, balance));
            });
        });
    }
    if (balanceSheet.obligations != null) {
        result.obligations = Object.entries(balanceSheet.obligations).map(([currency, value]) => ({ currency, value }));
    }
    return result;
}
function getBalanceSheet(address, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getBalanceSheet({ address, options });
        options = yield utils_1.ensureLedgerVersion.call(this, options);
        const response = yield this.request('gateway_balances', {
            account: address,
            strict: true,
            hotwallet: options.excludeAddresses,
            ledger_index: options.ledgerVersion
        });
        return formatBalanceSheet(response);
    });
}
exports.default = getBalanceSheet;
//# sourceMappingURL=balance-sheet.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\balance-sheet.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\balances.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cbalances.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const common_1 = require("../common");
function getTrustlineBalanceAmount(trustline) {
    return {
        currency: trustline.specification.currency,
        counterparty: trustline.specification.counterparty,
        value: trustline.state.balance
    };
}
function formatBalances(options, balances) {
    const result = balances.trustlines.map(getTrustlineBalanceAmount);
    if (!(options.counterparty || (options.currency && options.currency !== 'XRP'))) {
        const xrpBalance = {
            currency: 'XRP',
            value: balances.xrp
        };
        result.unshift(xrpBalance);
    }
    if (options.limit && result.length > options.limit) {
        const toRemove = result.length - options.limit;
        result.splice(-toRemove, toRemove);
    }
    return result;
}
function getLedgerVersionHelper(connection, optionValue) {
    if (optionValue != null && optionValue !== null) {
        return Promise.resolve(optionValue);
    }
    return connection.getLedgerVersion();
}
function getBalances(address, options = {}) {
    common_1.validate.getTrustlines({ address, options });
    address = common_1.ensureClassicAddress(address);
    return Promise.all([
        getLedgerVersionHelper(this.connection, options.ledgerVersion).then((ledgerVersion) => utils.getXRPBalance(this.connection, address, ledgerVersion)),
        this.getTrustlines(address, options)
    ]).then((results) => formatBalances(options, { xrp: results[0], trustlines: results[1] }));
}
exports.default = getBalances;
//# sourceMappingURL=balances.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\balances.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\ledger.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./parse/ledger":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\ledger.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cledger.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("../common");
const ledger_1 = require("./parse/ledger");
function getLedger(options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getLedger({ options });
        const response = yield this.request('ledger', {
            ledger_hash: options.ledgerHash,
            ledger_index: options.ledgerVersion || 'validated',
            expand: options.includeAllData,
            transactions: options.includeTransactions,
            accounts: options.includeState
        });
        return ledger_1.parseLedger(response.ledger);
    });
}
exports.default = getLedger;
//# sourceMappingURL=ledger.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\ledger.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\orderbook.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./parse/orderbook-order":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\orderbook-order.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Corderbook.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrderbook = exports.formatBidsAndAsks = void 0;
const _ = __importStar(require("lodash"));
const utils = __importStar(require("./utils"));
const orderbook_order_1 = require("./parse/orderbook-order");
const common_1 = require("../common");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
function isSameIssue(a, b) {
    return a.currency === b.currency && a.counterparty === b.counterparty;
}
function directionFilter(direction, order) {
    return order.specification.direction === direction;
}
function flipOrder(order) {
    const specification = order.specification;
    const flippedSpecification = {
        quantity: specification.totalPrice,
        totalPrice: specification.quantity,
        direction: specification.direction === 'buy' ? 'sell' : 'buy'
    };
    const newSpecification = _.merge({}, specification, flippedSpecification);
    return _.merge({}, order, { specification: newSpecification });
}
function alignOrder(base, order) {
    const quantity = order.specification.quantity;
    return isSameIssue(quantity, base) ? order : flipOrder(order);
}
function formatBidsAndAsks(orderbook, offers) {
    const orders = offers
        .sort((a, b) => {
        return new bignumber_js_1.default(a.quality).comparedTo(b.quality);
    })
        .map(orderbook_order_1.parseOrderbookOrder);
    const alignedOrders = orders.map(_.partial(alignOrder, orderbook.base));
    const bids = alignedOrders.filter(_.partial(directionFilter, 'buy'));
    const asks = alignedOrders.filter(_.partial(directionFilter, 'sell'));
    return { bids, asks };
}
exports.formatBidsAndAsks = formatBidsAndAsks;
function makeRequest(api, taker, options, takerGets, takerPays) {
    return __awaiter(this, void 0, void 0, function* () {
        const orderData = utils.renameCounterpartyToIssuerInOrder({
            taker_gets: takerGets,
            taker_pays: takerPays
        });
        return api._requestAll('book_offers', {
            taker_gets: orderData.taker_gets,
            taker_pays: orderData.taker_pays,
            ledger_index: options.ledgerVersion || 'validated',
            limit: options.limit,
            taker
        });
    });
}
function getOrderbook(address, orderbook, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getOrderbook({ address, orderbook, options });
        const [directOfferResults, reverseOfferResults] = yield Promise.all([
            makeRequest(this, address, options, orderbook.base, orderbook.counter),
            makeRequest(this, address, options, orderbook.counter, orderbook.base)
        ]);
        const directOffers = _.flatMap(directOfferResults, (directOfferResult) => directOfferResult.offers);
        const reverseOffers = _.flatMap(reverseOfferResults, (reverseOfferResult) => reverseOfferResult.offers);
        return formatBidsAndAsks(orderbook, [...directOffers, ...reverseOffers]);
    });
}
exports.getOrderbook = getOrderbook;
//# sourceMappingURL=orderbook.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\orderbook.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\orders.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./parse/account-order":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\account-order.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Corders.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const common_1 = require("../common");
const account_order_1 = require("./parse/account-order");
function formatResponse(address, responses) {
    let orders = [];
    for (const response of responses) {
        const offers = response.offers.map((offer) => {
            return account_order_1.parseAccountOrder(address, offer);
        });
        orders = orders.concat(offers);
    }
    return _.sortBy(orders, (order) => order.properties.sequence);
}
function getOrders(address, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getOrders({ address, options });
        const responses = yield this._requestAll('account_offers', {
            account: address,
            ledger_index: options.ledgerVersion || (yield this.getLedgerVersion()),
            limit: options.limit
        });
        return formatResponse(address, responses);
    });
}
exports.default = getOrders;
//# sourceMappingURL=orders.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\orders.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\account-delete.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Caccount-delete.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const common_1 = require("../../common");
const ripple_address_codec_1 = require("ripple-address-codec");
const utils_1 = require("./utils");
function parseAccountDelete(tx) {
    assert.ok(tx.TransactionType === 'AccountDelete');
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        destination: tx.Destination,
        destinationTag: tx.DestinationTag,
        destinationXAddress: ripple_address_codec_1.classicAddressToXAddress(tx.Destination, tx.DestinationTag == null ? false : tx.DestinationTag, false)
    });
}
exports.default = parseAccountDelete;
//# sourceMappingURL=account-delete.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\account-delete.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\account-order.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","./flags":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\flags.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Caccount-order.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAccountOrder = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const amount_1 = __importDefault(require("./amount"));
const utils_1 = require("./utils");
const common_1 = require("../../common");
const flags_1 = require("./flags");
function computeQuality(takerGets, takerPays) {
    const quotient = new bignumber_js_1.default(takerPays.value).dividedBy(takerGets.value);
    return quotient.precision(16, bignumber_js_1.default.ROUND_HALF_UP).toString();
}
function parseAccountOrder(address, order) {
    const direction = (order.flags & flags_1.orderFlags.Sell) === 0 ? 'buy' : 'sell';
    const takerGetsAmount = amount_1.default(order.taker_gets);
    const takerPaysAmount = amount_1.default(order.taker_pays);
    const quantity = direction === 'buy' ? takerPaysAmount : takerGetsAmount;
    const totalPrice = direction === 'buy' ? takerGetsAmount : takerPaysAmount;
    const specification = common_1.removeUndefined({
        direction: direction,
        quantity: quantity,
        totalPrice: totalPrice,
        passive: (order.flags & flags_1.orderFlags.Passive) !== 0 || undefined,
        expirationTime: utils_1.parseTimestamp(order.expiration)
    });
    const makerExchangeRate = order.quality
        ? utils_1.adjustQualityForXRP(order.quality.toString(), takerGetsAmount.currency, takerPaysAmount.currency)
        : computeQuality(takerGetsAmount, takerPaysAmount);
    const properties = {
        maker: address,
        sequence: order.seq,
        makerExchangeRate: makerExchangeRate
    };
    return { specification, properties };
}
exports.parseAccountOrder = parseAccountOrder;
//# sourceMappingURL=account-order.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\account-order.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\account-trustline.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Caccount-trustline.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const common_1 = require("../../common");
function parseAccountTrustline(trustline) {
    const specification = common_1.removeUndefined({
        limit: trustline.limit,
        currency: trustline.currency,
        counterparty: trustline.account,
        qualityIn: utils_1.parseQuality(trustline.quality_in) || undefined,
        qualityOut: utils_1.parseQuality(trustline.quality_out) || undefined,
        ripplingDisabled: trustline.no_ripple,
        frozen: trustline.freeze,
        authorized: trustline.authorized
    });
    const counterparty = common_1.removeUndefined({
        limit: trustline.limit_peer,
        ripplingDisabled: trustline.no_ripple_peer,
        frozen: trustline.freeze_peer,
        authorized: trustline.peer_authorized
    });
    const state = {
        balance: trustline.balance
    };
    return { specification, counterparty, state };
}
exports.default = parseAccountTrustline;
//# sourceMappingURL=account-trustline.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\account-trustline.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amendment.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Camendment.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function parseAmendment(tx) {
    return {
        amendment: tx.Amendment
    };
}
exports.default = parseAmendment;
//# sourceMappingURL=amendment.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amendment.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Camount.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const common = __importStar(require("../../common"));
function parseAmount(amount) {
    if (typeof amount === 'string') {
        return {
            currency: 'XRP',
            value: common.dropsToXrp(amount)
        };
    }
    return {
        currency: amount.currency,
        value: amount.value,
        counterparty: amount.issuer
    };
}
exports.default = parseAmount;
//# sourceMappingURL=amount.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\cancellation.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Ccancellation.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const utils_1 = require("./utils");
function parseOrderCancellation(tx) {
    assert.ok(tx.TransactionType === 'OfferCancel');
    return {
        memos: utils_1.parseMemos(tx),
        orderSequence: tx.OfferSequence
    };
}
exports.default = parseOrderCancellation;
//# sourceMappingURL=cancellation.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\cancellation.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\check-cancel.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Ccheck-cancel.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const common_1 = require("../../common");
const utils_1 = require("./utils");
function parseCheckCancel(tx) {
    assert.ok(tx.TransactionType === 'CheckCancel');
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        checkID: tx.CheckID
    });
}
exports.default = parseCheckCancel;
//# sourceMappingURL=check-cancel.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\check-cancel.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\check-cash.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Ccheck-cash.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const common_1 = require("../../common");
const amount_1 = __importDefault(require("./amount"));
const utils_1 = require("./utils");
function parseCheckCash(tx) {
    assert.ok(tx.TransactionType === 'CheckCash');
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        checkID: tx.CheckID,
        amount: tx.Amount && amount_1.default(tx.Amount),
        deliverMin: tx.DeliverMin && amount_1.default(tx.DeliverMin)
    });
}
exports.default = parseCheckCash;
//# sourceMappingURL=check-cash.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\check-cash.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\check-create.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Ccheck-create.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const utils_1 = require("./utils");
const common_1 = require("../../common");
const amount_1 = __importDefault(require("./amount"));
const utils_2 = require("./utils");
function parseCheckCreate(tx) {
    assert.ok(tx.TransactionType === 'CheckCreate');
    return common_1.removeUndefined({
        memos: utils_2.parseMemos(tx),
        destination: tx.Destination,
        sendMax: amount_1.default(tx.SendMax),
        destinationTag: tx.DestinationTag,
        expiration: tx.Expiration && utils_1.parseTimestamp(tx.Expiration),
        invoiceID: tx.InvoiceID
    });
}
exports.default = parseCheckCreate;
//# sourceMappingURL=check-create.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\check-create.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\deposit-preauth.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cdeposit-preauth.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const common_1 = require("../../common");
const utils_1 = require("./utils");
function parseDepositPreauth(tx) {
    assert.ok(tx.TransactionType === 'DepositPreauth');
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        authorize: tx.Authorize,
        unauthorize: tx.Unauthorize
    });
}
exports.default = parseDepositPreauth;
//# sourceMappingURL=deposit-preauth.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\deposit-preauth.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\escrow-cancellation.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cescrow-cancellation.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const utils_1 = require("./utils");
const common_1 = require("../../common");
function parseEscrowCancellation(tx) {
    assert.ok(tx.TransactionType === 'EscrowCancel');
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        owner: tx.Owner,
        escrowSequence: tx.OfferSequence
    });
}
exports.default = parseEscrowCancellation;
//# sourceMappingURL=escrow-cancellation.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\escrow-cancellation.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\escrow-creation.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cescrow-creation.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const amount_1 = __importDefault(require("./amount"));
const utils_1 = require("./utils");
const common_1 = require("../../common");
function parseEscrowCreation(tx) {
    assert.ok(tx.TransactionType === 'EscrowCreate');
    return common_1.removeUndefined({
        amount: amount_1.default(tx.Amount).value,
        destination: tx.Destination,
        memos: utils_1.parseMemos(tx),
        condition: tx.Condition,
        allowCancelAfter: utils_1.parseTimestamp(tx.CancelAfter),
        allowExecuteAfter: utils_1.parseTimestamp(tx.FinishAfter),
        sourceTag: tx.SourceTag,
        destinationTag: tx.DestinationTag
    });
}
exports.default = parseEscrowCreation;
//# sourceMappingURL=escrow-creation.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\escrow-creation.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\escrow-execution.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cescrow-execution.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const utils_1 = require("./utils");
const common_1 = require("../../common");
function parseEscrowExecution(tx) {
    assert.ok(tx.TransactionType === 'EscrowFinish');
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        owner: tx.Owner,
        escrowSequence: tx.OfferSequence,
        condition: tx.Condition,
        fulfillment: tx.Fulfillment
    });
}
exports.default = parseEscrowExecution;
//# sourceMappingURL=escrow-execution.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\escrow-execution.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\fee-update.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cfee-update.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const common_1 = require("../../common");
const utils_1 = require("./utils");
function parseFeeUpdate(tx) {
    const baseFeeDrops = new bignumber_js_1.default(tx.BaseFee, 16).toString();
    return {
        memos: utils_1.parseMemos(tx),
        baseFeeXRP: common_1.dropsToXrp(baseFeeDrops),
        referenceFeeUnits: tx.ReferenceFeeUnits,
        reserveBaseXRP: common_1.dropsToXrp(tx.ReserveBase),
        reserveIncrementXRP: common_1.dropsToXrp(tx.ReserveIncrement)
    };
}
exports.default = parseFeeUpdate;
//# sourceMappingURL=fee-update.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\fee-update.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\fields.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cfields.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const common_1 = require("../../common");
const AccountFields = common_1.constants.AccountFields;
function parseField(info, value) {
    if (info.encoding === 'hex' && !info.length) {
        return Buffer.from(value, 'hex').toString('ascii');
    }
    if (info.shift) {
        return new bignumber_js_1.default(value).shiftedBy(-info.shift).toNumber();
    }
    return value;
}
function parseFields(data) {
    const settings = {};
    for (const fieldName in AccountFields) {
        const fieldValue = data[fieldName];
        if (fieldValue != null) {
            const info = AccountFields[fieldName];
            settings[info.name] = parseField(info, fieldValue);
        }
    }
    if (data.RegularKey) {
        settings.regularKey = data.RegularKey;
    }
    if (data.signer_lists && data.signer_lists.length === 1) {
        settings.signers = {};
        if (data.signer_lists[0].SignerQuorum) {
            settings.signers.threshold = data.signer_lists[0].SignerQuorum;
        }
        if (data.signer_lists[0].SignerEntries) {
            settings.signers.weights = data.signer_lists[0].SignerEntries.map((entry) => {
                return {
                    address: entry.SignerEntry.Account,
                    weight: entry.SignerEntry.SignerWeight
                };
            });
        }
    }
    return settings;
}
exports.default = parseFields;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\fields.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\flags.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cflags.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trustlineFlags = exports.orderFlags = void 0;
const orderFlags = {
    Passive: 0x00010000,
    Sell: 0x00020000
};
exports.orderFlags = orderFlags;
const trustlineFlags = {
    LowReserve: 0x00010000,
    HighReserve: 0x00020000,
    LowAuth: 0x00040000,
    HighAuth: 0x00080000,
    LowNoRipple: 0x00100000,
    HighNoRipple: 0x00200000,
    LowFreeze: 0x00400000,
    HighFreeze: 0x00800000
};
exports.trustlineFlags = trustlineFlags;
//# sourceMappingURL=flags.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\flags.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\ledger.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./transaction":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\transaction.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cledger.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLedger = void 0;
const _ = __importStar(require("lodash"));
const common_1 = require("../../common");
const transaction_1 = __importDefault(require("./transaction"));
function parseTransactionWrapper(ledgerVersion, tx) {
    const transaction = Object.assign({}, _.omit(tx, 'metaData'), {
        meta: tx.metaData,
        ledger_index: ledgerVersion
    });
    const result = transaction_1.default(transaction, true);
    if (!result.outcome.ledgerVersion) {
        result.outcome.ledgerVersion = ledgerVersion;
    }
    return result;
}
function parseTransactions(transactions, ledgerVersion) {
    if (_.isEmpty(transactions)) {
        return {};
    }
    if (typeof transactions[0] === 'string') {
        return { transactionHashes: transactions };
    }
    return {
        transactions: transactions.map(_.partial(parseTransactionWrapper, ledgerVersion))
    };
}
function parseState(state) {
    if (_.isEmpty(state)) {
        return {};
    }
    if (typeof state[0] === 'string') {
        return { stateHashes: state };
    }
    return { rawState: JSON.stringify(state) };
}
function parseLedger(ledger) {
    const ledgerVersion = parseInt(ledger.ledger_index, 10);
    return common_1.removeUndefined(Object.assign({
        stateHash: ledger.account_hash,
        closeTime: common_1.rippleTimeToISO8601(ledger.close_time),
        closeTimeResolution: ledger.close_time_resolution,
        closeFlags: ledger.close_flags,
        ledgerHash: ledger.ledger_hash,
        ledgerVersion: ledgerVersion,
        parentLedgerHash: ledger.parent_hash,
        parentCloseTime: common_1.rippleTimeToISO8601(ledger.parent_close_time),
        totalDrops: ledger.total_coins,
        transactionHash: ledger.transaction_hash
    }, parseTransactions(ledger.transactions, ledgerVersion), parseState(ledger.accountState)));
}
exports.parseLedger = parseLedger;
//# sourceMappingURL=ledger.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\ledger.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\order.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Corder.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const utils_1 = require("./utils");
const utils_2 = require("./utils");
const amount_1 = __importDefault(require("./amount"));
const common_1 = require("../../common");
const flags = common_1.txFlags.OfferCreate;
function parseOrder(tx) {
    assert.ok(tx.TransactionType === 'OfferCreate');
    const direction = (tx.Flags & flags.Sell) === 0 ? 'buy' : 'sell';
    const takerGetsAmount = amount_1.default(tx.TakerGets);
    const takerPaysAmount = amount_1.default(tx.TakerPays);
    const quantity = direction === 'buy' ? takerPaysAmount : takerGetsAmount;
    const totalPrice = direction === 'buy' ? takerGetsAmount : takerPaysAmount;
    return common_1.removeUndefined({
        memos: utils_2.parseMemos(tx),
        direction: direction,
        quantity: quantity,
        totalPrice: totalPrice,
        passive: (tx.Flags & flags.Passive) !== 0 || undefined,
        immediateOrCancel: (tx.Flags & flags.ImmediateOrCancel) !== 0 || undefined,
        fillOrKill: (tx.Flags & flags.FillOrKill) !== 0 || undefined,
        expirationTime: utils_1.parseTimestamp(tx.Expiration)
    });
}
exports.default = parseOrder;
//# sourceMappingURL=order.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\order.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\orderbook-order.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","./flags":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\flags.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Corderbook-order.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOrderbookOrder = void 0;
const _ = __importStar(require("lodash"));
const utils_1 = require("./utils");
const common_1 = require("../../common");
const flags_1 = require("./flags");
const amount_1 = __importDefault(require("./amount"));
function parseOrderbookOrder(data) {
    const direction = (data.Flags & flags_1.orderFlags.Sell) === 0 ? 'buy' : 'sell';
    const takerGetsAmount = amount_1.default(data.TakerGets);
    const takerPaysAmount = amount_1.default(data.TakerPays);
    const quantity = direction === 'buy' ? takerPaysAmount : takerGetsAmount;
    const totalPrice = direction === 'buy' ? takerGetsAmount : takerPaysAmount;
    const specification = common_1.removeUndefined({
        direction: direction,
        quantity: quantity,
        totalPrice: totalPrice,
        passive: (data.Flags & flags_1.orderFlags.Passive) !== 0 || undefined,
        expirationTime: utils_1.parseTimestamp(data.Expiration)
    });
    const properties = {
        maker: data.Account,
        sequence: data.Sequence,
        makerExchangeRate: utils_1.adjustQualityForXRP(data.quality, takerGetsAmount.currency, takerPaysAmount.currency)
    };
    const takerGetsFunded = data.taker_gets_funded
        ? amount_1.default(data.taker_gets_funded)
        : undefined;
    const takerPaysFunded = data.taker_pays_funded
        ? amount_1.default(data.taker_pays_funded)
        : undefined;
    const available = common_1.removeUndefined({
        fundedAmount: takerGetsFunded,
        priceOfFundedAmount: takerPaysFunded
    });
    const state = _.isEmpty(available) ? undefined : available;
    return common_1.removeUndefined({ specification, properties, state, data });
}
exports.parseOrderbookOrder = parseOrderbookOrder;
//# sourceMappingURL=orderbook-order.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\orderbook-order.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\pathfind.js", {"./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cpathfind.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const amount_1 = __importDefault(require("./amount"));
function parsePaths(paths) {
    return paths.map((steps) => steps.map((step) => _.omit(step, ['type', 'type_hex'])));
}
function removeAnyCounterpartyEncoding(address, amount) {
    return amount.counterparty === address
        ? _.omit(amount, 'counterparty')
        : amount;
}
function createAdjustment(address, adjustmentWithoutAddress) {
    const amountKey = Object.keys(adjustmentWithoutAddress)[0];
    const amount = adjustmentWithoutAddress[amountKey];
    return _.set({ address: address }, amountKey, removeAnyCounterpartyEncoding(address, amount));
}
function parseAlternative(sourceAddress, destinationAddress, destinationAmount, alternative) {
    const amounts = alternative.destination_amount != null
        ? {
            source: { amount: amount_1.default(alternative.source_amount) },
            destination: { minAmount: amount_1.default(alternative.destination_amount) }
        }
        : {
            source: { maxAmount: amount_1.default(alternative.source_amount) },
            destination: { amount: amount_1.default(destinationAmount) }
        };
    return {
        source: createAdjustment(sourceAddress, amounts.source),
        destination: createAdjustment(destinationAddress, amounts.destination),
        paths: JSON.stringify(parsePaths(alternative.paths_computed))
    };
}
function parsePathfind(pathfindResult) {
    const sourceAddress = pathfindResult.source_account;
    const destinationAddress = pathfindResult.destination_account;
    const destinationAmount = pathfindResult.destination_amount;
    return pathfindResult.alternatives.map((alt) => parseAlternative(sourceAddress, destinationAddress, destinationAmount, alt));
}
exports.default = parsePathfind;
//# sourceMappingURL=pathfind.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\pathfind.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel-claim.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cpayment-channel-claim.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const common_1 = require("../../common");
const amount_1 = __importDefault(require("./amount"));
const utils_1 = require("./utils");
const claimFlags = common_1.txFlags.PaymentChannelClaim;
function parsePaymentChannelClaim(tx) {
    assert.ok(tx.TransactionType === 'PaymentChannelClaim');
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        channel: tx.Channel,
        balance: tx.Balance && amount_1.default(tx.Balance).value,
        amount: tx.Amount && amount_1.default(tx.Amount).value,
        signature: tx.Signature,
        publicKey: tx.PublicKey,
        renew: Boolean(tx.Flags & claimFlags.Renew) || undefined,
        close: Boolean(tx.Flags & claimFlags.Close) || undefined
    });
}
exports.default = parsePaymentChannelClaim;
//# sourceMappingURL=payment-channel-claim.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel-claim.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel-create.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cpayment-channel-create.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const utils_1 = require("./utils");
const common_1 = require("../../common");
const amount_1 = __importDefault(require("./amount"));
function parsePaymentChannelCreate(tx) {
    assert.ok(tx.TransactionType === 'PaymentChannelCreate');
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        amount: amount_1.default(tx.Amount).value,
        destination: tx.Destination,
        settleDelay: tx.SettleDelay,
        publicKey: tx.PublicKey,
        cancelAfter: tx.CancelAfter && utils_1.parseTimestamp(tx.CancelAfter),
        sourceTag: tx.SourceTag,
        destinationTag: tx.DestinationTag
    });
}
exports.default = parsePaymentChannelCreate;
//# sourceMappingURL=payment-channel-create.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel-create.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel-fund.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cpayment-channel-fund.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const utils_1 = require("./utils");
const common_1 = require("../../common");
const amount_1 = __importDefault(require("./amount"));
function parsePaymentChannelFund(tx) {
    assert.ok(tx.TransactionType === 'PaymentChannelFund');
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        channel: tx.Channel,
        amount: amount_1.default(tx.Amount).value,
        expiration: tx.Expiration && utils_1.parseTimestamp(tx.Expiration)
    });
}
exports.default = parsePaymentChannelFund;
//# sourceMappingURL=payment-channel-fund.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel-fund.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cpayment-channel.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePaymentChannel = void 0;
const utils_1 = require("./utils");
const common_1 = require("../../common");
function parsePaymentChannel(data) {
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(data),
        account: data.Account,
        amount: common_1.dropsToXrp(data.Amount),
        balance: common_1.dropsToXrp(data.Balance),
        destination: data.Destination,
        publicKey: data.PublicKey,
        settleDelay: data.SettleDelay,
        expiration: utils_1.parseTimestamp(data.Expiration),
        cancelAfter: utils_1.parseTimestamp(data.CancelAfter),
        sourceTag: data.SourceTag,
        destinationTag: data.DestinationTag,
        previousAffectingTransactionID: data.PreviousTxnID,
        previousAffectingTransactionLedgerVersion: data.PreviousTxnLgrSeq
    });
}
exports.parsePaymentChannel = parsePaymentChannel;
//# sourceMappingURL=payment-channel.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cpayment.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const assert = __importStar(require("assert"));
const utils = __importStar(require("./utils"));
const common_1 = require("../../common");
const amount_1 = __importDefault(require("./amount"));
function isNoDirectRipple(tx) {
    return (tx.Flags & common_1.txFlags.Payment.NoRippleDirect) !== 0;
}
function isQualityLimited(tx) {
    return (tx.Flags & common_1.txFlags.Payment.LimitQuality) !== 0;
}
function removeGenericCounterparty(amount, address) {
    return amount.counterparty === address
        ? _.omit(amount, 'counterparty')
        : amount;
}
function parsePayment(tx) {
    assert.ok(tx.TransactionType === 'Payment');
    const source = {
        address: tx.Account,
        maxAmount: removeGenericCounterparty(amount_1.default(tx.SendMax || tx.Amount), tx.Account),
        tag: tx.SourceTag
    };
    const destination = {
        address: tx.Destination,
        tag: tx.DestinationTag
    };
    return common_1.removeUndefined({
        source: common_1.removeUndefined(source),
        destination: common_1.removeUndefined(destination),
        memos: utils.parseMemos(tx),
        invoiceID: tx.InvoiceID,
        paths: tx.Paths ? JSON.stringify(tx.Paths) : undefined,
        allowPartialPayment: utils.isPartialPayment(tx) || undefined,
        noDirectRipple: isNoDirectRipple(tx) || undefined,
        limitQuality: isQualityLimited(tx) || undefined
    });
}
exports.default = parsePayment;
//# sourceMappingURL=payment.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\settings.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./fields":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\fields.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Csettings.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const assert = __importStar(require("assert"));
const common_1 = require("../../common");
const AccountFlags = common_1.constants.AccountFlags;
const fields_1 = __importDefault(require("./fields"));
function getAccountRootModifiedNode(tx) {
    const modifiedNodes = tx.meta.AffectedNodes.filter(node => { var _a; return ((_a = node.ModifiedNode) === null || _a === void 0 ? void 0 : _a.LedgerEntryType) === 'AccountRoot'; });
    assert.ok(modifiedNodes.length === 1);
    return modifiedNodes[0].ModifiedNode;
}
function parseFlags(tx) {
    const settings = {};
    if (tx.TransactionType !== 'AccountSet') {
        return settings;
    }
    const node = getAccountRootModifiedNode(tx);
    const oldFlags = _.get(node.PreviousFields, 'Flags');
    const newFlags = _.get(node.FinalFields, 'Flags');
    if (oldFlags != null && newFlags != null) {
        const changedFlags = oldFlags ^ newFlags;
        const setFlags = newFlags & changedFlags;
        const clearedFlags = oldFlags & changedFlags;
        Object.entries(AccountFlags).forEach(entry => {
            const [flagName, flagValue] = entry;
            if (setFlags & flagValue) {
                settings[flagName] = true;
            }
            else if (clearedFlags & flagValue) {
                settings[flagName] = false;
            }
        });
    }
    const oldField = _.get(node.PreviousFields, 'AccountTxnID');
    const newField = _.get(node.FinalFields, 'AccountTxnID');
    if (newField && !oldField) {
        settings.enableTransactionIDTracking = true;
    }
    else if (oldField && !newField) {
        settings.enableTransactionIDTracking = false;
    }
    return settings;
}
function parseSettings(tx) {
    const txType = tx.TransactionType;
    assert.ok(txType === 'AccountSet' ||
        txType === 'SetRegularKey' ||
        txType === 'SignerListSet');
    return Object.assign({}, parseFlags(tx), fields_1.default(tx));
}
exports.default = parseSettings;
//# sourceMappingURL=settings.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\settings.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\ticket-create.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cticket-create.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const common_1 = require("../../common");
const utils_1 = require("./utils");
function parseTicketCreate(tx) {
    assert.ok(tx.TransactionType === 'TicketCreate');
    return common_1.removeUndefined({
        memos: utils_1.parseMemos(tx),
        ticketCount: tx.TicketCount
    });
}
exports.default = parseTicketCreate;
//# sourceMappingURL=ticket-create.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\ticket-create.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\transaction.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./account-delete":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\account-delete.js","./amendment":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amendment.js","./cancellation":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\cancellation.js","./check-cancel":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\check-cancel.js","./check-cash":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\check-cash.js","./check-create":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\check-create.js","./deposit-preauth":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\deposit-preauth.js","./escrow-cancellation":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\escrow-cancellation.js","./escrow-creation":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\escrow-creation.js","./escrow-execution":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\escrow-execution.js","./fee-update":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\fee-update.js","./order":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\order.js","./payment":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment.js","./payment-channel-claim":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel-claim.js","./payment-channel-create":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel-create.js","./payment-channel-fund":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel-fund.js","./settings":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\settings.js","./ticket-create":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\ticket-create.js","./trustline":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\trustline.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Ctransaction.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const common_1 = require("../../common");
const settings_1 = __importDefault(require("./settings"));
const account_delete_1 = __importDefault(require("./account-delete"));
const check_cancel_1 = __importDefault(require("./check-cancel"));
const check_cash_1 = __importDefault(require("./check-cash"));
const check_create_1 = __importDefault(require("./check-create"));
const deposit_preauth_1 = __importDefault(require("./deposit-preauth"));
const escrow_cancellation_1 = __importDefault(require("./escrow-cancellation"));
const escrow_creation_1 = __importDefault(require("./escrow-creation"));
const escrow_execution_1 = __importDefault(require("./escrow-execution"));
const cancellation_1 = __importDefault(require("./cancellation"));
const order_1 = __importDefault(require("./order"));
const payment_1 = __importDefault(require("./payment"));
const payment_channel_claim_1 = __importDefault(require("./payment-channel-claim"));
const payment_channel_create_1 = __importDefault(require("./payment-channel-create"));
const payment_channel_fund_1 = __importDefault(require("./payment-channel-fund"));
const ticket_create_1 = __importDefault(require("./ticket-create"));
const trustline_1 = __importDefault(require("./trustline"));
const amendment_1 = __importDefault(require("./amendment"));
const fee_update_1 = __importDefault(require("./fee-update"));
function parseTransactionType(type) {
    const mapping = {
        AccountSet: 'settings',
        AccountDelete: 'accountDelete',
        CheckCancel: 'checkCancel',
        CheckCash: 'checkCash',
        CheckCreate: 'checkCreate',
        DepositPreauth: 'depositPreauth',
        EscrowCancel: 'escrowCancellation',
        EscrowCreate: 'escrowCreation',
        EscrowFinish: 'escrowExecution',
        OfferCancel: 'orderCancellation',
        OfferCreate: 'order',
        Payment: 'payment',
        PaymentChannelClaim: 'paymentChannelClaim',
        PaymentChannelCreate: 'paymentChannelCreate',
        PaymentChannelFund: 'paymentChannelFund',
        SetRegularKey: 'settings',
        SignerListSet: 'settings',
        TicketCreate: 'ticketCreate',
        TrustSet: 'trustline',
        EnableAmendment: 'amendment',
        SetFee: 'feeUpdate'
    };
    return mapping[type] || null;
}
function parseTransaction(tx, includeRawTransaction) {
    const type = parseTransactionType(tx.TransactionType);
    const mapping = {
        settings: settings_1.default,
        accountDelete: account_delete_1.default,
        checkCancel: check_cancel_1.default,
        checkCash: check_cash_1.default,
        checkCreate: check_create_1.default,
        depositPreauth: deposit_preauth_1.default,
        escrowCancellation: escrow_cancellation_1.default,
        escrowCreation: escrow_creation_1.default,
        escrowExecution: escrow_execution_1.default,
        orderCancellation: cancellation_1.default,
        order: order_1.default,
        payment: payment_1.default,
        paymentChannelClaim: payment_channel_claim_1.default,
        paymentChannelCreate: payment_channel_create_1.default,
        paymentChannelFund: payment_channel_fund_1.default,
        ticketCreate: ticket_create_1.default,
        trustline: trustline_1.default,
        amendment: amendment_1.default,
        feeUpdate: fee_update_1.default
    };
    const parser = mapping[type];
    const specification = parser
        ? parser(tx)
        : {
            UNAVAILABLE: 'Unrecognized transaction type.',
            SEE_RAW_TRANSACTION: 'Since this type is unrecognized, `rawTransaction` is included in this response.'
        };
    if (!parser) {
        includeRawTransaction = true;
    }
    const outcome = utils_1.parseOutcome(tx);
    return common_1.removeUndefined({
        type: type,
        address: tx.Account,
        sequence: tx.Sequence,
        id: tx.hash,
        specification: common_1.removeUndefined(specification),
        outcome: outcome ? common_1.removeUndefined(outcome) : undefined,
        rawTransaction: includeRawTransaction ? JSON.stringify(tx) : undefined
    });
}
exports.default = parseTransaction;
//# sourceMappingURL=transaction.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\transaction.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\trustline.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Ctrustline.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const utils_1 = require("./utils");
const common_1 = require("../../common");
const flags = common_1.txFlags.TrustSet;
function parseFlag(flagsValue, trueValue, falseValue) {
    if (flagsValue & trueValue) {
        return true;
    }
    if (flagsValue & falseValue) {
        return false;
    }
    return undefined;
}
function parseTrustline(tx) {
    assert.ok(tx.TransactionType === 'TrustSet');
    return common_1.removeUndefined({
        limit: tx.LimitAmount.value,
        currency: tx.LimitAmount.currency,
        counterparty: tx.LimitAmount.issuer,
        memos: utils_1.parseMemos(tx),
        qualityIn: utils_1.parseQuality(tx.QualityIn),
        qualityOut: utils_1.parseQuality(tx.QualityOut),
        ripplingDisabled: parseFlag(tx.Flags, flags.SetNoRipple, flags.ClearNoRipple),
        frozen: parseFlag(tx.Flags, flags.SetFreeze, flags.ClearFreeze),
        authorized: parseFlag(tx.Flags, flags.SetAuth, 0)
    });
}
exports.default = parseTrustline;
//# sourceMappingURL=trustline.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\trustline.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js", {"../../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./amount":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\amount.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ripple-lib-transactionparser":"F:\\metamask-extension\\node_modules\\ripple-lib-transactionparser\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cparse%5Cutils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPartialPayment = exports.adjustQualityForXRP = exports.parseTimestamp = exports.hexToString = exports.parseMemos = exports.parseOutcome = exports.parseQuality = void 0;
const ripple_lib_transactionparser_1 = __importDefault(require("ripple-lib-transactionparser"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const common = __importStar(require("../../common"));
const amount_1 = __importDefault(require("./amount"));
function adjustQualityForXRP(quality, takerGetsCurrency, takerPaysCurrency) {
    const numeratorShift = takerPaysCurrency === 'XRP' ? -6 : 0;
    const denominatorShift = takerGetsCurrency === 'XRP' ? -6 : 0;
    const shift = numeratorShift - denominatorShift;
    return shift === 0
        ? quality
        : new bignumber_js_1.default(quality).shiftedBy(shift).toString();
}
exports.adjustQualityForXRP = adjustQualityForXRP;
function parseQuality(quality) {
    if (typeof quality !== 'number') {
        return undefined;
    }
    return new bignumber_js_1.default(quality).shiftedBy(-9).toNumber();
}
exports.parseQuality = parseQuality;
function parseTimestamp(rippleTime) {
    if (typeof rippleTime !== 'number') {
        return undefined;
    }
    return common.rippleTimeToISO8601(rippleTime);
}
exports.parseTimestamp = parseTimestamp;
function removeEmptyCounterparty(amount) {
    if (amount.counterparty === '') {
        delete amount.counterparty;
    }
}
function removeEmptyCounterpartyInBalanceChanges(balanceChanges) {
    Object.entries(balanceChanges).forEach(([_, changes]) => {
        changes.forEach(removeEmptyCounterparty);
    });
}
function removeEmptyCounterpartyInOrderbookChanges(orderbookChanges) {
    Object.entries(orderbookChanges).forEach(([_, changes]) => {
        changes.forEach((change) => {
            Object.entries(change).forEach(removeEmptyCounterparty);
        });
    });
}
function isPartialPayment(tx) {
    return (tx.Flags & common.txFlags.Payment.PartialPayment) !== 0;
}
exports.isPartialPayment = isPartialPayment;
function parseDeliveredAmount(tx) {
    if (tx.TransactionType !== 'Payment' ||
        tx.meta.TransactionResult !== 'tesSUCCESS') {
        return undefined;
    }
    if (tx.meta.delivered_amount && tx.meta.delivered_amount === 'unavailable') {
        return undefined;
    }
    if (tx.meta.delivered_amount) {
        return amount_1.default(tx.meta.delivered_amount);
    }
    if (tx.meta.DeliveredAmount) {
        return amount_1.default(tx.meta.DeliveredAmount);
    }
    if (tx.Amount && !isPartialPayment(tx)) {
        return amount_1.default(tx.Amount);
    }
    if (tx.Amount && tx.ledger_index > 4594094) {
        return amount_1.default(tx.Amount);
    }
    return undefined;
}
function parseOutcome(tx) {
    const metadata = tx.meta || tx.metaData;
    if (!metadata) {
        return undefined;
    }
    const balanceChanges = ripple_lib_transactionparser_1.default.parseBalanceChanges(metadata);
    const orderbookChanges = ripple_lib_transactionparser_1.default.parseOrderbookChanges(metadata);
    const channelChanges = ripple_lib_transactionparser_1.default.parseChannelChanges(metadata);
    removeEmptyCounterpartyInBalanceChanges(balanceChanges);
    removeEmptyCounterpartyInOrderbookChanges(orderbookChanges);
    return common.removeUndefined({
        result: tx.meta.TransactionResult,
        timestamp: parseTimestamp(tx.date),
        fee: common.dropsToXrp(tx.Fee),
        balanceChanges: balanceChanges,
        orderbookChanges: orderbookChanges,
        channelChanges: channelChanges,
        ledgerVersion: tx.ledger_index,
        indexInLedger: tx.meta.TransactionIndex,
        deliveredAmount: parseDeliveredAmount(tx)
    });
}
exports.parseOutcome = parseOutcome;
function hexToString(hex) {
    return hex ? Buffer.from(hex, 'hex').toString('utf-8') : undefined;
}
exports.hexToString = hexToString;
function parseMemos(tx) {
    if (!Array.isArray(tx.Memos) || tx.Memos.length === 0) {
        return undefined;
    }
    return tx.Memos.map((m) => {
        return common.removeUndefined({
            type: m.Memo.parsed_memo_type || hexToString(m.Memo.MemoType),
            format: m.Memo.parsed_memo_format || hexToString(m.Memo.MemoFormat),
            data: m.Memo.parsed_memo_data || hexToString(m.Memo.MemoData)
        });
    });
}
exports.parseMemos = parseMemos;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\utils.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\pathfind.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./parse/pathfind":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\pathfind.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cpathfind.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils_1 = require("./utils");
const common_1 = require("../common");
const pathfind_1 = __importDefault(require("./parse/pathfind"));
const NotFoundError = common_1.errors.NotFoundError;
const ValidationError = common_1.errors.ValidationError;
function addParams(request, result) {
    return _.defaults(Object.assign({}, result, {
        source_account: request.source_account,
        source_currencies: request.source_currencies
    }), { destination_amount: request.destination_amount });
}
function requestPathFind(connection, pathfind) {
    const destinationAmount = Object.assign({
        value: pathfind.destination.amount.currency === 'XRP' ? common_1.dropsToXrp('-1') : '-1'
    }, pathfind.destination.amount);
    const request = {
        command: 'ripple_path_find',
        source_account: pathfind.source.address,
        destination_account: pathfind.destination.address,
        destination_amount: common_1.toRippledAmount(destinationAmount)
    };
    if (typeof request.destination_amount === 'object' &&
        !request.destination_amount.issuer) {
        request.destination_amount.issuer = request.destination_account;
    }
    if (pathfind.source.currencies && pathfind.source.currencies.length > 0) {
        request.source_currencies = pathfind.source.currencies.map((amount) => utils_1.renameCounterpartyToIssuer(amount));
    }
    if (pathfind.source.amount) {
        if (pathfind.destination.amount.value != null) {
            throw new ValidationError('Cannot specify both source.amount' +
                ' and destination.amount.value in getPaths');
        }
        request.send_max = common_1.toRippledAmount(pathfind.source.amount);
        if (typeof request.send_max !== 'string' && !request.send_max.issuer) {
            request.send_max.issuer = pathfind.source.address;
        }
    }
    return connection.request(request).then((paths) => addParams(request, paths));
}
function addDirectXrpPath(paths, xrpBalance) {
    const destinationAmount = paths.destination_amount;
    if (new bignumber_js_1.default(xrpBalance).isGreaterThanOrEqualTo(destinationAmount)) {
        paths.alternatives.unshift({
            paths_computed: [],
            source_amount: paths.destination_amount
        });
    }
    return paths;
}
function isRippledIOUAmount(amount) {
    return (typeof amount === 'object' && amount.currency && amount.currency !== 'XRP');
}
function conditionallyAddDirectXRPPath(connection, address, paths) {
    if (isRippledIOUAmount(paths.destination_amount) ||
        !paths.destination_currencies.includes('XRP')) {
        return Promise.resolve(paths);
    }
    return utils_1.getXRPBalance(connection, address, undefined).then((xrpBalance) => addDirectXrpPath(paths, xrpBalance));
}
function filterSourceFundsLowPaths(pathfind, paths) {
    if (pathfind.source.amount &&
        pathfind.destination.amount.value == null &&
        paths.alternatives) {
        paths.alternatives = paths.alternatives.filter((alt) => {
            if (!alt.source_amount) {
                return false;
            }
            const pathfindSourceAmountValue = new bignumber_js_1.default(pathfind.source.amount.currency === 'XRP'
                ? common_1.xrpToDrops(pathfind.source.amount.value)
                : pathfind.source.amount.value);
            const altSourceAmountValue = new bignumber_js_1.default(typeof alt.source_amount === 'string'
                ? alt.source_amount
                : alt.source_amount.value);
            return altSourceAmountValue.eq(pathfindSourceAmountValue);
        });
    }
    return paths;
}
function formatResponse(pathfind, paths) {
    if (paths.alternatives && paths.alternatives.length > 0) {
        return pathfind_1.default(paths);
    }
    if (paths.destination_currencies != null &&
        !paths.destination_currencies.includes(pathfind.destination.amount.currency)) {
        throw new NotFoundError('No paths found. ' +
            'The destination_account does not accept ' +
            pathfind.destination.amount.currency +
            ', they only accept: ' +
            paths.destination_currencies.join(', '));
    }
    else if (paths.source_currencies && paths.source_currencies.length > 0) {
        throw new NotFoundError('No paths found. Please ensure' +
            ' that the source_account has sufficient funds to execute' +
            ' the payment in one of the specified source_currencies. If it does' +
            ' there may be insufficient liquidity in the network to execute' +
            ' this payment right now');
    }
    else {
        throw new NotFoundError('No paths found.' +
            ' Please ensure that the source_account has sufficient funds to' +
            ' execute the payment. If it does there may be insufficient liquidity' +
            ' in the network to execute this payment right now');
    }
}
function getPaths(pathfind) {
    common_1.validate.getPaths({ pathfind });
    const address = pathfind.source.address;
    return requestPathFind(this.connection, pathfind)
        .then((paths) => conditionallyAddDirectXRPPath(this.connection, address, paths))
        .then((paths) => filterSourceFundsLowPaths(pathfind, paths))
        .then((paths) => formatResponse(pathfind, paths));
}
exports.default = getPaths;
//# sourceMappingURL=pathfind.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\pathfind.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\payment-channel.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./parse/payment-channel":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\payment-channel.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cpayment-channel.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const payment_channel_1 = require("./parse/payment-channel");
const common_1 = require("../common");
const NotFoundError = common_1.errors.NotFoundError;
function formatResponse(response) {
    if (response.node == null ||
        response.node.LedgerEntryType !== 'PayChannel') {
        throw new NotFoundError('Payment channel ledger entry not found');
    }
    return payment_channel_1.parsePaymentChannel(response.node);
}
function getPaymentChannel(id) {
    return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getPaymentChannel({ id });
        const response = yield this.request('ledger_entry', {
            index: id,
            binary: false,
            ledger_index: 'validated'
        });
        return formatResponse(response);
    });
}
exports.default = getPaymentChannel;
//# sourceMappingURL=payment-channel.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\payment-channel.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\settings.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./parse/fields":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\fields.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Csettings.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSettings = exports.parseAccountFlags = void 0;
const fields_1 = __importDefault(require("./parse/fields"));
const common_1 = require("../common");
const AccountFlags = common_1.constants.AccountFlags;
function parseAccountFlags(value, options = {}) {
    const settings = {};
    for (const flagName in AccountFlags) {
        if (value & AccountFlags[flagName]) {
            settings[flagName] = true;
        }
        else {
            if (!options.excludeFalse) {
                settings[flagName] = false;
            }
        }
    }
    return settings;
}
exports.parseAccountFlags = parseAccountFlags;
function formatSettings(response) {
    const data = response.account_data;
    const parsedFlags = parseAccountFlags(data.Flags, { excludeFalse: true });
    const parsedFields = fields_1.default(data);
    return Object.assign({}, parsedFlags, parsedFields);
}
function getSettings(address, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getSettings({ address, options });
        address = common_1.ensureClassicAddress(address);
        const response = yield this.request('account_info', {
            account: address,
            ledger_index: options.ledgerVersion || 'validated',
            signer_lists: true
        });
        return formatSettings(response);
    });
}
exports.getSettings = getSettings;
//# sourceMappingURL=settings.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\settings.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\transaction.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./parse/transaction":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\transaction.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Ctransaction.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const transaction_1 = __importDefault(require("./parse/transaction"));
const common_1 = require("../common");
function attachTransactionDate(connection, tx) {
    if (tx.date) {
        return Promise.resolve(tx);
    }
    const ledgerVersion = tx.ledger_index || tx.LedgerSequence;
    if (!ledgerVersion) {
        return new Promise(() => {
            const error = new common_1.errors.NotFoundError('Transaction has not been validated yet; try again later');
            error.data = {
                details: '(ledger_index and LedgerSequence not found in tx)'
            };
            throw error;
        });
    }
    const request = {
        command: 'ledger',
        ledger_index: ledgerVersion
    };
    return connection
        .request(request)
        .then((data) => {
        if (typeof data.ledger.close_time === 'number') {
            return Object.assign({ date: data.ledger.close_time }, tx);
        }
        throw new common_1.errors.UnexpectedError('Ledger missing close_time');
    })
        .catch((error) => {
        if (error instanceof common_1.errors.UnexpectedError) {
            throw error;
        }
        throw new common_1.errors.NotFoundError('Transaction ledger not found');
    });
}
function isTransactionInRange(tx, options) {
    return ((!options.minLedgerVersion ||
        tx.ledger_index >= options.minLedgerVersion) &&
        (!options.maxLedgerVersion || tx.ledger_index <= options.maxLedgerVersion));
}
function convertError(connection, options, error) {
    let shouldUseNotFoundError = false;
    if ((error.data && error.data.error === 'txnNotFound') ||
        error.message === 'txnNotFound') {
        shouldUseNotFoundError = true;
    }
    const _error = shouldUseNotFoundError
        ? new common_1.errors.NotFoundError('Transaction not found')
        : error;
    if (_error instanceof common_1.errors.NotFoundError) {
        return utils
            .hasCompleteLedgerRange(connection, options.minLedgerVersion, options.maxLedgerVersion)
            .then((hasCompleteLedgerRange) => {
            if (!hasCompleteLedgerRange) {
                return utils
                    .isPendingLedgerVersion(connection, options.maxLedgerVersion)
                    .then((isPendingLedgerVersion) => {
                    return isPendingLedgerVersion
                        ? new common_1.errors.PendingLedgerVersionError()
                        : new common_1.errors.MissingLedgerHistoryError();
                });
            }
            return _error;
        });
    }
    return Promise.resolve(_error);
}
function formatResponse(options, tx) {
    if (tx.validated !== true || !isTransactionInRange(tx, options)) {
        throw new common_1.errors.NotFoundError('Transaction not found');
    }
    return transaction_1.default(tx, options.includeRawTransaction);
}
function getTransaction(id, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getTransaction({ id, options });
        const _options = yield utils.ensureLedgerVersion.call(this, options);
        try {
            const tx = yield this.request('tx', {
                transaction: id,
                binary: false
            });
            const txWithDate = yield attachTransactionDate(this.connection, tx);
            return formatResponse(_options, txWithDate);
        }
        catch (error) {
            throw yield convertError(this.connection, _options, error);
        }
    });
}
exports.default = getTransaction;
//# sourceMappingURL=transaction.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\transaction.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\transactions.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","../common/hashes":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\index.js","./parse/transaction":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\transaction.js","./transaction":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\transaction.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\utils.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js","ripple-binary-codec":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Ctransactions.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const ripple_binary_codec_1 = __importDefault(require("ripple-binary-codec"));
const hashes_1 = require("../common/hashes");
const utils = __importStar(require("./utils"));
const transaction_1 = __importDefault(require("./parse/transaction"));
const transaction_2 = __importDefault(require("./transaction"));
const common_1 = require("../common");
function parseBinaryTransaction(transaction) {
    const tx = ripple_binary_codec_1.default.decode(transaction.tx_blob);
    tx.hash = hashes_1.computeTransactionHash(tx);
    tx.ledger_index = transaction.ledger_index;
    return {
        tx: tx,
        meta: ripple_binary_codec_1.default.decode(transaction.meta),
        validated: transaction.validated
    };
}
function parseAccountTxTransaction(tx, includeRawTransaction) {
    const _tx = tx.tx_blob ? parseBinaryTransaction(tx) : tx;
    return transaction_1.default(Object.assign({}, _tx.tx, { meta: _tx.meta, validated: _tx.validated }), includeRawTransaction);
}
function counterpartyFilter(filters, tx) {
    if (tx.address === filters.counterparty) {
        return true;
    }
    const specification = tx.specification;
    if (specification &&
        ((specification.destination &&
            specification.destination.address === filters.counterparty) ||
            specification.counterparty === filters.counterparty)) {
        return true;
    }
    return false;
}
function transactionFilter(address, filters, tx) {
    if (filters.excludeFailures && tx.outcome.result !== 'tesSUCCESS') {
        return false;
    }
    if (filters.types && !filters.types.includes(tx.type)) {
        return false;
    }
    if (filters.initiated === true && tx.address !== address) {
        return false;
    }
    if (filters.initiated === false && tx.address === address) {
        return false;
    }
    if (filters.counterparty && !counterpartyFilter(filters, tx)) {
        return false;
    }
    return true;
}
function orderFilter(options, tx) {
    return (!options.startTx ||
        (options.earliestFirst
            ? utils.compareTransactions(tx, options.startTx) > 0
            : utils.compareTransactions(tx, options.startTx) < 0));
}
function formatPartialResponse(address, options, data) {
    const parse = (tx) => parseAccountTxTransaction(tx, options.includeRawTransactions);
    return {
        marker: data.marker,
        results: data.transactions
            .filter((tx) => tx.validated)
            .map(parse)
            .filter(_.partial(transactionFilter, address, options))
            .filter(_.partial(orderFilter, options))
    };
}
function getAccountTx(connection, address, options, marker, limit) {
    const request = {
        command: 'account_tx',
        account: address,
        ledger_index_min: options.minLedgerVersion || -1,
        ledger_index_max: options.maxLedgerVersion || -1,
        forward: options.earliestFirst,
        binary: options.binary,
        limit: utils.clamp(limit, 10, 400),
        marker: marker
    };
    return connection
        .request(request)
        .then((response) => formatPartialResponse(address, options, response));
}
function checkForLedgerGaps(connection, options, transactions) {
    let { minLedgerVersion, maxLedgerVersion } = options;
    if (options.limit && transactions.length === options.limit) {
        if (options.earliestFirst) {
            maxLedgerVersion = transactions[transactions.length - 1].outcome.ledgerVersion;
        }
        else {
            minLedgerVersion = transactions[transactions.length - 1].outcome.ledgerVersion;
        }
    }
    return utils
        .hasCompleteLedgerRange(connection, minLedgerVersion, maxLedgerVersion)
        .then((hasCompleteLedgerRange) => {
        if (!hasCompleteLedgerRange) {
            throw new common_1.errors.MissingLedgerHistoryError();
        }
    });
}
function formatResponse(connection, options, transactions) {
    const sortedTransactions = options.earliestFirst
        ? transactions.sort(utils.compareTransactions)
        : transactions.sort(utils.compareTransactions).reverse();
    return checkForLedgerGaps(connection, options, sortedTransactions).then(() => sortedTransactions);
}
function getTransactionsInternal(connection, address, options) {
    const getter = _.partial(getAccountTx, connection, address, options);
    const format = _.partial(formatResponse, connection, options);
    return utils.getRecursive(getter, options.limit).then(format);
}
function getTransactions(address, options = {}) {
    common_1.validate.getTransactions({ address, options });
    address = common_1.ensureClassicAddress(address);
    const defaults = { maxLedgerVersion: -1 };
    if (options.start) {
        return transaction_2.default.call(this, options.start).then((tx) => {
            const ledgerVersion = tx.outcome.ledgerVersion;
            const bound = options.earliestFirst
                ? { minLedgerVersion: ledgerVersion }
                : { maxLedgerVersion: ledgerVersion };
            const startOptions = Object.assign({}, defaults, options, { startTx: tx }, bound);
            return getTransactionsInternal(this.connection, address, startOptions);
        });
    }
    const newOptions = Object.assign({}, defaults, options);
    return getTransactionsInternal(this.connection, address, newOptions);
}
exports.default = getTransactions;
//# sourceMappingURL=transactions.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\transactions.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\trustlines.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./parse/account-trustline":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\parse\\account-trustline.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Ctrustlines.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const common_1 = require("../common");
const account_trustline_1 = __importDefault(require("./parse/account-trustline"));
function currencyFilter(currency, trustline) {
    return currency === null || trustline.specification.currency === currency;
}
function getTrustlines(address, options = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.getTrustlines({ address, options });
        address = common_1.ensureClassicAddress(address);
        const responses = yield this._requestAll('account_lines', {
            account: address,
            ledger_index: (_a = options.ledgerVersion) !== null && _a !== void 0 ? _a : yield this.getLedgerVersion(),
            limit: options.limit,
            peer: options.counterparty
        });
        const trustlines = _.flatMap(responses, (response) => response.lines);
        return trustlines.map(account_trustline_1.default).filter((trustline) => {
            return currencyFilter(options.currency || null, trustline);
        });
    });
}
exports.default = getTrustlines;
//# sourceMappingURL=trustlines.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\trustlines.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\ledger\\utils.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cledger%5Cutils.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.common = exports.clamp = exports.isPendingLedgerVersion = exports.hasCompleteLedgerRange = exports.getRecursive = exports.renameCounterpartyToIssuerInOrder = exports.renameCounterpartyToIssuer = exports.compareTransactions = exports.ensureLedgerVersion = exports.getXRPBalance = void 0;
const _ = __importStar(require("lodash"));
const assert = __importStar(require("assert"));
const common = __importStar(require("../common"));
exports.common = common;
function clamp(value, min, max) {
    assert.ok(min <= max, 'Illegal clamp bounds');
    return Math.min(Math.max(value, min), max);
}
exports.clamp = clamp;
function getXRPBalance(connection, address, ledgerVersion) {
    const request = {
        command: 'account_info',
        account: address,
        ledger_index: ledgerVersion
    };
    return connection
        .request(request)
        .then((data) => common.dropsToXrp(data.account_data.Balance));
}
exports.getXRPBalance = getXRPBalance;
function getRecursiveRecur(getter, marker, limit) {
    return getter(marker, limit).then((data) => {
        const remaining = limit - data.results.length;
        if (remaining > 0 && data.marker != null) {
            return getRecursiveRecur(getter, data.marker, remaining).then((results) => data.results.concat(results));
        }
        return data.results.slice(0, limit);
    });
}
function getRecursive(getter, limit) {
    return getRecursiveRecur(getter, undefined, limit || Infinity);
}
exports.getRecursive = getRecursive;
function renameCounterpartyToIssuer(obj) {
    const issuer = obj.counterparty != null
        ? obj.counterparty
        : obj.issuer != null
            ? obj.issuer
            : undefined;
    const withIssuer = Object.assign({}, obj, { issuer });
    delete withIssuer.counterparty;
    return withIssuer;
}
exports.renameCounterpartyToIssuer = renameCounterpartyToIssuer;
function renameCounterpartyToIssuerInOrder(order) {
    const taker_gets = renameCounterpartyToIssuer(order.taker_gets);
    const taker_pays = renameCounterpartyToIssuer(order.taker_pays);
    const changes = { taker_gets, taker_pays };
    return Object.assign({}, order, _.omitBy(changes, value => value == null));
}
exports.renameCounterpartyToIssuerInOrder = renameCounterpartyToIssuerInOrder;
function signum(num) {
    return num === 0 ? 0 : num > 0 ? 1 : -1;
}
function compareTransactions(first, second) {
    if (!first.outcome || !second.outcome) {
        return 0;
    }
    if (first.outcome.ledgerVersion === second.outcome.ledgerVersion) {
        return signum(first.outcome.indexInLedger - second.outcome.indexInLedger);
    }
    return first.outcome.ledgerVersion < second.outcome.ledgerVersion ? -1 : 1;
}
exports.compareTransactions = compareTransactions;
function hasCompleteLedgerRange(connection, minLedgerVersion, maxLedgerVersion) {
    const firstLedgerVersion = 32570;
    return connection.hasLedgerVersions(minLedgerVersion || firstLedgerVersion, maxLedgerVersion);
}
exports.hasCompleteLedgerRange = hasCompleteLedgerRange;
function isPendingLedgerVersion(connection, maxLedgerVersion) {
    return connection
        .getLedgerVersion()
        .then((ledgerVersion) => ledgerVersion < (maxLedgerVersion || 0));
}
exports.isPendingLedgerVersion = isPendingLedgerVersion;
function ensureLedgerVersion(options) {
    if (Boolean(options) &&
        options.ledgerVersion != null &&
        options.ledgerVersion !== null) {
        return Promise.resolve(options);
    }
    return this.getLedgerVersion().then((ledgerVersion) => Object.assign({}, options, { ledgerVersion }));
}
exports.ensureLedgerVersion = ensureLedgerVersion;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\ledger\\utils.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\derive.js", {"ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js","ripple-keypairs":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Coffline%5Cderive.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = void 0;
const ripple_keypairs_1 = require("ripple-keypairs");
Object.defineProperty(exports, "deriveKeypair", { enumerable: true, get: function () { return ripple_keypairs_1.deriveKeypair; } });
Object.defineProperty(exports, "deriveAddress", { enumerable: true, get: function () { return ripple_keypairs_1.deriveAddress; } });
const ripple_address_codec_1 = require("ripple-address-codec");
function deriveXAddress(options) {
    const classicAddress = ripple_keypairs_1.deriveAddress(options.publicKey);
    return ripple_address_codec_1.classicAddressToXAddress(classicAddress, options.tag, options.test);
}
exports.deriveXAddress = deriveXAddress;
//# sourceMappingURL=derive.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\offline\\derive.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\generate-address.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js","ripple-keypairs":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Coffline%5Cgenerate-address.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAddressAPI = void 0;
const ripple_address_codec_1 = require("ripple-address-codec");
const ripple_keypairs_1 = __importDefault(require("ripple-keypairs"));
const common_1 = require("../common");
function generateAddressAPI(options = {}) {
    common_1.validate.generateAddress({ options });
    try {
        const generateSeedOptions = {
            algorithm: options.algorithm
        };
        if (options.entropy) {
            generateSeedOptions.entropy = Uint8Array.from(options.entropy);
        }
        const secret = ripple_keypairs_1.default.generateSeed(generateSeedOptions);
        const keypair = ripple_keypairs_1.default.deriveKeypair(secret);
        const classicAddress = ripple_keypairs_1.default.deriveAddress(keypair.publicKey);
        const returnValue = {
            xAddress: ripple_address_codec_1.classicAddressToXAddress(classicAddress, false, options && options.test),
            secret
        };
        if (options.includeClassicAddress) {
            returnValue.classicAddress = classicAddress;
            returnValue.address = classicAddress;
        }
        return returnValue;
    }
    catch (error) {
        throw new common_1.errors.UnexpectedError(error.message);
    }
}
exports.generateAddressAPI = generateAddressAPI;
//# sourceMappingURL=generate-address.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\offline\\generate-address.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\ledgerhash.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","../common/hashes":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Coffline%5Cledgerhash.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const hashes_1 = require("../common/hashes");
const common = __importStar(require("../common"));
function convertLedgerHeader(header) {
    return {
        account_hash: header.stateHash,
        close_time: common.iso8601ToRippleTime(header.closeTime),
        close_time_resolution: header.closeTimeResolution,
        close_flags: header.closeFlags,
        hash: header.ledgerHash,
        ledger_hash: header.ledgerHash,
        ledger_index: header.ledgerVersion.toString(),
        parent_hash: header.parentLedgerHash,
        parent_close_time: common.iso8601ToRippleTime(header.parentCloseTime),
        total_coins: header.totalDrops,
        transaction_hash: header.transactionHash
    };
}
function hashLedgerHeader(ledgerHeader) {
    const header = convertLedgerHeader(ledgerHeader);
    return hashes_1.computeLedgerHash(header);
}
function computeTransactionHash(ledger, options) {
    let transactions;
    if (ledger.rawTransactions) {
        transactions = JSON.parse(ledger.rawTransactions);
    }
    else if (ledger.transactions) {
        try {
            transactions = ledger.transactions.map((tx) => JSON.parse(tx.rawTransaction));
        }
        catch (e) {
            if (e.toString() ===
                'SyntaxError: Unexpected' + ' token u in JSON at position 0') {
                throw new common.errors.ValidationError('ledger' + ' is missing raw transactions');
            }
        }
    }
    else {
        if (options.computeTreeHashes) {
            throw new common.errors.ValidationError('transactions' + ' property is missing from the ledger');
        }
        return ledger.transactionHash;
    }
    const txs = transactions.map((tx) => {
        const mergeTx = Object.assign({}, _.omit(tx, 'tx'), tx.tx || {});
        const renameMeta = Object.assign({}, _.omit(mergeTx, 'meta'), tx.meta ? { metaData: tx.meta } : {});
        return renameMeta;
    });
    const transactionHash = hashes_1.computeTransactionTreeHash(txs);
    if (ledger.transactionHash != null &&
        ledger.transactionHash !== transactionHash) {
        throw new common.errors.ValidationError('transactionHash in header' +
            ' does not match computed hash of transactions', {
            transactionHashInHeader: ledger.transactionHash,
            computedHashOfTransactions: transactionHash
        });
    }
    return transactionHash;
}
function computeStateHash(ledger, options) {
    if (ledger.rawState == null) {
        if (options.computeTreeHashes) {
            throw new common.errors.ValidationError('rawState' + ' property is missing from the ledger');
        }
        return ledger.stateHash;
    }
    const state = JSON.parse(ledger.rawState);
    const stateHash = hashes_1.computeStateTreeHash(state);
    if (ledger.stateHash != null && ledger.stateHash !== stateHash) {
        throw new common.errors.ValidationError('stateHash in header' + ' does not match computed hash of state');
    }
    return stateHash;
}
function computeLedgerHeaderHash(ledger, options = {}) {
    const subhashes = {
        transactionHash: computeTransactionHash(ledger, options),
        stateHash: computeStateHash(ledger, options)
    };
    return hashLedgerHeader(Object.assign({}, ledger, subhashes));
}
exports.default = computeLedgerHeaderHash;
//# sourceMappingURL=ledgerhash.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\offline\\ledgerhash.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\sign-payment-channel-claim.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","ripple-binary-codec":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\index.js","ripple-keypairs":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Coffline%5Csign-payment-channel-claim.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const common = __importStar(require("../common"));
const ripple_keypairs_1 = __importDefault(require("ripple-keypairs"));
const ripple_binary_codec_1 = __importDefault(require("ripple-binary-codec"));
const { validate, xrpToDrops } = common;
function signPaymentChannelClaim(channel, amount, privateKey) {
    validate.signPaymentChannelClaim({ channel, amount, privateKey });
    const signingData = ripple_binary_codec_1.default.encodeForSigningClaim({
        channel: channel,
        amount: xrpToDrops(amount)
    });
    return ripple_keypairs_1.default.sign(signingData, privateKey);
}
exports.default = signPaymentChannelClaim;
//# sourceMappingURL=sign-payment-channel-claim.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\offline\\sign-payment-channel-claim.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\utils.js", {"../common/hashes":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\index.js","../common/utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\utils.js","../offline/generate-address":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\generate-address.js","./derive":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\derive.js","./ledgerhash":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\ledgerhash.js","./sign-payment-channel-claim":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\sign-payment-channel-claim.js","./verify-payment-channel-claim":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\verify-payment-channel-claim.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Coffline%5Cutils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyPaymentChannelClaim = exports.signPaymentChannelClaim = exports.deriveXAddress = exports.deriveAddress = exports.deriveKeypair = exports.generateXAddress = exports.generateAddress = exports.computePaymentChannelHash = exports.computeEscrowHash = exports.computeLedgerHash = exports.computeStateTreeHash = exports.computeTransactionTreeHash = exports.computeTrustlineHash = exports.computeOrderID = exports.computeSignerListLedgerObjectID = exports.computeAccountLedgerObjectID = exports.computeBinaryTransactionSigningHash = exports.computeTransactionHash = exports.computeBinaryTransactionHash = exports.isValidSecret = exports.iso8601ToRippleTime = exports.rippleTimeToISO8601 = exports.removeUndefined = exports.convertKeysFromSnakeCaseToCamelCase = exports.toRippledAmount = exports.xrpToDrops = exports.dropsToXrp = exports.computeLedgerHeaderHash = void 0;
const derive_1 = require("./derive");
Object.defineProperty(exports, "deriveKeypair", { enumerable: true, get: function () { return derive_1.deriveKeypair; } });
Object.defineProperty(exports, "deriveAddress", { enumerable: true, get: function () { return derive_1.deriveAddress; } });
Object.defineProperty(exports, "deriveXAddress", { enumerable: true, get: function () { return derive_1.deriveXAddress; } });
const ledgerhash_1 = __importDefault(require("./ledgerhash"));
exports.computeLedgerHeaderHash = ledgerhash_1.default;
const sign_payment_channel_claim_1 = __importDefault(require("./sign-payment-channel-claim"));
exports.signPaymentChannelClaim = sign_payment_channel_claim_1.default;
const verify_payment_channel_claim_1 = __importDefault(require("./verify-payment-channel-claim"));
exports.verifyPaymentChannelClaim = verify_payment_channel_claim_1.default;
const utils_1 = require("../common/utils");
Object.defineProperty(exports, "dropsToXrp", { enumerable: true, get: function () { return utils_1.dropsToXrp; } });
Object.defineProperty(exports, "xrpToDrops", { enumerable: true, get: function () { return utils_1.xrpToDrops; } });
Object.defineProperty(exports, "toRippledAmount", { enumerable: true, get: function () { return utils_1.toRippledAmount; } });
Object.defineProperty(exports, "convertKeysFromSnakeCaseToCamelCase", { enumerable: true, get: function () { return utils_1.convertKeysFromSnakeCaseToCamelCase; } });
Object.defineProperty(exports, "removeUndefined", { enumerable: true, get: function () { return utils_1.removeUndefined; } });
Object.defineProperty(exports, "rippleTimeToISO8601", { enumerable: true, get: function () { return utils_1.rippleTimeToISO8601; } });
Object.defineProperty(exports, "iso8601ToRippleTime", { enumerable: true, get: function () { return utils_1.iso8601ToRippleTime; } });
Object.defineProperty(exports, "isValidSecret", { enumerable: true, get: function () { return utils_1.isValidSecret; } });
const hashes_1 = require("../common/hashes");
Object.defineProperty(exports, "computeBinaryTransactionHash", { enumerable: true, get: function () { return hashes_1.computeBinaryTransactionHash; } });
Object.defineProperty(exports, "computeTransactionHash", { enumerable: true, get: function () { return hashes_1.computeTransactionHash; } });
Object.defineProperty(exports, "computeBinaryTransactionSigningHash", { enumerable: true, get: function () { return hashes_1.computeBinaryTransactionSigningHash; } });
Object.defineProperty(exports, "computeAccountLedgerObjectID", { enumerable: true, get: function () { return hashes_1.computeAccountLedgerObjectID; } });
Object.defineProperty(exports, "computeSignerListLedgerObjectID", { enumerable: true, get: function () { return hashes_1.computeSignerListLedgerObjectID; } });
Object.defineProperty(exports, "computeOrderID", { enumerable: true, get: function () { return hashes_1.computeOrderID; } });
Object.defineProperty(exports, "computeTrustlineHash", { enumerable: true, get: function () { return hashes_1.computeTrustlineHash; } });
Object.defineProperty(exports, "computeTransactionTreeHash", { enumerable: true, get: function () { return hashes_1.computeTransactionTreeHash; } });
Object.defineProperty(exports, "computeStateTreeHash", { enumerable: true, get: function () { return hashes_1.computeStateTreeHash; } });
Object.defineProperty(exports, "computeLedgerHash", { enumerable: true, get: function () { return hashes_1.computeLedgerHash; } });
Object.defineProperty(exports, "computeEscrowHash", { enumerable: true, get: function () { return hashes_1.computeEscrowHash; } });
Object.defineProperty(exports, "computePaymentChannelHash", { enumerable: true, get: function () { return hashes_1.computePaymentChannelHash; } });
const generate_address_1 = require("../offline/generate-address");
Object.defineProperty(exports, "generateXAddress", { enumerable: true, get: function () { return generate_address_1.generateAddressAPI; } });
const generateAddress = (options = {}) => (generate_address_1.generateAddressAPI(Object.assign(Object.assign({}, options), { includeClassicAddress: true })));
exports.generateAddress = generateAddress;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\offline\\utils.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\offline\\verify-payment-channel-claim.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","ripple-binary-codec":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\index.js","ripple-keypairs":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Coffline%5Cverify-payment-channel-claim.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ripple_keypairs_1 = __importDefault(require("ripple-keypairs"));
const ripple_binary_codec_1 = __importDefault(require("ripple-binary-codec"));
const common_1 = require("../common");
function verifyPaymentChannelClaim(channel, amount, signature, publicKey) {
    common_1.validate.verifyPaymentChannelClaim({ channel, amount, signature, publicKey });
    const signingData = ripple_binary_codec_1.default.encodeForSigningClaim({
        channel: channel,
        amount: common_1.xrpToDrops(amount)
    });
    return ripple_keypairs_1.default.verify(signingData, signature, publicKey);
}
exports.default = verifyPaymentChannelClaim;
//# sourceMappingURL=verify-payment-channel-claim.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\offline\\verify-payment-channel-claim.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\server\\server.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cserver%5Cserver.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatLedgerClose = exports.getLedgerVersion = exports.isConnected = exports.disconnect = exports.connect = void 0;
const common = __importStar(require("../common"));
function isConnected() {
    return this.connection.isConnected();
}
exports.isConnected = isConnected;
function getLedgerVersion() {
    return this.connection.getLedgerVersion();
}
exports.getLedgerVersion = getLedgerVersion;
function connect() {
    return __awaiter(this, void 0, void 0, function* () {
        return this.connection.connect();
    });
}
exports.connect = connect;
function disconnect() {
    return __awaiter(this, void 0, void 0, function* () {
        yield this.connection.disconnect();
    });
}
exports.disconnect = disconnect;
function formatLedgerClose(ledgerClose) {
    return {
        baseFeeXRP: common.dropsToXrp(ledgerClose.fee_base),
        ledgerHash: ledgerClose.ledger_hash,
        ledgerVersion: ledgerClose.ledger_index,
        ledgerTimestamp: common.rippleTimeToISO8601(ledgerClose.ledger_time),
        reserveBaseXRP: common.dropsToXrp(ledgerClose.reserve_base),
        reserveIncrementXRP: common.dropsToXrp(ledgerClose.reserve_inc),
        transactionCount: ledgerClose.txn_count,
        validatedLedgerVersions: ledgerClose.validated_ledgers
    };
}
exports.formatLedgerClose = formatLedgerClose;
//# sourceMappingURL=server.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\server\\server.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\check-cancel.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Ccheck-cancel.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const common_1 = require("../common");
function createCheckCancelTransaction(account, cancel) {
    const txJSON = {
        Account: account,
        TransactionType: 'CheckCancel',
        CheckID: cancel.checkID
    };
    return txJSON;
}
function prepareCheckCancel(address, checkCancel, instructions = {}) {
    try {
        common_1.validate.prepareCheckCancel({ address, checkCancel, instructions });
        const txJSON = createCheckCancelTransaction(address, checkCancel);
        return utils_1.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = prepareCheckCancel;
//# sourceMappingURL=check-cancel.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\check-cancel.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\check-cash.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Ccheck-cash.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const ValidationError = utils.common.errors.ValidationError;
const toRippledAmount = utils.common.toRippledAmount;
const common_1 = require("../common");
function createCheckCashTransaction(account, checkCash) {
    if (checkCash.amount && checkCash.deliverMin) {
        throw new ValidationError('"amount" and "deliverMin" properties on ' +
            'CheckCash are mutually exclusive');
    }
    const txJSON = {
        Account: account,
        TransactionType: 'CheckCash',
        CheckID: checkCash.checkID
    };
    if (checkCash.amount != null) {
        txJSON.Amount = toRippledAmount(checkCash.amount);
    }
    if (checkCash.deliverMin != null) {
        txJSON.DeliverMin = toRippledAmount(checkCash.deliverMin);
    }
    return txJSON;
}
function prepareCheckCash(address, checkCash, instructions = {}) {
    try {
        common_1.validate.prepareCheckCash({ address, checkCash, instructions });
        const txJSON = createCheckCashTransaction(address, checkCash);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = prepareCheckCash;
//# sourceMappingURL=check-cash.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\check-cash.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\check-create.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Ccheck-create.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const toRippledAmount = utils.common.toRippledAmount;
const common_1 = require("../common");
function createCheckCreateTransaction(account, check) {
    const txJSON = {
        Account: account,
        TransactionType: 'CheckCreate',
        Destination: check.destination,
        SendMax: toRippledAmount(check.sendMax)
    };
    if (check.destinationTag != null) {
        txJSON.DestinationTag = check.destinationTag;
    }
    if (check.expiration != null) {
        txJSON.Expiration = common_1.iso8601ToRippleTime(check.expiration);
    }
    if (check.invoiceID != null) {
        txJSON.InvoiceID = check.invoiceID;
    }
    return txJSON;
}
function prepareCheckCreate(address, checkCreate, instructions = {}) {
    try {
        common_1.validate.prepareCheckCreate({ address, checkCreate, instructions });
        const txJSON = createCheckCreateTransaction(address, checkCreate);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = prepareCheckCreate;
//# sourceMappingURL=check-create.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\check-create.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\combine.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","../common/errors":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\errors.js","../common/hashes":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\index.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js","ripple-binary-codec":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Ccombine.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const ripple_binary_codec_1 = __importDefault(require("ripple-binary-codec"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const errors_1 = require("../common/errors");
const ripple_address_codec_1 = require("ripple-address-codec");
const common_1 = require("../common");
const hashes_1 = require("../common/hashes");
function validateTransactionEquivalence(transactions) {
    const exampleTransaction = JSON.stringify(Object.assign(Object.assign({}, transactions[0]), { Signers: null }));
    if (transactions.slice(1).some(tx => JSON.stringify(Object.assign(Object.assign({}, tx), { Signers: null })) !== exampleTransaction)) {
        throw new errors_1.ValidationError('txJSON is not the same for all signedTransactions');
    }
}
function addressToBigNumber(address) {
    const hex = Buffer.from(ripple_address_codec_1.decodeAccountID(address)).toString('hex');
    return new bignumber_js_1.default(hex, 16);
}
function compareSigners(a, b) {
    return addressToBigNumber(a.Signer.Account).comparedTo(addressToBigNumber(b.Signer.Account));
}
function getTransactionWithAllSigners(transactions) {
    const sortedSigners = _.flatMap(transactions, tx => tx.Signers)
        .filter(signer => signer)
        .sort(compareSigners);
    return Object.assign(Object.assign({}, transactions[0]), { Signers: sortedSigners });
}
function combine(signedTransactions) {
    common_1.validate.combine({ signedTransactions });
    const transactions = signedTransactions.map(ripple_binary_codec_1.default.decode);
    validateTransactionEquivalence(transactions);
    const signedTransaction = ripple_binary_codec_1.default.encode(getTransactionWithAllSigners(transactions));
    return {
        signedTransaction: signedTransaction,
        id: hashes_1.computeBinaryTransactionHash(signedTransaction)
    };
}
exports.default = combine;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\combine.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\escrow-cancellation.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Cescrow-cancellation.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const validate = utils.common.validate;
function createEscrowCancellationTransaction(account, payment) {
    const txJSON = {
        TransactionType: 'EscrowCancel',
        Account: account,
        Owner: payment.owner,
        OfferSequence: payment.escrowSequence
    };
    if (payment.memos != null) {
        txJSON.Memos = payment.memos.map(utils.convertMemo);
    }
    return txJSON;
}
function prepareEscrowCancellation(address, escrowCancellation, instructions = {}) {
    validate.prepareEscrowCancellation({
        address,
        escrowCancellation,
        instructions
    });
    const txJSON = createEscrowCancellationTransaction(address, escrowCancellation);
    return utils.prepareTransaction(txJSON, this, instructions);
}
exports.default = prepareEscrowCancellation;
//# sourceMappingURL=escrow-cancellation.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\escrow-cancellation.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\escrow-creation.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Cescrow-creation.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const common_1 = require("../common");
const ValidationError = utils.common.errors.ValidationError;
function createEscrowCreationTransaction(account, payment) {
    const txJSON = {
        TransactionType: 'EscrowCreate',
        Account: account,
        Destination: payment.destination,
        Amount: common_1.xrpToDrops(payment.amount)
    };
    if (payment.condition != null) {
        txJSON.Condition = payment.condition;
    }
    if (payment.allowCancelAfter != null) {
        txJSON.CancelAfter = common_1.iso8601ToRippleTime(payment.allowCancelAfter);
    }
    if (payment.allowExecuteAfter != null) {
        txJSON.FinishAfter = common_1.iso8601ToRippleTime(payment.allowExecuteAfter);
    }
    if (payment.sourceTag != null) {
        txJSON.SourceTag = payment.sourceTag;
    }
    if (payment.destinationTag != null) {
        txJSON.DestinationTag = payment.destinationTag;
    }
    if (payment.memos != null) {
        txJSON.Memos = payment.memos.map(utils.convertMemo);
    }
    if (Boolean(payment.allowCancelAfter) &&
        Boolean(payment.allowExecuteAfter) &&
        txJSON.CancelAfter <= txJSON.FinishAfter) {
        throw new ValidationError('prepareEscrowCreation: ' +
            '"allowCancelAfter" must be after "allowExecuteAfter"');
    }
    return txJSON;
}
function prepareEscrowCreation(address, escrowCreation, instructions = {}) {
    try {
        common_1.validate.prepareEscrowCreation({ address, escrowCreation, instructions });
        const txJSON = createEscrowCreationTransaction(address, escrowCreation);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = prepareEscrowCreation;
//# sourceMappingURL=escrow-creation.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\escrow-creation.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\escrow-execution.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Cescrow-execution.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const validate = utils.common.validate;
const ValidationError = utils.common.errors.ValidationError;
function createEscrowExecutionTransaction(account, payment) {
    const txJSON = {
        TransactionType: 'EscrowFinish',
        Account: account,
        Owner: payment.owner,
        OfferSequence: payment.escrowSequence
    };
    if (Boolean(payment.condition) !== Boolean(payment.fulfillment)) {
        throw new ValidationError('"condition" and "fulfillment" fields on' +
            ' EscrowFinish must only be specified together.');
    }
    if (payment.condition != null) {
        txJSON.Condition = payment.condition;
    }
    if (payment.fulfillment != null) {
        txJSON.Fulfillment = payment.fulfillment;
    }
    if (payment.memos != null) {
        txJSON.Memos = payment.memos.map(utils.convertMemo);
    }
    return txJSON;
}
function prepareEscrowExecution(address, escrowExecution, instructions = {}) {
    try {
        validate.prepareEscrowExecution({ address, escrowExecution, instructions });
        const txJSON = createEscrowExecutionTransaction(address, escrowExecution);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = prepareEscrowExecution;
//# sourceMappingURL=escrow-execution.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\escrow-execution.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\order.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Corder.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const offerFlags = utils.common.txFlags.OfferCreate;
const common_1 = require("../common");
function createOrderTransaction(account, order) {
    const takerPays = common_1.toRippledAmount(order.direction === 'buy' ? order.quantity : order.totalPrice);
    const takerGets = common_1.toRippledAmount(order.direction === 'buy' ? order.totalPrice : order.quantity);
    const txJSON = {
        TransactionType: 'OfferCreate',
        Account: account,
        TakerGets: takerGets,
        TakerPays: takerPays,
        Flags: 0
    };
    if (order.direction === 'sell') {
        txJSON.Flags |= offerFlags.Sell;
    }
    if (order.passive === true) {
        txJSON.Flags |= offerFlags.Passive;
    }
    if (order.immediateOrCancel === true) {
        txJSON.Flags |= offerFlags.ImmediateOrCancel;
    }
    if (order.fillOrKill === true) {
        txJSON.Flags |= offerFlags.FillOrKill;
    }
    if (order.expirationTime != null) {
        txJSON.Expiration = common_1.iso8601ToRippleTime(order.expirationTime);
    }
    if (order.orderToReplace != null) {
        txJSON.OfferSequence = order.orderToReplace;
    }
    if (order.memos != null) {
        txJSON.Memos = order.memos.map(utils.convertMemo);
    }
    return txJSON;
}
function prepareOrder(address, order, instructions = {}) {
    try {
        common_1.validate.prepareOrder({ address, order, instructions });
        const txJSON = createOrderTransaction(address, order);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = prepareOrder;
//# sourceMappingURL=order.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\order.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\ordercancellation.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Cordercancellation.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const validate = utils.common.validate;
function createOrderCancellationTransaction(account, orderCancellation) {
    const txJSON = {
        TransactionType: 'OfferCancel',
        Account: account,
        OfferSequence: orderCancellation.orderSequence
    };
    if (orderCancellation.memos != null) {
        txJSON.Memos = orderCancellation.memos.map(utils.convertMemo);
    }
    return txJSON;
}
function prepareOrderCancellation(address, orderCancellation, instructions = {}) {
    try {
        validate.prepareOrderCancellation({
            address,
            orderCancellation,
            instructions
        });
        const txJSON = createOrderCancellationTransaction(address, orderCancellation);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = prepareOrderCancellation;
//# sourceMappingURL=ordercancellation.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\ordercancellation.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\payment-channel-claim.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Cpayment-channel-claim.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const ValidationError = utils.common.errors.ValidationError;
const claimFlags = utils.common.txFlags.PaymentChannelClaim;
const common_1 = require("../common");
function createPaymentChannelClaimTransaction(account, claim) {
    const txJSON = {
        Account: account,
        TransactionType: 'PaymentChannelClaim',
        Channel: claim.channel,
        Flags: 0
    };
    if (claim.balance != null) {
        txJSON.Balance = common_1.xrpToDrops(claim.balance);
    }
    if (claim.amount != null) {
        txJSON.Amount = common_1.xrpToDrops(claim.amount);
    }
    if (Boolean(claim.signature) !== Boolean(claim.publicKey)) {
        throw new ValidationError('"signature" and "publicKey" fields on' +
            ' PaymentChannelClaim must only be specified together.');
    }
    if (claim.signature != null) {
        txJSON.Signature = claim.signature;
    }
    if (claim.publicKey != null) {
        txJSON.PublicKey = claim.publicKey;
    }
    if (claim.renew === true && claim.close === true) {
        throw new ValidationError('"renew" and "close" flags on PaymentChannelClaim' +
            ' are mutually exclusive');
    }
    if (claim.renew === true) {
        txJSON.Flags |= claimFlags.Renew;
    }
    if (claim.close === true) {
        txJSON.Flags |= claimFlags.Close;
    }
    return txJSON;
}
function preparePaymentChannelClaim(address, paymentChannelClaim, instructions = {}) {
    try {
        common_1.validate.preparePaymentChannelClaim({
            address,
            paymentChannelClaim,
            instructions
        });
        const txJSON = createPaymentChannelClaimTransaction(address, paymentChannelClaim);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = preparePaymentChannelClaim;
//# sourceMappingURL=payment-channel-claim.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\payment-channel-claim.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\payment-channel-create.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Cpayment-channel-create.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const common_1 = require("../common");
function createPaymentChannelCreateTransaction(account, paymentChannel) {
    const txJSON = {
        Account: account,
        TransactionType: 'PaymentChannelCreate',
        Amount: common_1.xrpToDrops(paymentChannel.amount),
        Destination: paymentChannel.destination,
        SettleDelay: paymentChannel.settleDelay,
        PublicKey: paymentChannel.publicKey.toUpperCase()
    };
    if (paymentChannel.cancelAfter != null) {
        txJSON.CancelAfter = common_1.iso8601ToRippleTime(paymentChannel.cancelAfter);
    }
    if (paymentChannel.sourceTag != null) {
        txJSON.SourceTag = paymentChannel.sourceTag;
    }
    if (paymentChannel.destinationTag != null) {
        txJSON.DestinationTag = paymentChannel.destinationTag;
    }
    return txJSON;
}
function preparePaymentChannelCreate(address, paymentChannelCreate, instructions = {}) {
    try {
        common_1.validate.preparePaymentChannelCreate({
            address,
            paymentChannelCreate,
            instructions
        });
        const txJSON = createPaymentChannelCreateTransaction(address, paymentChannelCreate);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = preparePaymentChannelCreate;
//# sourceMappingURL=payment-channel-create.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\payment-channel-create.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\payment-channel-fund.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Cpayment-channel-fund.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const common_1 = require("../common");
function createPaymentChannelFundTransaction(account, fund) {
    const txJSON = {
        Account: account,
        TransactionType: 'PaymentChannelFund',
        Channel: fund.channel,
        Amount: common_1.xrpToDrops(fund.amount)
    };
    if (fund.expiration != null) {
        txJSON.Expiration = common_1.iso8601ToRippleTime(fund.expiration);
    }
    return txJSON;
}
function preparePaymentChannelFund(address, paymentChannelFund, instructions = {}) {
    try {
        common_1.validate.preparePaymentChannelFund({
            address,
            paymentChannelFund,
            instructions
        });
        const txJSON = createPaymentChannelFundTransaction(address, paymentChannelFund);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = preparePaymentChannelFund;
//# sourceMappingURL=payment-channel-fund.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\payment-channel-fund.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\payment.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Cpayment.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const _ = __importStar(require("lodash"));
const utils = __importStar(require("./utils"));
const validate = utils.common.validate;
const paymentFlags = utils.common.txFlags.Payment;
const ValidationError = utils.common.errors.ValidationError;
const common_1 = require("../common");
const utils_1 = require("./utils");
function isMaxAdjustment(source) {
    return source.maxAmount != null;
}
function isMinAdjustment(destination) {
    return destination.minAmount != null;
}
function isXRPToXRPPayment(payment) {
    const { source, destination } = payment;
    const sourceCurrency = isMaxAdjustment(source)
        ? source.maxAmount.currency
        : source.amount.currency;
    const destinationCurrency = isMinAdjustment(destination)
        ? destination.minAmount.currency
        : destination.amount.currency;
    return ((sourceCurrency === 'XRP' || sourceCurrency === 'drops') &&
        (destinationCurrency === 'XRP' || destinationCurrency === 'drops'));
}
function isIOUWithoutCounterparty(amount) {
    return (amount &&
        amount.currency !== 'XRP' &&
        amount.currency !== 'drops' &&
        amount.counterparty == null);
}
function applyAnyCounterpartyEncoding(payment) {
    [payment.source, payment.destination].forEach((adjustment) => {
        ['amount', 'minAmount', 'maxAmount'].forEach((key) => {
            if (isIOUWithoutCounterparty(adjustment[key])) {
                adjustment[key].counterparty = adjustment.address;
            }
        });
    });
}
function createMaximalAmount(amount) {
    const maxXRPValue = '100000000000';
    const maxIOUValue = '999999999999999900000000000000000000000000000000000000000000000000000000000000000000000000000000';
    let maxValue;
    if (amount.currency === 'XRP') {
        maxValue = maxXRPValue;
    }
    else if (amount.currency === 'drops') {
        maxValue = common_1.xrpToDrops(maxXRPValue);
    }
    else {
        maxValue = maxIOUValue;
    }
    return Object.assign({}, amount, { value: maxValue });
}
function validateAndNormalizeAddress(address, expectedTag) {
    const classicAddress = utils_1.getClassicAccountAndTag(address, expectedTag);
    classicAddress.tag =
        classicAddress.tag === false ? undefined : classicAddress.tag;
    return classicAddress;
}
function createPaymentTransaction(address, paymentArgument) {
    const payment = _.cloneDeep(paymentArgument);
    applyAnyCounterpartyEncoding(payment);
    const sourceAddressAndTag = validateAndNormalizeAddress(payment.source.address, payment.source.tag);
    const addressToVerifyAgainst = validateAndNormalizeAddress(address, undefined);
    if (addressToVerifyAgainst.classicAccount !== sourceAddressAndTag.classicAccount) {
        throw new ValidationError('address must match payment.source.address');
    }
    if (addressToVerifyAgainst.tag != null &&
        sourceAddressAndTag.tag != null &&
        addressToVerifyAgainst.tag !== sourceAddressAndTag.tag) {
        throw new ValidationError('address includes a tag that does not match payment.source.tag');
    }
    const destinationAddressAndTag = validateAndNormalizeAddress(payment.destination.address, payment.destination.tag);
    if ((isMaxAdjustment(payment.source) && isMinAdjustment(payment.destination)) ||
        (!isMaxAdjustment(payment.source) && !isMinAdjustment(payment.destination))) {
        throw new ValidationError('payment must specify either (source.maxAmount ' +
            'and destination.amount) or (source.amount and destination.minAmount)');
    }
    const destinationAmount = isMinAdjustment(payment.destination)
        ? payment.destination.minAmount
        : payment.destination.amount;
    const sourceAmount = isMaxAdjustment(payment.source)
        ? payment.source.maxAmount
        : payment.source.amount;
    const amount = isMinAdjustment(payment.destination) && !isXRPToXRPPayment(payment)
        ? createMaximalAmount(destinationAmount)
        : destinationAmount;
    const txJSON = {
        TransactionType: 'Payment',
        Account: sourceAddressAndTag.classicAccount,
        Destination: destinationAddressAndTag.classicAccount,
        Amount: common_1.toRippledAmount(amount),
        Flags: 0
    };
    if (payment.invoiceID != null) {
        txJSON.InvoiceID = payment.invoiceID;
    }
    if (sourceAddressAndTag.tag != null) {
        txJSON.SourceTag = sourceAddressAndTag.tag;
    }
    if (destinationAddressAndTag.tag != null) {
        txJSON.DestinationTag = destinationAddressAndTag.tag;
    }
    if (payment.memos != null) {
        txJSON.Memos = payment.memos.map(utils.convertMemo);
    }
    if (payment.noDirectRipple === true) {
        txJSON.Flags |= paymentFlags.NoRippleDirect;
    }
    if (payment.limitQuality === true) {
        txJSON.Flags |= paymentFlags.LimitQuality;
    }
    if (!isXRPToXRPPayment(payment)) {
        if (payment.allowPartialPayment || isMinAdjustment(payment.destination)) {
            txJSON.Flags |= paymentFlags.PartialPayment;
        }
        txJSON.SendMax = common_1.toRippledAmount(sourceAmount);
        if (isMinAdjustment(payment.destination)) {
            txJSON.DeliverMin = common_1.toRippledAmount(destinationAmount);
        }
        if (payment.paths != null) {
            txJSON.Paths = JSON.parse(payment.paths);
        }
    }
    else if (payment.allowPartialPayment === true) {
        throw new ValidationError('XRP to XRP payments cannot be partial payments');
    }
    return txJSON;
}
function preparePayment(address, payment, instructions = {}) {
    try {
        validate.preparePayment({ address, payment, instructions });
        const txJSON = createPaymentTransaction(address, payment);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = preparePayment;
//# sourceMappingURL=payment.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\payment.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\settings.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Csettings.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = __importStar(require("assert"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils = __importStar(require("./utils"));
const validate = utils.common.validate;
const AccountSetFlags = utils.common.constants.AccountSetFlags;
const AccountFields = utils.common.constants.AccountFields;
function setTransactionFlags(txJSON, values) {
    const keys = Object.keys(values).filter((key) => AccountSetFlags[key] != null);
    assert.ok(keys.length <= 1, 'ERROR: can only set one setting per transaction');
    const flagName = keys[0];
    const value = values[flagName];
    const index = AccountSetFlags[flagName];
    if (index != null) {
        if (value) {
            txJSON.SetFlag = index;
        }
        else {
            txJSON.ClearFlag = index;
        }
    }
}
function setTransactionFields(txJSON, input) {
    const fieldSchema = AccountFields;
    for (const fieldName in fieldSchema) {
        const field = fieldSchema[fieldName];
        let value = input[field.name];
        if (value === undefined) {
            continue;
        }
        if (value === null && field.hasOwnProperty('defaults')) {
            value = field.defaults;
        }
        if (field.encoding === 'hex' && !field.length) {
            value = Buffer.from(value, 'ascii').toString('hex').toUpperCase();
        }
        txJSON[fieldName] = value;
    }
}
function convertTransferRate(transferRate) {
    return new bignumber_js_1.default(transferRate).shiftedBy(9).toNumber();
}
function formatSignerEntry(signer) {
    return {
        SignerEntry: {
            Account: signer.address,
            SignerWeight: signer.weight
        }
    };
}
function createSettingsTransactionWithoutMemos(account, settings) {
    if (settings.regularKey !== undefined) {
        const removeRegularKey = {
            TransactionType: 'SetRegularKey',
            Account: account
        };
        if (settings.regularKey === null) {
            return removeRegularKey;
        }
        return Object.assign({}, removeRegularKey, {
            RegularKey: settings.regularKey
        });
    }
    if (settings.signers != null) {
        const setSignerList = {
            TransactionType: 'SignerListSet',
            Account: account,
            SignerEntries: [],
            SignerQuorum: settings.signers.threshold
        };
        if (settings.signers.weights != null) {
            setSignerList.SignerEntries = settings.signers.weights.map(formatSignerEntry);
        }
        return setSignerList;
    }
    const txJSON = {
        TransactionType: 'AccountSet',
        Account: account
    };
    const settingsWithoutMemos = Object.assign({}, settings);
    delete settingsWithoutMemos.memos;
    setTransactionFlags(txJSON, settingsWithoutMemos);
    setTransactionFields(txJSON, settings);
    if (txJSON.TransferRate != null) {
        txJSON.TransferRate = convertTransferRate(txJSON.TransferRate);
    }
    return txJSON;
}
function createSettingsTransaction(account, settings) {
    const txJSON = createSettingsTransactionWithoutMemos(account, settings);
    if (settings.memos != null) {
        txJSON.Memos = settings.memos.map(utils.convertMemo);
    }
    return txJSON;
}
function prepareSettings(address, settings, instructions = {}) {
    try {
        validate.prepareSettings({ address, settings, instructions });
        const txJSON = createSettingsTransaction(address, settings);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = prepareSettings;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\settings.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\sign.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","../common/hashes":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\hashes\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js","ripple-binary-codec":"F:\\metamask-extension\\node_modules\\ripple-binary-codec\\dist\\index.js","ripple-keypairs":"F:\\metamask-extension\\node_modules\\ripple-keypairs\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Csign.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const utils = __importStar(require("./utils"));
const ripple_keypairs_1 = __importDefault(require("ripple-keypairs"));
const ripple_binary_codec_1 = __importDefault(require("ripple-binary-codec"));
const hashes_1 = require("../common/hashes");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const common_1 = require("../common");
const validate = utils.common.validate;
function computeSignature(tx, privateKey, signAs) {
    const signingData = signAs
        ? ripple_binary_codec_1.default.encodeForMultisigning(tx, signAs)
        : ripple_binary_codec_1.default.encodeForSigning(tx);
    return ripple_keypairs_1.default.sign(signingData, privateKey);
}
function signWithKeypair(api, txJSON, keypair, options = {
    signAs: ''
}) {
    validate.sign({ txJSON, keypair });
    const tx = JSON.parse(txJSON);
    if (tx.TxnSignature || tx.Signers) {
        throw new utils.common.errors.ValidationError('txJSON must not contain "TxnSignature" or "Signers" properties');
    }
    checkFee(api, tx.Fee);
    const txToSignAndEncode = Object.assign({}, tx);
    txToSignAndEncode.SigningPubKey = options.signAs ? '' : keypair.publicKey;
    if (options.signAs) {
        const signer = {
            Account: options.signAs,
            SigningPubKey: keypair.publicKey,
            TxnSignature: computeSignature(txToSignAndEncode, keypair.privateKey, options.signAs)
        };
        txToSignAndEncode.Signers = [{ Signer: signer }];
    }
    else {
        txToSignAndEncode.TxnSignature = computeSignature(txToSignAndEncode, keypair.privateKey);
    }
    const serialized = ripple_binary_codec_1.default.encode(txToSignAndEncode);
    checkTxSerialization(serialized, tx);
    return {
        signedTransaction: serialized,
        id: hashes_1.computeBinaryTransactionHash(serialized)
    };
}
function objectDiff(a, b) {
    const diffs = {};
    const compare = function (i1, i2, k) {
        const type1 = Object.prototype.toString.call(i1);
        const type2 = Object.prototype.toString.call(i2);
        if (type2 === '[object Undefined]') {
            diffs[k] = null;
            return;
        }
        if (type1 !== type2) {
            diffs[k] = i2;
            return;
        }
        if (type1 === '[object Object]') {
            const objDiff = objectDiff(i1, i2);
            if (Object.keys(objDiff).length > 0) {
                diffs[k] = objDiff;
            }
            return;
        }
        if (type1 === '[object Array]') {
            if (!lodash_1.default.isEqual(i1, i2)) {
                diffs[k] = i2;
            }
            return;
        }
        if (type1 === '[object Function]') {
            if (i1.toString() !== i2.toString()) {
                diffs[k] = i2;
            }
            return;
        }
        if (i1 !== i2) {
            diffs[k] = i2;
        }
    };
    for (const key in a) {
        if (a.hasOwnProperty(key)) {
            compare(a[key], b[key], key);
        }
    }
    for (const key in b) {
        if (b.hasOwnProperty(key)) {
            if (!a[key] && a[key] !== b[key]) {
                diffs[key] = b[key];
            }
        }
    }
    return diffs;
}
function checkTxSerialization(serialized, tx) {
    var _a;
    const decoded = ripple_binary_codec_1.default.decode(serialized);
    if (!decoded.TxnSignature && !decoded.Signers) {
        throw new utils.common.errors.ValidationError('Serialized transaction must have a TxnSignature or Signers property');
    }
    delete decoded.TxnSignature;
    delete decoded.Signers;
    if (!tx.SigningPubKey) {
        delete decoded.SigningPubKey;
    }
    (_a = tx.Memos) === null || _a === void 0 ? void 0 : _a.map(memo => {
        var _a, _b, _c;
        if ((_a = memo === null || memo === void 0 ? void 0 : memo.Memo) === null || _a === void 0 ? void 0 : _a.MemoData) {
            memo.Memo.MemoData = memo.Memo.MemoData.toUpperCase();
        }
        if ((_b = memo === null || memo === void 0 ? void 0 : memo.Memo) === null || _b === void 0 ? void 0 : _b.MemoType) {
            memo.Memo.MemoType = memo.Memo.MemoType.toUpperCase();
        }
        if ((_c = memo === null || memo === void 0 ? void 0 : memo.Memo) === null || _c === void 0 ? void 0 : _c.MemoFormat) {
            memo.Memo.MemoFormat = memo.Memo.MemoFormat.toUpperCase();
        }
        return memo;
    });
    if (!lodash_1.default.isEqual(decoded, tx)) {
        const error = new utils.common.errors.ValidationError('Serialized transaction does not match original txJSON. See `error.data`');
        error.data = {
            decoded,
            tx,
            diff: objectDiff(tx, decoded)
        };
        throw error;
    }
}
function checkFee(api, txFee) {
    const fee = new bignumber_js_1.default(txFee);
    const maxFeeDrops = common_1.xrpToDrops(api._maxFeeXRP);
    if (fee.isGreaterThan(maxFeeDrops)) {
        throw new utils.common.errors.ValidationError(`"Fee" should not exceed "${maxFeeDrops}". ` +
            'To use a higher fee, set `maxFeeXRP` in the RippleAPI constructor.');
    }
}
function sign(txJSON, secret, options, keypair) {
    if (typeof secret === 'string') {
        validate.sign({ txJSON, secret });
        return signWithKeypair(this, txJSON, ripple_keypairs_1.default.deriveKeypair(secret), options);
    }
    else {
        if (!keypair && !secret) {
            throw new utils.common.errors.ValidationError('sign: Missing secret or keypair.');
        }
        return signWithKeypair(this, txJSON, keypair ? keypair : secret, options);
    }
}
exports.default = sign;
//# sourceMappingURL=sign.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\sign.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\submit.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Csubmit.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const common_1 = require("../common");
function isImmediateRejection(engineResult) {
    return engineResult.startsWith('tem');
}
function formatSubmitResponse(response) {
    const data = {
        resultCode: response.engine_result,
        resultMessage: response.engine_result_message,
        engine_result: response.engine_result,
        engine_result_code: response.engine_result_code,
        engine_result_message: response.engine_result_message,
        tx_blob: response.tx_blob,
        tx_json: response.tx_json
    };
    if (isImmediateRejection(response.engine_result)) {
        throw new utils.common.errors.RippledError('Submit failed', data);
    }
    return data;
}
function submit(signedTransaction, failHard) {
    return __awaiter(this, void 0, void 0, function* () {
        common_1.validate.submit({ signedTransaction });
        const response = yield this.request('submit', Object.assign({ tx_blob: signedTransaction }, (failHard ? { fail_hard: failHard } : {})));
        return formatSubmitResponse(response);
    });
}
exports.default = submit;
//# sourceMappingURL=submit.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\submit.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\ticket.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Cticket.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const validate = utils.common.validate;
const ValidationError = utils.common.errors.ValidationError;
function createTicketTransaction(account, ticketCount) {
    if (!ticketCount || ticketCount === 0)
        throw new ValidationError('Ticket count must be greater than 0.');
    const txJSON = {
        TransactionType: 'TicketCreate',
        Account: account,
        TicketCount: ticketCount
    };
    return txJSON;
}
function prepareTicketCreate(address, ticketCount, instructions = {}) {
    try {
        validate.prepareTicketCreate({ address, ticketCount, instructions });
        const txJSON = createTicketTransaction(address, ticketCount);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = prepareTicketCreate;
//# sourceMappingURL=ticket.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\ticket.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\trustline.js", {"./utils":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Ctrustline.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils = __importStar(require("./utils"));
const validate = utils.common.validate;
const trustlineFlags = utils.common.txFlags.TrustSet;
function convertQuality(quality) {
    return new bignumber_js_1.default(quality)
        .shiftedBy(9)
        .integerValue(bignumber_js_1.default.ROUND_DOWN)
        .toNumber();
}
function createTrustlineTransaction(account, trustline) {
    const limit = {
        currency: trustline.currency,
        issuer: trustline.counterparty,
        value: trustline.limit
    };
    const txJSON = {
        TransactionType: 'TrustSet',
        Account: account,
        LimitAmount: limit,
        Flags: 0
    };
    if (trustline.qualityIn != null) {
        txJSON.QualityIn = convertQuality(trustline.qualityIn);
    }
    if (trustline.qualityOut != null) {
        txJSON.QualityOut = convertQuality(trustline.qualityOut);
    }
    if (trustline.authorized === true) {
        txJSON.Flags |= trustlineFlags.SetAuth;
    }
    if (trustline.ripplingDisabled != null) {
        txJSON.Flags |= trustline.ripplingDisabled
            ? trustlineFlags.NoRipple
            : trustlineFlags.ClearNoRipple;
    }
    if (trustline.frozen != null) {
        txJSON.Flags |= trustline.frozen
            ? trustlineFlags.SetFreeze
            : trustlineFlags.ClearFreeze;
    }
    if (trustline.memos != null) {
        txJSON.Memos = trustline.memos.map(utils.convertMemo);
    }
    return txJSON;
}
function prepareTrustline(address, trustline, instructions = {}) {
    try {
        validate.prepareTrustline({ address, trustline, instructions });
        const txJSON = createTrustlineTransaction(address, trustline);
        return utils.prepareTransaction(txJSON, this, instructions);
    }
    catch (e) {
        return Promise.reject(e);
    }
}
exports.default = prepareTrustline;
//# sourceMappingURL=trustline.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\trustline.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\types.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Ctypes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=types.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\types.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","../common/errors":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\errors.js","bignumber.js":"F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ripple-address-codec":"F:\\metamask-extension\\node_modules\\ripple-address-codec\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Ctransaction%5Cutils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getClassicAccountAndTag = exports.setCanonicalFlag = exports.common = exports.prepareTransaction = exports.convertMemo = exports.convertStringToHex = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const common = __importStar(require("../common"));
exports.common = common;
const common_1 = require("../common");
const errors_1 = require("../common/errors");
const ripple_address_codec_1 = require("ripple-address-codec");
const txFlags = common.txFlags;
const TRANSACTION_TYPES_WITH_DESTINATION_TAG_FIELD = [
    'Payment',
    'CheckCreate',
    'EscrowCreate',
    'PaymentChannelCreate'
];
function formatPrepareResponse(txJSON) {
    const instructions = {
        fee: common.dropsToXrp(txJSON.Fee),
        maxLedgerVersion: txJSON.LastLedgerSequence == null ? null : txJSON.LastLedgerSequence
    };
    if (txJSON.TicketSequence != null) {
        instructions['ticketSequence'] = txJSON.TicketSequence;
    }
    else {
        instructions['sequence'] = txJSON.Sequence;
    }
    return {
        txJSON: JSON.stringify(txJSON),
        instructions
    };
}
function setCanonicalFlag(txJSON) {
    txJSON.Flags |= txFlags.Universal.FullyCanonicalSig;
    txJSON.Flags = txJSON.Flags >>> 0;
}
exports.setCanonicalFlag = setCanonicalFlag;
function scaleValue(value, multiplier, extra = 0) {
    return new bignumber_js_1.default(value).times(multiplier).plus(extra).toString();
}
function getClassicAccountAndTag(Account, expectedTag) {
    if (ripple_address_codec_1.isValidXAddress(Account)) {
        const classic = ripple_address_codec_1.xAddressToClassicAddress(Account);
        if (expectedTag != null && classic.tag !== expectedTag) {
            throw new errors_1.ValidationError('address includes a tag that does not match the tag specified in the transaction');
        }
        return {
            classicAccount: classic.classicAddress,
            tag: classic.tag
        };
    }
    else {
        return {
            classicAccount: Account,
            tag: expectedTag
        };
    }
}
exports.getClassicAccountAndTag = getClassicAccountAndTag;
function prepareTransaction(txJSON, api, instructions) {
    common.validate.instructions(instructions);
    common.validate.tx_json(txJSON);
    if (instructions.sequence != null && instructions.sequence === 0) {
        return Promise.reject(new errors_1.ValidationError('`sequence` cannot be 0'));
    }
    const disallowedFieldsInTxJSON = [
        'maxLedgerVersion',
        'maxLedgerVersionOffset',
        'fee',
        'sequence',
        'ticketSequence'
    ];
    const badFields = disallowedFieldsInTxJSON.filter((field) => txJSON[field]);
    if (badFields.length) {
        return Promise.reject(new errors_1.ValidationError('txJSON additionalProperty "' +
            badFields[0] +
            '" exists in instance when not allowed'));
    }
    const newTxJSON = Object.assign({}, txJSON);
    if (txJSON['SignerQuorum'] === 0) {
        delete newTxJSON.SignerEntries;
    }
    const { classicAccount, tag: sourceTag } = getClassicAccountAndTag(txJSON.Account);
    newTxJSON.Account = classicAccount;
    if (sourceTag != null) {
        if (txJSON.SourceTag && txJSON.SourceTag !== sourceTag) {
            return Promise.reject(new errors_1.ValidationError('The `SourceTag`, if present, must match the tag of the `Account` X-address'));
        }
        if (sourceTag) {
            newTxJSON.SourceTag = sourceTag;
        }
    }
    if (typeof txJSON.Destination === 'string') {
        const { classicAccount: destinationAccount, tag: destinationTag } = getClassicAccountAndTag(txJSON.Destination);
        newTxJSON.Destination = destinationAccount;
        if (destinationTag != null) {
            if (TRANSACTION_TYPES_WITH_DESTINATION_TAG_FIELD.includes(txJSON.TransactionType)) {
                if (txJSON.DestinationTag && txJSON.DestinationTag !== destinationTag) {
                    return Promise.reject(new errors_1.ValidationError('The Payment `DestinationTag`, if present, must match the tag of the `Destination` X-address'));
                }
                if (destinationTag) {
                    newTxJSON.DestinationTag = destinationTag;
                }
            }
        }
    }
    function convertToClassicAccountIfPresent(fieldName) {
        const account = txJSON[fieldName];
        if (typeof account === 'string') {
            const { classicAccount: ca } = getClassicAccountAndTag(account);
            newTxJSON[fieldName] = ca;
        }
    }
    function convertIssuedCurrencyToAccountIfPresent(fieldName) {
        const amount = txJSON[fieldName];
        if (typeof amount === 'number'
            || amount instanceof Array
            || amount == null)
            return;
        newTxJSON[fieldName] = common_1.toRippledAmount(amount);
    }
    convertToClassicAccountIfPresent('Authorize');
    convertToClassicAccountIfPresent('Unauthorize');
    convertToClassicAccountIfPresent('Owner');
    convertToClassicAccountIfPresent('RegularKey');
    convertIssuedCurrencyToAccountIfPresent('Amount');
    convertIssuedCurrencyToAccountIfPresent('SendMax');
    convertIssuedCurrencyToAccountIfPresent('DeliverMin');
    convertIssuedCurrencyToAccountIfPresent('TakerPays');
    convertIssuedCurrencyToAccountIfPresent('TakerGets');
    convertIssuedCurrencyToAccountIfPresent('LimitAmount');
    setCanonicalFlag(newTxJSON);
    function prepareMaxLedgerVersion() {
        if (newTxJSON.LastLedgerSequence && instructions.maxLedgerVersion) {
            return Promise.reject(new errors_1.ValidationError('`LastLedgerSequence` in txJSON and `maxLedgerVersion`' +
                ' in `instructions` cannot both be set'));
        }
        if (newTxJSON.LastLedgerSequence && instructions.maxLedgerVersionOffset) {
            return Promise.reject(new errors_1.ValidationError('`LastLedgerSequence` in txJSON and `maxLedgerVersionOffset`' +
                ' in `instructions` cannot both be set'));
        }
        if (newTxJSON.LastLedgerSequence) {
            return Promise.resolve();
        }
        if (instructions.maxLedgerVersion !== undefined) {
            if (instructions.maxLedgerVersion !== null) {
                newTxJSON.LastLedgerSequence = instructions.maxLedgerVersion;
            }
            return Promise.resolve();
        }
        const offset = instructions.maxLedgerVersionOffset != null
            ? instructions.maxLedgerVersionOffset
            : 3;
        return api.connection.getLedgerVersion().then((ledgerVersion) => {
            newTxJSON.LastLedgerSequence = ledgerVersion + offset;
            return;
        });
    }
    function prepareFee() {
        if (newTxJSON.Fee && instructions.fee) {
            return Promise.reject(new errors_1.ValidationError('`Fee` in txJSON and `fee` in `instructions` cannot both be set'));
        }
        if (newTxJSON.Fee) {
            return Promise.resolve();
        }
        const multiplier = instructions.signersCount == null
            ? 1
            : instructions.signersCount + 1;
        if (instructions.fee != null) {
            const fee = new bignumber_js_1.default(instructions.fee);
            if (fee.isGreaterThan(api._maxFeeXRP)) {
                return Promise.reject(new errors_1.ValidationError(`Fee of ${fee.toString(10)} XRP exceeds ` +
                    `max of ${api._maxFeeXRP} XRP. To use this fee, increase ` +
                    '`maxFeeXRP` in the RippleAPI constructor.'));
            }
            newTxJSON.Fee = scaleValue(common.xrpToDrops(instructions.fee), multiplier);
            return Promise.resolve();
        }
        const cushion = api._feeCushion;
        return api.getFee(cushion).then((fee) => {
            return api.connection.getFeeRef().then((feeRef) => {
                const extraFee = newTxJSON.TransactionType !== 'EscrowFinish' ||
                    newTxJSON.Fulfillment == null
                    ? 0
                    : cushion *
                        feeRef *
                        (32 +
                            Math.floor(Buffer.from(newTxJSON.Fulfillment, 'hex').length / 16));
                const feeDrops = common.xrpToDrops(fee);
                const maxFeeXRP = instructions.maxFee
                    ? bignumber_js_1.default.min(api._maxFeeXRP, instructions.maxFee)
                    : api._maxFeeXRP;
                const maxFeeDrops = common.xrpToDrops(maxFeeXRP);
                const normalFee = scaleValue(feeDrops, multiplier, extraFee);
                newTxJSON.Fee = bignumber_js_1.default.min(normalFee, maxFeeDrops).toString(10);
                return;
            });
        });
    }
    function prepareSequence() {
        return __awaiter(this, void 0, void 0, function* () {
            if (instructions.sequence != null) {
                if (newTxJSON.Sequence == null ||
                    instructions.sequence === newTxJSON.Sequence) {
                    newTxJSON.Sequence = instructions.sequence;
                    return Promise.resolve();
                }
                else {
                    return Promise.reject(new errors_1.ValidationError('`Sequence` in txJSON must match `sequence` in `instructions`'));
                }
            }
            if (newTxJSON.Sequence != null) {
                return Promise.resolve();
            }
            if (instructions.ticketSequence != null) {
                newTxJSON.Sequence = 0;
                newTxJSON.TicketSequence = instructions.ticketSequence;
                return Promise.resolve();
            }
            try {
                const response = yield api.request('account_info', {
                    account: classicAccount,
                    ledger_index: 'current'
                });
                newTxJSON.Sequence = response.account_data.Sequence;
                return Promise.resolve();
            }
            catch (e) {
                return Promise.reject(e);
            }
        });
    }
    return Promise.all([
        prepareMaxLedgerVersion(),
        prepareFee(),
        prepareSequence()
    ]).then(() => formatPrepareResponse(newTxJSON));
}
exports.prepareTransaction = prepareTransaction;
function convertStringToHex(string) {
    return Buffer.from(string, 'utf8').toString('hex').toUpperCase();
}
exports.convertStringToHex = convertStringToHex;
function convertMemo(memo) {
    return {
        Memo: common.removeUndefined({
            MemoData: memo.data ? convertStringToHex(memo.data) : undefined,
            MemoType: memo.type ? convertStringToHex(memo.type) : undefined,
            MemoFormat: memo.format ? convertStringToHex(memo.format) : undefined
        })
    };
}
exports.convertMemo = convertMemo;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\transaction\\utils.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\wallet\\wallet-generation.js", {"../common":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\index.js","../common/errors":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\errors.js","../common/schema-validator":"F:\\metamask-extension\\node_modules\\ripple-lib\\dist\\npm\\common\\schema-validator.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","https":"F:\\metamask-extension\\node_modules\\https-browserify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cdist%5Cnpm%5Cwallet%5Cwallet-generation.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFaucetUrl = exports.FaucetNetwork = void 0;
const https = require("https");
const common_1 = require("../common");
const schema_validator_1 = require("../common/schema-validator");
const errors_1 = require("../common/errors");
var FaucetNetwork;
(function (FaucetNetwork) {
    FaucetNetwork["Testnet"] = "faucet.altnet.rippletest.net";
    FaucetNetwork["Devnet"] = "faucet.devnet.rippletest.net";
})(FaucetNetwork = exports.FaucetNetwork || (exports.FaucetNetwork = {}));
const INTERVAL_SECONDS = 1;
const MAX_ATTEMPTS = 20;
function generateFaucetWallet(address) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!this.isConnected())
            throw new errors_1.RippledError("RippleAPI not connected, cannot call faucet");
        let body;
        let startingBalance = 0;
        let faucetUrl = getFaucetUrl(this);
        if (address && schema_validator_1.isValidAddress(address)) {
            body = new TextEncoder().encode(JSON.stringify({
                destination: address
            }));
            const addressToFundBalance = yield getAddressXrpBalance(this, address);
            if (addressToFundBalance && !isNaN(+addressToFundBalance)) {
                startingBalance = +addressToFundBalance;
            }
            else {
                startingBalance = 0;
            }
        }
        const options = {
            hostname: faucetUrl,
            port: 443,
            path: '/accounts',
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Content-Length': body ? body.length : 0
            }
        };
        return new Promise((resolve, reject) => {
            const request = https.request(options, (response) => {
                const chunks = [];
                response.on('data', (d) => {
                    chunks.push(d);
                });
                response.on('end', () => __awaiter(this, void 0, void 0, function* () {
                    const body = Buffer.concat(chunks).toString();
                    if (response.headers['content-type'].startsWith('application/json')) {
                        const wallet = JSON.parse(body);
                        const classicAddress = wallet.account.classicAddress;
                        if (classicAddress) {
                            try {
                                const isFunded = yield hasAddressBalanceIncreased(this, classicAddress, startingBalance);
                                if (isFunded) {
                                    resolve(wallet);
                                }
                                else {
                                    reject(new common_1.errors.XRPLFaucetError(`Unable to fund address with faucet after waiting ${INTERVAL_SECONDS * MAX_ATTEMPTS} seconds`));
                                }
                            }
                            catch (err) {
                                reject(new common_1.errors.XRPLFaucetError(err));
                            }
                        }
                        else {
                            reject(new common_1.errors.XRPLFaucetError(`The faucet account classic address is undefined`));
                        }
                    }
                    else {
                        reject({
                            statusCode: response.statusCode,
                            contentType: response.headers['content-type'],
                            body
                        });
                    }
                }));
            });
            request.write(body ? body : '');
            request.on('error', (error) => {
                reject(error);
            });
            request.end();
        });
    });
}
function getAddressXrpBalance(api, address) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const balances = yield api.getBalances(address);
            const xrpBalance = balances.filter((balance) => balance.currency.toUpperCase() === 'XRP');
            return xrpBalance[0].value;
        }
        catch (err) {
            return `Unable to retrieve ${address} balance. Error: ${err}`;
        }
    });
}
function hasAddressBalanceIncreased(api, address, originalBalance) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            let attempts = MAX_ATTEMPTS;
            const interval = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                if (attempts < 0) {
                    clearInterval(interval);
                    resolve(false);
                }
                else {
                    attempts--;
                }
                try {
                    const newBalance = +(yield getAddressXrpBalance(api, address));
                    if (newBalance > originalBalance) {
                        clearInterval(interval);
                        resolve(true);
                    }
                }
                catch (err) {
                    clearInterval(interval);
                    reject(new common_1.errors.XRPLFaucetError(`Unable to check if the address ${address} balance has increased. Error: ${err}`));
                }
            }), INTERVAL_SECONDS * 1000);
        });
    });
}
function getFaucetUrl(api) {
    const connectionUrl = api.connection.getUrl();
    if (connectionUrl.includes('altnet') || connectionUrl.includes('testnet')) {
        return FaucetNetwork.Testnet;
    }
    if (connectionUrl.includes('devnet')) {
        return FaucetNetwork.Devnet;
    }
    return undefined;
}
exports.getFaucetUrl = getFaucetUrl;
exports.default = generateFaucetWallet;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib",file:"node_modules\\ripple-lib\\dist\\npm\\wallet\\wallet-generation.js",}],
["F:\\metamask-extension\\node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cripple-lib%5Cnode_modules%5Cbignumber.js%5Cbignumber.js
      return function (require, module, exports) {
;(function (globalObject) {
  'use strict';

/*
 *      bignumber.js v9.1.1
 *      A JavaScript library for arbitrary-precision arithmetic.
 *      https://github.com/MikeMcl/bignumber.js
 *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *      MIT Licensed.
 *
 *      BigNumber.prototype methods     |  BigNumber methods
 *                                      |
 *      absoluteValue            abs    |  clone
 *      comparedTo                      |  config               set
 *      decimalPlaces            dp     |      DECIMAL_PLACES
 *      dividedBy                div    |      ROUNDING_MODE
 *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
 *      exponentiatedBy          pow    |      RANGE
 *      integerValue                    |      CRYPTO
 *      isEqualTo                eq     |      MODULO_MODE
 *      isFinite                        |      POW_PRECISION
 *      isGreaterThan            gt     |      FORMAT
 *      isGreaterThanOrEqualTo   gte    |      ALPHABET
 *      isInteger                       |  isBigNumber
 *      isLessThan               lt     |  maximum              max
 *      isLessThanOrEqualTo      lte    |  minimum              min
 *      isNaN                           |  random
 *      isNegative                      |  sum
 *      isPositive                      |
 *      isZero                          |
 *      minus                           |
 *      modulo                   mod    |
 *      multipliedBy             times  |
 *      negated                         |
 *      plus                            |
 *      precision                sd     |
 *      shiftedBy                       |
 *      squareRoot               sqrt   |
 *      toExponential                   |
 *      toFixed                         |
 *      toFormat                        |
 *      toFraction                      |
 *      toJSON                          |
 *      toNumber                        |
 *      toPrecision                     |
 *      toString                        |
 *      valueOf                         |
 *
 */


  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,

    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',

    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,

    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9;                                   // 0 to MAX_INT32


  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div, convertBase, parseNumeric,
      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },
      ONE = new BigNumber(1),


      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------


      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,                     // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,                       // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,                         // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,                         // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,                          // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,                           // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,                          // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,                         // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,                       // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',        // non-breaking space
        suffix: ''
      },

      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;


    //------------------------------------------------------------------------------------------


    // CONSTRUCTOR


    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);

      if (b == null) {

        if (v && v._isBigNumber === true) {
          x.s = v.s;

          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }

          return;
        }

        if ((isNum = typeof v == 'number') && v * 0 == 0) {

          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);

            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }

            return;
          }

          str = String(v);
        } else {

          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);

          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {

          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {

          // Integer.
          e = str.length;
        }

      } else {

        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }

        str = String(v);

        if (isNum = typeof v == 'number') {

          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);

          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error
             (tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }

        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {

              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {

              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||
                  str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }

            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');
        else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);

      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG &&
          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error
             (tooManyDigits + (x.s * v));
        }

         // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {

          // Infinity.
          x.c = x.e = null;

        // Underflow?
        } else if (e < MIN_EXP) {

          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;  // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));

            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }

            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }

          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {

        // Zero.
        x.c = [x.e = 0];
      }
    }


    // CONSTRUCTOR PROPERTIES


    BigNumber.clone = clone;

    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;


    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;

      if (obj != null) {

        if (typeof obj == 'object') {

          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error
                 (bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto &&
                 (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error
                   (bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error
               (bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (typeof v == 'object') FORMAT = v;
            else throw Error
             (bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error
               (bignumberError + p + ' invalid: ' + v);
            }
          }

        } else {

          // '[BigNumber Error] Object expected: {v}'
          throw Error
           (bignumberError + 'Object expected: ' + obj);
        }
      }

      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };


    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;

      var i, n,
        c = v.c,
        e = v.e,
        s = v.s;

      out: if ({}.toString.call(c) == '[object Array]') {

        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {

          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {

            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

      // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }

      throw Error
        (bignumberError + 'Invalid BigNumber: ' + v);
    };


    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };


    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };


    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = (function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
       ? function () { return mathfloor(Math.random() * pow2_53); }
       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
         (Math.random() * 0x800000 | 0); };

      return function (dp) {
        var a, b, e, k, v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);

        if (dp == null) dp = DECIMAL_PLACES;
        else intCheck(dp, 0, MAX);

        k = mathceil(dp / LOG_BASE);

        if (CRYPTO) {

          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {

            a = crypto.getRandomValues(new Uint32Array(k *= 2));

            for (; i < k;) {

              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {

                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

          // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {

            // buffer
            a = crypto.randomBytes(k *= 7);

            for (; i < k;) {

              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {

                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error
             (bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {

          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }

        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {

          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }

        rand.e = e;
        rand.c = c;
        return rand;
      };
    })();


    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };


    // PRIVATE FUNCTIONS


    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = (function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;

        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);

          arr[0] += alphabet.indexOf(str.charAt(i++));

          for (j = 0; j < arr.length; j++) {

            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }

        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),
           10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString
         ? (alphabet = ALPHABET, decimal)
         : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;

        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
               rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {

          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {

          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;

              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    })();


    // Perform division in the specified base. Called by div and convertBase.
    div = (function () {

      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m, temp, xlo, xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;

        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }

        if (carry) x = [carry].concat(x);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, cmp;

        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {

          for (i = cmp = 0; i < aL; i++) {

            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return cmp;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
          yL, yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {

          return new BigNumber(

           // Return NaN if either NaN, or both Infinity or 0.
           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xc && xc[0] == 0 || !yc ? s * 0 : s / 0
         );
        }

        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;

        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);

        if (yc[i] > (xc[i] || 0)) e--;

        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }

          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {

                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {

                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {

                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }

              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

               // If product was < remainder.
              if (cmp == -1) {

                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);

          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }

        if (base == BASE) {

          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);

          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

        // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }

        return q;
      };
    })();


    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;

      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);

      if (!n.c) return n.toString();

      c0 = n.c[0];
      ne = n.e;

      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)
         ? toExponential(str, ne)
         : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;

        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {

          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

        // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }

      return n.s < 0 && c0 ? '-' + str : str;
    }


    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);

      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }

      return m;
    }


    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

       // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

        // Infinity.
        n.c = n.e = null;

      // Underflow?
      } else if (e < MIN_EXP) {

        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }

      return n;
    }


    // Handle values that fail the validity test in BigNumber.
    parseNumeric = (function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;

      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {

            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });

            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }

            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error
              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }

        x.c = x.e = null;
      }
    })();


    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {

        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {

          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);

            if (ni >= xc.length) {

              if (r) {

                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }

          r = r || sd < 0 ||

          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

          r = rm < 4
           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
             rm == (x.s < 0 ? 8 : 7));

          if (sd < 1 || !xc[0]) {
            xc.length = 0;

            if (r) {

              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {

              // Zero.
              xc[0] = x.e = 0;
            }

            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {

            for (; ;) {

              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {

                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }

                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

        // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }

      return x;
    }


    function valueOf(n) {
      var str,
        e = n.e;

      if (e === null) return n.toString();

      str = coeffToString(n.c);

      str = e <= TO_EXP_NEG || e >= TO_EXP_POS
        ? toExponential(str, e)
        : toFixedPoint(str, e, '0');

      return n.s < 0 ? '-' + str : str;
    }


    // PROTOTYPE/INSTANCE METHODS


    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };


    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };


    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c, n, v,
        x = this;

      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), dp + x.e + 1, rm);
      }

      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };


    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };


    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,
        x = this;

      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error
          (bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }

      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {

        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }

      nIsNeg = n.s < 0;

      if (m) {

        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);

        isModExp = !nIsNeg && x.isInteger() && m.isInteger();

        if (isModExp) x = x.mod(m);

      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
        // [1, 240000000]
        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
        // [80000000000000]  [99999750000000]
        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {

        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);

      } else if (POW_PRECISION) {

        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }

      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }

      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (; ;) {

        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;

          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }

        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);

          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }

        x = x.times(x);

        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }

      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);

      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };


    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };


    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };


    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };


    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

    };


    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };


    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };


    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };


    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i, j, t, xLTy,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {

          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
           ROUNDING_MODE == 3 ? -0 : 0);
        }
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {

        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }

        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {

        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

        for (a = b = 0; b < j; b++) {

          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }

      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {

        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }

        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {

        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q, s,
        x = this;

      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

      // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }

      if (MODULO_MODE == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }

      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;

      return y;
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
        base, sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {

        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

          // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }

        return y;
      }

      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i = xcL;
        xcL = ycL;
        ycL = i;
      }

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));

      base = BASE;
      sqrtBase = SQRT_BASE;

      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;

        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }

        zc[j] = c;
      }

      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }

      return normalise(y, zc, e);
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;

      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
       if (a != b) {
        y.s = -b;
        return x.minus(y);
      }

      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;

      if (!xe || !ye) {

        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }

      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }

        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }

      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) {
        t = yc;
        yc = xc;
        xc = t;
        b = a;
      }

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }

      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };


    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c, n, v,
        x = this;

      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;
        else intCheck(rm, 0, 8);

        return round(new BigNumber(x), sd, rm);
      }

      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;

      if (v = c[v]) {

        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }

      if (sd && x.e + 1 > n) n = x.e + 1;

      return n;
    };


    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };


    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, r, rep, t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (; ;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));

          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {

            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {

              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);

                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }

              dp += 4;
              s += 4;
              rep = 1;
            } else {

              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }

              break;
            }
          }
        }
      }

      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };


    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };


    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;

      if (format == null) {
        if (dp != null && rm && typeof rm == 'object') {
          format = rm;
          rm = null;
        } else if (dp && typeof dp == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (typeof format != 'object') {
        throw Error
          (bignumberError + 'Argument not an object: ' + format);
      }

      str = x.toFixed(dp, rm);

      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;

        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }

        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }

        str = fractionPart
         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)
          ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
           '$&' + (format.fractionGroupSeparator || ''))
          : fractionPart)
         : intPart;
      }

      return (format.prefix || '') + str + (format.suffix || '');
    };


    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,
        x = this,
        xc = x.c;

      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error
            (bignumberError + 'Argument ' +
              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }

      if (!xc) return new BigNumber(x);

      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;

      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;

      for (; ;)  {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }

      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];

      MAX_EXP = exp;

      return r;
    };


    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };


    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };


    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS
           ? toExponential(coeffToString(n.c), e)
           : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }

        if (s < 0 && n.c[0]) str = '-' + str;
      }

      return str;
    };


    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };


    P._isBigNumber = true;

    if (configObject != null) BigNumber.set(configObject);

    return BigNumber;
  }


  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.


  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }


  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s, z,
      i = 1,
      j = a.length,
      r = a[0] + '';

    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);

    return r.slice(0, j + 1 || 1);
  }


  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a, b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;

    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }


  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error
       (bignumberError + (name || 'Argument') + (typeof n == 'number'
         ? n < min || n > max ? ' out of range: ' : ' not an integer: '
         : ' not a primitive number: ') + String(n));
    }
  }


  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }


  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
     (e < 0 ? 'e' : 'e+') + e;
  }


  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {

      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

    // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }

    return str;
  }


  // EXPORT


  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () { return BigNumber; });

  // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

  // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }

    globalObject.BigNumber = BigNumber;
  }
})(this);

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/blockchain-link>ripple-lib>bignumber.js",file:"node_modules\\ripple-lib\\node_modules\\bignumber.js\\bignumber.js",}],
["F:\\metamask-extension\\node_modules\\safe-stable-stringify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Csafe-stable-stringify%5Cindex.js
      return function (require, module, exports) {
'use strict'

const { hasOwnProperty } = Object.prototype

const stringify = configure()

// @ts-expect-error
stringify.configure = configure
// @ts-expect-error
stringify.stringify = stringify

// @ts-expect-error
stringify.default = stringify

// @ts-expect-error used for named export
exports.stringify = stringify
// @ts-expect-error used for named export
exports.configure = configure

module.exports = stringify

// eslint-disable-next-line no-control-regex
const strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]|[\ud800-\udbff](?![\udc00-\udfff])|(?:[^\ud800-\udbff]|^)[\udc00-\udfff]/

// Escape C0 control characters, double quotes, the backslash and every code
// unit with a numeric value in the inclusive range 0xD800 to 0xDFFF.
function strEscape (str) {
  // Some magic numbers that worked out fine while benchmarking with v8 8.0
  if (str.length < 5000 && !strEscapeSequencesRegExp.test(str)) {
    return `"${str}"`
  }
  return JSON.stringify(str)
}

function insertSort (array) {
  // Insertion sort is very efficient for small input sizes but it has a bad
  // worst case complexity. Thus, use native array sort for bigger values.
  if (array.length > 2e2) {
    return array.sort()
  }
  for (let i = 1; i < array.length; i++) {
    const currentValue = array[i]
    let position = i
    while (position !== 0 && array[position - 1] > currentValue) {
      array[position] = array[position - 1]
      position--
    }
    array[position] = currentValue
  }
  return array
}

const typedArrayPrototypeGetSymbolToStringTag =
  Object.getOwnPropertyDescriptor(
    Object.getPrototypeOf(
      Object.getPrototypeOf(
        new Int8Array()
      )
    ),
    Symbol.toStringTag
  ).get

function isTypedArrayWithEntries (value) {
  return typedArrayPrototypeGetSymbolToStringTag.call(value) !== undefined && value.length !== 0
}

function stringifyTypedArray (array, separator, maximumBreadth) {
  if (array.length < maximumBreadth) {
    maximumBreadth = array.length
  }
  const whitespace = separator === ',' ? '' : ' '
  let res = `"0":${whitespace}${array[0]}`
  for (let i = 1; i < maximumBreadth; i++) {
    res += `${separator}"${i}":${whitespace}${array[i]}`
  }
  return res
}

function getCircularValueOption (options) {
  if (hasOwnProperty.call(options, 'circularValue')) {
    const circularValue = options.circularValue
    if (typeof circularValue === 'string') {
      return `"${circularValue}"`
    }
    if (circularValue == null) {
      return circularValue
    }
    if (circularValue === Error || circularValue === TypeError) {
      return {
        toString () {
          throw new TypeError('Converting circular structure to JSON')
        }
      }
    }
    throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined')
  }
  return '"[Circular]"'
}

function getBooleanOption (options, key) {
  let value
  if (hasOwnProperty.call(options, key)) {
    value = options[key]
    if (typeof value !== 'boolean') {
      throw new TypeError(`The "${key}" argument must be of type boolean`)
    }
  }
  return value === undefined ? true : value
}

function getPositiveIntegerOption (options, key) {
  let value
  if (hasOwnProperty.call(options, key)) {
    value = options[key]
    if (typeof value !== 'number') {
      throw new TypeError(`The "${key}" argument must be of type number`)
    }
    if (!Number.isInteger(value)) {
      throw new TypeError(`The "${key}" argument must be an integer`)
    }
    if (value < 1) {
      throw new RangeError(`The "${key}" argument must be >= 1`)
    }
  }
  return value === undefined ? Infinity : value
}

function getItemCount (number) {
  if (number === 1) {
    return '1 item'
  }
  return `${number} items`
}

function getUniqueReplacerSet (replacerArray) {
  const replacerSet = new Set()
  for (const value of replacerArray) {
    if (typeof value === 'string' || typeof value === 'number') {
      replacerSet.add(String(value))
    }
  }
  return replacerSet
}

function getStrictOption (options) {
  if (hasOwnProperty.call(options, 'strict')) {
    const value = options.strict
    if (typeof value !== 'boolean') {
      throw new TypeError('The "strict" argument must be of type boolean')
    }
    if (value) {
      return (value) => {
        let message = `Object can not safely be stringified. Received type ${typeof value}`
        if (typeof value !== 'function') message += ` (${value.toString()})`
        throw new Error(message)
      }
    }
  }
}

function configure (options) {
  options = { ...options }
  const fail = getStrictOption(options)
  if (fail) {
    if (options.bigint === undefined) {
      options.bigint = false
    }
    if (!('circularValue' in options)) {
      options.circularValue = Error
    }
  }
  const circularValue = getCircularValueOption(options)
  const bigint = getBooleanOption(options, 'bigint')
  const deterministic = getBooleanOption(options, 'deterministic')
  const maximumDepth = getPositiveIntegerOption(options, 'maximumDepth')
  const maximumBreadth = getPositiveIntegerOption(options, 'maximumBreadth')

  function stringifyFnReplacer (key, parent, stack, replacer, spacer, indentation) {
    let value = parent[key]

    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
      value = value.toJSON(key)
    }
    value = replacer.call(parent, key, value)

    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        let res = ''
        let join = ','
        const originalIndentation = indentation

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          if (spacer !== '') {
            indentation += spacer
            res += `\n${indentation}`
            join = `,\n${indentation}`
          }
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)
            res += tmp !== undefined ? tmp : 'null'
            res += join
          }
          const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`
          }
          if (spacer !== '') {
            res += `\n${originalIndentation}`
          }
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return '{}'
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"'
        }
        let whitespace = ''
        let separator = ''
        if (spacer !== '') {
          indentation += spacer
          join = `,\n${indentation}`
          whitespace = ' '
        }
        const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (deterministic && !isTypedArrayWithEntries(value)) {
          keys = insertSort(keys)
        }
        stack.push(value)
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifyFnReplacer(key, value, stack, replacer, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`
            separator = join
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`
          separator = join
        }
        if (spacer !== '' && separator.length > 1) {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifyArrayReplacer (key, value, stack, replacer, spacer, indentation) {
    if (typeof value === 'object' && value !== null && typeof value.toJSON === 'function') {
      value = value.toJSON(key)
    }

    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        const originalIndentation = indentation
        let res = ''
        let join = ','

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          if (spacer !== '') {
            indentation += spacer
            res += `\n${indentation}`
            join = `,\n${indentation}`
          }
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)
            res += tmp !== undefined ? tmp : 'null'
            res += join
          }
          const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`
          }
          if (spacer !== '') {
            res += `\n${originalIndentation}`
          }
          stack.pop()
          return `[${res}]`
        }
        stack.push(value)
        let whitespace = ''
        if (spacer !== '') {
          indentation += spacer
          join = `,\n${indentation}`
          whitespace = ' '
        }
        let separator = ''
        for (const key of replacer) {
          const tmp = stringifyArrayReplacer(key, value[key], stack, replacer, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${whitespace}${tmp}`
            separator = join
          }
        }
        if (spacer !== '' && separator.length > 1) {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifyIndent (key, value, stack, spacer, indentation) {
    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (typeof value.toJSON === 'function') {
          value = value.toJSON(key)
          // Prevent calling `toJSON` again.
          if (typeof value !== 'object') {
            return stringifyIndent(key, value, stack, spacer, indentation)
          }
          if (value === null) {
            return 'null'
          }
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }
        const originalIndentation = indentation

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          indentation += spacer
          let res = `\n${indentation}`
          const join = `,\n${indentation}`
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)
            res += tmp !== undefined ? tmp : 'null'
            res += join
          }
          const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `${join}"... ${getItemCount(removedKeys)} not stringified"`
          }
          res += `\n${originalIndentation}`
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return '{}'
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"'
        }
        indentation += spacer
        const join = `,\n${indentation}`
        let res = ''
        let separator = ''
        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (isTypedArrayWithEntries(value)) {
          res += stringifyTypedArray(value, join, maximumBreadth)
          keys = keys.slice(value.length)
          maximumPropertiesToStringify -= value.length
          separator = join
        }
        if (deterministic) {
          keys = insertSort(keys)
        }
        stack.push(value)
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifyIndent(key, value[key], stack, spacer, indentation)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}: ${tmp}`
            separator = join
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`
          separator = join
        }
        if (separator !== '') {
          res = `\n${indentation}${res}\n${originalIndentation}`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringifySimple (key, value, stack) {
    switch (typeof value) {
      case 'string':
        return strEscape(value)
      case 'object': {
        if (value === null) {
          return 'null'
        }
        if (typeof value.toJSON === 'function') {
          value = value.toJSON(key)
          // Prevent calling `toJSON` again
          if (typeof value !== 'object') {
            return stringifySimple(key, value, stack)
          }
          if (value === null) {
            return 'null'
          }
        }
        if (stack.indexOf(value) !== -1) {
          return circularValue
        }

        let res = ''

        if (Array.isArray(value)) {
          if (value.length === 0) {
            return '[]'
          }
          if (maximumDepth < stack.length + 1) {
            return '"[Array]"'
          }
          stack.push(value)
          const maximumValuesToStringify = Math.min(value.length, maximumBreadth)
          let i = 0
          for (; i < maximumValuesToStringify - 1; i++) {
            const tmp = stringifySimple(String(i), value[i], stack)
            res += tmp !== undefined ? tmp : 'null'
            res += ','
          }
          const tmp = stringifySimple(String(i), value[i], stack)
          res += tmp !== undefined ? tmp : 'null'
          if (value.length - 1 > maximumBreadth) {
            const removedKeys = value.length - maximumBreadth - 1
            res += `,"... ${getItemCount(removedKeys)} not stringified"`
          }
          stack.pop()
          return `[${res}]`
        }

        let keys = Object.keys(value)
        const keyLength = keys.length
        if (keyLength === 0) {
          return '{}'
        }
        if (maximumDepth < stack.length + 1) {
          return '"[Object]"'
        }
        let separator = ''
        let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth)
        if (isTypedArrayWithEntries(value)) {
          res += stringifyTypedArray(value, ',', maximumBreadth)
          keys = keys.slice(value.length)
          maximumPropertiesToStringify -= value.length
          separator = ','
        }
        if (deterministic) {
          keys = insertSort(keys)
        }
        stack.push(value)
        for (let i = 0; i < maximumPropertiesToStringify; i++) {
          const key = keys[i]
          const tmp = stringifySimple(key, value[key], stack)
          if (tmp !== undefined) {
            res += `${separator}${strEscape(key)}:${tmp}`
            separator = ','
          }
        }
        if (keyLength > maximumBreadth) {
          const removedKeys = keyLength - maximumBreadth
          res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`
        }
        stack.pop()
        return `{${res}}`
      }
      case 'number':
        return isFinite(value) ? String(value) : fail ? fail(value) : 'null'
      case 'boolean':
        return value === true ? 'true' : 'false'
      case 'undefined':
        return undefined
      case 'bigint':
        if (bigint) {
          return String(value)
        }
        // fallthrough
      default:
        return fail ? fail(value) : undefined
    }
  }

  function stringify (value, replacer, space) {
    if (arguments.length > 1) {
      let spacer = ''
      if (typeof space === 'number') {
        spacer = ' '.repeat(Math.min(space, 10))
      } else if (typeof space === 'string') {
        spacer = space.slice(0, 10)
      }
      if (replacer != null) {
        if (typeof replacer === 'function') {
          return stringifyFnReplacer('', { '': value }, [], replacer, spacer, '')
        }
        if (Array.isArray(replacer)) {
          return stringifyArrayReplacer('', value, [], getUniqueReplacerSet(replacer), spacer, '')
        }
      }
      if (spacer.length !== 0) {
        return stringifyIndent('', value, [], spacer, '')
      }
    }
    return stringifySimple('', value, [])
  }

  return stringify
}

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>safe-stable-stringify",file:"node_modules\\safe-stable-stringify\\index.js",}],
["F:\\metamask-extension\\node_modules\\scryptsy\\lib\\scrypt.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","pbkdf2":"F:\\metamask-extension\\node_modules\\pbkdf2\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cscryptsy%5Clib%5Cscrypt.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var pbkdf2Sync = require('pbkdf2').pbkdf2Sync

var MAX_VALUE = 0x7fffffff

// N = Cpu cost, r = Memory cost, p = parallelization cost
function scrypt (key, salt, N, r, p, dkLen, progressCallback) {
  if (N === 0 || (N & (N - 1)) !== 0) throw Error('N must be > 0 and a power of 2')

  if (N > MAX_VALUE / 128 / r) throw Error('Parameter N is too large')
  if (r > MAX_VALUE / 128 / p) throw Error('Parameter r is too large')

  var XY = new Buffer(256 * r)
  var V = new Buffer(128 * r * N)

  // pseudo global
  var B32 = new Int32Array(16) // salsa20_8
  var x = new Int32Array(16) // salsa20_8
  var _X = new Buffer(64) // blockmix_salsa8

  // pseudo global
  var B = pbkdf2Sync(key, salt, 1, p * 128 * r, 'sha256')

  var tickCallback
  if (progressCallback) {
    var totalOps = p * N * 2
    var currentOp = 0

    tickCallback = function () {
      ++currentOp

      // send progress notifications once every 1,000 ops
      if (currentOp % 1000 === 0) {
        progressCallback({
          current: currentOp,
          total: totalOps,
          percent: (currentOp / totalOps) * 100.0
        })
      }
    }
  }

  for (var i = 0; i < p; i++) {
    smix(B, i * 128 * r, r, N, V, XY)
  }

  return pbkdf2Sync(key, B, 1, dkLen, 'sha256')

  // all of these functions are actually moved to the top
  // due to function hoisting

  function smix (B, Bi, r, N, V, XY) {
    var Xi = 0
    var Yi = 128 * r
    var i

    B.copy(XY, Xi, Bi, Bi + Yi)

    for (i = 0; i < N; i++) {
      XY.copy(V, i * Yi, Xi, Xi + Yi)
      blockmix_salsa8(XY, Xi, Yi, r)

      if (tickCallback) tickCallback()
    }

    for (i = 0; i < N; i++) {
      var offset = Xi + (2 * r - 1) * 64
      var j = XY.readUInt32LE(offset) & (N - 1)
      blockxor(V, j * Yi, XY, Xi, Yi)
      blockmix_salsa8(XY, Xi, Yi, r)

      if (tickCallback) tickCallback()
    }

    XY.copy(B, Bi, Xi, Xi + Yi)
  }

  function blockmix_salsa8 (BY, Bi, Yi, r) {
    var i

    arraycopy(BY, Bi + (2 * r - 1) * 64, _X, 0, 64)

    for (i = 0; i < 2 * r; i++) {
      blockxor(BY, i * 64, _X, 0, 64)
      salsa20_8(_X)
      arraycopy(_X, 0, BY, Yi + (i * 64), 64)
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2) * 64, BY, Bi + (i * 64), 64)
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64)
    }
  }

  function R (a, b) {
    return (a << b) | (a >>> (32 - b))
  }

  function salsa20_8 (B) {
    var i

    for (i = 0; i < 16; i++) {
      B32[i] = (B[i * 4 + 0] & 0xff) << 0
      B32[i] |= (B[i * 4 + 1] & 0xff) << 8
      B32[i] |= (B[i * 4 + 2] & 0xff) << 16
      B32[i] |= (B[i * 4 + 3] & 0xff) << 24
      // B32[i] = B.readUInt32LE(i*4)   <--- this is signficantly slower even in Node.js
    }

    arraycopy(B32, 0, x, 0, 16)

    for (i = 8; i > 0; i -= 2) {
      x[ 4] ^= R(x[ 0] + x[12], 7)
      x[ 8] ^= R(x[ 4] + x[ 0], 9)
      x[12] ^= R(x[ 8] + x[ 4], 13)
      x[ 0] ^= R(x[12] + x[ 8], 18)
      x[ 9] ^= R(x[ 5] + x[ 1], 7)
      x[13] ^= R(x[ 9] + x[ 5], 9)
      x[ 1] ^= R(x[13] + x[ 9], 13)
      x[ 5] ^= R(x[ 1] + x[13], 18)
      x[14] ^= R(x[10] + x[ 6], 7)
      x[ 2] ^= R(x[14] + x[10], 9)
      x[ 6] ^= R(x[ 2] + x[14], 13)
      x[10] ^= R(x[ 6] + x[ 2], 18)
      x[ 3] ^= R(x[15] + x[11], 7)
      x[ 7] ^= R(x[ 3] + x[15], 9)
      x[11] ^= R(x[ 7] + x[ 3], 13)
      x[15] ^= R(x[11] + x[ 7], 18)
      x[ 1] ^= R(x[ 0] + x[ 3], 7)
      x[ 2] ^= R(x[ 1] + x[ 0], 9)
      x[ 3] ^= R(x[ 2] + x[ 1], 13)
      x[ 0] ^= R(x[ 3] + x[ 2], 18)
      x[ 6] ^= R(x[ 5] + x[ 4], 7)
      x[ 7] ^= R(x[ 6] + x[ 5], 9)
      x[ 4] ^= R(x[ 7] + x[ 6], 13)
      x[ 5] ^= R(x[ 4] + x[ 7], 18)
      x[11] ^= R(x[10] + x[ 9], 7)
      x[ 8] ^= R(x[11] + x[10], 9)
      x[ 9] ^= R(x[ 8] + x[11], 13)
      x[10] ^= R(x[ 9] + x[ 8], 18)
      x[12] ^= R(x[15] + x[14], 7)
      x[13] ^= R(x[12] + x[15], 9)
      x[14] ^= R(x[13] + x[12], 13)
      x[15] ^= R(x[14] + x[13], 18)
    }

    for (i = 0; i < 16; ++i) B32[i] = x[i] + B32[i]

    for (i = 0; i < 16; i++) {
      var bi = i * 4
      B[bi + 0] = (B32[i] >> 0 & 0xff)
      B[bi + 1] = (B32[i] >> 8 & 0xff)
      B[bi + 2] = (B32[i] >> 16 & 0xff)
      B[bi + 3] = (B32[i] >> 24 & 0xff)
      // B.writeInt32LE(B32[i], i*4)  //<--- this is signficantly slower even in Node.js
    }
  }

  // naive approach... going back to loop unrolling may yield additional performance
  function blockxor (S, Si, D, Di, len) {
    for (var i = 0; i < len; i++) {
      D[Di + i] ^= S[Si + i]
    }
  }
}

function arraycopy (src, srcPos, dest, destPos, length) {
  if (Buffer.isBuffer(src) && Buffer.isBuffer(dest)) {
    src.copy(dest, destPos, srcPos, srcPos + length)
  } else {
    while (length--) {
      dest[destPos++] = src[srcPos++]
    }
  }
}

module.exports = scrypt

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"ethereumjs-wallet>scryptsy",file:"node_modules\\scryptsy\\lib\\scrypt.js",}],
["F:\\metamask-extension\\node_modules\\through\\index.js", {"_process":"F:\\metamask-extension\\node_modules\\process\\browser.js","stream":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cthrough%5Cindex.js
      return function (require, module, exports) {
(function (process){(function (){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"debounce-stream>through",file:"node_modules\\through\\index.js",}],
["F:\\metamask-extension\\node_modules\\tiny-secp256k1\\js.js", {"./rfc6979":"F:\\metamask-extension\\node_modules\\tiny-secp256k1\\rfc6979.js","bn.js":"F:\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","elliptic":"F:\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ctiny-secp256k1%5Cjs.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const BN = require('bn.js')
const EC = require('elliptic').ec
const secp256k1 = new EC('secp256k1')
const deterministicGenerateK = require('./rfc6979')

const ZERO32 = Buffer.alloc(32, 0)
const EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex')
const EC_P = Buffer.from('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f', 'hex')

const n = secp256k1.curve.n
const nDiv2 = n.shrn(1)
const G = secp256k1.curve.g

const THROW_BAD_PRIVATE = 'Expected Private'
const THROW_BAD_POINT = 'Expected Point'
const THROW_BAD_TWEAK = 'Expected Tweak'
const THROW_BAD_HASH = 'Expected Hash'
const THROW_BAD_SIGNATURE = 'Expected Signature'
const THROW_BAD_EXTRA_DATA = 'Expected Extra Data (32 bytes)'

function isScalar (x) {
  return Buffer.isBuffer(x) && x.length === 32
}

function isOrderScalar (x) {
  if (!isScalar(x)) return false
  return x.compare(EC_GROUP_ORDER) < 0 // < G
}

function isPoint (p) {
  if (!Buffer.isBuffer(p)) return false
  if (p.length < 33) return false

  const t = p[0]
  const x = p.slice(1, 33)
  if (x.compare(ZERO32) === 0) return false
  if (x.compare(EC_P) >= 0) return false
  if ((t === 0x02 || t === 0x03) && p.length === 33) {
    try { decodeFrom(p) } catch (e) { return false } // TODO: temporary
    return true
  }

  const y = p.slice(33)
  if (y.compare(ZERO32) === 0) return false
  if (y.compare(EC_P) >= 0) return false
  if (t === 0x04 && p.length === 65) return true
  return false
}

function __isPointCompressed (p) {
  return p[0] !== 0x04
}

function isPointCompressed (p) {
  if (!isPoint(p)) return false
  return __isPointCompressed(p)
}

function isPrivate (x) {
  if (!isScalar(x)) return false
  return x.compare(ZERO32) > 0 && // > 0
    x.compare(EC_GROUP_ORDER) < 0 // < G
}

function isSignature (value) {
  const r = value.slice(0, 32)
  const s = value.slice(32, 64)
  return Buffer.isBuffer(value) && value.length === 64 &&
    r.compare(EC_GROUP_ORDER) < 0 &&
    s.compare(EC_GROUP_ORDER) < 0
}

function assumeCompression (value, pubkey) {
  if (value === undefined && pubkey !== undefined) return __isPointCompressed(pubkey)
  if (value === undefined) return true
  return value
}

function fromBuffer (d) { return new BN(d) }
function toBuffer (d) { return d.toArrayLike(Buffer, 'be', 32) }
function decodeFrom (P) { return secp256k1.curve.decodePoint(P) }
function getEncoded (P, compressed) { return Buffer.from(P._encode(compressed)) }

function pointAdd (pA, pB, __compressed) {
  if (!isPoint(pA)) throw new TypeError(THROW_BAD_POINT)
  if (!isPoint(pB)) throw new TypeError(THROW_BAD_POINT)

  const a = decodeFrom(pA)
  const b = decodeFrom(pB)
  const pp = a.add(b)
  if (pp.isInfinity()) return null

  const compressed = assumeCompression(__compressed, pA)
  return getEncoded(pp, compressed)
}

function pointAddScalar (p, tweak, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const compressed = assumeCompression(__compressed, p)
  const pp = decodeFrom(p)
  if (tweak.compare(ZERO32) === 0) return getEncoded(pp, compressed)

  const tt = fromBuffer(tweak)
  const qq = G.mul(tt)
  const uu = pp.add(qq)
  if (uu.isInfinity()) return null

  return getEncoded(uu, compressed)
}

function pointCompress (p, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)

  const pp = decodeFrom(p)
  if (pp.isInfinity()) throw new TypeError(THROW_BAD_POINT)

  const compressed = assumeCompression(__compressed, p)

  return getEncoded(pp, compressed)
}

function pointFromScalar (d, __compressed) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)

  const dd = fromBuffer(d)
  const pp = G.mul(dd)
  if (pp.isInfinity()) return null

  const compressed = assumeCompression(__compressed)
  return getEncoded(pp, compressed)
}

function pointMultiply (p, tweak, __compressed) {
  if (!isPoint(p)) throw new TypeError(THROW_BAD_POINT)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const compressed = assumeCompression(__compressed, p)
  const pp = decodeFrom(p)
  const tt = fromBuffer(tweak)
  const qq = pp.mul(tt)
  if (qq.isInfinity()) return null

  return getEncoded(qq, compressed)
}

function privateAdd (d, tweak) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const dd = fromBuffer(d)
  const tt = fromBuffer(tweak)
  const dt = toBuffer(dd.add(tt).umod(n))
  if (!isPrivate(dt)) return null

  return dt
}

function privateSub (d, tweak) {
  if (!isPrivate(d)) throw new TypeError(THROW_BAD_PRIVATE)
  if (!isOrderScalar(tweak)) throw new TypeError(THROW_BAD_TWEAK)

  const dd = fromBuffer(d)
  const tt = fromBuffer(tweak)
  const dt = toBuffer(dd.sub(tt).umod(n))
  if (!isPrivate(dt)) return null

  return dt
}

function sign (hash, x) {
  return __sign(hash, x)
}

function signWithEntropy (hash, x, addData) {
  return __sign(hash, x, addData)
}

function __sign (hash, x, addData) {
  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
  if (!isPrivate(x)) throw new TypeError(THROW_BAD_PRIVATE)
  if (addData !== undefined && !isScalar(addData)) throw new TypeError(THROW_BAD_EXTRA_DATA)

  const d = fromBuffer(x)
  const e = fromBuffer(hash)

  let r, s
  const checkSig = function (k) {
    const kI = fromBuffer(k)
    const Q = G.mul(kI)

    if (Q.isInfinity()) return false

    r = Q.x.umod(n)
    if (r.isZero() === 0) return false

    s = kI
      .invm(n)
      .mul(e.add(d.mul(r)))
      .umod(n)
    if (s.isZero() === 0) return false

    return true
  }

  deterministicGenerateK(hash, x, checkSig, isPrivate, addData)

  // enforce low S values, see bip62: 'low s values in signatures'
  if (s.cmp(nDiv2) > 0) {
    s = n.sub(s)
  }

  const buffer = Buffer.allocUnsafe(64)
  toBuffer(r).copy(buffer, 0)
  toBuffer(s).copy(buffer, 32)
  return buffer
}

function verify (hash, q, signature, strict) {
  if (!isScalar(hash)) throw new TypeError(THROW_BAD_HASH)
  if (!isPoint(q)) throw new TypeError(THROW_BAD_POINT)

  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (1, isSignature enforces '< n - 1')
  if (!isSignature(signature)) throw new TypeError(THROW_BAD_SIGNATURE)

  const Q = decodeFrom(q)
  const r = fromBuffer(signature.slice(0, 32))
  const s = fromBuffer(signature.slice(32, 64))

  if (strict && s.cmp(nDiv2) > 0) {
    return false
  }

  // 1.4.1 Enforce r and s are both integers in the interval [1, n  1] (2, enforces '> 0')
  if (r.gtn(0) <= 0 /* || r.compareTo(n) >= 0 */) return false
  if (s.gtn(0) <= 0 /* || s.compareTo(n) >= 0 */) return false

  // 1.4.2 H = Hash(M), already done by the user
  // 1.4.3 e = H
  const e = fromBuffer(hash)

  // Compute s^-1
  const sInv = s.invm(n)

  // 1.4.4 Compute u1 = es^1 mod n
  //               u2 = rs^1 mod n
  const u1 = e.mul(sInv).umod(n)
  const u2 = r.mul(sInv).umod(n)

  // 1.4.5 Compute R = (xR, yR)
  //               R = u1G + u2Q
  const R = G.mulAdd(u1, Q, u2)

  // 1.4.5 (cont.) Enforce R is not at infinity
  if (R.isInfinity()) return false

  // 1.4.6 Convert the field element R.x to an integer
  const xR = R.x

  // 1.4.7 Set v = xR mod n
  const v = xR.umod(n)

  // 1.4.8 If v = r, output "valid", and if v != r, output "invalid"
  return v.eq(r)
}

module.exports = {
  isPoint,
  isPointCompressed,
  isPrivate,
  pointAdd,
  pointAddScalar,
  pointCompress,
  pointFromScalar,
  pointMultiply,
  privateAdd,
  privateSub,
  sign,
  signWithEntropy,
  verify
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>tiny-secp256k1",file:"node_modules\\tiny-secp256k1\\js.js",}],
["F:\\metamask-extension\\node_modules\\tiny-secp256k1\\rfc6979.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","create-hmac":"F:\\metamask-extension\\node_modules\\create-hmac\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ctiny-secp256k1%5Crfc6979.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const createHmac = require('create-hmac')

const ONE1 = Buffer.alloc(1, 1)
const ZERO1 = Buffer.alloc(1, 0)

// https://tools.ietf.org/html/rfc6979#section-3.2
function deterministicGenerateK (hash, x, checkSig, isPrivate, extraEntropy) {
  // Step A, ignored as hash already provided
  // Step B
  // Step C
  let k = Buffer.alloc(32, 0)
  let v = Buffer.alloc(32, 1)

  // Step D
  k = createHmac('sha256', k)
    .update(v)
    .update(ZERO1)
    .update(x)
    .update(hash)
    .update(extraEntropy || '')
    .digest()

  // Step E
  v = createHmac('sha256', k).update(v).digest()

  // Step F
  k = createHmac('sha256', k)
    .update(v)
    .update(ONE1)
    .update(x)
    .update(hash)
    .update(extraEntropy || '')
    .digest()

  // Step G
  v = createHmac('sha256', k).update(v).digest()

  // Step H1/H2a, ignored as tlen === qlen (256 bit)
  // Step H2b
  v = createHmac('sha256', k).update(v).digest()

  let T = v

  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA
  while (!isPrivate(T) || !checkSig(T)) {
    k = createHmac('sha256', k)
      .update(v)
      .update(ZERO1)
      .digest()

    v = createHmac('sha256', k).update(v).digest()

    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)
    // Step H2b again
    v = createHmac('sha256', k).update(v).digest()
    T = v
  }

  return T
}

module.exports = deterministicGenerateK

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>tiny-secp256k1",file:"node_modules\\tiny-secp256k1\\rfc6979.js",}],
["F:\\metamask-extension\\node_modules\\to-data-view\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cto-data-view%5Cindex.js
      return function (require, module, exports) {
module.exports = function toDataView (data) {
  if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
    return new DataView(data.buffer, data.byteOffset, data.byteLength)
  }

  if (data instanceof ArrayBuffer) {
    return new DataView(data)
  }

  throw new TypeError('Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray')
}

      };
    };
  }
  }
}, {package:"base32-encode>to-data-view",file:"node_modules\\to-data-view\\index.js",}],
["F:\\metamask-extension\\node_modules\\tweetnacl-util\\nacl-util.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ctweetnacl-util%5Cnacl-util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
// Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
(function(root, f) {
  'use strict';
  if (typeof module !== 'undefined' && module.exports) module.exports = f();
  else if (root.nacl) root.nacl.util = f();
  else {
    root.nacl = {};
    root.nacl.util = f();
  }
}(this, function() {
  'use strict';

  var util = {};

  function validateBase64(s) {
    if (!(/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s))) {
      throw new TypeError('invalid encoding');
    }
  }

  util.decodeUTF8 = function(s) {
    if (typeof s !== 'string') throw new TypeError('expected string');
    var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
    for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
    return b;
  };

  util.encodeUTF8 = function(arr) {
    var i, s = [];
    for (i = 0; i < arr.length; i++) s.push(String.fromCharCode(arr[i]));
    return decodeURIComponent(escape(s.join('')));
  };

  if (typeof atob === 'undefined') {
    // Node.js

    if (typeof Buffer.from !== 'undefined') {
       // Node v6 and later
      util.encodeBase64 = function (arr) { // v6 and later
          return Buffer.from(arr).toString('base64');
      };

      util.decodeBase64 = function (s) {
        validateBase64(s);
        return new Uint8Array(Array.prototype.slice.call(Buffer.from(s, 'base64'), 0));
      };

    } else {
      // Node earlier than v6
      util.encodeBase64 = function (arr) { // v6 and later
        return (new Buffer(arr)).toString('base64');
      };

      util.decodeBase64 = function(s) {
        validateBase64(s);
        return new Uint8Array(Array.prototype.slice.call(new Buffer(s, 'base64'), 0));
      };
    }

  } else {
    // Browsers

    util.encodeBase64 = function(arr) {
      var i, s = [], len = arr.length;
      for (i = 0; i < len; i++) s.push(String.fromCharCode(arr[i]));
      return btoa(s.join(''));
    };

    util.decodeBase64 = function(s) {
      validateBase64(s);
      var i, d = atob(s), b = new Uint8Array(d.length);
      for (i = 0; i < d.length; i++) b[i] = d.charCodeAt(i);
      return b;
    };

  }

  return util;

}));

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"eth-sig-util>tweetnacl-util",file:"node_modules\\tweetnacl-util\\nacl-util.js",}],
["F:\\metamask-extension\\node_modules\\tweetnacl\\nacl-fast.js", {"crypto":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ctweetnacl%5Cnacl-fast.js
      return function (require, module, exports) {
(function(nacl) {
'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = Math.floor((x[j] + 128) / 256);
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  return n;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES,

  gf: gf,
  D: D,
  L: L,
  pack25519: pack25519,
  unpack25519: unpack25519,
  M: M,
  A: A,
  S: S,
  Z: Z,
  pow2523: pow2523,
  add: add,
  set25519: set25519,
  modL: modL,
  scalarmult: scalarmult,
  scalarbase: scalarbase,
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  for (var i = 0; i < arguments.length; i++) {
    if (!(arguments[i] instanceof Uint8Array))
      throw new TypeError('unexpected type, use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (typeof require !== 'undefined') {
    // Node.js.
    crypto = require('crypto');
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})(typeof module !== 'undefined' && module.exports ? module.exports : (self.nacl = self.nacl || {}));

      };
    };
  }
  }
}, {package:"eth-sig-util>tweetnacl",file:"node_modules\\tweetnacl\\nacl-fast.js",}],
["F:\\metamask-extension\\node_modules\\typeforce\\errors.js", {"./native":"F:\\metamask-extension\\node_modules\\typeforce\\native.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ctypeforce%5Cerrors.js
      return function (require, module, exports) {
var native = require('./native')

function getTypeName (fn) {
  return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1]
}

function getValueTypeName (value) {
  return native.Nil(value) ? '' : getTypeName(value.constructor)
}

function getValue (value) {
  if (native.Function(value)) return ''
  if (native.String(value)) return JSON.stringify(value)
  if (value && native.Object(value)) return ''
  return value
}

function captureStackTrace (e, t) {
  if (Error.captureStackTrace) {
    Error.captureStackTrace(e, t)
  }
}

function tfJSON (type) {
  if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type)
  if (native.Array(type)) return 'Array'
  if (type && native.Object(type)) return 'Object'

  return type !== undefined ? type : ''
}

function tfErrorString (type, value, valueTypeName) {
  var valueJson = getValue(value)

  return 'Expected ' + tfJSON(type) + ', got' +
    (valueTypeName !== '' ? ' ' + valueTypeName : '') +
    (valueJson !== '' ? ' ' + valueJson : '')
}

function TfTypeError (type, value, valueTypeName) {
  valueTypeName = valueTypeName || getValueTypeName(value)
  this.message = tfErrorString(type, value, valueTypeName)

  captureStackTrace(this, TfTypeError)
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfTypeError.prototype = Object.create(Error.prototype)
TfTypeError.prototype.constructor = TfTypeError

function tfPropertyErrorString (type, label, name, value, valueTypeName) {
  var description = '" of type '
  if (label === 'key') description = '" with key type '

  return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName)
}

function TfPropertyTypeError (type, property, label, value, valueTypeName) {
  if (type) {
    valueTypeName = valueTypeName || getValueTypeName(value)
    this.message = tfPropertyErrorString(type, label, property, value, valueTypeName)
  } else {
    this.message = 'Unexpected property "' + property + '"'
  }

  captureStackTrace(this, TfTypeError)
  this.__label = label
  this.__property = property
  this.__type = type
  this.__value = value
  this.__valueTypeName = valueTypeName
}

TfPropertyTypeError.prototype = Object.create(Error.prototype)
TfPropertyTypeError.prototype.constructor = TfTypeError

function tfCustomError (expected, actual) {
  return new TfTypeError(expected, {}, actual)
}

function tfSubError (e, property, label) {
  // sub child?
  if (e instanceof TfPropertyTypeError) {
    property = property + '.' + e.__property

    e = new TfPropertyTypeError(
      e.__type, property, e.__label, e.__value, e.__valueTypeName
    )

  // child?
  } else if (e instanceof TfTypeError) {
    e = new TfPropertyTypeError(
      e.__type, property, label, e.__value, e.__valueTypeName
    )
  }

  captureStackTrace(e)
  return e
}

module.exports = {
  TfTypeError: TfTypeError,
  TfPropertyTypeError: TfPropertyTypeError,
  tfCustomError: tfCustomError,
  tfSubError: tfSubError,
  tfJSON: tfJSON,
  getValueTypeName: getValueTypeName
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>typeforce",file:"node_modules\\typeforce\\errors.js",}],
["F:\\metamask-extension\\node_modules\\typeforce\\extra.js", {"../is-buffer/index.js":"F:\\metamask-extension\\node_modules\\is-buffer\\index.js","./errors":"F:\\metamask-extension\\node_modules\\typeforce\\errors.js","./native":"F:\\metamask-extension\\node_modules\\typeforce\\native.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ctypeforce%5Cextra.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var NATIVE = require('./native')
var ERRORS = require('./errors')

function _Buffer (value) {
  return Buffer.isBuffer(value)
}

function Hex (value) {
  return typeof value === 'string' && /^([0-9a-f]{2})+$/i.test(value)
}

function _LengthN (type, length) {
  var name = type.toJSON()

  function Length (value) {
    if (!type(value)) return false
    if (value.length === length) return true

    throw ERRORS.tfCustomError(name + '(Length: ' + length + ')', name + '(Length: ' + value.length + ')')
  }
  Length.toJSON = function () { return name }

  return Length
}

var _ArrayN = _LengthN.bind(null, NATIVE.Array)
var _BufferN = _LengthN.bind(null, _Buffer)
var _HexN = _LengthN.bind(null, Hex)
var _StringN = _LengthN.bind(null, NATIVE.String)

function Range (a, b, f) {
  f = f || NATIVE.Number
  function _range (value, strict) {
    return f(value, strict) && (value > a) && (value < b)
  }
  _range.toJSON = function () {
    return `${f.toJSON()} between [${a}, ${b}]`
  }
  return _range
}

var INT53_MAX = Math.pow(2, 53) - 1

function Finite (value) {
  return typeof value === 'number' && isFinite(value)
}
function Int8 (value) { return ((value << 24) >> 24) === value }
function Int16 (value) { return ((value << 16) >> 16) === value }
function Int32 (value) { return (value | 0) === value }
function Int53 (value) {
  return typeof value === 'number' &&
    value >= -INT53_MAX &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}
function UInt8 (value) { return (value & 0xff) === value }
function UInt16 (value) { return (value & 0xffff) === value }
function UInt32 (value) { return (value >>> 0) === value }
function UInt53 (value) {
  return typeof value === 'number' &&
    value >= 0 &&
    value <= INT53_MAX &&
    Math.floor(value) === value
}

var types = {
  ArrayN: _ArrayN,
  Buffer: _Buffer,
  BufferN: _BufferN,
  Finite: Finite,
  Hex: Hex,
  HexN: _HexN,
  Int8: Int8,
  Int16: Int16,
  Int32: Int32,
  Int53: Int53,
  Range: Range,
  StringN: _StringN,
  UInt8: UInt8,
  UInt16: UInt16,
  UInt32: UInt32,
  UInt53: UInt53
}

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types

}).call(this)}).call(this,{"isBuffer":require("../is-buffer/index.js")})

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>typeforce",file:"node_modules\\typeforce\\extra.js",}],
["F:\\metamask-extension\\node_modules\\typeforce\\index.js", {"./errors":"F:\\metamask-extension\\node_modules\\typeforce\\errors.js","./extra":"F:\\metamask-extension\\node_modules\\typeforce\\extra.js","./native":"F:\\metamask-extension\\node_modules\\typeforce\\native.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ctypeforce%5Cindex.js
      return function (require, module, exports) {
var ERRORS = require('./errors')
var NATIVE = require('./native')

// short-hand
var tfJSON = ERRORS.tfJSON
var TfTypeError = ERRORS.TfTypeError
var TfPropertyTypeError = ERRORS.TfPropertyTypeError
var tfSubError = ERRORS.tfSubError
var getValueTypeName = ERRORS.getValueTypeName

var TYPES = {
  arrayOf: function arrayOf (type, options) {
    type = compile(type)
    options = options || {}

    function _arrayOf (array, strict) {
      if (!NATIVE.Array(array)) return false
      if (NATIVE.Nil(array)) return false
      if (options.minLength !== undefined && array.length < options.minLength) return false
      if (options.maxLength !== undefined && array.length > options.maxLength) return false
      if (options.length !== undefined && array.length !== options.length) return false

      return array.every(function (value, i) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _arrayOf.toJSON = function () {
      var str = '[' + tfJSON(type) + ']'
      if (options.length !== undefined) {
        str += '{' + options.length + '}'
      } else if (options.minLength !== undefined || options.maxLength !== undefined) {
        str += '{' +
          (options.minLength === undefined ? 0 : options.minLength) + ',' +
          (options.maxLength === undefined ? Infinity : options.maxLength) + '}'
      }
      return str
    }

    return _arrayOf
  },

  maybe: function maybe (type) {
    type = compile(type)

    function _maybe (value, strict) {
      return NATIVE.Nil(value) || type(value, strict, maybe)
    }
    _maybe.toJSON = function () { return '?' + tfJSON(type) }

    return _maybe
  },

  map: function map (propertyType, propertyKeyType) {
    propertyType = compile(propertyType)
    if (propertyKeyType) propertyKeyType = compile(propertyKeyType)

    function _map (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      for (var propertyName in value) {
        try {
          if (propertyKeyType) {
            typeforce(propertyKeyType, propertyName, strict)
          }
        } catch (e) {
          throw tfSubError(e, propertyName, 'key')
        }

        try {
          var propertyValue = value[propertyName]
          typeforce(propertyType, propertyValue, strict)
        } catch (e) {
          throw tfSubError(e, propertyName)
        }
      }

      return true
    }

    if (propertyKeyType) {
      _map.toJSON = function () {
        return '{' + tfJSON(propertyKeyType) + ': ' + tfJSON(propertyType) + '}'
      }
    } else {
      _map.toJSON = function () { return '{' + tfJSON(propertyType) + '}' }
    }

    return _map
  },

  object: function object (uncompiled) {
    var type = {}

    for (var typePropertyName in uncompiled) {
      type[typePropertyName] = compile(uncompiled[typePropertyName])
    }

    function _object (value, strict) {
      if (!NATIVE.Object(value)) return false
      if (NATIVE.Nil(value)) return false

      var propertyName

      try {
        for (propertyName in type) {
          var propertyType = type[propertyName]
          var propertyValue = value[propertyName]

          typeforce(propertyType, propertyValue, strict)
        }
      } catch (e) {
        throw tfSubError(e, propertyName)
      }

      if (strict) {
        for (propertyName in value) {
          if (type[propertyName]) continue

          throw new TfPropertyTypeError(undefined, propertyName)
        }
      }

      return true
    }
    _object.toJSON = function () { return tfJSON(type) }

    return _object
  },

  anyOf: function anyOf () {
    var types = [].slice.call(arguments).map(compile)

    function _anyOf (value, strict) {
      return types.some(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _anyOf.toJSON = function () { return types.map(tfJSON).join('|') }

    return _anyOf
  },

  allOf: function allOf () {
    var types = [].slice.call(arguments).map(compile)

    function _allOf (value, strict) {
      return types.every(function (type) {
        try {
          return typeforce(type, value, strict)
        } catch (e) {
          return false
        }
      })
    }
    _allOf.toJSON = function () { return types.map(tfJSON).join(' & ') }

    return _allOf
  },

  quacksLike: function quacksLike (type) {
    function _quacksLike (value) {
      return type === getValueTypeName(value)
    }
    _quacksLike.toJSON = function () { return type }

    return _quacksLike
  },

  tuple: function tuple () {
    var types = [].slice.call(arguments).map(compile)

    function _tuple (values, strict) {
      if (NATIVE.Nil(values)) return false
      if (NATIVE.Nil(values.length)) return false
      if (strict && (values.length !== types.length)) return false

      return types.every(function (type, i) {
        try {
          return typeforce(type, values[i], strict)
        } catch (e) {
          throw tfSubError(e, i)
        }
      })
    }
    _tuple.toJSON = function () { return '(' + types.map(tfJSON).join(', ') + ')' }

    return _tuple
  },

  value: function value (expected) {
    function _value (actual) {
      return actual === expected
    }
    _value.toJSON = function () { return expected }

    return _value
  }
}

// TODO: deprecate
TYPES.oneOf = TYPES.anyOf

function compile (type) {
  if (NATIVE.String(type)) {
    if (type[0] === '?') return TYPES.maybe(type.slice(1))

    return NATIVE[type] || TYPES.quacksLike(type)
  } else if (type && NATIVE.Object(type)) {
    if (NATIVE.Array(type)) {
      if (type.length !== 1) throw new TypeError('Expected compile() parameter of type Array of length 1')
      return TYPES.arrayOf(type[0])
    }

    return TYPES.object(type)
  } else if (NATIVE.Function(type)) {
    return type
  }

  return TYPES.value(type)
}

function typeforce (type, value, strict, surrogate) {
  if (NATIVE.Function(type)) {
    if (type(value, strict)) return true

    throw new TfTypeError(surrogate || type, value)
  }

  // JIT
  return typeforce(compile(type), value, strict)
}

// assign types to typeforce function
for (var typeName in NATIVE) {
  typeforce[typeName] = NATIVE[typeName]
}

for (typeName in TYPES) {
  typeforce[typeName] = TYPES[typeName]
}

var EXTRA = require('./extra')
for (typeName in EXTRA) {
  typeforce[typeName] = EXTRA[typeName]
}

typeforce.compile = compile
typeforce.TfTypeError = TfTypeError
typeforce.TfPropertyTypeError = TfPropertyTypeError

module.exports = typeforce

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>typeforce",file:"node_modules\\typeforce\\index.js",}],
["F:\\metamask-extension\\node_modules\\typeforce\\native.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Ctypeforce%5Cnative.js
      return function (require, module, exports) {
var types = {
  Array: function (value) { return value !== null && value !== undefined && value.constructor === Array },
  Boolean: function (value) { return typeof value === 'boolean' },
  Function: function (value) { return typeof value === 'function' },
  Nil: function (value) { return value === undefined || value === null },
  Number: function (value) { return typeof value === 'number' },
  Object: function (value) { return typeof value === 'object' },
  String: function (value) { return typeof value === 'string' },
  '': function () { return true }
}

// TODO: deprecate
types.Null = types.Nil

for (var typeName in types) {
  types[typeName].toJSON = function (t) {
    return t
  }.bind(null, typeName)
}

module.exports = types

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>typeforce",file:"node_modules\\typeforce\\native.js",}],
["F:\\metamask-extension\\node_modules\\uint8arrays\\concat.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuint8arrays%5Cconcat.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 *
 * @param {Array<ArrayLike<number>>} arrays
 * @param {number} [length]
 */
function concat (arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0)
  }

  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrays) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = concat

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>uint8arrays",file:"node_modules\\uint8arrays\\concat.js",}],
["F:\\metamask-extension\\node_modules\\uint8arrays\\equals.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuint8arrays%5Cequals.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns true if the two passed Uint8Arrays have the same content
 *
 * @param {Uint8Array} a
 * @param {Uint8Array} b
 */
function equals (a, b) {
  if (a === b) {
    return true
  }

  if (a.byteLength !== b.byteLength) {
    return false
  }

  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false
    }
  }

  return true
}

module.exports = equals

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>uint8arrays",file:"node_modules\\uint8arrays\\equals.js",}],
["F:\\metamask-extension\\node_modules\\uint8arrays\\from-string.js", {"multibase":"F:\\metamask-extension\\node_modules\\multibase\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuint8arrays%5Cfrom-string.js
      return function (require, module, exports) {
'use strict'

const { encoding: getCodec } = require('multibase')
const utf8Encoder = new TextEncoder()

/**
 * @typedef {__import__('multibase/src/types').BaseName | 'utf8' | 'utf-8' | 'ascii' | undefined} SupportedEncodings
 */

/**
 * Interprets each character in a string as a byte and
 * returns a Uint8Array of those bytes.
 *
 * @param {string} string - The string to turn into an array
 */
function asciiStringToUint8Array (string) {
  const array = new Uint8Array(string.length)

  for (let i = 0; i < string.length; i++) {
    array[i] = string.charCodeAt(i)
  }

  return array
}

/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {string} string
 * @param {SupportedEncodings} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc
 * @returns {Uint8Array}
 */
function fromString (string, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Encoder.encode(string)
  }

  if (encoding === 'ascii') {
    return asciiStringToUint8Array(string)
  }

  return getCodec(encoding).decode(string)
}

module.exports = fromString

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>uint8arrays",file:"node_modules\\uint8arrays\\from-string.js",}],
["F:\\metamask-extension\\node_modules\\uint8arrays\\to-string.js", {"multibase":"F:\\metamask-extension\\node_modules\\multibase\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cuint8arrays%5Cto-string.js
      return function (require, module, exports) {
'use strict'

const { encoding: getCodec } = require('multibase')
const utf8Decoder = new TextDecoder('utf8')

/**
 * @typedef {__import__('multibase/src/types').BaseName | 'utf8' | 'utf-8' | 'ascii' | undefined} SupportedEncodings
 */

/**
 * Turns a Uint8Array of bytes into a string with each
 * character being the char code of the corresponding byte
 *
 * @param {Uint8Array} array - The array to turn into a string
 */
function uint8ArrayToAsciiString (array) {
  let string = ''

  for (let i = 0; i < array.length; i++) {
    string += String.fromCharCode(array[i])
  }
  return string
}

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {Uint8Array} array - The array to turn into a string
 * @param {SupportedEncodings} [encoding=utf8] - The encoding to use
 * @returns {string}
 */
function toString (array, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Decoder.decode(array)
  }

  if (encoding === 'ascii') {
    return uint8ArrayToAsciiString(array)
  }

  return getCodec(encoding).encode(array)
}

module.exports = toString

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>cids>uint8arrays",file:"node_modules\\uint8arrays\\to-string.js",}],
["F:\\metamask-extension\\node_modules\\validate-npm-package-name\\lib\\index.js", {"builtins":"F:\\metamask-extension\\node_modules\\builtins\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cvalidate-npm-package-name%5Clib%5Cindex.js
      return function (require, module, exports) {
'use strict'

var scopedPackagePattern = new RegExp('^(?:@([^/]+?)[/])?([^/]+?)$')
var builtins = require('builtins')
var blacklist = [
  'node_modules',
  'favicon.ico',
]

function validate (name) {
  var warnings = []
  var errors = []

  if (name === null) {
    errors.push('name cannot be null')
    return done(warnings, errors)
  }

  if (name === undefined) {
    errors.push('name cannot be undefined')
    return done(warnings, errors)
  }

  if (typeof name !== 'string') {
    errors.push('name must be a string')
    return done(warnings, errors)
  }

  if (!name.length) {
    errors.push('name length must be greater than zero')
  }

  if (name.match(/^\./)) {
    errors.push('name cannot start with a period')
  }

  if (name.match(/^_/)) {
    errors.push('name cannot start with an underscore')
  }

  if (name.trim() !== name) {
    errors.push('name cannot contain leading or trailing spaces')
  }

  // No funny business
  blacklist.forEach(function (blacklistedName) {
    if (name.toLowerCase() === blacklistedName) {
      errors.push(blacklistedName + ' is a blacklisted name')
    }
  })

  // Generate warnings for stuff that used to be allowed

  // core module names like http, events, util, etc
  builtins({ version: '*' }).forEach(function (builtin) {
    if (name.toLowerCase() === builtin) {
      warnings.push(builtin + ' is a core module name')
    }
  })

  if (name.length > 214) {
    warnings.push('name can no longer contain more than 214 characters')
  }

  // mIxeD CaSe nAMEs
  if (name.toLowerCase() !== name) {
    warnings.push('name can no longer contain capital letters')
  }

  if (/[~'!()*]/.test(name.split('/').slice(-1)[0])) {
    warnings.push('name can no longer contain special characters ("~\'!()*")')
  }

  if (encodeURIComponent(name) !== name) {
    // Maybe it's a scoped package name, like @user/package
    var nameMatch = name.match(scopedPackagePattern)
    if (nameMatch) {
      var user = nameMatch[1]
      var pkg = nameMatch[2]
      if (encodeURIComponent(user) === user && encodeURIComponent(pkg) === pkg) {
        return done(warnings, errors)
      }
    }

    errors.push('name can only contain URL-friendly characters')
  }

  return done(warnings, errors)
}

var done = function (warnings, errors) {
  var result = {
    validForNewPackages: errors.length === 0 && warnings.length === 0,
    validForOldPackages: errors.length === 0,
    warnings: warnings,
    errors: errors,
  }
  if (!result.warnings.length) {
    delete result.warnings
  }
  if (!result.errors.length) {
    delete result.errors
  }
  return result
}

module.exports = validate

      };
    };
  }
  }
}, {package:"@metamask/snaps-utils>validate-npm-package-name",file:"node_modules\\validate-npm-package-name\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\varuint-bitcoin\\index.js", {"safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cvaruint-bitcoin%5Cindex.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer

// Number.MAX_SAFE_INTEGER
var MAX_SAFE_INTEGER = 9007199254740991

function checkUInt53 (n) {
  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')
}

function encode (number, buffer, offset) {
  checkUInt53(number)

  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
  if (!offset) offset = 0

  // 8 bit
  if (number < 0xfd) {
    buffer.writeUInt8(number, offset)
    encode.bytes = 1

  // 16 bit
  } else if (number <= 0xffff) {
    buffer.writeUInt8(0xfd, offset)
    buffer.writeUInt16LE(number, offset + 1)
    encode.bytes = 3

  // 32 bit
  } else if (number <= 0xffffffff) {
    buffer.writeUInt8(0xfe, offset)
    buffer.writeUInt32LE(number, offset + 1)
    encode.bytes = 5

  // 64 bit
  } else {
    buffer.writeUInt8(0xff, offset)
    buffer.writeUInt32LE(number >>> 0, offset + 1)
    buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)
    encode.bytes = 9
  }

  return buffer
}

function decode (buffer, offset) {
  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')
  if (!offset) offset = 0

  var first = buffer.readUInt8(offset)

  // 8 bit
  if (first < 0xfd) {
    decode.bytes = 1
    return first

  // 16 bit
  } else if (first === 0xfd) {
    decode.bytes = 3
    return buffer.readUInt16LE(offset + 1)

  // 32 bit
  } else if (first === 0xfe) {
    decode.bytes = 5
    return buffer.readUInt32LE(offset + 1)

  // 64 bit
  } else {
    decode.bytes = 9
    var lo = buffer.readUInt32LE(offset + 1)
    var hi = buffer.readUInt32LE(offset + 5)
    var number = hi * 0x0100000000 + lo
    checkUInt53(number)

    return number
  }
}

function encodingLength (number) {
  checkUInt53(number)

  return (
    number < 0xfd ? 1
      : number <= 0xffff ? 3
        : number <= 0xffffffff ? 5
          : 9
  )
}

module.exports = { encode: encode, decode: decode, encodingLength: encodingLength }

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>varuint-bitcoin",file:"node_modules\\varuint-bitcoin\\index.js",}],
["F:\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js", {"util":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cweb-encoding%5Csrc%5Clib.js
      return function (require, module, exports) {
"use strict"

exports.TextEncoder =
  typeof TextEncoder !== "undefined" ? TextEncoder : require("util").TextEncoder

exports.TextDecoder =
  typeof TextDecoder !== "undefined" ? TextDecoder : require("util").TextDecoder

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>web-encoding",file:"node_modules\\web-encoding\\src\\lib.js",}],
["F:\\metamask-extension\\node_modules\\whatwg-fetch\\dist\\fetch.umd.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cwhatwg-fetch%5Cdist%5Cfetch.umd.js
      return function (require, module, exports) {
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.WHATWGFetch = {})));
}(this, (function (exports) { 'use strict';

  var global =
    (typeof globalThis !== 'undefined' && globalThis) ||
    (typeof self !== 'undefined' && self) ||
    (typeof global !== 'undefined' && global);

  var support = {
    searchParams: 'URLSearchParams' in global,
    iterable: 'Symbol' in global && 'iterator' in Symbol,
    blob:
      'FileReader' in global &&
      'Blob' in global &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in global,
    arrayBuffer: 'ArrayBuffer' in global
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
      throw new TypeError('Invalid character in header field name: "' + name + '"')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      /*
        fetch-mock wraps the Response object in an ES6 Proxy to
        provide useful test harness features such as flush. However, on
        ES5 browsers without fetch or Proxy support pollyfills must be used;
        the proxy-pollyfill is unable to proxy an attribute unless it exists
        on the object before the Proxy is created. This change ensures
        Response.bodyUsed exists on the instance, while maintaining the
        semantic of setting Request.bodyUsed in the constructor before
        _initBody is called.
      */
      this.bodyUsed = this.bodyUsed;
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          var isConsumed = consumed(this);
          if (isConsumed) {
            return isConsumed
          }
          if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
            return Promise.resolve(
              this._bodyArrayBuffer.buffer.slice(
                this._bodyArrayBuffer.byteOffset,
                this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
              )
            )
          } else {
            return Promise.resolve(this._bodyArrayBuffer)
          }
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    if (!(this instanceof Request)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
    }

    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);

    if (this.method === 'GET' || this.method === 'HEAD') {
      if (options.cache === 'no-store' || options.cache === 'no-cache') {
        // Search for a '_' parameter in the query string
        var reParamSearch = /([?&])_=[^&]*/;
        if (reParamSearch.test(this.url)) {
          // If it already exists then set the value with the current time
          this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
        } else {
          // Otherwise add a new '_' parameter to the end with the current time
          var reQueryString = /\?/;
          this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
        }
      }
    }
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
    // https://github.com/github/fetch/issues/748
    // https://github.com/zloirock/core-js/issues/751
    preProcessedHeaders
      .split('\r')
      .map(function(header) {
        return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
      })
      .forEach(function(line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!(this instanceof Response)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
    }
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = global.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        setTimeout(function() {
          resolve(new Response(body, options));
        }, 0);
      };

      xhr.onerror = function() {
        setTimeout(function() {
          reject(new TypeError('Network request failed'));
        }, 0);
      };

      xhr.ontimeout = function() {
        setTimeout(function() {
          reject(new TypeError('Network request failed'));
        }, 0);
      };

      xhr.onabort = function() {
        setTimeout(function() {
          reject(new exports.DOMException('Aborted', 'AbortError'));
        }, 0);
      };

      function fixUrl(url) {
        try {
          return url === '' && global.location.href ? global.location.href : url
        } catch (e) {
          return url
        }
      }

      xhr.open(request.method, fixUrl(request.url), true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr) {
        if (support.blob) {
          xhr.responseType = 'blob';
        } else if (
          support.arrayBuffer &&
          request.headers.get('Content-Type') &&
          request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
        ) {
          xhr.responseType = 'arraybuffer';
        }
      }

      if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
        Object.getOwnPropertyNames(init.headers).forEach(function(name) {
          xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
        });
      } else {
        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
      }

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!global.fetch) {
    global.fetch = fetch;
    global.Headers = Headers;
    global.Request = Request;
    global.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

      };
    };
  }
  }
}, {package:"@metamask/smart-transactions-controller>isomorphic-fetch>whatwg-fetch",file:"node_modules\\whatwg-fetch\\dist\\fetch.umd.js",}],
["F:\\metamask-extension\\node_modules\\wif\\index.js", {"bs58check":"F:\\metamask-extension\\node_modules\\bs58check\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5Cwif%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
var bs58check = require('bs58check')

function decodeRaw (buffer, version) {
  // check version only if defined
  if (version !== undefined && buffer[0] !== version) throw new Error('Invalid network version')

  // uncompressed
  if (buffer.length === 33) {
    return {
      version: buffer[0],
      privateKey: buffer.slice(1, 33),
      compressed: false
    }
  }

  // invalid length
  if (buffer.length !== 34) throw new Error('Invalid WIF length')

  // invalid compression flag
  if (buffer[33] !== 0x01) throw new Error('Invalid compression flag')

  return {
    version: buffer[0],
    privateKey: buffer.slice(1, 33),
    compressed: true
  }
}

function encodeRaw (version, privateKey, compressed) {
  var result = new Buffer(compressed ? 34 : 33)

  result.writeUInt8(version, 0)
  privateKey.copy(result, 1)

  if (compressed) {
    result[33] = 0x01
  }

  return result
}

function decode (string, version) {
  return decodeRaw(bs58check.decode(string), version)
}

function encode (version, privateKey, compressed) {
  if (typeof version === 'number') return bs58check.encode(encodeRaw(version, privateKey, compressed))

  return bs58check.encode(
    encodeRaw(
      version.version,
      version.privateKey,
      version.compressed
    )
  )
}

module.exports = {
  decode: decode,
  decodeRaw: decodeRaw,
  encode: encode,
  encodeRaw: encodeRaw
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>@trezor/connect-web>@trezor/connect>@trezor/utxo-lib>wif",file:"node_modules\\wif\\index.js",}],
["F:\\metamask-extension\\shared\\constants\\alarms.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Calarms.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.METAMETRICS_FINALIZE_EVENT_FRAGMENT_ALARM = exports.AUTO_LOCK_TIMEOUT_ALARM = void 0;
const AUTO_LOCK_TIMEOUT_ALARM = 'AUTO_LOCK_TIMEOUT_ALARM';
exports.AUTO_LOCK_TIMEOUT_ALARM = AUTO_LOCK_TIMEOUT_ALARM;
const METAMETRICS_FINALIZE_EVENT_FRAGMENT_ALARM = 'METAMETRICS_FINALIZE_EVENT_FRAGMENT_ALARM';
exports.METAMETRICS_FINALIZE_EVENT_FRAGMENT_ALARM = METAMETRICS_FINALIZE_EVENT_FRAGMENT_ALARM;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\alarms.js",}],
["F:\\metamask-extension\\shared\\constants\\smartTransactions.js", {"./time":"F:\\metamask-extension\\shared\\constants\\time.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5CsmartTransactions.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FALLBACK_SMART_TRANSACTIONS_REFRESH_TIME = exports.FALLBACK_SMART_TRANSACTIONS_MAX_FEE_MULTIPLIER = exports.FALLBACK_SMART_TRANSACTIONS_DEADLINE = void 0;
var _time = require("./time");
const FALLBACK_SMART_TRANSACTIONS_REFRESH_TIME = _time.SECOND * 10;
exports.FALLBACK_SMART_TRANSACTIONS_REFRESH_TIME = FALLBACK_SMART_TRANSACTIONS_REFRESH_TIME;
const FALLBACK_SMART_TRANSACTIONS_DEADLINE = 180;
exports.FALLBACK_SMART_TRANSACTIONS_DEADLINE = FALLBACK_SMART_TRANSACTIONS_DEADLINE;
const FALLBACK_SMART_TRANSACTIONS_MAX_FEE_MULTIPLIER = 2;
exports.FALLBACK_SMART_TRANSACTIONS_MAX_FEE_MULTIPLIER = FALLBACK_SMART_TRANSACTIONS_MAX_FEE_MULTIPLIER;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\smartTransactions.js",}],
["F:\\metamask-extension\\shared\\constants\\test-flags.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cshared%5Cconstants%5Ctest-flags.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ACTION_QUEUE_METRICS_E2E_TEST = void 0;
const ACTION_QUEUE_METRICS_E2E_TEST = 'action_queue_metrics_e2e_test';
exports.ACTION_QUEUE_METRICS_E2E_TEST = ACTION_QUEUE_METRICS_E2E_TEST;

      };
    };
  }
  }
}, {package:"$root$",file:"shared\\constants\\test-flags.js",}],
["F:\\metamask-extension\\app\\scripts\\background.js", {"../../shared/constants/app":"F:\\metamask-extension\\shared\\constants\\app.ts","../../shared/constants/metametrics":"F:\\metamask-extension\\shared\\constants\\metametrics.ts","../../shared/modules/browser-runtime.utils":"F:\\metamask-extension\\shared\\modules\\browser-runtime.utils.js","../../shared/modules/mv3.utils":"F:\\metamask-extension\\shared\\modules\\mv3.utils.js","../../shared/modules/object.utils":"F:\\metamask-extension\\shared\\modules\\object.utils.js","./first-time-state":"F:\\metamask-extension\\app\\scripts\\first-time-state.js","./lib/createStreamSink":"F:\\metamask-extension\\app\\scripts\\lib\\createStreamSink.js","./lib/ens-ipfs/setup":"F:\\metamask-extension\\app\\scripts\\lib\\ens-ipfs\\setup.js","./lib/get-first-preferred-lang-code":"F:\\metamask-extension\\app\\scripts\\lib\\get-first-preferred-lang-code.js","./lib/getObjStructure":"F:\\metamask-extension\\app\\scripts\\lib\\getObjStructure.js","./lib/local-store":"F:\\metamask-extension\\app\\scripts\\lib\\local-store.js","./lib/migrator":"F:\\metamask-extension\\app\\scripts\\lib\\migrator\\index.js","./lib/network-store":"F:\\metamask-extension\\app\\scripts\\lib\\network-store.js","./lib/notification-manager":"F:\\metamask-extension\\app\\scripts\\lib\\notification-manager.js","./lib/setupSentry":"F:\\metamask-extension\\app\\scripts\\lib\\setupSentry.js","./lib/util":"F:\\metamask-extension\\app\\scripts\\lib\\util.ts","./metamask-controller":"F:\\metamask-extension\\app\\scripts\\metamask-controller.js","./migrations":"F:\\metamask-extension\\app\\scripts\\migrations\\index.js","./platforms/extension":"F:\\metamask-extension\\app\\scripts\\platforms\\extension.js","@metamask/obs-store":"F:\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\index.js","debounce-stream":"F:\\metamask-extension\\node_modules\\debounce-stream\\index.js","end-of-stream":"F:\\metamask-extension\\node_modules\\end-of-stream\\index.js","eth-rpc-errors":"F:\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","extension-port-stream":"F:\\metamask-extension\\node_modules\\extension-port-stream\\dist\\index.js","loglevel":"F:\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js","pump":"F:\\metamask-extension\\node_modules\\pump\\index.js","webextension-polyfill":"F:\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cbackground.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadStateFromPersistence = loadStateFromPersistence;
exports.setupController = setupController;
exports.statePersistenceEvents = void 0;
var _events = _interopRequireDefault(require("events"));
var _endOfStream = _interopRequireDefault(require("end-of-stream"));
var _pump = _interopRequireDefault(require("pump"));
var _debounceStream = _interopRequireDefault(require("debounce-stream"));
var _loglevel = _interopRequireDefault(require("loglevel"));
var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));
var _obsStore = require("@metamask/obs-store");
var _extensionPortStream = _interopRequireDefault(require("extension-port-stream"));
var _ethRpcErrors = require("eth-rpc-errors");
var _app = require("../../shared/constants/app");
var _metametrics = require("../../shared/constants/metametrics");
var _browserRuntime = require("../../shared/modules/browser-runtime.utils");
var _mv = require("../../shared/modules/mv3.utils");
var _object = require("../../shared/modules/object.utils");
var _migrations = _interopRequireDefault(require("./migrations"));
var _migrator = _interopRequireDefault(require("./lib/migrator"));
var _extension = _interopRequireDefault(require("./platforms/extension"));
var _localStore = _interopRequireDefault(require("./lib/local-store"));
var _networkStore = _interopRequireDefault(require("./lib/network-store"));
var _setupSentry = require("./lib/setupSentry");
var _createStreamSink = _interopRequireDefault(require("./lib/createStreamSink"));
var _notificationManager = _interopRequireWildcard(require("./lib/notification-manager"));
var _metamaskController = _interopRequireWildcard(require("./metamask-controller"));
var _firstTimeState = _interopRequireDefault(require("./first-time-state"));
var _getFirstPreferredLangCode = _interopRequireDefault(require("./lib/get-first-preferred-lang-code"));
var _getObjStructure = _interopRequireDefault(require("./lib/getObjStructure"));
var _setup = _interopRequireDefault(require("./lib/ens-ipfs/setup"));
var _util = require("./lib/util");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/**
 * @file The entry point for the web extension singleton process.
 */

/* eslint-enable import/first */

/* eslint-disable import/order */
/* eslint-enable import/order */
const {
  sentry
} = global;
const firstTimeState = {
  ..._firstTimeState.default
};
const metamaskInternalProcessHash = {
  [_app.ENVIRONMENT_TYPE_POPUP]: true,
  [_app.ENVIRONMENT_TYPE_NOTIFICATION]: true,
  [_app.ENVIRONMENT_TYPE_FULLSCREEN]: true
};
const metamaskBlockedPorts = ['trezor-connect'];
_loglevel.default.setDefaultLevel(true ? 'debug' : 'info');
const platform = new _extension.default();
const notificationManager = new _notificationManager.default();
let popupIsOpen = false;
let notificationIsOpen = false;
let uiIsTriggering = false;
const openMetamaskTabsIDs = {};
const requestAccountTabIds = {};
let controller;

// state persistence
const inTest = false;
const localStore = inTest ? new _networkStore.default() : new _localStore.default();
let versionedData;
if (inTest || true) {
  global.stateHooks.metamaskGetState = localStore.get.bind(localStore);
}
const phishingPageUrl = new URL("https://metamask.github.io/phishing-warning/v2.1.0/");
const ONE_SECOND_IN_MILLISECONDS = 1_000;
// Timeout for initializing phishing warning page.
const PHISHING_WARNING_PAGE_TIMEOUT = ONE_SECOND_IN_MILLISECONDS;
const ACK_KEEP_ALIVE_MESSAGE = 'ACK_KEEP_ALIVE_MESSAGE';
const WORKER_KEEP_ALIVE_MESSAGE = 'WORKER_KEEP_ALIVE_MESSAGE';

// Event emitter for state persistence
const statePersistenceEvents = new _events.default();

/**
 * This deferred Promise is used to track whether initialization has finished.
 *
 * It is very important to ensure that `resolveInitialization` is *always*
 * called once initialization has completed, and that `rejectInitialization` is
 * called if initialization fails in an unrecoverable way.
 */
exports.statePersistenceEvents = statePersistenceEvents;
const {
  promise: isInitialized,
  resolve: resolveInitialization,
  reject: rejectInitialization
} = (0, _util.deferredPromise)();

/**
 * Sends a message to the dapp(s) content script to signal it can connect to MetaMask background as
 * the backend is not active. It is required to re-connect dapps after service worker re-activates.
 * For non-dapp pages, the message will be sent and ignored.
 */
const sendReadyMessageToTabs = async () => {
  const tabs = await _webextensionPolyfill.default.tabs.query({
    /**
     * Only query tabs that our extension can run in. To do this, we query for all URLs that our
     * extension can inject scripts in, which is by using the "<all_urls>" value and __without__
     * the "tabs" manifest permission. If we included the "tabs" permission, this would also fetch
     * URLs that we'd not be able to inject in, e.g. chrome://pages, chrome://extension, which
     * is not what we'd want.
     *
     * You might be wondering, how does the "url" param work without the "tabs" permission?
     *
     * @see {@link https://bugs.chromium.org/p/chromium/issues/detail?id=661311#c1}
     *  "If the extension has access to inject scripts into Tab, then we can return the url
     *   of Tab (because the extension could just inject a script to message the location.href)."
     */
    url: '<all_urls>',
    windowType: 'normal'
  }).then(result => {
    (0, _browserRuntime.checkForLastErrorAndLog)();
    return result;
  }).catch(() => {
    (0, _browserRuntime.checkForLastErrorAndLog)();
  });

  /** @todo we should only sendMessage to dapp tabs, not all tabs. */
  for (const tab of tabs) {
    _webextensionPolyfill.default.tabs.sendMessage(tab.id, {
      name: _app.EXTENSION_MESSAGES.READY
    }).then(() => {
      (0, _browserRuntime.checkForLastErrorAndLog)();
    }).catch(() => {
      // An error may happen if the contentscript is blocked from loading,
      // and thus there is no runtime.onMessage handler to listen to the message.
      (0, _browserRuntime.checkForLastErrorAndLog)();
    });
  }
};

// These are set after initialization
let connectRemote;
let connectExternal;
_webextensionPolyfill.default.runtime.onConnect.addListener(async (...args) => {
  // Queue up connection attempts here, waiting until after initialization
  await isInitialized;

  // This is set in `setupController`, which is called as part of initialization
  connectRemote(...args);
});
_webextensionPolyfill.default.runtime.onConnectExternal.addListener(async (...args) => {
  // Queue up connection attempts here, waiting until after initialization
  await isInitialized;

  // This is set in `setupController`, which is called as part of initialization
  connectExternal(...args);
});

/**
 * @typedef {__import__('../../shared/constants/transaction').TransactionMeta} TransactionMeta
 */

/**
 * The data emitted from the MetaMaskController.store EventEmitter, also used to initialize the MetaMaskController. Available in UI on React state as state.metamask.
 *
 * @typedef MetaMaskState
 * @property {boolean} isInitialized - Whether the first vault has been created.
 * @property {boolean} isUnlocked - Whether the vault is currently decrypted and accounts are available for selection.
 * @property {boolean} isAccountMenuOpen - Represents whether the main account selection UI is currently displayed.
 * @property {boolean} isNetworkMenuOpen - Represents whether the main network selection UI is currently displayed.
 * @property {object} identities - An object matching lower-case hex addresses to Identity objects with "address" and "name" (nickname) keys.
 * @property {object} unapprovedTxs - An object mapping transaction hashes to unapproved transactions.
 * @property {object} networkConfigurations - A list of network configurations, containing RPC provider details (eg chainId, rpcUrl, rpcPreferences).
 * @property {Array} addressBook - A list of previously sent to addresses.
 * @property {object} contractExchangeRates - Info about current token prices.
 * @property {Array} tokens - Tokens held by the current user, including their balances.
 * @property {object} send - TODO: Document
 * @property {boolean} useBlockie - Indicates preferred user identicon format. True for blockie, false for Jazzicon.
 * @property {object} featureFlags - An object for optional feature flags.
 * @property {boolean} welcomeScreen - True if welcome screen should be shown.
 * @property {string} currentLocale - A locale string matching the user's preferred display language.
 * @property {object} providerConfig - The current selected network provider.
 * @property {string} providerConfig.rpcUrl - The address for the RPC API, if using an RPC API.
 * @property {string} providerConfig.type - An identifier for the type of network selected, allows MetaMask to use custom provider strategies for known networks.
 * @property {string} networkId - The stringified number of the current network ID.
 * @property {string} networkStatus - Either "unknown", "available", "unavailable", or "blocked", depending on the status of the currently selected network.
 * @property {object} accounts - An object mapping lower-case hex addresses to objects with "balance" and "address" keys, both storing hex string values.
 * @property {hex} currentBlockGasLimit - The most recently seen block gas limit, in a lower case hex prefixed string.
 * @property {TransactionMeta[]} currentNetworkTxList - An array of transactions associated with the currently selected network.
 * @property {object} unapprovedMsgs - An object of messages pending approval, mapping a unique ID to the options.
 * @property {number} unapprovedMsgCount - The number of messages in unapprovedMsgs.
 * @property {object} unapprovedPersonalMsgs - An object of messages pending approval, mapping a unique ID to the options.
 * @property {number} unapprovedPersonalMsgCount - The number of messages in unapprovedPersonalMsgs.
 * @property {object} unapprovedEncryptionPublicKeyMsgs - An object of messages pending approval, mapping a unique ID to the options.
 * @property {number} unapprovedEncryptionPublicKeyMsgCount - The number of messages in EncryptionPublicKeyMsgs.
 * @property {object} unapprovedDecryptMsgs - An object of messages pending approval, mapping a unique ID to the options.
 * @property {number} unapprovedDecryptMsgCount - The number of messages in unapprovedDecryptMsgs.
 * @property {object} unapprovedTypedMsgs - An object of messages pending approval, mapping a unique ID to the options.
 * @property {number} unapprovedTypedMsgCount - The number of messages in unapprovedTypedMsgs.
 * @property {number} pendingApprovalCount - The number of pending request in the approval controller.
 * @property {string[]} keyringTypes - An array of unique keyring identifying strings, representing available strategies for creating accounts.
 * @property {Keyring[]} keyrings - An array of keyring descriptions, summarizing the accounts that are available for use, and what keyrings they belong to.
 * @property {string} selectedAddress - A lower case hex string of the currently selected address.
 * @property {string} currentCurrency - A string identifying the user's preferred display currency, for use in showing conversion rates.
 * @property {number} conversionRate - A number representing the current exchange rate from the user's preferred currency to Ether.
 * @property {number} conversionDate - A unix epoch date (ms) for the time the current conversion rate was last retrieved.
 * @property {boolean} forgottenPassword - Returns true if the user has initiated the password recovery screen, is recovering from seed phrase.
 */

/**
 * @typedef VersionedData
 * @property {MetaMaskState} data - The data emitted from MetaMask controller, or used to initialize it.
 * @property {number} version - The latest migration version that has been run.
 */

/**
 * Initializes the MetaMask controller, and sets up all platform configuration.
 *
 * @returns {Promise} Setup complete.
 */
async function initialize() {
  try {
    const initState = await loadStateFromPersistence();
    const initLangCode = await (0, _getFirstPreferredLangCode.default)();
    let isFirstMetaMaskControllerSetup;
    if (_mv.isManifestV3) {
      const sessionData = await _webextensionPolyfill.default.storage.session.get(['isFirstMetaMaskControllerSetup']);
      isFirstMetaMaskControllerSetup = (sessionData === null || sessionData === void 0 ? void 0 : sessionData.isFirstMetaMaskControllerSetup) === undefined;
      await _webextensionPolyfill.default.storage.session.set({
        isFirstMetaMaskControllerSetup
      });
    }
    setupController(initState, initLangCode, {}, isFirstMetaMaskControllerSetup);
    if (!_mv.isManifestV3) {
      await loadPhishingWarningPage();
    }
    await sendReadyMessageToTabs();
    _loglevel.default.info('MetaMask initialization complete.');
    resolveInitialization();
  } catch (error) {
    rejectInitialization(error);
  }
}

/**
 * An error thrown if the phishing warning page takes too long to load.
 */
class PhishingWarningPageTimeoutError extends Error {
  constructor() {
    super('Timeout failed');
  }
}

/**
 * Load the phishing warning page temporarily to ensure the service
 * worker has been registered, so that the warning page works offline.
 */
async function loadPhishingWarningPage() {
  let iframe;
  try {
    const extensionStartupPhishingPageUrl = new URL("https://metamask.github.io/phishing-warning/v2.1.0/");
    // The `extensionStartup` hash signals to the phishing warning page that it should not bother
    // setting up streams for user interaction. Otherwise this page load would cause a console
    // error.
    extensionStartupPhishingPageUrl.hash = '#extensionStartup';
    iframe = window.document.createElement('iframe');
    iframe.setAttribute('src', extensionStartupPhishingPageUrl.href);
    iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin');

    // Create "deferred Promise" to allow passing resolve/reject to event handlers
    let deferredResolve;
    let deferredReject;
    const loadComplete = new Promise((resolve, reject) => {
      deferredResolve = resolve;
      deferredReject = reject;
    });

    // The load event is emitted once loading has completed, even if the loading failed.
    // If loading failed we can't do anything about it, so we don't need to check.
    iframe.addEventListener('load', deferredResolve);

    // This step initiates the page loading.
    window.document.body.appendChild(iframe);

    // This timeout ensures that this iframe gets cleaned up in a reasonable
    // timeframe, and ensures that the "initialization complete" message
    // doesn't get delayed too long.
    setTimeout(() => deferredReject(new PhishingWarningPageTimeoutError()), PHISHING_WARNING_PAGE_TIMEOUT);
    await loadComplete;
  } catch (error) {
    if (error instanceof PhishingWarningPageTimeoutError) {
      console.warn('Phishing warning page timeout; page not guaraneteed to work offline.');
    } else {
      console.error('Failed to initialize phishing warning page', error);
    }
  } finally {
    if (iframe) {
      iframe.remove();
    }
  }
}

//
// State and Persistence
//

/**
 * Loads any stored data, prioritizing the latest storage strategy.
 * Migrates that data schema in case it was last loaded on an older version.
 *
 * @returns {Promise<MetaMaskState>} Last data emitted from previous instance of MetaMask.
 */
async function loadStateFromPersistence() {
  // migrations
  const migrator = new _migrator.default({
    migrations: _migrations.default
  });
  migrator.on('error', console.warn);

  // read from disk
  // first from preferred, async API:
  versionedData = (await localStore.get()) || migrator.generateInitialState(firstTimeState);

  // check if somehow state is empty
  // this should never happen but new error reporting suggests that it has
  // for a small number of users
  // https://github.com/metamask/metamask-extension/issues/3919
  if (versionedData && !versionedData.data) {
    // unable to recover, clear state
    versionedData = migrator.generateInitialState(firstTimeState);
    sentry.captureMessage('MetaMask - Empty vault found - unable to recover');
  }

  // report migration errors to sentry
  migrator.on('error', err => {
    // get vault structure without secrets
    const vaultStructure = (0, _getObjStructure.default)(versionedData);
    sentry.captureException(err, {
      // "extra" key is required by Sentry
      extra: {
        vaultStructure
      }
    });
  });

  // migrate data
  versionedData = await migrator.migrateData(versionedData);
  if (!versionedData) {
    throw new Error('MetaMask - migrator returned undefined');
  }
  // this initializes the meta/version data as a class variable to be used for future writes
  localStore.setMetadata(versionedData.meta);

  // write to disk
  localStore.set(versionedData.data);

  // return just the data
  return versionedData.data;
}

/**
 * Initializes the MetaMask Controller with any initial state and default language.
 * Configures platform-specific error reporting strategy.
 * Streams emitted state updates to platform-specific storage strategy.
 * Creates platform listeners for new Dapps/Contexts, and sets up their data connections to the controller.
 *
 * @param {object} initState - The initial state to start the controller with, matches the state that is emitted from the controller.
 * @param {string} initLangCode - The region code for the language preferred by the current user.
 * @param {object} overrides - object with callbacks that are allowed to override the setup controller logic (usefull for desktop app)
 * @param isFirstMetaMaskControllerSetup
 */
function setupController(initState, initLangCode, overrides, isFirstMetaMaskControllerSetup) {
  //
  // MetaMask Controller
  //

  controller = new _metamaskController.default({
    infuraProjectId: "7e2c49dd161e4ddebc355d9fecfb9249",
    // User confirmation callbacks:
    showUserConfirmation: triggerUi,
    // initial state
    initState,
    // initial locale code
    initLangCode,
    // platform specific api
    platform,
    notificationManager,
    browser: _webextensionPolyfill.default,
    getRequestAccountTabIds: () => {
      return requestAccountTabIds;
    },
    getOpenMetamaskTabsIds: () => {
      return openMetamaskTabsIDs;
    },
    localStore,
    overrides,
    isFirstMetaMaskControllerSetup
  });
  (0, _setup.default)({
    getCurrentChainId: () => controller.networkController.state.providerConfig.chainId,
    getIpfsGateway: controller.preferencesController.getIpfsGateway.bind(controller.preferencesController),
    provider: controller.provider
  });

  // setup state persistence
  (0, _pump.default)((0, _obsStore.storeAsStream)(controller.store), (0, _debounceStream.default)(1000), (0, _createStreamSink.default)(async state => {
    await localStore.set(state);
    statePersistenceEvents.emit('state-persisted', state);
  }), error => {
    _loglevel.default.error('MetaMask - Persistence pipeline failed', error);
  });
  setupSentryGetStateGlobal(controller);
  const isClientOpenStatus = () => {
    return popupIsOpen || Boolean(Object.keys(openMetamaskTabsIDs).length) || notificationIsOpen;
  };
  const onCloseEnvironmentInstances = (isClientOpen, environmentType) => {
    // if all instances of metamask are closed we call a method on the controller to stop gasFeeController polling
    if (isClientOpen === false) {
      controller.onClientClosed();
      // otherwise we want to only remove the polling tokens for the environment type that has closed
    } else {
      // in the case of fullscreen environment a user might have multiple tabs open so we don't want to disconnect all of
      // its corresponding polling tokens unless all tabs are closed.
      if (environmentType === _app.ENVIRONMENT_TYPE_FULLSCREEN && Boolean(Object.keys(openMetamaskTabsIDs).length)) {
        return;
      }
      controller.onEnvironmentTypeClosed(environmentType);
    }
  };

  /**
   * A runtime.Port object, as provided by the browser:
   *
   * @see https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port
   * @typedef Port
   * @type Object
   */

  /**
   * Connects a Port to the MetaMask controller via a multiplexed duplex stream.
   * This method identifies trusted (MetaMask) interfaces, and connects them differently from untrusted (web pages).
   *
   * @param {Port} remotePort - The port provided by a new context.
   */
  connectRemote = async remotePort => {
    var _remotePort$sender;
    const processName = remotePort.name;
    if (metamaskBlockedPorts.includes(remotePort.name)) {
      return;
    }
    let isMetaMaskInternalProcess = false;
    const sourcePlatform = (0, _util.getPlatform)();
    const senderUrl = (_remotePort$sender = remotePort.sender) !== null && _remotePort$sender !== void 0 && _remotePort$sender.url ? new URL(remotePort.sender.url) : null;
    if (sourcePlatform === _app.PLATFORM_FIREFOX) {
      isMetaMaskInternalProcess = metamaskInternalProcessHash[processName];
    } else {
      isMetaMaskInternalProcess = (senderUrl === null || senderUrl === void 0 ? void 0 : senderUrl.origin) === `chrome-extension://${_webextensionPolyfill.default.runtime.id}`;
    }
    if (isMetaMaskInternalProcess) {
      var _overrides$getPortStr;
      const portStream = (overrides === null || overrides === void 0 ? void 0 : (_overrides$getPortStr = overrides.getPortStream) === null || _overrides$getPortStr === void 0 ? void 0 : _overrides$getPortStr.call(overrides, remotePort)) || new _extensionPortStream.default(remotePort);
      // communication with popup
      controller.isClientOpen = true;
      controller.setupTrustedCommunication(portStream, remotePort.sender);
      if (_mv.isManifestV3) {
        // If we get a WORKER_KEEP_ALIVE message, we respond with an ACK
        remotePort.onMessage.addListener(message => {
          if (message.name === WORKER_KEEP_ALIVE_MESSAGE) {
            // To test un-comment this line and wait for 1 minute. An error should be shown on MetaMask UI.
            remotePort.postMessage({
              name: ACK_KEEP_ALIVE_MESSAGE
            });
            controller.appStateController.setServiceWorkerLastActiveTime(Date.now());
          }
        });
      }
      if (processName === _app.ENVIRONMENT_TYPE_POPUP) {
        popupIsOpen = true;
        (0, _endOfStream.default)(portStream, () => {
          popupIsOpen = false;
          const isClientOpen = isClientOpenStatus();
          controller.isClientOpen = isClientOpen;
          onCloseEnvironmentInstances(isClientOpen, _app.ENVIRONMENT_TYPE_POPUP);
        });
      }
      if (processName === _app.ENVIRONMENT_TYPE_NOTIFICATION) {
        notificationIsOpen = true;
        (0, _endOfStream.default)(portStream, () => {
          notificationIsOpen = false;
          const isClientOpen = isClientOpenStatus();
          controller.isClientOpen = isClientOpen;
          onCloseEnvironmentInstances(isClientOpen, _app.ENVIRONMENT_TYPE_NOTIFICATION);
        });
      }
      if (processName === _app.ENVIRONMENT_TYPE_FULLSCREEN) {
        const tabId = remotePort.sender.tab.id;
        openMetamaskTabsIDs[tabId] = true;
        (0, _endOfStream.default)(portStream, () => {
          delete openMetamaskTabsIDs[tabId];
          const isClientOpen = isClientOpenStatus();
          controller.isClientOpen = isClientOpen;
          onCloseEnvironmentInstances(isClientOpen, _app.ENVIRONMENT_TYPE_FULLSCREEN);
        });
      }
    } else if (senderUrl && senderUrl.origin === phishingPageUrl.origin && senderUrl.pathname === phishingPageUrl.pathname) {
      var _overrides$getPortStr2;
      const portStream = (overrides === null || overrides === void 0 ? void 0 : (_overrides$getPortStr2 = overrides.getPortStream) === null || _overrides$getPortStr2 === void 0 ? void 0 : _overrides$getPortStr2.call(overrides, remotePort)) || new _extensionPortStream.default(remotePort);
      controller.setupPhishingCommunication({
        connectionStream: portStream
      });
    } else {
      if (remotePort.sender && remotePort.sender.tab && remotePort.sender.url) {
        const tabId = remotePort.sender.tab.id;
        const url = new URL(remotePort.sender.url);
        const {
          origin
        } = url;
        remotePort.onMessage.addListener(msg => {
          if (msg.data && msg.data.method === 'eth_requestAccounts') {
            requestAccountTabIds[origin] = tabId;
          }
        });
      }
      connectExternal(remotePort);
    }
  };

  // communication with page or other extension
  connectExternal = remotePort => {
    var _overrides$getPortStr3;
    const portStream = (overrides === null || overrides === void 0 ? void 0 : (_overrides$getPortStr3 = overrides.getPortStream) === null || _overrides$getPortStr3 === void 0 ? void 0 : _overrides$getPortStr3.call(overrides, remotePort)) || new _extensionPortStream.default(remotePort);
    controller.setupUntrustedCommunication({
      connectionStream: portStream,
      sender: remotePort.sender
    });
  };
  if (overrides !== null && overrides !== void 0 && overrides.registerConnectListeners) {
    overrides.registerConnectListeners(connectRemote, connectExternal);
  }

  //
  // User Interface setup
  //
  updateBadge();
  controller.txController.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.decryptMessageController.hub.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.encryptionPublicKeyController.hub.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.signatureController.hub.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.appStateController.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
  controller.controllerMessenger.subscribe(_metamaskController.METAMASK_CONTROLLER_EVENTS.APPROVAL_STATE_CHANGE, updateBadge);
  controller.txController.initApprovals();

  /**
   * Updates the Web Extension's "badge" number, on the little fox in the toolbar.
   * The number reflects the current number of pending transactions or message signatures needing user approval.
   */
  function updateBadge() {
    let label = '';
    const count = getUnapprovedTransactionCount();
    if (count) {
      label = String(count);
    }
    // browserAction has been replaced by action in MV3
    if (_mv.isManifestV3) {
      _webextensionPolyfill.default.action.setBadgeText({
        text: label
      });
      _webextensionPolyfill.default.action.setBadgeBackgroundColor({
        color: '#037DD6'
      });
    } else {
      _webextensionPolyfill.default.browserAction.setBadgeText({
        text: label
      });
      _webextensionPolyfill.default.browserAction.setBadgeBackgroundColor({
        color: '#037DD6'
      });
    }
  }
  function getUnapprovedTransactionCount() {
    const pendingApprovalCount = controller.approvalController.getTotalApprovalCount();
    const waitingForUnlockCount = controller.appStateController.waitingForUnlock.length;
    return pendingApprovalCount + waitingForUnlockCount;
  }
  notificationManager.on(_notificationManager.NOTIFICATION_MANAGER_EVENTS.POPUP_CLOSED, ({
    automaticallyClosed
  }) => {
    if (!automaticallyClosed) {
      rejectUnapprovedNotifications();
    } else if (getUnapprovedTransactionCount() > 0) {
      triggerUi();
    }
  });
  function rejectUnapprovedNotifications() {
    Object.keys(controller.txController.txStateManager.getUnapprovedTxList()).forEach(txId => controller.txController.txStateManager.setTxStatusRejected(txId));
    controller.signatureController.rejectUnapproved(_metametrics.REJECT_NOTIFICATION_CLOSE_SIG);
    controller.decryptMessageController.rejectUnapproved(_metametrics.REJECT_NOTIFICATION_CLOSE);
    controller.encryptionPublicKeyController.rejectUnapproved(_metametrics.REJECT_NOTIFICATION_CLOSE);

    // Finally, resolve snap dialog approvals on Flask and reject all the others managed by the ApprovalController.
    Object.values(controller.approvalController.state.pendingApprovals).forEach(({
      id,
      type
    }) => {
      switch (type) {
        default:
          controller.approvalController.reject(id, _ethRpcErrors.ethErrors.provider.userRejectedRequest());
          break;
      }
    });
    updateBadge();
  }
}

//
// Etc...
//

/**
 * Opens the browser popup for user confirmation
 */
async function triggerUi() {
  const tabs = await platform.getActiveTabs();
  const currentlyActiveMetamaskTab = Boolean(tabs.find(tab => openMetamaskTabsIDs[tab.id]));
  // Vivaldi is not closing port connection on popup close, so popupIsOpen does not work correctly
  // To be reviewed in the future if this behaviour is fixed - also the way we determine isVivaldi variable might change at some point
  const isVivaldi = tabs.length > 0 && tabs[0].extData && tabs[0].extData.indexOf('vivaldi_tab') > -1;
  if (!uiIsTriggering && (isVivaldi || !popupIsOpen) && !currentlyActiveMetamaskTab) {
    uiIsTriggering = true;
    try {
      const currentPopupId = controller.appStateController.getCurrentPopupId();
      await notificationManager.showPopup(newPopupId => controller.appStateController.setCurrentPopupId(newPopupId), currentPopupId);
    } finally {
      uiIsTriggering = false;
    }
  }
}

// It adds the "App Installed" event into a queue of events, which will be tracked only after a user opts into metrics.
const addAppInstalledEvent = () => {
  if (controller) {
    controller.metaMetricsController.updateTraits({
      [_metametrics.MetaMetricsUserTrait.InstallDateExt]: new Date().toISOString().split('T')[0] // yyyy-mm-dd
    });

    controller.metaMetricsController.addEventBeforeMetricsOptIn({
      category: _metametrics.MetaMetricsEventCategory.App,
      event: _metametrics.MetaMetricsEventName.AppInstalled,
      properties: {}
    });
    return;
  }
  setTimeout(() => {
    // If the controller is not set yet, we wait and try to add the "App Installed" event again.
    addAppInstalledEvent();
  }, 1000);
};

// On first install, open a new tab with MetaMask
_webextensionPolyfill.default.runtime.onInstalled.addListener(({
  reason
}) => {
  if (reason === 'install' && !(true || false)) {
    addAppInstalledEvent();
    platform.openExtensionInBrowser();
  }
});
function setupSentryGetStateGlobal(store) {
  global.stateHooks.getSentryState = function () {
    const fullState = store.getState();
    const debugState = (0, _object.maskObject)({
      metamask: fullState
    }, _setupSentry.SENTRY_STATE);
    return {
      browser: window.navigator.userAgent,
      store: debugState,
      version: platform.getVersion()
    };
  };
}
function initBackground() {
  initialize().catch(_loglevel.default.error);
}
if (!false) {
  initBackground();
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\background.js",}]],["F:\\metamask-extension\\app\\scripts\\background.js"],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL21pbmltYWwuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdmVyaWZpZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JhcHBlcnMuanMiLCJub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyaXRlcl9idWZmZXIuanMiLCJub2RlX21vZHVsZXMvcHVzaGRhdGEtYml0Y29pbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZW1vdmUtdHJhaWxpbmctc2xhc2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmZkYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYWRkcmVzcy1jb2RlYy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1hZGRyZXNzLWNvZGVjL2Rpc3QvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWFkZHJlc3MtY29kZWMvZGlzdC94cnAtY29kZWMuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvY29yZXR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC9lbnVtcy9kZWZpbml0aW9ucy5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC9lbnVtcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvaGFzaC1wcmVmaXhlcy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvaGFzaGVzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvbGVkZ2VyLWhhc2hlcy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvcXVhbGl0eS5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3Qvc2VyZGVzL2JpbmFyeS1wYXJzZXIuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3NlcmRlcy9iaW5hcnktc2VyaWFsaXplci5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3Qvc2hhbWFwLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy9hY2NvdW50LWlkLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy9hbW91bnQuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2Jsb2IuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2N1cnJlbmN5LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy9oYXNoLTEyOC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvaGFzaC0xNjAuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL2hhc2gtMjU2LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy9oYXNoLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvcGF0aC1zZXQuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3NlcmlhbGl6ZWQtdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvc3QtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWJpbmFyeS1jb2RlYy9kaXN0L3R5cGVzL3N0LW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvdWludC0xNi5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvdWludC0zMi5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvdWludC02NC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtYmluYXJ5LWNvZGVjL2Rpc3QvdHlwZXMvdWludC04LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy91aW50LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvZGlzdC90eXBlcy92ZWN0b3ItMjU2LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1iaW5hcnktY29kZWMvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUta2V5cGFpcnMvZGlzdC9TaGE1MTIuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWtleXBhaXJzL2Rpc3Qvc2VjcDI1NmsxLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9kaXN0L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1rZXlwYWlycy9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWItdHJhbnNhY3Rpb25wYXJzZXIvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi10cmFuc2FjdGlvbnBhcnNlci9zcmMvYmFsYW5jZWNoYW5nZXMuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi10cmFuc2FjdGlvbnBhcnNlci9zcmMvY2hhbm5lbGNoYW5nZXMuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi10cmFuc2FjdGlvbnBhcnNlci9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi10cmFuc2FjdGlvbnBhcnNlci9zcmMvb3JkZXJib29rY2hhbmdlcy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliLXRyYW5zYWN0aW9ucGFyc2VyL3NyYy9xdWFsaXR5LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWItdHJhbnNhY3Rpb25wYXJzZXIvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vYXBpLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vYnJvYWRjYXN0LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL2JhY2tvZmYuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vYnJvd3Nlci1oYWNrcy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9jb25uZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vaGFzaGVzL2hhc2gtcHJlZml4LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL2hhc2hlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9oYXNoZXMvbGVkZ2Vyc3BhY2VzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL2hhc2hlcy9zaGE1MTJIYWxmLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL2hhc2hlcy9zaGFtYXAuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vcmFuZ2VzZXQuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hLXZhbGlkYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L2FwaS1vcHRpb25zLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9jb21iaW5lLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9jb21wdXRlLWxlZGdlci1oYXNoLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9nZW5lcmF0ZS1hZGRyZXNzLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9nZXQtYWNjb3VudC1pbmZvLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9nZXQtYWNjb3VudC1vYmplY3RzLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9nZXQtYmFsYW5jZS1zaGVldC5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvaW5wdXQvZ2V0LWJhbGFuY2VzLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9nZXQtbGVkZ2VyLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9nZXQtb3JkZXJib29rLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9nZXQtb3JkZXJzLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9nZXQtcGF0aHMuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L2dldC1wYXltZW50LWNoYW5uZWwuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L2dldC1zZXR0aW5ncy5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvaW5wdXQvZ2V0LXRyYW5zYWN0aW9uLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9nZXQtdHJhbnNhY3Rpb25zLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9nZXQtdHJ1c3RsaW5lcy5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS1jaGVjay1jYW5jZWwuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtY2hlY2stY2FzaC5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS1jaGVjay1jcmVhdGUuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtZXNjcm93LWNhbmNlbGxhdGlvbi5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS1lc2Nyb3ctY3JlYXRpb24uanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtZXNjcm93LWV4ZWN1dGlvbi5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS1vcmRlci1jYW5jZWxsYXRpb24uanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtb3JkZXIuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtcGF5bWVudC1jaGFubmVsLWNsYWltLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9wcmVwYXJlLXBheW1lbnQtY2hhbm5lbC1jcmVhdGUuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtcGF5bWVudC1jaGFubmVsLWZ1bmQuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtcGF5bWVudC5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS1zZXR0aW5ncy5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS10aWNrZXQtY3JlYXRlLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9pbnB1dC9wcmVwYXJlLXRydXN0bGluZS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvaW5wdXQvc2lnbi1wYXltZW50LWNoYW5uZWwtY2xhaW0uanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L3NpZ24uanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL2lucHV0L3N1Ym1pdC5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvaW5wdXQvdmVyaWZ5LXBheW1lbnQtY2hhbm5lbC1jbGFpbS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9hZGRyZXNzLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL2FkanVzdG1lbnQuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvYW1vdW50Lmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL2Ftb3VudGJhc2UuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvYmFsYW5jZS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9ibG9iLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL2NsYXNzaWMtYWRkcmVzcy5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9jdXJyZW5jeS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9kZXN0aW5hdGlvbi1hZGRyZXNzLXRhZy5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9kZXN0aW5hdGlvbi1hZGp1c3RtZW50Lmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL2Rlc3RpbmF0aW9uLWV4YWN0LWFkanVzdG1lbnQuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvaGFzaDEyOC5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9oYXNoMjU2Lmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL2luc3RydWN0aW9ucy5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9pc3N1ZS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9sYXgtYW1vdW50Lmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL2xheC1sYXgtYW1vdW50Lmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL2xlZGdlci12ZXJzaW9uLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL21heC1hZGp1c3RtZW50Lmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL21lbW8uanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvbWVtb3MuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvbWluLWFkanVzdG1lbnQuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvb3JkZXJib29rLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL3ByaXZhdGUta2V5Lmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL3B1YmxpYy1rZXkuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvcXVhbGl0eS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9zZXF1ZW5jZS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9zZXR0aW5ncy1wbHVzLW1lbW9zLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL3NpZ25hdHVyZS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy9zaWduZWQtdmFsdWUuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvc291cmNlLWFkanVzdG1lbnQuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvc291cmNlLWV4YWN0LWFkanVzdG1lbnQuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvdGFnLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL3RpY2tldC1zZXF1ZW5jZS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy90cmFuc2FjdGlvbi1oYXNoLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vYmplY3RzL3RyYW5zYWN0aW9uLXR5cGUuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvdHgtanNvbi5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb2JqZWN0cy91aW50MzIuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMvdmFsdWUuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL29iamVjdHMveC1hZGRyZXNzLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vdXRwdXQvZ2V0LWFjY291bnQtaW5mby5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb3V0cHV0L2dldC1hY2NvdW50LW9iamVjdHMuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9nZXQtYmFsYW5jZS1zaGVldC5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb3V0cHV0L2dldC1iYWxhbmNlcy5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb3V0cHV0L2dldC1sZWRnZXIuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9nZXQtb3JkZXJib29rLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vdXRwdXQvZ2V0LW9yZGVycy5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb3V0cHV0L2dldC1wYXRocy5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb3V0cHV0L2dldC1wYXltZW50LWNoYW5uZWwuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9nZXQtc2VydmVyLWluZm8uanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9nZXQtc2V0dGluZ3MuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9nZXQtdHJhbnNhY3Rpb24uanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9nZXQtdHJhbnNhY3Rpb25zLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vdXRwdXQvZ2V0LXRydXN0bGluZXMuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9sZWRnZXItZXZlbnQuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9vcmRlci1jaGFuZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9vcmRlcmJvb2stb3JkZXJzLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9vdXRwdXQvb3V0Y29tZS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb3V0cHV0L3ByZXBhcmUuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9zaWduLXBheW1lbnQtY2hhbm5lbC1jbGFpbS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvb3V0cHV0L3NpZ24uanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC9zdWJtaXQuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL291dHB1dC92ZXJpZnktcGF5bWVudC1jaGFubmVsLWNsYWltLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9hY2NvdW50LWRlbGV0ZS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvY2hlY2stY2FuY2VsLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9jaGVjay1jYXNoLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9jaGVjay1jcmVhdGUuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL3NwZWNpZmljYXRpb25zL2RlcG9zaXQtcHJlYXV0aC5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvZXNjcm93LWNhbmNlbGxhdGlvbi5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvZXNjcm93LWNyZWF0aW9uLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9lc2Nyb3ctZXhlY3V0aW9uLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9nZXQtcGF5bWVudC5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvb3JkZXItY2FuY2VsbGF0aW9uLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9vcmRlci5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvcGF5bWVudC1jaGFubmVsLWNsYWltLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9wYXltZW50LWNoYW5uZWwtY3JlYXRlLmpzb24iLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9wYXltZW50LWNoYW5uZWwtZnVuZC5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvcGF5bWVudC5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvc2V0dGluZ3MuanNvbiIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi9zY2hlbWFzL3NwZWNpZmljYXRpb25zL3RydXN0bGluZS5qc29uIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vY29tbW9uL3NlcnZlcmluZm8uanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9jb21tb24vdHhmbGFncy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi90eXBlcy9vYmplY3RzL2xlZGdlci5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi92YWxpZGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2NvbW1vbi93c3dyYXBwZXIuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9hY2NvdW50aW5mby5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9hY2NvdW50b2JqZWN0cy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9iYWxhbmNlLXNoZWV0LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL2JhbGFuY2VzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL2xlZGdlci5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9vcmRlcmJvb2suanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvb3JkZXJzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL2FjY291bnQtZGVsZXRlLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL2FjY291bnQtb3JkZXIuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvYWNjb3VudC10cnVzdGxpbmUuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvYW1lbmRtZW50LmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL2Ftb3VudC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9wYXJzZS9jYW5jZWxsYXRpb24uanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvY2hlY2stY2FuY2VsLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL2NoZWNrLWNhc2guanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvY2hlY2stY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL2RlcG9zaXQtcHJlYXV0aC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9wYXJzZS9lc2Nyb3ctY2FuY2VsbGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL2VzY3Jvdy1jcmVhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9wYXJzZS9lc2Nyb3ctZXhlY3V0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL2ZlZS11cGRhdGUuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvZmllbGRzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL2xlZGdlci5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9wYXJzZS9vcmRlci5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9wYXJzZS9vcmRlcmJvb2stb3JkZXIuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvcGF0aGZpbmQuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvcGF5bWVudC1jaGFubmVsLWNsYWltLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL3BheW1lbnQtY2hhbm5lbC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvcGF5bWVudC1jaGFubmVsLWZ1bmQuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvcGF5bWVudC1jaGFubmVsLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3BhcnNlL3BheW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2Uvc2V0dGluZ3MuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvdGlja2V0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9wYXJzZS90cmFuc2FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci9wYXJzZS90cnVzdGxpbmUuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGFyc2UvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGF0aGZpbmQuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9sZWRnZXIvcGF5bWVudC1jaGFubmVsLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3NldHRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3RyYW5zYWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3RyYW5zYWN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL2xlZGdlci90cnVzdGxpbmVzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vbGVkZ2VyL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vb2ZmbGluZS9kZXJpdmUuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9vZmZsaW5lL2dlbmVyYXRlLWFkZHJlc3MuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9vZmZsaW5lL2xlZGdlcmhhc2guanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS9vZmZsaW5lL3NpZ24tcGF5bWVudC1jaGFubmVsLWNsYWltLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vb2ZmbGluZS91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL29mZmxpbmUvdmVyaWZ5LXBheW1lbnQtY2hhbm5lbC1jbGFpbS5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL3NlcnZlci9zZXJ2ZXIuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi9jaGVjay1jYW5jZWwuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi9jaGVjay1jYXNoLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vdHJhbnNhY3Rpb24vY2hlY2stY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vdHJhbnNhY3Rpb24vY29tYmluZS5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL3RyYW5zYWN0aW9uL2VzY3Jvdy1jYW5jZWxsYXRpb24uanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi9lc2Nyb3ctY3JlYXRpb24uanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi9lc2Nyb3ctZXhlY3V0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vdHJhbnNhY3Rpb24vb3JkZXIuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi9vcmRlcmNhbmNlbGxhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL3RyYW5zYWN0aW9uL3BheW1lbnQtY2hhbm5lbC1jbGFpbS5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL3RyYW5zYWN0aW9uL3BheW1lbnQtY2hhbm5lbC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi9wYXltZW50LWNoYW5uZWwtZnVuZC5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL3RyYW5zYWN0aW9uL3BheW1lbnQuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi9zZXR0aW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL3RyYW5zYWN0aW9uL3NpZ24uanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi9zdWJtaXQuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi90aWNrZXQuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi90cnVzdGxpbmUuanMiLCJub2RlX21vZHVsZXMvcmlwcGxlLWxpYi9kaXN0L25wbS90cmFuc2FjdGlvbi90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9yaXBwbGUtbGliL2Rpc3QvbnBtL3RyYW5zYWN0aW9uL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvZGlzdC9ucG0vd2FsbGV0L3dhbGxldC1nZW5lcmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3JpcHBsZS1saWIvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvc2FmZS1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NjcnlwdHN5L2xpYi9zY3J5cHQuanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aW55LXNlY3AyNTZrMS9qcy5qcyIsIm5vZGVfbW9kdWxlcy90aW55LXNlY3AyNTZrMS9yZmM2OTc5LmpzIiwibm9kZV9tb2R1bGVzL3RvLWRhdGEtdmlldy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90d2VldG5hY2wtdXRpbC9uYWNsLXV0aWwuanMiLCJub2RlX21vZHVsZXMvdHdlZXRuYWNsL25hY2wtZmFzdC5qcyIsIm5vZGVfbW9kdWxlcy90eXBlZm9yY2UvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVmb3JjZS9leHRyYS5qcyIsIm5vZGVfbW9kdWxlcy90eXBlZm9yY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHlwZWZvcmNlL25hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy91aW50OGFycmF5cy9jb25jYXQuanMiLCJub2RlX21vZHVsZXMvdWludDhhcnJheXMvZXF1YWxzLmpzIiwibm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL3RvLXN0cmluZy5qcyIsIm5vZGVfbW9kdWxlcy92YWxpZGF0ZS1ucG0tcGFja2FnZS1uYW1lL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92YXJ1aW50LWJpdGNvaW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViLWVuY29kaW5nL3NyYy9saWIuanMiLCJub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2Rpc3QvZmV0Y2gudW1kLmpzIiwibm9kZV9tb2R1bGVzL3dpZi9pbmRleC5qcyIsInNoYXJlZC9jb25zdGFudHMvYWxhcm1zLmpzIiwic2hhcmVkL2NvbnN0YW50cy9zbWFydFRyYW5zYWN0aW9ucy5qcyIsInNoYXJlZC9jb25zdGFudHMvdGVzdC1mbGFncy5qcyIsImFwcC9zY3JpcHRzL2JhY2tncm91bmQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbDdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsd0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzkyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2xkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNoSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pGQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5MkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3BtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDMVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdjFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzVtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9ETyxNQUFNLHVCQUF1QixHQUFHLHlCQUF5QjtBQUFDLE9BQUEsQ0FBQSx1QkFBQSxHQUFBLHVCQUFBO0FBQzFELE1BQU0seUNBQXlDLEdBQ3BELDJDQUEyQztBQUFDLE9BQUEsQ0FBQSx5Q0FBQSxHQUFBLHlDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0Y5QyxJQUFBLEtBQUEsR0FBQSxPQUFBO0FBRU8sTUFBTSx3Q0FBd0MsR0FBRyxZQUFNLEdBQUcsRUFBRTtBQUFDLE9BQUEsQ0FBQSx3Q0FBQSxHQUFBLHdDQUFBO0FBQzdELE1BQU0sb0NBQW9DLEdBQUcsR0FBRztBQUFDLE9BQUEsQ0FBQSxvQ0FBQSxHQUFBLG9DQUFBO0FBQ2pELE1BQU0sOENBQThDLEdBQUcsQ0FBQztBQUFDLE9BQUEsQ0FBQSw4Q0FBQSxHQUFBLDhDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0p6RCxNQUFNLDZCQUE2QixHQUFHLCtCQUErQjtBQUFDLE9BQUEsQ0FBQSw2QkFBQSxHQUFBLDZCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSTdFLElBQUEsVUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxlQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGVBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFFBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsTUFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsa0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsaUJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFlBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsVUFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsd0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsdUJBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFlBQUEsT0FBQSxDQUFBLHFCQUFBLENBQUEsQ0FBQTtBQUVBLElBQUEsdUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsdUJBQUEsQ0FBQSxDQUFBLENBQUE7QUFFQSxJQUFBLGdCQUFBLE9BQUEsQ0FBQSxnQkFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLE9BQUEsT0FBQSxDQUFBLDRCQUFBLENBQUEsQ0FBQTtBQU9BLElBQUEsZUFBQSxPQUFBLENBQUEsb0NBQUEsQ0FBQSxDQUFBO0FBT0EsSUFBQSxrQkFBQSxPQUFBLENBQUEsNENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxNQUFBLE9BQUEsQ0FBQSxnQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFVBQUEsT0FBQSxDQUFBLG1DQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsY0FBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxjQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxZQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGdCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxhQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHVCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxjQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLG1CQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxnQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxxQkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsZUFBQSxPQUFBLENBQUEsbUJBQUEsQ0FBQSxDQUFBO0FBRUEsSUFBQSxvQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx3QkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsdUJBQUEsdUJBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7QUFHQSxJQUFBLHNCQUFBLHVCQUFBLENBQUEsT0FBQSxDQUFBLHVCQUFBLENBQUEsQ0FBQSxDQUFBO0FBR0EsSUFBQSxrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxvQkFBQSxDQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsNkJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUNBQUEsQ0FBQSxDQUFBLENBQUE7QUFDQSxJQUFBLG1CQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHVCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxTQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHNCQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxRQUFBLE9BQUEsQ0FBQSxZQUFBLENBQUEsQ0FBQTtBQUEwRCwrQ0FBQSxFQUFBLElBQUEsT0FBQSxPQUFBLEtBQUEsVUFBQSxFQUFBLE9BQUEsSUFBQSxDQUFBLENBQUEsSUFBQSxvQkFBQSxJQUFBLE9BQUEsRUFBQSxDQUFBLENBQUEsSUFBQSxtQkFBQSxJQUFBLE9BQUEsRUFBQSxDQUFBLENBQUEsT0FBQSxDQUFBLDJCQUFBLHVCQUFBLEVBQUEsT0FBQSxXQUFBLEdBQUEsZ0JBQUEsR0FBQSxpQkFBQSxDQUFBLEVBQUEsRUFBQSxXQUFBLENBQUEsQ0FBQSxFQUFBO0FBQUEsbURBQUEsRUFBQSxJQUFBLENBQUEsV0FBQSxJQUFBLEdBQUEsSUFBQSxHQUFBLFdBQUEsRUFBQSxFQUFBLE9BQUEsR0FBQSxDQUFBLEVBQUEsQ0FBQSxJQUFBLEdBQUEsS0FBQSxJQUFBLElBQUEsT0FBQSxHQUFBLEtBQUEsUUFBQSxJQUFBLE9BQUEsR0FBQSxLQUFBLFVBQUEsRUFBQSxFQUFBLE9BQUEsRUFBQSxTQUFBLEdBQUEsRUFBQSxDQUFBLEVBQUEsQ0FBQSxJQUFBLFFBQUEsd0JBQUEsQ0FBQSxXQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsS0FBQSxJQUFBLEtBQUEsSUFBQSxDQUFBLEdBQUEsQ0FBQSxFQUFBLEVBQUEsT0FBQSxLQUFBLElBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsSUFBQSxTQUFBLEVBQUEsQ0FBQSxDQUFBLElBQUEsd0JBQUEsTUFBQSxlQUFBLElBQUEsTUFBQSx5QkFBQSxDQUFBLENBQUEsS0FBQSxJQUFBLEdBQUEsSUFBQSxHQUFBLEVBQUEsRUFBQSxJQUFBLEdBQUEsS0FBQSxTQUFBLElBQUEsTUFBQSxVQUFBLGVBQUEsS0FBQSxDQUFBLEdBQUEsRUFBQSxHQUFBLENBQUEsRUFBQSxFQUFBLElBQUEsT0FBQSxxQkFBQSxHQUFBLE1BQUEseUJBQUEsQ0FBQSxHQUFBLEVBQUEsR0FBQSxDQUFBLEdBQUEsSUFBQSxDQUFBLENBQUEsSUFBQSxJQUFBLEtBQUEsSUFBQSxJQUFBLElBQUEsSUFBQSxJQUFBLENBQUEsRUFBQSxFQUFBLE1BQUEsZUFBQSxDQUFBLE1BQUEsRUFBQSxHQUFBLEVBQUEsSUFBQSxDQUFBLENBQUEsRUFBQSxNQUFBLEVBQUEsTUFBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxFQUFBLEVBQUEsRUFBQSxDQUFBLE1BQUEsUUFBQSxHQUFBLEdBQUEsQ0FBQSxDQUFBLElBQUEsS0FBQSxFQUFBLEVBQUEsS0FBQSxJQUFBLENBQUEsR0FBQSxFQUFBLE1BQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxPQUFBLE1BQUEsQ0FBQSxFQUFBO0FBQUEscUNBQUEsRUFBQSxPQUFBLEdBQUEsSUFBQSxHQUFBLFdBQUEsR0FBQSxHQUFBLEdBQUEsRUFBQSxTQUFBLEdBQUEsRUFBQSxDQUFBLEVBQUE7Ozs7Ozs7OztBQVExRCxNQUFNOztDQUFVLEdBQUcsTUFBTSxDQUFBO0FBQ3pCLE1BQU0saUJBQWlCO0VBQUUsR0FBRyxlQUFBLFFBQUE7Q0FBbUIsQ0FBQTtBQUUvQyxNQUFNLDhCQUE4QjtFQUNsQyxDQUFDLElBQUEsdUJBQXNCLEdBQUcsSUFBSTtFQUM5QixDQUFDLElBQUEsOEJBQTZCLEdBQUcsSUFBSTtFQUNyQyxDQUFDLElBQUEsNEJBQTJCLEdBQUcsSUFBQTtDQUNoQyxDQUFBO0FBRUQsTUFBTSx1QkFBdUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFBO0FBRS9DLFNBQUEsUUFBRyxnQkFBZ0IsQ0FBQyxPQUFPLElBQUksZUFBZSxHQUFHLE9BQU8sR0FBRyxNQUFNLENBQUMsQ0FBQTtBQUVsRSxNQUFNLFdBQVcsSUFBSSxVQUFBLFFBQWlCLEVBQUUsQ0FBQTtBQUN4QyxNQUFNLHNCQUFzQixJQUFJLG9CQUFBLFFBQW1CLEVBQUUsQ0FBQTtBQUVyRCxJQUFJLGNBQWMsS0FBSyxDQUFBO0FBQ3ZCLElBQUkscUJBQXFCLEtBQUssQ0FBQTtBQUM5QixJQUFJLGlCQUFpQixLQUFLLENBQUE7QUFDMUIsTUFBTSxzQkFBc0IsRUFBRSxDQUFBO0FBQzlCLE1BQU0sdUJBQXVCLEVBQUUsQ0FBQTtBQUMvQixJQUFJLFVBQVUsQ0FBQTs7O0FBR2QsTUFBTSxTQUFTLE9BQU8sSUFBSSxRQUFRLENBQUE7QUFDbEMsTUFBTSxhQUFhLE1BQU0sR0FBRyxJQUFJLGFBQUEsUUFBb0IsRUFBRSxHQUFHLElBQUksV0FBQSxRQUFVLEVBQUUsQ0FBQTtBQUN6RSxJQUFJLGFBQWEsQ0FBQTtBQUVqQixJQUFJLE1BQU0sSUFBSSxPQUFPLElBQUksZUFBZSxFQUFFO0VBQ3hDLE1BQU0sV0FBVyxpQkFBaUIsR0FBRyxVQUFVLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFBO0NBQ3RFO0FBRUEsTUFBTSxrQkFBa0IsSUFBSSxHQUFHLENBQUMsT0FBTyxJQUFJLDBCQUEwQixDQUFDLENBQUE7QUFFdEUsTUFBTSw2QkFBNkIsS0FBSyxDQUFBOztBQUV4QyxNQUFNLGdDQUFnQywwQkFBMEIsQ0FBQTtBQUVoRSxNQUFNLHlCQUF5Qix3QkFBd0IsQ0FBQTtBQUN2RCxNQUFNLDRCQUE0QiwyQkFBMkIsQ0FBQTs7O0FBS3RELE1BQU0seUJBQXlCLElBQUksT0FBQSxRQUFZLEVBQUUsQ0FBQTs7Ozs7Ozs7O0FBRXhELE9BQUEsdUJBQUEsR0FBQSxzQkFBQSxDQUFBO0FBT0EsTUFBTTs7OztDQUlMLEdBQUcsQ0FBQSxDQUFBLEVBQUEsS0FBQSxnQkFBZSxHQUFFLENBQUE7Ozs7Ozs7QUFPckIsTUFBTSx5QkFBeUIsWUFBWTtFQUN6QyxNQUFNLE9BQU8sTUFBTSxxQkFBQSxRQUFPLEtBQUssTUFDdkIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7SUFjTCxLQUFLLFlBQVk7SUFDakIsWUFBWSxRQUFBO0dBQ2IsQ0FBQyxLQUNHLENBQUUsVUFBVztJQUNoQixDQUFBLENBQUEsRUFBQSxlQUFBLHdCQUF1QixHQUFFLENBQUE7SUFDekIsT0FBTyxNQUFNLENBQUE7R0FDZCxDQUFDLE1BQ0ksQ0FBQyxNQUFNO0lBQ1gsQ0FBQSxDQUFBLEVBQUEsZUFBQSx3QkFBdUIsR0FBRSxDQUFBO0dBQzFCLENBQUMsQ0FBQTs7O0VBR0osS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7SUFDdEIscUJBQUEsUUFBTyxLQUFLLFlBQ0UsQ0FBQyxHQUFHLEdBQUcsRUFBRTtNQUNuQixNQUFNLElBQUEsbUJBQWtCLE1BQUM7S0FDMUIsQ0FBQyxLQUNHLENBQUMsTUFBTTtNQUNWLENBQUEsQ0FBQSxFQUFBLGVBQUEsd0JBQXVCLEdBQUUsQ0FBQTtLQUMxQixDQUFDLE1BQ0ksQ0FBQyxNQUFNOzs7TUFHWCxDQUFBLENBQUEsRUFBQSxlQUFBLHdCQUF1QixHQUFFLENBQUE7S0FDMUIsQ0FBQyxDQUFBO0dBQ047Q0FDRCxDQUFBOzs7QUFHRCxJQUFJLGFBQWEsQ0FBQTtBQUNqQixJQUFJLGVBQWUsQ0FBQTtBQUVuQixxQkFBQSxRQUFPLFFBQVEsVUFBVSxZQUFZLENBQUMsT0FBTyxPQUFPLEtBQUs7O0VBRXZELE1BQU0sYUFBYSxDQUFBOzs7RUFHbkIsYUFBYSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUE7Q0FDdkIsQ0FBQyxDQUFBO0FBQ0YscUJBQUEsUUFBTyxRQUFRLGtCQUFrQixZQUFZLENBQUMsT0FBTyxPQUFPLEtBQUs7O0VBRS9ELE1BQU0sYUFBYSxDQUFBOzs7RUFHbkIsZUFBZSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUE7Q0FDekIsQ0FBQyxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0VGLDRCQUE0QjtFQUMxQixJQUFJO0lBQ0YsTUFBTSxZQUFZLE1BQU0sd0JBQXdCLEVBQUUsQ0FBQTtJQUNsRCxNQUFNLGVBQWUsTUFBTSxDQUFBLENBQUEsRUFBQSwwQkFBQSxRQUF5QixHQUFFLENBQUE7SUFJdEQsSUFBSSw4QkFBOEIsQ0FBQTtJQUNsQyxJQUFJLEdBQUEsYUFBWSxFQUFFO01BQ2hCLE1BQU0sY0FBYyxNQUFNLHFCQUFBLFFBQU8sUUFBUSxRQUFRLElBQUksQ0FBQyxDQUNwRCxnQ0FBZ0MsQ0FDakMsQ0FBQyxDQUFBO01BRUYsaUNBQ0UsQ0FBQSxXQUFXLEtBQUEsSUFBQSxJQUFYLFdBQVcsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBWCxXQUFXLCtCQUFnQyxNQUFLLFNBQVMsQ0FBQTtNQUMzRCxNQUFNLHFCQUFBLFFBQU8sUUFBUSxRQUFRLElBQUksQ0FBQztRQUFFLDhCQUFBO09BQWdDLENBQUMsQ0FBQTtLQUN2RTtJQUVBLGVBQWUsQ0FDYixTQUFTLEVBQ1QsWUFBWSxFQUNaLEVBQUUsRUFDRiw4QkFDRixDQUFDLENBQUE7SUFDRCxJQUFJLENBQUMsR0FBQSxhQUFZLEVBQUU7TUFDakIsTUFBTSx1QkFBdUIsRUFBRSxDQUFBO0tBQ2pDO0lBQ0EsTUFBTSxzQkFBc0IsRUFBRSxDQUFBO0lBQzlCLFNBQUEsUUFBRyxLQUFLLENBQUMsbUNBQW1DLENBQUMsQ0FBQTtJQUM3QyxxQkFBcUIsRUFBRSxDQUFBO0dBQ3hCLENBQUMsY0FBYztJQUNkLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFBO0dBQzdCO0NBQ0Y7Ozs7O0FBS0EsOENBQThDLEtBQUssQ0FBQztFQUNsRCxXQUFXLEdBQUc7SUFDWixLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQTtHQUN6QjtDQUNGOzs7Ozs7QUFNQSx5Q0FBeUM7RUFDdkMsSUFBSSxNQUFNLENBQUE7RUFDVixJQUFJO0lBQ0YsTUFBTSxrQ0FBa0MsSUFBSSxHQUFHLENBQzdDLE9BQU8sSUFBSSwwQkFDYixDQUFDLENBQUE7Ozs7SUFJRCwrQkFBK0IsS0FBSyxHQUFHLG1CQUFtQixDQUFBO0lBRTFELFNBQVMsTUFBTSxTQUFTLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQTtJQUNoRCxNQUFNLGFBQWEsQ0FBQyxLQUFLLEVBQUUsK0JBQStCLEtBQUssQ0FBQyxDQUFBO0lBQ2hFLE1BQU0sYUFBYSxDQUFDLFNBQVMsRUFBRSxpQ0FBaUMsQ0FBQyxDQUFBOzs7SUFHakUsSUFBSSxlQUFlLENBQUE7SUFDbkIsSUFBSSxjQUFjLENBQUE7SUFDbEIsTUFBTSxlQUFlLElBQUksT0FBTyxDQUFDLHFCQUFxQjtNQUNwRCxrQkFBa0IsT0FBTyxDQUFBO01BQ3pCLGlCQUFpQixNQUFNLENBQUE7S0FDeEIsQ0FBQyxDQUFBOzs7O0lBSUYsTUFBTSxpQkFBaUIsQ0FBQyxNQUFNLEVBQUUsZUFBZSxDQUFDLENBQUE7OztJQUdoRCxNQUFNLFNBQVMsS0FBSyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUE7Ozs7O0lBS3hDLFVBQVUsQ0FDUixNQUFNLGNBQWMsQ0FBQyxJQUFJLCtCQUErQixFQUFFLENBQUMsRUFDM0QsNkJBQ0YsQ0FBQyxDQUFBO0lBQ0QsTUFBTSxZQUFZLENBQUE7R0FDbkIsQ0FBQyxjQUFjO0lBQ2QsSUFBSSxLQUFLLFlBQVksK0JBQStCLEVBQUU7TUFDcEQsT0FBTyxLQUFLLENBQ1Ysc0VBQ0YsQ0FBQyxDQUFBO0tBQ0YsTUFBTTtNQUNMLE9BQU8sTUFBTSxDQUFDLDRDQUE0QyxFQUFFLEtBQUssQ0FBQyxDQUFBO0tBQ3BFO0dBQ0QsU0FBUztJQUNSLElBQUksTUFBTSxFQUFFO01BQ1YsTUFBTSxPQUFPLEVBQUUsQ0FBQTtLQUNqQjtHQUNGO0NBQ0Y7Ozs7Ozs7Ozs7OztBQVlPLDBDQUEwQzs7RUFFL0MsTUFBTSxXQUFXLElBQUksU0FBQSxRQUFRLENBQUM7SUFBRSxZQUFBLFdBQUEsUUFBQTtHQUFZLENBQUMsQ0FBQTtFQUM3QyxRQUFRLEdBQUcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxLQUFLLENBQUMsQ0FBQTs7OztFQUlsQyxnQkFDRSxDQUFDLE1BQU0sVUFBVSxJQUFJLEVBQUUsS0FBSyxRQUFRLHFCQUFxQixDQUFDLGNBQWMsQ0FBQyxDQUFBOzs7Ozs7RUFNM0UsSUFBSSxhQUFhLElBQUksQ0FBQyxhQUFhLEtBQUssRUFBRTs7SUFFeEMsZ0JBQWdCLFFBQVEscUJBQXFCLENBQUMsY0FBYyxDQUFDLENBQUE7SUFDN0QsTUFBTSxlQUFlLENBQUMsa0RBQWtELENBQUMsQ0FBQTtHQUMzRTs7O0VBR0EsUUFBUSxHQUFHLENBQUMsT0FBTyxFQUFHLE9BQVE7O0lBRTVCLE1BQU0saUJBQWlCLENBQUEsQ0FBQSxFQUFBLGdCQUFBLFFBQWUsRUFBQyxhQUFhLENBQUMsQ0FBQTtJQUNyRCxNQUFNLGlCQUFpQixDQUFDLEdBQUcsRUFBRTs7TUFFM0IsT0FBTztRQUFFLGNBQUE7T0FBZTtLQUN6QixDQUFDLENBQUE7R0FDSCxDQUFDLENBQUE7OztFQUdGLGdCQUFnQixNQUFNLFFBQVEsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFBO0VBQ3pELElBQUksQ0FBQyxhQUFhLEVBQUU7SUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFBO0dBQzNEOztFQUVBLFVBQVUsWUFBWSxDQUFDLGFBQWEsS0FBSyxDQUFDLENBQUE7OztFQUcxQyxVQUFVLElBQUksQ0FBQyxhQUFhLEtBQUssQ0FBQyxDQUFBOzs7RUFHbEMsT0FBTyxhQUFhLEtBQUssQ0FBQTtDQUMzQjs7Ozs7Ozs7Ozs7OztBQWFPLDZGQUtMOzs7OztFQUtBLGFBQWEsSUFBSSxtQkFBQSxRQUFrQixDQUFDO0lBQ2xDLGlCQUFpQixPQUFPLElBQUksa0JBQWtCOztJQUU5QyxzQkFBc0IsU0FBUzs7SUFFL0IsU0FBUzs7SUFFVCxZQUFZOztJQUVaLFFBQVE7SUFDUixtQkFBbUI7SUFDbkIsU0FBQSxxQkFBQSxRQUFPO0lBQ1AseUJBQXlCLE1BQU07TUFDN0IsT0FBTyxvQkFBb0IsQ0FBQTtLQUM1QjtJQUNELHdCQUF3QixNQUFNO01BQzVCLE9BQU8sbUJBQW1CLENBQUE7S0FDM0I7SUFDRCxVQUFVO0lBQ1YsU0FBUztJQUNULDhCQUFBO0dBQ0QsQ0FBQyxDQUFBO0VBRUYsQ0FBQSxDQUFBLEVBQUEsTUFBQSxRQUFvQixFQUFDO0lBQ25CLG1CQUFtQixNQUNqQixVQUFVLGtCQUFrQixNQUFNLGVBQWUsUUFBUTtJQUMzRCxnQkFBZ0IsVUFBVSxzQkFBc0IsZUFBZSxLQUFLLENBQ2xFLFVBQVUsc0JBQ1osQ0FBQztJQUNELFVBQVUsVUFBVSxTQUFDO0dBQ3RCLENBQUMsQ0FBQTs7O0VBR0YsQ0FBQSxDQUFBLEVBQUEsS0FBQSxRQUFJLEVBQ0YsQ0FBQSxDQUFBLEVBQUEsU0FBQSxjQUFhLEVBQUMsVUFBVSxNQUFNLENBQUMsRUFDL0IsQ0FBQSxDQUFBLEVBQUEsZUFBQSxRQUFRLEVBQUMsSUFBSSxDQUFDLEVBQ2QsQ0FBQSxDQUFBLEVBQUEsaUJBQUEsUUFBZ0IsRUFBQyxlQUFpQjtJQUNoQyxNQUFNLFVBQVUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQzNCLHNCQUFzQixLQUFLLENBQUMsaUJBQWlCLEVBQUUsS0FBSyxDQUFDLENBQUE7R0FDdEQsQ0FBQyxFQUNELFNBQVU7SUFDVCxTQUFBLFFBQUcsTUFBTSxDQUFDLHdDQUF3QyxFQUFFLEtBQUssQ0FBQyxDQUFBO0dBRTlELENBQUMsQ0FBQTtFQUVELHlCQUF5QixDQUFDLFVBQVUsQ0FBQyxDQUFBO0VBRXJDLE1BQU0scUJBQXFCLE1BQU07SUFDL0IsT0FDRSxXQUFXLElBQ1gsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxJQUNoRCxrQkFBa0IsQ0FBQTtHQUVyQixDQUFBO0VBRUQsTUFBTSw4QkFBOEIsbUNBQW1DOztJQUVyRSxJQUFJLFlBQVksS0FBSyxLQUFLLEVBQUU7TUFDMUIsVUFBVSxlQUFlLEVBQUUsQ0FBQTs7S0FFNUIsTUFBTTs7O01BR0wsSUFDRSxlQUFlLEtBQUssSUFBQSw0QkFBMkIsSUFDL0MsT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxFQUNoRDtRQUNBLE9BQUE7T0FDRjtNQUNBLFVBQVUsd0JBQXdCLENBQUMsZUFBZSxDQUFDLENBQUE7S0FDckQ7R0FDRCxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7O0VBZ0JELGdCQUFnQixvQkFBc0I7SUFBQSxJQUFBLGtCQUFBLENBQUE7SUFHcEMsTUFBTSxjQUFjLFVBQVUsS0FBSyxDQUFBO0lBRW5DLElBQUksb0JBQW9CLFNBQVMsQ0FBQyxVQUFVLEtBQUssQ0FBQyxFQUFFO01BQ2xELE9BQUE7S0FDRjtJQUVBLElBQUksNEJBQTRCLEtBQUssQ0FBQTtJQUNyQyxNQUFNLGlCQUFpQixDQUFBLENBQUEsRUFBQSxLQUFBLFlBQVcsR0FBRSxDQUFBO0lBQ3BDLE1BQU0sWUFBWSxDQUFBLHFCQUFBLFVBQVUsT0FBTyxNQUFBLElBQUEsSUFBQSxrQkFBQSxLQUFBLEtBQUEsQ0FBQSxJQUFqQixrQkFBQSxJQUFzQixHQUNwQyxJQUFJLEdBQUcsQ0FBQyxVQUFVLE9BQU8sSUFBSSxDQUFDLEdBQzlCLElBQUksQ0FBQTtJQUVSLElBQUksY0FBYyxLQUFLLElBQUEsaUJBQWdCLEVBQUU7TUFDdkMsNEJBQTRCLDJCQUEyQixDQUFDLFdBQVcsQ0FBQyxDQUFBO0tBQ3JFLE1BQU07TUFDTCw0QkFDRSxDQUFBLFNBQVMsS0FBQSxJQUFBLElBQVQsU0FBUyxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFULFNBQVMsT0FBUSxNQUFNLENBQUEsbUJBQUEsRUFBcUIscUJBQUEsUUFBTyxRQUFRLEdBQUksQ0FBQSxDQUFDLENBQUE7S0FDcEU7SUFFQSxJQUFJLHlCQUF5QixFQUFFO01BQUEsSUFBQSxxQkFBQSxDQUFBO01BQzdCLE1BQU0sYUFDSixDQUFBLFNBQVMsS0FBQSxJQUFBLElBQVQsU0FBUyxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFBLENBQUEsd0JBQVQsU0FBUyxjQUFlLE1BQUEsSUFBQSxJQUFBLHFCQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQXhCLHFCQUFBLEtBQUEsQ0FBQSxTQUFTLEVBQWtCLFVBQVUsQ0FBQyxLQUFJLElBQUksb0JBQUEsUUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFBOztNQUV0RSxVQUFVLGFBQWEsR0FBRyxJQUFJLENBQUE7TUFDOUIsVUFBVSwwQkFBMEIsQ0FBQyxVQUFVLEVBQUUsVUFBVSxPQUFPLENBQUMsQ0FBQTtNQUVuRSxJQUFJLEdBQUEsYUFBWSxFQUFFOztRQUVoQixVQUFVLFVBQVUsWUFBWSxDQUFFLFdBQVk7VUFDNUMsSUFBSSxPQUFPLEtBQUssS0FBSyx5QkFBeUIsRUFBRTs7WUFFOUMsVUFBVSxZQUFZLENBQUM7Y0FBRSxNQUFNLHNCQUFBO2FBQXdCLENBQUMsQ0FBQTtZQUV4RCxVQUFVLG1CQUFtQiwrQkFBK0IsQ0FDMUQsSUFBSSxJQUFJLEVBQ1YsQ0FBQyxDQUFBO1dBQ0g7U0FDRCxDQUFDLENBQUE7T0FDSjtNQUVBLElBQUksV0FBVyxLQUFLLElBQUEsdUJBQXNCLEVBQUU7UUFDMUMsY0FBYyxJQUFJLENBQUE7UUFDbEIsQ0FBQSxDQUFBLEVBQUEsWUFBQSxRQUFXLEVBQUMsVUFBVSxFQUFFLE1BQU07VUFDNUIsY0FBYyxLQUFLLENBQUE7VUFDbkIsTUFBTSxlQUFlLGtCQUFrQixFQUFFLENBQUE7VUFDekMsVUFBVSxhQUFhLEdBQUcsWUFBWSxDQUFBO1VBQ3RDLDJCQUEyQixDQUFDLFlBQVksRUFBRSxJQUFBLHVCQUFzQixDQUFDLENBQUE7U0FDbEUsQ0FBQyxDQUFBO09BQ0o7TUFFQSxJQUFJLFdBQVcsS0FBSyxJQUFBLDhCQUE2QixFQUFFO1FBQ2pELHFCQUFxQixJQUFJLENBQUE7UUFFekIsQ0FBQSxDQUFBLEVBQUEsWUFBQSxRQUFXLEVBQUMsVUFBVSxFQUFFLE1BQU07VUFDNUIscUJBQXFCLEtBQUssQ0FBQTtVQUMxQixNQUFNLGVBQWUsa0JBQWtCLEVBQUUsQ0FBQTtVQUN6QyxVQUFVLGFBQWEsR0FBRyxZQUFZLENBQUE7VUFDdEMsMkJBQTJCLENBQ3pCLFlBQVksRUFDWixJQUFBLDhCQUNGLENBQUMsQ0FBQTtTQUNGLENBQUMsQ0FBQTtPQUNKO01BRUEsSUFBSSxXQUFXLEtBQUssSUFBQSw0QkFBMkIsRUFBRTtRQUMvQyxNQUFNLFFBQVEsVUFBVSxPQUFPLElBQUksR0FBRyxDQUFBO1FBQ3RDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxHQUFHLElBQUksQ0FBQTtRQUVqQyxDQUFBLENBQUEsRUFBQSxZQUFBLFFBQVcsRUFBQyxVQUFVLEVBQUUsTUFBTTtVQUM1QixPQUFPLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFBO1VBQ2pDLE1BQU0sZUFBZSxrQkFBa0IsRUFBRSxDQUFBO1VBQ3pDLFVBQVUsYUFBYSxHQUFHLFlBQVksQ0FBQTtVQUN0QywyQkFBMkIsQ0FDekIsWUFBWSxFQUNaLElBQUEsNEJBQ0YsQ0FBQyxDQUFBO1NBQ0YsQ0FBQyxDQUFBO09BQ0o7S0FDRCxNQUFNLElBQ0wsU0FBUyxJQUNULFNBQVMsT0FBTyxLQUFLLGVBQWUsT0FBTyxJQUMzQyxTQUFTLFNBQVMsS0FBSyxlQUFlLFNBQVMsRUFDL0M7TUFBQSxJQUFBLHNCQUFBLENBQUE7TUFDQSxNQUFNLGFBQ0osQ0FBQSxTQUFTLEtBQUEsSUFBQSxJQUFULFNBQVMsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxDQUFBLHlCQUFULFNBQVMsY0FBZSxNQUFBLElBQUEsSUFBQSxzQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUF4QixzQkFBQSxLQUFBLENBQUEsU0FBUyxFQUFrQixVQUFVLENBQUMsS0FBSSxJQUFJLG9CQUFBLFFBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQTtNQUN0RSxVQUFVLDJCQUEyQixDQUFDO1FBQ3BDLGtCQUFrQixVQUFBO09BQ25CLENBQUMsQ0FBQTtLQUNILE1BQU07TUFDTCxJQUFJLFVBQVUsT0FBTyxJQUFJLFVBQVUsT0FBTyxJQUFJLElBQUksVUFBVSxPQUFPLElBQUksRUFBRTtRQUN2RSxNQUFNLFFBQVEsVUFBVSxPQUFPLElBQUksR0FBRyxDQUFBO1FBQ3RDLE1BQU0sTUFBTSxJQUFJLEdBQUcsQ0FBQyxVQUFVLE9BQU8sSUFBSSxDQUFDLENBQUE7UUFDMUMsTUFBTTs7U0FBVSxHQUFHLEdBQUcsQ0FBQTtRQUV0QixVQUFVLFVBQVUsWUFBWSxDQUFFLE9BQVE7VUFDeEMsSUFBSSxHQUFHLEtBQUssSUFBSSxHQUFHLEtBQUssT0FBTyxLQUFLLHFCQUFxQixFQUFFO1lBQ3pELG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQTtXQUN0QztTQUNELENBQUMsQ0FBQTtPQUNKO01BQ0EsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFBO0tBQzdCO0dBQ0QsQ0FBQTs7O0VBR0Qsa0JBQW1CLGNBQWU7SUFBQSxJQUFBLHNCQUFBLENBQUE7SUFHaEMsTUFBTSxhQUNKLENBQUEsU0FBUyxLQUFBLElBQUEsSUFBVCxTQUFTLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUEsQ0FBQSx5QkFBVCxTQUFTLGNBQWUsTUFBQSxJQUFBLElBQUEsc0JBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBeEIsc0JBQUEsS0FBQSxDQUFBLFNBQVMsRUFBa0IsVUFBVSxDQUFDLEtBQUksSUFBSSxvQkFBQSxRQUFVLENBQUMsVUFBVSxDQUFDLENBQUE7SUFDdEUsVUFBVSw0QkFBNEIsQ0FBQztNQUNyQyxrQkFBa0IsVUFBVTtNQUM1QixRQUFRLFVBQVUsT0FBQztLQUNwQixDQUFDLENBQUE7R0FDSCxDQUFBO0VBRUQsSUFBSSxTQUFTLEtBQUEsSUFBQSxJQUFULFNBQVMsS0FBQSxLQUFBLENBQUEsSUFBVCxTQUFTLHlCQUEwQixFQUFFO0lBQ3ZDLFNBQVMseUJBQXlCLENBQUMsYUFBYSxFQUFFLGVBQWUsQ0FBQyxDQUFBO0dBQ3BFOzs7OztFQUtBLFdBQVcsRUFBRSxDQUFBO0VBRWIsVUFBVSxhQUFhLEdBQUcsQ0FDeEIsbUJBQUEsMkJBQTBCLGFBQWEsRUFDdkMsV0FDRixDQUFDLENBQUE7RUFDRCxVQUFVLHlCQUF5QixJQUFJLEdBQUcsQ0FDeEMsbUJBQUEsMkJBQTBCLGFBQWEsRUFDdkMsV0FDRixDQUFDLENBQUE7RUFDRCxVQUFVLDhCQUE4QixJQUFJLEdBQUcsQ0FDN0MsbUJBQUEsMkJBQTBCLGFBQWEsRUFDdkMsV0FDRixDQUFDLENBQUE7RUFDRCxVQUFVLG9CQUFvQixJQUFJLEdBQUcsQ0FDbkMsbUJBQUEsMkJBQTBCLGFBQWEsRUFDdkMsV0FDRixDQUFDLENBQUE7RUFDRCxVQUFVLG1CQUFtQixHQUFHLENBQzlCLG1CQUFBLDJCQUEwQixhQUFhLEVBQ3ZDLFdBQ0YsQ0FBQyxDQUFBO0VBRUQsVUFBVSxvQkFBb0IsVUFBVSxDQUN0QyxtQkFBQSwyQkFBMEIsc0JBQXNCLEVBQ2hELFdBQ0YsQ0FBQyxDQUFBO0VBRUQsVUFBVSxhQUFhLGNBQWMsRUFBRSxDQUFBOzs7Ozs7RUFNdkMsdUJBQXVCO0lBQ3JCLElBQUksUUFBUSxFQUFFLENBQUE7SUFDZCxNQUFNLFFBQVEsNkJBQTZCLEVBQUUsQ0FBQTtJQUM3QyxJQUFJLEtBQUssRUFBRTtNQUNULFFBQVEsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFBO0tBQ3ZCOztJQUVBLElBQUksR0FBQSxhQUFZLEVBQUU7TUFDaEIscUJBQUEsUUFBTyxPQUFPLGFBQWEsQ0FBQztRQUFFLE1BQU0sS0FBQTtPQUFPLENBQUMsQ0FBQTtNQUM1QyxxQkFBQSxRQUFPLE9BQU8sd0JBQXdCLENBQUM7UUFBRSxPQUFPLFNBQUE7T0FBVyxDQUFDLENBQUE7S0FDN0QsTUFBTTtNQUNMLHFCQUFBLFFBQU8sY0FBYyxhQUFhLENBQUM7UUFBRSxNQUFNLEtBQUE7T0FBTyxDQUFDLENBQUE7TUFDbkQscUJBQUEsUUFBTyxjQUFjLHdCQUF3QixDQUFDO1FBQUUsT0FBTyxTQUFBO09BQVcsQ0FBQyxDQUFBO0tBQ3JFO0dBQ0Y7RUFFQSx5Q0FBeUM7SUFDdkMsTUFBTSx1QkFDSixVQUFVLG1CQUFtQixzQkFBc0IsRUFBRSxDQUFBO0lBQ3ZELE1BQU0sd0JBQ0osVUFBVSxtQkFBbUIsaUJBQWlCLE9BQU8sQ0FBQTtJQUN2RCxPQUFPLG9CQUFvQixHQUFHLHFCQUFxQixDQUFBO0dBQ3JEO0VBRUEsbUJBQW1CLEdBQUcsQ0FDcEIsb0JBQUEsNEJBQTJCLGFBQWEsRUFDeEMsQ0FBQzs7R0FBdUIsS0FBSztJQUMzQixJQUFJLENBQUMsbUJBQW1CLEVBQUU7TUFDeEIsNkJBQTZCLEVBQUUsQ0FBQTtLQUNoQyxNQUFNLElBQUksNkJBQTZCLEVBQUUsR0FBRyxDQUFDLEVBQUU7TUFDOUMsU0FBUyxFQUFFLENBQUE7S0FDYjtHQUVKLENBQUMsQ0FBQTtFQUVELHlDQUF5QztJQUN2QyxNQUFNLEtBQUssQ0FDVCxVQUFVLGFBQWEsZUFBZSxvQkFBb0IsRUFDNUQsQ0FBQyxRQUFRLENBQUUsUUFDVCxVQUFVLGFBQWEsZUFBZSxvQkFBb0IsQ0FBQyxJQUFJLENBQ2pFLENBQUMsQ0FBQTtJQUNELFVBQVUsb0JBQW9CLGlCQUFpQixDQUM3QyxZQUFBLDhCQUNGLENBQUMsQ0FBQTtJQUNELFVBQVUseUJBQXlCLGlCQUFpQixDQUNsRCxZQUFBLDBCQUNGLENBQUMsQ0FBQTtJQUNELFVBQVUsOEJBQThCLGlCQUFpQixDQUN2RCxZQUFBLDBCQUNGLENBQUMsQ0FBQTs7O0lBR0QsTUFBTSxPQUFPLENBQUMsVUFBVSxtQkFBbUIsTUFBTSxpQkFBaUIsQ0FBQyxRQUFRLENBQ3pFLENBQUM7OztLQUFZLEtBQUs7TUFDaEIsUUFBUSxJQUFJOztVQUdSLFVBQVUsbUJBQW1CLE9BQU8sQ0FDbEMsRUFBRSxFQUNGLGFBQUEsVUFBUyxTQUFTLG9CQUFvQixFQUN4QyxDQUFDLENBQUE7VUFDRCxNQUFBO09BQ0o7S0FFSixDQUFDLENBQUE7SUFFRCxXQUFXLEVBQUUsQ0FBQTtHQUNmO0NBR0Y7Ozs7Ozs7OztBQVNBLDJCQUEyQjtFQUN6QixNQUFNLE9BQU8sTUFBTSxRQUFRLGNBQWMsRUFBRSxDQUFBO0VBQzNDLE1BQU0sNkJBQTZCLE9BQU8sQ0FDeEMsSUFBSSxLQUFLLENBQUUsT0FBUSxtQkFBbUIsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUNoRCxDQUFDLENBQUE7OztFQUdELE1BQU0sWUFDSixJQUFJLE9BQU8sR0FBRyxDQUFDLElBQ2YsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLElBQ2YsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLFFBQVEsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQTtFQUM3QyxJQUNFLENBQUMsY0FBYyxLQUNkLFNBQVMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUMzQixDQUFDLDBCQUEwQixFQUMzQjtJQUNBLGlCQUFpQixJQUFJLENBQUE7SUFDckIsSUFBSTtNQUNGLE1BQU0saUJBQWlCLFVBQVUsbUJBQW1CLGtCQUFrQixFQUFFLENBQUE7TUFDeEUsTUFBTSxtQkFBbUIsVUFBVSxDQUNoQyxjQUNDLFVBQVUsbUJBQW1CLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxFQUM3RCxjQUNGLENBQUMsQ0FBQTtLQUNGLFNBQVM7TUFDUixpQkFBaUIsS0FBSyxDQUFBO0tBQ3hCO0dBQ0Y7Q0FDRjs7O0FBR0EsTUFBTSx1QkFBdUIsTUFBTTtFQUNqQyxJQUFJLFVBQVUsRUFBRTtJQUNkLFVBQVUsc0JBQXNCLGFBQWEsQ0FBQztNQUM1QyxDQUFDLFlBQUEscUJBQW9CLGVBQWUsR0FBRyxJQUFJLElBQUksRUFBRSxZQUNuQyxFQUFFLE1BQ1IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDakIsQ0FBQyxDQUFBOztJQUNGLFVBQVUsc0JBQXNCLDJCQUEyQixDQUFDO01BQzFELFVBQVUsWUFBQSx5QkFBd0IsSUFBSTtNQUN0QyxPQUFPLFlBQUEscUJBQW9CLGFBQWE7TUFDeEMsWUFBWSxFQUFDO0tBQ2QsQ0FBQyxDQUFBO0lBQ0YsT0FBQTtHQUNGO0VBQ0EsVUFBVSxDQUFDLE1BQU07O0lBRWYsb0JBQW9CLEVBQUUsQ0FBQTtHQUN2QixFQUFFLElBQUksQ0FBQyxDQUFBO0NBQ1QsQ0FBQTs7O0FBR0QscUJBQUEsUUFBTyxRQUFRLFlBQVksWUFBWSxDQUFDLENBQUM7O0NBQVUsS0FBSztFQUN0RCxJQUNFLE1BQU0sS0FBSyxTQUFTLElBQ3BCLEVBQUUsT0FBTyxJQUFJLGVBQWUsSUFBSSxPQUFPLElBQUksUUFBUSxDQUFDLEVBQ3BEO0lBQ0Esb0JBQW9CLEVBQUUsQ0FBQTtJQUN0QixRQUFRLHVCQUF1QixFQUFFLENBQUE7R0FDbkM7Q0FDRCxDQUFDLENBQUE7QUFFRiwwQ0FBMEM7RUFDeEMsTUFBTSxXQUFXLGVBQWUsR0FBRyxZQUFZO0lBQzdDLE1BQU0sWUFBWSxLQUFLLFNBQVMsRUFBRSxDQUFBO0lBQ2xDLE1BQU0sYUFBYSxDQUFBLENBQUEsRUFBQSxPQUFBLFdBQVUsRUFBQztNQUFFLFVBQVUsU0FBQTtLQUFXLEVBQUUsWUFBQSxhQUFZLENBQUMsQ0FBQTtJQUNwRSxPQUFPO01BQ0wsU0FBUyxNQUFNLFVBQVUsVUFBVTtNQUNuQyxPQUFPLFVBQVU7TUFDakIsU0FBUyxRQUFRLFdBQVcsRUFBQztLQUM5QixDQUFBO0dBQ0YsQ0FBQTtDQUNIO0FBRUEsMEJBQTBCO0VBQ3hCLFVBQVUsRUFBRSxNQUFNLENBQUMsU0FBQSxRQUFHLE1BQU0sQ0FBQyxDQUFBO0NBQy9CO0FBRUEsSUFBSSxDQUFDLE9BQU8sSUFBSSwrQkFBK0IsRUFBRTtFQUMvQyxjQUFjLEVBQUUsQ0FBQTtDQUNsQiIsImZpbGUiOiJiYWNrZ3JvdW5kLTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciB1dGlsID0gZXhwb3J0cztcblxuLy8gdXNlZCB0byByZXR1cm4gYSBQcm9taXNlIHdoZXJlIGNhbGxiYWNrIGlzIG9taXR0ZWRcbnV0aWwuYXNQcm9taXNlID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2FzcHJvbWlzZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwuYmFzZTY0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Jhc2U2NFwiKTtcblxuLy8gYmFzZSBjbGFzcyBvZiBycGMuU2VydmljZVxudXRpbC5FdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvZXZlbnRlbWl0dGVyXCIpO1xuXG4vLyBmbG9hdCBoYW5kbGluZyBhY2Nyb3NzIGJyb3dzZXJzXG51dGlsLmZsb2F0ID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2Zsb2F0XCIpO1xuXG4vLyByZXF1aXJlcyBtb2R1bGVzIG9wdGlvbmFsbHkgYW5kIGhpZGVzIHRoZSBjYWxsIGZyb20gYnVuZGxlcnNcbnV0aWwuaW5xdWlyZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9pbnF1aXJlXCIpO1xuXG4vLyBjb252ZXJ0cyB0byAvIGZyb20gdXRmOCBlbmNvZGVkIHN0cmluZ3NcbnV0aWwudXRmOCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy91dGY4XCIpO1xuXG4vLyBwcm92aWRlcyBhIG5vZGUtbGlrZSBidWZmZXIgcG9vbCBpbiB0aGUgYnJvd3NlclxudXRpbC5wb29sID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL3Bvb2xcIik7XG5cbi8vIHV0aWxpdHkgdG8gd29yayB3aXRoIHRoZSBsb3cgYW5kIGhpZ2ggYml0cyBvZiBhIDY0IGJpdCB2YWx1ZVxudXRpbC5Mb25nQml0cyA9IHJlcXVpcmUoXCIuL2xvbmdiaXRzXCIpO1xuXG4vKipcbiAqIFdoZXRoZXIgcnVubmluZyB3aXRoaW4gbm9kZSBvciBub3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHR5cGUge2Jvb2xlYW59XG4gKi9cbnV0aWwuaXNOb2RlID0gQm9vbGVhbih0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9uc1xuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzLnZlcnNpb25zLm5vZGUpO1xuXG4vKipcbiAqIEdsb2JhbCBvYmplY3QgcmVmZXJlbmNlLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnV0aWwuZ2xvYmFsID0gdXRpbC5pc05vZGUgJiYgZ2xvYmFsXG4gICAgICAgICAgIHx8IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93XG4gICAgICAgICAgIHx8IHR5cGVvZiBzZWxmICAgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZlxuICAgICAgICAgICB8fCB0aGlzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWludmFsaWQtdGhpc1xuXG4vKipcbiAqIEFuIGltbXVhYmxlIGVtcHR5IGFycmF5LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtBcnJheS48Kj59XG4gKiBAY29uc3RcbiAqL1xudXRpbC5lbXB0eUFycmF5ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoW10pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIEFuIGltbXV0YWJsZSBlbXB0eSBvYmplY3QuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplID8gT2JqZWN0LmZyZWV6ZSh7fSkgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fTsgLy8gdXNlZCBvbiBwcm90b3R5cGVzXG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGFuIGludGVnZXJcbiAqL1xudXRpbC5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmdcbiAqL1xudXRpbC5pc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCB2YWx1ZSBpcyBhIG5vbi1udWxsIG9iamVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3RcbiAqL1xudXRpbC5pc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIHV0aWwuaXNTZXR9LlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc3NldCA9XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgcHJvcGVydHkgb24gYSBtZXNzYWdlIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogUGxhaW4gb2JqZWN0IG9yIG1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgY29uc2lkZXJlZCB0byBiZSBwcmVzZW50LCBvdGhlcndpc2UgYGZhbHNlYFxuICovXG51dGlsLmlzU2V0ID0gZnVuY3Rpb24gaXNTZXQob2JqLCBwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXEsIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmxlbmd0aCA6IE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGgpID4gMDtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIFRoaXMgaXMgYSBtaW5pbWFsIHN0YW5kLWFsb25lIGRlZmluaXRpb24gb2YgYSBCdWZmZXIgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IG5vZGUncyB0eXBpbmdzLlxuICogQGludGVyZmFjZSBCdWZmZXJcbiAqIEBleHRlbmRzIFVpbnQ4QXJyYXlcbiAqL1xuXG4vKipcbiAqIE5vZGUncyBCdWZmZXIgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPEJ1ZmZlcj59XG4gKi9cbnV0aWwuQnVmZmVyID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBCdWZmZXIgPSB1dGlsLmlucXVpcmUoXCJidWZmZXJcIikuQnVmZmVyO1xuICAgICAgICAvLyByZWZ1c2UgdG8gdXNlIG5vbi1ub2RlIGJ1ZmZlcnMgaWYgbm90IGV4cGxpY2l0bHkgYXNzaWduZWQgKHBlcmYgcmVhc29ucyk6XG4gICAgICAgIHJldHVybiBCdWZmZXIucHJvdG90eXBlLnV0ZjhXcml0ZSA/IEJ1ZmZlciA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIG51bGw7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59KSgpO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZnVsbCBmb3IgQnVmZmVyLmZyb20uXG51dGlsLl9CdWZmZXJfZnJvbSA9IG51bGw7XG5cbi8vIEludGVybmFsIGFsaWFzIG9mIG9yIHBvbHlmaWxsIGZvciBCdWZmZXIuYWxsb2NVbnNhZmUuXG51dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgYnVmZmVyIG9mIHdoYXRldmVyIHR5cGUgc3VwcG9ydGVkIGJ5IHRoZSBlbnZpcm9ubWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBbc2l6ZU9yQXJyYXk9MF0gQnVmZmVyIHNpemUgb3IgbnVtYmVyIGFycmF5XG4gKiBAcmV0dXJucyB7VWludDhBcnJheXxCdWZmZXJ9IEJ1ZmZlclxuICovXG51dGlsLm5ld0J1ZmZlciA9IGZ1bmN0aW9uIG5ld0J1ZmZlcihzaXplT3JBcnJheSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHR5cGVvZiBzaXplT3JBcnJheSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZShzaXplT3JBcnJheSlcbiAgICAgICAgICAgIDogbmV3IHV0aWwuQXJyYXkoc2l6ZU9yQXJyYXkpXG4gICAgICAgIDogdXRpbC5CdWZmZXJcbiAgICAgICAgICAgID8gdXRpbC5fQnVmZmVyX2Zyb20oc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IHR5cGVvZiBVaW50OEFycmF5ID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyBzaXplT3JBcnJheVxuICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkoc2l6ZU9yQXJyYXkpO1xufTtcblxuLyoqXG4gKiBBcnJheSBpbXBsZW1lbnRhdGlvbiB1c2VkIGluIHRoZSBicm93c2VyLiBgVWludDhBcnJheWAgaWYgc3VwcG9ydGVkLCBvdGhlcndpc2UgYEFycmF5YC5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxVaW50OEFycmF5Pn1cbiAqL1xudXRpbC5BcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiID8gVWludDhBcnJheSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA6IEFycmF5O1xuXG4vKipcbiAqIEFueSBjb21wYXRpYmxlIExvbmcgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgTG9uZyBpbnN0YW5jZS4gVGhlIGFjdHVhbCB0eXBlIGlzIHRoYXQgZXhwb3J0ZWQgYnkgbG9uZy5qcy5cbiAqIEBpbnRlcmZhY2UgTG9uZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGxvdyBMb3cgYml0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IGhpZ2ggSGlnaCBiaXRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBMb25nLmpzJ3MgTG9uZyBjbGFzcyBpZiBhdmFpbGFibGUuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8TG9uZz59XG4gKi9cbnV0aWwuTG9uZyA9IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8gJiYgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuZGNvZGVJTy5Mb25nXG4gICAgICAgICB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5Mb25nXG4gICAgICAgICB8fCB1dGlsLmlucXVpcmUoXCJsb25nXCIpO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAyIGJpdCAoYGJvb2xgKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkyUmUgPSAvXnRydWV8ZmFsc2V8MHwxJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDMyIGJpdCAoYGludDMyYCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXkzMlJlID0gL14tPyg/OjB8WzEtOV1bMC05XSopJC87XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9uIHVzZWQgdG8gdmVyaWZ5IDY0IGJpdCAoYGludDY0YCBldGMuKSBtYXAga2V5cy5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKiBAY29uc3RcbiAqL1xudXRpbC5rZXk2NFJlID0gL14oPzpbXFxcXHgwMC1cXFxceGZmXXs4fXwtPyg/OjB8WzEtOV1bMC05XSopKSQvO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgbnVtYmVyIG9yIGxvbmcgdG8gYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBIYXNoXG4gKi9cbnV0aWwubG9uZ1RvSGFzaCA9IGZ1bmN0aW9uIGxvbmdUb0hhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgPyB1dGlsLkxvbmdCaXRzLmZyb20odmFsdWUpLnRvSGFzaCgpXG4gICAgICAgIDogdXRpbC5Mb25nQml0cy56ZXJvSGFzaDtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaCBzdHJpbmcgdG8gYSBsb25nIG9yIG51bWJlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIEhhc2hcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd8bnVtYmVyfSBPcmlnaW5hbCB2YWx1ZVxuICovXG51dGlsLmxvbmdGcm9tSGFzaCA9IGZ1bmN0aW9uIGxvbmdGcm9tSGFzaChoYXNoLCB1bnNpZ25lZCkge1xuICAgIHZhciBiaXRzID0gdXRpbC5Mb25nQml0cy5mcm9tSGFzaChoYXNoKTtcbiAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICByZXR1cm4gdXRpbC5Mb25nLmZyb21CaXRzKGJpdHMubG8sIGJpdHMuaGksIHVuc2lnbmVkKTtcbiAgICByZXR1cm4gYml0cy50b051bWJlcihCb29sZWFuKHVuc2lnbmVkKSk7XG59O1xuXG4vKipcbiAqIE1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdCBpbnRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gc3JjIFNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lmTm90U2V0PWZhbHNlXSBNZXJnZXMgb25seSBpZiB0aGUga2V5IGlzIG5vdCBhbHJlYWR5IHNldFxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXN0aW5hdGlvbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoZHN0LCBzcmMsIGlmTm90U2V0KSB7IC8vIHVzZWQgYnkgY29udmVydGVyc1xuICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcmMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChkc3Rba2V5c1tpXV0gPT09IHVuZGVmaW5lZCB8fCAhaWZOb3RTZXQpXG4gICAgICAgICAgICBkc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgcmV0dXJuIGRzdDtcbn1cblxudXRpbC5tZXJnZSA9IG1lcmdlO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gbG93ZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC5sY0ZpcnN0ID0gZnVuY3Rpb24gbGNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGN1c3RvbSBlcnJvciBjb25zdHJ1Y3Rvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBFcnJvciBuYW1lXG4gKiBAcmV0dXJucyB7Q29uc3RydWN0b3I8RXJyb3I+fSBDdXN0b20gZXJyb3IgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gbmV3RXJyb3IobmFtZSkge1xuXG4gICAgZnVuY3Rpb24gQ3VzdG9tRXJyb3IobWVzc2FnZSwgcHJvcGVydGllcykge1xuXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDdXN0b21FcnJvcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpO1xuXG4gICAgICAgIC8vIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIC8vIF4ganVzdCByZXR1cm5zIGEgbmV3IGVycm9yIGluc3RhbmNlIGJlY2F1c2UgdGhlIGN0b3IgY2FuIGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtZXNzYWdlOyB9IH0pO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgLy8gbm9kZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQ3VzdG9tRXJyb3IpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzdGFja1wiLCB7IHZhbHVlOiBuZXcgRXJyb3IoKS5zdGFjayB8fCBcIlwiIH0pO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgbWVyZ2UodGhpcywgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgKEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBDdXN0b21FcnJvcjtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDdXN0b21FcnJvci5wcm90b3R5cGUsIFwibmFtZVwiLCB7IGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBuYW1lOyB9IH0pO1xuXG4gICAgQ3VzdG9tRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7XG4gICAgfTtcblxuICAgIHJldHVybiBDdXN0b21FcnJvcjtcbn1cblxudXRpbC5uZXdFcnJvciA9IG5ld0Vycm9yO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcHJvdG9jb2wgZXJyb3IuXG4gKiBAY2xhc3NkZXNjIEVycm9yIHN1YmNsYXNzIGluZGljYXRpbmcgYSBwcm90b2NvbCBzcGVjaWZjIGVycm9yLlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBleHRlbmRzIEVycm9yXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgRXJyb3IgbWVzc2FnZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIEFkZGl0aW9uYWwgcHJvcGVydGllc1xuICogQGV4YW1wbGVcbiAqIHRyeSB7XG4gKiAgICAgTXlNZXNzYWdlLmRlY29kZShzb21lQnVmZmVyKTsgLy8gdGhyb3dzIGlmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICogfSBjYXRjaCAoZSkge1xuICogICAgIGlmIChlIGluc3RhbmNlb2YgUHJvdG9jb2xFcnJvciAmJiBlLmluc3RhbmNlKVxuICogICAgICAgICBjb25zb2xlLmxvZyhcImRlY29kZWQgc28gZmFyOiBcIiArIEpTT04uc3RyaW5naWZ5KGUuaW5zdGFuY2UpKTtcbiAqIH1cbiAqL1xudXRpbC5Qcm90b2NvbEVycm9yID0gbmV3RXJyb3IoXCJQcm90b2NvbEVycm9yXCIpO1xuXG4vKipcbiAqIFNvIGZhciBkZWNvZGVkIG1lc3NhZ2UgaW5zdGFuY2UuXG4gKiBAbmFtZSB1dGlsLlByb3RvY29sRXJyb3IjaW5zdGFuY2VcbiAqIEB0eXBlIHtNZXNzYWdlPFQ+fVxuICovXG5cbi8qKlxuICogQSBPbmVPZiBnZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZHZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZHZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBTZXQgZmllbGQgbmFtZSwgaWYgYW55XG4gKi9cblxuLyoqXG4gKiBCdWlsZHMgYSBnZXR0ZXIgZm9yIGEgb25lb2YncyBwcmVzZW50IGZpZWxkIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZHZXR0ZXJ9IFVuYm91bmQgZ2V0dGVyXG4gKi9cbnV0aWwub25lT2ZHZXR0ZXIgPSBmdW5jdGlvbiBnZXRPbmVPZihmaWVsZE5hbWVzKSB7XG4gICAgdmFyIGZpZWxkTWFwID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZE5hbWVzLmxlbmd0aDsgKytpKVxuICAgICAgICBmaWVsZE1hcFtmaWVsZE5hbWVzW2ldXSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID4gLTE7IC0taSlcbiAgICAgICAgICAgIGlmIChmaWVsZE1hcFtrZXlzW2ldXSA9PT0gMSAmJiB0aGlzW2tleXNbaV1dICE9PSB1bmRlZmluZWQgJiYgdGhpc1trZXlzW2ldXSAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5c1tpXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBBIE9uZU9mIHNldHRlciBhcyByZXR1cm5lZCBieSB7QGxpbmsgdXRpbC5vbmVPZlNldHRlcn0uXG4gKiBAdHlwZWRlZiBPbmVPZlNldHRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSB2YWx1ZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgc2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mU2V0dGVyfSBVbmJvdW5kIHNldHRlclxuICovXG51dGlsLm9uZU9mU2V0dGVyID0gZnVuY3Rpb24gc2V0T25lT2YoZmllbGROYW1lcykge1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRmllbGQgbmFtZVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQHRoaXMgT2JqZWN0XG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJldHVybiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWVzW2ldICE9PSBuYW1lKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ZpZWxkTmFtZXNbaV1dO1xuICAgIH07XG59O1xuXG4vKipcbiAqIERlZmF1bHQgY29udmVyc2lvbiBvcHRpb25zIHVzZWQgZm9yIHtAbGluayBNZXNzYWdlI3RvSlNPTn0gaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIFRoZXNlIG9wdGlvbnMgYXJlIGNsb3NlIHRvIHByb3RvMydzIEpTT04gbWFwcGluZyB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpbnRlcm5hbCB0eXBlcyBsaWtlIEFueSBhcmUgaGFuZGxlZCBqdXN0IGxpa2UgbWVzc2FnZXMuIE1vcmUgcHJlY2lzZWx5OlxuICpcbiAqIC0gTG9uZ3MgYmVjb21lIHN0cmluZ3NcbiAqIC0gRW51bXMgYmVjb21lIHN0cmluZyBrZXlzXG4gKiAtIEJ5dGVzIGJlY29tZSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKiAtIChTdWItKU1lc3NhZ2VzIGJlY29tZSBwbGFpbiBvYmplY3RzXG4gKiAtIE1hcHMgYmVjb21lIHBsYWluIG9iamVjdHMgd2l0aCBhbGwgc3RyaW5nIGtleXNcbiAqIC0gUmVwZWF0ZWQgZmllbGRzIGJlY29tZSBhcnJheXNcbiAqIC0gTmFOIGFuZCBJbmZpbml0eSBmb3IgZmxvYXQgYW5kIGRvdWJsZSBmaWVsZHMgYmVjb21lIHN0cmluZ3NcbiAqXG4gKiBAdHlwZSB7SUNvbnZlcnNpb25PcHRpb25zfVxuICogQHNlZSBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9wcm90b2NvbC1idWZmZXJzL2RvY3MvcHJvdG8zP2hsPWVuI2pzb25cbiAqL1xudXRpbC50b0pTT05PcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGpzb246IHRydWVcbn07XG5cbi8vIFNldHMgdXAgYnVmZmVyIHV0aWxpdHkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudCAoY2FsbGVkIGluIGluZGV4LW1pbmltYWwpXG51dGlsLl9jb25maWd1cmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFCdWZmZXIpIHtcbiAgICAgICAgdXRpbC5fQnVmZmVyX2Zyb20gPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGJlY2F1c2Ugbm9kZSA0LnggYnVmZmVycyBhcmUgaW5jb21wYXRpYmxlICYgaW1tdXRhYmxlXG4gICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGNvZGVJTy9wcm90b2J1Zi5qcy9wdWxsLzY2NVxuICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSAmJiBCdWZmZXIuZnJvbSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfZnJvbSh2YWx1ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnVmZmVyKHZhbHVlLCBlbmNvZGluZyk7XG4gICAgICAgIH07XG4gICAgdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gQnVmZmVyLmFsbG9jVW5zYWZlIHx8XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGZ1bmN0aW9uIEJ1ZmZlcl9hbGxvY1Vuc2FmZShzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcihzaXplKTtcbiAgICAgICAgfTtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gdmVyaWZpZXI7XG5cbnZhciBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbmZ1bmN0aW9uIGludmFsaWQoZmllbGQsIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZpZWxkLm5hbWUgKyBcIjogXCIgKyBleHBlY3RlZCArIChmaWVsZC5yZXBlYXRlZCAmJiBleHBlY3RlZCAhPT0gXCJhcnJheVwiID8gXCJbXVwiIDogZmllbGQubWFwICYmIGV4cGVjdGVkICE9PSBcIm9iamVjdFwiID8gXCJ7azpcIitmaWVsZC5rZXlUeXBlK1wifVwiIDogXCJcIikgKyBcIiBleHBlY3RlZFwiO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwgdmFsdWUgdmVyaWZpZXIuXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcbiAqIEBwYXJhbSB7bnVtYmVyfSBmaWVsZEluZGV4IEZpZWxkIGluZGV4XG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmIFZhcmlhYmxlIHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmVyaWZ5VmFsdWUoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcmVmKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbiAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlKSB7XG4gICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSB7IGdlblxuICAgICAgICAgICAgKFwic3dpdGNoKCVzKXtcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcImRlZmF1bHQ6XCIpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiZW51bSB2YWx1ZVwiKSk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlcyksIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7ICsraikgZ2VuXG4gICAgICAgICAgICAgICAgKFwiY2FzZSAlaTpcIiwgZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlc1trZXlzW2pdXSk7XG4gICAgICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIilcbiAgICAgICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZW5cbiAgICAgICAgICAgIChcIntcIilcbiAgICAgICAgICAgICAgICAoXCJ2YXIgZT10eXBlc1slaV0udmVyaWZ5KCVzKTtcIiwgZmllbGRJbmRleCwgcmVmKVxuICAgICAgICAgICAgICAgIChcImlmKGUpXCIpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqK2VcIiwgZmllbGQubmFtZSArIFwiLlwiKVxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCF1dGlsLmlzSW50ZWdlciglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQ2NFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZighdXRpbC5pc0ludGVnZXIoJXMpJiYhKCVzJiZ1dGlsLmlzSW50ZWdlciglcy5sb3cpJiZ1dGlsLmlzSW50ZWdlciglcy5oaWdoKSkpXCIsIHJlZiwgcmVmLCByZWYsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyfExvbmdcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZG91YmxlXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZiAlcyE9PVxcXCJudW1iZXJcXFwiKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwibnVtYmVyXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZiAlcyE9PVxcXCJib29sZWFuXFxcIilcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImJvb2xlYW5cIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZighdXRpbC5pc1N0cmluZyglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJzdHJpbmdcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCEoJXMmJnR5cGVvZiAlcy5sZW5ndGg9PT1cXFwibnVtYmVyXFxcInx8dXRpbC5pc1N0cmluZyglcykpKVwiLCByZWYsIHJlZiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImJ1ZmZlclwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdlbjtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGFydGlhbCBrZXkgdmVyaWZpZXIuXG4gKiBAcGFyYW0ge0NvZGVnZW59IGdlbiBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBSZWZsZWN0ZWQgZmllbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWYgVmFyaWFibGUgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WZXJpZnlLZXkoZ2VuLCBmaWVsZCwgcmVmKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbiAgICBzd2l0Y2ggKGZpZWxkLmtleVR5cGUpIHtcbiAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxuICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOlxuICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXkzMlJlLnRlc3QoJXMpKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJpbnRlZ2VyIGtleVwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgY2FzZSBcInNpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXk2NFJlLnRlc3QoJXMpKVwiLCByZWYpIC8vIHNlZSBjb21tZW50IGFib3ZlOiB4IGlzIG9rLCBkIGlzIG5vdFxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiaW50ZWdlcnxMb25nIGtleVwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJvb2xcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5rZXkyUmUudGVzdCglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImJvb2xlYW4ga2V5XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB2ZXJpZmllciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiB2ZXJpZmllcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG5cbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcIm1cIl0sIG10eXBlLm5hbWUgKyBcIiR2ZXJpZnlcIilcbiAgICAoXCJpZih0eXBlb2YgbSE9PVxcXCJvYmplY3RcXFwifHxtPT09bnVsbClcIilcbiAgICAgICAgKFwicmV0dXJuJWpcIiwgXCJvYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgdmFyIG9uZW9mcyA9IG10eXBlLm9uZW9mc0FycmF5LFxuICAgICAgICBzZWVuRmlyc3RGaWVsZCA9IHt9O1xuICAgIGlmIChvbmVvZnMubGVuZ3RoKSBnZW5cbiAgICAoXCJ2YXIgcD17fVwiKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIHJlZiAgID0gXCJtXCIgKyB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuXG4gICAgICAgIGlmIChmaWVsZC5vcHRpb25hbCkgZ2VuXG4gICAgICAgIChcImlmKCVzIT1udWxsJiZtLmhhc093blByb3BlcnR5KCVqKSl7XCIsIHJlZiwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAvLyBtYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHsgZ2VuXG4gICAgICAgICAgICAoXCJpZighdXRpbC5pc09iamVjdCglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcIm9iamVjdFwiKSlcbiAgICAgICAgICAgIChcInZhciBrPU9iamVjdC5rZXlzKCVzKVwiLCByZWYpXG4gICAgICAgICAgICAoXCJmb3IodmFyIGk9MDtpPGsubGVuZ3RoOysraSl7XCIpO1xuICAgICAgICAgICAgICAgIGdlblZlcmlmeUtleShnZW4sIGZpZWxkLCBcImtbaV1cIik7XG4gICAgICAgICAgICAgICAgZ2VuVmVyaWZ5VmFsdWUoZ2VuLCBmaWVsZCwgaSwgcmVmICsgXCJba1tpXV1cIilcbiAgICAgICAgICAgIChcIn1cIik7XG5cbiAgICAgICAgLy8gcmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG4gICAgICAgICAgICAoXCJpZighQXJyYXkuaXNBcnJheSglcykpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImFycmF5XCIpKVxuICAgICAgICAgICAgKFwiZm9yKHZhciBpPTA7aTwlcy5sZW5ndGg7KytpKXtcIiwgcmVmKTtcbiAgICAgICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYgKyBcIltpXVwiKVxuICAgICAgICAgICAgKFwifVwiKTtcblxuICAgICAgICAvLyByZXF1aXJlZCBvciBwcmVzZW50IGZpZWxkc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpZWxkLnBhcnRPZikge1xuICAgICAgICAgICAgICAgIHZhciBvbmVvZlByb3AgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLnBhcnRPZi5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbkZpcnN0RmllbGRbZmllbGQucGFydE9mLm5hbWVdID09PSAxKSBnZW5cbiAgICAgICAgICAgIChcImlmKHAlcz09PTEpXCIsIG9uZW9mUHJvcClcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBmaWVsZC5wYXJ0T2YubmFtZSArIFwiOiBtdWx0aXBsZSB2YWx1ZXNcIik7XG4gICAgICAgICAgICAgICAgc2VlbkZpcnN0RmllbGRbZmllbGQucGFydE9mLm5hbWVdID0gMTtcbiAgICAgICAgICAgICAgICBnZW5cbiAgICAgICAgICAgIChcInAlcz0xXCIsIG9uZW9mUHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5WZXJpZnlWYWx1ZShnZW4sIGZpZWxkLCBpLCByZWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZC5vcHRpb25hbCkgZ2VuXG4gICAgICAgIChcIn1cIik7XG4gICAgfVxuICAgIHJldHVybiBnZW5cbiAgICAoXCJyZXR1cm4gbnVsbFwiKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogV3JhcHBlcnMgZm9yIGNvbW1vbiB0eXBlcy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxJV3JhcHBlcj59XG4gKiBAY29uc3RcbiAqL1xudmFyIHdyYXBwZXJzID0gZXhwb3J0cztcblxudmFyIE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlXCIpO1xuXG4vKipcbiAqIEZyb20gb2JqZWN0IGNvbnZlcnRlciBwYXJ0IG9mIGFuIHtAbGluayBJV3JhcHBlcn0uXG4gKiBAdHlwZWRlZiBXcmFwcGVyRnJvbU9iamVjdENvbnZlcnRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAdGhpcyBUeXBlXG4gKi9cblxuLyoqXG4gKiBUbyBvYmplY3QgY29udmVydGVyIHBhcnQgb2YgYW4ge0BsaW5rIElXcmFwcGVyfS5cbiAqIEB0eXBlZGVmIFdyYXBwZXJUb09iamVjdENvbnZlcnRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXNzYWdlPHt9Pn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0lDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAqIEB0aGlzIFR5cGVcbiAqL1xuXG4vKipcbiAqIENvbW1vbiB0eXBlIHdyYXBwZXIgcGFydCBvZiB7QGxpbmsgd3JhcHBlcnN9LlxuICogQGludGVyZmFjZSBJV3JhcHBlclxuICogQHByb3BlcnR5IHtXcmFwcGVyRnJvbU9iamVjdENvbnZlcnRlcn0gW2Zyb21PYmplY3RdIEZyb20gb2JqZWN0IGNvbnZlcnRlclxuICogQHByb3BlcnR5IHtXcmFwcGVyVG9PYmplY3RDb252ZXJ0ZXJ9IFt0b09iamVjdF0gVG8gb2JqZWN0IGNvbnZlcnRlclxuICovXG5cbi8vIEN1c3RvbSB3cmFwcGVyIGZvciBBbnlcbndyYXBwZXJzW1wiLmdvb2dsZS5wcm90b2J1Zi5BbnlcIl0gPSB7XG5cbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgICAvLyB1bndyYXAgdmFsdWUgdHlwZSBpZiBtYXBwZWRcbiAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3RbXCJAdHlwZVwiXSkge1xuICAgICAgICAgICAgIC8vIE9ubHkgdXNlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIG5hbWUgYWZ0ZXIgdGhlIGxhc3QgJy8nXG4gICAgICAgICAgICB2YXIgbmFtZSA9IG9iamVjdFtcIkB0eXBlXCJdLnN1YnN0cmluZyhvYmplY3RbXCJAdHlwZVwiXS5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyB0eXBlX3VybCBkb2VzIG5vdCBhY2NlcHQgbGVhZGluZyBcIi5cIlxuICAgICAgICAgICAgICAgIHZhciB0eXBlX3VybCA9IG9iamVjdFtcIkB0eXBlXCJdLmNoYXJBdCgwKSA9PT0gXCIuXCIgP1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbXCJAdHlwZVwiXS5zdWJzdHIoMSkgOiBvYmplY3RbXCJAdHlwZVwiXTtcbiAgICAgICAgICAgICAgICAvLyB0eXBlX3VybCBwcmVmaXggaXMgb3B0aW9uYWwsIGJ1dCBwYXRoIHNlcGVyYXRvciBpcyByZXF1aXJlZFxuICAgICAgICAgICAgICAgIGlmICh0eXBlX3VybC5pbmRleE9mKFwiL1wiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZV91cmwgPSBcIi9cIiArIHR5cGVfdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlX3VybDogdHlwZV91cmwsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0eXBlLmVuY29kZSh0eXBlLmZyb21PYmplY3Qob2JqZWN0KSkuZmluaXNoKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZyb21PYmplY3Qob2JqZWN0KTtcbiAgICB9LFxuXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKG1lc3NhZ2UsIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBEZWZhdWx0IHByZWZpeFxuICAgICAgICB2YXIgZ29vZ2xlQXBpID0gXCJ0eXBlLmdvb2dsZWFwaXMuY29tL1wiO1xuICAgICAgICB2YXIgcHJlZml4ID0gXCJcIjtcbiAgICAgICAgdmFyIG5hbWUgPSBcIlwiO1xuXG4gICAgICAgIC8vIGRlY29kZSB2YWx1ZSBpZiByZXF1ZXN0ZWQgYW5kIHVubWFwcGVkXG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuanNvbiAmJiBtZXNzYWdlLnR5cGVfdXJsICYmIG1lc3NhZ2UudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdXNlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIG5hbWUgYWZ0ZXIgdGhlIGxhc3QgJy8nXG4gICAgICAgICAgICBuYW1lID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcobWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIC8vIFNlcGFyYXRlIHRoZSBwcmVmaXggdXNlZFxuICAgICAgICAgICAgcHJlZml4ID0gbWVzc2FnZS50eXBlX3VybC5zdWJzdHJpbmcoMCwgbWVzc2FnZS50eXBlX3VybC5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHR5cGUpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHR5cGUuZGVjb2RlKG1lc3NhZ2UudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd3JhcCB2YWx1ZSBpZiB1bm1hcHBlZFxuICAgICAgICBpZiAoIShtZXNzYWdlIGluc3RhbmNlb2YgdGhpcy5jdG9yKSAmJiBtZXNzYWdlIGluc3RhbmNlb2YgTWVzc2FnZSkge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG1lc3NhZ2UuJHR5cGUudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZU5hbWUgPSBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lWzBdID09PSBcIi5cIiA/XG4gICAgICAgICAgICAgICAgbWVzc2FnZS4kdHlwZS5mdWxsTmFtZS5zdWJzdHIoMSkgOiBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lO1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0eXBlLmdvb2dsZWFwaXMuY29tIHByZWZpeCBpZiBubyBwcmVmaXggaXMgdXNlZFxuICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9IGdvb2dsZUFwaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWUgPSBwcmVmaXggKyBtZXNzYWdlTmFtZTtcbiAgICAgICAgICAgIG9iamVjdFtcIkB0eXBlXCJdID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy50b09iamVjdChtZXNzYWdlLCBvcHRpb25zKTtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlcldyaXRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIGJhc2U2NCAgICA9IHV0aWwuYmFzZTY0LFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIFVpbnQ4QXJyYXksIG51bWJlcil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIE9wKGZuLCBsZW4sIHZhbCkge1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX1cbiAgICAgKi9cbiAgICB0aGlzLmZuID0gZm47XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBieXRlIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gbGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1dyaXRlci5PcHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy52YWwgPSB2YWw7IC8vIHR5cGUgdmFyaWVzXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBub29wKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIHN0YXRlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBDb3BpZWQgd3JpdGVyIHN0YXRlLlxuICogQG1lbWJlcm9mIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dyaXRlcn0gd3JpdGVyIFdyaXRlciB0byBjb3B5IHN0YXRlIGZyb21cbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gU3RhdGUod3JpdGVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhlYWQuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSB3cml0ZXIuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdGFpbC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHdyaXRlci50YWlsO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSB3cml0ZXIubGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7U3RhdGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB3cml0ZXIuc3RhdGVzO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV3JpdGVyKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIGhlYWQuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIHRhaWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIExpbmtlZCBmb3JrZWQgc3RhdGVzLlxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XG5cbiAgICAvLyBXaGVuIGEgdmFsdWUgaXMgd3JpdHRlbiwgdGhlIHdyaXRlciBjYWxjdWxhdGVzIGl0cyBieXRlIGxlbmd0aCBhbmQgcHV0cyBpdCBpbnRvIGEgbGlua2VkXG4gICAgLy8gbGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm0gd2hlbiBmaW5pc2goKSBpcyBjYWxsZWQuIFRoaXMgYm90aCBhbGxvd3MgdXMgdG8gYWxsb2NhdGVcbiAgICAvLyBidWZmZXJzIG9mIHRoZSBleGFjdCByZXF1aXJlZCBzaXplIGFuZCByZWR1Y2VzIHRoZSBhbW91bnQgb2Ygd29yayB3ZSBoYXZlIHRvIGRvIGNvbXBhcmVkXG4gICAgLy8gdG8gZmlyc3QgY2FsY3VsYXRpbmcgb3ZlciBvYmplY3RzIGFuZCB0aGVuIGVuY29kaW5nIG92ZXIgb2JqZWN0cy4gSW4gb3VyIGNhc2UsIHRoZSBlbmNvZGluZ1xuICAgIC8vIHBhcnQgaXMganVzdCBhIGxpbmtlZCBsaXN0IHdhbGsgY2FsbGluZyBvcGVyYXRpb25zIHdpdGggYWxyZWFkeSBwcmVwYXJlZCB2YWx1ZXMuXG59XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoV3JpdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlcigpO1xuICAgICAgICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHdyaXRlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcnxXcml0ZXJ9IEEge0BsaW5rIEJ1ZmZlcldyaXRlcn0gd2hlbiBCdWZmZXJzIGFyZSBzdXBwb3J0ZWQsIG90aGVyd2lzZSBhIHtAbGluayBXcml0ZXJ9XG4gKi9cbldyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuLyoqXG4gKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcbiAqL1xuV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSkge1xuICAgIHJldHVybiBuZXcgdXRpbC5BcnJheShzaXplKTtcbn07XG5cbi8vIFVzZSBVaW50OEFycmF5IGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyLCBqdXN0IGxpa2Ugbm9kZSBkb2VzIHdpdGggYnVmZmVyc1xuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh1dGlsLkFycmF5ICE9PSBBcnJheSlcbiAgICBXcml0ZXIuYWxsb2MgPSB1dGlsLnBvb2woV3JpdGVyLmFsbG9jLCB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSk7XG5cbi8qKlxuICogUHVzaGVzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHByaXZhdGVcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIHB1c2goZm4sIGxlbiwgdmFsKSB7XG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgT3AoZm4sIGxlbiwgdmFsKTtcbiAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUJ5dGUodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xufVxuXG5mdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwgJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbCA+Pj49IDc7XG4gICAgfVxuICAgIGJ1Zltwb3NdID0gdmFsO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgdmFyaW50IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBleHRlbmRzIE9wXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gVmFyaW50T3AobGVuLCB2YWwpIHtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52YWwgPSB2YWw7XG59XG5cblZhcmludE9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKTtcblZhcmludE9wLnByb3RvdHlwZS5mbiA9IHdyaXRlVmFyaW50MzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24gd3JpdGVfdWludDMyKHZhbHVlKSB7XG4gICAgLy8gaGVyZSwgdGhlIGNhbGwgdG8gdGhpcy5wdXNoIGhhcyBiZWVuIGlubGluZWQgYW5kIGEgdmFyaW50IHNwZWNpZmljIE9wIHN1YmNsYXNzIGlzIHVzZWQuXG4gICAgLy8gdWludDMyIGlzIGJ5IGZhciB0aGUgbW9zdCBmcmVxdWVudGx5IHVzZWQgb3BlcmF0aW9uIGFuZCBiZW5lZml0cyBzaWduaWZpY2FudGx5IGZyb20gdGhpcy5cbiAgICB0aGlzLmxlbiArPSAodGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgVmFyaW50T3AoXG4gICAgICAgICh2YWx1ZSA9IHZhbHVlID4+PiAwKVxuICAgICAgICAgICAgICAgIDwgMTI4ICAgICAgID8gMVxuICAgICAgICA6IHZhbHVlIDwgMTYzODQgICAgID8gMlxuICAgICAgICA6IHZhbHVlIDwgMjA5NzE1MiAgID8gM1xuICAgICAgICA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNFxuICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICB2YWx1ZSkpLmxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMFxuICAgICAgICA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSAvLyAxMCBieXRlcyBwZXIgc3BlY1xuICAgICAgICA6IHRoaXMudWludDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVZhcmludDY0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsLmhpKSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9ICh2YWwubG8gPj4+IDcgfCB2YWwuaGkgPDwgMjUpID4+PiAwO1xuICAgICAgICB2YWwuaGkgPj4+PSA3O1xuICAgIH1cbiAgICB3aGlsZSAodmFsLmxvID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9IHZhbC5sbyA+Pj4gNztcbiAgICB9XG4gICAgYnVmW3BvcysrXSA9IHZhbC5sbztcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gd3JpdGVfdWludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50NjQgPSBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50NjQgPSBmdW5jdGlvbiB3cml0ZV9zaW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGJvb2xpc2ggdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gd3JpdGVfYm9vbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICAmIDI1NTtcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkMzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIHZhbHVlID4+PiAwKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDMyID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkNjQgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgZmxvYXQgKDMyIGJpdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiB3cml0ZV9kb3VibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHZhbHVlKTtcbn07XG5cbnZhciB3cml0ZUJ5dGVzID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc2V0XG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XG4gICAgfTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzZXF1ZW5jZSBvZiBieXRlcy5cbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IHZhbHVlIEJ1ZmZlciBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXModmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIGlmICghbGVuKVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcbiAgICAgICAgYmFzZTY0LmRlY29kZSh2YWx1ZSwgYnVmLCAwKTtcbiAgICAgICAgdmFsdWUgPSBidWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHdyaXRlQnl0ZXMsIGxlbiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCh2YWx1ZSk7XG4gICAgcmV0dXJuIGxlblxuICAgICAgICA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSlcbiAgICAgICAgOiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG59O1xuXG4vKipcbiAqIEZvcmtzIHRoaXMgd3JpdGVyJ3Mgc3RhdGUgYnkgcHVzaGluZyBpdCB0byBhIHN0YWNrLlxuICogQ2FsbGluZyB7QGxpbmsgV3JpdGVyI3Jlc2V0fHJlc2V0fSBvciB7QGxpbmsgV3JpdGVyI2xkZWxpbXxsZGVsaW19IHJlc2V0cyB0aGUgd3JpdGVyIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlKHRoaXMpO1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICB0aGlzLmxlbiA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIHRvIHRoZSBsYXN0IHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5oZWFkICAgPSB0aGlzLnN0YXRlcy5oZWFkO1xuICAgICAgICB0aGlzLnRhaWwgICA9IHRoaXMuc3RhdGVzLnRhaWw7XG4gICAgICAgIHRoaXMubGVuICAgID0gdGhpcy5zdGF0ZXMubGVuO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgICB0aGlzLmxlbiAgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRvIHRoZSBsYXN0IHN0YXRlIGFuZCBhcHBlbmRzIHRoZSBmb3JrIHN0YXRlJ3MgY3VycmVudCB3cml0ZSBsZW5ndGggYXMgYSB2YXJpbnQgZm9sbG93ZWQgYnkgaXRzIG9wZXJhdGlvbnMuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5sZGVsaW0gPSBmdW5jdGlvbiBsZGVsaW0oKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsXG4gICAgICAgIHRhaWwgPSB0aGlzLnRhaWwsXG4gICAgICAgIGxlbiAgPSB0aGlzLmxlbjtcbiAgICB0aGlzLnJlc2V0KCkudWludDMyKGxlbik7XG4gICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGhlYWQubmV4dDsgLy8gc2tpcCBub29wXG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gRmluaXNoZWQgYnVmZmVyXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLm5leHQsIC8vIHNraXAgbm9vcFxuICAgICAgICBidWYgID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksXG4gICAgICAgIHBvcyAgPSAwO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICAgIGhlYWQuZm4oaGVhZC52YWwsIGJ1ZiwgcG9zKTtcbiAgICAgICAgcG9zICs9IGhlYWQubGVuO1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICAvLyB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHJldHVybiBidWY7XG59O1xuXG5Xcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlcldyaXRlcl8pIHtcbiAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xuICAgIFdyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJXcml0ZXI7XG5cbi8vIGV4dGVuZHMgV3JpdGVyXG52YXIgV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xuKEJ1ZmZlcldyaXRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFdyaXRlci5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEJ1ZmZlcldyaXRlcjtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBidWZmZXIgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgbm9kZSBidWZmZXJzLlxuICogQGV4dGVuZHMgV3JpdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQnVmZmVyV3JpdGVyKCkge1xuICAgIFdyaXRlci5jYWxsKHRoaXMpO1xufVxuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIEJ1ZmZlciBzaXplXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gQnVmZmVyXG4gICAgICovXG4gICAgQnVmZmVyV3JpdGVyLmFsbG9jID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlO1xuXG4gICAgQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIgPSB1dGlsLkJ1ZmZlciAmJiB1dGlsLkJ1ZmZlci5wcm90b3R5cGUgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZS5zZXQubmFtZSA9PT0gXCJzZXRcIlxuICAgICAgICA/IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfc2V0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgICBidWYuc2V0KHZhbCwgcG9zKTsgLy8gZmFzdGVyIHRoYW4gY29weSAocmVxdWlyZXMgbm9kZSA+PSA0IHdoZXJlIEJ1ZmZlcnMgZXh0ZW5kIFVpbnQ4QXJyYXkgYW5kIHNldCBpcyBwcm9wZXJseSBpbmhlcml0ZWQpXG4gICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiB3cml0ZUJ5dGVzQnVmZmVyX2NvcHkodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGlmICh2YWwuY29weSkgLy8gQnVmZmVyIHZhbHVlc1xuICAgICAgICAgICAgdmFsLmNvcHkoYnVmLCBwb3MsIDAsIHZhbC5sZW5ndGgpO1xuICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOykgLy8gcGxhaW4gYXJyYXkgdmFsdWVzXG4gICAgICAgICAgICBidWZbcG9zKytdID0gdmFsW2krK107XG4gICAgICAgIH07XG59O1xuXG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkJ1ZmZlcldyaXRlci5wcm90b3R5cGUuYnl0ZXMgPSBmdW5jdGlvbiB3cml0ZV9ieXRlc19idWZmZXIodmFsdWUpIHtcbiAgICBpZiAodXRpbC5pc1N0cmluZyh2YWx1ZSkpXG4gICAgICAgIHZhbHVlID0gdXRpbC5fQnVmZmVyX2Zyb20odmFsdWUsIFwiYmFzZTY0XCIpO1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGggPj4+IDA7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKEJ1ZmZlcldyaXRlci53cml0ZUJ5dGVzQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHdyaXRlU3RyaW5nQnVmZmVyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA8IDQwKSAvLyBwbGFpbiBqcyBpcyBmYXN0ZXIgZm9yIHNob3J0IHN0cmluZ3MgKHByb2JhYmx5IGR1ZSB0byByZWR1bmRhbnQgYXNzZXJ0aW9ucylcbiAgICAgICAgdXRpbC51dGY4LndyaXRlKHZhbCwgYnVmLCBwb3MpO1xuICAgIGVsc2UgaWYgKGJ1Zi51dGY4V3JpdGUpXG4gICAgICAgIGJ1Zi51dGY4V3JpdGUodmFsLCBwb3MpO1xuICAgIGVsc2VcbiAgICAgICAgYnVmLndyaXRlKHZhbCwgcG9zKTtcbn1cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5zdHJpbmcgPSBmdW5jdGlvbiB3cml0ZV9zdHJpbmdfYnVmZmVyKHZhbHVlKSB7XG4gICAgdmFyIGxlbiA9IHV0aWwuQnVmZmVyLmJ5dGVMZW5ndGgodmFsdWUpO1xuICAgIHRoaXMudWludDMyKGxlbik7XG4gICAgaWYgKGxlbilcbiAgICAgICAgdGhpcy5fcHVzaCh3cml0ZVN0cmluZ0J1ZmZlciwgbGVuLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogRmluaXNoZXMgdGhlIHdyaXRlIG9wZXJhdGlvbi5cbiAqIEBuYW1lIEJ1ZmZlcldyaXRlciNmaW5pc2hcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gRmluaXNoZWQgYnVmZmVyXG4gKi9cblxuQnVmZmVyV3JpdGVyLl9jb25maWd1cmUoKTtcbiIsInZhciBPUFMgPSByZXF1aXJlKCdiaXRjb2luLW9wcycpXG5cbmZ1bmN0aW9uIGVuY29kaW5nTGVuZ3RoIChpKSB7XG4gIHJldHVybiBpIDwgT1BTLk9QX1BVU0hEQVRBMSA/IDFcbiAgOiBpIDw9IDB4ZmYgPyAyXG4gIDogaSA8PSAweGZmZmYgPyAzXG4gIDogNVxufVxuXG5mdW5jdGlvbiBlbmNvZGUgKGJ1ZmZlciwgbnVtYmVyLCBvZmZzZXQpIHtcbiAgdmFyIHNpemUgPSBlbmNvZGluZ0xlbmd0aChudW1iZXIpXG5cbiAgLy8gfjYgYml0XG4gIGlmIChzaXplID09PSAxKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgobnVtYmVyLCBvZmZzZXQpXG5cbiAgLy8gOCBiaXRcbiAgfSBlbHNlIGlmIChzaXplID09PSAyKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoT1BTLk9QX1BVU0hEQVRBMSwgb2Zmc2V0KVxuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KG51bWJlciwgb2Zmc2V0ICsgMSlcblxuICAvLyAxNiBiaXRcbiAgfSBlbHNlIGlmIChzaXplID09PSAzKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgoT1BTLk9QX1BVU0hEQVRBMiwgb2Zmc2V0KVxuICAgIGJ1ZmZlci53cml0ZVVJbnQxNkxFKG51bWJlciwgb2Zmc2V0ICsgMSlcblxuICAvLyAzMiBiaXRcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OChPUFMuT1BfUFVTSERBVEE0LCBvZmZzZXQpXG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUobnVtYmVyLCBvZmZzZXQgKyAxKVxuICB9XG5cbiAgcmV0dXJuIHNpemVcbn1cblxuZnVuY3Rpb24gZGVjb2RlIChidWZmZXIsIG9mZnNldCkge1xuICB2YXIgb3Bjb2RlID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpXG4gIHZhciBudW1iZXIsIHNpemVcblxuICAvLyB+NiBiaXRcbiAgaWYgKG9wY29kZSA8IE9QUy5PUF9QVVNIREFUQTEpIHtcbiAgICBudW1iZXIgPSBvcGNvZGVcbiAgICBzaXplID0gMVxuXG4gIC8vIDggYml0XG4gIH0gZWxzZSBpZiAob3Bjb2RlID09PSBPUFMuT1BfUFVTSERBVEExKSB7XG4gICAgaWYgKG9mZnNldCArIDIgPiBidWZmZXIubGVuZ3RoKSByZXR1cm4gbnVsbFxuICAgIG51bWJlciA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0ICsgMSlcbiAgICBzaXplID0gMlxuXG4gIC8vIDE2IGJpdFxuICB9IGVsc2UgaWYgKG9wY29kZSA9PT0gT1BTLk9QX1BVU0hEQVRBMikge1xuICAgIGlmIChvZmZzZXQgKyAzID4gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIG51bGxcbiAgICBudW1iZXIgPSBidWZmZXIucmVhZFVJbnQxNkxFKG9mZnNldCArIDEpXG4gICAgc2l6ZSA9IDNcblxuICAvLyAzMiBiaXRcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgNSA+IGJ1ZmZlci5sZW5ndGgpIHJldHVybiBudWxsXG4gICAgaWYgKG9wY29kZSAhPT0gT1BTLk9QX1BVU0hEQVRBNCkgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIG9wY29kZScpXG5cbiAgICBudW1iZXIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDEpXG4gICAgc2l6ZSA9IDVcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3Bjb2RlOiBvcGNvZGUsXG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgc2l6ZTogc2l6ZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBlbmNvZGluZ0xlbmd0aDogZW5jb2RpbmdMZW5ndGgsXG4gIGVuY29kZTogZW5jb2RlLFxuICBkZWNvZGU6IGRlY29kZVxufVxuIiwiXG4vKipcbiAqIFJlbW92ZSB0cmFpbGluZyBzbGFzaGVzIGZyb20gdGhlIGdpdmVuIGBzdHJgXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShleHBvcnRzLmV4cHIsICcnKTtcbn07XG5cbi8qKlxuICogRXhwb3NlIHRoZSByZWdleFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuZXhwb3J0cy5leHByID0gL1xcLyskLztcbiIsIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSByZmRjXG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIgKGN1cikge1xuICBpZiAoY3VyIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGN1cilcbiAgfVxuXG4gIHJldHVybiBuZXcgY3VyLmNvbnN0cnVjdG9yKGN1ci5idWZmZXIuc2xpY2UoKSwgY3VyLmJ5dGVPZmZzZXQsIGN1ci5sZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHJmZGMgKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBpZiAob3B0cy5jaXJjbGVzKSByZXR1cm4gcmZkY0NpcmNsZXMob3B0cylcbiAgcmV0dXJuIG9wdHMucHJvdG8gPyBjbG9uZVByb3RvIDogY2xvbmVcblxuICBmdW5jdGlvbiBjbG9uZUFycmF5IChhLCBmbikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYSlcbiAgICB2YXIgYTIgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgayA9IGtleXNbaV1cbiAgICAgIHZhciBjdXIgPSBhW2tdXG4gICAgICBpZiAodHlwZW9mIGN1ciAhPT0gJ29iamVjdCcgfHwgY3VyID09PSBudWxsKSB7XG4gICAgICAgIGEyW2tdID0gY3VyXG4gICAgICB9IGVsc2UgaWYgKGN1ciBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgYTJba10gPSBuZXcgRGF0ZShjdXIpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjdXIpKSB7XG4gICAgICAgIGEyW2tdID0gY29weUJ1ZmZlcihjdXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhMltrXSA9IGZuKGN1cilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGEyXG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZSAobykge1xuICAgIGlmICh0eXBlb2YgbyAhPT0gJ29iamVjdCcgfHwgbyA9PT0gbnVsbCkgcmV0dXJuIG9cbiAgICBpZiAobyBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBuZXcgRGF0ZShvKVxuICAgIGlmIChBcnJheS5pc0FycmF5KG8pKSByZXR1cm4gY2xvbmVBcnJheShvLCBjbG9uZSlcbiAgICBpZiAobyBpbnN0YW5jZW9mIE1hcCkgcmV0dXJuIG5ldyBNYXAoY2xvbmVBcnJheShBcnJheS5mcm9tKG8pLCBjbG9uZSkpXG4gICAgaWYgKG8gaW5zdGFuY2VvZiBTZXQpIHJldHVybiBuZXcgU2V0KGNsb25lQXJyYXkoQXJyYXkuZnJvbShvKSwgY2xvbmUpKVxuICAgIHZhciBvMiA9IHt9XG4gICAgZm9yICh2YXIgayBpbiBvKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobywgaykgPT09IGZhbHNlKSBjb250aW51ZVxuICAgICAgdmFyIGN1ciA9IG9ba11cbiAgICAgIGlmICh0eXBlb2YgY3VyICE9PSAnb2JqZWN0JyB8fCBjdXIgPT09IG51bGwpIHtcbiAgICAgICAgbzJba10gPSBjdXJcbiAgICAgIH0gZWxzZSBpZiAoY3VyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvMltrXSA9IG5ldyBEYXRlKGN1cilcbiAgICAgIH0gZWxzZSBpZiAoY3VyIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG8yW2tdID0gbmV3IE1hcChjbG9uZUFycmF5KEFycmF5LmZyb20oY3VyKSwgY2xvbmUpKVxuICAgICAgfSBlbHNlIGlmIChjdXIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgbzJba10gPSBuZXcgU2V0KGNsb25lQXJyYXkoQXJyYXkuZnJvbShjdXIpLCBjbG9uZSkpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjdXIpKSB7XG4gICAgICAgIG8yW2tdID0gY29weUJ1ZmZlcihjdXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvMltrXSA9IGNsb25lKGN1cilcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG8yXG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZVByb3RvIChvKSB7XG4gICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0JyB8fCBvID09PSBudWxsKSByZXR1cm4gb1xuICAgIGlmIChvIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIG5ldyBEYXRlKG8pXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHJldHVybiBjbG9uZUFycmF5KG8sIGNsb25lUHJvdG8pXG4gICAgaWYgKG8gaW5zdGFuY2VvZiBNYXApIHJldHVybiBuZXcgTWFwKGNsb25lQXJyYXkoQXJyYXkuZnJvbShvKSwgY2xvbmVQcm90bykpXG4gICAgaWYgKG8gaW5zdGFuY2VvZiBTZXQpIHJldHVybiBuZXcgU2V0KGNsb25lQXJyYXkoQXJyYXkuZnJvbShvKSwgY2xvbmVQcm90bykpXG4gICAgdmFyIG8yID0ge31cbiAgICBmb3IgKHZhciBrIGluIG8pIHtcbiAgICAgIHZhciBjdXIgPSBvW2tdXG4gICAgICBpZiAodHlwZW9mIGN1ciAhPT0gJ29iamVjdCcgfHwgY3VyID09PSBudWxsKSB7XG4gICAgICAgIG8yW2tdID0gY3VyXG4gICAgICB9IGVsc2UgaWYgKGN1ciBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgbzJba10gPSBuZXcgRGF0ZShjdXIpXG4gICAgICB9IGVsc2UgaWYgKGN1ciBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBvMltrXSA9IG5ldyBNYXAoY2xvbmVBcnJheShBcnJheS5mcm9tKGN1ciksIGNsb25lUHJvdG8pKVxuICAgICAgfSBlbHNlIGlmIChjdXIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgbzJba10gPSBuZXcgU2V0KGNsb25lQXJyYXkoQXJyYXkuZnJvbShjdXIpLCBjbG9uZVByb3RvKSlcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGN1cikpIHtcbiAgICAgICAgbzJba10gPSBjb3B5QnVmZmVyKGN1cilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8yW2tdID0gY2xvbmVQcm90byhjdXIpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvMlxuICB9XG59XG5cbmZ1bmN0aW9uIHJmZGNDaXJjbGVzIChvcHRzKSB7XG4gIHZhciByZWZzID0gW11cbiAgdmFyIHJlZnNOZXcgPSBbXVxuXG4gIHJldHVybiBvcHRzLnByb3RvID8gY2xvbmVQcm90byA6IGNsb25lXG5cbiAgZnVuY3Rpb24gY2xvbmVBcnJheSAoYSwgZm4pIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGEpXG4gICAgdmFyIGEyID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGsgPSBrZXlzW2ldXG4gICAgICB2YXIgY3VyID0gYVtrXVxuICAgICAgaWYgKHR5cGVvZiBjdXIgIT09ICdvYmplY3QnIHx8IGN1ciA9PT0gbnVsbCkge1xuICAgICAgICBhMltrXSA9IGN1clxuICAgICAgfSBlbHNlIGlmIChjdXIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGEyW2tdID0gbmV3IERhdGUoY3VyKVxuICAgICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoY3VyKSkge1xuICAgICAgICBhMltrXSA9IGNvcHlCdWZmZXIoY3VyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVmcy5pbmRleE9mKGN1cilcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIGEyW2tdID0gcmVmc05ld1tpbmRleF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhMltrXSA9IGZuKGN1cilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTJcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lIChvKSB7XG4gICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0JyB8fCBvID09PSBudWxsKSByZXR1cm4gb1xuICAgIGlmIChvIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIG5ldyBEYXRlKG8pXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHJldHVybiBjbG9uZUFycmF5KG8sIGNsb25lKVxuICAgIGlmIChvIGluc3RhbmNlb2YgTWFwKSByZXR1cm4gbmV3IE1hcChjbG9uZUFycmF5KEFycmF5LmZyb20obyksIGNsb25lKSlcbiAgICBpZiAobyBpbnN0YW5jZW9mIFNldCkgcmV0dXJuIG5ldyBTZXQoY2xvbmVBcnJheShBcnJheS5mcm9tKG8pLCBjbG9uZSkpXG4gICAgdmFyIG8yID0ge31cbiAgICByZWZzLnB1c2gobylcbiAgICByZWZzTmV3LnB1c2gobzIpXG4gICAgZm9yICh2YXIgayBpbiBvKSB7XG4gICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobywgaykgPT09IGZhbHNlKSBjb250aW51ZVxuICAgICAgdmFyIGN1ciA9IG9ba11cbiAgICAgIGlmICh0eXBlb2YgY3VyICE9PSAnb2JqZWN0JyB8fCBjdXIgPT09IG51bGwpIHtcbiAgICAgICAgbzJba10gPSBjdXJcbiAgICAgIH0gZWxzZSBpZiAoY3VyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBvMltrXSA9IG5ldyBEYXRlKGN1cilcbiAgICAgIH0gZWxzZSBpZiAoY3VyIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIG8yW2tdID0gbmV3IE1hcChjbG9uZUFycmF5KEFycmF5LmZyb20oY3VyKSwgY2xvbmUpKVxuICAgICAgfSBlbHNlIGlmIChjdXIgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgbzJba10gPSBuZXcgU2V0KGNsb25lQXJyYXkoQXJyYXkuZnJvbShjdXIpLCBjbG9uZSkpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjdXIpKSB7XG4gICAgICAgIG8yW2tdID0gY29weUJ1ZmZlcihjdXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IHJlZnMuaW5kZXhPZihjdXIpXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgIG8yW2tdID0gcmVmc05ld1tpXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8yW2tdID0gY2xvbmUoY3VyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJlZnMucG9wKClcbiAgICByZWZzTmV3LnBvcCgpXG4gICAgcmV0dXJuIG8yXG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZVByb3RvIChvKSB7XG4gICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0JyB8fCBvID09PSBudWxsKSByZXR1cm4gb1xuICAgIGlmIChvIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIG5ldyBEYXRlKG8pXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHJldHVybiBjbG9uZUFycmF5KG8sIGNsb25lUHJvdG8pXG4gICAgaWYgKG8gaW5zdGFuY2VvZiBNYXApIHJldHVybiBuZXcgTWFwKGNsb25lQXJyYXkoQXJyYXkuZnJvbShvKSwgY2xvbmVQcm90bykpXG4gICAgaWYgKG8gaW5zdGFuY2VvZiBTZXQpIHJldHVybiBuZXcgU2V0KGNsb25lQXJyYXkoQXJyYXkuZnJvbShvKSwgY2xvbmVQcm90bykpXG4gICAgdmFyIG8yID0ge31cbiAgICByZWZzLnB1c2gobylcbiAgICByZWZzTmV3LnB1c2gobzIpXG4gICAgZm9yICh2YXIgayBpbiBvKSB7XG4gICAgICB2YXIgY3VyID0gb1trXVxuICAgICAgaWYgKHR5cGVvZiBjdXIgIT09ICdvYmplY3QnIHx8IGN1ciA9PT0gbnVsbCkge1xuICAgICAgICBvMltrXSA9IGN1clxuICAgICAgfSBlbHNlIGlmIChjdXIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIG8yW2tdID0gbmV3IERhdGUoY3VyKVxuICAgICAgfSBlbHNlIGlmIChjdXIgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgbzJba10gPSBuZXcgTWFwKGNsb25lQXJyYXkoQXJyYXkuZnJvbShjdXIpLCBjbG9uZVByb3RvKSlcbiAgICAgIH0gZWxzZSBpZiAoY3VyIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIG8yW2tdID0gbmV3IFNldChjbG9uZUFycmF5KEFycmF5LmZyb20oY3VyKSwgY2xvbmVQcm90bykpXG4gICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhjdXIpKSB7XG4gICAgICAgIG8yW2tdID0gY29weUJ1ZmZlcihjdXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IHJlZnMuaW5kZXhPZihjdXIpXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgIG8yW2tdID0gcmVmc05ld1tpXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG8yW2tdID0gY2xvbmVQcm90byhjdXIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVmcy5wb3AoKVxuICAgIHJlZnNOZXcucG9wKClcbiAgICByZXR1cm4gbzJcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzVmFsaWRYQWRkcmVzcyA9IGV4cG9ydHMuZGVjb2RlWEFkZHJlc3MgPSBleHBvcnRzLnhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyA9IGV4cG9ydHMuZW5jb2RlWEFkZHJlc3MgPSBleHBvcnRzLmNsYXNzaWNBZGRyZXNzVG9YQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZENsYXNzaWNBZGRyZXNzID0gZXhwb3J0cy5kZWNvZGVBY2NvdW50UHVibGljID0gZXhwb3J0cy5lbmNvZGVBY2NvdW50UHVibGljID0gZXhwb3J0cy5kZWNvZGVOb2RlUHVibGljID0gZXhwb3J0cy5lbmNvZGVOb2RlUHVibGljID0gZXhwb3J0cy5kZWNvZGVBY2NvdW50SUQgPSBleHBvcnRzLmVuY29kZUFjY291bnRJRCA9IGV4cG9ydHMuZGVjb2RlU2VlZCA9IGV4cG9ydHMuZW5jb2RlU2VlZCA9IGV4cG9ydHMuY29kZWMgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuY29uc3QgeHJwX2NvZGVjXzEgPSByZXF1aXJlKFwiLi94cnAtY29kZWNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb2RlY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuY29kZWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVTZWVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5lbmNvZGVTZWVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlU2VlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZGVjb2RlU2VlZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUFjY291bnRJRFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZW5jb2RlQWNjb3VudElEOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlQWNjb3VudElEXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5kZWNvZGVBY2NvdW50SUQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmNvZGVOb2RlUHVibGljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5lbmNvZGVOb2RlUHVibGljOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVjb2RlTm9kZVB1YmxpY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4geHJwX2NvZGVjXzEuZGVjb2RlTm9kZVB1YmxpYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVuY29kZUFjY291bnRQdWJsaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHhycF9jb2RlY18xLmVuY29kZUFjY291bnRQdWJsaWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWNvZGVBY2NvdW50UHVibGljXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5kZWNvZGVBY2NvdW50UHVibGljOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZENsYXNzaWNBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4cnBfY29kZWNfMS5pc1ZhbGlkQ2xhc3NpY0FkZHJlc3M7IH0gfSk7XG5jb25zdCBQUkVGSVhfQllURVMgPSB7XG4gICAgLy8gNSwgNjhcbiAgICBNQUlOOiBCdWZmZXIuZnJvbShbMHgwNSwgMHg0NF0pLFxuICAgIC8vIDQsIDE0N1xuICAgIFRFU1Q6IEJ1ZmZlci5mcm9tKFsweDA0LCAweDkzXSksXG59O1xuY29uc3QgTUFYXzMyX0JJVF9VTlNJR05FRF9JTlQgPSA0Mjk0OTY3Mjk1O1xuZnVuY3Rpb24gY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzKGNsYXNzaWNBZGRyZXNzLCB0YWcsIHRlc3QpIHtcbiAgICBjb25zdCBhY2NvdW50SWQgPSAoMCwgeHJwX2NvZGVjXzEuZGVjb2RlQWNjb3VudElEKShjbGFzc2ljQWRkcmVzcyk7XG4gICAgcmV0dXJuIGVuY29kZVhBZGRyZXNzKGFjY291bnRJZCwgdGFnLCB0ZXN0KTtcbn1cbmV4cG9ydHMuY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzID0gY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzO1xuZnVuY3Rpb24gZW5jb2RlWEFkZHJlc3MoYWNjb3VudElkLCB0YWcsIHRlc3QpIHtcbiAgICBpZiAoYWNjb3VudElkLmxlbmd0aCAhPT0gMjApIHtcbiAgICAgICAgLy8gUklQRU1EMTYwIGlzIDE2MCBiaXRzID0gMjAgYnl0ZXNcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IElEIG11c3QgYmUgMjAgYnl0ZXMnKTtcbiAgICB9XG4gICAgaWYgKHRhZyA+IE1BWF8zMl9CSVRfVU5TSUdORURfSU5UKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0YWcnKTtcbiAgICB9XG4gICAgY29uc3QgdGhlVGFnID0gdGFnID09PSBmYWxzZSA/IDAgOiB0YWc7XG4gICAgY29uc3QgZmxhZyA9IHRhZyA9PT0gZmFsc2UgPyAwIDogMTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlIC0tLVxuICAgICAqIG5lZWQgdG8gdXNlIGJpdHdpc2Ugb3BlcmF0aW9ucyBoZXJlICovXG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgdGVzdCA/IFBSRUZJWF9CWVRFUy5URVNUIDogUFJFRklYX0JZVEVTLk1BSU4sXG4gICAgICAgIGFjY291bnRJZCxcbiAgICAgICAgQnVmZmVyLmZyb20oW1xuICAgICAgICAgICAgLy8gMHgwMCBpZiBubyB0YWcsIDB4MDEgaWYgMzItYml0IHRhZ1xuICAgICAgICAgICAgZmxhZyxcbiAgICAgICAgICAgIC8vIGZpcnN0IGJ5dGVcbiAgICAgICAgICAgIHRoZVRhZyAmIDB4ZmYsXG4gICAgICAgICAgICAvLyBzZWNvbmQgYnl0ZVxuICAgICAgICAgICAgKHRoZVRhZyA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICAvLyB0aGlyZCBieXRlXG4gICAgICAgICAgICAodGhlVGFnID4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICAvLyBmb3VydGggYnl0ZVxuICAgICAgICAgICAgKHRoZVRhZyA+PiAyNCkgJiAweGZmLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgLy8gZm91ciB6ZXJvIGJ5dGVzIChyZXNlcnZlZCBmb3IgNjQtYml0IHRhZ3MpXG4gICAgICAgICAgICAwLFxuICAgICAgICBdKSxcbiAgICBdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbiAgICByZXR1cm4geHJwX2NvZGVjXzEuY29kZWMuZW5jb2RlQ2hlY2tlZChieXRlcyk7XG59XG5leHBvcnRzLmVuY29kZVhBZGRyZXNzID0gZW5jb2RlWEFkZHJlc3M7XG5mdW5jdGlvbiB4QWRkcmVzc1RvQ2xhc3NpY0FkZHJlc3MoeEFkZHJlc3MpIHtcbiAgICBjb25zdCB7IGFjY291bnRJZCwgdGFnLCB0ZXN0IH0gPSBkZWNvZGVYQWRkcmVzcyh4QWRkcmVzcyk7XG4gICAgY29uc3QgY2xhc3NpY0FkZHJlc3MgPSAoMCwgeHJwX2NvZGVjXzEuZW5jb2RlQWNjb3VudElEKShhY2NvdW50SWQpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNsYXNzaWNBZGRyZXNzLFxuICAgICAgICB0YWcsXG4gICAgICAgIHRlc3QsXG4gICAgfTtcbn1cbmV4cG9ydHMueEFkZHJlc3NUb0NsYXNzaWNBZGRyZXNzID0geEFkZHJlc3NUb0NsYXNzaWNBZGRyZXNzO1xuZnVuY3Rpb24gZGVjb2RlWEFkZHJlc3MoeEFkZHJlc3MpIHtcbiAgICBjb25zdCBkZWNvZGVkID0geHJwX2NvZGVjXzEuY29kZWMuZGVjb2RlQ2hlY2tlZCh4QWRkcmVzcyk7XG4gICAgY29uc3QgdGVzdCA9IGlzQnVmZmVyRm9yVGVzdEFkZHJlc3MoZGVjb2RlZCk7XG4gICAgY29uc3QgYWNjb3VudElkID0gZGVjb2RlZC5zbGljZSgyLCAyMik7XG4gICAgY29uc3QgdGFnID0gdGFnRnJvbUJ1ZmZlcihkZWNvZGVkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50SWQsXG4gICAgICAgIHRhZyxcbiAgICAgICAgdGVzdCxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWNvZGVYQWRkcmVzcyA9IGRlY29kZVhBZGRyZXNzO1xuZnVuY3Rpb24gaXNCdWZmZXJGb3JUZXN0QWRkcmVzcyhidWYpIHtcbiAgICBjb25zdCBkZWNvZGVkUHJlZml4ID0gYnVmLnNsaWNlKDAsIDIpO1xuICAgIGlmIChQUkVGSVhfQllURVMuTUFJTi5lcXVhbHMoZGVjb2RlZFByZWZpeCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoUFJFRklYX0JZVEVTLlRFU1QuZXF1YWxzKGRlY29kZWRQcmVmaXgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgWC1hZGRyZXNzOiBiYWQgcHJlZml4Jyk7XG59XG5mdW5jdGlvbiB0YWdGcm9tQnVmZmVyKGJ1Zikge1xuICAgIGNvbnN0IGZsYWcgPSBidWZbMjJdO1xuICAgIGlmIChmbGFnID49IDIpIHtcbiAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3IgNjQtYml0IHRhZ3MgYXQgdGhpcyB0aW1lXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgWC1hZGRyZXNzJyk7XG4gICAgfVxuICAgIGlmIChmbGFnID09PSAxKSB7XG4gICAgICAgIC8vIExpdHRsZS1lbmRpYW4gdG8gYmlnLWVuZGlhblxuICAgICAgICByZXR1cm4gYnVmWzIzXSArIGJ1ZlsyNF0gKiAweDEwMCArIGJ1ZlsyNV0gKiAweDEwMDAwICsgYnVmWzI2XSAqIDB4MTAwMDAwMDtcbiAgICB9XG4gICAgYXNzZXJ0LnN0cmljdEVxdWFsKGZsYWcsIDAsICdmbGFnIG11c3QgYmUgemVybyB0byBpbmRpY2F0ZSBubyB0YWcnKTtcbiAgICBhc3NlcnQub2soQnVmZmVyLmZyb20oJzAwMDAwMDAwMDAwMDAwMDAnLCAnaGV4JykuZXF1YWxzKGJ1Zi5zbGljZSgyMywgMjMgKyA4KSksICdyZW1haW5pbmcgYnl0ZXMgbXVzdCBiZSB6ZXJvJyk7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZFhBZGRyZXNzKHhBZGRyZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgZGVjb2RlWEFkZHJlc3MoeEFkZHJlc3MpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzVmFsaWRYQWRkcmVzcyA9IGlzVmFsaWRYQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25jYXRBcmdzID0gZXhwb3J0cy5zZXFFcXVhbCA9IHZvaWQgMDtcbi8qKlxuICogQ2hlY2sgd2hldGhlciB0d28gc2VxdWVuY2VzIChlLmcuIEFycmF5cyBvZiBudW1iZXJzKSBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIGFycjEgLSBPbmUgb2YgdGhlIGFycmF5cyB0byBjb21wYXJlLlxuICogQHBhcmFtIGFycjIgLSBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqL1xuZnVuY3Rpb24gc2VxRXF1YWwoYXJyMSwgYXJyMikge1xuICAgIGlmIChhcnIxLmxlbmd0aCAhPT0gYXJyMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuc2VxRXF1YWwgPSBzZXFFcXVhbDtcbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHZhbHVlIGlzIGEgc2VxdWVuY2UgKGUuZy4gQXJyYXkgb2YgbnVtYmVycykuXG4gKlxuICogQHBhcmFtIHZhbCAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNTZXF1ZW5jZSh2YWwpIHtcbiAgICByZXR1cm4gdmFsLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbGwgYGFyZ3VtZW50c2AgaW50byBhIHNpbmdsZSBhcnJheS4gRWFjaCBhcmd1bWVudCBjYW4gYmUgZWl0aGVyXG4gKiBhIHNpbmdsZSBlbGVtZW50IG9yIGEgc2VxdWVuY2UsIHdoaWNoIGhhcyBhIGBsZW5ndGhgIHByb3BlcnR5IGFuZCBzdXBwb3J0c1xuICogZWxlbWVudCByZXRyaWV2YWwgdmlhIHNlcXVlbmNlW2l4XS5cbiAqXG4gKiA+IGNvbmNhdEFyZ3MoMSwgWzIsIDNdLCBCdWZmZXIuZnJvbShbNCw1XSksIG5ldyBVaW50OEFycmF5KFs2LCA3XSkpO1xuICogWzEsMiwzLDQsNSw2LDddXG4gKlxuICogQHJldHVybnMgQXJyYXkgb2YgY29uY2F0ZW5hdGVkIGFyZ3VtZW50c1xuICovXG5mdW5jdGlvbiBjb25jYXRBcmdzKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZXQgPSBbXTtcbiAgICBhcmdzLmZvckVhY2goKGFyZykgPT4ge1xuICAgICAgICBpZiAoaXNTZXF1ZW5jZShhcmcpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGogb2YgYXJnKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQucHVzaChhcmcpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmV4cG9ydHMuY29uY2F0QXJncyA9IGNvbmNhdEFyZ3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29kZWMgY2xhc3NcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkQ2xhc3NpY0FkZHJlc3MgPSBleHBvcnRzLmRlY29kZUFjY291bnRQdWJsaWMgPSBleHBvcnRzLmVuY29kZUFjY291bnRQdWJsaWMgPSBleHBvcnRzLmVuY29kZU5vZGVQdWJsaWMgPSBleHBvcnRzLmRlY29kZU5vZGVQdWJsaWMgPSBleHBvcnRzLmRlY29kZUFkZHJlc3MgPSBleHBvcnRzLmRlY29kZUFjY291bnRJRCA9IGV4cG9ydHMuZW5jb2RlQWRkcmVzcyA9IGV4cG9ydHMuZW5jb2RlQWNjb3VudElEID0gZXhwb3J0cy5kZWNvZGVTZWVkID0gZXhwb3J0cy5lbmNvZGVTZWVkID0gZXhwb3J0cy5jb2RlYyA9IHZvaWQgMDtcbmNvbnN0IGJhc2VDb2RlYyA9IHJlcXVpcmUoXCJiYXNlLXhcIik7XG5jb25zdCBjcmVhdGVIYXNoID0gcmVxdWlyZShcImNyZWF0ZS1oYXNoXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY2xhc3MgQ29kZWMge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zaGEyNTYgPSBvcHRpb25zLnNoYTI1NjtcbiAgICAgICAgdGhpcy5hbHBoYWJldCA9IG9wdGlvbnMuYWxwaGFiZXQ7XG4gICAgICAgIHRoaXMuY29kZWMgPSBiYXNlQ29kZWModGhpcy5hbHBoYWJldCk7XG4gICAgICAgIHRoaXMuYmFzZSA9IHRoaXMuYWxwaGFiZXQubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ5dGVzIC0gQnVmZmVyIG9mIGRhdGEgdG8gZW5jb2RlLlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBvYmplY3QgaW5jbHVkaW5nIHRoZSB2ZXJzaW9uIGJ5dGVzIGFuZCB0aGUgZXhwZWN0ZWQgbGVuZ3RoIG9mIHRoZSBkYXRhIHRvIGVuY29kZS5cbiAgICAgKi9cbiAgICBlbmNvZGUoYnl0ZXMsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBvcHRzLnZlcnNpb25zO1xuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVWZXJzaW9uZWQoYnl0ZXMsIHZlcnNpb25zLCBvcHRzLmV4cGVjdGVkTGVuZ3RoKTtcbiAgICB9XG4gICAgZW5jb2RlVmVyc2lvbmVkKGJ5dGVzLCB2ZXJzaW9ucywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgaWYgKGV4cGVjdGVkTGVuZ3RoICYmIGJ5dGVzLmxlbmd0aCAhPT0gZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZF9wYXlsb2FkX2xlbmd0aDogYnl0ZXMubGVuZ3RoIGRvZXMgbm90IG1hdGNoIGV4cGVjdGVkTGVuZ3RoLicgK1xuICAgICAgICAgICAgICAgICcgRW5zdXJlIHRoYXQgdGhlIGJ5dGVzIGFyZSBhIEJ1ZmZlci4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbmNvZGVDaGVja2VkKEJ1ZmZlci5mcm9tKCgwLCB1dGlsc18xLmNvbmNhdEFyZ3MpKHZlcnNpb25zLCBieXRlcykpKTtcbiAgICB9XG4gICAgZW5jb2RlQ2hlY2tlZChidWZmZXIpIHtcbiAgICAgICAgY29uc3QgY2hlY2sgPSB0aGlzLnNoYTI1Nih0aGlzLnNoYTI1NihidWZmZXIpKS5zbGljZSgwLCA0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlUmF3KEJ1ZmZlci5mcm9tKCgwLCB1dGlsc18xLmNvbmNhdEFyZ3MpKGJ1ZmZlciwgY2hlY2spKSk7XG4gICAgfVxuICAgIGVuY29kZVJhdyhieXRlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlYy5lbmNvZGUoYnl0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJhc2U1OHN0cmluZyAtIEJhc2U1OENoZWNrLWVuY29kZWQgc3RyaW5nIHRvIGRlY29kZS5cbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgb2JqZWN0IGluY2x1ZGluZyB0aGUgdmVyc2lvbiBieXRlKHMpIGFuZCB0aGUgZXhwZWN0ZWQgbGVuZ3RoIG9mIHRoZSBkYXRhIGFmdGVyIGRlY29kaW5nLlxuICAgICAqL1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1saW5lcy1wZXItZnVuY3Rpb24gLS1cbiAgICAgKiBUT0RPIHJlZmFjdG9yICovXG4gICAgZGVjb2RlKGJhc2U1OHN0cmluZywgb3B0cykge1xuICAgICAgICBjb25zdCB2ZXJzaW9ucyA9IG9wdHMudmVyc2lvbnM7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gb3B0cy52ZXJzaW9uVHlwZXM7XG4gICAgICAgIGNvbnN0IHdpdGhvdXRTdW0gPSB0aGlzLmRlY29kZUNoZWNrZWQoYmFzZTU4c3RyaW5nKTtcbiAgICAgICAgaWYgKHZlcnNpb25zLmxlbmd0aCA+IDEgJiYgIW9wdHMuZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWRMZW5ndGggaXMgcmVxdWlyZWQgYmVjYXVzZSB0aGVyZSBhcmUgPj0gMiBwb3NzaWJsZSB2ZXJzaW9ucycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcnNpb25MZW5ndGhHdWVzcyA9IHR5cGVvZiB2ZXJzaW9uc1swXSA9PT0gJ251bWJlcicgPyAxIDogdmVyc2lvbnNbMF0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBwYXlsb2FkTGVuZ3RoID0gb3B0cy5leHBlY3RlZExlbmd0aCB8fCB3aXRob3V0U3VtLmxlbmd0aCAtIHZlcnNpb25MZW5ndGhHdWVzcztcbiAgICAgICAgY29uc3QgdmVyc2lvbkJ5dGVzID0gd2l0aG91dFN1bS5zbGljZSgwLCAtcGF5bG9hZExlbmd0aCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB3aXRob3V0U3VtLnNsaWNlKC1wYXlsb2FkTGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJzaW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IEFycmF5LmlzQXJyYXkodmVyc2lvbnNbaV0pXG4gICAgICAgICAgICAgICAgPyB2ZXJzaW9uc1tpXVxuICAgICAgICAgICAgICAgIDogW3ZlcnNpb25zW2ldXTtcbiAgICAgICAgICAgIGlmICgoMCwgdXRpbHNfMS5zZXFFcXVhbCkodmVyc2lvbkJ5dGVzLCB2ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlcyA/IHR5cGVzW2ldIDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmVyc2lvbl9pbnZhbGlkOiB2ZXJzaW9uIGJ5dGVzIGRvIG5vdCBtYXRjaCBhbnkgb2YgdGhlIHByb3ZpZGVkIHZlcnNpb24ocyknKTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGluZXMtcGVyLWZ1bmN0aW9uICovXG4gICAgZGVjb2RlQ2hlY2tlZChiYXNlNThzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5kZWNvZGVSYXcoYmFzZTU4c3RyaW5nKTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPCA1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWRfaW5wdXRfc2l6ZTogZGVjb2RlZCBkYXRhIG11c3QgaGF2ZSBsZW5ndGggPj0gNScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy52ZXJpZnlDaGVja1N1bShidWZmZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NoZWNrc3VtX2ludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKDAsIC00KTtcbiAgICB9XG4gICAgZGVjb2RlUmF3KGJhc2U1OHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlYy5kZWNvZGUoYmFzZTU4c3RyaW5nKTtcbiAgICB9XG4gICAgdmVyaWZ5Q2hlY2tTdW0oYnl0ZXMpIHtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSB0aGlzLnNoYTI1Nih0aGlzLnNoYTI1NihieXRlcy5zbGljZSgwLCAtNCkpKS5zbGljZSgwLCA0KTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW0gPSBieXRlcy5zbGljZSgtNCk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5zZXFFcXVhbCkoY29tcHV0ZWQsIGNoZWNrc3VtKTtcbiAgICB9XG59XG4vKipcbiAqIFhSUCBjb2RlY1xuICovXG4vLyBiYXNlNTggZW5jb2RpbmdzOiBodHRwczovL3hycGwub3JnL2Jhc2U1OC1lbmNvZGluZ3MuaHRtbFxuLy8gQWNjb3VudCBhZGRyZXNzICgyMCBieXRlcylcbmNvbnN0IEFDQ09VTlRfSUQgPSAwO1xuLy8gQWNjb3VudCBwdWJsaWMga2V5ICgzMyBieXRlcylcbmNvbnN0IEFDQ09VTlRfUFVCTElDX0tFWSA9IDB4MjM7XG4vLyAzMzsgU2VlZCB2YWx1ZSAoZm9yIHNlY3JldCBrZXlzKSAoMTYgYnl0ZXMpXG5jb25zdCBGQU1JTFlfU0VFRCA9IDB4MjE7XG4vLyAyODsgVmFsaWRhdGlvbiBwdWJsaWMga2V5ICgzMyBieXRlcylcbmNvbnN0IE5PREVfUFVCTElDID0gMHgxYztcbi8vIFsxLCAyMjUsIDc1XVxuY29uc3QgRUQyNTUxOV9TRUVEID0gWzB4MDEsIDB4ZTEsIDB4NGJdO1xuY29uc3QgY29kZWNPcHRpb25zID0ge1xuICAgIHNoYTI1NihieXRlcykge1xuICAgICAgICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKEJ1ZmZlci5mcm9tKGJ5dGVzKSkuZGlnZXN0KCk7XG4gICAgfSxcbiAgICBhbHBoYWJldDogJ3Jwc2huYWYzOXdCVURORUdISktMTTRQUVJTVDdWV1hZWjJiY2RlQ2c2NWprbThvRnFpMXR1dkF4eXonLFxufTtcbmNvbnN0IGNvZGVjV2l0aFhycEFscGhhYmV0ID0gbmV3IENvZGVjKGNvZGVjT3B0aW9ucyk7XG5leHBvcnRzLmNvZGVjID0gY29kZWNXaXRoWHJwQWxwaGFiZXQ7XG4vLyBlbnRyb3B5IGlzIGEgQnVmZmVyIG9mIHNpemUgMTZcbi8vIHR5cGUgaXMgJ2VkMjU1MTknIG9yICdzZWNwMjU2azEnXG5mdW5jdGlvbiBlbmNvZGVTZWVkKGVudHJvcHksIHR5cGUpIHtcbiAgICBpZiAoZW50cm9weS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50cm9weSBtdXN0IGhhdmUgbGVuZ3RoIDE2Jyk7XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgIGV4cGVjdGVkTGVuZ3RoOiAxNixcbiAgICAgICAgLy8gZm9yIHNlY3AyNTZrMSwgdXNlIGBGQU1JTFlfU0VFRGBcbiAgICAgICAgdmVyc2lvbnM6IHR5cGUgPT09ICdlZDI1NTE5JyA/IEVEMjU1MTlfU0VFRCA6IFtGQU1JTFlfU0VFRF0sXG4gICAgfTtcbiAgICAvLyBwcmVmaXhlcyBlbnRyb3B5IHdpdGggdmVyc2lvbiBieXRlc1xuICAgIHJldHVybiBjb2RlY1dpdGhYcnBBbHBoYWJldC5lbmNvZGUoZW50cm9weSwgb3B0cyk7XG59XG5leHBvcnRzLmVuY29kZVNlZWQgPSBlbmNvZGVTZWVkO1xuZnVuY3Rpb24gZGVjb2RlU2VlZChzZWVkLCBvcHRzID0ge1xuICAgIHZlcnNpb25UeXBlczogWydlZDI1NTE5JywgJ3NlY3AyNTZrMSddLFxuICAgIHZlcnNpb25zOiBbRUQyNTUxOV9TRUVELCBGQU1JTFlfU0VFRF0sXG4gICAgZXhwZWN0ZWRMZW5ndGg6IDE2LFxufSkge1xuICAgIHJldHVybiBjb2RlY1dpdGhYcnBBbHBoYWJldC5kZWNvZGUoc2VlZCwgb3B0cyk7XG59XG5leHBvcnRzLmRlY29kZVNlZWQgPSBkZWNvZGVTZWVkO1xuZnVuY3Rpb24gZW5jb2RlQWNjb3VudElEKGJ5dGVzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgdmVyc2lvbnM6IFtBQ0NPVU5UX0lEXSwgZXhwZWN0ZWRMZW5ndGg6IDIwIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmVuY29kZShieXRlcywgb3B0cyk7XG59XG5leHBvcnRzLmVuY29kZUFjY291bnRJRCA9IGVuY29kZUFjY291bnRJRDtcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby11bnVzZWQtbW9kdWxlcyAtLS1cbiAqIHVuY2xlYXIgd2h5IHRoaXMgaXMgYWxpYXNlZCBidXQgd2Ugc2hvdWxkIGtlZXAgaXQgaW4gY2FzZSBzb21lb25lIGVsc2UgaXNcbiAqIGltcG9ydGluZyBpdCB3aXRoIHRoZSBhbGlhc2VkIG5hbWUgKi9cbmV4cG9ydHMuZW5jb2RlQWRkcmVzcyA9IGVuY29kZUFjY291bnRJRDtcbi8qIGVzbGludC1lbmFibGUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzICovXG5mdW5jdGlvbiBkZWNvZGVBY2NvdW50SUQoYWNjb3VudElkKSB7XG4gICAgY29uc3Qgb3B0cyA9IHsgdmVyc2lvbnM6IFtBQ0NPVU5UX0lEXSwgZXhwZWN0ZWRMZW5ndGg6IDIwIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmRlY29kZShhY2NvdW50SWQsIG9wdHMpLmJ5dGVzO1xufVxuZXhwb3J0cy5kZWNvZGVBY2NvdW50SUQgPSBkZWNvZGVBY2NvdW50SUQ7XG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXMgLS0tXG4gKiB1bmNsZWFyIHdoeSB0aGlzIGlzIGFsaWFzZWQgYnV0IHdlIHNob3VsZCBrZWVwIGl0IGluIGNhc2Ugc29tZW9uZSBlbHNlIGlzXG4gKiBpbXBvcnRpbmcgaXQgd2l0aCB0aGUgYWxpYXNlZCBuYW1lICovXG5leHBvcnRzLmRlY29kZUFkZHJlc3MgPSBkZWNvZGVBY2NvdW50SUQ7XG4vKiBlc2xpbnQtZW5hYmxlIGltcG9ydC9uby11bnVzZWQtbW9kdWxlcyAqL1xuZnVuY3Rpb24gZGVjb2RlTm9kZVB1YmxpYyhiYXNlNThzdHJpbmcpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW05PREVfUFVCTElDXSwgZXhwZWN0ZWRMZW5ndGg6IDMzIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmRlY29kZShiYXNlNThzdHJpbmcsIG9wdHMpLmJ5dGVzO1xufVxuZXhwb3J0cy5kZWNvZGVOb2RlUHVibGljID0gZGVjb2RlTm9kZVB1YmxpYztcbmZ1bmN0aW9uIGVuY29kZU5vZGVQdWJsaWMoYnl0ZXMpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW05PREVfUFVCTElDXSwgZXhwZWN0ZWRMZW5ndGg6IDMzIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmVuY29kZShieXRlcywgb3B0cyk7XG59XG5leHBvcnRzLmVuY29kZU5vZGVQdWJsaWMgPSBlbmNvZGVOb2RlUHVibGljO1xuZnVuY3Rpb24gZW5jb2RlQWNjb3VudFB1YmxpYyhieXRlcykge1xuICAgIGNvbnN0IG9wdHMgPSB7IHZlcnNpb25zOiBbQUNDT1VOVF9QVUJMSUNfS0VZXSwgZXhwZWN0ZWRMZW5ndGg6IDMzIH07XG4gICAgcmV0dXJuIGNvZGVjV2l0aFhycEFscGhhYmV0LmVuY29kZShieXRlcywgb3B0cyk7XG59XG5leHBvcnRzLmVuY29kZUFjY291bnRQdWJsaWMgPSBlbmNvZGVBY2NvdW50UHVibGljO1xuZnVuY3Rpb24gZGVjb2RlQWNjb3VudFB1YmxpYyhiYXNlNThzdHJpbmcpIHtcbiAgICBjb25zdCBvcHRzID0geyB2ZXJzaW9uczogW0FDQ09VTlRfUFVCTElDX0tFWV0sIGV4cGVjdGVkTGVuZ3RoOiAzMyB9O1xuICAgIHJldHVybiBjb2RlY1dpdGhYcnBBbHBoYWJldC5kZWNvZGUoYmFzZTU4c3RyaW5nLCBvcHRzKS5ieXRlcztcbn1cbmV4cG9ydHMuZGVjb2RlQWNjb3VudFB1YmxpYyA9IGRlY29kZUFjY291bnRQdWJsaWM7XG5mdW5jdGlvbiBpc1ZhbGlkQ2xhc3NpY0FkZHJlc3MoYWRkcmVzcykge1xuICAgIHRyeSB7XG4gICAgICAgIGRlY29kZUFjY291bnRJRChhZGRyZXNzKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc1ZhbGlkQ2xhc3NpY0FkZHJlc3MgPSBpc1ZhbGlkQ2xhc3NpY0FkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14cnAtY29kZWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiBlc2xpbnQtZGlzYWJsZSBmdW5jLXN0eWxlICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyYW5zYWN0aW9uSUQgPSBleHBvcnRzLnNoYTUxMkhhbGYgPSBleHBvcnRzLmJpbmFyeVRvSlNPTiA9IGV4cG9ydHMuc2lnbmluZ0NsYWltRGF0YSA9IGV4cG9ydHMuc2lnbmluZ0RhdGEgPSBleHBvcnRzLm11bHRpU2lnbmluZ0RhdGEgPSBleHBvcnRzLnJlYWRKU09OID0gZXhwb3J0cy5zZXJpYWxpemVPYmplY3QgPSBleHBvcnRzLm1ha2VQYXJzZXIgPSBleHBvcnRzLkJ5dGVzTGlzdCA9IGV4cG9ydHMuQmluYXJ5U2VyaWFsaXplciA9IGV4cG9ydHMuQmluYXJ5UGFyc2VyID0gdm9pZCAwO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBiaW5hcnlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9zZXJkZXMvYmluYXJ5LXBhcnNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJpbmFyeVBhcnNlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmluYXJ5X3BhcnNlcl8xLkJpbmFyeVBhcnNlcjsgfSB9KTtcbnZhciBoYXNoX3ByZWZpeGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoLXByZWZpeGVzXCIpO1xudmFyIGJpbmFyeV9zZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJkZXMvYmluYXJ5LXNlcmlhbGl6ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCaW5hcnlTZXJpYWxpemVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaW5hcnlfc2VyaWFsaXplcl8xLkJpbmFyeVNlcmlhbGl6ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCeXRlc0xpc3RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpbmFyeV9zZXJpYWxpemVyXzEuQnl0ZXNMaXN0OyB9IH0pO1xudmFyIGhhc2hlc18xID0gcmVxdWlyZShcIi4vaGFzaGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhNTEySGFsZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaGVzXzEuc2hhNTEySGFsZjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRyYW5zYWN0aW9uSURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlc18xLnRyYW5zYWN0aW9uSUQ7IH0gfSk7XG52YXIgYmlnSW50ID0gcmVxdWlyZShcImJpZy1pbnRlZ2VyXCIpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBCaW5hcnlQYXJzZXJcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgaGV4LXN0cmluZyB0byBjb25zdHJ1Y3QgQmluYXJ5UGFyc2VyIGZyb21cbiAqIEByZXR1cm5zIEEgQmluYXJ5UGFyc2VyXG4gKi9cbnZhciBtYWtlUGFyc2VyID0gZnVuY3Rpb24gKGJ5dGVzKSB7IHJldHVybiBuZXcgYmluYXJ5X3BhcnNlcl8xLkJpbmFyeVBhcnNlcihieXRlcyk7IH07XG5leHBvcnRzLm1ha2VQYXJzZXIgPSBtYWtlUGFyc2VyO1xuLyoqXG4gKiBQYXJzZSBCaW5hcnlQYXJzZXIgaW50byBKU09OXG4gKlxuICogQHBhcmFtIHBhcnNlciBCaW5hcnlQYXJzZXIgb2JqZWN0XG4gKiBAcmV0dXJucyBKU09OIGZvciB0aGUgYnl0ZXMgaW4gdGhlIEJpbmFyeVBhcnNlclxuICovXG52YXIgcmVhZEpTT04gPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgcmV0dXJuIHBhcnNlci5yZWFkVHlwZSh0eXBlc18xLmNvcmVUeXBlcy5TVE9iamVjdCkudG9KU09OKCk7XG59O1xuZXhwb3J0cy5yZWFkSlNPTiA9IHJlYWRKU09OO1xuLyoqXG4gKiBQYXJzZSBhIGhleC1zdHJpbmcgaW50byBpdHMgSlNPTiBpbnRlcnByZXRhdGlvblxuICpcbiAqIEBwYXJhbSBieXRlcyBoZXgtc3RyaW5nIHRvIHBhcnNlIGludG8gSlNPTlxuICogQHJldHVybnMgSlNPTlxuICovXG52YXIgYmluYXJ5VG9KU09OID0gZnVuY3Rpb24gKGJ5dGVzKSB7IHJldHVybiByZWFkSlNPTihtYWtlUGFyc2VyKGJ5dGVzKSk7IH07XG5leHBvcnRzLmJpbmFyeVRvSlNPTiA9IGJpbmFyeVRvSlNPTjtcbi8qKlxuICogRnVuY3Rpb24gdG8gc2VyaWFsaXplIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyBhIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIG9iamVjdCBKU09OIG9iamVjdCB0byBzZXJpYWxpemVcbiAqIEBwYXJhbSBvcHRzIG9wdGlvbnMgZm9yIHNlcmlhbGl6aW5nLCBpbmNsdWRpbmcgb3B0aW9uYWwgcHJlZml4LCBzdWZmaXgsIGFuZCBzaWduaW5nRmllbGRPbmx5XG4gKiBAcmV0dXJucyBBIEJ1ZmZlciBjb250YWluaW5nIHRoZSBzZXJpYWxpemVkIG9iamVjdFxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3Qob2JqZWN0LCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICB2YXIgcHJlZml4ID0gb3B0cy5wcmVmaXgsIHN1ZmZpeCA9IG9wdHMuc3VmZml4LCBfYSA9IG9wdHMuc2lnbmluZ0ZpZWxkc09ubHksIHNpZ25pbmdGaWVsZHNPbmx5ID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2E7XG4gICAgdmFyIGJ5dGVzTGlzdCA9IG5ldyBiaW5hcnlfc2VyaWFsaXplcl8xLkJ5dGVzTGlzdCgpO1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgYnl0ZXNMaXN0LnB1dChwcmVmaXgpO1xuICAgIH1cbiAgICB2YXIgZmlsdGVyID0gc2lnbmluZ0ZpZWxkc09ubHlcbiAgICAgICAgPyBmdW5jdGlvbiAoZikgeyByZXR1cm4gZi5pc1NpZ25pbmdGaWVsZDsgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB0eXBlc18xLmNvcmVUeXBlcy5TVE9iamVjdC5mcm9tKG9iamVjdCwgZmlsdGVyKS50b0J5dGVzU2luayhieXRlc0xpc3QpO1xuICAgIGlmIChzdWZmaXgpIHtcbiAgICAgICAgYnl0ZXNMaXN0LnB1dChzdWZmaXgpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXNMaXN0LnRvQnl0ZXMoKTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplT2JqZWN0ID0gc2VyaWFsaXplT2JqZWN0O1xuLyoqXG4gKiBTZXJpYWxpemUgYW4gb2JqZWN0IGZvciBzaWduaW5nXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIFRyYW5zYWN0aW9uIHRvIHNlcmlhbGl6ZVxuICogQHBhcmFtIHByZWZpeCBQcmVmaXggYnl0ZXMgdG8gcHV0IGJlZm9yZSB0aGUgc2VyaWFsaXplZCBvYmplY3RcbiAqIEByZXR1cm5zIEEgQnVmZmVyIHdpdGggdGhlIHNlcmlhbGl6ZWQgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHNpZ25pbmdEYXRhKHRyYW5zYWN0aW9uLCBwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4ID09PSB2b2lkIDApIHsgcHJlZml4ID0gaGFzaF9wcmVmaXhlc18xLkhhc2hQcmVmaXgudHJhbnNhY3Rpb25TaWc7IH1cbiAgICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KHRyYW5zYWN0aW9uLCB7IHByZWZpeDogcHJlZml4LCBzaWduaW5nRmllbGRzT25seTogdHJ1ZSB9KTtcbn1cbmV4cG9ydHMuc2lnbmluZ0RhdGEgPSBzaWduaW5nRGF0YTtcbi8qKlxuICogU2VyaWFsaXplIGEgc2lnbmluZ0NsYWltXG4gKlxuICogQHBhcmFtIGNsYWltIEEgY2xhaW0gb2JqZWN0IHRvIHNlcmlhbGl6ZVxuICogQHJldHVybnMgdGhlIHNlcmlhbGl6ZWQgb2JqZWN0IHdpdGggYXBwcm9wcmlhdGUgcHJlZml4XG4gKi9cbmZ1bmN0aW9uIHNpZ25pbmdDbGFpbURhdGEoY2xhaW0pIHtcbiAgICB2YXIgbnVtID0gYmlnSW50KFN0cmluZyhjbGFpbS5hbW91bnQpKTtcbiAgICB2YXIgcHJlZml4ID0gaGFzaF9wcmVmaXhlc18xLkhhc2hQcmVmaXgucGF5bWVudENoYW5uZWxDbGFpbTtcbiAgICB2YXIgY2hhbm5lbCA9IHR5cGVzXzEuY29yZVR5cGVzLkhhc2gyNTYuZnJvbShjbGFpbS5jaGFubmVsKS50b0J5dGVzKCk7XG4gICAgdmFyIGFtb3VudCA9IHR5cGVzXzEuY29yZVR5cGVzLlVJbnQ2NC5mcm9tKG51bSkudG9CeXRlcygpO1xuICAgIHZhciBieXRlc0xpc3QgPSBuZXcgYmluYXJ5X3NlcmlhbGl6ZXJfMS5CeXRlc0xpc3QoKTtcbiAgICBieXRlc0xpc3QucHV0KHByZWZpeCk7XG4gICAgYnl0ZXNMaXN0LnB1dChjaGFubmVsKTtcbiAgICBieXRlc0xpc3QucHV0KGFtb3VudCk7XG4gICAgcmV0dXJuIGJ5dGVzTGlzdC50b0J5dGVzKCk7XG59XG5leHBvcnRzLnNpZ25pbmdDbGFpbURhdGEgPSBzaWduaW5nQ2xhaW1EYXRhO1xuLyoqXG4gKiBTZXJpYWxpemUgYSB0cmFuc2FjdGlvbiBvYmplY3QgZm9yIG11bHRpU2lnbmluZ1xuICpcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbiB0cmFuc2FjdGlvbiB0byBzZXJpYWxpemVcbiAqIEBwYXJhbSBzaWduaW5nQWNjb3VudCBBY2NvdW50IHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uIHdpdGhcbiAqIEByZXR1cm5zIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gd2l0aCBhcHByb3ByaWF0ZSBwcmVmaXggYW5kIHN1ZmZpeFxuICovXG5mdW5jdGlvbiBtdWx0aVNpZ25pbmdEYXRhKHRyYW5zYWN0aW9uLCBzaWduaW5nQWNjb3VudCkge1xuICAgIHZhciBwcmVmaXggPSBoYXNoX3ByZWZpeGVzXzEuSGFzaFByZWZpeC50cmFuc2FjdGlvbk11bHRpU2lnO1xuICAgIHZhciBzdWZmaXggPSB0eXBlc18xLmNvcmVUeXBlcy5BY2NvdW50SUQuZnJvbShzaWduaW5nQWNjb3VudCkudG9CeXRlcygpO1xuICAgIHJldHVybiBzZXJpYWxpemVPYmplY3QodHJhbnNhY3Rpb24sIHtcbiAgICAgICAgcHJlZml4OiBwcmVmaXgsXG4gICAgICAgIHN1ZmZpeDogc3VmZml4LFxuICAgICAgICBzaWduaW5nRmllbGRzT25seTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMubXVsdGlTaWduaW5nRGF0YSA9IG11bHRpU2lnbmluZ0RhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5hcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnR5cGVzID0gZXhwb3J0cy5TaGFNYXAgPSBleHBvcnRzLkhhc2hQcmVmaXggPSBleHBvcnRzLnF1YWxpdHkgPSBleHBvcnRzLlRyYW5zYWN0aW9uUmVzdWx0ID0gZXhwb3J0cy5UeXBlID0gZXhwb3J0cy5MZWRnZXJFbnRyeVR5cGUgPSBleHBvcnRzLlRyYW5zYWN0aW9uVHlwZSA9IGV4cG9ydHMuRmllbGQgPSBleHBvcnRzLmxlZGdlckhhc2hlcyA9IGV4cG9ydHMuYmluYXJ5ID0gZXhwb3J0cy5oYXNoZXMgPSB2b2lkIDA7XG52YXIgZW51bXNfMSA9IHJlcXVpcmUoXCIuL2VudW1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmllbGRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuRmllbGQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc2FjdGlvblR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuVHJhbnNhY3Rpb25UeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGVkZ2VyRW50cnlUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnVtc18xLkxlZGdlckVudHJ5VHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVudW1zXzEuVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlRyYW5zYWN0aW9uUmVzdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbnVtc18xLlRyYW5zYWN0aW9uUmVzdWx0OyB9IH0pO1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5leHBvcnRzLnR5cGVzID0gdHlwZXM7XG52YXIgYmluYXJ5ID0gcmVxdWlyZShcIi4vYmluYXJ5XCIpO1xuZXhwb3J0cy5iaW5hcnkgPSBiaW5hcnk7XG52YXIgc2hhbWFwXzEgPSByZXF1aXJlKFwiLi9zaGFtYXBcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTaGFNYXBcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNoYW1hcF8xLlNoYU1hcDsgfSB9KTtcbnZhciBsZWRnZXJIYXNoZXMgPSByZXF1aXJlKFwiLi9sZWRnZXItaGFzaGVzXCIpO1xuZXhwb3J0cy5sZWRnZXJIYXNoZXMgPSBsZWRnZXJIYXNoZXM7XG52YXIgaGFzaGVzID0gcmVxdWlyZShcIi4vaGFzaGVzXCIpO1xuZXhwb3J0cy5oYXNoZXMgPSBoYXNoZXM7XG52YXIgcXVhbGl0eV8xID0gcmVxdWlyZShcIi4vcXVhbGl0eVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInF1YWxpdHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHF1YWxpdHlfMS5xdWFsaXR5OyB9IH0pO1xudmFyIGhhc2hfcHJlZml4ZXNfMSA9IHJlcXVpcmUoXCIuL2hhc2gtcHJlZml4ZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIYXNoUHJlZml4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoX3ByZWZpeGVzXzEuSGFzaFByZWZpeDsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmV0eXBlcy5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiVFlQRVNcIjoge1xuICAgIFwiVmFsaWRhdGlvblwiOiAxMDAwMyxcbiAgICBcIkRvbmVcIjogLTEsXG4gICAgXCJIYXNoMTI4XCI6IDQsXG4gICAgXCJCbG9iXCI6IDcsXG4gICAgXCJBY2NvdW50SURcIjogOCxcbiAgICBcIkFtb3VudFwiOiA2LFxuICAgIFwiSGFzaDI1NlwiOiA1LFxuICAgIFwiVUludDhcIjogMTYsXG4gICAgXCJWZWN0b3IyNTZcIjogMTksXG4gICAgXCJTVE9iamVjdFwiOiAxNCxcbiAgICBcIlVua25vd25cIjogLTIsXG4gICAgXCJUcmFuc2FjdGlvblwiOiAxMDAwMSxcbiAgICBcIkhhc2gxNjBcIjogMTcsXG4gICAgXCJQYXRoU2V0XCI6IDE4LFxuICAgIFwiTGVkZ2VyRW50cnlcIjogMTAwMDIsXG4gICAgXCJVSW50MTZcIjogMSxcbiAgICBcIk5vdFByZXNlbnRcIjogMCxcbiAgICBcIlVJbnQ2NFwiOiAzLFxuICAgIFwiVUludDMyXCI6IDIsXG4gICAgXCJTVEFycmF5XCI6IDE1XG4gIH0sXG4gIFwiTEVER0VSX0VOVFJZX1RZUEVTXCI6IHtcbiAgICBcIkFueVwiOiAtMyxcbiAgICBcIkNoaWxkXCI6IC0yLFxuICAgIFwiSW52YWxpZFwiOiAtMSxcbiAgICBcIkFjY291bnRSb290XCI6IDk3LFxuICAgIFwiRGlyZWN0b3J5Tm9kZVwiOiAxMDAsXG4gICAgXCJSaXBwbGVTdGF0ZVwiOiAxMTQsXG4gICAgXCJUaWNrZXRcIjogODQsXG4gICAgXCJTaWduZXJMaXN0XCI6IDgzLFxuICAgIFwiT2ZmZXJcIjogMTExLFxuICAgIFwiTGVkZ2VySGFzaGVzXCI6IDEwNCxcbiAgICBcIkFtZW5kbWVudHNcIjogMTAyLFxuICAgIFwiRmVlU2V0dGluZ3NcIjogMTE1LFxuICAgIFwiRXNjcm93XCI6IDExNyxcbiAgICBcIlBheUNoYW5uZWxcIjogMTIwLFxuICAgIFwiRGVwb3NpdFByZWF1dGhcIjogMTEyLFxuICAgIFwiQ2hlY2tcIjogNjcsXG4gICAgXCJOaWNrbmFtZVwiOiAxMTAsXG4gICAgXCJDb250cmFjdFwiOiA5OSxcbiAgICBcIk5GVG9rZW5QYWdlXCI6IDgwLFxuICAgIFwiTkZUb2tlbk9mZmVyXCI6IDU1LFxuICAgIFwiTmVnYXRpdmVVTkxcIjogNzhcbiAgfSxcbiAgXCJGSUVMRFNcIjogW1xuICAgIFtcbiAgICAgIFwiR2VuZXJpY1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAwLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVW5rbm93blwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkludmFsaWRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogLTEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJVbmtub3duXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiTGVkZ2VyRW50cnlUeXBlXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDE2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVHJhbnNhY3Rpb25UeXBlXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDIsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDE2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiU2lnbmVyV2VpZ2h0XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDMsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDE2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVHJhbnNmZXJGZWVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJGbGFnc1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlNvdXJjZVRhZ1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAzLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlNlcXVlbmNlXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDQsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiUHJldmlvdXNUeG5MZ3JTZXFcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJMZWRnZXJTZXF1ZW5jZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA2LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkNsb3NlVGltZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA3LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlBhcmVudENsb3NlVGltZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA4LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlNpZ25pbmdUaW1lXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDksXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiRXhwaXJhdGlvblwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxMCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUcmFuc2ZlclJhdGVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiV2FsbGV0U2l6ZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxMixcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJPd25lckNvdW50XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDEzLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkRlc3RpbmF0aW9uVGFnXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDE0LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkhpZ2hRdWFsaXR5SW5cIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTYsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiSGlnaFF1YWxpdHlPdXRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTcsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiTG93UXVhbGl0eUluXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDE4LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkxvd1F1YWxpdHlPdXRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTksXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiUXVhbGl0eUluXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDIwLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlF1YWxpdHlPdXRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMjEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiU3RhbXBFc2Nyb3dcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMjIsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQm9uZEFtb3VudFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyMyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJMb2FkRmVlXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDI0LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIk9mZmVyU2VxdWVuY2VcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMjUsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiRmlyc3RMZWRnZXJTZXF1ZW5jZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyNixcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJMYXN0TGVkZ2VyU2VxdWVuY2VcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMjcsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVHJhbnNhY3Rpb25JbmRleFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyOCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJPcGVyYXRpb25MaW1pdFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyOSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJSZWZlcmVuY2VGZWVVbml0c1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAzMCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJSZXNlcnZlQmFzZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAzMSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJSZXNlcnZlSW5jcmVtZW50XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDMyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlNldEZsYWdcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMzMsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQ2xlYXJGbGFnXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDM0LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlNpZ25lclF1b3J1bVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAzNSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJDYW5jZWxBZnRlclwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAzNixcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJGaW5pc2hBZnRlclwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAzNyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJJbmRleE5leHRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50NjRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJJbmRleFByZXZpb3VzXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDIsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDY0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQm9va05vZGVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50NjRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJPd25lck5vZGVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50NjRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJCYXNlRmVlXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDUsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDY0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiRXhjaGFuZ2VSYXRlXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDYsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDY0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiTG93Tm9kZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA3LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQ2NFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkhpZ2hOb2RlXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDgsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDY0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiRW1haWxIYXNoXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiSGFzaDEyOFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkxlZGdlckhhc2hcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiUGFyZW50SGFzaFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUcmFuc2FjdGlvbkhhc2hcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQWNjb3VudEhhc2hcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiUHJldmlvdXNUeG5JRFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA1LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJMZWRnZXJJbmRleFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA2LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJXYWxsZXRMb2NhdG9yXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDcsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiSGFzaDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlJvb3RJbmRleFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA4LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJBY2NvdW50VHhuSURcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogOSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVG9rZW5JRFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxMCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQm9va0RpcmVjdG9yeVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxNixcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiSW52b2ljZUlEXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDE3LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJOaWNrbmFtZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxOCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQW1lbmRtZW50XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDE5LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUaWNrZXRJRFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyMCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiRGlnZXN0XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDIxLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJoYXNoXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDI1NyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJpbmRleFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyNTgsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQW1vdW50XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQW1vdW50XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQmFsYW5jZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkFtb3VudFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkxpbWl0QW1vdW50XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDMsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQW1vdW50XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVGFrZXJQYXlzXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDQsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQW1vdW50XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVGFrZXJHZXRzXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDUsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQW1vdW50XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiTG93TGltaXRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNixcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJBbW91bnRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJIaWdoTGltaXRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJBbW91bnRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJGZWVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogOCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJBbW91bnRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJTZW5kTWF4XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDksXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQW1vdW50XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiRGVsaXZlck1pblwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxMCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJBbW91bnRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJNaW5pbXVtT2ZmZXJcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTYsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQW1vdW50XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiUmlwcGxlRXNjcm93XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDE3LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkFtb3VudFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkRlbGl2ZXJlZEFtb3VudFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxOCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJBbW91bnRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJCcm9rZXJGZWVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTksXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQW1vdW50XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwidGFrZXJfZ2V0c19mdW5kZWRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMjU4LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQW1vdW50XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwidGFrZXJfcGF5c19mdW5kZWRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMjU5LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQW1vdW50XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiUHVibGljS2V5XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJCbG9iXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiTWVzc2FnZUtleVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQmxvYlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlNpZ25pbmdQdWJLZXlcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkJsb2JcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUeG5TaWduYXR1cmVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IGZhbHNlLFxuICAgICAgICBcInR5cGVcIjogXCJCbG9iXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVVJJXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDUsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJCbG9iXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiU2lnbmF0dXJlXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDYsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQmxvYlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkRvbWFpblwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA3LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQmxvYlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkZ1bmRDb2RlXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDgsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJCbG9iXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiUmVtb3ZlQ29kZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA5LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQmxvYlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkV4cGlyZUNvZGVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTAsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJCbG9iXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQ3JlYXRlQ29kZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxMSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkJsb2JcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJNZW1vVHlwZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxMixcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkJsb2JcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJNZW1vRGF0YVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxMyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkJsb2JcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJNZW1vRm9ybWF0XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDE0LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQmxvYlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkZ1bGZpbGxtZW50XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDE2LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQmxvYlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkNvbmRpdGlvblwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxNyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkJsb2JcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJNYXN0ZXJTaWduYXR1cmVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTgsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQmxvYlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlVOTE1vZGlmeVZhbGlkYXRvclwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxOSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkJsb2JcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJWYWxpZGF0b3JUb0Rpc2FibGVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMjAsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJCbG9iXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVmFsaWRhdG9yVG9SZUVuYWJsZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyMSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkJsb2JcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJBY2NvdW50XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJBY2NvdW50SURcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJPd25lclwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQWNjb3VudElEXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiRGVzdGluYXRpb25cIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkFjY291bnRJRFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIklzc3VlclwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA0LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQWNjb3VudElEXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQXV0aG9yaXplXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDUsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJBY2NvdW50SURcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJVbmF1dGhvcml6ZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA2LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiQWNjb3VudElEXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVGFyZ2V0XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDcsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJBY2NvdW50SURcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJSZWd1bGFyS2V5XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDgsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJBY2NvdW50SURcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJNaW50ZXJcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogOSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkFjY291bnRJRFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIk9iamVjdEVuZE1hcmtlclwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlNUT2JqZWN0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVHJhbnNhY3Rpb25NZXRhRGF0YVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlNUT2JqZWN0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQ3JlYXRlZE5vZGVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJTVE9iamVjdFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkRlbGV0ZWROb2RlXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDQsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiU1RPYmplY3RcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJNb2RpZmllZE5vZGVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJTVE9iamVjdFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlByZXZpb3VzRmllbGRzXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDYsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiU1RPYmplY3RcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJGaW5hbEZpZWxkc1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA3LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlNUT2JqZWN0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiTmV3RmllbGRzXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDgsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiU1RPYmplY3RcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUZW1wbGF0ZUVudHJ5XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDksXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiU1RPYmplY3RcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJNZW1vXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDEwLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlNUT2JqZWN0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiU2lnbmVyRW50cnlcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiU1RPYmplY3RcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJOb25GdW5naWJsZVRva2VuXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDEyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlNUT2JqZWN0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiU2lnbmVyXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDE2LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlNUT2JqZWN0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiTWFqb3JpdHlcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTgsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiU1RPYmplY3RcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJEaXNhYmxlZFZhbGlkYXRvclwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxOSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJTVE9iamVjdFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIkFycmF5RW5kTWFya2VyXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiU1RBcnJheVwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlNpZ25lcnNcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiU1RBcnJheVwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlNpZ25lckVudHJpZXNcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJTVEFycmF5XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVGVtcGxhdGVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJTVEFycmF5XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiTmVjZXNzYXJ5XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDYsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiU1RBcnJheVwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlN1ZmZpY2llbnRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJTVEFycmF5XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQWZmZWN0ZWROb2Rlc1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA4LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlNUQXJyYXlcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJNZW1vc1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA5LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlNUQXJyYXlcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJOb25GdW5naWJsZVRva2Vuc1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxMCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJTVEFycmF5XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiTWFqb3JpdGllc1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxNixcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJTVEFycmF5XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiRGlzYWJsZWRWYWxpZGF0b3JzXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDE3LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlNUQXJyYXlcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJDbG9zZVJlc29sdXRpb25cIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50OFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIk1ldGhvZFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQ4XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVHJhbnNhY3Rpb25SZXN1bHRcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50OFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlRha2VyUGF5c0N1cnJlbmN5XCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDEsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiSGFzaDE2MFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlRha2VyUGF5c0lzc3VlclwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gxNjBcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUYWtlckdldHNDdXJyZW5jeVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAzLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gxNjBcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUYWtlckdldHNJc3N1ZXJcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMTYwXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiUGF0aHNcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJQYXRoU2V0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiSW5kZXhlc1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVmVjdG9yMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiSGFzaGVzXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDIsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJWZWN0b3IyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJBbWVuZG1lbnRzXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDMsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJWZWN0b3IyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUb2tlbk9mZmVyc1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA0LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVmVjdG9yMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVHJhbnNhY3Rpb25cIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcIlRyYW5zYWN0aW9uXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiTGVkZ2VyRW50cnlcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogZmFsc2UsXG4gICAgICAgIFwidHlwZVwiOiBcIkxlZGdlckVudHJ5XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVmFsaWRhdGlvblwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiBmYWxzZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVmFsaWRhdGlvblwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlNpZ25lckxpc3RJRFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAzOCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJTZXR0bGVEZWxheVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAzOSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUaWNrZXRDb3VudFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA0MCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUaWNrZXRTZXF1ZW5jZVwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA0MSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJUb2tlblRheG9uXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDQyLFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIlVJbnQzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIk1pbnRlZFRva2Vuc1wiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiA0MyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50MzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJCdXJuZWRUb2tlbnNcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogNDQsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQ2hhbm5lbFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyMixcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQ29uc2Vuc3VzSGFzaFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyMyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQ2hlY2tJRFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyNCxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVmFsaWRhdGVkSGFzaFwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyNSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiUHJldmlvdXNQYWdlTWluXCIsXG4gICAgICB7XG4gICAgICAgIFwibnRoXCI6IDI2LFxuICAgICAgICBcImlzVkxFbmNvZGVkXCI6IGZhbHNlLFxuICAgICAgICBcImlzU2VyaWFsaXplZFwiOiB0cnVlLFxuICAgICAgICBcImlzU2lnbmluZ0ZpZWxkXCI6IHRydWUsXG4gICAgICAgIFwidHlwZVwiOiBcIkhhc2gyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJOZXh0UGFnZU1pblwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyNyxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiQnV5T2ZmZXJcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMjgsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiSGFzaDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBbXG4gICAgICBcIlNlbGxPZmZlclwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAyOSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJIYXNoMjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiVGlja1NpemVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTYsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDhcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJVTkxNb2RpZnlEaXNhYmxpbmdcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTcsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDhcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJEZXN0aW5hdGlvbk5vZGVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogOSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50NjRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJDb29raWVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTAsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDY0XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIFwiU2VydmVyVmVyc2lvblwiLFxuICAgICAge1xuICAgICAgICBcIm50aFwiOiAxMSxcbiAgICAgICAgXCJpc1ZMRW5jb2RlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJpc1NlcmlhbGl6ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJpc1NpZ25pbmdGaWVsZFwiOiB0cnVlLFxuICAgICAgICBcInR5cGVcIjogXCJVSW50NjRcIlxuICAgICAgfVxuICAgIF0sXG4gICAgW1xuICAgICAgXCJPZmZlck5vZGVcIixcbiAgICAgIHtcbiAgICAgICAgXCJudGhcIjogMTIsXG4gICAgICAgIFwiaXNWTEVuY29kZWRcIjogZmFsc2UsXG4gICAgICAgIFwiaXNTZXJpYWxpemVkXCI6IHRydWUsXG4gICAgICAgIFwiaXNTaWduaW5nRmllbGRcIjogdHJ1ZSxcbiAgICAgICAgXCJ0eXBlXCI6IFwiVUludDY0XCJcbiAgICAgIH1cbiAgICBdXG4gIF0sXG4gIFwiVFJBTlNBQ1RJT05fUkVTVUxUU1wiOiB7XG4gICAgXCJ0ZWxMT0NBTF9FUlJPUlwiOiAtMzk5LFxuICAgIFwidGVsQkFEX0RPTUFJTlwiOiAtMzk4LFxuICAgIFwidGVsQkFEX1BBVEhfQ09VTlRcIjogLTM5NyxcbiAgICBcInRlbEJBRF9QVUJMSUNfS0VZXCI6IC0zOTYsXG4gICAgXCJ0ZWxGQUlMRURfUFJPQ0VTU0lOR1wiOiAtMzk1LFxuICAgIFwidGVsSU5TVUZfRkVFX1BcIjogLTM5NCxcbiAgICBcInRlbE5PX0RTVF9QQVJUSUFMXCI6IC0zOTMsXG4gICAgXCJ0ZWxDQU5fTk9UX1FVRVVFXCI6IC0zOTIsXG4gICAgXCJ0ZWxDQU5fTk9UX1FVRVVFX0JBTEFOQ0VcIjogLTM5MSxcbiAgICBcInRlbENBTl9OT1RfUVVFVUVfQkxPQ0tTXCI6IC0zOTAsXG4gICAgXCJ0ZWxDQU5fTk9UX1FVRVVFX0JMT0NLRURcIjogLTM4OSxcbiAgICBcInRlbENBTl9OT1RfUVVFVUVfRkVFXCI6IC0zODgsXG4gICAgXCJ0ZWxDQU5fTk9UX1FVRVVFX0ZVTExcIjogLTM4NyxcblxuICAgIFwidGVtTUFMRk9STUVEXCI6IC0yOTksXG4gICAgXCJ0ZW1CQURfQU1PVU5UXCI6IC0yOTgsXG4gICAgXCJ0ZW1CQURfQ1VSUkVOQ1lcIjogLTI5NyxcbiAgICBcInRlbUJBRF9FWFBJUkFUSU9OXCI6IC0yOTYsXG4gICAgXCJ0ZW1CQURfRkVFXCI6IC0yOTUsXG4gICAgXCJ0ZW1CQURfSVNTVUVSXCI6IC0yOTQsXG4gICAgXCJ0ZW1CQURfTElNSVRcIjogLTI5MyxcbiAgICBcInRlbUJBRF9PRkZFUlwiOiAtMjkyLFxuICAgIFwidGVtQkFEX1BBVEhcIjogLTI5MSxcbiAgICBcInRlbUJBRF9QQVRIX0xPT1BcIjogLTI5MCxcbiAgICBcInRlbUJBRF9SRUdLRVlcIjogLTI4OSxcbiAgICBcInRlbUJBRF9TRU5EX1hSUF9MSU1JVFwiOiAtMjg4LFxuICAgIFwidGVtQkFEX1NFTkRfWFJQX01BWFwiOiAtMjg3LFxuICAgIFwidGVtQkFEX1NFTkRfWFJQX05PX0RJUkVDVFwiOiAtMjg2LFxuICAgIFwidGVtQkFEX1NFTkRfWFJQX1BBUlRJQUxcIjogLTI4NSxcbiAgICBcInRlbUJBRF9TRU5EX1hSUF9QQVRIU1wiOiAtMjg0LFxuICAgIFwidGVtQkFEX1NFUVVFTkNFXCI6IC0yODMsXG4gICAgXCJ0ZW1CQURfU0lHTkFUVVJFXCI6IC0yODIsXG4gICAgXCJ0ZW1CQURfU1JDX0FDQ09VTlRcIjogLTI4MSxcbiAgICBcInRlbUJBRF9UUkFOU0ZFUl9SQVRFXCI6IC0yODAsXG4gICAgXCJ0ZW1EU1RfSVNfU1JDXCI6IC0yNzksXG4gICAgXCJ0ZW1EU1RfTkVFREVEXCI6IC0yNzgsXG4gICAgXCJ0ZW1JTlZBTElEXCI6IC0yNzcsXG4gICAgXCJ0ZW1JTlZBTElEX0ZMQUdcIjogLTI3NixcbiAgICBcInRlbVJFRFVOREFOVFwiOiAtMjc1LFxuICAgIFwidGVtUklQUExFX0VNUFRZXCI6IC0yNzQsXG4gICAgXCJ0ZW1ESVNBQkxFRFwiOiAtMjczLFxuICAgIFwidGVtQkFEX1NJR05FUlwiOiAtMjcyLFxuICAgIFwidGVtQkFEX1FVT1JVTVwiOiAtMjcxLFxuICAgIFwidGVtQkFEX1dFSUdIVFwiOiAtMjcwLFxuICAgIFwidGVtQkFEX1RJQ0tfU0laRVwiOiAtMjY5LFxuICAgIFwidGVtSU5WQUxJRF9BQ0NPVU5UX0lEXCI6IC0yNjgsXG4gICAgXCJ0ZW1DQU5OT1RfUFJFQVVUSF9TRUxGXCI6IC0yNjcsXG4gICAgXCJ0ZW1VTkNFUlRBSU5cIjogLTI2NixcbiAgICBcInRlbVVOS05PV05cIjogLTI2NSxcblxuICAgIFwidGVmRkFJTFVSRVwiOiAtMTk5LFxuICAgIFwidGVmQUxSRUFEWVwiOiAtMTk4LFxuICAgIFwidGVmQkFEX0FERF9BVVRIXCI6IC0xOTcsXG4gICAgXCJ0ZWZCQURfQVVUSFwiOiAtMTk2LFxuICAgIFwidGVmQkFEX0xFREdFUlwiOiAtMTk1LFxuICAgIFwidGVmQ1JFQVRFRFwiOiAtMTk0LFxuICAgIFwidGVmRVhDRVBUSU9OXCI6IC0xOTMsXG4gICAgXCJ0ZWZJTlRFUk5BTFwiOiAtMTkyLFxuICAgIFwidGVmTk9fQVVUSF9SRVFVSVJFRFwiOiAtMTkxLFxuICAgIFwidGVmUEFTVF9TRVFcIjogLTE5MCxcbiAgICBcInRlZldST05HX1BSSU9SXCI6IC0xODksXG4gICAgXCJ0ZWZNQVNURVJfRElTQUJMRURcIjogLTE4OCxcbiAgICBcInRlZk1BWF9MRURHRVJcIjogLTE4NyxcbiAgICBcInRlZkJBRF9TSUdOQVRVUkVcIjogLTE4NixcbiAgICBcInRlZkJBRF9RVU9SVU1cIjogLTE4NSxcbiAgICBcInRlZk5PVF9NVUxUSV9TSUdOSU5HXCI6IC0xODQsXG4gICAgXCJ0ZWZCQURfQVVUSF9NQVNURVJcIjogLTE4MyxcbiAgICBcInRlZklOVkFSSUFOVF9GQUlMRURcIjogLTE4MixcbiAgICBcInRlZlRPT19CSUdcIjogLTE4MSxcbiAgICBcInRlZk5PX1RJQ0tFVFwiOiAtMTgwLFxuICAgIFwidGVmVE9LRU5fSVNfTk9UX1RSQU5TRkVSQUJMRVwiOiAtMTc5LFxuXG4gICAgXCJ0ZXJSRVRSWVwiOiAtOTksXG4gICAgXCJ0ZXJGVU5EU19TUEVOVFwiOiAtOTgsXG4gICAgXCJ0ZXJJTlNVRl9GRUVfQlwiOiAtOTcsXG4gICAgXCJ0ZXJOT19BQ0NPVU5UXCI6IC05NixcbiAgICBcInRlck5PX0FVVEhcIjogLTk1LFxuICAgIFwidGVyTk9fTElORVwiOiAtOTQsXG4gICAgXCJ0ZXJPV05FUlNcIjogLTkzLFxuICAgIFwidGVyUFJFX1NFUVwiOiAtOTIsXG4gICAgXCJ0ZXJMQVNUXCI6IC05MSxcbiAgICBcInRlck5PX1JJUFBMRVwiOiAtOTAsXG4gICAgXCJ0ZXJRVUVVRURcIjogLTg5LFxuXG4gICAgXCJ0ZXNTVUNDRVNTXCI6IDAsXG5cbiAgICBcInRlY0NMQUlNXCI6IDEwMCxcbiAgICBcInRlY1BBVEhfUEFSVElBTFwiOiAxMDEsXG4gICAgXCJ0ZWNVTkZVTkRFRF9BRERcIjogMTAyLFxuICAgIFwidGVjVU5GVU5ERURfT0ZGRVJcIjogMTAzLFxuICAgIFwidGVjVU5GVU5ERURfUEFZTUVOVFwiOiAxMDQsXG4gICAgXCJ0ZWNGQUlMRURfUFJPQ0VTU0lOR1wiOiAxMDUsXG4gICAgXCJ0ZWNESVJfRlVMTFwiOiAxMjEsXG4gICAgXCJ0ZWNJTlNVRl9SRVNFUlZFX0xJTkVcIjogMTIyLFxuICAgIFwidGVjSU5TVUZfUkVTRVJWRV9PRkZFUlwiOiAxMjMsXG4gICAgXCJ0ZWNOT19EU1RcIjogMTI0LFxuICAgIFwidGVjTk9fRFNUX0lOU1VGX1hSUFwiOiAxMjUsXG4gICAgXCJ0ZWNOT19MSU5FX0lOU1VGX1JFU0VSVkVcIjogMTI2LFxuICAgIFwidGVjTk9fTElORV9SRURVTkRBTlRcIjogMTI3LFxuICAgIFwidGVjUEFUSF9EUllcIjogMTI4LFxuICAgIFwidGVjVU5GVU5ERURcIjogMTI5LFxuICAgIFwidGVjTk9fQUxURVJOQVRJVkVfS0VZXCI6IDEzMCxcbiAgICBcInRlY05PX1JFR1VMQVJfS0VZXCI6IDEzMSxcbiAgICBcInRlY09XTkVSU1wiOiAxMzIsXG4gICAgXCJ0ZWNOT19JU1NVRVJcIjogMTMzLFxuICAgIFwidGVjTk9fQVVUSFwiOiAxMzQsXG4gICAgXCJ0ZWNOT19MSU5FXCI6IDEzNSxcbiAgICBcInRlY0lOU1VGRl9GRUVcIjogMTM2LFxuICAgIFwidGVjRlJPWkVOXCI6IDEzNyxcbiAgICBcInRlY05PX1RBUkdFVFwiOiAxMzgsXG4gICAgXCJ0ZWNOT19QRVJNSVNTSU9OXCI6IDEzOSxcbiAgICBcInRlY05PX0VOVFJZXCI6IDE0MCxcbiAgICBcInRlY0lOU1VGRklDSUVOVF9SRVNFUlZFXCI6IDE0MSxcbiAgICBcInRlY05FRURfTUFTVEVSX0tFWVwiOiAxNDIsXG4gICAgXCJ0ZWNEU1RfVEFHX05FRURFRFwiOiAxNDMsXG4gICAgXCJ0ZWNJTlRFUk5BTFwiOiAxNDQsXG4gICAgXCJ0ZWNPVkVSU0laRVwiOiAxNDUsXG4gICAgXCJ0ZWNDUllQVE9DT05ESVRJT05fRVJST1JcIjogMTQ2LFxuICAgIFwidGVjSU5WQVJJQU5UX0ZBSUxFRFwiOiAxNDcsXG4gICAgXCJ0ZWNFWFBJUkVEXCI6IDE0OCxcbiAgICBcInRlY0RVUExJQ0FURVwiOiAxNDksXG4gICAgXCJ0ZWNLSUxMRURcIjogMTUwLFxuICAgIFwidGVjSEFTX09CTElHQVRJT05TXCI6IDE1MSxcbiAgICBcInRlY1RPT19TT09OXCI6IDE1MixcblxuICAgIFwidGVjTUFYX1NFUVVFTkNFX1JFQUNIRURcIjogMTU0LFxuICAgIFwidGVjTk9fU1VJVEFCTEVfUEFHRVwiOiAxNTUsXG4gICAgXCJ0ZWNCVVlfU0VMTF9NSVNNQVRDSFwiOiAxNTYsXG4gICAgXCJ0ZWNPRkZFUl9UWVBFX01JU01BVENIXCI6IDE1NyxcbiAgICBcInRlY0NBTlRfQUNDRVBUX09XTl9PRkZFUlwiOiAxNTgsXG4gICAgXCJ0ZWNJTlNVRkZJQ0lFTlRfRlVORFNcIjogMTU5LFxuICAgIFwidGVjT0JKRUNUX05PVF9GT1VORFwiOiAxNjAsXG4gICAgXCJ0ZWNJTlNVRkZJQ0lFTlRfUEFZTUVOVFwiOiAxNjEsXG4gICAgXCJ0ZWNJTkNPUlJFQ1RfQVNTRVRcIjogMTYyLFxuICAgIFwidGVjVE9PX01BTllcIjogMTYzXG4gIH0sXG4gIFwiVFJBTlNBQ1RJT05fVFlQRVNcIjoge1xuICAgIFwiSW52YWxpZFwiOiAtMSxcblxuICAgIFwiUGF5bWVudFwiOiAwLFxuICAgIFwiRXNjcm93Q3JlYXRlXCI6IDEsXG4gICAgXCJFc2Nyb3dGaW5pc2hcIjogMixcbiAgICBcIkFjY291bnRTZXRcIjogMyxcbiAgICBcIkVzY3Jvd0NhbmNlbFwiOiA0LFxuICAgIFwiU2V0UmVndWxhcktleVwiOiA1LFxuICAgIFwiTmlja05hbWVTZXRcIjogNixcbiAgICBcIk9mZmVyQ3JlYXRlXCI6IDcsXG4gICAgXCJPZmZlckNhbmNlbFwiOiA4LFxuICAgIFwiQ29udHJhY3RcIjogOSxcbiAgICBcIlRpY2tldENyZWF0ZVwiOiAxMCxcbiAgICBcIlRpY2tldENhbmNlbFwiOiAxMSxcbiAgICBcIlNpZ25lckxpc3RTZXRcIjogMTIsXG4gICAgXCJQYXltZW50Q2hhbm5lbENyZWF0ZVwiOiAxMyxcbiAgICBcIlBheW1lbnRDaGFubmVsRnVuZFwiOiAxNCxcbiAgICBcIlBheW1lbnRDaGFubmVsQ2xhaW1cIjogMTUsXG4gICAgXCJDaGVja0NyZWF0ZVwiOiAxNixcbiAgICBcIkNoZWNrQ2FzaFwiOiAxNyxcbiAgICBcIkNoZWNrQ2FuY2VsXCI6IDE4LFxuICAgIFwiRGVwb3NpdFByZWF1dGhcIjogMTksXG4gICAgXCJUcnVzdFNldFwiOiAyMCxcbiAgICBcIkFjY291bnREZWxldGVcIjogMjEsXG4gICAgXCJORlRva2VuTWludFwiOiAyNSxcbiAgICBcIk5GVG9rZW5CdXJuXCI6IDI2LFxuICAgIFwiTkZUb2tlbkNyZWF0ZU9mZmVyXCI6IDI3LFxuICAgIFwiTkZUb2tlbkNhbmNlbE9mZmVyXCI6IDI4LFxuICAgIFwiTkZUb2tlbkFjY2VwdE9mZmVyXCI6IDI5LFxuICAgIFwiRW5hYmxlQW1lbmRtZW50XCI6IDEwMCxcbiAgICBcIlNldEZlZVwiOiAxMDEsXG4gICAgXCJVTkxNb2RpZnlcIjogMTAyXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc2FjdGlvblR5cGUgPSBleHBvcnRzLlRyYW5zYWN0aW9uUmVzdWx0ID0gZXhwb3J0cy5MZWRnZXJFbnRyeVR5cGUgPSBleHBvcnRzLlR5cGUgPSBleHBvcnRzLkZpZWxkID0gZXhwb3J0cy5CeXRlcyA9IGV4cG9ydHMuVFJBTlNBQ1RJT05fVFlQRVMgPSB2b2lkIDA7XG52YXIgZW51bXMgPSByZXF1aXJlKFwiLi9kZWZpbml0aW9ucy5qc29uXCIpO1xudmFyIHNlcmlhbGl6ZWRfdHlwZV8xID0gcmVxdWlyZShcIi4uL3R5cGVzL3NlcmlhbGl6ZWQtdHlwZVwiKTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLypcbiAqIEBicmllZjogQWxsIHZhbGlkIHRyYW5zYWN0aW9uIHR5cGVzXG4gKi9cbmV4cG9ydHMuVFJBTlNBQ1RJT05fVFlQRVMgPSBPYmplY3QuZW50cmllcyhlbnVtcy5UUkFOU0FDVElPTl9UWVBFUylcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfa2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgcmV0dXJuIHZhbHVlID49IDA7XG59KVxuICAgIC5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGtleSA9IF9hWzBdLCBfdmFsdWUgPSBfYVsxXTtcbiAgICByZXR1cm4ga2V5O1xufSk7XG52YXIgVFlQRV9XSURUSCA9IDI7XG52YXIgTEVER0VSX0VOVFJZX1dJRFRIID0gMjtcbnZhciBUUkFOU0FDVElPTl9UWVBFX1dJRFRIID0gMjtcbnZhciBUUkFOU0FDVElPTl9SRVNVTFRfV0lEVEggPSAxO1xuLypcbiAqIEBicmllZjogU2VyaWFsaXplIGEgZmllbGQgYmFzZWQgb24gdHlwZV9jb2RlIGFuZCBGaWVsZC5udGhcbiAqL1xuZnVuY3Rpb24gZmllbGRIZWFkZXIodHlwZSwgbnRoKSB7XG4gICAgdmFyIGhlYWRlciA9IFtdO1xuICAgIGlmICh0eXBlIDwgMTYpIHtcbiAgICAgICAgaWYgKG50aCA8IDE2KSB7XG4gICAgICAgICAgICBoZWFkZXIucHVzaCgodHlwZSA8PCA0KSB8IG50aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXIucHVzaCh0eXBlIDw8IDQsIG50aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAobnRoIDwgMTYpIHtcbiAgICAgICAgaGVhZGVyLnB1c2gobnRoLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhlYWRlci5wdXNoKDAsIHR5cGUsIG50aCk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbShoZWFkZXIpO1xufVxuLypcbiAqIEBicmllZjogQnl0ZXMsIG5hbWUsIGFuZCBvcmRpbmFsIHJlcHJlc2VudGluZyBvbmUgdHlwZSwgbGVkZ2VyX3R5cGUsIHRyYW5zYWN0aW9uIHR5cGUsIG9yIHJlc3VsdFxuICovXG52YXIgQnl0ZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnl0ZXMobmFtZSwgb3JkaW5hbCwgb3JkaW5hbFdpZHRoKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMub3JkaW5hbCA9IG9yZGluYWw7XG4gICAgICAgIHRoaXMub3JkaW5hbFdpZHRoID0gb3JkaW5hbFdpZHRoO1xuICAgICAgICB0aGlzLmJ5dGVzID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKG9yZGluYWxXaWR0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkaW5hbFdpZHRoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNbb3JkaW5hbFdpZHRoIC0gaSAtIDFdID0gKG9yZGluYWwgPj4+IChpICogOCkpICYgMHhmZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBCeXRlcy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH07XG4gICAgQnl0ZXMucHJvdG90eXBlLnRvQnl0ZXNTaW5rID0gZnVuY3Rpb24gKHNpbmspIHtcbiAgICAgICAgc2luay5wdXQodGhpcy5ieXRlcyk7XG4gICAgfTtcbiAgICBCeXRlcy5wcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXM7XG4gICAgfTtcbiAgICByZXR1cm4gQnl0ZXM7XG59KCkpO1xuZXhwb3J0cy5CeXRlcyA9IEJ5dGVzO1xuLypcbiAqIEBicmllZjogQ29sbGVjdGlvbiBvZiBCeXRlcyBvYmplY3RzLCBtYXBwaW5nIGJpZGlyZWN0aW9uYWxseVxuICovXG52YXIgQnl0ZXNMb29rdXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQnl0ZXNMb29rdXAodHlwZXMsIG9yZGluYWxXaWR0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLm9yZGluYWxXaWR0aCA9IG9yZGluYWxXaWR0aDtcbiAgICAgICAgT2JqZWN0LmVudHJpZXModHlwZXMpLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgayA9IF9hWzBdLCB2ID0gX2FbMV07XG4gICAgICAgICAgICBfdGhpc1trXSA9IG5ldyBCeXRlcyhrLCB2LCBvcmRpbmFsV2lkdGgpO1xuICAgICAgICAgICAgX3RoaXNbdi50b1N0cmluZygpXSA9IF90aGlzW2tdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgQnl0ZXNMb29rdXAucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQnl0ZXMgPyB2YWx1ZSA6IHRoaXNbdmFsdWVdO1xuICAgIH07XG4gICAgQnl0ZXNMb29rdXAucHJvdG90eXBlLmZyb21QYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20ocGFyc2VyLnJlYWRVSW50Tih0aGlzLm9yZGluYWxXaWR0aCkudG9TdHJpbmcoKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQnl0ZXNMb29rdXA7XG59KCkpO1xuZnVuY3Rpb24gYnVpbGRGaWVsZChfYSkge1xuICAgIHZhciBuYW1lID0gX2FbMF0sIGluZm8gPSBfYVsxXTtcbiAgICB2YXIgdHlwZU9yZGluYWwgPSBlbnVtcy5UWVBFU1tpbmZvLnR5cGVdO1xuICAgIHZhciBmaWVsZCA9IGZpZWxkSGVhZGVyKHR5cGVPcmRpbmFsLCBpbmZvLm50aCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgbnRoOiBpbmZvLm50aCxcbiAgICAgICAgaXNWYXJpYWJsZUxlbmd0aEVuY29kZWQ6IGluZm8uaXNWTEVuY29kZWQsXG4gICAgICAgIGlzU2VyaWFsaXplZDogaW5mby5pc1NlcmlhbGl6ZWQsXG4gICAgICAgIGlzU2lnbmluZ0ZpZWxkOiBpbmZvLmlzU2lnbmluZ0ZpZWxkLFxuICAgICAgICBvcmRpbmFsOiAodHlwZU9yZGluYWwgPDwgMTYpIHwgaW5mby5udGgsXG4gICAgICAgIHR5cGU6IG5ldyBCeXRlcyhpbmZvLnR5cGUsIHR5cGVPcmRpbmFsLCBUWVBFX1dJRFRIKSxcbiAgICAgICAgaGVhZGVyOiBmaWVsZCxcbiAgICAgICAgYXNzb2NpYXRlZFR5cGU6IHNlcmlhbGl6ZWRfdHlwZV8xLlNlcmlhbGl6ZWRUeXBlLCAvLyBGb3IgbGF0ZXIgYXNzaWdubWVudCBpbiAuL3R5cGVzL2luZGV4LmpzXG4gICAgfTtcbn1cbi8qXG4gKiBAYnJpZWY6IFRoZSBjb2xsZWN0aW9uIG9mIGFsbCBmaWVsZHMgYXMgZGVmaW5lZCBpbiBkZWZpbml0aW9ucy5qc29uXG4gKi9cbnZhciBGaWVsZExvb2t1cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWVsZExvb2t1cChmaWVsZHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgayA9IF9hWzBdLCB2ID0gX2FbMV07XG4gICAgICAgICAgICBfdGhpc1trXSA9IGJ1aWxkRmllbGQoW2ssIHZdKTtcbiAgICAgICAgICAgIF90aGlzW190aGlzW2tdLm9yZGluYWwudG9TdHJpbmcoKV0gPSBfdGhpc1trXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIEZpZWxkTG9va3VwLnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3ZhbHVlXTtcbiAgICB9O1xuICAgIHJldHVybiBGaWVsZExvb2t1cDtcbn0oKSk7XG52YXIgVHlwZSA9IG5ldyBCeXRlc0xvb2t1cChlbnVtcy5UWVBFUywgVFlQRV9XSURUSCk7XG5leHBvcnRzLlR5cGUgPSBUeXBlO1xudmFyIExlZGdlckVudHJ5VHlwZSA9IG5ldyBCeXRlc0xvb2t1cChlbnVtcy5MRURHRVJfRU5UUllfVFlQRVMsIExFREdFUl9FTlRSWV9XSURUSCk7XG5leHBvcnRzLkxlZGdlckVudHJ5VHlwZSA9IExlZGdlckVudHJ5VHlwZTtcbnZhciBUcmFuc2FjdGlvblR5cGUgPSBuZXcgQnl0ZXNMb29rdXAoZW51bXMuVFJBTlNBQ1RJT05fVFlQRVMsIFRSQU5TQUNUSU9OX1RZUEVfV0lEVEgpO1xuZXhwb3J0cy5UcmFuc2FjdGlvblR5cGUgPSBUcmFuc2FjdGlvblR5cGU7XG52YXIgVHJhbnNhY3Rpb25SZXN1bHQgPSBuZXcgQnl0ZXNMb29rdXAoZW51bXMuVFJBTlNBQ1RJT05fUkVTVUxUUywgVFJBTlNBQ1RJT05fUkVTVUxUX1dJRFRIKTtcbmV4cG9ydHMuVHJhbnNhY3Rpb25SZXN1bHQgPSBUcmFuc2FjdGlvblJlc3VsdDtcbnZhciBGaWVsZCA9IG5ldyBGaWVsZExvb2t1cChlbnVtcy5GSUVMRFMpO1xuZXhwb3J0cy5GaWVsZCA9IEZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhhc2hQcmVmaXggPSB2b2lkIDA7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogV3JpdGUgYSAzMiBiaXQgaW50ZWdlciB0byBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB1aW50MzIgMzIgYml0IGludGVnZXIgdG8gd3JpdGUgdG8gYnVmZmVyXG4gKiBAcmV0dXJucyBhIGJ1ZmZlciB3aXRoIHRoZSBieXRlcyByZXByZXNlbnRhdGlvbiBvZiB1aW50MzJcbiAqL1xuZnVuY3Rpb24gYnl0ZXModWludDMyKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KTtcbiAgICByZXN1bHQud3JpdGVVSW50MzJCRSh1aW50MzIsIDApO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIE1hcHMgSGFzaFByZWZpeCBuYW1lcyB0byB0aGVpciBieXRlIHJlcHJlc2VudGF0aW9uXG4gKi9cbnZhciBIYXNoUHJlZml4ID0ge1xuICAgIHRyYW5zYWN0aW9uSUQ6IGJ5dGVzKDB4NTQ1ODRlMDApLFxuICAgIC8vIHRyYW5zYWN0aW9uIHBsdXMgbWV0YWRhdGFcbiAgICB0cmFuc2FjdGlvbjogYnl0ZXMoMHg1MzRlNDQwMCksXG4gICAgLy8gYWNjb3VudCBzdGF0ZVxuICAgIGFjY291bnRTdGF0ZUVudHJ5OiBieXRlcygweDRkNGM0ZTAwKSxcbiAgICAvLyBpbm5lciBub2RlIGluIHRyZWVcbiAgICBpbm5lck5vZGU6IGJ5dGVzKDB4NGQ0OTRlMDApLFxuICAgIC8vIGxlZGdlciBtYXN0ZXIgZGF0YSBmb3Igc2lnbmluZ1xuICAgIGxlZGdlckhlYWRlcjogYnl0ZXMoMHg0YzU3NTIwMCksXG4gICAgLy8gaW5uZXIgdHJhbnNhY3Rpb24gdG8gc2lnblxuICAgIHRyYW5zYWN0aW9uU2lnOiBieXRlcygweDUzNTQ1ODAwKSxcbiAgICAvLyBpbm5lciB0cmFuc2FjdGlvbiB0byBzaWduXG4gICAgdHJhbnNhY3Rpb25NdWx0aVNpZzogYnl0ZXMoMHg1MzRkNTQwMCksXG4gICAgLy8gdmFsaWRhdGlvbiBmb3Igc2lnbmluZ1xuICAgIHZhbGlkYXRpb246IGJ5dGVzKDB4NTY0MTRjMDApLFxuICAgIC8vIHByb3Bvc2FsIGZvciBzaWduaW5nXG4gICAgcHJvcG9zYWw6IGJ5dGVzKDB4NTA1MjUwMDApLFxuICAgIC8vIHBheW1lbnQgY2hhbm5lbCBjbGFpbVxuICAgIHBheW1lbnRDaGFubmVsQ2xhaW06IGJ5dGVzKDB4NDM0YzRkMDApLFxufTtcbmV4cG9ydHMuSGFzaFByZWZpeCA9IEhhc2hQcmVmaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXByZWZpeGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJhbnNhY3Rpb25JRCA9IGV4cG9ydHMuc2hhNTEySGFsZiA9IGV4cG9ydHMuU2hhNTEySGFsZiA9IHZvaWQgMDtcbnZhciBoYXNoX3ByZWZpeGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoLXByZWZpeGVzXCIpO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKFwiY3JlYXRlLWhhc2hcIik7XG52YXIgaGFzaF8yNTZfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL2hhc2gtMjU2XCIpO1xudmFyIGJpbmFyeV9zZXJpYWxpemVyXzEgPSByZXF1aXJlKFwiLi9zZXJkZXMvYmluYXJ5LXNlcmlhbGl6ZXJcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogQ2xhc3MgZm9yIGhhc2hpbmcgd2l0aCBTSEE1MTJcbiAqIEBleHRlbmRzIEJ5dGVzTGlzdCBTbyBTZXJpYWxpemVkVHlwZXMgY2FuIHdyaXRlIGJ5dGVzIHRvIGEgU2hhNTEySGFsZlxuICovXG52YXIgU2hhNTEySGFsZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2hhNTEySGFsZiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaGE1MTJIYWxmKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFzaCA9IGNyZWF0ZUhhc2goJ3NoYTUxMicpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIG5ldyBTaGE1MTJIYXNoIGFuZCB3cml0ZSBieXRlcyB0aGlzLmhhc2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyBieXRlcyB0byB3cml0ZSB0byB0aGlzLmhhc2hcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IFNoYTUxMkhhc2ggb2JqZWN0XG4gICAgICovXG4gICAgU2hhNTEySGFsZi5wdXQgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaGE1MTJIYWxmKCkucHV0KGJ5dGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdyaXRlIGJ5dGVzIHRvIGFuIGV4aXN0aW5nIFNoYTUxMkhhc2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyBieXRlcyB0byB3cml0ZSB0byBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB0aGUgU2hhNTEyIG9iamVjdFxuICAgICAqL1xuICAgIFNoYTUxMkhhbGYucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICB0aGlzLmhhc2gudXBkYXRlKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIFNIQTUxMiBoYXNoIGFuZCBzbGljZSBpbiBoYWxmXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBoYWxmIG9mIGEgU0hBNTEyIGhhc2hcbiAgICAgKi9cbiAgICBTaGE1MTJIYWxmLnByb3RvdHlwZS5maW5pc2gyNTYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbSh0aGlzLmhhc2guZGlnZXN0KCkuc2xpY2UoMCwgMzIpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBIYXNoMjU2IGZyb20gdGhlIFNoYTUxMkhhbGYgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIEhhc2gyNTYgb2JqZWN0XG4gICAgICovXG4gICAgU2hhNTEySGFsZi5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IGhhc2hfMjU2XzEuSGFzaDI1Nih0aGlzLmZpbmlzaDI1NigpKTtcbiAgICB9O1xuICAgIHJldHVybiBTaGE1MTJIYWxmO1xufShiaW5hcnlfc2VyaWFsaXplcl8xLkJ5dGVzTGlzdCkpO1xuZXhwb3J0cy5TaGE1MTJIYWxmID0gU2hhNTEySGFsZjtcbi8qKlxuICogY29tcHV0ZSBTSEE1MTIgaGFzaCBvZiBhIGxpc3Qgb2YgYnl0ZXNcbiAqXG4gKiBAcGFyYW0gYXJncyB6ZXJvIG9yIG1vcmUgYXJndW1lbnRzIHRvIGhhc2hcbiAqIEByZXR1cm5zIHRoZSBzaGE1MTJoYWxmIGhhc2ggb2YgdGhlIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2hhNTEySGFsZigpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGhhc2ggPSBuZXcgU2hhNTEySGFsZigpO1xuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoYSkgeyByZXR1cm4gaGFzaC5wdXQoYSk7IH0pO1xuICAgIHJldHVybiBoYXNoLmZpbmlzaDI1NigpO1xufVxuZXhwb3J0cy5zaGE1MTJIYWxmID0gc2hhNTEySGFsZjtcbi8qKlxuICogQ29uc3RydWN0IGEgdHJhbnNhY3Rpb25JRCBmcm9tIGEgU2VyaWFsaXplZCBUcmFuc2FjdGlvblxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIGJ5dGVzIHRvIGhhc2hcbiAqIEByZXR1cm5zIGEgSGFzaDI1NiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gdHJhbnNhY3Rpb25JRChzZXJpYWxpemVkKSB7XG4gICAgcmV0dXJuIG5ldyBoYXNoXzI1Nl8xLkhhc2gyNTYoc2hhNTEySGFsZihoYXNoX3ByZWZpeGVzXzEuSGFzaFByZWZpeC50cmFuc2FjdGlvbklELCBzZXJpYWxpemVkKSk7XG59XG5leHBvcnRzLnRyYW5zYWN0aW9uSUQgPSB0cmFuc2FjdGlvbklEO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG52YXIgY29yZXR5cGVzXzEgPSByZXF1aXJlKFwiLi9jb3JldHlwZXNcIik7XG52YXIgbGVkZ2VyX2hhc2hlc18xID0gcmVxdWlyZShcIi4vbGVkZ2VyLWhhc2hlc1wiKTtcbnZhciBlbnVtc18xID0gcmVxdWlyZShcIi4vZW51bXNcIik7XG52YXIgc2lnbmluZ0RhdGEgPSBjb3JldHlwZXNfMS5iaW5hcnkuc2lnbmluZ0RhdGEsIHNpZ25pbmdDbGFpbURhdGEgPSBjb3JldHlwZXNfMS5iaW5hcnkuc2lnbmluZ0NsYWltRGF0YSwgbXVsdGlTaWduaW5nRGF0YSA9IGNvcmV0eXBlc18xLmJpbmFyeS5tdWx0aVNpZ25pbmdEYXRhLCBiaW5hcnlUb0pTT04gPSBjb3JldHlwZXNfMS5iaW5hcnkuYmluYXJ5VG9KU09OLCBzZXJpYWxpemVPYmplY3QgPSBjb3JldHlwZXNfMS5iaW5hcnkuc2VyaWFsaXplT2JqZWN0O1xuLyoqXG4gKiBEZWNvZGUgYSB0cmFuc2FjdGlvblxuICpcbiAqIEBwYXJhbSBiaW5hcnkgaGV4LXN0cmluZyBvZiB0aGUgZW5jb2RlZCB0cmFuc2FjdGlvblxuICogQHJldHVybnMgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShiaW5hcnkpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIGJpbmFyeSA9PT0gJ3N0cmluZycsICdiaW5hcnkgbXVzdCBiZSBhIGhleCBzdHJpbmcnKTtcbiAgICByZXR1cm4gYmluYXJ5VG9KU09OKGJpbmFyeSk7XG59XG4vKipcbiAqIEVuY29kZSBhIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIGpzb24gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSB0cmFuc2FjdGlvblxuICogQHJldHVybnMgQSBoZXgtc3RyaW5nIG9mIHRoZSBlbmNvZGVkIHRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGVuY29kZShqc29uKSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiBqc29uID09PSAnb2JqZWN0Jyk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdChqc29uKVxuICAgICAgICAudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpO1xufVxuLyoqXG4gKiBFbmNvZGUgYSB0cmFuc2FjdGlvbiBhbmQgcHJlcGFyZSBmb3Igc2lnbmluZ1xuICpcbiAqIEBwYXJhbSBqc29uIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBzaWduZXIgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYWNjb3VudCB0byBzaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoXG4gKiBAcmV0dXJucyBhIGhleCBzdHJpbmcgb2YgdGhlIGVuY29kZWQgdHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gZW5jb2RlRm9yU2lnbmluZyhqc29uKSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiBqc29uID09PSAnb2JqZWN0Jyk7XG4gICAgcmV0dXJuIHNpZ25pbmdEYXRhKGpzb24pXG4gICAgICAgIC50b1N0cmluZygnaGV4JylcbiAgICAgICAgLnRvVXBwZXJDYXNlKCk7XG59XG4vKipcbiAqIEVuY29kZSBhIHRyYW5zYWN0aW9uIGFuZCBwcmVwYXJlIGZvciBzaWduaW5nIHdpdGggYSBjbGFpbVxuICpcbiAqIEBwYXJhbSBqc29uIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBzaWduZXIgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYWNjb3VudCB0byBzaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoXG4gKiBAcmV0dXJucyBhIGhleCBzdHJpbmcgb2YgdGhlIGVuY29kZWQgdHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gZW5jb2RlRm9yU2lnbmluZ0NsYWltKGpzb24pIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIGpzb24gPT09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gc2lnbmluZ0NsYWltRGF0YShqc29uKVxuICAgICAgICAudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgIC50b1VwcGVyQ2FzZSgpO1xufVxuLyoqXG4gKiBFbmNvZGUgYSB0cmFuc2FjdGlvbiBhbmQgcHJlcGFyZSBmb3IgbXVsdGktc2lnbmluZ1xuICpcbiAqIEBwYXJhbSBqc29uIEpTT04gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSBzaWduZXIgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYWNjb3VudCB0byBzaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoXG4gKiBAcmV0dXJucyBhIGhleCBzdHJpbmcgb2YgdGhlIGVuY29kZWQgdHJhbnNhY3Rpb25cbiAqL1xuZnVuY3Rpb24gZW5jb2RlRm9yTXVsdGlzaWduaW5nKGpzb24sIHNpZ25lcikge1xuICAgIGFzc2VydC5vayh0eXBlb2YganNvbiA9PT0gJ29iamVjdCcpO1xuICAgIGFzc2VydC5lcXVhbChqc29uWydTaWduaW5nUHViS2V5J10sICcnKTtcbiAgICByZXR1cm4gbXVsdGlTaWduaW5nRGF0YShqc29uLCBzaWduZXIpXG4gICAgICAgIC50b1N0cmluZygnaGV4JylcbiAgICAgICAgLnRvVXBwZXJDYXNlKCk7XG59XG4vKipcbiAqIEVuY29kZSBhIHF1YWxpdHkgdmFsdWVcbiAqXG4gKiBAcGFyYW0gdmFsdWUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbnVtYmVyXG4gKiBAcmV0dXJucyBhIGhleC1zdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBxdWFsaXR5XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVF1YWxpdHkodmFsdWUpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XG4gICAgcmV0dXJuIGNvcmV0eXBlc18xLnF1YWxpdHkuZW5jb2RlKHZhbHVlKS50b1N0cmluZygnaGV4JykudG9VcHBlckNhc2UoKTtcbn1cbi8qKlxuICogRGVjb2RlIGEgcXVhbGl0eSB2YWx1ZVxuICpcbiAqIEBwYXJhbSB2YWx1ZSBoZXgtc3RyaW5nIG9mIGEgcXVhbGl0eVxuICogQHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBxdWFsaXR5XG4gKi9cbmZ1bmN0aW9uIGRlY29kZVF1YWxpdHkodmFsdWUpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyk7XG4gICAgcmV0dXJuIGNvcmV0eXBlc18xLnF1YWxpdHkuZGVjb2RlKHZhbHVlKS50b1N0cmluZygpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZW5jb2RlRm9yU2lnbmluZzogZW5jb2RlRm9yU2lnbmluZyxcbiAgICBlbmNvZGVGb3JTaWduaW5nQ2xhaW06IGVuY29kZUZvclNpZ25pbmdDbGFpbSxcbiAgICBlbmNvZGVGb3JNdWx0aXNpZ25pbmc6IGVuY29kZUZvck11bHRpc2lnbmluZyxcbiAgICBlbmNvZGVRdWFsaXR5OiBlbmNvZGVRdWFsaXR5LFxuICAgIGRlY29kZVF1YWxpdHk6IGRlY29kZVF1YWxpdHksXG4gICAgZGVjb2RlTGVkZ2VyRGF0YTogbGVkZ2VyX2hhc2hlc18xLmRlY29kZUxlZGdlckRhdGEsXG4gICAgVFJBTlNBQ1RJT05fVFlQRVM6IGVudW1zXzEuVFJBTlNBQ1RJT05fVFlQRVMsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUxlZGdlckRhdGEgPSBleHBvcnRzLmxlZGdlckhhc2ggPSBleHBvcnRzLnRyYW5zYWN0aW9uVHJlZUhhc2ggPSBleHBvcnRzLmFjY291bnRTdGF0ZUhhc2ggPSB2b2lkIDA7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbnZhciBzaGFtYXBfMSA9IHJlcXVpcmUoXCIuL3NoYW1hcFwiKTtcbnZhciBoYXNoX3ByZWZpeGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoLXByZWZpeGVzXCIpO1xudmFyIGhhc2hlc18xID0gcmVxdWlyZShcIi4vaGFzaGVzXCIpO1xudmFyIGJpbmFyeV8xID0gcmVxdWlyZShcIi4vYmluYXJ5XCIpO1xudmFyIGhhc2hfMjU2XzEgPSByZXF1aXJlKFwiLi90eXBlcy9oYXNoLTI1NlwiKTtcbnZhciBzdF9vYmplY3RfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3N0LW9iamVjdFwiKTtcbnZhciB1aW50XzY0XzEgPSByZXF1aXJlKFwiLi90eXBlcy91aW50LTY0XCIpO1xudmFyIHVpbnRfMzJfMSA9IHJlcXVpcmUoXCIuL3R5cGVzL3VpbnQtMzJcIik7XG52YXIgdWludF84XzEgPSByZXF1aXJlKFwiLi90eXBlcy91aW50LThcIik7XG52YXIgYmluYXJ5X3BhcnNlcl8xID0gcmVxdWlyZShcIi4vc2VyZGVzL2JpbmFyeS1wYXJzZXJcIik7XG52YXIgYmlnSW50ID0gcmVxdWlyZShcImJpZy1pbnRlZ2VyXCIpO1xuLyoqXG4gKiBDb21wdXRlcyB0aGUgaGFzaCBvZiBhIGxpc3Qgb2Ygb2JqZWN0c1xuICpcbiAqIEBwYXJhbSBpdGVtaXplciBDb252ZXJ0cyBhbiBpdGVtIGludG8gYSBmb3JtYXQgdGhhdCBjYW4gYmUgYWRkZWQgdG8gU0hBTWFwXG4gKiBAcGFyYW0gaXRlbXNKc29uIEFycmF5IG9mIGl0ZW1zIHRvIGFkZCB0byBhIFNIQU1hcFxuICogQHJldHVybnMgdGhlIGhhc2ggb2YgdGhlIFNIQU1hcFxuICovXG5mdW5jdGlvbiBjb21wdXRlSGFzaChpdGVtaXplciwgaXRlbXNKc29uKSB7XG4gICAgdmFyIG1hcCA9IG5ldyBzaGFtYXBfMS5TaGFNYXAoKTtcbiAgICBpdGVtc0pzb24uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gbWFwLmFkZEl0ZW0uYXBwbHkobWFwLCBpdGVtaXplcihpdGVtKSk7IH0pO1xuICAgIHJldHVybiBtYXAuaGFzaCgpO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgdHJhbnNhY3Rpb24gaW50byBhbiBpbmRleCBhbmQgYW4gaXRlbVxuICpcbiAqIEBwYXJhbSBqc29uIHRyYW5zYWN0aW9uIHdpdGggbWV0YWRhdGFcbiAqIEByZXR1cm5zIGEgdHVwbGUgb2YgaW5kZXggYW5kIGl0ZW0gdG8gYmUgYWRkZWQgdG8gU0hBTWFwXG4gKi9cbmZ1bmN0aW9uIHRyYW5zYWN0aW9uSXRlbWl6ZXIoanNvbikge1xuICAgIGFzc2VydC5vayhqc29uLmhhc2gpO1xuICAgIHZhciBpbmRleCA9IGhhc2hfMjU2XzEuSGFzaDI1Ni5mcm9tKGpzb24uaGFzaCk7XG4gICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgIGhhc2hQcmVmaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNoX3ByZWZpeGVzXzEuSGFzaFByZWZpeC50cmFuc2FjdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgdG9CeXRlc1Npbms6IGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgICAgICB2YXIgc2VyaWFsaXplciA9IG5ldyBiaW5hcnlfMS5CaW5hcnlTZXJpYWxpemVyKHNpbmspO1xuICAgICAgICAgICAgc2VyaWFsaXplci53cml0ZUxlbmd0aEVuY29kZWQoc3Rfb2JqZWN0XzEuU1RPYmplY3QuZnJvbShqc29uKSk7XG4gICAgICAgICAgICBzZXJpYWxpemVyLndyaXRlTGVuZ3RoRW5jb2RlZChzdF9vYmplY3RfMS5TVE9iamVjdC5mcm9tKGpzb24ubWV0YURhdGEpKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBbaW5kZXgsIGl0ZW0sIHVuZGVmaW5lZF07XG59XG4vKipcbiAqIENvbnZlcnQgYW4gZW50cnkgdG8gYSBwYWlyIEhhc2gyNTYgYW5kIFNoYU1hcE5vZGVcbiAqXG4gKiBAcGFyYW0ganNvbiBKU09OIGRlc2NyaWJpbmcgYSBsZWRnZXIgZW50cnkgaXRlbVxuICogQHJldHVybnMgYSB0dXBsZSBvZiBpbmRleCBhbmQgaXRlbSB0byBiZSBhZGRlZCB0byBTSEFNYXBcbiAqL1xuZnVuY3Rpb24gZW50cnlJdGVtaXplcihqc29uKSB7XG4gICAgdmFyIGluZGV4ID0gaGFzaF8yNTZfMS5IYXNoMjU2LmZyb20oanNvbi5pbmRleCk7XG4gICAgdmFyIGJ5dGVzID0gKDAsIGJpbmFyeV8xLnNlcmlhbGl6ZU9iamVjdCkoanNvbik7XG4gICAgdmFyIGl0ZW0gPSB7XG4gICAgICAgIGhhc2hQcmVmaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNoX3ByZWZpeGVzXzEuSGFzaFByZWZpeC5hY2NvdW50U3RhdGVFbnRyeTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9CeXRlc1Npbms6IGZ1bmN0aW9uIChzaW5rKSB7XG4gICAgICAgICAgICBzaW5rLnB1dChieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gW2luZGV4LCBpdGVtLCB1bmRlZmluZWRdO1xufVxuLyoqXG4gKiBGdW5jdGlvbiBjb21wdXRpbmcgdGhlIGhhc2ggb2YgYSB0cmFuc2FjdGlvbiB0cmVlXG4gKlxuICogQHBhcmFtIHBhcmFtIEFuIGFycmF5IG9mIHRyYW5zYWN0aW9uIG9iamVjdHMgdG8gaGFzaFxuICogQHJldHVybnMgQSBIYXNoMjU2IG9iamVjdFxuICovXG5mdW5jdGlvbiB0cmFuc2FjdGlvblRyZWVIYXNoKHBhcmFtKSB7XG4gICAgdmFyIGl0ZW1pemVyID0gdHJhbnNhY3Rpb25JdGVtaXplcjtcbiAgICByZXR1cm4gY29tcHV0ZUhhc2goaXRlbWl6ZXIsIHBhcmFtKTtcbn1cbmV4cG9ydHMudHJhbnNhY3Rpb25UcmVlSGFzaCA9IHRyYW5zYWN0aW9uVHJlZUhhc2g7XG4vKipcbiAqIEZ1bmN0aW9uIGNvbXB1dGluZyB0aGUgaGFzaCBvZiBhY2NvdW50U3RhdGVcbiAqXG4gKiBAcGFyYW0gcGFyYW0gQSBsaXN0IG9mIGFjY291bnRTdGF0ZXMgaGFzaFxuICogQHJldHVybnMgQSBIYXNoMjU2IG9iamVjdFxuICovXG5mdW5jdGlvbiBhY2NvdW50U3RhdGVIYXNoKHBhcmFtKSB7XG4gICAgdmFyIGl0ZW1pemVyID0gZW50cnlJdGVtaXplcjtcbiAgICByZXR1cm4gY29tcHV0ZUhhc2goaXRlbWl6ZXIsIHBhcmFtKTtcbn1cbmV4cG9ydHMuYWNjb3VudFN0YXRlSGFzaCA9IGFjY291bnRTdGF0ZUhhc2g7XG4vKipcbiAqIFNlcmlhbGl6ZSBhbmQgaGFzaCBhIGxlZGdlciBoZWFkZXJcbiAqXG4gKiBAcGFyYW0gaGVhZGVyIGEgbGVkZ2VyIGhlYWRlclxuICogQHJldHVybnMgdGhlIGhhc2ggb2YgaGVhZGVyXG4gKi9cbmZ1bmN0aW9uIGxlZGdlckhhc2goaGVhZGVyKSB7XG4gICAgdmFyIGhhc2ggPSBuZXcgaGFzaGVzXzEuU2hhNTEySGFsZigpO1xuICAgIGhhc2gucHV0KGhhc2hfcHJlZml4ZXNfMS5IYXNoUHJlZml4LmxlZGdlckhlYWRlcik7XG4gICAgYXNzZXJ0Lm9rKGhlYWRlci5wYXJlbnRfY2xvc2VfdGltZSAhPT0gdW5kZWZpbmVkKTtcbiAgICBhc3NlcnQub2soaGVhZGVyLmNsb3NlX2ZsYWdzICE9PSB1bmRlZmluZWQpO1xuICAgIHVpbnRfMzJfMS5VSW50MzIuZnJvbShoZWFkZXIubGVkZ2VyX2luZGV4KS50b0J5dGVzU2luayhoYXNoKTtcbiAgICB1aW50XzY0XzEuVUludDY0LmZyb20oYmlnSW50KFN0cmluZyhoZWFkZXIudG90YWxfY29pbnMpKSkudG9CeXRlc1NpbmsoaGFzaCk7XG4gICAgaGFzaF8yNTZfMS5IYXNoMjU2LmZyb20oaGVhZGVyLnBhcmVudF9oYXNoKS50b0J5dGVzU2luayhoYXNoKTtcbiAgICBoYXNoXzI1Nl8xLkhhc2gyNTYuZnJvbShoZWFkZXIudHJhbnNhY3Rpb25faGFzaCkudG9CeXRlc1NpbmsoaGFzaCk7XG4gICAgaGFzaF8yNTZfMS5IYXNoMjU2LmZyb20oaGVhZGVyLmFjY291bnRfaGFzaCkudG9CeXRlc1NpbmsoaGFzaCk7XG4gICAgdWludF8zMl8xLlVJbnQzMi5mcm9tKGhlYWRlci5wYXJlbnRfY2xvc2VfdGltZSkudG9CeXRlc1NpbmsoaGFzaCk7XG4gICAgdWludF8zMl8xLlVJbnQzMi5mcm9tKGhlYWRlci5jbG9zZV90aW1lKS50b0J5dGVzU2luayhoYXNoKTtcbiAgICB1aW50XzhfMS5VSW50OC5mcm9tKGhlYWRlci5jbG9zZV90aW1lX3Jlc29sdXRpb24pLnRvQnl0ZXNTaW5rKGhhc2gpO1xuICAgIHVpbnRfOF8xLlVJbnQ4LmZyb20oaGVhZGVyLmNsb3NlX2ZsYWdzKS50b0J5dGVzU2luayhoYXNoKTtcbiAgICByZXR1cm4gaGFzaC5maW5pc2goKTtcbn1cbmV4cG9ydHMubGVkZ2VySGFzaCA9IGxlZGdlckhhc2g7XG4vKipcbiAqIERlY29kZXMgYSBzZXJpYWxpemVkIGxlZGdlciBoZWFkZXJcbiAqXG4gKiBAcGFyYW0gYmluYXJ5IEEgc2VyaWFsaXplZCBsZWRnZXIgaGVhZGVyXG4gKiBAcmV0dXJucyBBIEpTT04gb2JqZWN0IGRlc2NyaWJpbmcgYSBsZWRnZXIgaGVhZGVyXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUxlZGdlckRhdGEoYmluYXJ5KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiBiaW5hcnkgPT09ICdzdHJpbmcnLCAnYmluYXJ5IG11c3QgYmUgYSBoZXggc3RyaW5nJyk7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBiaW5hcnlfcGFyc2VyXzEuQmluYXJ5UGFyc2VyKGJpbmFyeSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVkZ2VyX2luZGV4OiBwYXJzZXIucmVhZFVJbnQzMigpLFxuICAgICAgICB0b3RhbF9jb2luczogcGFyc2VyLnJlYWRUeXBlKHVpbnRfNjRfMS5VSW50NjQpLnZhbHVlT2YoKS50b1N0cmluZygpLFxuICAgICAgICBwYXJlbnRfaGFzaDogcGFyc2VyLnJlYWRUeXBlKGhhc2hfMjU2XzEuSGFzaDI1NikudG9IZXgoKSxcbiAgICAgICAgdHJhbnNhY3Rpb25faGFzaDogcGFyc2VyLnJlYWRUeXBlKGhhc2hfMjU2XzEuSGFzaDI1NikudG9IZXgoKSxcbiAgICAgICAgYWNjb3VudF9oYXNoOiBwYXJzZXIucmVhZFR5cGUoaGFzaF8yNTZfMS5IYXNoMjU2KS50b0hleCgpLFxuICAgICAgICBwYXJlbnRfY2xvc2VfdGltZTogcGFyc2VyLnJlYWRVSW50MzIoKSxcbiAgICAgICAgY2xvc2VfdGltZTogcGFyc2VyLnJlYWRVSW50MzIoKSxcbiAgICAgICAgY2xvc2VfdGltZV9yZXNvbHV0aW9uOiBwYXJzZXIucmVhZFVJbnQ4KCksXG4gICAgICAgIGNsb3NlX2ZsYWdzOiBwYXJzZXIucmVhZFVJbnQ4KCksXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVjb2RlTGVkZ2VyRGF0YSA9IGRlY29kZUxlZGdlckRhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWRnZXItaGFzaGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5xdWFsaXR5ID0gdm9pZCAwO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBkZWNpbWFsX2pzXzEgPSByZXF1aXJlKFwiZGVjaW1hbC5qc1wiKTtcbnZhciBiaWdJbnQgPSByZXF1aXJlKFwiYmlnLWludGVnZXJcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogY2xhc3MgZm9yIGVuY29kaW5nIGFuZCBkZWNvZGluZyBxdWFsaXR5XG4gKi9cbnZhciBxdWFsaXR5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHF1YWxpdHkoKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBxdWFsaXR5IGFtb3VudFxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gYW1vdW50XG4gICAgICogQHJldHVybnMgU2VyaWFsaXplZCBxdWFsaXR5XG4gICAgICovXG4gICAgcXVhbGl0eS5lbmNvZGUgPSBmdW5jdGlvbiAocXVhbGl0eSkge1xuICAgICAgICB2YXIgZGVjaW1hbCA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChxdWFsaXR5KTtcbiAgICAgICAgdmFyIGV4cG9uZW50ID0gZGVjaW1hbC5lIC0gMTU7XG4gICAgICAgIHZhciBxdWFsaXR5U3RyaW5nID0gZGVjaW1hbC50aW1lcyhcIjFlXCIuY29uY2F0KC1leHBvbmVudCkpLmFicygpLnRvU3RyaW5nKCk7XG4gICAgICAgIHZhciBieXRlcyA9IHR5cGVzXzEuY29yZVR5cGVzLlVJbnQ2NC5mcm9tKGJpZ0ludChxdWFsaXR5U3RyaW5nKSkudG9CeXRlcygpO1xuICAgICAgICBieXRlc1swXSA9IGV4cG9uZW50ICsgMTAwO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZWNvZGUgcXVhbGl0eSBhbW91bnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmcgaGV4LXN0cmluZyBkZW5vdGluZyBzZXJpYWxpemVkIHF1YWxpdHlcbiAgICAgKiBAcmV0dXJucyBkZXNlcmlhbGl6ZWQgcXVhbGl0eVxuICAgICAqL1xuICAgIHF1YWxpdHkuZGVjb2RlID0gZnVuY3Rpb24gKHF1YWxpdHkpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gYnVmZmVyXzEuQnVmZmVyLmZyb20ocXVhbGl0eSwgJ2hleCcpLnNsaWNlKC04KTtcbiAgICAgICAgdmFyIGV4cG9uZW50ID0gYnl0ZXNbMF0gLSAxMDA7XG4gICAgICAgIHZhciBtYW50aXNzYSA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbChcIjB4XCIuY29uY2F0KGJ5dGVzLnNsaWNlKDEpLnRvU3RyaW5nKCdoZXgnKSkpO1xuICAgICAgICByZXR1cm4gbWFudGlzc2EudGltZXMoXCIxZVwiLmNvbmNhdChleHBvbmVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIHF1YWxpdHk7XG59KCkpO1xuZXhwb3J0cy5xdWFsaXR5ID0gcXVhbGl0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1YWxpdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJpbmFyeVBhcnNlciA9IHZvaWQgMDtcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIGVudW1zXzEgPSByZXF1aXJlKFwiLi4vZW51bXNcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogQmluYXJ5UGFyc2VyIGlzIHVzZWQgdG8gY29tcHV0ZSBmaWVsZHMgYW5kIHZhbHVlcyBmcm9tIGEgSGV4U3RyaW5nXG4gKi9cbnZhciBCaW5hcnlQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBieXRlcyB0byBhIGhleCBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSBoZXhCeXRlcyBhIGhleCBzdHJpbmdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBCaW5hcnlQYXJzZXIoaGV4Qnl0ZXMpIHtcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGhleEJ5dGVzLCAnaGV4Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlZWsgdGhlIGZpcnN0IGJ5dGUgb2YgdGhlIEJpbmFyeVBhcnNlclxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGZpcnN0IGJ5dGUgb2YgdGhlIEJpbmFyeVBhcnNlclxuICAgICAqL1xuICAgIEJpbmFyeVBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXNzZXJ0Lm9rKHRoaXMuYnl0ZXMuYnl0ZUxlbmd0aCAhPT0gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzWzBdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3VtZSB0aGUgZmlyc3QgbiBieXRlcyBvZiB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXBcbiAgICAgKi9cbiAgICBCaW5hcnlQYXJzZXIucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAobikge1xuICAgICAgICBhc3NlcnQub2sobiA8PSB0aGlzLmJ5dGVzLmJ5dGVMZW5ndGgpO1xuICAgICAgICB0aGlzLmJ5dGVzID0gdGhpcy5ieXRlcy5zbGljZShuKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIHJlYWQgdGhlIGZpcnN0IG4gYnl0ZXMgZnJvbSB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWRcbiAgICAgKiBAcmV0dXJuIFRoZSBieXRlc1xuICAgICAqL1xuICAgIEJpbmFyeVBhcnNlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGFzc2VydC5vayhuIDw9IHRoaXMuYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHZhciBzbGljZSA9IHRoaXMuYnl0ZXMuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuc2tpcChuKTtcbiAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZCBhbiBpbnRlZ2VyIG9mIGdpdmVuIHNpemVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZFxuICAgICAqIEByZXR1cm4gVGhlIG51bWJlciByZXByZXNlbnRlZCBieSB0aG9zZSBieXRlc1xuICAgICAqL1xuICAgIEJpbmFyeVBhcnNlci5wcm90b3R5cGUucmVhZFVJbnROID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgYXNzZXJ0Lm9rKDAgPCBuICYmIG4gPD0gNCwgJ2ludmFsaWQgbicpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkKG4pLnJlZHVjZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGEgPDwgOCkgfCBiOyB9KSA+Pj4gMDtcbiAgICB9O1xuICAgIEJpbmFyeVBhcnNlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkVUludE4oMSk7XG4gICAgfTtcbiAgICBCaW5hcnlQYXJzZXIucHJvdG90eXBlLnJlYWRVSW50MTYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWRVSW50TigyKTtcbiAgICB9O1xuICAgIEJpbmFyeVBhcnNlci5wcm90b3R5cGUucmVhZFVJbnQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZFVJbnROKDQpO1xuICAgIH07XG4gICAgQmluYXJ5UGFyc2VyLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5ieXRlTGVuZ3RoO1xuICAgIH07XG4gICAgQmluYXJ5UGFyc2VyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY3VzdG9tRW5kKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGggPT09IDAgfHwgKGN1c3RvbUVuZCAhPT0gdW5kZWZpbmVkICYmIGxlbmd0aCA8PSBjdXN0b21FbmQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZHMgdmFyaWFibGUgbGVuZ3RoIGVuY29kZWQgYnl0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIHZhcmlhYmxlIGxlbmd0aCBieXRlc1xuICAgICAqL1xuICAgIEJpbmFyeVBhcnNlci5wcm90b3R5cGUucmVhZFZhcmlhYmxlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkKHRoaXMucmVhZFZhcmlhYmxlTGVuZ3RoTGVuZ3RoKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGxlbmd0aCBvZiB0aGUgdmFyaWFibGUgbGVuZ3RoIGVuY29kZWQgYnl0ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm4gVGhlIGxlbmd0aCBvZiB0aGUgdmFyaWFibGUgbGVuZ3RoIGVuY29kZWQgYnl0ZXNcbiAgICAgKi9cbiAgICBCaW5hcnlQYXJzZXIucHJvdG90eXBlLnJlYWRWYXJpYWJsZUxlbmd0aExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGIxID0gdGhpcy5yZWFkVUludDgoKTtcbiAgICAgICAgaWYgKGIxIDw9IDE5Mikge1xuICAgICAgICAgICAgcmV0dXJuIGIxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIxIDw9IDI0MCkge1xuICAgICAgICAgICAgdmFyIGIyID0gdGhpcy5yZWFkVUludDgoKTtcbiAgICAgICAgICAgIHJldHVybiAxOTMgKyAoYjEgLSAxOTMpICogMjU2ICsgYjI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYjEgPD0gMjU0KSB7XG4gICAgICAgICAgICB2YXIgYjIgPSB0aGlzLnJlYWRVSW50OCgpO1xuICAgICAgICAgICAgdmFyIGIzID0gdGhpcy5yZWFkVUludDgoKTtcbiAgICAgICAgICAgIHJldHVybiAxMjQ4MSArIChiMSAtIDI0MSkgKiA2NTUzNiArIGIyICogMjU2ICsgYjM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhcmlhYmxlIGxlbmd0aCBpbmRpY2F0b3InKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlYWRzIHRoZSBmaWVsZCBvcmRpbmFsIGZyb20gdGhlIEJpbmFyeVBhcnNlclxuICAgICAqXG4gICAgICogQHJldHVybiBGaWVsZCBvcmRpbmFsXG4gICAgICovXG4gICAgQmluYXJ5UGFyc2VyLnByb3RvdHlwZS5yZWFkRmllbGRPcmRpbmFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMucmVhZFVJbnQ4KCk7XG4gICAgICAgIHZhciBudGggPSB0eXBlICYgMTU7XG4gICAgICAgIHR5cGUgPj49IDQ7XG4gICAgICAgIGlmICh0eXBlID09PSAwKSB7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5yZWFkVUludDgoKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAwIHx8IHR5cGUgPCAxNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlYWQgRmllbGRPcmRpbmFsLCB0eXBlX2NvZGUgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG50aCA9PT0gMCkge1xuICAgICAgICAgICAgbnRoID0gdGhpcy5yZWFkVUludDgoKTtcbiAgICAgICAgICAgIGlmIChudGggPT09IDAgfHwgbnRoIDwgMTYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWFkIEZpZWxkT3JkaW5hbCwgZmllbGRfY29kZSBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHR5cGUgPDwgMTYpIHwgbnRoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZmllbGQgZnJvbSB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBmaWVsZCByZXByZXNlbnRlZCBieSB0aGUgYnl0ZXMgYXQgdGhlIGhlYWQgb2YgdGhlIEJpbmFyeVBhcnNlclxuICAgICAqL1xuICAgIEJpbmFyeVBhcnNlci5wcm90b3R5cGUucmVhZEZpZWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZW51bXNfMS5GaWVsZC5mcm9tU3RyaW5nKHRoaXMucmVhZEZpZWxkT3JkaW5hbCgpLnRvU3RyaW5nKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGdpdmVuIHR5cGUgZnJvbSB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgdHlwZSB0aGF0IHlvdSB3YW50IHRvIHJlYWQgZnJvbSB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICogQHJldHVybiBUaGUgaW5zdGFuY2Ugb2YgdGhhdCB0eXBlIHJlYWQgZnJvbSB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICovXG4gICAgQmluYXJ5UGFyc2VyLnByb3RvdHlwZS5yZWFkVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlLmZyb21QYXJzZXIodGhpcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZmllbGRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZCBUaGUgZmllbGQgdGhhdCB5b3Ugd2FuIHRvIGdldCB0aGUgdHlwZSBvZlxuICAgICAqIEByZXR1cm4gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBmaWVsZFxuICAgICAqL1xuICAgIEJpbmFyeVBhcnNlci5wcm90b3R5cGUudHlwZUZvckZpZWxkID0gZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIHJldHVybiBmaWVsZC5hc3NvY2lhdGVkVHlwZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlYWQgdmFsdWUgb2YgdGhlIHR5cGUgc3BlY2lmaWVkIGJ5IGZpZWxkIGZyb20gdGhlIEJpbmFyeVBhcnNlclxuICAgICAqXG4gICAgICogQHBhcmFtIGZpZWxkIFRoZSBmaWVsZCB0aGF0IHlvdSB3YW50IHRvIGdldCB0aGUgYXNzb2NpYXRlZCB2YWx1ZSBmb3JcbiAgICAgKiBAcmV0dXJuIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGZpZWxkXG4gICAgICovXG4gICAgQmluYXJ5UGFyc2VyLnByb3RvdHlwZS5yZWFkRmllbGRWYWx1ZSA9IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZUZvckZpZWxkKGZpZWxkKTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZDogKFwiLmNvbmNhdChmaWVsZC5uYW1lLCBcIiwgXCIpLmNvbmNhdChmaWVsZC50eXBlLm5hbWUsIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemVIaW50ID0gZmllbGQuaXNWYXJpYWJsZUxlbmd0aEVuY29kZWRcbiAgICAgICAgICAgID8gdGhpcy5yZWFkVmFyaWFibGVMZW5ndGhMZW5ndGgoKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGUuZnJvbVBhcnNlcih0aGlzLCBzaXplSGludCk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmcm9tUGFyc2VyIGZvciAoXCIuY29uY2F0KGZpZWxkLm5hbWUsIFwiLCBcIikuY29uY2F0KGZpZWxkLnR5cGUubmFtZSwgXCIpIC0+IHVuZGVmaW5lZCBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbmV4dCBmaWVsZCBhbmQgdmFsdWUgZnJvbSB0aGUgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIFRoZSBmaWVsZCBhbmQgdmFsdWVcbiAgICAgKi9cbiAgICBCaW5hcnlQYXJzZXIucHJvdG90eXBlLnJlYWRGaWVsZEFuZFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZmllbGQgPSB0aGlzLnJlYWRGaWVsZCgpO1xuICAgICAgICByZXR1cm4gW2ZpZWxkLCB0aGlzLnJlYWRGaWVsZFZhbHVlKGZpZWxkKV07XG4gICAgfTtcbiAgICByZXR1cm4gQmluYXJ5UGFyc2VyO1xufSgpKTtcbmV4cG9ydHMuQmluYXJ5UGFyc2VyID0gQmluYXJ5UGFyc2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmluYXJ5LXBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmluYXJ5U2VyaWFsaXplciA9IGV4cG9ydHMuQnl0ZXNMaXN0ID0gdm9pZCAwO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogQnl0ZXMgbGlzdCBpcyBhIGNvbGxlY3Rpb24gb2YgYnVmZmVyIG9iamVjdHNcbiAqL1xudmFyIEJ5dGVzTGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCeXRlc0xpc3QoKSB7XG4gICAgICAgIHRoaXMuYnl0ZXNBcnJheSA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBpbiB0aGUgQnl0ZXNMaXN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXNcbiAgICAgKi9cbiAgICBCeXRlc0xpc3QucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQodGhpcy5ieXRlc0FycmF5KS5ieXRlTGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUHV0IGJ5dGVzIGluIHRoZSBCeXRlc0xpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlc0FyZyBBIEJ1ZmZlclxuICAgICAqIEByZXR1cm4gdGhpcyBCeXRlc0xpc3RcbiAgICAgKi9cbiAgICBCeXRlc0xpc3QucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChieXRlc0FyZykge1xuICAgICAgICB2YXIgYnl0ZXMgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShieXRlc0FyZyk7IC8vIFRlbXBvcmFyeSwgdG8gY2F0Y2ggaW5zdGFuY2VzIG9mIFVpbnQ4QXJyYXkgYmVpbmcgcGFzc2VkIGluXG4gICAgICAgIHRoaXMuYnl0ZXNBcnJheS5wdXNoKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGlzIEJ5dGVzTGlzdCB0byB0aGUgYmFjayBvZiBhbm90aGVyIGJ5dGVzIGxpc3RcbiAgICAgKlxuICAgICAqICBAcGFyYW0gbGlzdCBUaGUgQnl0ZXNMaXN0IHRvIHdyaXRlIHRvXG4gICAgICovXG4gICAgQnl0ZXNMaXN0LnByb3RvdHlwZS50b0J5dGVzU2luayA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIGxpc3QucHV0KHRoaXMudG9CeXRlcygpKTtcbiAgICB9O1xuICAgIEJ5dGVzTGlzdC5wcm90b3R5cGUudG9CeXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQodGhpcy5ieXRlc0FycmF5KTtcbiAgICB9O1xuICAgIEJ5dGVzTGlzdC5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoKS50b1N0cmluZygnaGV4JykudG9VcHBlckNhc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBCeXRlc0xpc3Q7XG59KCkpO1xuZXhwb3J0cy5CeXRlc0xpc3QgPSBCeXRlc0xpc3Q7XG4vKipcbiAqIEJpbmFyeVNlcmlhbGl6ZXIgaXMgdXNlZCB0byB3cml0ZSBmaWVsZHMgYW5kIHZhbHVlcyB0byBidWZmZXJzXG4gKi9cbnZhciBCaW5hcnlTZXJpYWxpemVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJpbmFyeVNlcmlhbGl6ZXIoc2luaykge1xuICAgICAgICB0aGlzLnNpbmsgPSBuZXcgQnl0ZXNMaXN0KCk7XG4gICAgICAgIHRoaXMuc2luayA9IHNpbms7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgdmFsdWUgdG8gdGhpcyBCaW5hcnlTZXJpYWxpemVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgYSBTZXJpYWxpemVkVHlwZSB2YWx1ZVxuICAgICAqL1xuICAgIEJpbmFyeVNlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlLnRvQnl0ZXNTaW5rKHRoaXMuc2luayk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSBieXRlcyB0byB0aGlzIEJpbmFyeVNlcmlhbGl6ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyB0aGUgYnl0ZXMgdG8gd3JpdGVcbiAgICAgKi9cbiAgICBCaW5hcnlTZXJpYWxpemVyLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5zaW5rLnB1dChieXRlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIHZhbHVlIG9mIGEgZ2l2ZW4gdHlwZSB0byB0aGlzIEJpbmFyeVNlcmlhbGl6ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlIHRoZSB0eXBlIHRvIHdyaXRlXG4gICAgICogQHBhcmFtIHZhbHVlIGEgdmFsdWUgb2YgdGhhdCB0eXBlXG4gICAgICovXG4gICAgQmluYXJ5U2VyaWFsaXplci5wcm90b3R5cGUud3JpdGVUeXBlID0gZnVuY3Rpb24gKHR5cGUsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMud3JpdGUodHlwZS5mcm9tKHZhbHVlKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSBCeXRlc0xpc3QgdG8gdGhpcyBCaW5hcnlTZXJpYWxpemVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmwgQnl0ZXNMaXN0IHRvIHdyaXRlIHRvIEJpbmFyeVNlcmlhbGl6ZXJcbiAgICAgKi9cbiAgICBCaW5hcnlTZXJpYWxpemVyLnByb3RvdHlwZS53cml0ZUJ5dGVzTGlzdCA9IGZ1bmN0aW9uIChibCkge1xuICAgICAgICBibC50b0J5dGVzU2luayh0aGlzLnNpbmspO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBoZWFkZXIgb2YgVmFyaWFibGUgTGVuZ3RoIGVuY29kZWQgYnl0ZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsZW5ndGggdGhlIGxlbmd0aCBvZiB0aGUgYnl0ZXNcbiAgICAgKi9cbiAgICBCaW5hcnlTZXJpYWxpemVyLnByb3RvdHlwZS5lbmNvZGVWYXJpYWJsZUxlbmd0aCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgdmFyIGxlbkJ5dGVzID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDMpO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDE5Mikge1xuICAgICAgICAgICAgbGVuQnl0ZXNbMF0gPSBsZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbGVuQnl0ZXMuc2xpY2UoMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDEyNDgwKSB7XG4gICAgICAgICAgICBsZW5ndGggLT0gMTkzO1xuICAgICAgICAgICAgbGVuQnl0ZXNbMF0gPSAxOTMgKyAobGVuZ3RoID4+PiA4KTtcbiAgICAgICAgICAgIGxlbkJ5dGVzWzFdID0gbGVuZ3RoICYgMHhmZjtcbiAgICAgICAgICAgIHJldHVybiBsZW5CeXRlcy5zbGljZSgwLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGggPD0gOTE4NzQ0KSB7XG4gICAgICAgICAgICBsZW5ndGggLT0gMTI0ODE7XG4gICAgICAgICAgICBsZW5CeXRlc1swXSA9IDI0MSArIChsZW5ndGggPj4+IDE2KTtcbiAgICAgICAgICAgIGxlbkJ5dGVzWzFdID0gKGxlbmd0aCA+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBsZW5CeXRlc1syXSA9IGxlbmd0aCAmIDB4ZmY7XG4gICAgICAgICAgICByZXR1cm4gbGVuQnl0ZXMuc2xpY2UoMCwgMyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVyZmxvdyBlcnJvcicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGUgZmllbGQgYW5kIHZhbHVlIHRvIEJpbmFyeVNlcmlhbGl6ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZCBmaWVsZCB0byB3cml0ZSB0byBCaW5hcnlTZXJpYWxpemVyXG4gICAgICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIHdyaXRlIHRvIEJpbmFyeVNlcmlhbGl6ZXJcbiAgICAgKi9cbiAgICBCaW5hcnlTZXJpYWxpemVyLnByb3RvdHlwZS53cml0ZUZpZWxkQW5kVmFsdWUgPSBmdW5jdGlvbiAoZmllbGQsIHZhbHVlLCBpc1VubE1vZGlmeVdvcmthcm91bmQpIHtcbiAgICAgICAgaWYgKGlzVW5sTW9kaWZ5V29ya2Fyb3VuZCA9PT0gdm9pZCAwKSB7IGlzVW5sTW9kaWZ5V29ya2Fyb3VuZCA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBhc3NvY2lhdGVkVmFsdWUgPSBmaWVsZC5hc3NvY2lhdGVkVHlwZS5mcm9tKHZhbHVlKTtcbiAgICAgICAgYXNzZXJ0Lm9rKGFzc29jaWF0ZWRWYWx1ZS50b0J5dGVzU2luayAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgYXNzZXJ0Lm9rKGZpZWxkLm5hbWUgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuc2luay5wdXQoZmllbGQuaGVhZGVyKTtcbiAgICAgICAgaWYgKGZpZWxkLmlzVmFyaWFibGVMZW5ndGhFbmNvZGVkKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlTGVuZ3RoRW5jb2RlZChhc3NvY2lhdGVkVmFsdWUsIGlzVW5sTW9kaWZ5V29ya2Fyb3VuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NvY2lhdGVkVmFsdWUudG9CeXRlc1NpbmsodGhpcy5zaW5rKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggZW5jb2RlZCB2YWx1ZSB0byB0aGUgQmluYXJ5U2VyaWFsaXplclxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIGxlbmd0aCBlbmNvZGVkIHZhbHVlIHRvIHdyaXRlIHRvIEJ5dGVzTGlzdFxuICAgICAqL1xuICAgIEJpbmFyeVNlcmlhbGl6ZXIucHJvdG90eXBlLndyaXRlTGVuZ3RoRW5jb2RlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNVbmxNb2RpZnlXb3JrYXJvdW5kKSB7XG4gICAgICAgIGlmIChpc1VubE1vZGlmeVdvcmthcm91bmQgPT09IHZvaWQgMCkgeyBpc1VubE1vZGlmeVdvcmthcm91bmQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgQnl0ZXNMaXN0KCk7XG4gICAgICAgIGlmICghaXNVbmxNb2RpZnlXb3JrYXJvdW5kKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHBhcnQgZG9lc24ndCBoYXBwZW4gZm9yIHRoZSBBY2NvdW50IGZpZWxkIGluIGEgVU5MTW9kaWZ5IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICB2YWx1ZS50b0J5dGVzU2luayhieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXQodGhpcy5lbmNvZGVWYXJpYWJsZUxlbmd0aChieXRlcy5nZXRMZW5ndGgoKSkpO1xuICAgICAgICB0aGlzLndyaXRlQnl0ZXNMaXN0KGJ5dGVzKTtcbiAgICB9O1xuICAgIHJldHVybiBCaW5hcnlTZXJpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuQmluYXJ5U2VyaWFsaXplciA9IEJpbmFyeVNlcmlhbGl6ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaW5hcnktc2VyaWFsaXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNoYU1hcExlYWYgPSBleHBvcnRzLlNoYU1hcE5vZGUgPSBleHBvcnRzLlNoYU1hcCA9IHZvaWQgMDtcbnZhciBhc3NlcnRfMSA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xudmFyIGhhc2hfcHJlZml4ZXNfMSA9IHJlcXVpcmUoXCIuL2hhc2gtcHJlZml4ZXNcIik7XG52YXIgaGFzaGVzXzEgPSByZXF1aXJlKFwiLi9oYXNoZXNcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZGVzY3JpYmluZyBhIFNIQU1hcE5vZGVcbiAqL1xudmFyIFNoYU1hcE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2hhTWFwTm9kZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIFNoYU1hcE5vZGU7XG59KCkpO1xuZXhwb3J0cy5TaGFNYXBOb2RlID0gU2hhTWFwTm9kZTtcbi8qKlxuICogQ2xhc3MgZGVzY3JpYmluZyBhIExlYWYgb2YgU0hBTWFwXG4gKi9cbnZhciBTaGFNYXBMZWFmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaGFNYXBMZWFmLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNoYU1hcExlYWYoaW5kZXgsIGl0ZW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgX3RoaXMuaXRlbSA9IGl0ZW07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdHJ1ZSBhcyBTaGFNYXBMZWFmIGlzIGEgbGVhZiBub2RlXG4gICAgICovXG4gICAgU2hhTWFwTGVhZi5wcm90b3R5cGUuaXNMZWFmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGZhbHNlIGFzIFNoYU1hcExlYWYgaXMgbm90IGFuIGlubmVyIG5vZGVcbiAgICAgKi9cbiAgICBTaGFNYXBMZWFmLnByb3RvdHlwZS5pc0lubmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHByZWZpeCBvZiB0aGUgdGhpcy5pdGVtXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaGFzaCBwcmVmaXgsIHVubGVzcyB0aGlzLml0ZW0gaXMgdW5kZWZpbmVkLCB0aGVuIGl0IHJldHVybnMgYW4gZW1wdHkgQnVmZmVyXG4gICAgICovXG4gICAgU2hhTWFwTGVhZi5wcm90b3R5cGUuaGFzaFByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbSA9PT0gdW5kZWZpbmVkID8gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDApIDogdGhpcy5pdGVtLmhhc2hQcmVmaXgoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEhhc2ggdGhlIGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIHRoaXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGhhc2ggb2YgdGhpcy5pdGVtIGNvbmNhdGVuYXRlZCB3aXRoIHRoaXMuaW5kZXhcbiAgICAgKi9cbiAgICBTaGFNYXBMZWFmLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFzaCA9IGhhc2hlc18xLlNoYTUxMkhhbGYucHV0KHRoaXMuaGFzaFByZWZpeCgpKTtcbiAgICAgICAgdGhpcy50b0J5dGVzU2luayhoYXNoKTtcbiAgICAgICAgcmV0dXJuIGhhc2guZmluaXNoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZSB0aGUgYnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0byBhIEJ5dGVzTGlzdFxuICAgICAqIEBwYXJhbSBsaXN0IEJ5dGVzTGlzdCB0byB3cml0ZSBieXRlcyB0b1xuICAgICAqL1xuICAgIFNoYU1hcExlYWYucHJvdG90eXBlLnRvQnl0ZXNTaW5rID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW0udG9CeXRlc1NpbmsobGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleC50b0J5dGVzU2luayhsaXN0KTtcbiAgICB9O1xuICAgIHJldHVybiBTaGFNYXBMZWFmO1xufShTaGFNYXBOb2RlKSk7XG5leHBvcnRzLlNoYU1hcExlYWYgPSBTaGFNYXBMZWFmO1xuLyoqXG4gKiBDbGFzcyBkZWZpbmluZyBhbiBJbm5lciBOb2RlIG9mIGEgU0hBTWFwXG4gKi9cbnZhciBTaGFNYXBJbm5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2hhTWFwSW5uZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2hhTWFwSW5uZXIoZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSB2b2lkIDApIHsgZGVwdGggPSAwOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIF90aGlzLnNsb3RCaXRzID0gMDtcbiAgICAgICAgX3RoaXMuYnJhbmNoZXMgPSBBcnJheSgxNik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdHJ1ZSBhcyBTaGFNYXBJbm5lciBpcyBhbiBpbm5lciBub2RlXG4gICAgICovXG4gICAgU2hhTWFwSW5uZXIucHJvdG90eXBlLmlzSW5uZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgZmFsc2UgYXMgU2hhTWFwSW5uZXIgaXMgbm90IGEgbGVhZiBub2RlXG4gICAgICovXG4gICAgU2hhTWFwSW5uZXIucHJvdG90eXBlLmlzTGVhZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBoYXNoIHByZWZpeCBmb3IgdGhpcyBub2RlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBoYXNoIHByZWZpeCBkZXNjcmliaW5nIGFuIGlubmVyIG5vZGVcbiAgICAgKi9cbiAgICBTaGFNYXBJbm5lci5wcm90b3R5cGUuaGFzaFByZWZpeCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGhhc2hfcHJlZml4ZXNfMS5IYXNoUHJlZml4LmlubmVyTm9kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCBhIGJyYW5jaCBvZiB0aGlzIG5vZGUgdG8gYmUgYW5vdGhlciBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2xvdCBTbG90IHRvIGFkZCBicmFuY2ggdG8gdGhpcy5icmFuY2hlc1xuICAgICAqIEBwYXJhbSBicmFuY2ggQnJhbmNoIHRvIGFkZFxuICAgICAqL1xuICAgIFNoYU1hcElubmVyLnByb3RvdHlwZS5zZXRCcmFuY2ggPSBmdW5jdGlvbiAoc2xvdCwgYnJhbmNoKSB7XG4gICAgICAgIHRoaXMuc2xvdEJpdHMgPSB0aGlzLnNsb3RCaXRzIHwgKDEgPDwgc2xvdCk7XG4gICAgICAgIHRoaXMuYnJhbmNoZXNbc2xvdF0gPSBicmFuY2g7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgZW1wdHlcbiAgICAgKi9cbiAgICBTaGFNYXBJbm5lci5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNsb3RCaXRzID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZSB0aGUgaGFzaCBvZiB0aGlzIG5vZGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoaXMgbm9kZVxuICAgICAqL1xuICAgIFNoYU1hcElubmVyLnByb3RvdHlwZS5oYXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5jb3JlVHlwZXMuSGFzaDI1Ni5aRVJPXzI1NjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzaCA9IGhhc2hlc18xLlNoYTUxMkhhbGYucHV0KHRoaXMuaGFzaFByZWZpeCgpKTtcbiAgICAgICAgdGhpcy50b0J5dGVzU2luayhoYXNoKTtcbiAgICAgICAgcmV0dXJuIGhhc2guZmluaXNoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdGhlIGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgbm9kZSB0byBhIEJ5dGVzTGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3QgQnl0ZXNMaXN0IHRvIHdyaXRlIGJ5dGVzIHRvXG4gICAgICovXG4gICAgU2hhTWFwSW5uZXIucHJvdG90eXBlLnRvQnl0ZXNTaW5rID0gZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJyYW5jaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYnJhbmNoID0gdGhpcy5icmFuY2hlc1tpXTtcbiAgICAgICAgICAgIHZhciBoYXNoID0gYnJhbmNoID8gYnJhbmNoLmhhc2goKSA6IHR5cGVzXzEuY29yZVR5cGVzLkhhc2gyNTYuWkVST18yNTY7XG4gICAgICAgICAgICBoYXNoLnRvQnl0ZXNTaW5rKGxpc3QpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGQgaXRlbSB0byB0aGUgU0hBTWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXggSGFzaCBvZiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gYmVpbmcgaW5zZXJ0ZWRcbiAgICAgKiBAcGFyYW0gaXRlbSBJdGVtIHRvIGluc2VydCBpbiB0aGUgbWFwXG4gICAgICogQHBhcmFtIGxlYWYgTGVhZiBub2RlIHRvIGluc2VydCB3aGVuIGJyYW5jaCBkb2Vzbid0IGV4aXN0XG4gICAgICovXG4gICAgU2hhTWFwSW5uZXIucHJvdG90eXBlLmFkZEl0ZW0gPSBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0sIGxlYWYpIHtcbiAgICAgICAgYXNzZXJ0XzEuc3RyaWN0Lm9rKGluZGV4ICE9PSB1bmRlZmluZWQpO1xuICAgICAgICB2YXIgbmliYmxlID0gaW5kZXgubmliYmxldCh0aGlzLmRlcHRoKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdGhpcy5icmFuY2hlc1tuaWJibGVdO1xuICAgICAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zZXRCcmFuY2gobmliYmxlLCBsZWFmIHx8IG5ldyBTaGFNYXBMZWFmKGluZGV4LCBpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhpc3RpbmcgaW5zdGFuY2VvZiBTaGFNYXBMZWFmKSB7XG4gICAgICAgICAgICB2YXIgbmV3SW5uZXIgPSBuZXcgU2hhTWFwSW5uZXIodGhpcy5kZXB0aCArIDEpO1xuICAgICAgICAgICAgbmV3SW5uZXIuYWRkSXRlbShleGlzdGluZy5pbmRleCwgdW5kZWZpbmVkLCBleGlzdGluZyk7XG4gICAgICAgICAgICBuZXdJbm5lci5hZGRJdGVtKGluZGV4LCBpdGVtLCBsZWFmKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QnJhbmNoKG5pYmJsZSwgbmV3SW5uZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4aXN0aW5nIGluc3RhbmNlb2YgU2hhTWFwSW5uZXIpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLmFkZEl0ZW0oaW5kZXgsIGl0ZW0sIGxlYWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNoYU1hcC5hZGRJdGVtIGNhbGwnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNoYU1hcElubmVyO1xufShTaGFNYXBOb2RlKSk7XG52YXIgU2hhTWFwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTaGFNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2hhTWFwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaGFNYXA7XG59KFNoYU1hcElubmVyKSk7XG5leHBvcnRzLlNoYU1hcCA9IFNoYU1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYW1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFjY291bnRJRCA9IHZvaWQgMDtcbnZhciByaXBwbGVfYWRkcmVzc19jb2RlY18xID0gcmVxdWlyZShcInJpcHBsZS1hZGRyZXNzLWNvZGVjXCIpO1xudmFyIGhhc2hfMTYwXzEgPSByZXF1aXJlKFwiLi9oYXNoLTE2MFwiKTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xudmFyIEhFWF9SRUdFWCA9IC9eW0EtRjAtOV17NDB9JC87XG4vKipcbiAqIENsYXNzIGRlZmluaW5nIGhvdyB0byBlbmNvZGUgYW5kIGRlY29kZSBhbiBBY2NvdW50SURcbiAqL1xudmFyIEFjY291bnRJRCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWNjb3VudElELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjY291bnRJRChieXRlcykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgYnl0ZXMgIT09IG51bGwgJiYgYnl0ZXMgIT09IHZvaWQgMCA/IGJ5dGVzIDogQWNjb3VudElELmRlZmF1bHRBY2NvdW50SUQuYnl0ZXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaG93IHRvIGNvbnN0cnVjdCBhbiBBY2NvdW50SURcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBlaXRoZXIgYW4gZXhpc3RpbmcgQWNjb3VudElELCBhIGhleC1zdHJpbmcsIG9yIGEgYmFzZTU4IHItQWRkcmVzc1xuICAgICAqIEByZXR1cm5zIGFuIEFjY291bnRJRCBvYmplY3RcbiAgICAgKi9cbiAgICBBY2NvdW50SUQuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBY2NvdW50SUQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWNjb3VudElEKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSEVYX1JFR0VYLnRlc3QodmFsdWUpXG4gICAgICAgICAgICAgICAgPyBuZXcgQWNjb3VudElEKGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHZhbHVlLCAnaGV4JykpXG4gICAgICAgICAgICAgICAgOiB0aGlzLmZyb21CYXNlNTgodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBBY2NvdW50SUQgZnJvbSB2YWx1ZSBnaXZlbicpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBob3cgdG8gYnVpbGQgYW4gQWNjb3VudElEIGZyb20gYSBiYXNlNTggci1BZGRyZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgYSBiYXNlNTggci1BZGRyZXNzXG4gICAgICogQHJldHVybnMgYW4gQWNjb3VudElEIG9iamVjdFxuICAgICAqL1xuICAgIEFjY291bnRJRC5mcm9tQmFzZTU4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICgoMCwgcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5pc1ZhbGlkWEFkZHJlc3MpKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIGNsYXNzaWMgPSAoMCwgcmlwcGxlX2FkZHJlc3NfY29kZWNfMS54QWRkcmVzc1RvQ2xhc3NpY0FkZHJlc3MpKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc2ljLnRhZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGFsbG93ZWQgdG8gaGF2ZSB0YWcgb24gQWNjb3VudCBvciBEZXN0aW5hdGlvbicpO1xuICAgICAgICAgICAgdmFsdWUgPSBjbGFzc2ljLmNsYXNzaWNBZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWNjb3VudElEKGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKCgwLCByaXBwbGVfYWRkcmVzc19jb2RlY18xLmRlY29kZUFjY291bnRJRCkodmFsdWUpKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPdmVybG9hZCBvZiB0b0pTT05cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBiYXNlNTggc3RyaW5nIGZvciB0aGlzIEFjY291bnRJRFxuICAgICAqL1xuICAgIEFjY291bnRJRC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0Jhc2U1OCgpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBob3cgdG8gZW5jb2RlIEFjY291bnRJRCBpbnRvIGEgYmFzZTU4IGFkZHJlc3NcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBiYXNlNTggc3RyaW5nIGRlZmluZWQgYnkgdGhpcy5ieXRlc1xuICAgICAqL1xuICAgIEFjY291bnRJRC5wcm90b3R5cGUudG9CYXNlNTggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbiAgICAgICAgcmV0dXJuICgwLCByaXBwbGVfYWRkcmVzc19jb2RlY18xLmVuY29kZUFjY291bnRJRCkodGhpcy5ieXRlcyk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuICAgIH07XG4gICAgQWNjb3VudElELmRlZmF1bHRBY2NvdW50SUQgPSBuZXcgQWNjb3VudElEKGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygyMCkpO1xuICAgIHJldHVybiBBY2NvdW50SUQ7XG59KGhhc2hfMTYwXzEuSGFzaDE2MCkpO1xuZXhwb3J0cy5BY2NvdW50SUQgPSBBY2NvdW50SUQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvdW50LWlkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQW1vdW50ID0gdm9pZCAwO1xudmFyIGRlY2ltYWxfanNfMSA9IHJlcXVpcmUoXCJkZWNpbWFsLmpzXCIpO1xudmFyIGJpbmFyeV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuLi9zZXJkZXMvYmluYXJ5LXBhcnNlclwiKTtcbnZhciBhY2NvdW50X2lkXzEgPSByZXF1aXJlKFwiLi9hY2NvdW50LWlkXCIpO1xudmFyIGN1cnJlbmN5XzEgPSByZXF1aXJlKFwiLi9jdXJyZW5jeVwiKTtcbnZhciBzZXJpYWxpemVkX3R5cGVfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZWQtdHlwZVwiKTtcbnZhciBiaWdJbnQgPSByZXF1aXJlKFwiYmlnLWludGVnZXJcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogQ29uc3RhbnRzIGZvciB2YWxpZGF0aW5nIGFtb3VudHNcbiAqL1xudmFyIE1JTl9JT1VfRVhQT05FTlQgPSAtOTY7XG52YXIgTUFYX0lPVV9FWFBPTkVOVCA9IDgwO1xudmFyIE1BWF9JT1VfUFJFQ0lTSU9OID0gMTY7XG52YXIgTUFYX0RST1BTID0gbmV3IGRlY2ltYWxfanNfMS5EZWNpbWFsKCcxZTE3Jyk7XG52YXIgTUlOX1hSUCA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCgnMWUtNicpO1xudmFyIG1hc2sgPSBiaWdJbnQoMHgwMDAwMDAwMGZmZmZmZmZmKTtcbi8qKlxuICogZGVjaW1hbC5qcyBjb25maWd1cmF0aW9uIGZvciBBbW91bnQgSU9Vc1xuICovXG5kZWNpbWFsX2pzXzEuRGVjaW1hbC5jb25maWcoe1xuICAgIHRvRXhwUG9zOiBNQVhfSU9VX0VYUE9ORU5UICsgTUFYX0lPVV9QUkVDSVNJT04sXG4gICAgdG9FeHBOZWc6IE1JTl9JT1VfRVhQT05FTlQgLSBNQVhfSU9VX1BSRUNJU0lPTixcbn0pO1xuLyoqXG4gKiBUeXBlIGd1YXJkIGZvciBBbW91bnRPYmplY3RcbiAqL1xuZnVuY3Rpb24gaXNBbW91bnRPYmplY3QoYXJnKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhcmcpLnNvcnQoKTtcbiAgICByZXR1cm4gKGtleXMubGVuZ3RoID09PSAzICYmXG4gICAgICAgIGtleXNbMF0gPT09ICdjdXJyZW5jeScgJiZcbiAgICAgICAga2V5c1sxXSA9PT0gJ2lzc3VlcicgJiZcbiAgICAgICAga2V5c1syXSA9PT0gJ3ZhbHVlJyk7XG59XG4vKipcbiAqIENsYXNzIGZvciBzZXJpYWxpemluZy9EZXNlcmlhbGl6aW5nIEFtb3VudHNcbiAqL1xudmFyIEFtb3VudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW1vdW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFtb3VudChieXRlcykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgYnl0ZXMgIT09IG51bGwgJiYgYnl0ZXMgIT09IHZvaWQgMCA/IGJ5dGVzIDogQW1vdW50LmRlZmF1bHRBbW91bnQuYnl0ZXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiBhbW91bnQgZnJvbSBhbiBJT1Ugb3Igc3RyaW5nIGFtb3VudFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEFuIEFtb3VudCwgb2JqZWN0IHJlcHJlc2VudGluZyBhbiBJT1UsIG9yIGEgc3RyaW5nXG4gICAgICogICAgIHJlcHJlc2VudGluZyBhbiBpbnRlZ2VyIGFtb3VudFxuICAgICAqIEByZXR1cm5zIEFuIEFtb3VudCBvYmplY3RcbiAgICAgKi9cbiAgICBBbW91bnQuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBbW91bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW1vdW50ID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDgpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgQW1vdW50LmFzc2VydFhycElzVmFsaWQodmFsdWUpO1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IGJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgaW50QnVmID0gW2J1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KSwgYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDQpXTtcbiAgICAgICAgICAgIGludEJ1ZlswXS53cml0ZVVJbnQzMkJFKE51bWJlcihudW1iZXIuc2hpZnRSaWdodCgzMikpLCAwKTtcbiAgICAgICAgICAgIGludEJ1ZlsxXS53cml0ZVVJbnQzMkJFKE51bWJlcihudW1iZXIuYW5kKG1hc2spKSwgMCk7XG4gICAgICAgICAgICBhbW91bnQgPSBidWZmZXJfMS5CdWZmZXIuY29uY2F0KGludEJ1Zik7XG4gICAgICAgICAgICBhbW91bnRbMF0gfD0gMHg0MDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQW1vdW50KGFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQW1vdW50T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCh2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICBBbW91bnQuYXNzZXJ0SW91SXNWYWxpZChudW1iZXIpO1xuICAgICAgICAgICAgaWYgKG51bWJlci5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgIGFtb3VudFswXSB8PSAweDgwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGludGVnZXJOdW1iZXJTdHJpbmcgPSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgLnRpbWVzKFwiMWVcIi5jb25jYXQoLShudW1iZXIuZSAtIDE1KSkpXG4gICAgICAgICAgICAgICAgICAgIC5hYnMoKVxuICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgbnVtID0gYmlnSW50KGludGVnZXJOdW1iZXJTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHZhciBpbnRCdWYgPSBbYnVmZmVyXzEuQnVmZmVyLmFsbG9jKDQpLCBidWZmZXJfMS5CdWZmZXIuYWxsb2MoNCldO1xuICAgICAgICAgICAgICAgIGludEJ1ZlswXS53cml0ZVVJbnQzMkJFKE51bWJlcihudW0uc2hpZnRSaWdodCgzMikpLCAwKTtcbiAgICAgICAgICAgICAgICBpbnRCdWZbMV0ud3JpdGVVSW50MzJCRShOdW1iZXIobnVtLmFuZChtYXNrKSksIDApO1xuICAgICAgICAgICAgICAgIGFtb3VudCA9IGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoaW50QnVmKTtcbiAgICAgICAgICAgICAgICBhbW91bnRbMF0gfD0gMHg4MDtcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyLmd0KG5ldyBkZWNpbWFsX2pzXzEuRGVjaW1hbCgwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50WzBdIHw9IDB4NDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBleHBvbmVudCA9IG51bWJlci5lIC0gMTU7XG4gICAgICAgICAgICAgICAgdmFyIGV4cG9uZW50Qnl0ZSA9IDk3ICsgZXhwb25lbnQ7XG4gICAgICAgICAgICAgICAgYW1vdW50WzBdIHw9IGV4cG9uZW50Qnl0ZSA+Pj4gMjtcbiAgICAgICAgICAgICAgICBhbW91bnRbMV0gfD0gKGV4cG9uZW50Qnl0ZSAmIDB4MDMpIDw8IDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3VycmVuY3kgPSBjdXJyZW5jeV8xLkN1cnJlbmN5LmZyb20odmFsdWUuY3VycmVuY3kpLnRvQnl0ZXMoKTtcbiAgICAgICAgICAgIHZhciBpc3N1ZXIgPSBhY2NvdW50X2lkXzEuQWNjb3VudElELmZyb20odmFsdWUuaXNzdWVyKS50b0J5dGVzKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFtb3VudChidWZmZXJfMS5CdWZmZXIuY29uY2F0KFthbW91bnQsIGN1cnJlbmN5LCBpc3N1ZXJdKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR5cGUgdG8gY29uc3RydWN0IGFuIEFtb3VudCcpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZCBhbiBhbW91bnQgZnJvbSBhIEJpbmFyeVBhcnNlclxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcnNlciBCaW5hcnlQYXJzZXIgdG8gcmVhZCB0aGUgQW1vdW50IGZyb21cbiAgICAgKiBAcmV0dXJucyBBbiBBbW91bnQgb2JqZWN0XG4gICAgICovXG4gICAgQW1vdW50LmZyb21QYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHZhciBpc1hSUCA9IHBhcnNlci5wZWVrKCkgJiAweDgwO1xuICAgICAgICB2YXIgbnVtQnl0ZXMgPSBpc1hSUCA/IDQ4IDogODtcbiAgICAgICAgcmV0dXJuIG5ldyBBbW91bnQocGFyc2VyLnJlYWQobnVtQnl0ZXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIEFtb3VudFxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIEpTT04gaW50ZXJwcmV0YXRpb24gb2YgdGhpcy5ieXRlc1xuICAgICAqL1xuICAgIEFtb3VudC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc05hdGl2ZSgpKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZXMgPSB0aGlzLmJ5dGVzO1xuICAgICAgICAgICAgdmFyIGlzUG9zaXRpdmUgPSBieXRlc1swXSAmIDB4NDA7XG4gICAgICAgICAgICB2YXIgc2lnbiA9IGlzUG9zaXRpdmUgPyAnJyA6ICctJztcbiAgICAgICAgICAgIGJ5dGVzWzBdICY9IDB4M2Y7XG4gICAgICAgICAgICB2YXIgbXNiID0gYmlnSW50KGJ5dGVzLnNsaWNlKDAsIDQpLnJlYWRVSW50MzJCRSgwKSk7XG4gICAgICAgICAgICB2YXIgbHNiID0gYmlnSW50KGJ5dGVzLnNsaWNlKDQpLnJlYWRVSW50MzJCRSgwKSk7XG4gICAgICAgICAgICB2YXIgbnVtID0gbXNiLnNoaWZ0TGVmdCgzMikub3IobHNiKTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChzaWduKS5jb25jYXQobnVtLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBiaW5hcnlfcGFyc2VyXzEuQmluYXJ5UGFyc2VyKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB2YXIgbWFudGlzc2EgPSBwYXJzZXIucmVhZCg4KTtcbiAgICAgICAgICAgIHZhciBjdXJyZW5jeSA9IGN1cnJlbmN5XzEuQ3VycmVuY3kuZnJvbVBhcnNlcihwYXJzZXIpO1xuICAgICAgICAgICAgdmFyIGlzc3VlciA9IGFjY291bnRfaWRfMS5BY2NvdW50SUQuZnJvbVBhcnNlcihwYXJzZXIpO1xuICAgICAgICAgICAgdmFyIGIxID0gbWFudGlzc2FbMF07XG4gICAgICAgICAgICB2YXIgYjIgPSBtYW50aXNzYVsxXTtcbiAgICAgICAgICAgIHZhciBpc1Bvc2l0aXZlID0gYjEgJiAweDQwO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSBpc1Bvc2l0aXZlID8gJycgOiAnLSc7XG4gICAgICAgICAgICB2YXIgZXhwb25lbnQgPSAoKGIxICYgMHgzZikgPDwgMikgKyAoKGIyICYgMHhmZikgPj4gNikgLSA5NztcbiAgICAgICAgICAgIG1hbnRpc3NhWzBdID0gMDtcbiAgICAgICAgICAgIG1hbnRpc3NhWzFdICY9IDB4M2Y7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoXCJcIi5jb25jYXQoc2lnbiwgXCIweFwiKS5jb25jYXQobWFudGlzc2EudG9TdHJpbmcoJ2hleCcpKSkudGltZXMoXCIxZVwiLmNvbmNhdChleHBvbmVudCkpO1xuICAgICAgICAgICAgQW1vdW50LmFzc2VydElvdUlzVmFsaWQodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBjdXJyZW5jeTogY3VycmVuY3kudG9KU09OKCksXG4gICAgICAgICAgICAgICAgaXNzdWVyOiBpc3N1ZXIudG9KU09OKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBYUlAgYW1vdW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW1vdW50IFN0cmluZyByZXByZXNlbnRpbmcgWFJQIGFtb3VudFxuICAgICAqIEByZXR1cm5zIHZvaWQsIGJ1dCB3aWxsIHRocm93IGlmIGludmFsaWQgYW1vdW50XG4gICAgICovXG4gICAgQW1vdW50LmFzc2VydFhycElzVmFsaWQgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgIGlmIChhbW91bnQuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGFtb3VudC50b1N0cmluZygpLCBcIiBpcyBhbiBpbGxlZ2FsIGFtb3VudFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlY2ltYWwgPSBuZXcgZGVjaW1hbF9qc18xLkRlY2ltYWwoYW1vdW50KTtcbiAgICAgICAgaWYgKCFkZWNpbWFsLmlzWmVybygpKSB7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbC5sdChNSU5fWFJQKSB8fCBkZWNpbWFsLmd0KE1BWF9EUk9QUykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIi5jb25jYXQoYW1vdW50LnRvU3RyaW5nKCksIFwiIGlzIGFuIGlsbGVnYWwgYW1vdW50XCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgSU9VLnZhbHVlIGFtb3VudFxuICAgICAqXG4gICAgICogQHBhcmFtIGRlY2ltYWwgRGVjaW1hbC5qcyBvYmplY3QgcmVwcmVzZW50aW5nIElPVS52YWx1ZVxuICAgICAqIEByZXR1cm5zIHZvaWQsIGJ1dCB3aWxsIHRocm93IGlmIGludmFsaWQgYW1vdW50XG4gICAgICovXG4gICAgQW1vdW50LmFzc2VydElvdUlzVmFsaWQgPSBmdW5jdGlvbiAoZGVjaW1hbCkge1xuICAgICAgICBpZiAoIWRlY2ltYWwuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHZhciBwID0gZGVjaW1hbC5wcmVjaXNpb24oKTtcbiAgICAgICAgICAgIHZhciBlID0gZGVjaW1hbC5lIC0gMTU7XG4gICAgICAgICAgICBpZiAocCA+IE1BWF9JT1VfUFJFQ0lTSU9OIHx8XG4gICAgICAgICAgICAgICAgZSA+IE1BWF9JT1VfRVhQT05FTlQgfHxcbiAgICAgICAgICAgICAgICBlIDwgTUlOX0lPVV9FWFBPTkVOVCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjaW1hbCBwcmVjaXNpb24gb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZlcmlmeU5vRGVjaW1hbChkZWNpbWFsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgdGhlIHZhbHVlIGFmdGVyIGJlaW5nIG11bHRpcGxpZWQgYnkgdGhlIGV4cG9uZW50IGRvZXMgbm90XG4gICAgICogY29udGFpbiBhIGRlY2ltYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVjaW1hbCBhIERlY2ltYWwgb2JqZWN0XG4gICAgICogQHJldHVybnMgYSBzdHJpbmcgb2YgdGhlIG9iamVjdCB3aXRob3V0IGEgZGVjaW1hbFxuICAgICAqL1xuICAgIEFtb3VudC52ZXJpZnlOb0RlY2ltYWwgPSBmdW5jdGlvbiAoZGVjaW1hbCkge1xuICAgICAgICB2YXIgaW50ZWdlck51bWJlclN0cmluZyA9IGRlY2ltYWxcbiAgICAgICAgICAgIC50aW1lcyhcIjFlXCIuY29uY2F0KC0oZGVjaW1hbC5lIC0gMTUpKSlcbiAgICAgICAgICAgIC5hYnMoKVxuICAgICAgICAgICAgLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChpbnRlZ2VyTnVtYmVyU3RyaW5nLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjaW1hbCBwbGFjZSBmb3VuZCBpbiBpbnRlZ2VyTnVtYmVyU3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhpcyBhbW91bnQgaXMgaW4gdW5pdHMgb2YgTmF0aXZlIEN1cnJlbmN5KFhSUClcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgTmF0aXZlIChYUlApXG4gICAgICovXG4gICAgQW1vdW50LnByb3RvdHlwZS5pc05hdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJ5dGVzWzBdICYgMHg4MCkgPT09IDA7XG4gICAgfTtcbiAgICBBbW91bnQuZGVmYXVsdEFtb3VudCA9IG5ldyBBbW91bnQoYnVmZmVyXzEuQnVmZmVyLmZyb20oJzQwMDAwMDAwMDAwMDAwMDAnLCAnaGV4JykpO1xuICAgIHJldHVybiBBbW91bnQ7XG59KHNlcmlhbGl6ZWRfdHlwZV8xLlNlcmlhbGl6ZWRUeXBlKSk7XG5leHBvcnRzLkFtb3VudCA9IEFtb3VudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtb3VudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJsb2IgPSB2b2lkIDA7XG52YXIgc2VyaWFsaXplZF90eXBlXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVkLXR5cGVcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogVmFyaWFibGUgbGVuZ3RoIGVuY29kZWQgdHlwZVxuICovXG52YXIgQmxvYiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQmxvYiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9iKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBieXRlcykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBob3cgdG8gcmVhZCBhIEJsb2IgZnJvbSBhIEJpbmFyeVBhcnNlclxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcnNlciBUaGUgYmluYXJ5IHBhcnNlciB0byByZWFkIHRoZSBCbG9iIGZyb21cbiAgICAgKiBAcGFyYW0gaGludCBUaGUgbGVuZ3RoIG9mIHRoZSBibG9iLCBjb21wdXRlZCBieSByZWFkVmFyaWFibGVMZW5ndGhMZW5ndGgoKSBhbmQgcGFzc2VkIGluXG4gICAgICogQHJldHVybnMgQSBCbG9iIG9iamVjdFxuICAgICAqL1xuICAgIEJsb2IuZnJvbVBhcnNlciA9IGZ1bmN0aW9uIChwYXJzZXIsIGhpbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKHBhcnNlci5yZWFkKGhpbnQpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIEJsb2Igb2JqZWN0IGZyb20gYSBoZXgtc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgZXhpc3RpbmcgQmxvYiBvYmplY3Qgb3IgYSBoZXgtc3RyaW5nXG4gICAgICogQHJldHVybnMgQSBCbG9iIG9iamVjdFxuICAgICAqL1xuICAgIEJsb2IuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihidWZmZXJfMS5CdWZmZXIuZnJvbSh2YWx1ZSwgJ2hleCcpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgQmxvYiBmcm9tIHZhbHVlIGdpdmVuJyk7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvYjtcbn0oc2VyaWFsaXplZF90eXBlXzEuU2VyaWFsaXplZFR5cGUpKTtcbmV4cG9ydHMuQmxvYiA9IEJsb2I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9iLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ3VycmVuY3kgPSB2b2lkIDA7XG52YXIgaGFzaF8xNjBfMSA9IHJlcXVpcmUoXCIuL2hhc2gtMTYwXCIpO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG52YXIgSVNPX1JFR0VYID0gL15bQS1aMC05XXszfSQvO1xudmFyIEhFWF9SRUdFWCA9IC9eW0EtRjAtOV17NDB9JC87XG4vKipcbiAqIENvbnZlcnQgYW4gSVNPIGNvZGUgdG8gYSBjdXJyZW5jeSBieXRlcyByZXByZXNlbnRhdGlvblxuICovXG5mdW5jdGlvbiBpc29Ub0J5dGVzKGlzbykge1xuICAgIHZhciBieXRlcyA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygyMCk7XG4gICAgaWYgKGlzbyAhPT0gJ1hSUCcpIHtcbiAgICAgICAgdmFyIGlzb0J5dGVzID0gaXNvLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMuY2hhckNvZGVBdCgwKTsgfSk7XG4gICAgICAgIGJ5dGVzLnNldChpc29CeXRlcywgMTIpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIFRlc3RzIGlmIElTTyBpcyBhIHZhbGlkIGlzbyBjb2RlXG4gKi9cbmZ1bmN0aW9uIGlzSXNvQ29kZShpc28pIHtcbiAgICByZXR1cm4gSVNPX1JFR0VYLnRlc3QoaXNvKTtcbn1cbmZ1bmN0aW9uIGlzb0NvZGVGcm9tSGV4KGNvZGUpIHtcbiAgICB2YXIgaXNvID0gY29kZS50b1N0cmluZygpO1xuICAgIGlmIChpc28gPT09ICdYUlAnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGlzYWxsb3dlZCBjdXJyZW5jeSBjb2RlOiB0byBpbmRpY2F0ZSB0aGUgY3VycmVuY3kgWFJQIHlvdSBtdXN0IHVzZSAyMCBieXRlcyBvZiAwcycpO1xuICAgIH1cbiAgICBpZiAoaXNJc29Db2RlKGlzbykpIHtcbiAgICAgICAgcmV0dXJuIGlzbztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFRlc3RzIGlmIGhleCBpcyBhIHZhbGlkIGhleC1zdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXgoaGV4KSB7XG4gICAgcmV0dXJuIEhFWF9SRUdFWC50ZXN0KGhleCk7XG59XG4vKipcbiAqIFRlc3RzIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYSBjdXJyZW5jeVxuICovXG5mdW5jdGlvbiBpc1N0cmluZ1JlcHJlc2VudGF0aW9uKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0Lmxlbmd0aCA9PT0gMyB8fCBpc0hleChpbnB1dCk7XG59XG4vKipcbiAqIFRlc3RzIGlmIGEgQnVmZmVyIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYSBjdXJyZW5jeVxuICovXG5mdW5jdGlvbiBpc0J5dGVzQXJyYXkoYnl0ZXMpIHtcbiAgICByZXR1cm4gYnl0ZXMuYnl0ZUxlbmd0aCA9PT0gMjA7XG59XG4vKipcbiAqIEVuc3VyZXMgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYSBjdXJyZW5jeVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkUmVwcmVzZW50YXRpb24oaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBidWZmZXJfMS5CdWZmZXJcbiAgICAgICAgPyBpc0J5dGVzQXJyYXkoaW5wdXQpXG4gICAgICAgIDogaXNTdHJpbmdSZXByZXNlbnRhdGlvbihpbnB1dCk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGJ5dGVzIGZyb20gYSBzdHJpbmcgb3IgYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIGEgY3VycmVuY3lcbiAqL1xuZnVuY3Rpb24gYnl0ZXNGcm9tUmVwcmVzZW50YXRpb24oaW5wdXQpIHtcbiAgICBpZiAoIWlzVmFsaWRSZXByZXNlbnRhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQ3VycmVuY3kgcmVwcmVzZW50YXRpb246IFwiLmNvbmNhdChpbnB1dCkpO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQubGVuZ3RoID09PSAzID8gaXNvVG9CeXRlcyhpbnB1dCkgOiBidWZmZXJfMS5CdWZmZXIuZnJvbShpbnB1dCwgJ2hleCcpO1xufVxuLyoqXG4gKiBDbGFzcyBkZWZpbmluZyBob3cgdG8gZW5jb2RlIGFuZCBkZWNvZGUgQ3VycmVuY2llc1xuICovXG52YXIgQ3VycmVuY3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEN1cnJlbmN5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEN1cnJlbmN5KGJ5dGVCdWYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYnl0ZUJ1ZiAhPT0gbnVsbCAmJiBieXRlQnVmICE9PSB2b2lkIDAgPyBieXRlQnVmIDogQ3VycmVuY3kuWFJQLmJ5dGVzKSB8fCB0aGlzO1xuICAgICAgICB2YXIgY29kZSA9IF90aGlzLmJ5dGVzLnNsaWNlKDEyLCAxNSk7XG4gICAgICAgIGlmIChfdGhpcy5ieXRlc1swXSAhPT0gMCkge1xuICAgICAgICAgICAgX3RoaXMuX2lzbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14wKiQvLnRlc3QoX3RoaXMuYnl0ZXMudG9TdHJpbmcoJ2hleCcpKSkge1xuICAgICAgICAgICAgX3RoaXMuX2lzbyA9ICdYUlAnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuX2lzbyA9IGlzb0NvZGVGcm9tSGV4KGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBJU08gY29kZSBvZiB0aGlzIGN1cnJlbmN5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJU08gY29kZSBpZiBpdCBleGlzdHMsIGVsc2UgbnVsbFxuICAgICAqL1xuICAgIEN1cnJlbmN5LnByb3RvdHlwZS5pc28gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc287XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgQ3VycmVuY3kgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsIEN1cnJlbmN5IG9iamVjdCBvciBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGN1cnJlbmN5XG4gICAgICovXG4gICAgQ3VycmVuY3kuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBDdXJyZW5jeSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEN1cnJlbmN5KGJ5dGVzRnJvbVJlcHJlc2VudGF0aW9uKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IEN1cnJlbmN5IGZyb20gdmFsdWUgZ2l2ZW4nKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBjdXJyZW5jeVxuICAgICAqXG4gICAgICogQHJldHVybnMgSlNPTiByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIEN1cnJlbmN5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpc28gPSB0aGlzLmlzbygpO1xuICAgICAgICBpZiAoaXNvICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNvO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLnRvU3RyaW5nKCdoZXgnKS50b1VwcGVyQ2FzZSgpO1xuICAgIH07XG4gICAgQ3VycmVuY3kuWFJQID0gbmV3IEN1cnJlbmN5KGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYygyMCkpO1xuICAgIHJldHVybiBDdXJyZW5jeTtcbn0oaGFzaF8xNjBfMS5IYXNoMTYwKSk7XG5leHBvcnRzLkN1cnJlbmN5ID0gQ3VycmVuY3k7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJyZW5jeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhhc2gxMjggPSB2b2lkIDA7XG52YXIgaGFzaF8xID0gcmVxdWlyZShcIi4vaGFzaFwiKTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLyoqXG4gKiBIYXNoIHdpdGggYSB3aWR0aCBvZiAxMjggYml0c1xuICovXG52YXIgSGFzaDEyOCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSGFzaDEyOCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIYXNoMTI4KGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBieXRlcyAhPT0gbnVsbCAmJiBieXRlcyAhPT0gdm9pZCAwID8gYnl0ZXMgOiBIYXNoMTI4LlpFUk9fMTI4LmJ5dGVzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBIYXNoMTI4LndpZHRoID0gMTY7XG4gICAgSGFzaDEyOC5aRVJPXzEyOCA9IG5ldyBIYXNoMTI4KGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhIYXNoMTI4LndpZHRoKSk7XG4gICAgcmV0dXJuIEhhc2gxMjg7XG59KGhhc2hfMS5IYXNoKSk7XG5leHBvcnRzLkhhc2gxMjggPSBIYXNoMTI4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC0xMjguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IYXNoMTYwID0gdm9pZCAwO1xudmFyIGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogSGFzaCB3aXRoIGEgd2lkdGggb2YgMTYwIGJpdHNcbiAqL1xudmFyIEhhc2gxNjAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhhc2gxNjAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGFzaDE2MChieXRlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYnl0ZXMgJiYgYnl0ZXMuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBIYXNoMTYwLlpFUk9fMTYwLmJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgYnl0ZXMgIT09IG51bGwgJiYgYnl0ZXMgIT09IHZvaWQgMCA/IGJ5dGVzIDogSGFzaDE2MC5aRVJPXzE2MC5ieXRlcykgfHwgdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBIYXNoMTYwLndpZHRoID0gMjA7XG4gICAgSGFzaDE2MC5aRVJPXzE2MCA9IG5ldyBIYXNoMTYwKGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhIYXNoMTYwLndpZHRoKSk7XG4gICAgcmV0dXJuIEhhc2gxNjA7XG59KGhhc2hfMS5IYXNoKSk7XG5leHBvcnRzLkhhc2gxNjAgPSBIYXNoMTYwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC0xNjAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IYXNoMjU2ID0gdm9pZCAwO1xudmFyIGhhc2hfMSA9IHJlcXVpcmUoXCIuL2hhc2hcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogSGFzaCB3aXRoIGEgd2lkdGggb2YgMjU2IGJpdHNcbiAqL1xudmFyIEhhc2gyNTYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhhc2gyNTYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGFzaDI1NihieXRlcykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgYnl0ZXMgIT09IG51bGwgJiYgYnl0ZXMgIT09IHZvaWQgMCA/IGJ5dGVzIDogSGFzaDI1Ni5aRVJPXzI1Ni5ieXRlcykgfHwgdGhpcztcbiAgICB9XG4gICAgSGFzaDI1Ni53aWR0aCA9IDMyO1xuICAgIEhhc2gyNTYuWkVST18yNTYgPSBuZXcgSGFzaDI1NihidWZmZXJfMS5CdWZmZXIuYWxsb2MoSGFzaDI1Ni53aWR0aCkpO1xuICAgIHJldHVybiBIYXNoMjU2O1xufShoYXNoXzEuSGFzaCkpO1xuZXhwb3J0cy5IYXNoMjU2ID0gSGFzaDI1Njtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtMjU2LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFzaCA9IHZvaWQgMDtcbnZhciBzZXJpYWxpemVkX3R5cGVfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZWQtdHlwZVwiKTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGRlZmluaW5nIGhvdyB0byBlbmNvZGUgYW5kIGRlY29kZSBoYXNoZXNcbiAqL1xudmFyIEhhc2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhhc2gsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSGFzaChieXRlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBieXRlcykgfHwgdGhpcztcbiAgICAgICAgaWYgKF90aGlzLmJ5dGVzLmJ5dGVMZW5ndGggIT09IF90aGlzLmNvbnN0cnVjdG9yLndpZHRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEhhc2ggbGVuZ3RoIFwiLmNvbmNhdChfdGhpcy5ieXRlcy5ieXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBIYXNoIG9iamVjdCBmcm9tIGFuIGV4aXN0aW5nIEhhc2ggb2JqZWN0IG9yIGEgaGV4LXN0cmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEEgaGFzaCBvYmplY3Qgb3IgaGV4LXN0cmluZyBvZiBhIGhhc2hcbiAgICAgKi9cbiAgICBIYXNoLmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMoYnVmZmVyXzEuQnVmZmVyLmZyb20odmFsdWUsICdoZXgnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IEhhc2ggZnJvbSBnaXZlbiB2YWx1ZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZCBhIEhhc2ggb2JqZWN0IGZyb20gYSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJzZXIgQmluYXJ5UGFyc2VyIHRvIHJlYWQgdGhlIGhhc2ggZnJvbVxuICAgICAqIEBwYXJhbSBoaW50IGxlbmd0aCBvZiB0aGUgYnl0ZXMgdG8gcmVhZCwgb3B0aW9uYWxcbiAgICAgKi9cbiAgICBIYXNoLmZyb21QYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyLCBoaW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhwYXJzZXIucmVhZChoaW50ICE9PSBudWxsICYmIGhpbnQgIT09IHZvaWQgMCA/IGhpbnQgOiB0aGlzLndpZHRoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPdmVybG9hZGVkIG9wZXJhdG9yIGZvciBjb21wYXJpbmcgdHdvIGhhc2ggb2JqZWN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIG90aGVyIFRoZSBIYXNoIHRvIGNvbXBhcmUgdGhpcyB0b1xuICAgICAqL1xuICAgIEhhc2gucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5jb21wYXJlKHRoaXMuY29uc3RydWN0b3IuZnJvbShvdGhlcikuYnl0ZXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgdGhlIGhleC1zdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBIYXNoXG4gICAgICovXG4gICAgSGFzaC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZvdXIgYml0cyBhdCB0aGUgc3BlY2lmaWVkIGRlcHRoIHdpdGhpbiBhIGhhc2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkZXB0aCBUaGUgZGVwdGggb2YgdGhlIGZvdXIgYml0c1xuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGZvdXIgYml0c1xuICAgICAqL1xuICAgIEhhc2gucHJvdG90eXBlLm5pYmJsZXQgPSBmdW5jdGlvbiAoZGVwdGgpIHtcbiAgICAgICAgdmFyIGJ5dGVJeCA9IGRlcHRoID4gMCA/IChkZXB0aCAvIDIpIHwgMCA6IDA7XG4gICAgICAgIHZhciBiID0gdGhpcy5ieXRlc1tieXRlSXhdO1xuICAgICAgICBpZiAoZGVwdGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICBiID0gKGIgJiAweGYwKSA+Pj4gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGIgPSBiICYgMHgwZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYjtcbiAgICB9O1xuICAgIHJldHVybiBIYXNoO1xufShzZXJpYWxpemVkX3R5cGVfMS5Db21wYXJhYmxlKSk7XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29yZVR5cGVzID0gdm9pZCAwO1xudmFyIGVudW1zXzEgPSByZXF1aXJlKFwiLi4vZW51bXNcIik7XG52YXIgYWNjb3VudF9pZF8xID0gcmVxdWlyZShcIi4vYWNjb3VudC1pZFwiKTtcbnZhciBhbW91bnRfMSA9IHJlcXVpcmUoXCIuL2Ftb3VudFwiKTtcbnZhciBibG9iXzEgPSByZXF1aXJlKFwiLi9ibG9iXCIpO1xudmFyIGN1cnJlbmN5XzEgPSByZXF1aXJlKFwiLi9jdXJyZW5jeVwiKTtcbnZhciBoYXNoXzEyOF8xID0gcmVxdWlyZShcIi4vaGFzaC0xMjhcIik7XG52YXIgaGFzaF8xNjBfMSA9IHJlcXVpcmUoXCIuL2hhc2gtMTYwXCIpO1xudmFyIGhhc2hfMjU2XzEgPSByZXF1aXJlKFwiLi9oYXNoLTI1NlwiKTtcbnZhciBwYXRoX3NldF8xID0gcmVxdWlyZShcIi4vcGF0aC1zZXRcIik7XG52YXIgc3RfYXJyYXlfMSA9IHJlcXVpcmUoXCIuL3N0LWFycmF5XCIpO1xudmFyIHN0X29iamVjdF8xID0gcmVxdWlyZShcIi4vc3Qtb2JqZWN0XCIpO1xudmFyIHVpbnRfMTZfMSA9IHJlcXVpcmUoXCIuL3VpbnQtMTZcIik7XG52YXIgdWludF8zMl8xID0gcmVxdWlyZShcIi4vdWludC0zMlwiKTtcbnZhciB1aW50XzY0XzEgPSByZXF1aXJlKFwiLi91aW50LTY0XCIpO1xudmFyIHVpbnRfOF8xID0gcmVxdWlyZShcIi4vdWludC04XCIpO1xudmFyIHZlY3Rvcl8yNTZfMSA9IHJlcXVpcmUoXCIuL3ZlY3Rvci0yNTZcIik7XG52YXIgY29yZVR5cGVzID0ge1xuICAgIEFjY291bnRJRDogYWNjb3VudF9pZF8xLkFjY291bnRJRCxcbiAgICBBbW91bnQ6IGFtb3VudF8xLkFtb3VudCxcbiAgICBCbG9iOiBibG9iXzEuQmxvYixcbiAgICBDdXJyZW5jeTogY3VycmVuY3lfMS5DdXJyZW5jeSxcbiAgICBIYXNoMTI4OiBoYXNoXzEyOF8xLkhhc2gxMjgsXG4gICAgSGFzaDE2MDogaGFzaF8xNjBfMS5IYXNoMTYwLFxuICAgIEhhc2gyNTY6IGhhc2hfMjU2XzEuSGFzaDI1NixcbiAgICBQYXRoU2V0OiBwYXRoX3NldF8xLlBhdGhTZXQsXG4gICAgU1RBcnJheTogc3RfYXJyYXlfMS5TVEFycmF5LFxuICAgIFNUT2JqZWN0OiBzdF9vYmplY3RfMS5TVE9iamVjdCxcbiAgICBVSW50ODogdWludF84XzEuVUludDgsXG4gICAgVUludDE2OiB1aW50XzE2XzEuVUludDE2LFxuICAgIFVJbnQzMjogdWludF8zMl8xLlVJbnQzMixcbiAgICBVSW50NjQ6IHVpbnRfNjRfMS5VSW50NjQsXG4gICAgVmVjdG9yMjU2OiB2ZWN0b3JfMjU2XzEuVmVjdG9yMjU2LFxufTtcbmV4cG9ydHMuY29yZVR5cGVzID0gY29yZVR5cGVzO1xuT2JqZWN0LnZhbHVlcyhlbnVtc18xLkZpZWxkKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGZpZWxkLmFzc29jaWF0ZWRUeXBlID0gY29yZVR5cGVzW2ZpZWxkLnR5cGUubmFtZV07XG59KTtcbmVudW1zXzEuRmllbGRbJ1RyYW5zYWN0aW9uVHlwZSddLmFzc29jaWF0ZWRUeXBlID0gZW51bXNfMS5UcmFuc2FjdGlvblR5cGU7XG5lbnVtc18xLkZpZWxkWydUcmFuc2FjdGlvblJlc3VsdCddLmFzc29jaWF0ZWRUeXBlID0gZW51bXNfMS5UcmFuc2FjdGlvblJlc3VsdDtcbmVudW1zXzEuRmllbGRbJ0xlZGdlckVudHJ5VHlwZSddLmFzc29jaWF0ZWRUeXBlID0gZW51bXNfMS5MZWRnZXJFbnRyeVR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBhdGhTZXQgPSB2b2lkIDA7XG52YXIgYWNjb3VudF9pZF8xID0gcmVxdWlyZShcIi4vYWNjb3VudC1pZFwiKTtcbnZhciBjdXJyZW5jeV8xID0gcmVxdWlyZShcIi4vY3VycmVuY3lcIik7XG52YXIgYmluYXJ5X3BhcnNlcl8xID0gcmVxdWlyZShcIi4uL3NlcmRlcy9iaW5hcnktcGFyc2VyXCIpO1xudmFyIHNlcmlhbGl6ZWRfdHlwZV8xID0gcmVxdWlyZShcIi4vc2VyaWFsaXplZC10eXBlXCIpO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG4vKipcbiAqIENvbnN0YW50cyBmb3Igc2VwYXJhdGluZyBQYXRocyBpbiBhIFBhdGhTZXRcbiAqL1xudmFyIFBBVEhTRVRfRU5EX0JZVEUgPSAweDAwO1xudmFyIFBBVEhfU0VQQVJBVE9SX0JZVEUgPSAweGZmO1xuLyoqXG4gKiBDb25zdGFudCBmb3IgbWFza2luZyB0eXBlcyBvZiBhIEhvcFxuICovXG52YXIgVFlQRV9BQ0NPVU5UID0gMHgwMTtcbnZhciBUWVBFX0NVUlJFTkNZID0gMHgxMDtcbnZhciBUWVBFX0lTU1VFUiA9IDB4MjA7XG4vKipcbiAqIFR5cGVHdWFyZCBmb3IgSG9wT2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzSG9wT2JqZWN0KGFyZykge1xuICAgIHJldHVybiAoYXJnLmlzc3VlciAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGFyZy5hY2NvdW50ICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgYXJnLmN1cnJlbmN5ICE9PSB1bmRlZmluZWQpO1xufVxuLyoqXG4gKiBUeXBlR3VhcmQgZm9yIFBhdGhTZXRcbiAqL1xuZnVuY3Rpb24gaXNQYXRoU2V0KGFyZykge1xuICAgIHJldHVybiAoKEFycmF5LmlzQXJyYXkoYXJnKSAmJiBhcmcubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShhcmcpICYmIEFycmF5LmlzQXJyYXkoYXJnWzBdKSAmJiBhcmdbMF0ubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShhcmcpICYmIEFycmF5LmlzQXJyYXkoYXJnWzBdKSAmJiBpc0hvcE9iamVjdChhcmdbMF1bMF0pKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZSBhbmQgRGVzZXJpYWxpemUgYSBIb3BcbiAqL1xudmFyIEhvcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSG9wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhvcCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBIb3AgZnJvbSBhIEhvcE9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEVpdGhlciBhIGhvcCBvciBIb3BPYmplY3QgdG8gY3JlYXRlIGEgaG9wIHdpdGhcbiAgICAgKiBAcmV0dXJucyBhIEhvcFxuICAgICAqL1xuICAgIEhvcC5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBieXRlcyA9IFtidWZmZXJfMS5CdWZmZXIuZnJvbShbMF0pXTtcbiAgICAgICAgaWYgKHZhbHVlLmFjY291bnQpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goYWNjb3VudF9pZF8xLkFjY291bnRJRC5mcm9tKHZhbHVlLmFjY291bnQpLnRvQnl0ZXMoKSk7XG4gICAgICAgICAgICBieXRlc1swXVswXSB8PSBUWVBFX0FDQ09VTlQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmN1cnJlbmN5KSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKGN1cnJlbmN5XzEuQ3VycmVuY3kuZnJvbSh2YWx1ZS5jdXJyZW5jeSkudG9CeXRlcygpKTtcbiAgICAgICAgICAgIGJ5dGVzWzBdWzBdIHw9IFRZUEVfQ1VSUkVOQ1k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmlzc3Vlcikge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChhY2NvdW50X2lkXzEuQWNjb3VudElELmZyb20odmFsdWUuaXNzdWVyKS50b0J5dGVzKCkpO1xuICAgICAgICAgICAgYnl0ZXNbMF1bMF0gfD0gVFlQRV9JU1NVRVI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIb3AoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChieXRlcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgSG9wIGZyb20gYSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJzZXIgQmluYXJ5UGFyc2VyIHRvIHJlYWQgdGhlIEhvcCBmcm9tXG4gICAgICogQHJldHVybnMgYSBIb3BcbiAgICAgKi9cbiAgICBIb3AuZnJvbVBhcnNlciA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBwYXJzZXIucmVhZFVJbnQ4KCk7XG4gICAgICAgIHZhciBieXRlcyA9IFtidWZmZXJfMS5CdWZmZXIuZnJvbShbdHlwZV0pXTtcbiAgICAgICAgaWYgKHR5cGUgJiBUWVBFX0FDQ09VTlQpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2gocGFyc2VyLnJlYWQoYWNjb3VudF9pZF8xLkFjY291bnRJRC53aWR0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICYgVFlQRV9DVVJSRU5DWSkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChwYXJzZXIucmVhZChjdXJyZW5jeV8xLkN1cnJlbmN5LndpZHRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgJiBUWVBFX0lTU1VFUikge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChwYXJzZXIucmVhZChhY2NvdW50X2lkXzEuQWNjb3VudElELndpZHRoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIb3AoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChieXRlcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBKU09OIGludGVycHJldGF0aW9uIG9mIHRoaXMgaG9wXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIEhvcE9iamVjdCwgYW4gSlMgb2JqZWN0IHdpdGggb3B0aW9uYWwgYWNjb3VudCwgaXNzdWVyLCBhbmQgY3VycmVuY3lcbiAgICAgKi9cbiAgICBIb3AucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhvcFBhcnNlciA9IG5ldyBiaW5hcnlfcGFyc2VyXzEuQmluYXJ5UGFyc2VyKHRoaXMuYnl0ZXMudG9TdHJpbmcoJ2hleCcpKTtcbiAgICAgICAgdmFyIHR5cGUgPSBob3BQYXJzZXIucmVhZFVJbnQ4KCk7XG4gICAgICAgIHZhciBhY2NvdW50LCBjdXJyZW5jeSwgaXNzdWVyO1xuICAgICAgICBpZiAodHlwZSAmIFRZUEVfQUNDT1VOVCkge1xuICAgICAgICAgICAgYWNjb3VudCA9IGFjY291bnRfaWRfMS5BY2NvdW50SUQuZnJvbVBhcnNlcihob3BQYXJzZXIpLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlICYgVFlQRV9DVVJSRU5DWSkge1xuICAgICAgICAgICAgY3VycmVuY3kgPSBjdXJyZW5jeV8xLkN1cnJlbmN5LmZyb21QYXJzZXIoaG9wUGFyc2VyKS50b0pTT04oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSAmIFRZUEVfSVNTVUVSKSB7XG4gICAgICAgICAgICBpc3N1ZXIgPSBhY2NvdW50X2lkXzEuQWNjb3VudElELmZyb21QYXJzZXIoaG9wUGFyc2VyKS50b0pTT04oKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGlmIChhY2NvdW50KSB7XG4gICAgICAgICAgICByZXN1bHQuYWNjb3VudCA9IGFjY291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzc3Vlcikge1xuICAgICAgICAgICAgcmVzdWx0Lmlzc3VlciA9IGlzc3VlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVuY3kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jdXJyZW5jeSA9IGN1cnJlbmN5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXQgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRoaXMgaG9wXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIG51bWJlciB0byBiZSBiaXR3aXNlIGFuZC1lZCB3aXRoIFRZUEVfIGNvbnN0YW50cyB0byBkZXNjcmliZSB0aGUgdHlwZXMgaW4gdGhlIGhvcFxuICAgICAqL1xuICAgIEhvcC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbMF07XG4gICAgfTtcbiAgICByZXR1cm4gSG9wO1xufShzZXJpYWxpemVkX3R5cGVfMS5TZXJpYWxpemVkVHlwZSkpO1xuLyoqXG4gKiBDbGFzcyBmb3Igc2VyaWFsaXppbmcvZGVzZXJpYWxpemluZyBQYXRoc1xuICovXG52YXIgUGF0aCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGF0aCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQYXRoKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNvbnN0cnVjdCBhIFBhdGggZnJvbSBhbiBhcnJheSBvZiBIb3BzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgUGF0aCBvciBhcnJheSBvZiBIb3BPYmplY3RzIHRvIGNvbnN0cnVjdCBhIFBhdGhcbiAgICAgKiBAcmV0dXJucyB0aGUgUGF0aFxuICAgICAqL1xuICAgIFBhdGguZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGhvcCkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChIb3AuZnJvbShob3ApLnRvQnl0ZXMoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFBhdGgoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChieXRlcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVhZCBhIFBhdGggZnJvbSBhIEJpbmFyeVBhcnNlclxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcnNlciBCaW5hcnlQYXJzZXIgdG8gcmVhZCBQYXRoIGZyb21cbiAgICAgKiBAcmV0dXJucyB0aGUgUGF0aCByZXByZXNlbnRlZCBieSB0aGUgYnl0ZXMgcmVhZCBmcm9tIHRoZSBCaW5hcnlQYXJzZXJcbiAgICAgKi9cbiAgICBQYXRoLmZyb21QYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHZhciBieXRlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIXBhcnNlci5lbmQoKSkge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChIb3AuZnJvbVBhcnNlcihwYXJzZXIpLnRvQnl0ZXMoKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VyLnBlZWsoKSA9PT0gUEFUSFNFVF9FTkRfQllURSB8fFxuICAgICAgICAgICAgICAgIHBhcnNlci5wZWVrKCkgPT09IFBBVEhfU0VQQVJBVE9SX0JZVEUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhdGgoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChieXRlcykpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgUGF0aFxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gQXJyYXkgb2YgSG9wT2JqZWN0IGNvbnN0cnVjdGVkIGZyb20gdGhpcy5ieXRlc1xuICAgICAqL1xuICAgIFBhdGgucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGpzb24gPSBbXTtcbiAgICAgICAgdmFyIHBhdGhQYXJzZXIgPSBuZXcgYmluYXJ5X3BhcnNlcl8xLkJpbmFyeVBhcnNlcih0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICB3aGlsZSAoIXBhdGhQYXJzZXIuZW5kKCkpIHtcbiAgICAgICAgICAgIGpzb24ucHVzaChIb3AuZnJvbVBhcnNlcihwYXRoUGFyc2VyKS50b0pTT04oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfTtcbiAgICByZXR1cm4gUGF0aDtcbn0oc2VyaWFsaXplZF90eXBlXzEuU2VyaWFsaXplZFR5cGUpKTtcbi8qKlxuICogRGVzZXJpYWxpemUgYW5kIFNlcmlhbGl6ZSB0aGUgUGF0aFNldCB0eXBlXG4gKi9cbnZhciBQYXRoU2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXRoU2V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhdGhTZXQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgUGF0aFNldCBmcm9tIGFuIEFycmF5IG9mIEFycmF5cyByZXByZXNlbnRpbmcgcGF0aHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBBIFBhdGhTZXQgb3IgQXJyYXkgb2YgQXJyYXkgb2YgSG9wT2JqZWN0c1xuICAgICAqIEByZXR1cm5zIHRoZSBQYXRoU2V0IGNvbnN0cnVjdGVkIGZyb20gdmFsdWVcbiAgICAgKi9cbiAgICBQYXRoU2V0LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUGF0aFNldCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BhdGhTZXQodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgYnl0ZXNfMSA9IFtdO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzXzEucHVzaChQYXRoLmZyb20ocGF0aCkudG9CeXRlcygpKTtcbiAgICAgICAgICAgICAgICBieXRlc18xLnB1c2goYnVmZmVyXzEuQnVmZmVyLmZyb20oW1BBVEhfU0VQQVJBVE9SX0JZVEVdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJ5dGVzXzFbYnl0ZXNfMS5sZW5ndGggLSAxXSA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKFtQQVRIU0VUX0VORF9CWVRFXSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhdGhTZXQoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChieXRlc18xKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IFBhdGhTZXQgZnJvbSBnaXZlbiB2YWx1ZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgUGF0aFNldCBmcm9tIGEgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyc2VyIEEgQmluYXJ5UGFyc2VyIHRvIHJlYWQgUGF0aFNldCBmcm9tXG4gICAgICogQHJldHVybnMgdGhlIFBhdGhTZXQgcmVhZCBmcm9tIHBhcnNlclxuICAgICAqL1xuICAgIFBhdGhTZXQuZnJvbVBhcnNlciA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICAgIHdoaWxlICghcGFyc2VyLmVuZCgpKSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKFBhdGguZnJvbVBhcnNlcihwYXJzZXIpLnRvQnl0ZXMoKSk7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHBhcnNlci5yZWFkKDEpKTtcbiAgICAgICAgICAgIGlmIChieXRlc1tieXRlcy5sZW5ndGggLSAxXVswXSA9PSBQQVRIU0VUX0VORF9CWVRFKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoU2V0KGJ1ZmZlcl8xLkJ1ZmZlci5jb25jYXQoYnl0ZXMpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFBhdGhTZXRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIEFycmF5IG9mIEFycmF5IG9mIEhvcE9iamVjdHMsIHJlcHJlc2VudGluZyB0aGlzIFBhdGhTZXRcbiAgICAgKi9cbiAgICBQYXRoU2V0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBqc29uID0gW107XG4gICAgICAgIHZhciBwYXRoUGFyc2VyID0gbmV3IGJpbmFyeV9wYXJzZXJfMS5CaW5hcnlQYXJzZXIodGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgd2hpbGUgKCFwYXRoUGFyc2VyLmVuZCgpKSB7XG4gICAgICAgICAgICBqc29uLnB1c2goUGF0aC5mcm9tUGFyc2VyKHBhdGhQYXJzZXIpLnRvSlNPTigpKTtcbiAgICAgICAgICAgIHBhdGhQYXJzZXIuc2tpcCgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9O1xuICAgIHJldHVybiBQYXRoU2V0O1xufShzZXJpYWxpemVkX3R5cGVfMS5TZXJpYWxpemVkVHlwZSkpO1xuZXhwb3J0cy5QYXRoU2V0ID0gUGF0aFNldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGgtc2V0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcGFyYWJsZSA9IGV4cG9ydHMuU2VyaWFsaXplZFR5cGUgPSB2b2lkIDA7XG52YXIgYmluYXJ5X3NlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuLi9zZXJkZXMvYmluYXJ5LXNlcmlhbGl6ZXJcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogVGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBiaW5hcnktY29kZWMgdHlwZXNcbiAqL1xudmFyIFNlcmlhbGl6ZWRUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZWRUeXBlKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIHRoaXMuYnl0ZXMgPSBieXRlcyAhPT0gbnVsbCAmJiBieXRlcyAhPT0gdm9pZCAwID8gYnl0ZXMgOiBidWZmZXJfMS5CdWZmZXIuYWxsb2MoMCk7XG4gICAgfVxuICAgIFNlcmlhbGl6ZWRUeXBlLmZyb21QYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyLCBoaW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbVBhcnNlciBub3QgaW1wbGVtZW50ZWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVBhcnNlcihwYXJzZXIsIGhpbnQpO1xuICAgIH07XG4gICAgU2VyaWFsaXplZFR5cGUuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zyb20gbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20odmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogV3JpdGUgdGhlIGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIGEgU2VyaWFsaXplZFR5cGUgdG8gYSBCeXRlc0xpc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0IFRoZSBCeXRlc0xpc3QgdG8gd3JpdGUgU2VyaWFsaXplZFR5cGUgYnl0ZXMgdG9cbiAgICAgKi9cbiAgICBTZXJpYWxpemVkVHlwZS5wcm90b3R5cGUudG9CeXRlc1NpbmsgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICBsaXN0LnB1dCh0aGlzLmJ5dGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaGV4IHJlcHJlc2VudGF0aW9uIG9mIGEgU2VyaWFsaXplZFR5cGUncyBieXRlc1xuICAgICAqXG4gICAgICogQHJldHVybnMgaGV4IFN0cmluZyBvZiB0aGlzLmJ5dGVzXG4gICAgICovXG4gICAgU2VyaWFsaXplZFR5cGUucHJvdG90eXBlLnRvSGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCkudG9TdHJpbmcoJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIGEgU2VyaWFsaXplZFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgYnVmZmVyIG9mIHRoZSBieXRlc1xuICAgICAqL1xuICAgIFNlcmlhbGl6ZWRUeXBlLnByb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IGJpbmFyeV9zZXJpYWxpemVyXzEuQnl0ZXNMaXN0KCk7XG4gICAgICAgIHRoaXMudG9CeXRlc1NpbmsoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gYnl0ZXMudG9CeXRlcygpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgU2VyaWFsaXplZFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFueSB0eXBlLCBpZiBub3Qgb3ZlcmxvYWRlZCByZXR1cm5zIGhleFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBieXRlc1xuICAgICAqL1xuICAgIFNlcmlhbGl6ZWRUeXBlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBoZXhTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcy5ieXRlc1xuICAgICAqL1xuICAgIFNlcmlhbGl6ZWRUeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXgoKTtcbiAgICB9O1xuICAgIHJldHVybiBTZXJpYWxpemVkVHlwZTtcbn0oKSk7XG5leHBvcnRzLlNlcmlhbGl6ZWRUeXBlID0gU2VyaWFsaXplZFR5cGU7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFNlcmlhbGl6ZWRUeXBlcyB0aGF0IGFyZSBjb21wYXJhYmxlXG4gKi9cbnZhciBDb21wYXJhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb21wYXJhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbXBhcmFibGUoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29tcGFyYWJsZS5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA8IDA7XG4gICAgfTtcbiAgICBDb21wYXJhYmxlLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlVG8ob3RoZXIpID09PSAwO1xuICAgIH07XG4gICAgQ29tcGFyYWJsZS5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA+IDA7XG4gICAgfTtcbiAgICBDb21wYXJhYmxlLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA+IC0xO1xuICAgIH07XG4gICAgQ29tcGFyYWJsZS5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVUbyhvdGhlcikgPCAxO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogT3ZlcmxvYWQgdGhpcyBtZXRob2QgdG8gZGVmaW5lIGhvdyB0d28gQ29tcGFyYWJsZSBTZXJpYWxpemVkVHlwZXMgYXJlIGNvbXBhcmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgVGhlIGNvbXBhcmFibGUgb2JqZWN0IHRvIGNvbXBhcmUgdGhpcyB0b1xuICAgICAqIEByZXR1cm5zIEEgbnVtYmVyIGRlbm90aW5nIHRoZSByZWxhdGlvbnNoaXAgb2YgdGhpcyBhbmQgb3RoZXJcbiAgICAgKi9cbiAgICBDb21wYXJhYmxlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbXBhcmUgXCIuY29uY2F0KHRoaXMudG9TdHJpbmcoKSwgXCIgYW5kIFwiKS5jb25jYXQob3RoZXIudG9TdHJpbmcoKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbXBhcmFibGU7XG59KFNlcmlhbGl6ZWRUeXBlKSk7XG5leHBvcnRzLkNvbXBhcmFibGUgPSBDb21wYXJhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXplZC10eXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU1RBcnJheSA9IHZvaWQgMDtcbnZhciBzZXJpYWxpemVkX3R5cGVfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZWQtdHlwZVwiKTtcbnZhciBzdF9vYmplY3RfMSA9IHJlcXVpcmUoXCIuL3N0LW9iamVjdFwiKTtcbnZhciBiaW5hcnlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vc2VyZGVzL2JpbmFyeS1wYXJzZXJcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbnZhciBBUlJBWV9FTkRfTUFSS0VSID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oWzB4ZjFdKTtcbnZhciBBUlJBWV9FTkRfTUFSS0VSX05BTUUgPSAnQXJyYXlFbmRNYXJrZXInO1xudmFyIE9CSkVDVF9FTkRfTUFSS0VSID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oWzB4ZTFdKTtcbi8qKlxuICogVHlwZUd1YXJkIGZvciBBcnJheTxKc29uT2JqZWN0PlxuICovXG5mdW5jdGlvbiBpc09iamVjdHMoYXJncykge1xuICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiAoYXJncy5sZW5ndGggPT09IDAgfHwgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnKSk7XG59XG4vKipcbiAqIENsYXNzIGZvciBzZXJpYWxpemluZyBhbmQgZGVzZXJpYWxpemluZyBBcnJheXMgb2YgT2JqZWN0c1xuICovXG52YXIgU1RBcnJheSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU1RBcnJheSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTVEFycmF5KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiBTVEFycmF5IGZyb20gYSBCaW5hcnlQYXJzZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJzZXIgQmluYXJ5UGFyc2VyIHRvIHBhcnNlIGFuIFNUQXJyYXkgZnJvbVxuICAgICAqIEByZXR1cm5zIEFuIFNUQXJyYXkgT2JqZWN0XG4gICAgICovXG4gICAgU1RBcnJheS5mcm9tUGFyc2VyID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgICAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFwYXJzZXIuZW5kKCkpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IHBhcnNlci5yZWFkRmllbGQoKTtcbiAgICAgICAgICAgIGlmIChmaWVsZC5uYW1lID09PSBBUlJBWV9FTkRfTUFSS0VSX05BTUUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ5dGVzLnB1c2goZmllbGQuaGVhZGVyLCBwYXJzZXIucmVhZEZpZWxkVmFsdWUoZmllbGQpLnRvQnl0ZXMoKSwgT0JKRUNUX0VORF9NQVJLRVIpO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzLnB1c2goQVJSQVlfRU5EX01BUktFUik7XG4gICAgICAgIHJldHVybiBuZXcgU1RBcnJheShidWZmZXJfMS5CdWZmZXIuY29uY2F0KGJ5dGVzKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4gU1RBcnJheSBmcm9tIGFuIEFycmF5IG9mIEpTT04gT2JqZWN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFNUQXJyYXkgb3IgQXJyYXkgb2YgT2JqZWN0cyB0byBwYXJzZSBpbnRvIGFuIFNUQXJyYXlcbiAgICAgKiBAcmV0dXJucyBBbiBTVEFycmF5IG9iamVjdFxuICAgICAqL1xuICAgIFNUQXJyYXkuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTVEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBieXRlc18xID0gW107XG4gICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICBieXRlc18xLnB1c2goc3Rfb2JqZWN0XzEuU1RPYmplY3QuZnJvbShvYmopLnRvQnl0ZXMoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJ5dGVzXzEucHVzaChBUlJBWV9FTkRfTUFSS0VSKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU1RBcnJheShidWZmZXJfMS5CdWZmZXIuY29uY2F0KGJ5dGVzXzEpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgU1RBcnJheSBmcm9tIHZhbHVlIGdpdmVuJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhpcy5ieXRlc1xuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gQXJyYXkgb2YgSlNPTiBvYmplY3RzXG4gICAgICovXG4gICAgU1RBcnJheS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBhcnJheVBhcnNlciA9IG5ldyBiaW5hcnlfcGFyc2VyXzEuQmluYXJ5UGFyc2VyKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIHdoaWxlICghYXJyYXlQYXJzZXIuZW5kKCkpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGFycmF5UGFyc2VyLnJlYWRGaWVsZCgpO1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IEFSUkFZX0VORF9NQVJLRVJfTkFNRSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG91dGVyID0ge307XG4gICAgICAgICAgICBvdXRlcltmaWVsZC5uYW1lXSA9IHN0X29iamVjdF8xLlNUT2JqZWN0LmZyb21QYXJzZXIoYXJyYXlQYXJzZXIpLnRvSlNPTigpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gob3V0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gU1RBcnJheTtcbn0oc2VyaWFsaXplZF90eXBlXzEuU2VyaWFsaXplZFR5cGUpKTtcbmV4cG9ydHMuU1RBcnJheSA9IFNUQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdC1hcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNUT2JqZWN0ID0gdm9pZCAwO1xudmFyIGVudW1zXzEgPSByZXF1aXJlKFwiLi4vZW51bXNcIik7XG52YXIgc2VyaWFsaXplZF90eXBlXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVkLXR5cGVcIik7XG52YXIgcmlwcGxlX2FkZHJlc3NfY29kZWNfMSA9IHJlcXVpcmUoXCJyaXBwbGUtYWRkcmVzcy1jb2RlY1wiKTtcbnZhciBiaW5hcnlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi4vc2VyZGVzL2JpbmFyeS1wYXJzZXJcIik7XG52YXIgYmluYXJ5X3NlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuLi9zZXJkZXMvYmluYXJ5LXNlcmlhbGl6ZXJcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbnZhciBPQkpFQ1RfRU5EX01BUktFUl9CWVRFID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oWzB4ZTFdKTtcbnZhciBPQkpFQ1RfRU5EX01BUktFUiA9ICdPYmplY3RFbmRNYXJrZXInO1xudmFyIFNUX09CSkVDVCA9ICdTVE9iamVjdCc7XG52YXIgREVTVElOQVRJT04gPSAnRGVzdGluYXRpb24nO1xudmFyIEFDQ09VTlQgPSAnQWNjb3VudCc7XG52YXIgU09VUkNFX1RBRyA9ICdTb3VyY2VUYWcnO1xudmFyIERFU1RfVEFHID0gJ0Rlc3RpbmF0aW9uVGFnJztcbi8qKlxuICogQnJlYWsgZG93biBhbiBYLUFkZHJlc3MgaW50byBhbiBhY2NvdW50IGFuZCBhIHRhZ1xuICpcbiAqIEBwYXJhbSBmaWVsZCBOYW1lIG9mIGZpZWxkXG4gKiBAcGFyYW0geEFkZHJlc3MgWC1BZGRyZXNzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVhBZGRyZXNzKGZpZWxkLCB4QWRkcmVzcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIGRlY29kZWQgPSAoMCwgcmlwcGxlX2FkZHJlc3NfY29kZWNfMS54QWRkcmVzc1RvQ2xhc3NpY0FkZHJlc3MpKHhBZGRyZXNzKTtcbiAgICB2YXIgdGFnTmFtZTtcbiAgICBpZiAoZmllbGQgPT09IERFU1RJTkFUSU9OKVxuICAgICAgICB0YWdOYW1lID0gREVTVF9UQUc7XG4gICAgZWxzZSBpZiAoZmllbGQgPT09IEFDQ09VTlQpXG4gICAgICAgIHRhZ05hbWUgPSBTT1VSQ0VfVEFHO1xuICAgIGVsc2UgaWYgKGRlY29kZWQudGFnICE9PSBmYWxzZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIuY29uY2F0KGZpZWxkLCBcIiBjYW5ub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIHRhZ1wiKSk7XG4gICAgcmV0dXJuIGRlY29kZWQudGFnICE9PSBmYWxzZVxuICAgICAgICA/IChfYSA9IHt9LCBfYVtmaWVsZF0gPSBkZWNvZGVkLmNsYXNzaWNBZGRyZXNzLCBfYVt0YWdOYW1lXSA9IGRlY29kZWQudGFnLCBfYSkgOiAoX2IgPSB7fSwgX2JbZmllbGRdID0gZGVjb2RlZC5jbGFzc2ljQWRkcmVzcywgX2IpO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHR3byBvYmplY3RzIGRvbid0IGJvdGggaGF2ZSB0aGUgc2FtZSB0YWcgZmllbGRzXG4gKlxuICogQHBhcmFtIG9iajEgRmlyc3Qgb2JqZWN0IHRvIGNoZWNrIGZvciB0YWdzXG4gKiBAcGFyYW0gb2JqMiBTZWNvbmQgb2JqZWN0IHRvIGNoZWNrIGZvciB0YWdzXG4gKiBAdGhyb3dzIFdoZW4gYm90aCBvYmplY3RzIGhhdmUgU291cmNlVGFnIG9yIERlc3RpbmF0aW9uVGFnXG4gKi9cbmZ1bmN0aW9uIGNoZWNrRm9yRHVwbGljYXRlVGFncyhvYmoxLCBvYmoyKSB7XG4gICAgaWYgKCEob2JqMVtTT1VSQ0VfVEFHXSA9PT0gdW5kZWZpbmVkIHx8IG9iajJbU09VUkNFX1RBR10gPT09IHVuZGVmaW5lZCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgQWNjb3VudCBYLUFkZHJlc3MgYW5kIFNvdXJjZVRhZycpO1xuICAgIGlmICghKG9iajFbREVTVF9UQUddID09PSB1bmRlZmluZWQgfHwgb2JqMltERVNUX1RBR10gPT09IHVuZGVmaW5lZCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgRGVzdGluYXRpb24gWC1BZGRyZXNzIGFuZCBEZXN0aW5hdGlvblRhZycpO1xufVxuLyoqXG4gKiBDbGFzcyBmb3IgU2VyaWFsaXppbmcvRGVzZXJpYWxpemluZyBvYmplY3RzXG4gKi9cbnZhciBTVE9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU1RPYmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU1RPYmplY3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgU1RPYmplY3QgZnJvbSBhIEJpbmFyeVBhcnNlclxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcnNlciBCaW5hcnlQYXJzZXIgdG8gcmVhZCBTVE9iamVjdCBmcm9tXG4gICAgICogQHJldHVybnMgQSBTVE9iamVjdCBvYmplY3RcbiAgICAgKi9cbiAgICBTVE9iamVjdC5mcm9tUGFyc2VyID0gZnVuY3Rpb24gKHBhcnNlcikge1xuICAgICAgICB2YXIgbGlzdCA9IG5ldyBiaW5hcnlfc2VyaWFsaXplcl8xLkJ5dGVzTGlzdCgpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgYmluYXJ5X3NlcmlhbGl6ZXJfMS5CaW5hcnlTZXJpYWxpemVyKGxpc3QpO1xuICAgICAgICB3aGlsZSAoIXBhcnNlci5lbmQoKSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gcGFyc2VyLnJlYWRGaWVsZCgpO1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IE9CSkVDVF9FTkRfTUFSS0VSKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXNzb2NpYXRlZFZhbHVlID0gcGFyc2VyLnJlYWRGaWVsZFZhbHVlKGZpZWxkKTtcbiAgICAgICAgICAgIGJ5dGVzLndyaXRlRmllbGRBbmRWYWx1ZShmaWVsZCwgYXNzb2NpYXRlZFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChmaWVsZC50eXBlLm5hbWUgPT09IFNUX09CSkVDVCkge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1dChPQkpFQ1RfRU5EX01BUktFUl9CWVRFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNUT2JqZWN0KGxpc3QudG9CeXRlcygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFNUT2JqZWN0IGZyb20gYSBKU09OIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEFuIG9iamVjdCB0byBpbmNsdWRlXG4gICAgICogQHBhcmFtIGZpbHRlciBvcHRpb25hbCwgZGVub3RlIHdoaWNoIGZpZWxkIHRvIGluY2x1ZGUgaW4gc2VyaWFsaXplZCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyBhIFNUT2JqZWN0IG9iamVjdFxuICAgICAqL1xuICAgIFNUT2JqZWN0LmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGZpbHRlcikge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTVE9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ID0gbmV3IGJpbmFyeV9zZXJpYWxpemVyXzEuQnl0ZXNMaXN0KCk7XG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBiaW5hcnlfc2VyaWFsaXplcl8xLkJpbmFyeVNlcmlhbGl6ZXIobGlzdCk7XG4gICAgICAgIHZhciBpc1VubE1vZGlmeSA9IGZhbHNlO1xuICAgICAgICB2YXIgeEFkZHJlc3NEZWNvZGVkID0gT2JqZWN0LmVudHJpZXModmFsdWUpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfYSkge1xuICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgdmFyIGtleSA9IF9hWzBdLCB2YWwgPSBfYVsxXTtcbiAgICAgICAgICAgIHZhciBoYW5kbGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiAoMCwgcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5pc1ZhbGlkWEFkZHJlc3MpKHZhbC50b1N0cmluZygpKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSBoYW5kbGVYQWRkcmVzcyhrZXksIHZhbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBjaGVja0ZvckR1cGxpY2F0ZVRhZ3MoaGFuZGxlZCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCBoYW5kbGVkICE9PSBudWxsICYmIGhhbmRsZWQgIT09IHZvaWQgMCA/IGhhbmRsZWQgOiAoX2IgPSB7fSwgX2Jba2V5XSA9IHZhbCwgX2IpKTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB2YXIgc29ydGVkID0gT2JqZWN0LmtleXMoeEFkZHJlc3NEZWNvZGVkKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZikgeyByZXR1cm4gZW51bXNfMS5GaWVsZFtmXTsgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICB4QWRkcmVzc0RlY29kZWRbZi5uYW1lXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgZi5pc1NlcmlhbGl6ZWQ7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEub3JkaW5hbCAtIGIub3JkaW5hbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmaWx0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc29ydGVkID0gc29ydGVkLmZpbHRlcihmaWx0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHNvcnRlZC5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICAgICAgdmFyIGFzc29jaWF0ZWRWYWx1ZSA9IGZpZWxkLmFzc29jaWF0ZWRUeXBlLmZyb20oeEFkZHJlc3NEZWNvZGVkW2ZpZWxkLm5hbWVdKTtcbiAgICAgICAgICAgIGlmIChhc3NvY2lhdGVkVmFsdWUubmFtZSA9PT0gJ1VOTE1vZGlmeScpIHtcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQgd2hlbiB0aGUgVHJhbnNhY3Rpb25UeXBlIGZpZWxkIGhhcyBhIHZhbHVlIG9mICdVTkxNb2RpZnknXG4gICAgICAgICAgICAgICAgaXNVbmxNb2RpZnkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHJ1ZSB3aGVuIGluIHRoZSBVTkxNb2RpZnkgcHNldWRvdHJhbnNhY3Rpb24gKGFmdGVyIHRoZSB0cmFuc2FjdGlvbiB0eXBlIGhhcyBiZWVuIHByb2Nlc3NlZCkgYW5kIHdvcmtpbmcgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIEFjY291bnQgZmllbGRcbiAgICAgICAgICAgIC8vIFRoZSBBY2NvdW50IGZpZWxkIG11c3Qgbm90IGJlIGEgcGFydCBvZiB0aGUgVU5MTW9kaWZ5IHBzZXVkb3RyYW5zYWN0aW9uIGVuY29kaW5nLCBkdWUgdG8gYSBidWcgaW4gcmlwcGxlZFxuICAgICAgICAgICAgdmFyIGlzVW5sTW9kaWZ5V29ya2Fyb3VuZCA9IGZpZWxkLm5hbWUgPT0gJ0FjY291bnQnICYmIGlzVW5sTW9kaWZ5O1xuICAgICAgICAgICAgYnl0ZXMud3JpdGVGaWVsZEFuZFZhbHVlKGZpZWxkLCBhc3NvY2lhdGVkVmFsdWUsIGlzVW5sTW9kaWZ5V29ya2Fyb3VuZCk7XG4gICAgICAgICAgICBpZiAoZmllbGQudHlwZS5uYW1lID09PSBTVF9PQkpFQ1QpIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXQoT0JKRUNUX0VORF9NQVJLRVJfQllURSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFNUT2JqZWN0KGxpc3QudG9CeXRlcygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgSlNPTiBpbnRlcnByZXRhdGlvbiBvZiB0aGlzLmJ5dGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIEpTT04gb2JqZWN0XG4gICAgICovXG4gICAgU1RPYmplY3QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9iamVjdFBhcnNlciA9IG5ldyBiaW5hcnlfcGFyc2VyXzEuQmluYXJ5UGFyc2VyKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgICAgIHZhciBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgICB3aGlsZSAoIW9iamVjdFBhcnNlci5lbmQoKSkge1xuICAgICAgICAgICAgdmFyIGZpZWxkID0gb2JqZWN0UGFyc2VyLnJlYWRGaWVsZCgpO1xuICAgICAgICAgICAgaWYgKGZpZWxkLm5hbWUgPT09IE9CSkVDVF9FTkRfTUFSS0VSKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY2N1bXVsYXRvcltmaWVsZC5uYW1lXSA9IG9iamVjdFBhcnNlci5yZWFkRmllbGRWYWx1ZShmaWVsZCkudG9KU09OKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH07XG4gICAgcmV0dXJuIFNUT2JqZWN0O1xufShzZXJpYWxpemVkX3R5cGVfMS5TZXJpYWxpemVkVHlwZSkpO1xuZXhwb3J0cy5TVE9iamVjdCA9IFNUT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Qtb2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVUludDE2ID0gdm9pZCAwO1xudmFyIHVpbnRfMSA9IHJlcXVpcmUoXCIuL3VpbnRcIik7XG52YXIgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyL1wiKTtcbi8qKlxuICogRGVyaXZlZCBVSW50IGNsYXNzIGZvciBzZXJpYWxpemluZy9kZXNlcmlhbGl6aW5nIDE2IGJpdCBVSW50XG4gKi9cbnZhciBVSW50MTYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVJbnQxNiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVSW50MTYoYnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGJ5dGVzICE9PSBudWxsICYmIGJ5dGVzICE9PSB2b2lkIDAgPyBieXRlcyA6IFVJbnQxNi5kZWZhdWx0VUludDE2LmJ5dGVzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBVSW50MTYuZnJvbVBhcnNlciA9IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVSW50MTYocGFyc2VyLnJlYWQoVUludDE2LndpZHRoKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYSBVSW50MTYgb2JqZWN0IGZyb20gYSBudW1iZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWwgVUludDE2IG9iamVjdCBvciBudW1iZXJcbiAgICAgKi9cbiAgICBVSW50MTYuZnJvbSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFVJbnQxNikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBidWZmZXJfMS5CdWZmZXIuYWxsb2MoVUludDE2LndpZHRoKTtcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKHZhbCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVJbnQxNihidWYpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuIG5vdCBjb25zdHJ1Y3QgVUludDE2IHdpdGggZ2l2ZW4gdmFsdWUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdmFsdWUgb2YgYSBVSW50MTYgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgbnVtYmVyIHJlcHJlc2VudGVkIGJ5IHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICBVSW50MTYucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLnJlYWRVSW50MTZCRSgwKTtcbiAgICB9O1xuICAgIFVJbnQxNi53aWR0aCA9IDE2IC8gODsgLy8gMlxuICAgIFVJbnQxNi5kZWZhdWx0VUludDE2ID0gbmV3IFVJbnQxNihidWZmZXJfMS5CdWZmZXIuYWxsb2MoVUludDE2LndpZHRoKSk7XG4gICAgcmV0dXJuIFVJbnQxNjtcbn0odWludF8xLlVJbnQpKTtcbmV4cG9ydHMuVUludDE2ID0gVUludDE2O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWludC0xNi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVJbnQzMiA9IHZvaWQgMDtcbnZhciB1aW50XzEgPSByZXF1aXJlKFwiLi91aW50XCIpO1xudmFyIGJ1ZmZlcl8xID0gcmVxdWlyZShcImJ1ZmZlci9cIik7XG4vKipcbiAqIERlcml2ZWQgVUludCBjbGFzcyBmb3Igc2VyaWFsaXppbmcvZGVzZXJpYWxpemluZyAzMiBiaXQgVUludFxuICovXG52YXIgVUludDMyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVSW50MzIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVUludDMyKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBieXRlcyAhPT0gbnVsbCAmJiBieXRlcyAhPT0gdm9pZCAwID8gYnl0ZXMgOiBVSW50MzIuZGVmYXVsdFVJbnQzMi5ieXRlcykgfHwgdGhpcztcbiAgICB9XG4gICAgVUludDMyLmZyb21QYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVUludDMyKHBhcnNlci5yZWFkKFVJbnQzMi53aWR0aCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgVUludDMyIG9iamVjdCBmcm9tIGEgbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsIFVJbnQzMiBvYmplY3Qgb3IgbnVtYmVyXG4gICAgICovXG4gICAgVUludDMyLmZyb20gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBVSW50MzIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhVSW50MzIud2lkdGgpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBudW0gPSBOdW1iZXIucGFyc2VJbnQodmFsKTtcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQzMkJFKG51bSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVJbnQzMihidWYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYnVmLndyaXRlVUludDMyQkUodmFsLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVUludDMyKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IFVJbnQzMiBmcm9tIGdpdmVuIHZhbHVlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHZhbHVlIG9mIGEgVUludDMyIG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIG51bWJlciByZXByZXNlbnRlZCBieSB0aGlzLmJ5dGVzXG4gICAgICovXG4gICAgVUludDMyLnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5yZWFkVUludDMyQkUoMCk7XG4gICAgfTtcbiAgICBVSW50MzIud2lkdGggPSAzMiAvIDg7IC8vIDRcbiAgICBVSW50MzIuZGVmYXVsdFVJbnQzMiA9IG5ldyBVSW50MzIoYnVmZmVyXzEuQnVmZmVyLmFsbG9jKFVJbnQzMi53aWR0aCkpO1xuICAgIHJldHVybiBVSW50MzI7XG59KHVpbnRfMS5VSW50KSk7XG5leHBvcnRzLlVJbnQzMiA9IFVJbnQzMjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpbnQtMzIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5VSW50NjQgPSB2b2lkIDA7XG52YXIgdWludF8xID0gcmVxdWlyZShcIi4vdWludFwiKTtcbnZhciBiaWdJbnQgPSByZXF1aXJlKFwiYmlnLWludGVnZXJcIik7XG52YXIgYmlnX2ludGVnZXJfMSA9IHJlcXVpcmUoXCJiaWctaW50ZWdlclwiKTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xudmFyIEhFWF9SRUdFWCA9IC9eW2EtZkEtRjAtOV17MSwxNn0kLztcbnZhciBtYXNrID0gYmlnSW50KDB4MDAwMDAwMDBmZmZmZmZmZik7XG4vKipcbiAqIERlcml2ZWQgVUludCBjbGFzcyBmb3Igc2VyaWFsaXppbmcvZGVzZXJpYWxpemluZyA2NCBiaXQgVUludFxuICovXG52YXIgVUludDY0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVSW50NjQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVUludDY0KGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBieXRlcyAhPT0gbnVsbCAmJiBieXRlcyAhPT0gdm9pZCAwID8gYnl0ZXMgOiBVSW50NjQuZGVmYXVsdFVJbnQ2NC5ieXRlcykgfHwgdGhpcztcbiAgICB9XG4gICAgVUludDY0LmZyb21QYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVUludDY0KHBhcnNlci5yZWFkKFVJbnQ2NC53aWR0aCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgVUludDY0IG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbCBBIFVJbnQ2NCwgaGV4LXN0cmluZywgYmlnSW50LCBvciBudW1iZXJcbiAgICAgKiBAcmV0dXJucyBBIFVJbnQ2NCBvYmplY3RcbiAgICAgKi9cbiAgICBVSW50NjQuZnJvbSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFVJbnQ2NCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKFVJbnQ2NC53aWR0aCk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIG11c3QgYmUgYW4gdW5zaWduZWQgaW50ZWdlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG51bWJlciA9IGJpZ0ludCh2YWwpO1xuICAgICAgICAgICAgdmFyIGludEJ1ZiA9IFtidWZmZXJfMS5CdWZmZXIuYWxsb2MoNCksIGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KV07XG4gICAgICAgICAgICBpbnRCdWZbMF0ud3JpdGVVSW50MzJCRShOdW1iZXIobnVtYmVyLnNoaWZ0UmlnaHQoMzIpKSwgMCk7XG4gICAgICAgICAgICBpbnRCdWZbMV0ud3JpdGVVSW50MzJCRShOdW1iZXIobnVtYmVyLmFuZChtYXNrKSksIDApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVSW50NjQoYnVmZmVyXzEuQnVmZmVyLmNvbmNhdChpbnRCdWYpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICghSEVYX1JFR0VYLnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdCh2YWwsIFwiIGlzIG5vdCBhIHZhbGlkIGhleC1zdHJpbmdcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0ckJ1ZiA9IHZhbC5wYWRTdGFydCgxNiwgJzAnKTtcbiAgICAgICAgICAgIGJ1ZiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHN0ckJ1ZiwgJ2hleCcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVSW50NjQoYnVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIGJpZ19pbnRlZ2VyXzEuaXNJbnN0YW5jZSkodmFsKSkge1xuICAgICAgICAgICAgdmFyIGludEJ1ZiA9IFtidWZmZXJfMS5CdWZmZXIuYWxsb2MoNCksIGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyg0KV07XG4gICAgICAgICAgICBpbnRCdWZbMF0ud3JpdGVVSW50MzJCRShOdW1iZXIodmFsLnNoaWZ0UmlnaHQoYmlnSW50KDMyKSkpLCAwKTtcbiAgICAgICAgICAgIGludEJ1ZlsxXS53cml0ZVVJbnQzMkJFKE51bWJlcih2YWwuYW5kKG1hc2spKSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVJbnQ2NChidWZmZXJfMS5CdWZmZXIuY29uY2F0KGludEJ1ZikpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBVSW50NjQgZnJvbSBnaXZlbiB2YWx1ZScpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBVSW50NjQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhIGhleC1zdHJpbmdcbiAgICAgKi9cbiAgICBVSW50NjQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMudG9TdHJpbmcoJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIHRoZSBVSW50NjRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBudW1iZXIgcmVwcmVzZW50ZWQgYnV5IHRoaXMuYnl0ZXNcbiAgICAgKi9cbiAgICBVSW50NjQucHJvdG90eXBlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtc2IgPSBiaWdJbnQodGhpcy5ieXRlcy5zbGljZSgwLCA0KS5yZWFkVUludDMyQkUoMCkpO1xuICAgICAgICB2YXIgbHNiID0gYmlnSW50KHRoaXMuYnl0ZXMuc2xpY2UoNCkucmVhZFVJbnQzMkJFKDApKTtcbiAgICAgICAgcmV0dXJuIG1zYi5zaGlmdExlZnQoYmlnSW50KDMyKSkub3IobHNiKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYnl0ZXMgcmVwcmVzZW50YXRpb24gb2YgdGhlIFVJbnQ2NCBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIDggYnl0ZXMgcmVwcmVzZW50aW5nIHRoZSBVSW50NjRcbiAgICAgKi9cbiAgICBVSW50NjQucHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzO1xuICAgIH07XG4gICAgVUludDY0LndpZHRoID0gNjQgLyA4OyAvLyA4XG4gICAgVUludDY0LmRlZmF1bHRVSW50NjQgPSBuZXcgVUludDY0KGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhVSW50NjQud2lkdGgpKTtcbiAgICByZXR1cm4gVUludDY0O1xufSh1aW50XzEuVUludCkpO1xuZXhwb3J0cy5VSW50NjQgPSBVSW50NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11aW50LTY0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVUludDggPSB2b2lkIDA7XG52YXIgdWludF8xID0gcmVxdWlyZShcIi4vdWludFwiKTtcbnZhciBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXIvXCIpO1xuLyoqXG4gKiBEZXJpdmVkIFVJbnQgY2xhc3MgZm9yIHNlcmlhbGl6aW5nL2Rlc2VyaWFsaXppbmcgOCBiaXQgVUludFxuICovXG52YXIgVUludDggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVJbnQ4LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVJbnQ4KGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBieXRlcyAhPT0gbnVsbCAmJiBieXRlcyAhPT0gdm9pZCAwID8gYnl0ZXMgOiBVSW50OC5kZWZhdWx0VUludDguYnl0ZXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFVJbnQ4LmZyb21QYXJzZXIgPSBmdW5jdGlvbiAocGFyc2VyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVUludDgocGFyc2VyLnJlYWQoVUludDgud2lkdGgpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFVJbnQ4IG9iamVjdCBmcm9tIGEgbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsIFVJbnQ4IG9iamVjdCBvciBudW1iZXJcbiAgICAgKi9cbiAgICBVSW50OC5mcm9tID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgVUludDgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YXIgYnVmID0gYnVmZmVyXzEuQnVmZmVyLmFsbG9jKFVJbnQ4LndpZHRoKTtcbiAgICAgICAgICAgIGJ1Zi53cml0ZVVJbnQ4KHZhbCwgMCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVJbnQ4KGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29uc3RydWN0IFVJbnQ4IGZyb20gZ2l2ZW4gdmFsdWUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGdldCB0aGUgdmFsdWUgb2YgYSBVSW50OCBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBudW1iZXIgcmVwcmVzZW50ZWQgYnkgdGhpcy5ieXRlc1xuICAgICAqL1xuICAgIFVJbnQ4LnByb3RvdHlwZS52YWx1ZU9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5yZWFkVUludDgoMCk7XG4gICAgfTtcbiAgICBVSW50OC53aWR0aCA9IDggLyA4OyAvLyAxXG4gICAgVUludDguZGVmYXVsdFVJbnQ4ID0gbmV3IFVJbnQ4KGJ1ZmZlcl8xLkJ1ZmZlci5hbGxvYyhVSW50OC53aWR0aCkpO1xuICAgIHJldHVybiBVSW50ODtcbn0odWludF8xLlVJbnQpKTtcbmV4cG9ydHMuVUludDggPSBVSW50ODtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVpbnQtOC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlVJbnQgPSB2b2lkIDA7XG52YXIgc2VyaWFsaXplZF90eXBlXzEgPSByZXF1aXJlKFwiLi9zZXJpYWxpemVkLXR5cGVcIik7XG4vKipcbiAqIENvbXBhcmUgbnVtYmVycyBhbmQgYmlnSW50cyBuMSBhbmQgbjJcbiAqXG4gKiBAcGFyYW0gbjEgRmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmVcbiAqIEBwYXJhbSBuMiBTZWNvbmQgb2JqZWN0IHRvIGNvbXBhcmVcbiAqIEByZXR1cm5zIC0xLCAwLCBvciAxLCBkZXBlbmRpbmcgb24gaG93IHRoZSB0d28gb2JqZWN0cyBjb21wYXJlXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUobjEsIG4yKSB7XG4gICAgcmV0dXJuIG4xIDwgbjIgPyAtMSA6IG4xID09IG4yID8gMCA6IDE7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIHNlcmlhbGl6aW5nIGFuZCBkZXNlcmlhbGl6aW5nIHVuc2lnbmVkIGludGVnZXJzLlxuICovXG52YXIgVUludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVUludCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVSW50KGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBieXRlcykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcmxvYWQgb2YgY29tcGFyZVRvIGZvciBDb21wYXJhYmxlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXIgb3RoZXIgVUludCB0byBjb21wYXJlIHRoaXMgdG9cbiAgICAgKiBAcmV0dXJucyAtMSwgMCwgb3IgMSBkZXBlbmRpbmcgb24gaG93IHRoZSBvYmplY3RzIHJlbGF0ZSB0byBlYWNoIG90aGVyXG4gICAgICovXG4gICAgVUludC5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBjb21wYXJlKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIFVJbnQgb2JqZWN0IHRvIEpTT05cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIG51bWJlciBvciBzdHJpbmcgcmVwcmVzZW50ZWQgYnkgdGhpcy5ieXRlc1xuICAgICAqL1xuICAgIFVJbnQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgPyB2YWwgOiB2YWwudG9TdHJpbmcoKTtcbiAgICB9O1xuICAgIHJldHVybiBVSW50O1xufShzZXJpYWxpemVkX3R5cGVfMS5Db21wYXJhYmxlKSk7XG5leHBvcnRzLlVJbnQgPSBVSW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWludC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlZlY3RvcjI1NiA9IHZvaWQgMDtcbnZhciBzZXJpYWxpemVkX3R5cGVfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbGl6ZWQtdHlwZVwiKTtcbnZhciBoYXNoXzI1Nl8xID0gcmVxdWlyZShcIi4vaGFzaC0yNTZcIik7XG52YXIgYmluYXJ5X3NlcmlhbGl6ZXJfMSA9IHJlcXVpcmUoXCIuLi9zZXJkZXMvYmluYXJ5LXNlcmlhbGl6ZXJcIik7XG4vKipcbiAqIFR5cGVHdWFyZCBmb3IgQXJyYXk8c3RyaW5nPlxuICovXG5mdW5jdGlvbiBpc1N0cmluZ3MoYXJnKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSAmJiAoYXJnLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgYXJnWzBdID09PSAnc3RyaW5nJyk7XG59XG4vKipcbiAqIENsYXNzIGZvciBzZXJpYWxpemluZyBhbmQgZGVzZXJpYWxpemluZyB2ZWN0b3JzIG9mIEhhc2gyNTZcbiAqL1xudmFyIFZlY3RvcjI1NiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmVjdG9yMjU2LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZlY3RvcjI1NihieXRlcykge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgYnl0ZXMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFZlY3RvcjI1NiBmcm9tIGEgQmluYXJ5UGFyc2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyc2VyIEJpbmFyeVBhcnNlciB0b1xuICAgICAqIEBwYXJhbSBoaW50IGxlbmd0aCBvZiB0aGUgdmVjdG9yLCBpbiBieXRlcywgb3B0aW9uYWxcbiAgICAgKiBAcmV0dXJucyBhIFZlY3RvcjI1NiBvYmplY3RcbiAgICAgKi9cbiAgICBWZWN0b3IyNTYuZnJvbVBhcnNlciA9IGZ1bmN0aW9uIChwYXJzZXIsIGhpbnQpIHtcbiAgICAgICAgdmFyIGJ5dGVzTGlzdCA9IG5ldyBiaW5hcnlfc2VyaWFsaXplcl8xLkJ5dGVzTGlzdCgpO1xuICAgICAgICB2YXIgYnl0ZXMgPSBoaW50ICE9PSBudWxsICYmIGhpbnQgIT09IHZvaWQgMCA/IGhpbnQgOiBwYXJzZXIuc2l6ZSgpO1xuICAgICAgICB2YXIgaGFzaGVzID0gYnl0ZXMgLyAzMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoZXM7IGkrKykge1xuICAgICAgICAgICAgaGFzaF8yNTZfMS5IYXNoMjU2LmZyb21QYXJzZXIocGFyc2VyKS50b0J5dGVzU2luayhieXRlc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yMjU2KGJ5dGVzTGlzdC50b0J5dGVzKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgVmVjdG9yMjU2IG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIGhhc2hlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEEgVmVjdG9yMjU2IG9iamVjdCBvciBhcnJheSBvZiBoZXgtc3RyaW5ncyByZXByZXNlbnRpbmcgSGFzaDI1NidzXG4gICAgICogQHJldHVybnMgYSBWZWN0b3IyNTYgb2JqZWN0XG4gICAgICovXG4gICAgVmVjdG9yMjU2LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVmVjdG9yMjU2KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU3RyaW5ncyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBieXRlc0xpc3RfMSA9IG5ldyBiaW5hcnlfc2VyaWFsaXplcl8xLkJ5dGVzTGlzdCgpO1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgICAgICAgIGhhc2hfMjU2XzEuSGFzaDI1Ni5mcm9tKGhhc2gpLnRvQnl0ZXNTaW5rKGJ5dGVzTGlzdF8xKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyNTYoYnl0ZXNMaXN0XzEudG9CeXRlcygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgVmVjdG9yMjU2IGZyb20gZ2l2ZW4gdmFsdWUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBBcnJheSBvZiBoZXgtc3RyaW5ncyByZXByZXNlbnRlZCBieSB0aGlzLmJ5dGVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBBcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgSGFzaDI1NiBvYmplY3RzXG4gICAgICovXG4gICAgVmVjdG9yMjU2LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ5dGVzLmJ5dGVMZW5ndGggJSAzMiAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGVzIGZvciBWZWN0b3IyNTYnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ieXRlcy5ieXRlTGVuZ3RoOyBpICs9IDMyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmJ5dGVzXG4gICAgICAgICAgICAgICAgLnNsaWNlKGksIGkgKyAzMilcbiAgICAgICAgICAgICAgICAudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgICAgICAgICAgLnRvVXBwZXJDYXNlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gVmVjdG9yMjU2O1xufShzZXJpYWxpemVkX3R5cGVfMS5TZXJpYWxpemVkVHlwZSkpO1xuZXhwb3J0cy5WZWN0b3IyNTYgPSBWZWN0b3IyNTY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZWN0b3ItMjU2LmpzLm1hcCIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpXG4gICAgPyBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG52YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICB2YXIgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICB2YXIgaTE2ID0gaSAqIDE2XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgLS1cbiAqIGxvdHMgb2YgYml0d2lzZSBvcGVyYXRvcnMgbmVjZXNzYXJ5IGZvciB0aGlzICovXG5jb25zdCBoYXNoanMgPSByZXF1aXJlKFwiaGFzaC5qc1wiKTtcbmNvbnN0IEJpZ051bSA9IHJlcXVpcmUoXCJibi5qc1wiKTtcbmNsYXNzIFNoYTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaGFzaCA9IGhhc2hqcy5zaGE1MTIoKTtcbiAgICB9XG4gICAgYWRkKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuaGFzaC51cGRhdGUoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkVTMyKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKFtcbiAgICAgICAgICAgIChpID4+PiAyNCkgJiAweGZmLFxuICAgICAgICAgICAgKGkgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICAoaSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgaSAmIDB4ZmYsXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhc2guZGlnZXN0KCk7XG4gICAgfVxuICAgIGZpcnN0MjU2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKS5zbGljZSgwLCAzMik7XG4gICAgfVxuICAgIGZpcnN0MjU2Qk4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtKHRoaXMuZmlyc3QyNTYoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2hhNTEyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2hhNTEyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZShcImFzc2VydFwiKTtcbmNvbnN0IGJyb3JhbmQgPSByZXF1aXJlKFwiYnJvcmFuZFwiKTtcbmNvbnN0IGhhc2hqcyA9IHJlcXVpcmUoXCJoYXNoLmpzXCIpO1xuY29uc3QgZWxsaXB0aWMgPSByZXF1aXJlKFwiZWxsaXB0aWNcIik7XG5jb25zdCBhZGRyZXNzQ29kZWMgPSByZXF1aXJlKFwicmlwcGxlLWFkZHJlc3MtY29kZWNcIik7XG5jb25zdCBzZWNwMjU2azFfMSA9IHJlcXVpcmUoXCIuL3NlY3AyNTZrMVwiKTtcbmNvbnN0IHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBFZDI1NTE5ID0gZWxsaXB0aWMuZWRkc2EoJ2VkMjU1MTknKTtcbmNvbnN0IFNlY3AyNTZrMSA9IGVsbGlwdGljLmVjKCdzZWNwMjU2azEnKTtcbmNvbnN0IHsgaGV4VG9CeXRlcyB9ID0gdXRpbHM7XG5jb25zdCB7IGJ5dGVzVG9IZXggfSA9IHV0aWxzO1xuZnVuY3Rpb24gZ2VuZXJhdGVTZWVkKG9wdGlvbnMgPSB7fSkge1xuICAgIGFzc2VydC5vayghb3B0aW9ucy5lbnRyb3B5IHx8IG9wdGlvbnMuZW50cm9weS5sZW5ndGggPj0gMTYsICdlbnRyb3B5IHRvbyBzaG9ydCcpO1xuICAgIGNvbnN0IGVudHJvcHkgPSBvcHRpb25zLmVudHJvcHkgPyBvcHRpb25zLmVudHJvcHkuc2xpY2UoMCwgMTYpIDogYnJvcmFuZCgxNik7XG4gICAgY29uc3QgdHlwZSA9IG9wdGlvbnMuYWxnb3JpdGhtID09PSAnZWQyNTUxOScgPyAnZWQyNTUxOScgOiAnc2VjcDI1NmsxJztcbiAgICByZXR1cm4gYWRkcmVzc0NvZGVjLmVuY29kZVNlZWQoQnVmZmVyLmZyb20oZW50cm9weSksIHR5cGUpO1xufVxuZnVuY3Rpb24gaGFzaChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIGhhc2hqcy5zaGE1MTIoKS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCkuc2xpY2UoMCwgMzIpO1xufVxuY29uc3Qgc2VjcDI1NmsxID0ge1xuICAgIGRlcml2ZUtleXBhaXIoZW50cm9weSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSAnMDAnO1xuICAgICAgICBjb25zdCBwcml2YXRlS2V5ID0gcHJlZml4ICsgKDAsIHNlY3AyNTZrMV8xLmRlcml2ZVByaXZhdGVLZXkpKGVudHJvcHksIG9wdGlvbnMpLnRvU3RyaW5nKDE2LCA2NCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYnl0ZXNUb0hleChTZWNwMjU2azEua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleS5zbGljZSgyKSlcbiAgICAgICAgICAgIC5nZXRQdWJsaWMoKVxuICAgICAgICAgICAgLmVuY29kZUNvbXByZXNzZWQoKSk7XG4gICAgICAgIHJldHVybiB7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9O1xuICAgIH0sXG4gICAgc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5KSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KFNlY3AyNTZrMS5zaWduKGhhc2gobWVzc2FnZSksIGhleFRvQnl0ZXMocHJpdmF0ZUtleSksIHtcbiAgICAgICAgICAgIGNhbm9uaWNhbDogdHJ1ZSxcbiAgICAgICAgfSkudG9ERVIoKSk7XG4gICAgfSxcbiAgICB2ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgICAgICAgcmV0dXJuIFNlY3AyNTZrMS52ZXJpZnkoaGFzaChtZXNzYWdlKSwgc2lnbmF0dXJlLCBoZXhUb0J5dGVzKHB1YmxpY0tleSkpO1xuICAgIH0sXG59O1xuY29uc3QgZWQyNTUxOSA9IHtcbiAgICBkZXJpdmVLZXlwYWlyKGVudHJvcHkpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gJ0VEJztcbiAgICAgICAgY29uc3QgcmF3UHJpdmF0ZUtleSA9IGhhc2goZW50cm9weSk7XG4gICAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSBwcmVmaXggKyBieXRlc1RvSGV4KHJhd1ByaXZhdGVLZXkpO1xuICAgICAgICBjb25zdCBwdWJsaWNLZXkgPSBwcmVmaXggKyBieXRlc1RvSGV4KEVkMjU1MTkua2V5RnJvbVNlY3JldChyYXdQcml2YXRlS2V5KS5wdWJCeXRlcygpKTtcbiAgICAgICAgcmV0dXJuIHsgcHJpdmF0ZUtleSwgcHVibGljS2V5IH07XG4gICAgfSxcbiAgICBzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXkpIHtcbiAgICAgICAgLy8gY2F1dGlvbjogRWQyNTUxOS5zaWduIGludGVycHJldHMgYWxsIHN0cmluZ3MgYXMgaGV4LCBzdHJpcHBpbmdcbiAgICAgICAgLy8gYW55IG5vbi1oZXggY2hhcmFjdGVycyB3aXRob3V0IHdhcm5pbmdcbiAgICAgICAgYXNzZXJ0Lm9rKEFycmF5LmlzQXJyYXkobWVzc2FnZSksICdtZXNzYWdlIG11c3QgYmUgYXJyYXkgb2Ygb2N0ZXRzJyk7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KEVkMjU1MTkuc2lnbihtZXNzYWdlLCBoZXhUb0J5dGVzKHByaXZhdGVLZXkpLnNsaWNlKDEpKS50b0J5dGVzKCkpO1xuICAgIH0sXG4gICAgdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiBFZDI1NTE5LnZlcmlmeShtZXNzYWdlLCBoZXhUb0J5dGVzKHNpZ25hdHVyZSksIGhleFRvQnl0ZXMocHVibGljS2V5KS5zbGljZSgxKSk7XG4gICAgfSxcbn07XG5mdW5jdGlvbiBzZWxlY3QoYWxnb3JpdGhtKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IHsgJ2VjZHNhLXNlY3AyNTZrMSc6IHNlY3AyNTZrMSwgZWQyNTUxOSB9O1xuICAgIHJldHVybiBtZXRob2RzW2FsZ29yaXRobV07XG59XG5mdW5jdGlvbiBkZXJpdmVLZXlwYWlyKHNlZWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gYWRkcmVzc0NvZGVjLmRlY29kZVNlZWQoc2VlZCk7XG4gICAgY29uc3QgYWxnb3JpdGhtID0gZGVjb2RlZC50eXBlID09PSAnZWQyNTUxOScgPyAnZWQyNTUxOScgOiAnZWNkc2Etc2VjcDI1NmsxJztcbiAgICBjb25zdCBtZXRob2QgPSBzZWxlY3QoYWxnb3JpdGhtKTtcbiAgICBjb25zdCBrZXlwYWlyID0gbWV0aG9kLmRlcml2ZUtleXBhaXIoZGVjb2RlZC5ieXRlcywgb3B0aW9ucyk7XG4gICAgY29uc3QgbWVzc2FnZVRvVmVyaWZ5ID0gaGFzaCgnVGhpcyB0ZXN0IG1lc3NhZ2Ugc2hvdWxkIHZlcmlmeS4nKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBtZXRob2Quc2lnbihtZXNzYWdlVG9WZXJpZnksIGtleXBhaXIucHJpdmF0ZUtleSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG1ldGhvZC52ZXJpZnkobWVzc2FnZVRvVmVyaWZ5LCBzaWduYXR1cmUsIGtleXBhaXIucHVibGljS2V5KSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rlcml2ZWQga2V5cGFpciBkaWQgbm90IGdlbmVyYXRlIHZlcmlmaWFibGUgc2lnbmF0dXJlJyk7XG4gICAgfVxuICAgIHJldHVybiBrZXlwYWlyO1xufVxuZnVuY3Rpb24gZ2V0QWxnb3JpdGhtRnJvbUtleShrZXkpIHtcbiAgICBjb25zdCBieXRlcyA9IGhleFRvQnl0ZXMoa2V5KTtcbiAgICByZXR1cm4gYnl0ZXMubGVuZ3RoID09PSAzMyAmJiBieXRlc1swXSA9PT0gMHhlZFxuICAgICAgICA/ICdlZDI1NTE5J1xuICAgICAgICA6ICdlY2RzYS1zZWNwMjU2azEnO1xufVxuZnVuY3Rpb24gc2lnbihtZXNzYWdlSGV4LCBwcml2YXRlS2V5KSB7XG4gICAgY29uc3QgYWxnb3JpdGhtID0gZ2V0QWxnb3JpdGhtRnJvbUtleShwcml2YXRlS2V5KTtcbiAgICByZXR1cm4gc2VsZWN0KGFsZ29yaXRobSkuc2lnbihoZXhUb0J5dGVzKG1lc3NhZ2VIZXgpLCBwcml2YXRlS2V5KTtcbn1cbmZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlSGV4LCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IGFsZ29yaXRobSA9IGdldEFsZ29yaXRobUZyb21LZXkocHVibGljS2V5KTtcbiAgICByZXR1cm4gc2VsZWN0KGFsZ29yaXRobSkudmVyaWZ5KGhleFRvQnl0ZXMobWVzc2FnZUhleCksIHNpZ25hdHVyZSwgcHVibGljS2V5KTtcbn1cbmZ1bmN0aW9uIGRlcml2ZUFkZHJlc3NGcm9tQnl0ZXMocHVibGljS2V5Qnl0ZXMpIHtcbiAgICByZXR1cm4gYWRkcmVzc0NvZGVjLmVuY29kZUFjY291bnRJRCh1dGlscy5jb21wdXRlUHVibGljS2V5SGFzaChwdWJsaWNLZXlCeXRlcykpO1xufVxuZnVuY3Rpb24gZGVyaXZlQWRkcmVzcyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gZGVyaXZlQWRkcmVzc0Zyb21CeXRlcyhCdWZmZXIuZnJvbShoZXhUb0J5dGVzKHB1YmxpY0tleSkpKTtcbn1cbmZ1bmN0aW9uIGRlcml2ZU5vZGVBZGRyZXNzKHB1YmxpY0tleSkge1xuICAgIGNvbnN0IGdlbmVyYXRvckJ5dGVzID0gYWRkcmVzc0NvZGVjLmRlY29kZU5vZGVQdWJsaWMocHVibGljS2V5KTtcbiAgICBjb25zdCBhY2NvdW50UHVibGljQnl0ZXMgPSAoMCwgc2VjcDI1NmsxXzEuYWNjb3VudFB1YmxpY0Zyb21QdWJsaWNHZW5lcmF0b3IpKGdlbmVyYXRvckJ5dGVzKTtcbiAgICByZXR1cm4gZGVyaXZlQWRkcmVzc0Zyb21CeXRlcyhhY2NvdW50UHVibGljQnl0ZXMpO1xufVxuY29uc3QgeyBkZWNvZGVTZWVkIH0gPSBhZGRyZXNzQ29kZWM7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZW5lcmF0ZVNlZWQsXG4gICAgZGVyaXZlS2V5cGFpcixcbiAgICBzaWduLFxuICAgIHZlcmlmeSxcbiAgICBkZXJpdmVBZGRyZXNzLFxuICAgIGRlcml2ZU5vZGVBZGRyZXNzLFxuICAgIGRlY29kZVNlZWQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFjY291bnRQdWJsaWNGcm9tUHVibGljR2VuZXJhdG9yID0gZXhwb3J0cy5kZXJpdmVQcml2YXRlS2V5ID0gdm9pZCAwO1xuY29uc3QgZWxsaXB0aWMgPSByZXF1aXJlKFwiZWxsaXB0aWNcIik7XG5jb25zdCBTaGE1MTJfMSA9IHJlcXVpcmUoXCIuL1NoYTUxMlwiKTtcbmNvbnN0IHNlY3AyNTZrMSA9IGVsbGlwdGljLmVjKCdzZWNwMjU2azEnKTtcbmZ1bmN0aW9uIGRlcml2ZVNjYWxhcihieXRlcywgZGlzY3JpbSkge1xuICAgIGNvbnN0IG9yZGVyID0gc2VjcDI1NmsxLmN1cnZlLm47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMHhmZmZmZmZmZjsgaSsrKSB7XG4gICAgICAgIC8vIFdlIGhhc2ggdGhlIGJ5dGVzIHRvIGZpbmQgYSAyNTYgYml0IG51bWJlciwgbG9vcGluZyB1bnRpbCB3ZSBhcmUgc3VyZSBpdFxuICAgICAgICAvLyBpcyBsZXNzIHRoYW4gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZS5cbiAgICAgICAgY29uc3QgaGFzaGVyID0gbmV3IFNoYTUxMl8xLmRlZmF1bHQoKS5hZGQoYnl0ZXMpO1xuICAgICAgICAvLyBJZiB0aGUgb3B0aW9uYWwgZGlzY3JpbWluYXRvciBpbmRleCB3YXMgcGFzc2VkIGluLCB1cGRhdGUgdGhlIGhhc2guXG4gICAgICAgIGlmIChkaXNjcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhhc2hlci5hZGRVMzIoZGlzY3JpbSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzaGVyLmFkZFUzMihpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gaGFzaGVyLmZpcnN0MjU2Qk4oKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGtleS5jbXBuKDApID4gMCAmJiBrZXkuY21wKG9yZGVyKSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBlcnJvciBpcyBwcmFjdGljYWxseSBpbXBvc3NpYmxlIHRvIHJlYWNoLlxuICAgIC8vIFRoZSBvcmRlciBvZiB0aGUgY3VydmUgZGVzY3JpYmVzIHRoZSAoZmluaXRlKSBhbW91bnQgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljL2Jsb2IvbWFzdGVyL2xpYi9lbGxpcHRpYy9jdXJ2ZXMuanMjTDE4MlxuICAgIC8vIEhvdyBvZnRlbiB3aWxsIGFuIChlc3NlbnRpYWxseSkgcmFuZG9tIG51bWJlciBnZW5lcmF0ZWQgYnkgU2hhNTEyIGJlIGxhcmdlciB0aGFuIHRoYXQ/XG4gICAgLy8gVGhlcmUncyAyXjMyIGNoYW5jZXMgKHRoZSBmb3IgbG9vcCkgdG8gZ2V0IGEgbnVtYmVyIHNtYWxsZXIgdGhhbiB0aGUgb3JkZXIsXG4gICAgLy8gYW5kIGl0J3MgcmFyZSB0aGF0IHlvdSdsbCBldmVuIGdldCBwYXN0IHRoZSBmaXJzdCBsb29wIGl0ZXJhdGlvbi5cbiAgICAvLyBOb3RlIHRoYXQgaW4gVHlwZVNjcmlwdCB3ZSBhY3R1YWxseSBuZWVkIHRoZSB0aHJvdywgb3RoZXJ3aXNlIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgd291bGQgYmUgQk4gfCB1bmRlZmluZWRcbiAgICAvL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGhyb3cgbmV3IEVycm9yKCdpbXBvc3NpYmxlIHVuaWNvcm4gOyknKTtcbn1cbi8qKlxuICogQHBhcmFtIHNlZWQgLSBCeXRlcy5cbiAqIEBwYXJhbSBbb3B0c10gLSBPYmplY3QuXG4gKiBAcGFyYW0gW29wdHMuYWNjb3VudEluZGV4PTBdIC0gVGhlIGFjY291bnQgbnVtYmVyIHRvIGdlbmVyYXRlLlxuICogQHBhcmFtIFtvcHRzLnZhbGlkYXRvcj1mYWxzZV0gLSBHZW5lcmF0ZSByb290IGtleS1wYWlyLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXMgdXNlZCBieSB2YWxpZGF0b3JzLlxuICogQHJldHVybnMge2JuLmpzfSAyNTYgYml0IHNjYWxhciB2YWx1ZS5cbiAqXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZVByaXZhdGVLZXkoc2VlZCwgb3B0cyA9IHt9KSB7XG4gICAgY29uc3Qgcm9vdCA9IG9wdHMudmFsaWRhdG9yO1xuICAgIGNvbnN0IG9yZGVyID0gc2VjcDI1NmsxLmN1cnZlLm47XG4gICAgLy8gVGhpcyBwcml2YXRlIGdlbmVyYXRvciByZXByZXNlbnRzIHRoZSBgcm9vdGAgcHJpdmF0ZSBrZXksIGFuZCBpcyB3aGF0J3NcbiAgICAvLyB1c2VkIGJ5IHZhbGlkYXRvcnMgZm9yIHNpZ25pbmcgd2hlbiBhIGtleXBhaXIgaXMgZ2VuZXJhdGVkIGZyb20gYSBzZWVkLlxuICAgIGNvbnN0IHByaXZhdGVHZW4gPSBkZXJpdmVTY2FsYXIoc2VlZCk7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgICAgLy8gQXMgcmV0dXJuZWQgYnkgdmFsaWRhdGlvbl9jcmVhdGUgZm9yIGEgZ2l2ZW4gc2VlZFxuICAgICAgICByZXR1cm4gcHJpdmF0ZUdlbjtcbiAgICB9XG4gICAgY29uc3QgcHVibGljR2VuID0gc2VjcDI1NmsxLmcubXVsKHByaXZhdGVHZW4pO1xuICAgIC8vIEEgc2VlZCBjYW4gZ2VuZXJhdGUgbWFueSBrZXlwYWlycyBhcyBhIGZ1bmN0aW9uIG9mIHRoZSBzZWVkIGFuZCBhIHVpbnQzMi5cbiAgICAvLyBBbG1vc3QgZXZlcnlvbmUganVzdCB1c2VzIHRoZSBmaXJzdCBhY2NvdW50LCBgMGAuXG4gICAgY29uc3QgYWNjb3VudEluZGV4ID0gb3B0cy5hY2NvdW50SW5kZXggfHwgMDtcbiAgICByZXR1cm4gZGVyaXZlU2NhbGFyKHB1YmxpY0dlbi5lbmNvZGVDb21wcmVzc2VkKCksIGFjY291bnRJbmRleClcbiAgICAgICAgLmFkZChwcml2YXRlR2VuKVxuICAgICAgICAubW9kKG9yZGVyKTtcbn1cbmV4cG9ydHMuZGVyaXZlUHJpdmF0ZUtleSA9IGRlcml2ZVByaXZhdGVLZXk7XG5mdW5jdGlvbiBhY2NvdW50UHVibGljRnJvbVB1YmxpY0dlbmVyYXRvcihwdWJsaWNHZW5CeXRlcykge1xuICAgIGNvbnN0IHJvb3RQdWJQb2ludCA9IHNlY3AyNTZrMS5jdXJ2ZS5kZWNvZGVQb2ludChwdWJsaWNHZW5CeXRlcyk7XG4gICAgY29uc3Qgc2NhbGFyID0gZGVyaXZlU2NhbGFyKHB1YmxpY0dlbkJ5dGVzLCAwKTtcbiAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMS5nLm11bChzY2FsYXIpO1xuICAgIGNvbnN0IG9mZnNldCA9IHJvb3RQdWJQb2ludC5hZGQocG9pbnQpO1xuICAgIHJldHVybiBvZmZzZXQuZW5jb2RlQ29tcHJlc3NlZCgpO1xufVxuZXhwb3J0cy5hY2NvdW50UHVibGljRnJvbVB1YmxpY0dlbmVyYXRvciA9IGFjY291bnRQdWJsaWNGcm9tUHVibGljR2VuZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wdXRlUHVibGljS2V5SGFzaCA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5jb25zdCBoYXNoanMgPSByZXF1aXJlKFwiaGFzaC5qc1wiKTtcbmNvbnN0IEJOID0gcmVxdWlyZShcImJuLmpzXCIpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleChhKSB7XG4gICAgcmV0dXJuIGFcbiAgICAgICAgLm1hcCgoYnl0ZVZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhleCA9IGJ5dGVWYWx1ZS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggPiAxID8gaGV4IDogYDAke2hleH1gO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcnKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGEpIHtcbiAgICBhc3NlcnQub2soYS5sZW5ndGggJSAyID09PSAwKTtcbiAgICByZXR1cm4gbmV3IEJOKGEsIDE2KS50b0FycmF5KG51bGwsIGEubGVuZ3RoIC8gMik7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuZnVuY3Rpb24gY29tcHV0ZVB1YmxpY0tleUhhc2gocHVibGljS2V5Qnl0ZXMpIHtcbiAgICBjb25zdCBoYXNoMjU2ID0gaGFzaGpzLnNoYTI1NigpLnVwZGF0ZShwdWJsaWNLZXlCeXRlcykuZGlnZXN0KCk7XG4gICAgY29uc3QgaGFzaDE2MCA9IGhhc2hqcy5yaXBlbWQxNjAoKS51cGRhdGUoaGFzaDI1NikuZGlnZXN0KCk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhhc2gxNjApO1xufVxuZXhwb3J0cy5jb21wdXRlUHVibGljS2V5SGFzaCA9IGNvbXB1dGVQdWJsaWNLZXlIYXNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBCdWZmZXIgPSB3aW5kb3cuQnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgbnVtYmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQsIGVuZGlhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtudW1iZXIgJiAweDNmZmZmZmZdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleDRCaXRzIChzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgLy8gJzAnIC0gJzknXG4gICAgaWYgKGMgPj0gNDggJiYgYyA8PSA1Nykge1xuICAgICAgcmV0dXJuIGMgLSA0ODtcbiAgICAvLyAnQScgLSAnRidcbiAgICB9IGVsc2UgaWYgKGMgPj0gNjUgJiYgYyA8PSA3MCkge1xuICAgICAgcmV0dXJuIGMgLSA1NTtcbiAgICAvLyAnYScgLSAnZidcbiAgICB9IGVsc2UgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMDIpIHtcbiAgICAgIHJldHVybiBjIC0gODc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ0ludmFsaWQgY2hhcmFjdGVyIGluICcgKyBzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZSAoc3RyaW5nLCBsb3dlckJvdW5kLCBpbmRleCkge1xuICAgIHZhciByID0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggLSAxID49IGxvd2VyQm91bmQpIHtcbiAgICAgIHIgfD0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4IC0gMSkgPDwgNDtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICAvLyAyNC1iaXRzIGNodW5rc1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyBpIC09IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyc2VMZW5ndGggPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICBmb3IgKGkgPSBwYXJzZUxlbmd0aCAlIDIgPT09IDAgPyBzdGFydCArIDEgOiBzdGFydDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBiID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICBiID0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICBiID0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIgPSBjO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGMgPj0gMCAmJiBiIDwgbXVsLCAnSW52YWxpZCBjaGFyYWN0ZXInKTtcbiAgICAgIHIgKz0gYjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgICB0aGlzLndvcmRzID0gWzBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gbW92ZSAoZGVzdCwgc3JjKSB7XG4gICAgZGVzdC53b3JkcyA9IHNyYy53b3JkcztcbiAgICBkZXN0Lmxlbmd0aCA9IHNyYy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHNyYy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHNyYy5yZWQ7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiBfbW92ZSAoZGVzdCkge1xuICAgIG1vdmUoZGVzdCwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5fc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuICAgIC8vIC0wID0gMFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQ2hlY2sgU3ltYm9sLmZvciBiZWNhdXNlIG5vdCBldmVyeXdoZXJlIHdoZXJlIFN5bWJvbCBkZWZpbmVkXG4gIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TeW1ib2wjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBCTi5wcm90b3R5cGVbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBpbnNwZWN0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBpbnNwZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH1cblxuICAvKlxuXG4gIHZhciB6ZXJvcyA9IFtdO1xuICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG4gIHZhciBzID0gJyc7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICAgIHplcm9zW2ldID0gcztcbiAgICBzICs9ICcwJztcbiAgfVxuICBncm91cFNpemVzWzBdID0gMDtcbiAgZ3JvdXBTaXplc1sxXSA9IDA7XG4gIGdyb3VwQmFzZXNbMF0gPSAwO1xuICBncm91cEJhc2VzWzFdID0gMDtcbiAgdmFyIGJhc2UgPSAyIC0gMTtcbiAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICAgIHZhciBncm91cFNpemUgPSAwO1xuICAgIHZhciBncm91cEJhc2UgPSAxO1xuICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICAgIGdyb3VwU2l6ZSArPSAxO1xuICAgIH1cbiAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG4gIH1cblxuICAqL1xuXG4gIHZhciB6ZXJvcyA9IFtcbiAgICAnJyxcbiAgICAnMCcsXG4gICAgJzAwJyxcbiAgICAnMDAwJyxcbiAgICAnMDAwMCcsXG4gICAgJzAwMDAwJyxcbiAgICAnMDAwMDAwJyxcbiAgICAnMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgXTtcblxuICB2YXIgZ3JvdXBTaXplcyA9IFtcbiAgICAwLCAwLFxuICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG4gIF07XG5cbiAgdmFyIGdyb3VwQmFzZXMgPSBbXG4gICAgMCwgMCxcbiAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuICBdO1xuXG4gIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cbiAgICB2YXIgb3V0O1xuICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgb2ZmID0gMDtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG4gICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwO1xuICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgIHZhciByID0gYy5tb2Rybihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNiwgMik7XG4gIH07XG5cbiAgaWYgKEJ1ZmZlcikge1xuICAgIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlIChBcnJheVR5cGUsIHNpemUpIHtcbiAgICBpZiAoQXJyYXlUeXBlLmFsbG9jVW5zYWZlKSB7XG4gICAgICByZXR1cm4gQXJyYXlUeXBlLmFsbG9jVW5zYWZlKHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5VHlwZShzaXplKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHRoaXMuX3N0cmlwKCk7XG5cbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB2YXIgcmVzID0gYWxsb2NhdGUoQXJyYXlUeXBlLCByZXFMZW5ndGgpO1xuICAgIHZhciBwb3N0Zml4ID0gZW5kaWFuID09PSAnbGUnID8gJ0xFJyA6ICdCRSc7XG4gICAgdGhpc1snX3RvQXJyYXlMaWtlJyArIHBvc3RmaXhdKHJlcywgYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3RvQXJyYXlMaWtlTEUgPSBmdW5jdGlvbiBfdG9BcnJheUxpa2VMRSAocmVzLCBieXRlTGVuZ3RoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gKHRoaXMud29yZHNbaV0gPDwgc2hpZnQpIHwgY2Fycnk7XG5cbiAgICAgIHJlc1twb3NpdGlvbisrXSA9IHdvcmQgJiAweGZmO1xuICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDE2KSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGlmdCA9PT0gNikge1xuICAgICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgIHNoaWZ0ICs9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgcmVzW3Bvc2l0aW9uKytdID0gY2Fycnk7XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl90b0FycmF5TGlrZUJFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlQkUgKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBwb3NpdGlvbiA9IHJlcy5sZW5ndGggLSAxO1xuICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnQgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSAodGhpcy53b3Jkc1tpXSA8PCBzaGlmdCkgfCBjYXJyeTtcblxuICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gd29yZCAmIDB4ZmY7XG4gICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiAyNCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3b3JkID4+PiAyNDtcbiAgICAgICAgc2hpZnQgKz0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gY2Fycnk7XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSA+Pj4gd2JpdCkgJiAweDAxO1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgIHIgKz0gYjtcbiAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgYnl0ZXNOZWVkZWQtLTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG4gICAgfVxuXG4gICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cbiAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIC8vIFRlbXBvcmFyeSBkaXNhYmxlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvaXNzdWVzLzIxMVxuICAgIC8vIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICAvLyByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgICByZXR1cm4gYmlnTXVsVG8oc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbiAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgaDtcbiAgICBpZiAoaGludCkge1xuICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgICBoIC09IHM7XG4gICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG4gICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcbiAgICB9XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgIH1cblxuICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPD0gbnVtKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pc3VibihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aG91dCBjaGVja3NcbiAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcbiAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuICAgIC8vIENhcnJ5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcbiAgICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZG4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYXJyeVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgICBpZiAoc2hpZnQgIT09IDApIHtcbiAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcbiAgICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICAgIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB2YXIgcTtcblxuICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgcSA9IG5ldyBCTihudWxsKTtcbiAgICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxLndvcmRzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIGEgPSBkaWZmO1xuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcbiAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAgIC8vICgweDdmZmZmZmYpXG4gICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBxai0tO1xuICAgICAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocSkge1xuICAgICAgcS5fc3RyaXAoKTtcbiAgICB9XG4gICAgYS5fc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZHJuKG51bS53b3Jkc1swXSkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kcm4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgKHIyID09PSAxICYmIGNtcCA9PT0gMCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICAvLyBSb3VuZCB1cFxuICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm1vZHJuID0gZnVuY3Rpb24gbW9kcm4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzTmVnTnVtID8gLWFjYyA6IGFjYztcbiAgfTtcblxuICAvLyBXQVJOSU5HOiBERVBSRUNBVEVEXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kcm4obnVtKTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICAgIGNhcnJ5ID0gdyAlIG51bTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoci5zdHJpcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHIgaXMgYSBCTiB2NCBpbnN0YW5jZVxuICAgICAgICByLnN0cmlwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByIGlzIGEgQk4gdjUgaW5zdGFuY2VcbiAgICAgICAgci5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIG1vdmUoYSwgYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpKTtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiIsIjsoZnVuY3Rpb24gKGdsb2JhbE9iamVjdCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjEuMVxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDIyIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxuICB2YXIgQmlnTnVtYmVyLFxyXG4gICAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gICAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICAgIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICAgIEJBU0UgPSAxZTE0LFxyXG4gICAgTE9HX0JBU0UgPSAxNCxcclxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAvLyBFRElUQUJMRVxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICAgIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICAgIEZPUk1BVCA9IHtcclxuICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAgIC8vIG5vbi1icmVha2luZyBzcGFjZVxyXG4gICAgICAgIHN1ZmZpeDogJydcclxuICAgICAgfSxcclxuXHJcbiAgICAgIC8vIFRoZSBhbHBoYWJldCB1c2VkIGZvciBiYXNlIGNvbnZlcnNpb24uIEl0IG11c3QgYmUgYXQgbGVhc3QgMiBjaGFyYWN0ZXJzIGxvbmcsIHdpdGggbm8gJysnLFxyXG4gICAgICAvLyAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAvLyAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXydcclxuICAgICAgQUxQSEFCRVQgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcclxuICAgICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBCaWdOdW1iZXIgY29uc3RydWN0b3IgYW5kIGV4cG9ydGVkIGZ1bmN0aW9uLlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIHYge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygdi4gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBCaWdOdW1iZXIodiwgYikge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGMsIGNhc2VDaGFuZ2VkLCBlLCBpLCBpc051bSwgbGVuLCBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAvLyBFbmFibGUgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IGBuZXdgLlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgQmlnTnVtYmVyKSkgcmV0dXJuIG5ldyBCaWdOdW1iZXIodiwgYik7XHJcblxyXG4gICAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh2ICYmIHYuX2lzQmlnTnVtYmVyID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgICAgaWYgKCF2LmMgfHwgdi5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgICAgeC5jID0gdi5jLnNsaWNlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSAmJiB2ICogMCA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gVXNlIGAxIC8gbmAgdG8gaGFuZGxlIG1pbnVzIHplcm8gYWxzby5cclxuICAgICAgICAgIHgucyA9IDEgLyB2IDwgMCA/ICh2ID0gLXYsIC0xKSA6IDE7XHJcblxyXG4gICAgICAgICAgLy8gRmFzdCBwYXRoIGZvciBpbnRlZ2Vycywgd2hlcmUgbiA8IDIxNDc0ODM2NDggKDIqKjMxKS5cclxuICAgICAgICAgIGlmICh2ID09PSB+fnYpIHtcclxuICAgICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyk7XHJcblxyXG4gICAgICAgICAgICBpZiAoZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgICAgeC5jID0gW3ZdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgaWYgKCFpc051bWVyaWMudGVzdChzdHIgPSBTdHJpbmcodikpKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0pO1xyXG5cclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlY2ltYWwgcG9pbnQ/XHJcbiAgICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgICAgaWYgKChpID0gc3RyLnNlYXJjaCgvZS9pKSkgPiAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgICAgaWYgKGUgPCAwKSBlID0gaTtcclxuICAgICAgICAgIGUgKz0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLlxyXG4gICAgICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuXHJcbiAgICAgICAgLy8gQWxsb3cgZXhwb25lbnRpYWwgbm90YXRpb24gdG8gYmUgdXNlZCB3aXRoIGJhc2UgMTAgYXJndW1lbnQsIHdoaWxlXHJcbiAgICAgICAgLy8gYWxzbyByb3VuZGluZyB0byBERUNJTUFMX1BMQUNFUyBhcyB3aXRoIG90aGVyIGJhc2VzLlxyXG4gICAgICAgIGlmIChiID09IDEwICYmIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cykge1xyXG4gICAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAgICpcclxuICAgICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICpcclxuICAgICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICAgKlxyXG4gICAgICogRS5nLlxyXG4gICAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICAgKlxyXG4gICAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgdmFyIHAsIHY7XHJcblxyXG4gICAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzYWxsb3cgaWYgbGVzcyB0aGFuIHR3byBjaGFyYWN0ZXJzLFxyXG4gICAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdi5zbGljZSgwLCAxMCkgPT0gJzAxMjM0NTY3ODknO1xyXG4gICAgICAgICAgICAgIEFMUEhBQkVUID0gdjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBpbnZhbGlkOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gT2JqZWN0IGV4cGVjdGVkOiB7dn0nXHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdPYmplY3QgZXhwZWN0ZWQ6ICcgKyBvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBERUNJTUFMX1BMQUNFUzogREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgUk9VTkRJTkdfTU9ERTogUk9VTkRJTkdfTU9ERSxcclxuICAgICAgICBFWFBPTkVOVElBTF9BVDogW1RPX0VYUF9ORUcsIFRPX0VYUF9QT1NdLFxyXG4gICAgICAgIFJBTkdFOiBbTUlOX0VYUCwgTUFYX0VYUF0sXHJcbiAgICAgICAgQ1JZUFRPOiBDUllQVE8sXHJcbiAgICAgICAgTU9EVUxPX01PREU6IE1PRFVMT19NT0RFLFxyXG4gICAgICAgIFBPV19QUkVDSVNJT046IFBPV19QUkVDSVNJT04sXHJcbiAgICAgICAgRk9STUFUOiBGT1JNQVQsXHJcbiAgICAgICAgQUxQSEFCRVQ6IEFMUEhBQkVUXHJcbiAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdiBpcyBhIEJpZ051bWJlciBpbnN0YW5jZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBCaWdOdW1iZXIuREVCVUcgaXMgdHJ1ZSwgdGhyb3cgaWYgYSBCaWdOdW1iZXIgaW5zdGFuY2UgaXMgbm90IHdlbGwtZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqIHYge2FueX1cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gSW52YWxpZCBCaWdOdW1iZXI6IHt2fSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKHYpIHtcclxuICAgICAgaWYgKCF2IHx8IHYuX2lzQmlnTnVtYmVyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICghQmlnTnVtYmVyLkRFQlVHKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciBpLCBuLFxyXG4gICAgICAgIGMgPSB2LmMsXHJcbiAgICAgICAgZSA9IHYuZSxcclxuICAgICAgICBzID0gdi5zO1xyXG5cclxuICAgICAgb3V0OiBpZiAoe30udG9TdHJpbmcuY2FsbChjKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblxyXG4gICAgICAgIGlmICgocyA9PT0gMSB8fCBzID09PSAtMSkgJiYgZSA+PSAtTUFYICYmIGUgPD0gTUFYICYmIGUgPT09IG1hdGhmbG9vcihlKSkge1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBlbGVtZW50IGlzIHplcm8sIHRoZSBCaWdOdW1iZXIgdmFsdWUgbXVzdCBiZSB6ZXJvLlxyXG4gICAgICAgICAgaWYgKGNbMF0gPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGUgPT09IDAgJiYgYy5sZW5ndGggPT09IDEpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgdGhhdCBjWzBdIHNob3VsZCBoYXZlLCBiYXNlZCBvbiB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICAgICAgaWYgKGkgPCAxKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgICAgICAvL2lmIChNYXRoLmNlaWwoTWF0aC5sb2coY1swXSArIDEpIC8gTWF0aC5MTjEwKSA9PSBpKSB7XHJcbiAgICAgICAgICBpZiAoU3RyaW5nKGNbMF0pLmxlbmd0aCA9PSBpKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIG4gPSBjW2ldO1xyXG4gICAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IEJBU0UgfHwgbiAhPT0gbWF0aGZsb29yKG4pKSBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIExhc3QgZWxlbWVudCBjYW5ub3QgYmUgemVybywgdW5sZXNzIGl0IGlzIHRoZSBvbmx5IGVsZW1lbnQuXHJcbiAgICAgICAgICAgIGlmIChuICE9PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS9OYU5cclxuICAgICAgfSBlbHNlIGlmIChjID09PSBudWxsICYmIGUgPT09IG51bGwgJiYgKHMgPT09IG51bGwgfHwgcyA9PT0gMSB8fCBzID09PSAtMSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnSW52YWxpZCBCaWdOdW1iZXI6ICcgKyB2KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1heGltdW0gPSBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmx0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gbWF4T3JNaW4oYXJndW1lbnRzLCBQLmd0KTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICogYW5kIHdpdGggZHAsIG9yIERFQ0lNQUxfUExBQ0VTIGlmIGRwIGlzIG9taXR0ZWQsIGRlY2ltYWwgcGxhY2VzIChvciBsZXNzIGlmIHRyYWlsaW5nXHJcbiAgICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5yYW5kb20gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgcG93Ml81MyA9IDB4MjAwMDAwMDAwMDAwMDA7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgICAvLyBDaGVjayBpZiBNYXRoLnJhbmRvbSgpIHByb2R1Y2VzIG1vcmUgdGhhbiAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXHJcbiAgICAgIC8vIElmIGl0IGRvZXMsIGFzc3VtZSBhdCBsZWFzdCA1MyBiaXRzIGFyZSBwcm9kdWNlZCwgb3RoZXJ3aXNlIGFzc3VtZSBhdCBsZWFzdCAzMCBiaXRzLlxyXG4gICAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgICB2YXIgcmFuZG9tNTNiaXRJbnQgPSAoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpICYgMHgxZmZmZmZcclxuICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0aGZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKTsgfVxyXG4gICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgICAoTWF0aC5yYW5kb20oKSAqIDB4ODAwMDAwIHwgMCk7IH07XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRwKSB7XHJcbiAgICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAgIGlmIChkcCA9PSBudWxsKSBkcCA9IERFQ0lNQUxfUExBQ0VTO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcblxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgIC8vIEJyb3dzZXJzIHN1cHBvcnRpbmcgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5cclxuICAgICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoayAqPSAyKSk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTEwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMFxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMHgyMDAwMCBpcyAyXjIxLlxyXG4gICAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbMF07XHJcbiAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSAyO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDcpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAgaXMgMl4zMiwgMHgxMDAwMDAwIGlzIDJeMjRcclxuICAgICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICB2ID0gKChhW2ldICYgMzEpICogMHgxMDAwMDAwMDAwMDAwKSArIChhW2kgKyAxXSAqIDB4MTAwMDAwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgICAoYVtpICsgNF0gPDwgMTYpICsgKGFbaSArIDVdIDw8IDgpICsgYVtpICsgNl07XHJcblxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgICAgaSArPSA3O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbS5cclxuICAgICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICAgICAgdiA9IHJhbmRvbTUzYml0SW50KCk7XHJcbiAgICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgIGRwICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRyYWlsaW5nIGRpZ2l0cyB0byB6ZXJvcyBhY2NvcmRpbmcgdG8gZHAuXHJcbiAgICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgIGNbaV0gPSBtYXRoZmxvb3IoayAvIHYpICogdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVyby5cclxuICAgICAgICBmb3IgKDsgY1tpXSA9PT0gMDsgYy5wb3AoKSwgaS0tKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGMgPSBbZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGZvciAoZSA9IC0xIDsgY1swXSA9PT0gMDsgYy5zcGxpY2UoMCwgMSksIGUgLT0gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCB2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByYW5kLmUgPSBlO1xyXG4gICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgcmV0dXJuIHJhbmQ7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuc3VtID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgICBzdW0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOykgc3VtID0gc3VtLnBsdXMoYXJnc1tpKytdKTtcclxuICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8vIFBSSVZBVEUgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgICBjb252ZXJ0QmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBkZWNpbWFsID0gJzAxMjM0NTY3ODknO1xyXG5cclxuICAgICAgLypcclxuICAgICAgICogQ29udmVydCBzdHJpbmcgb2YgYmFzZUluIHRvIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYmFzZU91dC5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnMjU1JywgMTAsIDE2KSByZXR1cm5zIFsxNSwgMTVdLlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgICAqL1xyXG4gICAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGFscGhhYmV0KSB7XHJcbiAgICAgICAgdmFyIGosXHJcbiAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICBhcnJMLFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjspIHtcclxuICAgICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgICAgYXJyWzBdICs9IGFscGhhYmV0LmluZGV4T2Yoc3RyLmNoYXJBdChpKyspKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYXJyLmxlbmd0aDsgaisrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PSBudWxsKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgdG9TdHJpbmcsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZSAxMCB0byBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIEJpZ051bWJlciwgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlSW4gdG8gYmFzZSAxMC5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICAgIHZhciBhbHBoYWJldCwgZCwgZSwgaywgciwgeCwgeGMsIHksXHJcbiAgICAgICAgICBpID0gc3RyLmluZGV4T2YoJy4nKSxcclxuICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgIC8vIE5vbi1pbnRlZ2VyLlxyXG4gICAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICAgIGsgPSBQT1dfUFJFQ0lTSU9OO1xyXG5cclxuICAgICAgICAgIC8vIFVubGltaXRlZCBwcmVjaXNpb24uXHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gaztcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHN0ciBhcyBpZiBhbiBpbnRlZ2VyLCB0aGVuIHJlc3RvcmUgdGhlIGZyYWN0aW9uIHBhcnQgYnkgZGl2aWRpbmcgdGhlXHJcbiAgICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgICAgeS5jID0gdG9CYXNlT3V0KHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKHguYyksIHguZSwgJzAnKSxcclxuICAgICAgICAgICAxMCwgYmFzZU91dCwgZGVjaW1hbCk7XHJcbiAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGludGVnZXIuXHJcblxyXG4gICAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICAgID8gKGFscGhhYmV0ID0gQUxQSEFCRVQsIGRlY2ltYWwpXHJcbiAgICAgICAgIDogKGFscGhhYmV0ID0gZGVjaW1hbCwgQUxQSEFCRVQpKTtcclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgICBlID0gayA9IHhjLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgICAgLy8gWmVybz9cclxuICAgICAgICBpZiAoIXhjWzBdKSByZXR1cm4gYWxwaGFiZXQuY2hhckF0KDApO1xyXG5cclxuICAgICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIC0tZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5jID0geGM7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICB4ID0gZGl2KHgsIHksIGRwLCBybSwgYmFzZU91dCk7XHJcbiAgICAgICAgICB4YyA9IHguYztcclxuICAgICAgICAgIHIgPSB4LnI7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGNvbnZlcnRlZCB0byBiYXNlT3V0LlxyXG5cclxuICAgICAgICAvLyBUSGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQ6IHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgaSA9IHhjW2RdO1xyXG5cclxuICAgICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICAgIGsgPSBiYXNlT3V0IC8gMjtcclxuICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgICAgOiBpID4gayB8fCBpID09IGsgJiYocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiYgeGNbZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgICAgLy8gemVybywgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBiYXNlIGNvbnZlcnNpb24gaXMgemVybyBvciwgaWYgcm91bmRpbmcgdXAsIGEgdmFsdWVcclxuICAgICAgICAvLyBzdWNoIGFzIDAuMDAwMDEuXHJcbiAgICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAgIC8vIDFeLWRwIG9yIDBcclxuICAgICAgICAgIHN0ciA9IHIgPyB0b0ZpeGVkUG9pbnQoYWxwaGFiZXQuY2hhckF0KDEpLCAtZHAsIGFscGhhYmV0LmNoYXJBdCgwKSkgOiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB4YyB0byB0aGUgcmVxdWlyZWQgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgeGMubGVuZ3RoID0gZDtcclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSb3VuZGluZyB1cCBtYXkgbWVhbiB0aGUgcHJldmlvdXMgZGlnaXQgaGFzIHRvIGJlIHJvdW5kZWQgdXAgYW5kIHNvIG9uLlxyXG4gICAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgIGlmICghZCkge1xyXG4gICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgeGMgPSBbMV0uY29uY2F0KHhjKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICAgIGZvciAoaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBhbHBoYWJldC5jaGFyQXQoeGNbaSsrXSkpO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsIGFscGhhYmV0LmNoYXJBdCgwKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICBkaXYgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAgICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICAgIGZ1bmN0aW9uIG11bHRpcGx5KHgsIGssIGJhc2UpIHtcclxuICAgICAgICB2YXIgbSwgdGVtcCwgeGxvLCB4aGksXHJcbiAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICBpID0geC5sZW5ndGgsXHJcbiAgICAgICAgICBrbG8gPSBrICUgU1FSVF9CQVNFLFxyXG4gICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoeCA9IHguc2xpY2UoKTsgaS0tOykge1xyXG4gICAgICAgICAgeGxvID0geFtpXSAlIFNRUlRfQkFTRTtcclxuICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgbSA9IGtoaSAqIHhsbyArIHhoaSAqIGtsbztcclxuICAgICAgICAgIHRlbXAgPSBrbG8gKiB4bG8gKyAoKG0gJSBTUVJUX0JBU0UpICogU1FSVF9CQVNFKSArIGNhcnJ5O1xyXG4gICAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgICAgdmFyIGksIGNtcDtcclxuXHJcbiAgICAgICAgaWYgKGFMICE9IGJMKSB7XHJcbiAgICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gY21wID0gMDsgaSA8IGFMOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgICBjbXAgPSBhW2ldID4gYltpXSA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNtcDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgYUwsIGJhc2UpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICAgIGZvciAoOyBhTC0tOykge1xyXG4gICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgICBhW2FMXSA9IGkgKiBiYXNlICsgYVthTF0gLSBiW2FMXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc3BsaWNlKDAsIDEpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geDogZGl2aWRlbmQsIHk6IGRpdmlzb3IuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgZHAsIHJtLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgeUwsIHl6LFxyXG4gICAgICAgICAgcyA9IHgucyA9PSB5LnMgPyAxIDogLTEsXHJcbiAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcclxuXHJcbiAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIHggaXMgwrEwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyDCsTAuXHJcbiAgICAgICAgICAgIHhjICYmIHhjWzBdID09IDAgfHwgIXljID8gcyAqIDAgOiBzIC8gMFxyXG4gICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcSA9IG5ldyBCaWdOdW1iZXIocyk7XHJcbiAgICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgIHMgPSBkcCArIGUgKyAxO1xyXG5cclxuICAgICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSAtIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGVuIHRoZSBjdXJyZW50IHZhbHVlIG9mIGUuXHJcbiAgICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAoaSA9IDA7IHljW2ldID09ICh4Y1tpXSB8fCAwKTsgaSsrKTtcclxuXHJcbiAgICAgICAgaWYgKHljW2ldID4gKHhjW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgICAgcWMucHVzaCgxKTtcclxuICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhjIGFuZCB5YyBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHljIGlzID49IGJhc2UgLyAyLlxyXG5cclxuICAgICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gaGFuZGxlIG9kZCBiYXNlcyB3aGVyZSB5Y1swXSA9PSAoYmFzZSAvIDIpIC0gMS5cclxuICAgICAgICAgIC8vIGlmIChuID4gMSB8fCBuKysgPT0gMSAmJiB5Y1swXSA8IGJhc2UgLyAyKSB7XHJcbiAgICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgICAgeWMgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHhjID0gbXVsdGlwbHkoeGMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhjLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOyByZW1bcmVtTCsrXSA9IDApO1xyXG4gICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICAgIHljMCA9IHljWzBdO1xyXG4gICAgICAgICAgaWYgKHljWzFdID49IGJhc2UgLyAyKSB5YzArKztcclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgIC8vIGVsc2UgaWYgKGJhc2UgPT0gMyAmJiB5YzAgPT0gMSkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIG4uXHJcblxyXG4gICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgaWYgKHlMICE9IHJlbUwpIHJlbTAgPSByZW0wICogYmFzZSArIChyZW1bMV0gfHwgMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIG4gaXMgaG93IG1hbnkgdGltZXMgdGhlIGRpdmlzb3IgZ29lcyBpbnRvIHRoZSBjdXJyZW50IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICBwcm9kdWN0ID0gZGl2aXNvciBtdWx0aXBsaWVkIGJ5IHRyaWFsIGRpZ2l0IChuKS5cclxuICAgICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3QgaXMgZ3JlYXRlciB0aGFuIHJlbWFpbmRlcjpcclxuICAgICAgICAgICAgICAvLyAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdCwgZGVjcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IHdhcyBsZXNzIHRoYW4gcmVtYWluZGVyIGF0IHRoZSBsYXN0IGNvbXBhcmU6XHJcbiAgICAgICAgICAgICAgLy8gICAgQ29tcGFyZSBuZXcgcmVtYWluZGVyIGFuZCBkaXZpc29yLlxyXG4gICAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgICAvLyAgICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIsIGluY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPiAxKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgICBpZiAobiA+PSBiYXNlKSBuID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0ID4gcmVtYWluZGVyIHRoZW4gdHJpYWwgZGlnaXQgbiB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKSA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5YywgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHljIGFuZCByZW0gYWdhaW4gYmVsb3csXHJcbiAgICAgICAgICAgICAgICAvLyBzbyBjaGFuZ2UgY21wIHRvIDEgdG8gYXZvaWQgaXQuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICBpZiAobiA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3JcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgcHJvZCwgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKSA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbisrO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHljLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNtcCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgICByZW1bcmVtTCsrXSA9IHhjW3hpXSB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBMZWFkaW5nIHplcm8/XHJcbiAgICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoYmFzZSA9PSBCQVNFKSB7XHJcblxyXG4gICAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIHJvdW5kKHEsIGRwICsgKHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSArIDEsIHJtLCBtb3JlKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBxLmUgPSBlO1xyXG4gICAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcTtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICogbm90YXRpb24gcm91bmRlZCB0byB0aGUgc3BlY2lmaWVkIGRlY2ltYWwgcGxhY2VzIG9yIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAqXHJcbiAgICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgICAqIGk6IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBkaWdpdCByZXF1aXJlZCAoaS5lLiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cCkuXHJcbiAgICAgKiBybTogdGhlIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmb3JtYXQobiwgaSwgcm0sIGlkKSB7XHJcbiAgICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgc3RyID0gaWQgPT0gMSB8fCBpZCA9PSAyICYmIChuZSA8PSBUT19FWFBfTkVHIHx8IG5lID49IFRPX0VYUF9QT1MpXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIG5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAgIC8vIG4uZSBtYXkgaGF2ZSBjaGFuZ2VkIGlmIHRoZSB2YWx1ZSB3YXMgcm91bmRlZCB1cC5cclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgLy8gdG9QcmVjaXNpb24gcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGZvciAoOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyk7XHJcbiAgICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBpZiAoZSArIDEgPiBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgKz0gZSAtIGxlbjtcclxuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGUgKyAxID09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgJiYgYzAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gICAgZnVuY3Rpb24gbWF4T3JNaW4oYXJncywgbWV0aG9kKSB7XHJcbiAgICAgIHZhciBuLFxyXG4gICAgICAgIGkgPSAxLFxyXG4gICAgICAgIG0gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbMF0pO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIoYXJnc1tpXSk7XHJcblxyXG4gICAgICAgIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gICAgICAgIGlmICghbi5zKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kLmNhbGwobSwgbikpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cclxuICAgICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG5vcm1hbGlzZShuLCBjLCBlKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBqID0gYy5sZW5ndGg7XHJcblxyXG4gICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICBmb3IgKGogPSBjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICgoZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxKSA+IE1BWF9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIG4uYyA9IFtuLmUgPSAwXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuLmUgPSBlO1xyXG4gICAgICAgIG4uYyA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXHJcbiAgICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2ksXHJcbiAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcclxuICAgICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgICBpc0luZmluaXR5T3JOYU4gPSAvXi0/KEluZmluaXR5fE5hTikkLyxcclxuICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrKD89W1xcdy5dKXxeXFxzK3xcXHMrJC9nO1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgICAgdmFyIGJhc2UsXHJcbiAgICAgICAgICBzID0gaXNOdW0gPyBzdHIgOiBzdHIucmVwbGFjZSh3aGl0ZXNwYWNlT3JQbHVzLCAnJyk7XHJcblxyXG4gICAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgICBpZiAoaXNJbmZpbml0eU9yTmFOLnRlc3QocykpIHtcclxuICAgICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoIWlzTnVtKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gKHAyID0gcDIudG9Mb3dlckNhc2UoKSkgPT0gJ3gnID8gMTYgOiBwMiA9PSAnYicgPyAyIDogODtcclxuICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IGI7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKGRvdEFmdGVyLCAnJDEnKS5yZXBsYWNlKGRvdEJlZm9yZSwgJzAuJDEnKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIE5hTlxyXG4gICAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAgICogSWYgciBpcyB0cnV0aHksIGl0IGlzIGtub3duIHRoYXQgdGhlcmUgYXJlIG1vcmUgZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICAgIHZhciBkLCBpLCBqLCBrLCBuLCBuaSwgcmQsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgLy8gbiBpcyBhIGJhc2UgMWUxNCBudW1iZXIsIHRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCBvZiBhcnJheSB4LmMgY29udGFpbmluZyByZC5cclxuICAgICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAvLyBpIGlzIHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiBpbmNsdWRpbmcgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICAgIGZvciAoZCA9IDEsIGsgPSB4Y1swXTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuICAgICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgaiA9IHNkO1xyXG4gICAgICAgICAgICBuID0geGNbbmkgPSAwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICByZCA9IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5pID0gbWF0aGNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChuaSA+PSB4Yy5sZW5ndGgpIHtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkZWQgYnkgc3FydC5cclxuICAgICAgICAgICAgICAgIGZvciAoOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkpO1xyXG4gICAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgICBmb3IgKGQgPSAxOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLlxyXG4gICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgIC8vIFRoZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuIGlzIGdpdmVuIGJ5IExPR19CQVNFIC0gZC5cclxuICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAvLyBBcmUgdGhlcmUgYW55IG5vbi16ZXJvIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQ/XHJcbiAgICAgICAgICAvLyBUaGUgZXhwcmVzc2lvbiAgbiAlIHBvd3MxMFtkIC0gaiAtIDFdICByZXR1cm5zIGFsbCBkaWdpdHMgb2YgbiB0byB0aGUgcmlnaHRcclxuICAgICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgICB4Y1tuaSArIDFdICE9IG51bGwgfHwgKGogPCAwID8gbiA6IG4gJSBwb3dzMTBbZCAtIGogLSAxXSk7XHJcblxyXG4gICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkaWdpdCB0byB0aGUgbGVmdCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgb2RkLlxyXG4gICAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgICBpZiAoc2QgPCAxIHx8ICF4Y1swXSkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCBzZCB0byBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0gcG93czEwWyhMT0dfQkFTRSAtIHNkICUgTE9HX0JBU0UpICUgTE9HX0JBU0VdO1xyXG4gICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICBpZiAoaSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pICsgMTtcclxuICAgICAgICAgICAgayA9IHBvd3MxMFtMT0dfQkFTRSAtIGldO1xyXG5cclxuICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gal0gJSBwb3dzMTBbal0pICogayA6IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICBpZiAobmkgPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKyspO1xyXG4gICAgICAgICAgICAgICAgaiA9IHhjWzBdICs9IGs7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICBpZiAoeGNbMF0gPT0gQkFTRSkgeGNbMF0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaV0gKz0gaztcclxuICAgICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB4Y1tuaS0tXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICBmb3IgKGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIHZhbHVlT2Yobikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuXHJcbiAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBlKVxyXG4gICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBQUk9UT1RZUEUvSU5TVEFOQ0UgTUVUSE9EU1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgKi9cclxuICAgIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIGlmICh4LnMgPCAwKSB4LnMgPSAxO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm5cclxuICAgICAqICAgMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIC0xIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgKiAgIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBpcyBOYU4uXHJcbiAgICAgKi9cclxuICAgIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIGRwIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG9mIHRoZVxyXG4gICAgICogdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgZHAgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBkcCBkZWNpbWFsIHBsYWNlcyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXM6IGludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5kZWNpbWFsUGxhY2VzID0gUC5kcCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBkcCArIHguZSArIDEsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICBuID0gKCh2ID0gYy5sZW5ndGggLSAxKSAtIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSkgKiBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgICBpZiAodiA9IGNbdl0pIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuICAgICAgaWYgKG4gPCAwKSBuID0gMDtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC8gMCA9IElcclxuICAgICAqICBuIC8gTiA9IE5cclxuICAgICAqICBuIC8gSSA9IDBcclxuICAgICAqICAwIC8gbiA9IDBcclxuICAgICAqICAwIC8gMCA9IE5cclxuICAgICAqICAwIC8gTiA9IE5cclxuICAgICAqICAwIC8gSSA9IDBcclxuICAgICAqICBOIC8gbiA9IE5cclxuICAgICAqICBOIC8gMCA9IE5cclxuICAgICAqICBOIC8gTiA9IE5cclxuICAgICAqICBOIC8gSSA9IE5cclxuICAgICAqICBJIC8gbiA9IElcclxuICAgICAqICBJIC8gMCA9IElcclxuICAgICAqICBJIC8gTiA9IE5cclxuICAgICAqICBJIC8gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBkaXZpZGVkIGJ5IHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkQnkgPSBQLmRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGludGVnZXIgcGFydCBvZiBkaXZpZGluZyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5pZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgICAqXHJcbiAgICAgKiBJZiBtIGlzIHByZXNlbnQsIHJldHVybiB0aGUgcmVzdWx0IG1vZHVsbyBtLlxyXG4gICAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vbi16ZXJvIGFuZCBtIGlzIG5vdCBwcmVzZW50LCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgICAqIGlzIGVxdWl2YWxlbnQgdG8gY2FsY3VsYXRpbmcgeC5leHBvbmVudGlhdGVkQnkobikubW9kdWxvKG0pIHdpdGggYSBQT1dfUFJFQ0lTSU9OIG9mIDAuXHJcbiAgICAgKlxyXG4gICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgICAqIFttXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBtb2R1bHVzLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAgICovXHJcbiAgICBQLmV4cG9uZW50aWF0ZWRCeSA9IFAucG93ID0gZnVuY3Rpb24gKG4sIG0pIHtcclxuICAgICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobik7XHJcblxyXG4gICAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgICBpZiAobi5jICYmICFuLmlzSW50ZWdlcigpKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobSAhPSBudWxsKSBtID0gbmV3IEJpZ051bWJlcihtKTtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICAgIG5Jc0JpZyA9IG4uZSA+IDE0O1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBOYU4sIMKxSW5maW5pdHksIMKxMCBvciDCsTEsIG9yIG4gaXMgwrFJbmZpbml0eSwgTmFOIG9yIMKxMC5cclxuICAgICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gVGhlIHNpZ24gb2YgdGhlIHJlc3VsdCBvZiBwb3cgd2hlbiB4IGlzIG5lZ2F0aXZlIGRlcGVuZHMgb24gdGhlIGV2ZW5uZXNzIG9mIG4uXHJcbiAgICAgICAgLy8gSWYgK24gb3ZlcmZsb3dzIHRvIMKxSW5maW5pdHksIHRoZSBldmVubmVzcyBvZiBuIHdvdWxkIGJlIG5vdCBiZSBrbm93bi5cclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gbi5zICogKDIgLSBpc09kZChuKSkgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHtcclxuICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgeGMgPSB5YztcclxuICAgICAgICB5YyA9IHQ7XHJcbiAgICAgICAgeS5zID0gLXkucztcclxuICAgICAgfVxyXG5cclxuICAgICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIpO1xyXG4gICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXHJcbiAgICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICBzID0geS5zO1xyXG4gICAgICAgIHkucyA9IDE7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCAzKTtcclxuICAgICAgICB5LnMgPSBzO1xyXG4gICAgICAgIHEucyAqPSBzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0geC5taW51cyhxLnRpbWVzKHkpKTtcclxuXHJcbiAgICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAqIDAgPSAwXHJcbiAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgKiAgMCAqIG4gPSAwXHJcbiAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgKiAgMCAqIEkgPSBOXHJcbiAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgKiAgTiAqIE4gPSBOXHJcbiAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgKiAgSSAqIDAgPSBOXHJcbiAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgIGJhc2UsIHNxcnRCYXNlLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0gKHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpKS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgaWYgKCF4YyB8fCAheWMpIHtcclxuICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgeS5zICo9IHgucztcclxuICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgIGlmICh4Y0wgPCB5Y0wpIHtcclxuICAgICAgICB6YyA9IHhjO1xyXG4gICAgICAgIHhjID0geWM7XHJcbiAgICAgICAgeWMgPSB6YztcclxuICAgICAgICBpID0geGNMO1xyXG4gICAgICAgIHhjTCA9IHljTDtcclxuICAgICAgICB5Y0wgPSBpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgZm9yIChpID0geGNMICsgeWNMLCB6YyA9IFtdOyBpLS07IHpjLnB1c2goMCkpO1xyXG5cclxuICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgIHNxcnRCYXNlID0gU1FSVF9CQVNFO1xyXG5cclxuICAgICAgZm9yIChpID0geWNMOyAtLWkgPj0gMDspIHtcclxuICAgICAgICBjID0gMDtcclxuICAgICAgICB5bG8gPSB5Y1tpXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHloaSA9IHljW2ldIC8gc3FydEJhc2UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICB4aGkgPSB4Y1trXSAvIHNxcnRCYXNlIHwgMDtcclxuICAgICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoKG0gJSBzcXJ0QmFzZSkgKiBzcXJ0QmFzZSkgKyB6Y1tqXSArIGM7XHJcbiAgICAgICAgICBjID0gKHhsbyAvIGJhc2UgfCAwKSArIChtIC8gc3FydEJhc2UgfCAwKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgemNbal0gPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYykge1xyXG4gICAgICAgICsrZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB6Yy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgKi9cclxuICAgIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICB4LnMgPSAteC5zIHx8IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuICsgMCA9IG5cclxuICAgICAqICBuICsgTiA9IE5cclxuICAgICAqICBuICsgSSA9IElcclxuICAgICAqICAwICsgbiA9IG5cclxuICAgICAqICAwICsgMCA9IDBcclxuICAgICAqICAwICsgTiA9IE5cclxuICAgICAqICAwICsgSSA9IElcclxuICAgICAqICBOICsgbiA9IE5cclxuICAgICAqICBOICsgMCA9IE5cclxuICAgICAqICBOICsgTiA9IE5cclxuICAgICAqICBOICsgSSA9IE5cclxuICAgICAqICBJICsgbiA9IElcclxuICAgICAqICBJICsgMCA9IElcclxuICAgICAqICBJICsgTiA9IE5cclxuICAgICAqICBJICsgSSA9IElcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBwbHVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLnBsdXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICB2YXIgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBhID0geC5zO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcbiAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICBpZiAoIWEgfHwgIWIpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoYSAvIDApO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkgcmV0dXJuIHljWzBdID8geSA6IG5ldyBCaWdOdW1iZXIoeGNbMF0gPyB4IDogYSAqIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZSA9IGJpdEZsb29yKHhlKTtcclxuICAgICAgeWUgPSBiaXRGbG9vcih5ZSk7XHJcbiAgICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLiBGYXN0ZXIgdG8gdXNlIHJldmVyc2UgdGhlbiBkbyB1bnNoaWZ0cy5cclxuICAgICAgaWYgKGEgPSB4ZSAtIHllKSB7XHJcbiAgICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICBmb3IgKDsgYS0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBhID0geGMubGVuZ3RoO1xyXG4gICAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUG9pbnQgeGMgdG8gdGhlIGxvbmdlciBhcnJheSwgYW5kIGIgdG8gdGhlIHNob3J0ZXIgbGVuZ3RoLlxyXG4gICAgICBpZiAoYSAtIGIgPCAwKSB7XHJcbiAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIHljID0geGM7XHJcbiAgICAgICAgeGMgPSB0O1xyXG4gICAgICAgIGIgPSBhO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5Yy5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4YyBjYW4gYmUgaWdub3JlZC5cclxuICAgICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgICBhID0gKHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSkgLyBCQVNFIHwgMDtcclxuICAgICAgICB4Y1tiXSA9IEJBU0UgPT09IHhjW2JdID8gMCA6IHhjW2JdICUgQkFTRTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGEpIHtcclxuICAgICAgICB4YyA9IFthXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICsreWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgc2QgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mXHJcbiAgICAgKiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsIG9yIG51bGwgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBzZCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgYm9vbGVhbjogd2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgICAgdmFyIGMsIG4sIHYsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICAgIGludENoZWNrKHNkLCAxLCBNQVgpO1xyXG4gICAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICAgIHJldHVybiByb3VuZChuZXcgQmlnTnVtYmVyKHgpLCBzZCwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIHYgPSBjLmxlbmd0aCAtIDE7XHJcbiAgICAgIG4gPSB2ICogTE9HX0JBU0UgKyAxO1xyXG5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBuKyspO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgc2hpZnRlZCBieSBrIHBsYWNlc1xyXG4gICAgICogKHBvd2VycyBvZiAxMCkuIFNoaWZ0IHRvIHRoZSByaWdodCBpZiBuID4gMCwgYW5kIHRvIHRoZSBsZWZ0IGlmIG4gPCAwLlxyXG4gICAgICpcclxuICAgICAqIGsge251bWJlcn0gSW50ZWdlciwgLU1BWF9TQUZFX0lOVEVHRVIgdG8gTUFYX1NBRkVfSU5URUdFUiBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgICAqL1xyXG4gICAgUC5zaGlmdGVkQnkgPSBmdW5jdGlvbiAoaykge1xyXG4gICAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICAgIHJldHVybiB0aGlzLnRpbWVzKCcxZScgKyBrKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAgICogIHNxcnQoTikgPSAgTlxyXG4gICAgICogIHNxcnQoLUkpID0gIE5cclxuICAgICAqICBzcXJ0KEkpID0gIElcclxuICAgICAqICBzcXJ0KDApID0gIDBcclxuICAgICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICBjID0geC5jLFxyXG4gICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgZSA9IHguZSxcclxuICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTICsgNCxcclxuICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgaWYgKHMgIT09IDEgfHwgIWMgfHwgIWNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgICAvLyBNYXRoLnNxcnQgdW5kZXJmbG93L292ZXJmbG93P1xyXG4gICAgICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gICAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gY29lZmZUb1N0cmluZyhjKTtcclxuICAgICAgICBpZiAoKG4ubGVuZ3RoICsgZSkgJSAyID09IDApIG4gKz0gJzAnO1xyXG4gICAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICAgIGUgPSBiaXRGbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSBuZXcgQmlnTnVtYmVyKHMgKyAnJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgIGlmIChyLmNbMF0pIHtcclxuICAgICAgICBlID0gci5lO1xyXG4gICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgaWYgKHMgPCAzKSBzID0gMDtcclxuXHJcbiAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgICB0ID0gcjtcclxuICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKHQucGx1cyhkaXYoeCwgdCwgZHAsIDEpKSk7XHJcblxyXG4gICAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgb2YgciBtYXkgaGVyZSBiZSBvbmUgbGVzcyB0aGFuIHRoZSBmaW5hbCByZXN1bHQgZXhwb25lbnQsXHJcbiAgICAgICAgICAgIC8vIGUuZyAwLjAwMDk5OTkgKGUtNCkgLS0gPiAwLjAwMSAoZS0zKSwgc28gYWRqdXN0IHMgc28gdGhlIHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAvLyBhcmUgaW5kZXhlZCBjb3JyZWN0bHkuXHJcbiAgICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICAgIG4gPSBuLnNsaWNlKHMgLSAzLCBzICsgMSk7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgICAgLy8gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAvLyBleGFjdCByZXN1bHQgYXMgdGhlIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICAgIHMgKz0gNDtcclxuICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgZXhhY3RcclxuICAgICAgICAgICAgICAvLyByZXN1bHQuIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAxKTtcclxuICAgICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQociwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBleHBvbmVudGlhbCBub3RhdGlvbiBhbmRcclxuICAgICAqIHJvdW5kZWQgdXNpbmcgUk9VTkRJTkdfTU9ERSB0byBkcCBmaXhlZCBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBkcCsrO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtLCAxKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRml4ZWQgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHAgPSBkcCArIHRoaXMuZSArIDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgICAqIHVzaW5nIHJtIG9yIFJPVU5ESU5HX01PREUgdG8gZHAgZGVjaW1hbCBwbGFjZXMsIGFuZCBmb3JtYXR0ZWQgYWNjb3JkaW5nIHRvIHRoZSBwcm9wZXJ0aWVzXHJcbiAgICAgKiBvZiB0aGUgZm9ybWF0IG9yIEZPUk1BVCBvYmplY3QgKHNlZSBCaWdOdW1iZXIuc2V0KS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZm9ybWF0dGluZyBvYmplY3QgbWF5IGNvbnRhaW4gc29tZSBvciBhbGwgb2YgdGhlIHByb3BlcnRpZXMgc2hvd24gYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogRk9STUFUID0ge1xyXG4gICAgICogICBwcmVmaXg6ICcnLFxyXG4gICAgICogICBncm91cFNpemU6IDMsXHJcbiAgICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAqICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAqICAgc3VmZml4OiAnJ1xyXG4gICAgICogfTtcclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbZm9ybWF0XSB7b2JqZWN0fSBGb3JtYXR0aW5nIG9wdGlvbnMuIFNlZSBGT1JNQVQgcGJqZWN0IGFib3ZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IG5vdCBhbiBvYmplY3Q6IHtmb3JtYXR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgICBpZiAoZHAgIT0gbnVsbCAmJiBybSAmJiB0eXBlb2Ygcm0gPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgIGZvcm1hdCA9IHJtO1xyXG4gICAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZHAgJiYgdHlwZW9mIGRwID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBkcDtcclxuICAgICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBGT1JNQVQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmb3JtYXQgIT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzdHIgPSB4LnRvRml4ZWQoZHAsIHJtKTtcclxuXHJcbiAgICAgIGlmICh4LmMpIHtcclxuICAgICAgICB2YXIgaSxcclxuICAgICAgICAgIGFyciA9IHN0ci5zcGxpdCgnLicpLFxyXG4gICAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICAgIGcyID0gK2Zvcm1hdC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICBncm91cFNlcGFyYXRvciA9IGZvcm1hdC5ncm91cFNlcGFyYXRvciB8fCAnJyxcclxuICAgICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgaWYgKGcyKSB7XHJcbiAgICAgICAgICBpID0gZzE7XHJcbiAgICAgICAgICBnMSA9IGcyO1xyXG4gICAgICAgICAgZzIgPSBpO1xyXG4gICAgICAgICAgbGVuIC09IGk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBERUNJTUFMX1BMQUNFUyArIGUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIG4uZSwgJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50Q2hlY2soYiwgMiwgQUxQSEFCRVQubGVuZ3RoLCAnQmFzZScpO1xyXG4gICAgICAgICAgc3RyID0gY29udmVydEJhc2UodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKSwgMTAsIGIsIHMsIHRydWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHMgPCAwICYmIG4uY1swXSkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgICAqIG5lZ2F0aXZlIHplcm8uXHJcbiAgICAgKi9cclxuICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgICBpZiAoY29uZmlnT2JqZWN0ICE9IG51bGwpIEJpZ051bWJlci5zZXQoY29uZmlnT2JqZWN0KTtcclxuXHJcbiAgICByZXR1cm4gQmlnTnVtYmVyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBSSVZBVEUgSEVMUEVSIEZVTkNUSU9OU1xyXG5cclxuICAvLyBUaGVzZSBmdW5jdGlvbnMgZG9uJ3QgbmVlZCBhY2Nlc3MgdG8gdmFyaWFibGVzLFxyXG4gIC8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgIHZhciBpID0gbiB8IDA7XHJcbiAgICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxuICB9XHJcblxyXG5cclxuICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICBmdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICAgIHZhciBzLCB6LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgIGZvciAoOyBpIDwgajspIHtcclxuICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgZm9yICg7IHotLTsgcyA9ICcwJyArIHMpO1xyXG4gICAgICByICs9IHM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICAgIHJldHVybiByLnNsaWNlKDAsIGogKyAxIHx8IDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuICBmdW5jdGlvbiBjb21wYXJlKHgsIHkpIHtcclxuICAgIHZhciBhLCBiLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSB5LmMsXHJcbiAgICAgIGkgPSB4LnMsXHJcbiAgICAgIGogPSB5LnMsXHJcbiAgICAgIGsgPSB4LmUsXHJcbiAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghaSB8fCAhaikgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgYSA9IHhjICYmICF4Y1swXTtcclxuICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICBpZiAoYSB8fCBiKSByZXR1cm4gYSA/IGIgPyAwIDogLWogOiBpO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChpICE9IGopIHJldHVybiBpO1xyXG5cclxuICAgIGEgPSBpIDwgMDtcclxuICAgIGIgPSBrID09IGw7XHJcblxyXG4gICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBiID8gMCA6ICF4YyBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoIWIpIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgaiA9IChrID0geGMubGVuZ3RoKSA8IChsID0geWMubGVuZ3RoKSA/IGsgOiBsO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgajsgaSsrKSBpZiAoeGNbaV0gIT0geWNbaV0pIHJldHVybiB4Y1tpXSA+IHljW2ldIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGludENoZWNrKG4sIG1pbiwgbWF4LCBuYW1lKSB7XHJcbiAgICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgKGJpZ251bWJlckVycm9yICsgKG5hbWUgfHwgJ0FyZ3VtZW50JykgKyAodHlwZW9mIG4gPT0gJ251bWJlcidcclxuICAgICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgICAgOiAnIG5vdCBhIHByaW1pdGl2ZSBudW1iZXI6ICcpICsgU3RyaW5nKG4pKTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBBc3N1bWVzIGZpbml0ZSBuLlxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgICByZXR1cm4gYml0Rmxvb3Iobi5lIC8gTE9HX0JBU0UpID09IGsgJiYgbi5jW2tdICUgMiAhPSAwO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgICByZXR1cm4gKHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0cikgK1xyXG4gICAgIChlIDwgMCA/ICdlJyA6ICdlKycpICsgZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCB6KSB7XHJcbiAgICB2YXIgbGVuLCB6cztcclxuXHJcbiAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICAgIHN0ciA9IHpzICsgc3RyO1xyXG5cclxuICAgIC8vIFBvc2l0aXZlIGV4cG9uZW50XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgICAgZm9yICh6cyA9IHosIGUgLT0gbGVuOyAtLWU7IHpzICs9IHopO1xyXG4gICAgICAgIHN0ciArPSB6cztcclxuICAgICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLnNsaWNlKDAsIGUpICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN0cjtcclxuICB9XHJcblxyXG5cclxuICAvLyBFWFBPUlRcclxuXHJcblxyXG4gIEJpZ051bWJlciA9IGNsb25lKCk7XHJcbiAgQmlnTnVtYmVyWydkZWZhdWx0J10gPSBCaWdOdW1iZXIuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBBTUQuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlnTnVtYmVyOyB9KTtcclxuXHJcbiAgLy8gTm9kZS5qcyBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG5cclxuICAvLyBCcm93c2VyLlxyXG4gIH0gZWxzZSB7XHJcbiAgICBpZiAoIWdsb2JhbE9iamVjdCkge1xyXG4gICAgICBnbG9iYWxPYmplY3QgPSB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmID8gc2VsZiA6IHdpbmRvdztcclxuICAgIH1cclxuXHJcbiAgICBnbG9iYWxPYmplY3QuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpXG52YXIgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJylcbnZhciBub3JtYWxpemVOb2RlcyA9IHJlcXVpcmUoJy4vdXRpbHMnKS5ub3JtYWxpemVOb2Rlc1xudmFyIGRyb3BzVG9YUlAgPSByZXF1aXJlKCcuL3V0aWxzJykuZHJvcHNUb1hSUFxuXG5mdW5jdGlvbiBncm91cEJ5QWRkcmVzcyhiYWxhbmNlQ2hhbmdlcykge1xuICB2YXIgZ3JvdXBlZCA9IF8uZ3JvdXBCeShiYWxhbmNlQ2hhbmdlcywgZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLmFkZHJlc3NcbiAgfSlcbiAgcmV0dXJuIF8ubWFwVmFsdWVzKGdyb3VwZWQsIGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgcmV0dXJuIF8ubWFwKGdyb3VwLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5iYWxhbmNlXG4gICAgfSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gbmV3IEJpZ051bWJlcih2YWx1ZS52YWx1ZSB8fCB2YWx1ZSlcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUJhbGFuY2VDaGFuZ2Uobm9kZSkge1xuICB2YXIgdmFsdWUgPSBudWxsXG4gIGlmIChub2RlLm5ld0ZpZWxkcy5CYWxhbmNlKSB7XG4gICAgdmFsdWUgPSBwYXJzZVZhbHVlKG5vZGUubmV3RmllbGRzLkJhbGFuY2UpXG4gIH0gZWxzZSBpZiAobm9kZS5wcmV2aW91c0ZpZWxkcy5CYWxhbmNlICYmIG5vZGUuZmluYWxGaWVsZHMuQmFsYW5jZSkge1xuICAgIHZhbHVlID0gcGFyc2VWYWx1ZShub2RlLmZpbmFsRmllbGRzLkJhbGFuY2UpLm1pbnVzKFxuICAgICAgcGFyc2VWYWx1ZShub2RlLnByZXZpb3VzRmllbGRzLkJhbGFuY2UpKVxuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IG51bGwgOiB2YWx1ZS5pc1plcm8oKSA/IG51bGwgOiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBwYXJzZUZpbmFsQmFsYW5jZShub2RlKSB7XG4gIGlmIChub2RlLm5ld0ZpZWxkcy5CYWxhbmNlKSB7XG4gICAgcmV0dXJuIHBhcnNlVmFsdWUobm9kZS5uZXdGaWVsZHMuQmFsYW5jZSlcbiAgfSBlbHNlIGlmIChub2RlLmZpbmFsRmllbGRzLkJhbGFuY2UpIHtcbiAgICByZXR1cm4gcGFyc2VWYWx1ZShub2RlLmZpbmFsRmllbGRzLkJhbGFuY2UpXG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuXG5mdW5jdGlvbiBwYXJzZVhSUFF1YW50aXR5KG5vZGUsIHZhbHVlUGFyc2VyKSB7XG4gIHZhciB2YWx1ZSA9IHZhbHVlUGFyc2VyKG5vZGUpXG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRkcmVzczogbm9kZS5maW5hbEZpZWxkcy5BY2NvdW50IHx8IG5vZGUubmV3RmllbGRzLkFjY291bnQsXG4gICAgYmFsYW5jZToge1xuICAgICAgY291bnRlcnBhcnR5OiAnJyxcbiAgICAgIGN1cnJlbmN5OiAnWFJQJyxcbiAgICAgIHZhbHVlOiBkcm9wc1RvWFJQKHZhbHVlKS50b1N0cmluZygpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsaXBUcnVzdGxpbmVQZXJzcGVjdGl2ZShxdWFudGl0eSkge1xuICB2YXIgbmVnYXRlZEJhbGFuY2UgPSAobmV3IEJpZ051bWJlcihxdWFudGl0eS5iYWxhbmNlLnZhbHVlKSkubmVnYXRlZCgpXG4gIHJldHVybiB7XG4gICAgYWRkcmVzczogcXVhbnRpdHkuYmFsYW5jZS5jb3VudGVycGFydHksXG4gICAgYmFsYW5jZToge1xuICAgICAgY291bnRlcnBhcnR5OiBxdWFudGl0eS5hZGRyZXNzLFxuICAgICAgY3VycmVuY3k6IHF1YW50aXR5LmJhbGFuY2UuY3VycmVuY3ksXG4gICAgICB2YWx1ZTogbmVnYXRlZEJhbGFuY2UudG9TdHJpbmcoKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRydXN0bGluZVF1YW50aXR5KG5vZGUsIHZhbHVlUGFyc2VyKSB7XG4gIHZhciB2YWx1ZSA9IHZhbHVlUGFyc2VyKG5vZGUpXG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qXG4gICAqIEEgdHJ1c3RsaW5lIGNhbiBiZSBjcmVhdGVkIHdpdGggYSBub24temVybyBzdGFydGluZyBiYWxhbmNlXG4gICAqIElmIGFuIG9mZmVyIGlzIHBsYWNlZCB0byBhY3F1aXJlIGFuIGFzc2V0IHdpdGggbm8gZXhpc3RpbmcgdHJ1c3RsaW5lLFxuICAgKiB0aGUgdHJ1c3RsaW5lIGNhbiBiZSBjcmVhdGVkIHdoZW4gdGhlIG9mZmVyIGlzIHRha2VuLlxuICAgKi9cbiAgdmFyIGZpZWxkcyA9IF8uaXNFbXB0eShub2RlLm5ld0ZpZWxkcykgPyBub2RlLmZpbmFsRmllbGRzIDogbm9kZS5uZXdGaWVsZHNcblxuICAvLyB0aGUgYmFsYW5jZSBpcyBhbHdheXMgZnJvbSBsb3cgbm9kZSdzIHBlcnNwZWN0aXZlXG4gIHZhciByZXN1bHQgPSB7XG4gICAgYWRkcmVzczogZmllbGRzLkxvd0xpbWl0Lmlzc3VlcixcbiAgICBiYWxhbmNlOiB7XG4gICAgICBjb3VudGVycGFydHk6IGZpZWxkcy5IaWdoTGltaXQuaXNzdWVyLFxuICAgICAgY3VycmVuY3k6IGZpZWxkcy5CYWxhbmNlLmN1cnJlbmN5LFxuICAgICAgdmFsdWU6IHZhbHVlLnRvU3RyaW5nKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtyZXN1bHQsIGZsaXBUcnVzdGxpbmVQZXJzcGVjdGl2ZShyZXN1bHQpXVxufVxuXG5mdW5jdGlvbiBwYXJzZVF1YW50aXRpZXMobWV0YWRhdGEsIHZhbHVlUGFyc2VyKSB7XG4gIHZhciB2YWx1ZXMgPSBub3JtYWxpemVOb2RlcyhtZXRhZGF0YSkubWFwKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5lbnRyeVR5cGUgPT09ICdBY2NvdW50Um9vdCcpIHtcbiAgICAgIHJldHVybiBbcGFyc2VYUlBRdWFudGl0eShub2RlLCB2YWx1ZVBhcnNlcildXG4gICAgfSBlbHNlIGlmIChub2RlLmVudHJ5VHlwZSA9PT0gJ1JpcHBsZVN0YXRlJykge1xuICAgICAgcmV0dXJuIHBhcnNlVHJ1c3RsaW5lUXVhbnRpdHkobm9kZSwgdmFsdWVQYXJzZXIpXG4gICAgfVxuICAgIHJldHVybiBbXVxuICB9KVxuICByZXR1cm4gZ3JvdXBCeUFkZHJlc3MoXy5jb21wYWN0KF8uZmxhdHRlbih2YWx1ZXMpKSlcbn1cblxuLyoqXG4gKiAgQ29tcHV0ZXMgdGhlIGNvbXBsZXRlIGxpc3Qgb2YgZXZlcnkgYmFsYW5jZSB0aGF0IGNoYW5nZWQgaW4gdGhlIGxlZGdlclxuICogIGFzIGEgcmVzdWx0IG9mIHRoZSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAqXG4gKiAgQHBhcmFtIHtPYmplY3R9IG1ldGFkYXRhIFRyYW5zYWN0aW9uIG1ldGFkYVxuICogIEByZXR1cm5zIHtPYmplY3R9IHBhcnNlZCBiYWxhbmNlIGNoYW5nZXNcbiAqL1xuZnVuY3Rpb24gcGFyc2VCYWxhbmNlQ2hhbmdlcyhtZXRhZGF0YSkge1xuICByZXR1cm4gcGFyc2VRdWFudGl0aWVzKG1ldGFkYXRhLCBjb21wdXRlQmFsYW5jZUNoYW5nZSlcbn1cblxuXG4vKipcbiAqICBDb21wdXRlcyB0aGUgY29tcGxldGUgbGlzdCBvZiBldmVyeSBmaW5hbCBiYWxhbmNlIGluIHRoZSBsZWRnZXJcbiAqICBhcyBhIHJlc3VsdCBvZiB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gKlxuICogIEBwYXJhbSB7T2JqZWN0fSBtZXRhZGF0YSBUcmFuc2FjdGlvbiBtZXRhZGFcbiAqICBAcmV0dXJucyB7T2JqZWN0fSBwYXJzZWQgYmFsYW5jZXNcbiAqL1xuZnVuY3Rpb24gcGFyc2VGaW5hbEJhbGFuY2VzKG1ldGFkYXRhKSB7XG4gIHJldHVybiBwYXJzZVF1YW50aXRpZXMobWV0YWRhdGEsIHBhcnNlRmluYWxCYWxhbmNlKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5wYXJzZUJhbGFuY2VDaGFuZ2VzID0gcGFyc2VCYWxhbmNlQ2hhbmdlc1xubW9kdWxlLmV4cG9ydHMucGFyc2VGaW5hbEJhbGFuY2VzID0gcGFyc2VGaW5hbEJhbGFuY2VzXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3Qgbm9ybWFsaXplTm9kZXMgPSByZXF1aXJlKCcuL3V0aWxzJykubm9ybWFsaXplTm9kZXNcbmNvbnN0IEJpZ051bWJlciA9IHJlcXVpcmUoJ2JpZ251bWJlci5qcycpXG5cbmZ1bmN0aW9uIHBhcnNlUGF5bWVudENoYW5uZWxTdGF0dXMobm9kZSkge1xuICBpZiAobm9kZS5kaWZmVHlwZSA9PT0gJ0NyZWF0ZWROb2RlJykge1xuICAgIHJldHVybiAnY3JlYXRlZCdcbiAgfVxuXG4gIGlmIChub2RlLmRpZmZUeXBlID09PSAnTW9kaWZpZWROb2RlJykge1xuICAgIHJldHVybiAnbW9kaWZpZWQnXG4gIH1cblxuICBpZiAobm9kZS5kaWZmVHlwZSA9PT0gJ0RlbGV0ZWROb2RlJykge1xuICAgIHJldHVybiAnZGVsZXRlZCdcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIHN1bW1hcml6ZVBheW1lbnRDaGFubmVsKG5vZGUpIHtcblxuICBjb25zdCBmaW5hbCA9IChub2RlLmRpZmZUeXBlID09PSAnQ3JlYXRlZE5vZGUnKSA/XG4gICAgbm9kZS5uZXdGaWVsZHMgOiBub2RlLmZpbmFsRmllbGRzXG4gIGNvbnN0IHByZXYgPSBub2RlLnByZXZpb3VzRmllbGRzIHx8IHt9XG5cbiAgY29uc3Qgc3VtbWFyeSA9IHtcbiAgICAvLyBTdGF0dXMgbWF5IGJlICdjcmVhdGVkJywgJ21vZGlmaWVkJywgb3IgJ2RlbGV0ZWQnLlxuICAgIHN0YXR1czogcGFyc2VQYXltZW50Q2hhbm5lbFN0YXR1cyhub2RlKSxcblxuICAgIC8vIFRoZSBMZWRnZXJJbmRleCBpbmRpY2F0ZXMgdGhlIENoYW5uZWwgSUQsXG4gICAgLy8gd2hpY2ggaXMgbmVjZXNzYXJ5IHRvIHNpZ24gY2xhaW1zLlxuICAgIGNoYW5uZWxJZDogbm9kZS5sZWRnZXJJbmRleCxcblxuICAgIC8vIFRoZSBzb3VyY2UgYWRkcmVzcyB0aGF0IG93bnMgdGhpcyBwYXltZW50IGNoYW5uZWwuXG4gICAgLy8gVGhpcyBjb21lcyBmcm9tIHRoZSBzZW5kaW5nIGFkZHJlc3Mgb2YgdGhlXG4gICAgLy8gdHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVkIHRoZSBjaGFubmVsLlxuICAgIHNvdXJjZTogZmluYWwuQWNjb3VudCxcblxuICAgIC8vIFRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzIGZvciB0aGlzIHBheW1lbnQgY2hhbm5lbC5cbiAgICAvLyBXaGlsZSB0aGUgcGF5bWVudCBjaGFubmVsIGlzIG9wZW4sIHRoaXMgYWRkcmVzcyBpcyB0aGUgb25seSBvbmUgdGhhdCBjYW4gcmVjZWl2ZVxuICAgIC8vIFhSUCBmcm9tIHRoZSBjaGFubmVsLiBUaGlzIGNvbWVzIGZyb20gdGhlIERlc3RpbmF0aW9uIGZpZWxkIG9mIHRoZSB0cmFuc2FjdGlvblxuICAgIC8vIHRoYXQgY3JlYXRlZCB0aGUgY2hhbm5lbC5cbiAgICBkZXN0aW5hdGlvbjogZmluYWwuRGVzdGluYXRpb24sXG5cbiAgICAvLyBUb3RhbCBYUlAsIGluIGRyb3BzLCB0aGF0IGhhcyBiZWVuIGFsbG9jYXRlZCB0byB0aGlzIGNoYW5uZWwuXG4gICAgLy8gVGhpcyBpbmNsdWRlcyBYUlAgdGhhdCBoYXMgYmVlbiBwYWlkIHRvIHRoZSBkZXN0aW5hdGlvbiBhZGRyZXNzLlxuICAgIC8vIFRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVkIHRoZSBjaGFubmVsIGFuZFxuICAgIC8vIGNhbiBiZSBpbmNyZWFzZWQgaWYgdGhlIHNvdXJjZSBhZGRyZXNzIHNlbmRzIGEgUGF5bWVudENoYW5uZWxGdW5kIHRyYW5zYWN0aW9uLlxuICAgIGNoYW5uZWxBbW91bnREcm9wczpcbiAgICAgICAgICBuZXcgQmlnTnVtYmVyKGZpbmFsLkFtb3VudCB8fCAwKS50b1N0cmluZygxMCksXG5cbiAgICAvLyBUb3RhbCBYUlAsIGluIGRyb3BzLCBhbHJlYWR5IHBhaWQgb3V0IGJ5IHRoZSBjaGFubmVsLlxuICAgIC8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyB2YWx1ZSBhbmQgdGhlIEFtb3VudCBmaWVsZCBpcyBob3cgbXVjaCBYUlAgY2FuIHN0aWxsXG4gICAgLy8gYmUgcGFpZCB0byB0aGUgZGVzdGluYXRpb24gYWRkcmVzcyB3aXRoIFBheW1lbnRDaGFubmVsQ2xhaW0gdHJhbnNhY3Rpb25zLlxuICAgIC8vIElmIHRoZSBjaGFubmVsIGNsb3NlcywgdGhlIHJlbWFpbmluZyBkaWZmZXJlbmNlIGlzIHJldHVybmVkIHRvIHRoZSBzb3VyY2UgYWRkcmVzcy5cbiAgICBjaGFubmVsQmFsYW5jZURyb3BzOlxuICAgICAgICAgIG5ldyBCaWdOdW1iZXIoZmluYWwuQmFsYW5jZSB8fCAwKS50b1N0cmluZygxMClcbiAgfVxuXG4gIGlmIChwcmV2LkFtb3VudCkge1xuICAgIC8vIFRoZSBjaGFuZ2UgaW4gdGhlIG51bWJlciBvZiBYUlAgZHJvcHMgYWxsb2NhdGVkIHRvIHRoaXMgY2hhbm5lbC5cbiAgICAvLyBUaGlzIGlzIHBvc2l0aXZlIGlmIHRoaXMgaXMgYSBQYXltZW50Q2hhbm5lbEZ1bmQgdHJhbnNhY3Rpb24uXG4gICAgc3VtbWFyeS5jaGFubmVsQW1vdW50Q2hhbmdlRHJvcHMgPSBuZXcgQmlnTnVtYmVyKGZpbmFsLkFtb3VudClcbiAgICAgIC5taW51cyhuZXcgQmlnTnVtYmVyKHByZXYuQW1vdW50IHx8IDApKVxuICAgICAgLnRvU3RyaW5nKDEwKVxuICB9XG5cbiAgaWYgKHByZXYuQmFsYW5jZSkge1xuICAgIC8vIFRoZSBjaGFuZ2UgaW4gdGhlIG51bWJlciBvZiBYUlAgZHJvcHMgYWxyZWFkeSBwYWlkIG91dCBieSB0aGUgY2hhbm5lbC5cbiAgICBzdW1tYXJ5LmNoYW5uZWxCYWxhbmNlQ2hhbmdlRHJvcHMgPSBuZXcgQmlnTnVtYmVyKGZpbmFsLkJhbGFuY2UpXG4gICAgICAubWludXMobmV3IEJpZ051bWJlcihwcmV2LkJhbGFuY2UgfHwgMCkpXG4gICAgICAudG9TdHJpbmcoMTApXG4gIH1cblxuICBpZiAobm9kZS5QcmV2aW91c1R4bklEKSB7XG4gICAgLy8gVGhlIGlkZW50aWZ5aW5nIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIHRoYXRcbiAgICAvLyBtb3N0IHJlY2VudGx5IG1vZGlmaWVkIHRoaXMgcGF5bWVudCBjaGFubmVsIG9iamVjdC5cbiAgICAvLyBZb3UgY2FuIHVzZSB0aGlzIHRvIHJldHJpZXZlIHRoZSBvYmplY3QncyBoaXN0b3J5LlxuICAgIHN1bW1hcnkucHJldmlvdXNUeG5JZCA9IG5vZGUuUHJldmlvdXNUeG5JRFxuICB9XG5cbiAgcmV0dXJuIHN1bW1hcnlcbn1cblxuZnVuY3Rpb24gcGFyc2VDaGFubmVsQ2hhbmdlcyhtZXRhZGF0YSkge1xuICBjb25zdCBwYXltZW50Q2hhbm5lbHMgPSBub3JtYWxpemVOb2RlcyhtZXRhZGF0YSlcbiAgICAuZmlsdGVyKG4gPT4ge1xuICAgICAgcmV0dXJuIG4uZW50cnlUeXBlID09PSAnUGF5Q2hhbm5lbCdcbiAgICB9KVxuXG4gIHJldHVybiAocGF5bWVudENoYW5uZWxzLmxlbmd0aCA9PT0gMSkgP1xuICAgIHN1bW1hcml6ZVBheW1lbnRDaGFubmVsKHBheW1lbnRDaGFubmVsc1swXSkgOlxuICAgIHVuZGVmaW5lZFxufVxuXG5tb2R1bGUuZXhwb3J0cy5wYXJzZUNoYW5uZWxDaGFuZ2VzID0gcGFyc2VDaGFubmVsQ2hhbmdlc1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlQmFsYW5jZUNoYW5nZXMgPVxuICByZXF1aXJlKCcuL2JhbGFuY2VjaGFuZ2VzJykucGFyc2VCYWxhbmNlQ2hhbmdlc1xubW9kdWxlLmV4cG9ydHMucGFyc2VGaW5hbEJhbGFuY2VzID1cbiAgcmVxdWlyZSgnLi9iYWxhbmNlY2hhbmdlcycpLnBhcnNlRmluYWxCYWxhbmNlc1xubW9kdWxlLmV4cG9ydHMucGFyc2VPcmRlcmJvb2tDaGFuZ2VzID1cbiAgcmVxdWlyZSgnLi9vcmRlcmJvb2tjaGFuZ2VzJykucGFyc2VPcmRlcmJvb2tDaGFuZ2VzXG5tb2R1bGUuZXhwb3J0cy5nZXRBZmZlY3RlZEFjY291bnRzID1cbiAgcmVxdWlyZSgnLi91dGlscycpLmdldEFmZmVjdGVkQWNjb3VudHNcbm1vZHVsZS5leHBvcnRzLnBhcnNlQ2hhbm5lbENoYW5nZXMgPVxuICByZXF1aXJlKCcuL2NoYW5uZWxjaGFuZ2VzJykucGFyc2VDaGFubmVsQ2hhbmdlc1xuIiwiJ3VzZSBzdHJpY3QnXG52YXIgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJylcbnZhciBHbG9iYWxCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKVxudmFyIEJpZ051bWJlciA9IEdsb2JhbEJpZ051bWJlci5jbG9uZSh7REVDSU1BTF9QTEFDRVM6IDQwfSlcbnZhciBwYXJzZVF1YWxpdHkgPSByZXF1aXJlKCcuL3F1YWxpdHknKVxuXG52YXIgbHNmU2VsbCA9IDB4MDAwMjAwMDAgLy8gc2VlIFwibHNmU2VsbFwiIGZsYWcgaW4gcmlwcGxlZCBzb3VyY2UgY29kZVxuXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWQob2JqKSB7XG4gIHJldHVybiBfLm9taXRCeShvYmosIF8uaXNVbmRlZmluZWQpXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPcmRlckNoYW5nZShvcmRlcikge1xuICB2YXIgdGFrZXJHZXRzID0gb3JkZXIudGFrZXJfZ2V0c1xuICB2YXIgdGFrZXJQYXlzID0gb3JkZXIudGFrZXJfcGF5c1xuICB2YXIgZGlyZWN0aW9uID0gb3JkZXIuc2VsbCA/ICdzZWxsJyA6ICdidXknXG4gIHZhciBxdWFudGl0eSA9IChkaXJlY3Rpb24gPT09ICdidXknKSA/IHRha2VyUGF5cyA6IHRha2VyR2V0c1xuICB2YXIgdG90YWxQcmljZSA9IChkaXJlY3Rpb24gPT09ICdidXknKSA/IHRha2VyR2V0cyA6IHRha2VyUGF5c1xuICByZXR1cm4gcmVtb3ZlVW5kZWZpbmVkKHtcbiAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICBxdWFudGl0eTogcXVhbnRpdHksXG4gICAgdG90YWxQcmljZTogdG90YWxQcmljZSxcbiAgICBzZXF1ZW5jZTogb3JkZXIuc2VxdWVuY2UsXG4gICAgc3RhdHVzOiBvcmRlci5zdGF0dXMsXG4gICAgbWFrZXJFeGNoYW5nZVJhdGU6IG9yZGVyLnF1YWxpdHksXG4gICAgZXhwaXJhdGlvblRpbWU6IG9yZGVyLmV4cGlyYXRpb25cbiAgfSlcbn1cblxuZnVuY3Rpb24gcmlwcGxlVG9Vbml4VGltZXN0YW1wKHJwZXBvY2gpIHtcbiAgcmV0dXJuIChycGVwb2NoICsgMHgzODZENDM4MCkgKiAxMDAwXG59XG5cbmZ1bmN0aW9uIGdldEV4cGlyYXRpb25UaW1lKG5vZGUpIHtcbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gbm9kZS5maW5hbEZpZWxkcy5FeHBpcmF0aW9uIHx8IG5vZGUubmV3RmllbGRzLkV4cGlyYXRpb25cbiAgaWYgKGV4cGlyYXRpb25UaW1lID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgcmV0dXJuIChuZXcgRGF0ZShyaXBwbGVUb1VuaXhUaW1lc3RhbXAoZXhwaXJhdGlvblRpbWUpKSkudG9JU09TdHJpbmcoKVxufVxuXG5mdW5jdGlvbiBnZXRRdWFsaXR5KG5vZGUpIHtcbiAgdmFyIHRha2VyR2V0cyA9IG5vZGUuZmluYWxGaWVsZHMuVGFrZXJHZXRzIHx8IG5vZGUubmV3RmllbGRzLlRha2VyR2V0c1xuICB2YXIgdGFrZXJQYXlzID0gbm9kZS5maW5hbEZpZWxkcy5UYWtlclBheXMgfHwgbm9kZS5uZXdGaWVsZHMuVGFrZXJQYXlzXG4gIHZhciB0YWtlckdldHNDdXJyZW5jeSA9IHRha2VyR2V0cy5jdXJyZW5jeSB8fCAnWFJQJ1xuICB2YXIgdGFrZXJQYXlzQ3VycmVuY3kgPSB0YWtlclBheXMuY3VycmVuY3kgfHwgJ1hSUCdcbiAgdmFyIGJvb2tEaXJlY3RvcnkgPSBub2RlLmZpbmFsRmllbGRzLkJvb2tEaXJlY3RvcnlcbiAgICB8fCBub2RlLm5ld0ZpZWxkcy5Cb29rRGlyZWN0b3J5XG4gIHZhciBxdWFsaXR5SGV4ID0gYm9va0RpcmVjdG9yeS5zdWJzdHJpbmcoYm9va0RpcmVjdG9yeS5sZW5ndGggLSAxNilcbiAgcmV0dXJuIHBhcnNlUXVhbGl0eShxdWFsaXR5SGV4LCB0YWtlckdldHNDdXJyZW5jeSwgdGFrZXJQYXlzQ3VycmVuY3kpXG59XG5cbmZ1bmN0aW9uIHBhcnNlT3JkZXJTdGF0dXMobm9kZSkge1xuICBpZiAobm9kZS5kaWZmVHlwZSA9PT0gJ0NyZWF0ZWROb2RlJykge1xuICAgIC8vIFwic3VibWl0dGVkXCIgaXMgbW9yZSBjb252ZW50aW9uYWwsIGJ1dCBjb3VsZCBiZSBjb25mdXNpbmcgaW4gdGhlXG4gICAgLy8gY29udGV4dCBvZiBSaXBwbGVcbiAgICByZXR1cm4gJ2NyZWF0ZWQnXG4gIH1cblxuICBpZiAobm9kZS5kaWZmVHlwZSA9PT0gJ01vZGlmaWVkTm9kZScpIHtcbiAgICByZXR1cm4gJ3BhcnRpYWxseS1maWxsZWQnXG4gIH1cblxuICBpZiAobm9kZS5kaWZmVHlwZSA9PT0gJ0RlbGV0ZWROb2RlJykge1xuICAgIC8vIEEgZmlsbGVkIG9yZGVyIGhhcyBwcmV2aW91cyBmaWVsZHNcbiAgICBpZiAobm9kZS5wcmV2aW91c0ZpZWxkcy5oYXNPd25Qcm9wZXJ0eSgnVGFrZXJQYXlzJykpIHtcbiAgICAgIHJldHVybiAnZmlsbGVkJ1xuICAgIH1cblxuICAgIC8vIEEgY2FuY2VsbGVkIG9yZGVyIGhhcyBubyBwcmV2aW91cyBmaWVsZHNcbiAgICAvLyBnb29nbGUgc2VhcmNoIGZvciBcImNhbmNlbGxlZCBvcmRlclwiIHNob3dzIDV4IG1vcmUgcmVzdWx0cyB0aGFuXG4gICAgLy8gXCJjYW5jZWxlZCBvcmRlclwiLCBldmVuIHRob3VnaCBib3RoIHNwZWxsaW5ncyBhcmUgY29ycmVjdFxuICAgIHJldHVybiAnY2FuY2VsbGVkJ1xuICB9XG4gIHJldHVybiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlRGVsdGEoZmluYWxBbW91bnQsIHByZXZpb3VzQW1vdW50KSB7XG4gIGlmIChwcmV2aW91c0Ftb3VudCkge1xuICAgIHZhciBmaW5hbFZhbHVlID0gbmV3IEJpZ051bWJlcihmaW5hbEFtb3VudC52YWx1ZSlcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IG5ldyBCaWdOdW1iZXIocHJldmlvdXNBbW91bnQudmFsdWUpXG4gICAgcmV0dXJuIGZpbmFsVmFsdWUubWludXMocHJldmlvdXNWYWx1ZSkuYWJzKCkudG9TdHJpbmcoKVxuICB9XG4gIHJldHVybiAnMCdcbn1cblxuZnVuY3Rpb24gcGFyc2VDaGFuZ2VBbW91bnQobm9kZSwgdHlwZSkge1xuICB2YXIgc3RhdHVzID0gcGFyc2VPcmRlclN0YXR1cyhub2RlKVxuXG4gIGlmIChzdGF0dXMgPT09ICdjYW5jZWxsZWQnKSB7XG4gICAgLy8gQ2FuY2VsZWQgb3JkZXJzIGRvIG5vdCBoYXZlIFByZXZpb3VzRmllbGRzOyBGaW5hbEZpZWxkc1xuICAgIC8vIGhhdmUgcG9zaXRpdmUgdmFsdWVzXG4gICAgcmV0dXJuIHV0aWxzLnBhcnNlQ3VycmVuY3lBbW91bnQobm9kZS5maW5hbEZpZWxkc1t0eXBlXSlcbiAgfSBlbHNlIGlmIChzdGF0dXMgPT09ICdjcmVhdGVkJykge1xuICAgIHJldHVybiB1dGlscy5wYXJzZUN1cnJlbmN5QW1vdW50KG5vZGUubmV3RmllbGRzW3R5cGVdKVxuICB9XG4gIHZhciBmaW5hbEFtb3VudCA9IHV0aWxzLnBhcnNlQ3VycmVuY3lBbW91bnQobm9kZS5maW5hbEZpZWxkc1t0eXBlXSlcbiAgdmFyIHByZXZpb3VzQW1vdW50ID0gdXRpbHMucGFyc2VDdXJyZW5jeUFtb3VudChub2RlLnByZXZpb3VzRmllbGRzW3R5cGVdKVxuICB2YXIgdmFsdWUgPSBjYWxjdWxhdGVEZWx0YShmaW5hbEFtb3VudCwgcHJldmlvdXNBbW91bnQpXG4gIHJldHVybiBfLmFzc2lnbih7fSwgZmluYWxBbW91bnQsIHt2YWx1ZTogdmFsdWV9KVxufVxuXG5mdW5jdGlvbiBwYXJzZU9yZGVyQ2hhbmdlKG5vZGUpIHtcbiAgdmFyIG9yZGVyQ2hhbmdlID0gY29udmVydE9yZGVyQ2hhbmdlKHtcbiAgICB0YWtlcl9wYXlzOiBwYXJzZUNoYW5nZUFtb3VudChub2RlLCAnVGFrZXJQYXlzJyksXG4gICAgdGFrZXJfZ2V0czogcGFyc2VDaGFuZ2VBbW91bnQobm9kZSwgJ1Rha2VyR2V0cycpLFxuICAgIHNlbGw6IChub2RlLmZpbmFsRmllbGRzLkZsYWdzICYgbHNmU2VsbCkgIT09IDAsXG4gICAgc2VxdWVuY2U6IG5vZGUuZmluYWxGaWVsZHMuU2VxdWVuY2UgfHwgbm9kZS5uZXdGaWVsZHMuU2VxdWVuY2UsXG4gICAgc3RhdHVzOiBwYXJzZU9yZGVyU3RhdHVzKG5vZGUpLFxuICAgIHF1YWxpdHk6IGdldFF1YWxpdHkobm9kZSksXG4gICAgZXhwaXJhdGlvbjogZ2V0RXhwaXJhdGlvblRpbWUobm9kZSlcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3JkZXJDaGFuZ2UsICdhY2NvdW50Jywge1xuICAgIHZhbHVlOiBub2RlLmZpbmFsRmllbGRzLkFjY291bnQgfHwgbm9kZS5uZXdGaWVsZHMuQWNjb3VudFxuICB9KVxuXG4gIHJldHVybiBvcmRlckNoYW5nZVxufVxuXG5mdW5jdGlvbiBncm91cEJ5QWRkcmVzcyhvcmRlckNoYW5nZXMpIHtcbiAgcmV0dXJuIF8uZ3JvdXBCeShvcmRlckNoYW5nZXMsIGZ1bmN0aW9uKGNoYW5nZSkge1xuICAgIHJldHVybiBjaGFuZ2UuYWNjb3VudFxuICB9KVxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjb21wbGV0ZSBsaXN0IG9mIGV2ZXJ5IE9mZmVyIHRoYXQgY2hhbmdlZCBpbiB0aGUgbGVkZ2VyXG4gKiBhcyBhIHJlc3VsdCBvZiB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gKiBSZXR1cm5zIGNoYW5nZXMgZ3JvdXBlZCBieSBSaXBwbGUgYWNjb3VudC5cbiAqXG4gKiAgQHBhcmFtIHtPYmplY3R9IG1ldGFkYXRhIC0gVHJhbnNhY3Rpb24gbWV0YWRhdGEgYXMgcmV0dXJuIGJ5IHJpcHBsZS1saWJcbiAqICBAcmV0dXJucyB7T2JqZWN0fSAtIE9yZGVyYm9vayBjaGFuZ2VzIGdyb3VwZWQgYnkgUmlwcGxlIGFjY291bnRcbiAqXG4gKi9cbmV4cG9ydHMucGFyc2VPcmRlcmJvb2tDaGFuZ2VzID0gZnVuY3Rpb24gcGFyc2VPcmRlcmJvb2tDaGFuZ2VzKG1ldGFkYXRhKSB7XG4gIHZhciBub2RlcyA9IHV0aWxzLm5vcm1hbGl6ZU5vZGVzKG1ldGFkYXRhKVxuXG4gIHZhciBvcmRlckNoYW5nZXMgPSBfLm1hcChfLmZpbHRlcihub2RlcywgZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBub2RlLmVudHJ5VHlwZSA9PT0gJ09mZmVyJ1xuICB9KSwgcGFyc2VPcmRlckNoYW5nZSlcblxuICByZXR1cm4gZ3JvdXBCeUFkZHJlc3Mob3JkZXJDaGFuZ2VzKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKVxuXG4vKlxuVGhlIHF1YWxpdHksIGFzIHN0b3JlZCBpbiB0aGUgbGFzdCA2NCBiaXRzIG9mIGEgZGlyZWN0b3J5IGluZGV4LCBpcyBzdG9yZWQgYXNcbnRoZSBxdW90aWVudCBvZiBUYWtlclBheXMvVGFrZXJHZXRzLiBJdCB1c2VzIGRyb3BzICgxZS02IFhSUCkgZm9yIFhSUCB2YWx1ZXMuXG4qL1xuXG5mdW5jdGlvbiBhZGp1c3RRdWFsaXR5Rm9yWFJQKHF1YWxpdHksIHRha2VyR2V0c0N1cnJlbmN5LCB0YWtlclBheXNDdXJyZW5jeSkge1xuICB2YXIgbnVtZXJhdG9yU2hpZnQgPSAodGFrZXJQYXlzQ3VycmVuY3kgPT09ICdYUlAnID8gLTYgOiAwKVxuICB2YXIgZGVub21pbmF0b3JTaGlmdCA9ICh0YWtlckdldHNDdXJyZW5jeSA9PT0gJ1hSUCcgPyAtNiA6IDApXG4gIHZhciBzaGlmdCA9IG51bWVyYXRvclNoaWZ0IC0gZGVub21pbmF0b3JTaGlmdFxuICByZXR1cm4gc2hpZnQgPT09IDAgPyAobmV3IEJpZ051bWJlcihxdWFsaXR5KSkudG9TdHJpbmcoKSA6XG4gICAgKG5ldyBCaWdOdW1iZXIocXVhbGl0eSkpLnNoaWZ0ZWRCeShzaGlmdCkudG9TdHJpbmcoKVxufVxuXG5mdW5jdGlvbiBwYXJzZVF1YWxpdHkocXVhbGl0eUhleCwgdGFrZXJHZXRzQ3VycmVuY3ksIHRha2VyUGF5c0N1cnJlbmN5KSB7XG4gIGFzc2VydChxdWFsaXR5SGV4Lmxlbmd0aCA9PT0gMTYpXG4gIHZhciBtYW50aXNzYSA9IG5ldyBCaWdOdW1iZXIocXVhbGl0eUhleC5zdWJzdHJpbmcoMiksIDE2KVxuICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQocXVhbGl0eUhleC5zdWJzdHJpbmcoMCwgMiksIDE2KSAtIDEwMFxuICB2YXIgcXVhbGl0eSA9IG1hbnRpc3NhLnRvU3RyaW5nKCkgKyAnZScgKyBvZmZzZXQudG9TdHJpbmcoKVxuICByZXR1cm4gYWRqdXN0UXVhbGl0eUZvclhSUChxdWFsaXR5LCB0YWtlckdldHNDdXJyZW5jeSwgdGFrZXJQYXlzQ3VycmVuY3kpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2VRdWFsaXR5XG4iLCIndXNlIHN0cmljdCdcbnZhciBfID0gcmVxdWlyZSgnbG9kYXNoJylcbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKVxuXG4vLyBkcm9wcyBpcyBhIGJpZ251bWJlci5qcyBCaWdOdW1iZXJcbmZ1bmN0aW9uIGRyb3BzVG9YUlAoZHJvcHMpIHtcbiAgcmV0dXJuIGRyb3BzLmRpdmlkZWRCeSgxMDAwMDAwKVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVOb2RlKGFmZmVjdGVkTm9kZSkge1xuICB2YXIgZGlmZlR5cGUgPSBPYmplY3Qua2V5cyhhZmZlY3RlZE5vZGUpWzBdXG4gIHZhciBub2RlID0gYWZmZWN0ZWROb2RlW2RpZmZUeXBlXVxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwge1xuICAgIGRpZmZUeXBlOiBkaWZmVHlwZSxcbiAgICBlbnRyeVR5cGU6IG5vZGUuTGVkZ2VyRW50cnlUeXBlLFxuICAgIGxlZGdlckluZGV4OiBub2RlLkxlZGdlckluZGV4LFxuICAgIG5ld0ZpZWxkczogbm9kZS5OZXdGaWVsZHMgfHwge30sXG4gICAgZmluYWxGaWVsZHM6IG5vZGUuRmluYWxGaWVsZHMgfHwge30sXG4gICAgcHJldmlvdXNGaWVsZHM6IG5vZGUuUHJldmlvdXNGaWVsZHMgfHwge31cbiAgfSlcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplTm9kZXMobWV0YWRhdGEpIHtcbiAgaWYgKCFtZXRhZGF0YS5BZmZlY3RlZE5vZGVzKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgcmV0dXJuIG1ldGFkYXRhLkFmZmVjdGVkTm9kZXMubWFwKG5vcm1hbGl6ZU5vZGUpXG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3VycmVuY3lBbW91bnQoY3VycmVuY3lBbW91bnQpIHtcbiAgaWYgKGN1cnJlbmN5QW1vdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbiAgaWYgKHR5cGVvZiBjdXJyZW5jeUFtb3VudCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVuY3k6ICdYUlAnLFxuICAgICAgdmFsdWU6IGRyb3BzVG9YUlAobmV3IEJpZ051bWJlcihjdXJyZW5jeUFtb3VudCkpLnRvU3RyaW5nKClcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGN1cnJlbmN5OiBjdXJyZW5jeUFtb3VudC5jdXJyZW5jeSxcbiAgICBjb3VudGVycGFydHk6IGN1cnJlbmN5QW1vdW50Lmlzc3VlcixcbiAgICB2YWx1ZTogY3VycmVuY3lBbW91bnQudmFsdWVcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0FjY291bnRGaWVsZChmaWVsZE5hbWUpIHtcbiAgdmFyIGZpZWxkTmFtZXMgPSBbJ0FjY291bnQnLCAnT3duZXInLCAnRGVzdGluYXRpb24nLCAnSXNzdWVyJywgJ1RhcmdldCddXG4gIHJldHVybiBfLmluY2x1ZGVzKGZpZWxkTmFtZXMsIGZpZWxkTmFtZSlcbn1cblxuZnVuY3Rpb24gaXNBbW91bnRGaWVsZEFmZmVjdGluZ0lzc3VlcihmaWVsZE5hbWUpIHtcbiAgdmFyIGZpZWxkTmFtZXMgPSBbJ0xvd0xpbWl0JywgJ0hpZ2hMaW1pdCcsICdUYWtlclBheXMnLCAnVGFrZXJHZXRzJ11cbiAgcmV0dXJuIF8uaW5jbHVkZXMoZmllbGROYW1lcywgZmllbGROYW1lKVxufVxuXG5mdW5jdGlvbiBnZXRBZmZlY3RlZEFjY291bnRzKG1ldGFkYXRhKSB7XG4gIHZhciBhY2NvdW50cyA9IFtdXG4gIF8uZm9yRWFjaChub3JtYWxpemVOb2RlcyhtZXRhZGF0YSksIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgZmllbGRzID0gbm9kZS5kaWZmVHlwZSA9PT0gJ0NyZWF0ZWROb2RlJyA/XG4gICAgICBub2RlLm5ld0ZpZWxkcyA6IG5vZGUuZmluYWxGaWVsZHNcbiAgICBfLmZvckVhY2goZmllbGRzLCBmdW5jdGlvbihmaWVsZFZhbHVlLCBmaWVsZE5hbWUpIHtcbiAgICAgIGlmIChpc0FjY291bnRGaWVsZChmaWVsZE5hbWUpKSB7XG4gICAgICAgIGFjY291bnRzLnB1c2goZmllbGRWYWx1ZSlcbiAgICAgIH0gZWxzZSBpZiAoaXNBbW91bnRGaWVsZEFmZmVjdGluZ0lzc3VlcihmaWVsZE5hbWUpICYmIGZpZWxkVmFsdWUuaXNzdWVyKSB7XG4gICAgICAgIGFjY291bnRzLnB1c2goZmllbGRWYWx1ZS5pc3N1ZXIpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbiAgcmV0dXJuIF8udW5pcShhY2NvdW50cylcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJvcHNUb1hSUDogZHJvcHNUb1hSUCxcbiAgbm9ybWFsaXplTm9kZXM6IG5vcm1hbGl6ZU5vZGVzLFxuICBwYXJzZUN1cnJlbmN5QW1vdW50OiBwYXJzZUN1cnJlbmN5QW1vdW50LFxuICBnZXRBZmZlY3RlZEFjY291bnRzOiBnZXRBZmZlY3RlZEFjY291bnRzXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmlwcGxlQVBJID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi9jb21tb25cIik7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci9zZXJ2ZXJcIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2xlZGdlci90cmFuc2FjdGlvblwiKSk7XG5jb25zdCB0cmFuc2FjdGlvbnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9sZWRnZXIvdHJhbnNhY3Rpb25zXCIpKTtcbmNvbnN0IHRydXN0bGluZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9sZWRnZXIvdHJ1c3RsaW5lc1wiKSk7XG5jb25zdCBiYWxhbmNlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2xlZGdlci9iYWxhbmNlc1wiKSk7XG5jb25zdCBiYWxhbmNlX3NoZWV0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGVkZ2VyL2JhbGFuY2Utc2hlZXRcIikpO1xuY29uc3QgcGF0aGZpbmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9sZWRnZXIvcGF0aGZpbmRcIikpO1xuY29uc3Qgb3JkZXJzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGVkZ2VyL29yZGVyc1wiKSk7XG5jb25zdCBvcmRlcmJvb2tfMSA9IHJlcXVpcmUoXCIuL2xlZGdlci9vcmRlcmJvb2tcIik7XG5jb25zdCBzZXR0aW5nc18xID0gcmVxdWlyZShcIi4vbGVkZ2VyL3NldHRpbmdzXCIpO1xuY29uc3QgYWNjb3VudGluZm9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9sZWRnZXIvYWNjb3VudGluZm9cIikpO1xuY29uc3QgYWNjb3VudG9iamVjdHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9sZWRnZXIvYWNjb3VudG9iamVjdHNcIikpO1xuY29uc3QgcGF5bWVudF9jaGFubmVsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGVkZ2VyL3BheW1lbnQtY2hhbm5lbFwiKSk7XG5jb25zdCBwYXltZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24vcGF5bWVudFwiKSk7XG5jb25zdCB0cnVzdGxpbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi90cnVzdGxpbmVcIikpO1xuY29uc3Qgb3JkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi9vcmRlclwiKSk7XG5jb25zdCBvcmRlcmNhbmNlbGxhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uL29yZGVyY2FuY2VsbGF0aW9uXCIpKTtcbmNvbnN0IGVzY3Jvd19jcmVhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uL2VzY3Jvdy1jcmVhdGlvblwiKSk7XG5jb25zdCBlc2Nyb3dfZXhlY3V0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24vZXNjcm93LWV4ZWN1dGlvblwiKSk7XG5jb25zdCBlc2Nyb3dfY2FuY2VsbGF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24vZXNjcm93LWNhbmNlbGxhdGlvblwiKSk7XG5jb25zdCBwYXltZW50X2NoYW5uZWxfY3JlYXRlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24vcGF5bWVudC1jaGFubmVsLWNyZWF0ZVwiKSk7XG5jb25zdCBwYXltZW50X2NoYW5uZWxfZnVuZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uL3BheW1lbnQtY2hhbm5lbC1mdW5kXCIpKTtcbmNvbnN0IHBheW1lbnRfY2hhbm5lbF9jbGFpbV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uL3BheW1lbnQtY2hhbm5lbC1jbGFpbVwiKSk7XG5jb25zdCBjaGVja19jcmVhdGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi9jaGVjay1jcmVhdGVcIikpO1xuY29uc3QgY2hlY2tfY2FuY2VsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24vY2hlY2stY2FuY2VsXCIpKTtcbmNvbnN0IGNoZWNrX2Nhc2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi9jaGVjay1jYXNoXCIpKTtcbmNvbnN0IHNldHRpbmdzXzIgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24vc2V0dGluZ3NcIikpO1xuY29uc3QgdGlja2V0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24vdGlja2V0XCIpKTtcbmNvbnN0IHNpZ25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi9zaWduXCIpKTtcbmNvbnN0IGNvbWJpbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi9jb21iaW5lXCIpKTtcbmNvbnN0IHN1Ym1pdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uL3N1Ym1pdFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vb2ZmbGluZS91dGlsc1wiKTtcbmNvbnN0IGRlcml2ZV8xID0gcmVxdWlyZShcIi4vb2ZmbGluZS9kZXJpdmVcIik7XG5jb25zdCBsZWRnZXJoYXNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb2ZmbGluZS9sZWRnZXJoYXNoXCIpKTtcbmNvbnN0IHNpZ25fcGF5bWVudF9jaGFubmVsX2NsYWltXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb2ZmbGluZS9zaWduLXBheW1lbnQtY2hhbm5lbC1jbGFpbVwiKSk7XG5jb25zdCB2ZXJpZnlfcGF5bWVudF9jaGFubmVsX2NsYWltXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb2ZmbGluZS92ZXJpZnktcGF5bWVudC1jaGFubmVsLWNsYWltXCIpKTtcbmNvbnN0IGxlZGdlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2xlZGdlci9sZWRnZXJcIikpO1xuY29uc3QgcmFuZ2VzZXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jb21tb24vcmFuZ2VzZXRcIikpO1xuY29uc3QgbGVkZ2VyVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vbGVkZ2VyL3V0aWxzXCIpKTtcbmNvbnN0IHRyYW5zYWN0aW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNhY3Rpb24vdXRpbHNcIikpO1xuY29uc3Qgc2NoZW1hVmFsaWRhdG9yID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbW1vbi9zY2hlbWEtdmFsaWRhdG9yXCIpKTtcbmNvbnN0IHNlcnZlcmluZm9fMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9zZXJ2ZXJpbmZvXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL2xlZGdlci91dGlsc1wiKTtcbmNvbnN0IHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEgPSByZXF1aXJlKFwicmlwcGxlLWFkZHJlc3MtY29kZWNcIik7XG5jb25zdCBoYXNoZXNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9oYXNoZXNcIik7XG5jb25zdCB3YWxsZXRfZ2VuZXJhdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3dhbGxldC93YWxsZXQtZ2VuZXJhdGlvblwiKSk7XG5mdW5jdGlvbiBnZXRDb2xsZWN0S2V5RnJvbUNvbW1hbmQoY29tbWFuZCkge1xuICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlICdhY2NvdW50X29mZmVycyc6XG4gICAgICAgIGNhc2UgJ2Jvb2tfb2ZmZXJzJzpcbiAgICAgICAgICAgIHJldHVybiAnb2ZmZXJzJztcbiAgICAgICAgY2FzZSAnYWNjb3VudF9saW5lcyc6XG4gICAgICAgICAgICByZXR1cm4gJ2xpbmVzJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgUmlwcGxlQVBJIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUFkZHJlc3MgPSB1dGlsc18xLmdlbmVyYXRlQWRkcmVzcztcbiAgICAgICAgdGhpcy5nZW5lcmF0ZVhBZGRyZXNzID0gdXRpbHNfMS5nZW5lcmF0ZVhBZGRyZXNzO1xuICAgICAgICB0aGlzLmNvbm5lY3QgPSBzZXJ2ZXJfMS5jb25uZWN0O1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QgPSBzZXJ2ZXJfMS5kaXNjb25uZWN0O1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gc2VydmVyXzEuaXNDb25uZWN0ZWQ7XG4gICAgICAgIHRoaXMuZ2V0U2VydmVySW5mbyA9IHNlcnZlcmluZm9fMS5nZXRTZXJ2ZXJJbmZvO1xuICAgICAgICB0aGlzLmdldEZlZSA9IHNlcnZlcmluZm9fMS5nZXRGZWU7XG4gICAgICAgIHRoaXMuZ2V0TGVkZ2VyVmVyc2lvbiA9IHNlcnZlcl8xLmdldExlZGdlclZlcnNpb247XG4gICAgICAgIHRoaXMuZ2V0VHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbl8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuZ2V0VHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zXzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy5nZXRUcnVzdGxpbmVzID0gdHJ1c3RsaW5lc18xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuZ2V0QmFsYW5jZXMgPSBiYWxhbmNlc18xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuZ2V0QmFsYW5jZVNoZWV0ID0gYmFsYW5jZV9zaGVldF8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuZ2V0UGF0aHMgPSBwYXRoZmluZF8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuZ2V0T3JkZXJib29rID0gb3JkZXJib29rXzEuZ2V0T3JkZXJib29rO1xuICAgICAgICB0aGlzLmdldE9yZGVycyA9IG9yZGVyc18xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuZ2V0U2V0dGluZ3MgPSBzZXR0aW5nc18xLmdldFNldHRpbmdzO1xuICAgICAgICB0aGlzLmdldEFjY291bnRJbmZvID0gYWNjb3VudGluZm9fMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLmdldEFjY291bnRPYmplY3RzID0gYWNjb3VudG9iamVjdHNfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLmdldFBheW1lbnRDaGFubmVsID0gcGF5bWVudF9jaGFubmVsXzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy5nZXRMZWRnZXIgPSBsZWRnZXJfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnBhcnNlQWNjb3VudEZsYWdzID0gc2V0dGluZ3NfMS5wYXJzZUFjY291bnRGbGFncztcbiAgICAgICAgdGhpcy5wcmVwYXJlUGF5bWVudCA9IHBheW1lbnRfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnByZXBhcmVUcnVzdGxpbmUgPSB0cnVzdGxpbmVfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnByZXBhcmVPcmRlciA9IG9yZGVyXzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy5wcmVwYXJlT3JkZXJDYW5jZWxsYXRpb24gPSBvcmRlcmNhbmNlbGxhdGlvbl8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMucHJlcGFyZUVzY3Jvd0NyZWF0aW9uID0gZXNjcm93X2NyZWF0aW9uXzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy5wcmVwYXJlRXNjcm93RXhlY3V0aW9uID0gZXNjcm93X2V4ZWN1dGlvbl8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMucHJlcGFyZUVzY3Jvd0NhbmNlbGxhdGlvbiA9IGVzY3Jvd19jYW5jZWxsYXRpb25fMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnByZXBhcmVQYXltZW50Q2hhbm5lbENyZWF0ZSA9IHBheW1lbnRfY2hhbm5lbF9jcmVhdGVfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnByZXBhcmVQYXltZW50Q2hhbm5lbEZ1bmQgPSBwYXltZW50X2NoYW5uZWxfZnVuZF8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMucHJlcGFyZVBheW1lbnRDaGFubmVsQ2xhaW0gPSBwYXltZW50X2NoYW5uZWxfY2xhaW1fMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnByZXBhcmVDaGVja0NyZWF0ZSA9IGNoZWNrX2NyZWF0ZV8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMucHJlcGFyZUNoZWNrQ2FzaCA9IGNoZWNrX2Nhc2hfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnByZXBhcmVDaGVja0NhbmNlbCA9IGNoZWNrX2NhbmNlbF8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMucHJlcGFyZVRpY2tldENyZWF0ZSA9IHRpY2tldF8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMucHJlcGFyZVNldHRpbmdzID0gc2V0dGluZ3NfMi5kZWZhdWx0O1xuICAgICAgICB0aGlzLnNpZ24gPSBzaWduXzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy5jb21iaW5lID0gY29tYmluZV8xLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMuc3VibWl0ID0gc3VibWl0XzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy5kZXJpdmVLZXlwYWlyID0gZGVyaXZlXzEuZGVyaXZlS2V5cGFpcjtcbiAgICAgICAgdGhpcy5kZXJpdmVBZGRyZXNzID0gZGVyaXZlXzEuZGVyaXZlQWRkcmVzcztcbiAgICAgICAgdGhpcy5jb21wdXRlTGVkZ2VySGFzaCA9IGxlZGdlcmhhc2hfMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnNpZ25QYXltZW50Q2hhbm5lbENsYWltID0gc2lnbl9wYXltZW50X2NoYW5uZWxfY2xhaW1fMS5kZWZhdWx0O1xuICAgICAgICB0aGlzLnZlcmlmeVBheW1lbnRDaGFubmVsQ2xhaW0gPSB2ZXJpZnlfcGF5bWVudF9jaGFubmVsX2NsYWltXzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUZhdWNldFdhbGxldCA9IHdhbGxldF9nZW5lcmF0aW9uXzEuZGVmYXVsdDtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBjb21tb25fMS5lcnJvcnM7XG4gICAgICAgIHRoaXMueHJwVG9Ecm9wcyA9IGNvbW1vbl8xLnhycFRvRHJvcHM7XG4gICAgICAgIHRoaXMuZHJvcHNUb1hycCA9IGNvbW1vbl8xLmRyb3BzVG9YcnA7XG4gICAgICAgIHRoaXMucmlwcGxlVGltZVRvSVNPODYwMSA9IGNvbW1vbl8xLnJpcHBsZVRpbWVUb0lTTzg2MDE7XG4gICAgICAgIHRoaXMuaXNvODYwMVRvUmlwcGxlVGltZSA9IGNvbW1vbl8xLmlzbzg2MDFUb1JpcHBsZVRpbWU7XG4gICAgICAgIHRoaXMudHhGbGFncyA9IGNvbW1vbl8xLnR4RmxhZ3M7XG4gICAgICAgIHRoaXMuYWNjb3VudFNldEZsYWdzID0gY29tbW9uXzEuY29uc3RhbnRzLkFjY291bnRTZXRGbGFncztcbiAgICAgICAgdGhpcy5pc1ZhbGlkQWRkcmVzcyA9IHNjaGVtYVZhbGlkYXRvci5pc1ZhbGlkQWRkcmVzcztcbiAgICAgICAgdGhpcy5pc1ZhbGlkU2VjcmV0ID0gc2NoZW1hVmFsaWRhdG9yLmlzVmFsaWRTZWNyZXQ7XG4gICAgICAgIGNvbW1vbl8xLnZhbGlkYXRlLmFwaU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2ZlZUN1c2hpb24gPSBvcHRpb25zLmZlZUN1c2hpb24gfHwgMS4yO1xuICAgICAgICB0aGlzLl9tYXhGZWVYUlAgPSBvcHRpb25zLm1heEZlZVhSUCB8fCAnMic7XG4gICAgICAgIGNvbnN0IHNlcnZlclVSTCA9IG9wdGlvbnMuc2VydmVyO1xuICAgICAgICBpZiAoc2VydmVyVVJMICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldyBjb21tb25fMS5Db25uZWN0aW9uKHNlcnZlclVSTCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2xlZGdlckNsb3NlZCcsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdsZWRnZXInLCBzZXJ2ZXJfMS5mb3JtYXRMZWRnZXJDbG9zZShtZXNzYWdlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5vbignZXJyb3InLCAoZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UsIGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2Nvbm5lY3RlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2Rpc2Nvbm5lY3RlZCcsIChjb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbmFsQ29kZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmFsQ29kZSA9PT0gMTAwNSB8fCBmaW5hbENvZGUgPT09IDQwMDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxDb2RlID0gMTAwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0ZWQnLCBmaW5hbENvZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBuZXcgY29tbW9uXzEuQ29ubmVjdGlvbihudWxsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0KGNvbW1hbmQsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnJlcXVlc3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IGNvbW1hbmQsIGFjY291bnQ6IHBhcmFtcy5hY2NvdW50ID8gY29tbW9uXzEuZW5zdXJlQ2xhc3NpY0FkZHJlc3MocGFyYW1zLmFjY291bnQpIDogdW5kZWZpbmVkIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhc05leHRQYWdlKGN1cnJlbnRSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gISFjdXJyZW50UmVzcG9uc2UubWFya2VyO1xuICAgIH1cbiAgICByZXF1ZXN0TmV4dFBhZ2UoY29tbWFuZCwgcGFyYW1zID0ge30sIGN1cnJlbnRSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50UmVzcG9uc2UubWFya2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBjb21tb25fMS5lcnJvcnMuTm90Rm91bmRFcnJvcigncmVzcG9uc2UgZG9lcyBub3QgaGF2ZSBhIG5leHQgcGFnZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRQYWdlUGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgbWFya2VyOiBjdXJyZW50UmVzcG9uc2UubWFya2VyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QoY29tbWFuZCwgbmV4dFBhZ2VQYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJlcGFyZVRyYW5zYWN0aW9uKHR4SlNPTiwgaW5zdHJ1Y3Rpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvblV0aWxzLnByZXBhcmVUcmFuc2FjdGlvbih0eEpTT04sIHRoaXMsIGluc3RydWN0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb252ZXJ0U3RyaW5nVG9IZXgoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvblV0aWxzLmNvbnZlcnRTdHJpbmdUb0hleChzdHJpbmcpO1xuICAgIH1cbiAgICBfcmVxdWVzdEFsbChjb21tYW5kLCBwYXJhbXMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0S2V5ID0gb3B0aW9ucy5jb2xsZWN0IHx8IGdldENvbGxlY3RLZXlGcm9tQ29tbWFuZChjb21tYW5kKTtcbiAgICAgICAgICAgIGlmICghY29sbGVjdEtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb21tb25fMS5lcnJvcnMuVmFsaWRhdGlvbkVycm9yKGBubyBjb2xsZWN0IGtleSBmb3IgY29tbWFuZCAke2NvbW1hbmR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb3VudFRvID0gcGFyYW1zLmxpbWl0ICE9IG51bGwgPyBwYXJhbXMubGltaXQgOiBJbmZpbml0eTtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgbWFya2VyID0gcGFyYW1zLm1hcmtlcjtcbiAgICAgICAgICAgIGxldCBsYXN0QmF0Y2hMZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgY291bnRSZW1haW5pbmcgPSB1dGlsc18yLmNsYW1wKGNvdW50VG8gLSBjb3VudCwgMTAsIDQwMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVwZWF0UHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgbGltaXQ6IGNvdW50UmVtYWluaW5nLCBtYXJrZXIgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2luZ2xlUmVzdWx0ID0geWllbGQgdGhpcy5yZXF1ZXN0KGNvbW1hbmQsIHJlcGVhdFByb3BzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsZWN0ZWREYXRhID0gc2luZ2xlUmVzdWx0W2NvbGxlY3RLZXldO1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHNpbmdsZVJlc3VsdFsnbWFya2VyJ107XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNpbmdsZVJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFeHBlY3RlZEZvcm1hdCA9IEFycmF5LmlzQXJyYXkoY29sbGVjdGVkRGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXhwZWN0ZWRGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gY29sbGVjdGVkRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RCYXRjaExlbmd0aCA9IGNvbGxlY3RlZERhdGEubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEJhdGNoTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICghIW1hcmtlciAmJiBjb3VudCA8IGNvdW50VG8gJiYgbGFzdEJhdGNoTGVuZ3RoICE9PSAwKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJpcHBsZUFQSSA9IFJpcHBsZUFQSTtcblJpcHBsZUFQSS5fUFJJVkFURSA9IHtcbiAgICB2YWxpZGF0ZTogY29tbW9uXzEudmFsaWRhdGUsXG4gICAgUmFuZ2VTZXQ6IHJhbmdlc2V0XzEuZGVmYXVsdCxcbiAgICBsZWRnZXJVdGlscyxcbiAgICBzY2hlbWFWYWxpZGF0b3Jcbn07XG5SaXBwbGVBUEkucmVuYW1lQ291bnRlcnBhcnR5VG9Jc3N1ZXIgPSB1dGlsc18yLnJlbmFtZUNvdW50ZXJwYXJ0eVRvSXNzdWVyO1xuUmlwcGxlQVBJLmZvcm1hdEJpZHNBbmRBc2tzID0gb3JkZXJib29rXzEuZm9ybWF0Qmlkc0FuZEFza3M7XG5SaXBwbGVBUEkuZGVyaXZlWEFkZHJlc3MgPSBkZXJpdmVfMS5kZXJpdmVYQWRkcmVzcztcblJpcHBsZUFQSS5kZXJpdmVDbGFzc2ljQWRkcmVzcyA9IGRlcml2ZV8xLmRlcml2ZUFkZHJlc3M7XG5SaXBwbGVBUEkuY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzID0gcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5jbGFzc2ljQWRkcmVzc1RvWEFkZHJlc3M7XG5SaXBwbGVBUEkueEFkZHJlc3NUb0NsYXNzaWNBZGRyZXNzID0gcmlwcGxlX2FkZHJlc3NfY29kZWNfMS54QWRkcmVzc1RvQ2xhc3NpY0FkZHJlc3M7XG5SaXBwbGVBUEkuaXNWYWxpZFhBZGRyZXNzID0gcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5pc1ZhbGlkWEFkZHJlc3M7XG5SaXBwbGVBUEkuaXNWYWxpZENsYXNzaWNBZGRyZXNzID0gcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5pc1ZhbGlkQ2xhc3NpY0FkZHJlc3M7XG5SaXBwbGVBUEkuZW5jb2RlU2VlZCA9IHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZW5jb2RlU2VlZDtcblJpcHBsZUFQSS5kZWNvZGVTZWVkID0gcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5kZWNvZGVTZWVkO1xuUmlwcGxlQVBJLmVuY29kZUFjY291bnRJRCA9IHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZW5jb2RlQWNjb3VudElEO1xuUmlwcGxlQVBJLmRlY29kZUFjY291bnRJRCA9IHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZGVjb2RlQWNjb3VudElEO1xuUmlwcGxlQVBJLmVuY29kZU5vZGVQdWJsaWMgPSByaXBwbGVfYWRkcmVzc19jb2RlY18xLmVuY29kZU5vZGVQdWJsaWM7XG5SaXBwbGVBUEkuZGVjb2RlTm9kZVB1YmxpYyA9IHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZGVjb2RlTm9kZVB1YmxpYztcblJpcHBsZUFQSS5lbmNvZGVBY2NvdW50UHVibGljID0gcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5lbmNvZGVBY2NvdW50UHVibGljO1xuUmlwcGxlQVBJLmRlY29kZUFjY291bnRQdWJsaWMgPSByaXBwbGVfYWRkcmVzc19jb2RlY18xLmRlY29kZUFjY291bnRQdWJsaWM7XG5SaXBwbGVBUEkuZW5jb2RlWEFkZHJlc3MgPSByaXBwbGVfYWRkcmVzc19jb2RlY18xLmVuY29kZVhBZGRyZXNzO1xuUmlwcGxlQVBJLmRlY29kZVhBZGRyZXNzID0gcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5kZWNvZGVYQWRkcmVzcztcblJpcHBsZUFQSS5jb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoID0gaGFzaGVzXzEuY29tcHV0ZUJpbmFyeVRyYW5zYWN0aW9uSGFzaDtcblJpcHBsZUFQSS5jb21wdXRlVHJhbnNhY3Rpb25IYXNoID0gaGFzaGVzXzEuY29tcHV0ZVRyYW5zYWN0aW9uSGFzaDtcblJpcHBsZUFQSS5jb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25TaWduaW5nSGFzaCA9IGhhc2hlc18xLmNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvblNpZ25pbmdIYXNoO1xuUmlwcGxlQVBJLmNvbXB1dGVBY2NvdW50TGVkZ2VyT2JqZWN0SUQgPSBoYXNoZXNfMS5jb21wdXRlQWNjb3VudExlZGdlck9iamVjdElEO1xuUmlwcGxlQVBJLmNvbXB1dGVTaWduZXJMaXN0TGVkZ2VyT2JqZWN0SUQgPSBoYXNoZXNfMS5jb21wdXRlU2lnbmVyTGlzdExlZGdlck9iamVjdElEO1xuUmlwcGxlQVBJLmNvbXB1dGVPcmRlcklEID0gaGFzaGVzXzEuY29tcHV0ZU9yZGVySUQ7XG5SaXBwbGVBUEkuY29tcHV0ZVRydXN0bGluZUhhc2ggPSBoYXNoZXNfMS5jb21wdXRlVHJ1c3RsaW5lSGFzaDtcblJpcHBsZUFQSS5jb21wdXRlVHJhbnNhY3Rpb25UcmVlSGFzaCA9IGhhc2hlc18xLmNvbXB1dGVUcmFuc2FjdGlvblRyZWVIYXNoO1xuUmlwcGxlQVBJLmNvbXB1dGVTdGF0ZVRyZWVIYXNoID0gaGFzaGVzXzEuY29tcHV0ZVN0YXRlVHJlZUhhc2g7XG5SaXBwbGVBUEkuY29tcHV0ZUxlZGdlckhhc2ggPSBsZWRnZXJoYXNoXzEuZGVmYXVsdDtcblJpcHBsZUFQSS5jb21wdXRlRXNjcm93SGFzaCA9IGhhc2hlc18xLmNvbXB1dGVFc2Nyb3dIYXNoO1xuUmlwcGxlQVBJLmNvbXB1dGVQYXltZW50Q2hhbm5lbEhhc2ggPSBoYXNoZXNfMS5jb21wdXRlUGF5bWVudENoYW5uZWxIYXNoO1xuUmlwcGxlQVBJLnR4RmxhZ3MgPSBjb21tb25fMS50eEZsYWdzO1xuUmlwcGxlQVBJLmFjY291bnRTZXRGbGFncyA9IGNvbW1vbl8xLmNvbnN0YW50cy5BY2NvdW50U2V0RmxhZ3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmlwcGxlQVBJQnJvYWRjYXN0ID0gdm9pZCAwO1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiLi9hcGlcIik7XG5jbGFzcyBSaXBwbGVBUElCcm9hZGNhc3QgZXh0ZW5kcyBhcGlfMS5SaXBwbGVBUEkge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlcnMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5sZWRnZXJWZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBhcGlzID0gc2VydmVycy5tYXAoKHNlcnZlcikgPT4gbmV3IGFwaV8xLlJpcHBsZUFQSShPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7IHNlcnZlciB9KSkpO1xuICAgICAgICB0aGlzLl9hcGlzID0gYXBpcztcbiAgICAgICAgdGhpcy5nZXRNZXRob2ROYW1lcygpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmFjZShhcGlzLm1hcCgoYXBpKSA9PiBhcGlbbmFtZV0oLi4uYXJndW1lbnRzKSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoYXBpcy5tYXAoKGFwaSkgPT4gYXBpLmNvbm5lY3QoKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoYXBpcy5tYXAoKGFwaSkgPT4gYXBpLmRpc2Nvbm5lY3QoKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBpcy5tYXAoKGFwaSkgPT4gYXBpLmlzQ29ubmVjdGVkKCkpLmV2ZXJ5KEJvb2xlYW4pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkZWZhdWx0QVBJID0gYXBpc1swXTtcbiAgICAgICAgY29uc3Qgc3luY01ldGhvZHMgPSBbJ3NpZ24nLCAnZ2VuZXJhdGVBZGRyZXNzJywgJ2NvbXB1dGVMZWRnZXJIYXNoJ107XG4gICAgICAgIHN5bmNNZXRob2RzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBkZWZhdWx0QVBJW25hbWVdLmJpbmQoZGVmYXVsdEFQSSk7XG4gICAgICAgIH0pO1xuICAgICAgICBhcGlzLmZvckVhY2goKGFwaSkgPT4ge1xuICAgICAgICAgICAgYXBpLm9uKCdsZWRnZXInLCB0aGlzLm9uTGVkZ2VyRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBhcGkub24oJ2Vycm9yJywgKGVycm9yQ29kZSwgZXJyb3JNZXNzYWdlLCBkYXRhKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UsIGRhdGEpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uTGVkZ2VyRXZlbnQobGVkZ2VyKSB7XG4gICAgICAgIGlmIChsZWRnZXIubGVkZ2VyVmVyc2lvbiA+IHRoaXMubGVkZ2VyVmVyc2lvbiB8fFxuICAgICAgICAgICAgdGhpcy5sZWRnZXJWZXJzaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubGVkZ2VyVmVyc2lvbiA9IGxlZGdlci5sZWRnZXJWZXJzaW9uO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdsZWRnZXInLCBsZWRnZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldE1ldGhvZE5hbWVzKCkge1xuICAgICAgICBjb25zdCBtZXRob2ROYW1lcyA9IFtdO1xuICAgICAgICBjb25zdCByaXBwbGVBUEkgPSB0aGlzLl9hcGlzWzBdO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocmlwcGxlQVBJKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByaXBwbGVBUElbbmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtZXRob2ROYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2ROYW1lcztcbiAgICB9XG59XG5leHBvcnRzLlJpcHBsZUFQSUJyb2FkY2FzdCA9IFJpcHBsZUFQSUJyb2FkY2FzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb2FkY2FzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXhwb25lbnRpYWxCYWNrb2ZmID0gdm9pZCAwO1xuY2xhc3MgRXhwb25lbnRpYWxCYWNrb2ZmIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5mYWN0b3IgPSAyO1xuICAgICAgICB0aGlzLmppdHRlciA9IDA7XG4gICAgICAgIHRoaXMuYXR0ZW1wdHMgPSAwO1xuICAgICAgICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICAgICAgICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICAgIH1cbiAgICBkdXJhdGlvbigpIHtcbiAgICAgICAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICAgICAgICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICAgICAgICAgIHZhciByYW5kID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICAgICAgICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuYXR0ZW1wdHMgPSAwO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhwb25lbnRpYWxCYWNrb2ZmID0gRXhwb25lbnRpYWxCYWNrb2ZmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja29mZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0UHJvdG90eXBlT2YgPSBleHBvcnRzLmdldENvbnN0cnVjdG9yTmFtZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKG9iamVjdCwgcHJvdG90eXBlKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mXG4gICAgICAgID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKG9iamVjdCwgcHJvdG90eXBlKVxuICAgICAgICA6XG4gICAgICAgICAgICAob2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZSk7XG59XG5leHBvcnRzLnNldFByb3RvdHlwZU9mID0gc2V0UHJvdG90eXBlT2Y7XG5mdW5jdGlvbiBnZXRDb25zdHJ1Y3Rvck5hbWUob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdC5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QuY29uc3RydWN0b3IubmFtZTtcbiAgICB9XG4gICAgY29uc3QgY29uc3RydWN0b3JTdHJpbmcgPSBvYmplY3QuY29uc3RydWN0b3IudG9TdHJpbmcoKTtcbiAgICBjb25zdCBmdW5jdGlvbkNvbnN0cnVjdG9yID0gY29uc3RydWN0b3JTdHJpbmcubWF0Y2goL15mdW5jdGlvblxccysoW14oXSopLyk7XG4gICAgY29uc3QgY2xhc3NDb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yU3RyaW5nLm1hdGNoKC9eY2xhc3NcXHMoW15cXHNdKikvKTtcbiAgICByZXR1cm4gZnVuY3Rpb25Db25zdHJ1Y3RvciA/IGZ1bmN0aW9uQ29uc3RydWN0b3JbMV0gOiBjbGFzc0NvbnN0cnVjdG9yWzFdO1xufVxuZXhwb3J0cy5nZXRDb25zdHJ1Y3Rvck5hbWUgPSBnZXRDb25zdHJ1Y3Rvck5hbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLWhhY2tzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25uZWN0aW9uID0gdm9pZCAwO1xuY29uc3QgXyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibG9kYXNoXCIpKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHdzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIndzXCIpKTtcbmNvbnN0IHJhbmdlc2V0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmFuZ2VzZXRcIikpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBiYWNrb2ZmXzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmXCIpO1xuY29uc3QgSU5URU5USU9OQUxfRElTQ09OTkVDVF9DT0RFID0gNDAwMDtcbmZ1bmN0aW9uIGNyZWF0ZVdlYlNvY2tldCh1cmwsIGNvbmZpZykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICBpZiAoY29uZmlnLnByb3h5ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVVJMID0gdXJsXzEucGFyc2UodXJsKTtcbiAgICAgICAgY29uc3QgcGFyc2VkUHJveHlVUkwgPSB1cmxfMS5wYXJzZShjb25maWcucHJveHkpO1xuICAgICAgICBjb25zdCBwcm94eU92ZXJyaWRlcyA9IF8ub21pdEJ5KHtcbiAgICAgICAgICAgIHNlY3VyZUVuZHBvaW50OiBwYXJzZWRVUkwucHJvdG9jb2wgPT09ICd3c3M6JyxcbiAgICAgICAgICAgIHNlY3VyZVByb3h5OiBwYXJzZWRQcm94eVVSTC5wcm90b2NvbCA9PT0gJ2h0dHBzOicsXG4gICAgICAgICAgICBhdXRoOiBjb25maWcucHJveHlBdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgY2E6IGNvbmZpZy50cnVzdGVkQ2VydGlmaWNhdGVzLFxuICAgICAgICAgICAga2V5OiBjb25maWcua2V5LFxuICAgICAgICAgICAgcGFzc3BocmFzZTogY29uZmlnLnBhc3NwaHJhc2UsXG4gICAgICAgICAgICBjZXJ0OiBjb25maWcuY2VydGlmaWNhdGVcbiAgICAgICAgfSwgKHZhbHVlKSA9PiB2YWx1ZSA9PSBudWxsKTtcbiAgICAgICAgY29uc3QgcHJveHlPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkUHJveHlVUkwsIHByb3h5T3ZlcnJpZGVzKTtcbiAgICAgICAgbGV0IEh0dHBzUHJveHlBZ2VudDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEh0dHBzUHJveHlBZ2VudCA9IHJlcXVpcmUoJ2h0dHBzLXByb3h5LWFnZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wicHJveHlcIiBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgYnJvd3NlcicpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuYWdlbnQgPSBuZXcgSHR0cHNQcm94eUFnZW50KHByb3h5T3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChjb25maWcuYXV0aG9yaXphdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IEJ1ZmZlci5mcm9tKGNvbmZpZy5hdXRob3JpemF0aW9uKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVycyA9IHsgQXV0aG9yaXphdGlvbjogYEJhc2ljICR7YmFzZTY0fWAgfTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9uc092ZXJyaWRlcyA9IF8ub21pdEJ5KHtcbiAgICAgICAgY2E6IGNvbmZpZy50cnVzdGVkQ2VydGlmaWNhdGVzLFxuICAgICAgICBrZXk6IGNvbmZpZy5rZXksXG4gICAgICAgIHBhc3NwaHJhc2U6IGNvbmZpZy5wYXNzcGhyYXNlLFxuICAgICAgICBjZXJ0OiBjb25maWcuY2VydGlmaWNhdGVcbiAgICB9LCAodmFsdWUpID0+IHZhbHVlID09IG51bGwpO1xuICAgIGNvbnN0IHdlYnNvY2tldE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCBvcHRpb25zT3ZlcnJpZGVzKTtcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBuZXcgd3NfMS5kZWZhdWx0KHVybCwgbnVsbCwgd2Vic29ja2V0T3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiB3ZWJzb2NrZXQuc2V0TWF4TGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdlYnNvY2tldC5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuICAgIH1cbiAgICByZXR1cm4gd2Vic29ja2V0O1xufVxuZnVuY3Rpb24gd2Vic29ja2V0U2VuZEFzeW5jKHdzLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgd3Muc2VuZChtZXNzYWdlLCB1bmRlZmluZWQsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnNfMS5EaXNjb25uZWN0ZWRFcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmNsYXNzIExlZGdlckhpc3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmZlZUJhc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmZlZVJlZiA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0VmVyc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzZXJ2ZUJhc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmF2YWlsYWJsZVZlcnNpb25zID0gbmV3IHJhbmdlc2V0XzEuZGVmYXVsdCgpO1xuICAgIH1cbiAgICBoYXNWZXJzaW9uKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlVmVyc2lvbnMuY29udGFpbnNWYWx1ZSh2ZXJzaW9uKTtcbiAgICB9XG4gICAgaGFzVmVyc2lvbnMobG93VmVyc2lvbiwgaGlnaFZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXZhaWxhYmxlVmVyc2lvbnMuY29udGFpbnNSYW5nZShsb3dWZXJzaW9uLCBoaWdoVmVyc2lvbik7XG4gICAgfVxuICAgIHVwZGF0ZShsZWRnZXJNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZmVlQmFzZSA9IGxlZGdlck1lc3NhZ2UuZmVlX2Jhc2U7XG4gICAgICAgIHRoaXMuZmVlUmVmID0gbGVkZ2VyTWVzc2FnZS5mZWVfcmVmO1xuICAgICAgICB0aGlzLmxhdGVzdFZlcnNpb24gPSBsZWRnZXJNZXNzYWdlLmxlZGdlcl9pbmRleDtcbiAgICAgICAgdGhpcy5yZXNlcnZlQmFzZSA9IGxlZGdlck1lc3NhZ2UucmVzZXJ2ZV9iYXNlO1xuICAgICAgICBpZiAobGVkZ2VyTWVzc2FnZS52YWxpZGF0ZWRfbGVkZ2Vycykge1xuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVWZXJzaW9ucy5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVWZXJzaW9ucy5wYXJzZUFuZEFkZFJhbmdlcyhsZWRnZXJNZXNzYWdlLnZhbGlkYXRlZF9sZWRnZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXZhaWxhYmxlVmVyc2lvbnMuYWRkVmFsdWUodGhpcy5sYXRlc3RWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENvbm5lY3Rpb25NYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlc0F3YWl0aW5nQ29ubmVjdGlvbiA9IFtdO1xuICAgIH1cbiAgICByZXNvbHZlQWxsQXdhaXRpbmcoKSB7XG4gICAgICAgIHRoaXMucHJvbWlzZXNBd2FpdGluZ0Nvbm5lY3Rpb24ubWFwKCh7IHJlc29sdmUgfSkgPT4gcmVzb2x2ZSgpKTtcbiAgICAgICAgdGhpcy5wcm9taXNlc0F3YWl0aW5nQ29ubmVjdGlvbiA9IFtdO1xuICAgIH1cbiAgICByZWplY3RBbGxBd2FpdGluZyhlcnJvcikge1xuICAgICAgICB0aGlzLnByb21pc2VzQXdhaXRpbmdDb25uZWN0aW9uLm1hcCgoeyByZWplY3QgfSkgPT4gcmVqZWN0KGVycm9yKSk7XG4gICAgICAgIHRoaXMucHJvbWlzZXNBd2FpdGluZ0Nvbm5lY3Rpb24gPSBbXTtcbiAgICB9XG4gICAgYXdhaXRDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9taXNlc0F3YWl0aW5nQ29ubmVjdGlvbi5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBSZXF1ZXN0TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubmV4dElkID0gMDtcbiAgICAgICAgdGhpcy5wcm9taXNlc0F3YWl0aW5nUmVzcG9uc2UgPSBbXTtcbiAgICB9XG4gICAgY2FuY2VsKGlkKSB7XG4gICAgICAgIGNvbnN0IHsgdGltZXIgfSA9IHRoaXMucHJvbWlzZXNBd2FpdGluZ1Jlc3BvbnNlW2lkXTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucHJvbWlzZXNBd2FpdGluZ1Jlc3BvbnNlW2lkXTtcbiAgICB9XG4gICAgcmVzb2x2ZShpZCwgZGF0YSkge1xuICAgICAgICBjb25zdCB7IHRpbWVyLCByZXNvbHZlIH0gPSB0aGlzLnByb21pc2VzQXdhaXRpbmdSZXNwb25zZVtpZF07XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb21pc2VzQXdhaXRpbmdSZXNwb25zZVtpZF07XG4gICAgfVxuICAgIHJlamVjdChpZCwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyB0aW1lciwgcmVqZWN0IH0gPSB0aGlzLnByb21pc2VzQXdhaXRpbmdSZXNwb25zZVtpZF07XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb21pc2VzQXdhaXRpbmdSZXNwb25zZVtpZF07XG4gICAgfVxuICAgIHJlamVjdEFsbChlcnJvcikge1xuICAgICAgICB0aGlzLnByb21pc2VzQXdhaXRpbmdSZXNwb25zZS5mb3JFYWNoKChfLCBpZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QoaWQsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVJlcXVlc3QoZGF0YSwgdGltZW91dCkge1xuICAgICAgICBjb25zdCBuZXdJZCA9IHRoaXMubmV4dElkKys7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IGlkOiBuZXdJZCB9KSk7XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlamVjdChuZXdJZCwgbmV3IGVycm9yc18xLlRpbWVvdXRFcnJvcigpKSwgdGltZW91dCk7XG4gICAgICAgIGlmICh0aW1lci51bnJlZikge1xuICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9taXNlc0F3YWl0aW5nUmVzcG9uc2VbbmV3SWRdID0geyByZXNvbHZlLCByZWplY3QsIHRpbWVyIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gW25ld0lkLCBuZXdEYXRhLCBuZXdQcm9taXNlXTtcbiAgICB9XG4gICAgaGFuZGxlUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoZGF0YS5pZCkgfHwgZGF0YS5pZCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5SZXNwb25zZUZvcm1hdEVycm9yKCd2YWxpZCBpZCBub3QgZm91bmQgaW4gcmVzcG9uc2UnLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucHJvbWlzZXNBd2FpdGluZ1Jlc3BvbnNlW2RhdGEuaWRdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBlcnJvcnNfMS5SaXBwbGVkRXJyb3IoZGF0YS5lcnJvcl9tZXNzYWdlIHx8IGRhdGEuZXJyb3IsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QoZGF0YS5pZCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnN0YXR1cyAhPT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBlcnJvcnNfMS5SZXNwb25zZUZvcm1hdEVycm9yKGB1bnJlY29nbml6ZWQgc3RhdHVzOiAke2RhdGEuc3RhdHVzfWAsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QoZGF0YS5pZCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb2x2ZShkYXRhLmlkLCBkYXRhLnJlc3VsdCk7XG4gICAgfVxufVxuY2xhc3MgQ29ubmVjdGlvbiBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IodXJsLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fd3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RUaW1lb3V0SUQgPSBudWxsO1xuICAgICAgICB0aGlzLl9oZWFydGJlYXRJbnRlcnZhbElEID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmV0cnlDb25uZWN0aW9uQmFja29mZiA9IG5ldyBiYWNrb2ZmXzEuRXhwb25lbnRpYWxCYWNrb2ZmKHtcbiAgICAgICAgICAgIG1pbjogMTAwLFxuICAgICAgICAgICAgbWF4OiA2MCAqIDEwMDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3RyYWNlID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLl9sZWRnZXIgPSBuZXcgTGVkZ2VySGlzdG9yeSgpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IG5ldyBSZXF1ZXN0TWFuYWdlcigpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBDb25uZWN0aW9uTWFuYWdlcigpO1xuICAgICAgICB0aGlzLl9jbGVhckhlYXJ0YmVhdEludGVydmFsID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9oZWFydGJlYXRJbnRlcnZhbElEKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc3RhcnRIZWFydGJlYXRJbnRlcnZhbCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFySGVhcnRiZWF0SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgIHRoaXMuX2hlYXJ0YmVhdEludGVydmFsSUQgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLl9oZWFydGJlYXQoKSwgdGhpcy5fY29uZmlnLnRpbWVvdXQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9oZWFydGJlYXQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgY29tbWFuZDogJ3BpbmcnIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWNvbm5lY3QoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsICdyZWNvbm5lY3QnLCBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25Db25uZWN0aW9uRmFpbGVkID0gKGVycm9yT3JDb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fd3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93cy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93cy5vbignZXJyb3InLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd3MuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yT3JDb2RlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25NYW5hZ2VyLnJlamVjdEFsbEF3YWl0aW5nKG5ldyBlcnJvcnNfMS5Ob3RDb25uZWN0ZWRFcnJvcihgQ29ubmVjdGlvbiBmYWlsZWQgd2l0aCBjb2RlICR7ZXJyb3JPckNvZGV9LmAsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JPckNvZGVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvck9yQ29kZSAmJiBlcnJvck9yQ29kZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbk1hbmFnZXIucmVqZWN0QWxsQXdhaXRpbmcobmV3IGVycm9yc18xLk5vdENvbm5lY3RlZEVycm9yKGVycm9yT3JDb2RlLm1lc3NhZ2UsIGVycm9yT3JDb2RlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uTWFuYWdlci5yZWplY3RBbGxBd2FpdGluZyhuZXcgZXJyb3JzXzEuTm90Q29ubmVjdGVkRXJyb3IoJ0Nvbm5lY3Rpb24gZmFpbGVkLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyB0aW1lb3V0OiAyMCAqIDEwMDAsIGNvbm5lY3Rpb25UaW1lb3V0OiA1ICogMTAwMCB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFjZSA9IG9wdGlvbnMudHJhY2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy50cmFjZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2UgPSBjb25zb2xlLmxvZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fdHJhY2UoJ3JlY2VpdmUnLCBtZXNzYWdlKTtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCAnYmFkTWVzc2FnZScsIGVycm9yLm1lc3NhZ2UsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT0gbnVsbCAmJiBkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZGF0YS5lcnJvciwgZGF0YS5lcnJvcl9tZXNzYWdlLCBkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50eXBlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZGF0YS50eXBlLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnbGVkZ2VyQ2xvc2VkJykge1xuICAgICAgICAgICAgdGhpcy5fbGVkZ2VyLnVwZGF0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS50eXBlID09PSAncmVzcG9uc2UnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLmhhbmRsZVJlc3BvbnNlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsICdiYWRNZXNzYWdlJywgZXJyb3IubWVzc2FnZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IF9zdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dzID8gdGhpcy5fd3MucmVhZHlTdGF0ZSA6IHdzXzEuZGVmYXVsdC5DTE9TRUQ7XG4gICAgfVxuICAgIGdldCBfc2hvdWxkQmVDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cyAhPT0gbnVsbDtcbiAgICB9XG4gICAgX3dhaXRGb3JSZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2hvdWxkQmVDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IGVycm9yc18xLk5vdENvbm5lY3RlZEVycm9yKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fc3RhdGUgPT09IHdzXzEuZGVmYXVsdC5PUEVOKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdjb25uZWN0ZWQnLCAoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3N1YnNjcmliZVRvTGVkZ2VyKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgY29tbWFuZDogJ3N1YnNjcmliZScsXG4gICAgICAgICAgICAgICAgc3RyZWFtczogWydsZWRnZXInXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoXy5pc0VtcHR5KGRhdGEpIHx8ICFkYXRhLmxlZGdlcl9pbmRleCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5SaXBwbGVkTm90SW5pdGlhbGl6ZWRFcnJvcignUmlwcGxlZCBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sZWRnZXIudXBkYXRlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZSA9PT0gd3NfMS5kZWZhdWx0Lk9QRU47XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IHdzXzEuZGVmYXVsdC5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvbk1hbmFnZXIuYXdhaXRDb25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl91cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3JzXzEuQ29ubmVjdGlvbkVycm9yKCdDYW5ub3QgY29ubmVjdCBiZWNhdXNlIG5vIHNlcnZlciB3YXMgc3BlY2lmaWVkJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl93cykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnNfMS5SaXBwbGVFcnJvcignV2Vic29ja2V0IGNvbm5lY3Rpb24gbmV2ZXIgY2xlYW5lZCB1cC4nLCB7XG4gICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuX3N0YXRlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29ubmVjdGlvblRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25Db25uZWN0aW9uRmFpbGVkKG5ldyBlcnJvcnNfMS5Db25uZWN0aW9uRXJyb3IoYEVycm9yOiBjb25uZWN0KCkgdGltZWQgb3V0IGFmdGVyICR7dGhpcy5fY29uZmlnLmNvbm5lY3Rpb25UaW1lb3V0fSBtcy4gYCArXG4gICAgICAgICAgICAgICAgYElmIHlvdXIgaW50ZXJuZXQgY29ubmVjdGlvbiBpcyB3b3JraW5nLCB0aGUgcmlwcGxlZCBzZXJ2ZXIgbWF5IGJlIGJsb2NrZWQgb3IgaW5hY2Nlc3NpYmxlLiBgICtcbiAgICAgICAgICAgICAgICBgWW91IGNhbiBhbHNvIHRyeSBzZXR0aW5nIHRoZSAnY29ubmVjdGlvblRpbWVvdXQnIG9wdGlvbiBpbiB0aGUgUmlwcGxlQVBJIGNvbnN0cnVjdG9yLmApKTtcbiAgICAgICAgfSwgdGhpcy5fY29uZmlnLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgdGhpcy5fd3MgPSBjcmVhdGVXZWJTb2NrZXQodGhpcy5fdXJsLCB0aGlzLl9jb25maWcpO1xuICAgICAgICB0aGlzLl93cy5vbignZXJyb3InLCB0aGlzLl9vbkNvbm5lY3Rpb25GYWlsZWQpO1xuICAgICAgICB0aGlzLl93cy5vbignZXJyb3InLCAoKSA9PiBjbGVhclRpbWVvdXQoY29ubmVjdGlvblRpbWVvdXRJRCkpO1xuICAgICAgICB0aGlzLl93cy5vbignY2xvc2UnLCB0aGlzLl9vbkNvbm5lY3Rpb25GYWlsZWQpO1xuICAgICAgICB0aGlzLl93cy5vbignY2xvc2UnLCAoKSA9PiBjbGVhclRpbWVvdXQoY29ubmVjdGlvblRpbWVvdXRJRCkpO1xuICAgICAgICB0aGlzLl93cy5vbmNlKCdvcGVuJywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fd3MucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvblRpbWVvdXRJRCk7XG4gICAgICAgICAgICB0aGlzLl93cy5vbignbWVzc2FnZScsIChtZXNzYWdlKSA9PiB0aGlzLl9vbk1lc3NhZ2UobWVzc2FnZSkpO1xuICAgICAgICAgICAgdGhpcy5fd3Mub24oJ2Vycm9yJywgKGVycm9yKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgJ3dlYnNvY2tldCcsIGVycm9yLm1lc3NhZ2UsIGVycm9yKSk7XG4gICAgICAgICAgICB0aGlzLl93cy5vbmNlKCdjbG9zZScsIChjb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xlYXJIZWFydGJlYXRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLnJlamVjdEFsbChuZXcgZXJyb3JzXzEuRGlzY29ubmVjdGVkRXJyb3IoJ3dlYnNvY2tldCB3YXMgY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3RlZCcsIGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBJTlRFTlRJT05BTF9ESVNDT05ORUNUX0NPREUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlUaW1lb3V0ID0gdGhpcy5fcmV0cnlDb25uZWN0aW9uQmFja29mZi5kdXJhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl90cmFjZSgncmVjb25uZWN0JywgYFJldHJ5aW5nIGNvbm5lY3Rpb24gaW4gJHtyZXRyeVRpbWVvdXR9bXMuYCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVjb25uZWN0aW5nJywgdGhpcy5fcmV0cnlDb25uZWN0aW9uQmFja29mZi5hdHRlbXB0cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdFRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgJ3JlY29ubmVjdCcsIGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LCByZXRyeVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXRyeUNvbm5lY3Rpb25CYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fc3Vic2NyaWJlVG9MZWRnZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydEhlYXJ0YmVhdEludGVydmFsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbk1hbmFnZXIucmVzb2x2ZUFsbEF3YWl0aW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25NYW5hZ2VyLnJlamVjdEFsbEF3YWl0aW5nKGVycm9yKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKS5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uTWFuYWdlci5hd2FpdENvbm5lY3Rpb24oKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlY29ubmVjdFRpbWVvdXRJRCk7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdFRpbWVvdXRJRCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gd3NfMS5kZWZhdWx0LkNMT1NFRCB8fCAhdGhpcy5fd3MpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dzLm9uY2UoJ2Nsb3NlJywgKGNvZGUpID0+IHJlc29sdmUoY29kZSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSB3c18xLmRlZmF1bHQuQ0xPU0lORykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dzLmNsb3NlKElOVEVOVElPTkFMX0RJU0NPTk5FQ1RfQ09ERSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlY29ubmVjdCcpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEZlZUJhc2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLl93YWl0Rm9yUmVhZHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZWRnZXIuZmVlQmFzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEZlZVJlZigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX3dhaXRGb3JSZWFkeSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZGdlci5mZWVSZWY7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRMZWRnZXJWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5fd2FpdEZvclJlYWR5KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVkZ2VyLmxhdGVzdFZlcnNpb247XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRSZXNlcnZlQmFzZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX3dhaXRGb3JSZWFkeSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZGdlci5yZXNlcnZlQmFzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhhc0xlZGdlclZlcnNpb25zKGxvd0xlZGdlclZlcnNpb24sIGhpZ2hMZWRnZXJWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIWhpZ2hMZWRnZXJWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzTGVkZ2VyVmVyc2lvbihsb3dMZWRnZXJWZXJzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX3dhaXRGb3JSZWFkeSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZGdlci5oYXNWZXJzaW9ucyhsb3dMZWRnZXJWZXJzaW9uLCBoaWdoTGVkZ2VyVmVyc2lvbik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYXNMZWRnZXJWZXJzaW9uKGxlZGdlclZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuX3dhaXRGb3JSZWFkeSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xlZGdlci5oYXNWZXJzaW9uKGxlZGdlclZlcnNpb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWVzdChyZXF1ZXN0LCB0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Nob3VsZEJlQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbaWQsIG1lc3NhZ2UsIHJlc3BvbnNlUHJvbWlzZV0gPSB0aGlzLl9yZXF1ZXN0TWFuYWdlci5jcmVhdGVSZXF1ZXN0KHJlcXVlc3QsIHRpbWVvdXQgfHwgdGhpcy5fY29uZmlnLnRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fdHJhY2UoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIHdlYnNvY2tldFNlbmRBc3luYyh0aGlzLl93cywgbWVzc2FnZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIucmVqZWN0KGlkLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZVByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgfVxufVxuZXhwb3J0cy5Db25uZWN0aW9uID0gQ29ubmVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbm5lY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFjY291bnRGbGFncyA9IGV4cG9ydHMuQWNjb3VudFNldEZsYWdzID0gZXhwb3J0cy5BY2NvdW50RmllbGRzID0gdm9pZCAwO1xuY29uc3QgdHhmbGFnc18xID0gcmVxdWlyZShcIi4vdHhmbGFnc1wiKTtcbmNvbnN0IGFjY291bnRSb290RmxhZ3MgPSB7XG4gICAgRGVmYXVsdFJpcHBsZTogMHgwMDgwMDAwMCxcbiAgICBEZXBvc2l0QXV0aDogMHgwMTAwMDAwMCxcbiAgICBEaXNhYmxlTWFzdGVyOiAweDAwMTAwMDAwLFxuICAgIERpc2FsbG93WFJQOiAweDAwMDgwMDAwLFxuICAgIEdsb2JhbEZyZWV6ZTogMHgwMDQwMDAwMCxcbiAgICBOb0ZyZWV6ZTogMHgwMDIwMDAwMCxcbiAgICBQYXNzd29yZFNwZW50OiAweDAwMDEwMDAwLFxuICAgIFJlcXVpcmVBdXRoOiAweDAwMDQwMDAwLFxuICAgIFJlcXVpcmVEZXN0VGFnOiAweDAwMDIwMDAwXG59O1xuY29uc3QgQWNjb3VudEZsYWdzID0ge1xuICAgIHBhc3N3b3JkU3BlbnQ6IGFjY291bnRSb290RmxhZ3MuUGFzc3dvcmRTcGVudCxcbiAgICByZXF1aXJlRGVzdGluYXRpb25UYWc6IGFjY291bnRSb290RmxhZ3MuUmVxdWlyZURlc3RUYWcsXG4gICAgcmVxdWlyZUF1dGhvcml6YXRpb246IGFjY291bnRSb290RmxhZ3MuUmVxdWlyZUF1dGgsXG4gICAgZGVwb3NpdEF1dGg6IGFjY291bnRSb290RmxhZ3MuRGVwb3NpdEF1dGgsXG4gICAgZGlzYWxsb3dJbmNvbWluZ1hSUDogYWNjb3VudFJvb3RGbGFncy5EaXNhbGxvd1hSUCxcbiAgICBkaXNhYmxlTWFzdGVyS2V5OiBhY2NvdW50Um9vdEZsYWdzLkRpc2FibGVNYXN0ZXIsXG4gICAgbm9GcmVlemU6IGFjY291bnRSb290RmxhZ3MuTm9GcmVlemUsXG4gICAgZ2xvYmFsRnJlZXplOiBhY2NvdW50Um9vdEZsYWdzLkdsb2JhbEZyZWV6ZSxcbiAgICBkZWZhdWx0UmlwcGxlOiBhY2NvdW50Um9vdEZsYWdzLkRlZmF1bHRSaXBwbGVcbn07XG5leHBvcnRzLkFjY291bnRGbGFncyA9IEFjY291bnRGbGFncztcbmNvbnN0IEFjY291bnRTZXRGbGFncyA9IHtcbiAgICByZXF1aXJlRGVzdGluYXRpb25UYWc6IHR4ZmxhZ3NfMS50eEZsYWdJbmRpY2VzLkFjY291bnRTZXQuYXNmUmVxdWlyZURlc3QsXG4gICAgcmVxdWlyZUF1dGhvcml6YXRpb246IHR4ZmxhZ3NfMS50eEZsYWdJbmRpY2VzLkFjY291bnRTZXQuYXNmUmVxdWlyZUF1dGgsXG4gICAgZGVwb3NpdEF1dGg6IHR4ZmxhZ3NfMS50eEZsYWdJbmRpY2VzLkFjY291bnRTZXQuYXNmRGVwb3NpdEF1dGgsXG4gICAgZGlzYWxsb3dJbmNvbWluZ1hSUDogdHhmbGFnc18xLnR4RmxhZ0luZGljZXMuQWNjb3VudFNldC5hc2ZEaXNhbGxvd1hSUCxcbiAgICBkaXNhYmxlTWFzdGVyS2V5OiB0eGZsYWdzXzEudHhGbGFnSW5kaWNlcy5BY2NvdW50U2V0LmFzZkRpc2FibGVNYXN0ZXIsXG4gICAgZW5hYmxlVHJhbnNhY3Rpb25JRFRyYWNraW5nOiB0eGZsYWdzXzEudHhGbGFnSW5kaWNlcy5BY2NvdW50U2V0LmFzZkFjY291bnRUeG5JRCxcbiAgICBub0ZyZWV6ZTogdHhmbGFnc18xLnR4RmxhZ0luZGljZXMuQWNjb3VudFNldC5hc2ZOb0ZyZWV6ZSxcbiAgICBnbG9iYWxGcmVlemU6IHR4ZmxhZ3NfMS50eEZsYWdJbmRpY2VzLkFjY291bnRTZXQuYXNmR2xvYmFsRnJlZXplLFxuICAgIGRlZmF1bHRSaXBwbGU6IHR4ZmxhZ3NfMS50eEZsYWdJbmRpY2VzLkFjY291bnRTZXQuYXNmRGVmYXVsdFJpcHBsZVxufTtcbmV4cG9ydHMuQWNjb3VudFNldEZsYWdzID0gQWNjb3VudFNldEZsYWdzO1xuY29uc3QgQWNjb3VudEZpZWxkcyA9IHtcbiAgICBFbWFpbEhhc2g6IHtcbiAgICAgICAgbmFtZTogJ2VtYWlsSGFzaCcsXG4gICAgICAgIGVuY29kaW5nOiAnaGV4JyxcbiAgICAgICAgbGVuZ3RoOiAzMixcbiAgICAgICAgZGVmYXVsdHM6ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgICB9LFxuICAgIFdhbGxldExvY2F0b3I6IHsgbmFtZTogJ3dhbGxldExvY2F0b3InIH0sXG4gICAgTWVzc2FnZUtleTogeyBuYW1lOiAnbWVzc2FnZUtleScgfSxcbiAgICBEb21haW46IHsgbmFtZTogJ2RvbWFpbicsIGVuY29kaW5nOiAnaGV4JyB9LFxuICAgIFRyYW5zZmVyUmF0ZTogeyBuYW1lOiAndHJhbnNmZXJSYXRlJywgZGVmYXVsdHM6IDAsIHNoaWZ0OiA5IH0sXG4gICAgVGlja1NpemU6IHsgbmFtZTogJ3RpY2tTaXplJywgZGVmYXVsdHM6IDAgfVxufTtcbmV4cG9ydHMuQWNjb3VudEZpZWxkcyA9IEFjY291bnRGaWVsZHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5YUlBMRmF1Y2V0RXJyb3IgPSBleHBvcnRzLkxlZGdlclZlcnNpb25FcnJvciA9IGV4cG9ydHMuTWlzc2luZ0xlZGdlckhpc3RvcnlFcnJvciA9IGV4cG9ydHMuUGVuZGluZ0xlZGdlclZlcnNpb25FcnJvciA9IGV4cG9ydHMuTm90Rm91bmRFcnJvciA9IGV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gZXhwb3J0cy5SZXNwb25zZUZvcm1hdEVycm9yID0gZXhwb3J0cy5UaW1lb3V0RXJyb3IgPSBleHBvcnRzLlJpcHBsZWROb3RJbml0aWFsaXplZEVycm9yID0gZXhwb3J0cy5EaXNjb25uZWN0ZWRFcnJvciA9IGV4cG9ydHMuTm90Q29ubmVjdGVkRXJyb3IgPSBleHBvcnRzLlJpcHBsZWRFcnJvciA9IGV4cG9ydHMuQ29ubmVjdGlvbkVycm9yID0gZXhwb3J0cy5VbmV4cGVjdGVkRXJyb3IgPSBleHBvcnRzLlJpcHBsZUVycm9yID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBicm93c2VySGFja3MgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vYnJvd3Nlci1oYWNrc1wiKSk7XG5jbGFzcyBSaXBwbGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlID0gJycsIGRhdGEpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IGJyb3dzZXJIYWNrcy5nZXRDb25zdHJ1Y3Rvck5hbWUodGhpcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSAnWycgKyB0aGlzLm5hbWUgKyAnKCcgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICAgIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnLCAnICsgdXRpbF8xLmluc3BlY3QodGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyldJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaW5zcGVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG59XG5leHBvcnRzLlJpcHBsZUVycm9yID0gUmlwcGxlRXJyb3I7XG5jbGFzcyBSaXBwbGVkRXJyb3IgZXh0ZW5kcyBSaXBwbGVFcnJvciB7XG59XG5leHBvcnRzLlJpcHBsZWRFcnJvciA9IFJpcHBsZWRFcnJvcjtcbmNsYXNzIFVuZXhwZWN0ZWRFcnJvciBleHRlbmRzIFJpcHBsZUVycm9yIHtcbn1cbmV4cG9ydHMuVW5leHBlY3RlZEVycm9yID0gVW5leHBlY3RlZEVycm9yO1xuY2xhc3MgTGVkZ2VyVmVyc2lvbkVycm9yIGV4dGVuZHMgUmlwcGxlRXJyb3Ige1xufVxuZXhwb3J0cy5MZWRnZXJWZXJzaW9uRXJyb3IgPSBMZWRnZXJWZXJzaW9uRXJyb3I7XG5jbGFzcyBDb25uZWN0aW9uRXJyb3IgZXh0ZW5kcyBSaXBwbGVFcnJvciB7XG59XG5leHBvcnRzLkNvbm5lY3Rpb25FcnJvciA9IENvbm5lY3Rpb25FcnJvcjtcbmNsYXNzIE5vdENvbm5lY3RlZEVycm9yIGV4dGVuZHMgQ29ubmVjdGlvbkVycm9yIHtcbn1cbmV4cG9ydHMuTm90Q29ubmVjdGVkRXJyb3IgPSBOb3RDb25uZWN0ZWRFcnJvcjtcbmNsYXNzIERpc2Nvbm5lY3RlZEVycm9yIGV4dGVuZHMgQ29ubmVjdGlvbkVycm9yIHtcbn1cbmV4cG9ydHMuRGlzY29ubmVjdGVkRXJyb3IgPSBEaXNjb25uZWN0ZWRFcnJvcjtcbmNsYXNzIFJpcHBsZWROb3RJbml0aWFsaXplZEVycm9yIGV4dGVuZHMgQ29ubmVjdGlvbkVycm9yIHtcbn1cbmV4cG9ydHMuUmlwcGxlZE5vdEluaXRpYWxpemVkRXJyb3IgPSBSaXBwbGVkTm90SW5pdGlhbGl6ZWRFcnJvcjtcbmNsYXNzIFRpbWVvdXRFcnJvciBleHRlbmRzIENvbm5lY3Rpb25FcnJvciB7XG59XG5leHBvcnRzLlRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvcjtcbmNsYXNzIFJlc3BvbnNlRm9ybWF0RXJyb3IgZXh0ZW5kcyBDb25uZWN0aW9uRXJyb3Ige1xufVxuZXhwb3J0cy5SZXNwb25zZUZvcm1hdEVycm9yID0gUmVzcG9uc2VGb3JtYXRFcnJvcjtcbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIFJpcHBsZUVycm9yIHtcbn1cbmV4cG9ydHMuVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yO1xuY2xhc3MgWFJQTEZhdWNldEVycm9yIGV4dGVuZHMgUmlwcGxlRXJyb3Ige1xufVxuZXhwb3J0cy5YUlBMRmF1Y2V0RXJyb3IgPSBYUlBMRmF1Y2V0RXJyb3I7XG5jbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgUmlwcGxlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UgPSAnTm90IGZvdW5kJykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLk5vdEZvdW5kRXJyb3IgPSBOb3RGb3VuZEVycm9yO1xuY2xhc3MgTWlzc2luZ0xlZGdlckhpc3RvcnlFcnJvciBleHRlbmRzIFJpcHBsZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ1NlcnZlciBpcyBtaXNzaW5nIGxlZGdlciBoaXN0b3J5IGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UnKTtcbiAgICB9XG59XG5leHBvcnRzLk1pc3NpbmdMZWRnZXJIaXN0b3J5RXJyb3IgPSBNaXNzaW5nTGVkZ2VySGlzdG9yeUVycm9yO1xuY2xhc3MgUGVuZGluZ0xlZGdlclZlcnNpb25FcnJvciBleHRlbmRzIFJpcHBsZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgfHxcbiAgICAgICAgICAgIFwibWF4TGVkZ2VyVmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gc2VydmVyJ3MgbW9zdCByZWNlbnRcIiArXG4gICAgICAgICAgICAgICAgJyB2YWxpZGF0ZWQgbGVkZ2VyJyk7XG4gICAgfVxufVxuZXhwb3J0cy5QZW5kaW5nTGVkZ2VyVmVyc2lvbkVycm9yID0gUGVuZGluZ0xlZGdlclZlcnNpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBIYXNoUHJlZml4O1xuKGZ1bmN0aW9uIChIYXNoUHJlZml4KSB7XG4gICAgSGFzaFByZWZpeFtIYXNoUHJlZml4W1wiVFJBTlNBQ1RJT05fSURcIl0gPSAxNDE1MDczMjgwXSA9IFwiVFJBTlNBQ1RJT05fSURcIjtcbiAgICBIYXNoUHJlZml4W0hhc2hQcmVmaXhbXCJUUkFOU0FDVElPTl9OT0RFXCJdID0gMTM5NzYzODE0NF0gPSBcIlRSQU5TQUNUSU9OX05PREVcIjtcbiAgICBIYXNoUHJlZml4W0hhc2hQcmVmaXhbXCJJTk5FUl9OT0RFXCJdID0gMTI5NjY0OTcyOF0gPSBcIklOTkVSX05PREVcIjtcbiAgICBIYXNoUHJlZml4W0hhc2hQcmVmaXhbXCJMRUFGX05PREVcIl0gPSAxMjk2ODQ2MzM2XSA9IFwiTEVBRl9OT0RFXCI7XG4gICAgSGFzaFByZWZpeFtIYXNoUHJlZml4W1wiVFJBTlNBQ1RJT05fU0lHTlwiXSA9IDEzOTgwMzY0ODBdID0gXCJUUkFOU0FDVElPTl9TSUdOXCI7XG4gICAgSGFzaFByZWZpeFtIYXNoUHJlZml4W1wiVFJBTlNBQ1RJT05fU0lHTl9URVNUTkVUXCJdID0gMTkzNzAxMjczNl0gPSBcIlRSQU5TQUNUSU9OX1NJR05fVEVTVE5FVFwiO1xuICAgIEhhc2hQcmVmaXhbSGFzaFByZWZpeFtcIlRSQU5TQUNUSU9OX01VTFRJU0lHTlwiXSA9IDEzOTc1NzY3MDRdID0gXCJUUkFOU0FDVElPTl9NVUxUSVNJR05cIjtcbiAgICBIYXNoUHJlZml4W0hhc2hQcmVmaXhbXCJMRURHRVJcIl0gPSAxMjgwNzkxMDQwXSA9IFwiTEVER0VSXCI7XG59KShIYXNoUHJlZml4IHx8IChIYXNoUHJlZml4ID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEhhc2hQcmVmaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXByZWZpeC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29tcHV0ZVBheW1lbnRDaGFubmVsSGFzaCA9IGV4cG9ydHMuY29tcHV0ZUVzY3Jvd0hhc2ggPSBleHBvcnRzLmNvbXB1dGVMZWRnZXJIYXNoID0gZXhwb3J0cy5jb21wdXRlU3RhdGVUcmVlSGFzaCA9IGV4cG9ydHMuY29tcHV0ZVRyYW5zYWN0aW9uVHJlZUhhc2ggPSBleHBvcnRzLmNvbXB1dGVUcnVzdGxpbmVIYXNoID0gZXhwb3J0cy5jb21wdXRlT3JkZXJJRCA9IGV4cG9ydHMuY29tcHV0ZVNpZ25lckxpc3RMZWRnZXJPYmplY3RJRCA9IGV4cG9ydHMuY29tcHV0ZUFjY291bnRMZWRnZXJPYmplY3RJRCA9IGV4cG9ydHMuY29tcHV0ZUJpbmFyeVRyYW5zYWN0aW9uU2lnbmluZ0hhc2ggPSBleHBvcnRzLmNvbXB1dGVUcmFuc2FjdGlvbkhhc2ggPSBleHBvcnRzLmNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvbkhhc2ggPSB2b2lkIDA7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpKTtcbmNvbnN0IHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEgPSByZXF1aXJlKFwicmlwcGxlLWFkZHJlc3MtY29kZWNcIik7XG5jb25zdCBzaGE1MTJIYWxmXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhNTEySGFsZlwiKSk7XG5jb25zdCBoYXNoX3ByZWZpeF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2hhc2gtcHJlZml4XCIpKTtcbmNvbnN0IHNoYW1hcF8xID0gcmVxdWlyZShcIi4vc2hhbWFwXCIpO1xuY29uc3QgcmlwcGxlX2JpbmFyeV9jb2RlY18xID0gcmVxdWlyZShcInJpcHBsZS1iaW5hcnktY29kZWNcIik7XG5jb25zdCBsZWRnZXJzcGFjZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9sZWRnZXJzcGFjZXNcIikpO1xuY29uc3QgcGFkTGVmdFplcm8gPSAoc3RyaW5nLCBsZW5ndGgpID0+IHtcbiAgICByZXR1cm4gQXJyYXkobGVuZ3RoIC0gc3RyaW5nLmxlbmd0aCArIDEpLmpvaW4oJzAnKSArIHN0cmluZztcbn07XG5jb25zdCBpbnRUb0hleCA9IChpbnRlZ2VyLCBieXRlTGVuZ3RoKSA9PiB7XG4gICAgcmV0dXJuIHBhZExlZnRaZXJvKE51bWJlcihpbnRlZ2VyKS50b1N0cmluZygxNiksIGJ5dGVMZW5ndGggKiAyKTtcbn07XG5jb25zdCBieXRlc1RvSGV4ID0gKGJ5dGVzKSA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKS50b1N0cmluZygnaGV4Jyk7XG59O1xuY29uc3QgYmlnaW50VG9IZXggPSAoaW50ZWdlclN0cmluZywgYnl0ZUxlbmd0aCkgPT4ge1xuICAgIGNvbnN0IGhleCA9IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KGludGVnZXJTdHJpbmcpLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gcGFkTGVmdFplcm8oaGV4LCBieXRlTGVuZ3RoICogMik7XG59O1xuY29uc3QgbGVkZ2VyU3BhY2VIZXggPSAobmFtZSkgPT4ge1xuICAgIHJldHVybiBpbnRUb0hleChsZWRnZXJzcGFjZXNfMS5kZWZhdWx0W25hbWVdLmNoYXJDb2RlQXQoMCksIDIpO1xufTtcbmNvbnN0IGFkZHJlc3NUb0hleCA9IChhZGRyZXNzKSA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuZGVjb2RlQWNjb3VudElEKGFkZHJlc3MpKS50b1N0cmluZygnaGV4Jyk7XG59O1xuY29uc3QgY3VycmVuY3lUb0hleCA9IChjdXJyZW5jeSkgPT4ge1xuICAgIGlmIChjdXJyZW5jeS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgQXJyYXkoMjAgKyAxKS5qb2luKCcwJykuc3BsaXQoJycpLm1hcChwYXJzZUZsb2F0KTtcbiAgICAgICAgYnl0ZXNbMTJdID0gY3VycmVuY3kuY2hhckNvZGVBdCgwKSAmIDB4ZmY7XG4gICAgICAgIGJ5dGVzWzEzXSA9IGN1cnJlbmN5LmNoYXJDb2RlQXQoMSkgJiAweGZmO1xuICAgICAgICBieXRlc1sxNF0gPSBjdXJyZW5jeS5jaGFyQ29kZUF0KDIpICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgoYnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVuY3k7XG59O1xuY29uc3QgYWRkTGVuZ3RoUHJlZml4ID0gKGhleCkgPT4ge1xuICAgIGNvbnN0IGxlbmd0aCA9IGhleC5sZW5ndGggLyAyO1xuICAgIGlmIChsZW5ndGggPD0gMTkyKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KFtsZW5ndGhdKSArIGhleDtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuZ3RoIDw9IDEyNDgwKSB7XG4gICAgICAgIGNvbnN0IHggPSBsZW5ndGggLSAxOTM7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KFsxOTMgKyAoeCA+Pj4gOCksIHggJiAweGZmXSkgKyBoZXg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbmd0aCA8PSA5MTg3NDQpIHtcbiAgICAgICAgY29uc3QgeCA9IGxlbmd0aCAtIDEyNDgxO1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0hleChbMjQxICsgKHggPj4+IDE2KSwgKHggPj4+IDgpICYgMHhmZiwgeCAmIDB4ZmZdKSArIGhleDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdWYXJpYWJsZSBpbnRlZ2VyIG92ZXJmbG93LicpO1xufTtcbmV4cG9ydHMuY29tcHV0ZUJpbmFyeVRyYW5zYWN0aW9uSGFzaCA9ICh0eEJsb2JIZXgpID0+IHtcbiAgICBjb25zdCBwcmVmaXggPSBoYXNoX3ByZWZpeF8xLmRlZmF1bHQuVFJBTlNBQ1RJT05fSUQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIHNoYTUxMkhhbGZfMS5kZWZhdWx0KHByZWZpeCArIHR4QmxvYkhleCk7XG59O1xuZXhwb3J0cy5jb21wdXRlVHJhbnNhY3Rpb25IYXNoID0gKHR4SlNPTikgPT4ge1xuICAgIHJldHVybiBleHBvcnRzLmNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvbkhhc2gocmlwcGxlX2JpbmFyeV9jb2RlY18xLmVuY29kZSh0eEpTT04pKTtcbn07XG5leHBvcnRzLmNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvblNpZ25pbmdIYXNoID0gKHR4QmxvYkhleCkgPT4ge1xuICAgIGNvbnN0IHByZWZpeCA9IGhhc2hfcHJlZml4XzEuZGVmYXVsdC5UUkFOU0FDVElPTl9TSUdOLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBzaGE1MTJIYWxmXzEuZGVmYXVsdChwcmVmaXggKyB0eEJsb2JIZXgpO1xufTtcbmV4cG9ydHMuY29tcHV0ZUFjY291bnRMZWRnZXJPYmplY3RJRCA9IChhZGRyZXNzKSA9PiB7XG4gICAgcmV0dXJuIHNoYTUxMkhhbGZfMS5kZWZhdWx0KGxlZGdlclNwYWNlSGV4KCdhY2NvdW50JykgKyBhZGRyZXNzVG9IZXgoYWRkcmVzcykpO1xufTtcbmV4cG9ydHMuY29tcHV0ZVNpZ25lckxpc3RMZWRnZXJPYmplY3RJRCA9IChhZGRyZXNzKSA9PiB7XG4gICAgcmV0dXJuIHNoYTUxMkhhbGZfMS5kZWZhdWx0KGxlZGdlclNwYWNlSGV4KCdzaWduZXJMaXN0JykgKyBhZGRyZXNzVG9IZXgoYWRkcmVzcykgKyAnMDAwMDAwMDAnKTtcbn07XG5leHBvcnRzLmNvbXB1dGVPcmRlcklEID0gKGFkZHJlc3MsIHNlcXVlbmNlKSA9PiB7XG4gICAgY29uc3QgcHJlZml4ID0gJzAwJyArIGludFRvSGV4KGxlZGdlcnNwYWNlc18xLmRlZmF1bHQub2ZmZXIuY2hhckNvZGVBdCgwKSwgMSk7XG4gICAgcmV0dXJuIHNoYTUxMkhhbGZfMS5kZWZhdWx0KHByZWZpeCArIGFkZHJlc3NUb0hleChhZGRyZXNzKSArIGludFRvSGV4KHNlcXVlbmNlLCA0KSk7XG59O1xuZXhwb3J0cy5jb21wdXRlVHJ1c3RsaW5lSGFzaCA9IChhZGRyZXNzMSwgYWRkcmVzczIsIGN1cnJlbmN5KSA9PiB7XG4gICAgY29uc3QgYWRkcmVzczFIZXggPSBhZGRyZXNzVG9IZXgoYWRkcmVzczEpO1xuICAgIGNvbnN0IGFkZHJlc3MySGV4ID0gYWRkcmVzc1RvSGV4KGFkZHJlc3MyKTtcbiAgICBjb25zdCBzd2FwID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoYWRkcmVzczFIZXgsIDE2KS5pc0dyZWF0ZXJUaGFuKG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KGFkZHJlc3MySGV4LCAxNikpO1xuICAgIGNvbnN0IGxvd0FkZHJlc3NIZXggPSBzd2FwID8gYWRkcmVzczJIZXggOiBhZGRyZXNzMUhleDtcbiAgICBjb25zdCBoaWdoQWRkcmVzc0hleCA9IHN3YXAgPyBhZGRyZXNzMUhleCA6IGFkZHJlc3MySGV4O1xuICAgIGNvbnN0IHByZWZpeCA9IGxlZGdlclNwYWNlSGV4KCdyaXBwbGVTdGF0ZScpO1xuICAgIHJldHVybiBzaGE1MTJIYWxmXzEuZGVmYXVsdChwcmVmaXggKyBsb3dBZGRyZXNzSGV4ICsgaGlnaEFkZHJlc3NIZXggKyBjdXJyZW5jeVRvSGV4KGN1cnJlbmN5KSk7XG59O1xuZXhwb3J0cy5jb21wdXRlVHJhbnNhY3Rpb25UcmVlSGFzaCA9ICh0cmFuc2FjdGlvbnMpID0+IHtcbiAgICBjb25zdCBzaGFtYXAgPSBuZXcgc2hhbWFwXzEuU0hBTWFwKCk7XG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHR4SlNPTikgPT4ge1xuICAgICAgICBjb25zdCB0eEJsb2JIZXggPSByaXBwbGVfYmluYXJ5X2NvZGVjXzEuZW5jb2RlKHR4SlNPTik7XG4gICAgICAgIGNvbnN0IG1ldGFIZXggPSByaXBwbGVfYmluYXJ5X2NvZGVjXzEuZW5jb2RlKHR4SlNPTi5tZXRhRGF0YSk7XG4gICAgICAgIGNvbnN0IHR4SGFzaCA9IGV4cG9ydHMuY29tcHV0ZUJpbmFyeVRyYW5zYWN0aW9uSGFzaCh0eEJsb2JIZXgpO1xuICAgICAgICBjb25zdCBkYXRhID0gYWRkTGVuZ3RoUHJlZml4KHR4QmxvYkhleCkgKyBhZGRMZW5ndGhQcmVmaXgobWV0YUhleCk7XG4gICAgICAgIHNoYW1hcC5hZGRJdGVtKHR4SGFzaCwgZGF0YSwgc2hhbWFwXzEuTm9kZVR5cGUuVFJBTlNBQ1RJT05fTUVUQURBVEEpO1xuICAgIH0pO1xuICAgIHJldHVybiBzaGFtYXAuaGFzaDtcbn07XG5leHBvcnRzLmNvbXB1dGVTdGF0ZVRyZWVIYXNoID0gKGVudHJpZXMpID0+IHtcbiAgICBjb25zdCBzaGFtYXAgPSBuZXcgc2hhbWFwXzEuU0hBTWFwKCk7XG4gICAgZW50cmllcy5mb3JFYWNoKChsZWRnZXJFbnRyeSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gcmlwcGxlX2JpbmFyeV9jb2RlY18xLmVuY29kZShsZWRnZXJFbnRyeSk7XG4gICAgICAgIHNoYW1hcC5hZGRJdGVtKGxlZGdlckVudHJ5LmluZGV4LCBkYXRhLCBzaGFtYXBfMS5Ob2RlVHlwZS5BQ0NPVU5UX1NUQVRFKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2hhbWFwLmhhc2g7XG59O1xuZXhwb3J0cy5jb21wdXRlTGVkZ2VySGFzaCA9IChsZWRnZXJIZWFkZXIpID0+IHtcbiAgICBjb25zdCBwcmVmaXggPSBoYXNoX3ByZWZpeF8xLmRlZmF1bHQuTEVER0VSLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBzaGE1MTJIYWxmXzEuZGVmYXVsdChwcmVmaXggK1xuICAgICAgICBpbnRUb0hleChsZWRnZXJIZWFkZXIubGVkZ2VyX2luZGV4LCA0KSArXG4gICAgICAgIGJpZ2ludFRvSGV4KGxlZGdlckhlYWRlci50b3RhbF9jb2lucywgOCkgK1xuICAgICAgICBsZWRnZXJIZWFkZXIucGFyZW50X2hhc2ggK1xuICAgICAgICBsZWRnZXJIZWFkZXIudHJhbnNhY3Rpb25faGFzaCArXG4gICAgICAgIGxlZGdlckhlYWRlci5hY2NvdW50X2hhc2ggK1xuICAgICAgICBpbnRUb0hleChsZWRnZXJIZWFkZXIucGFyZW50X2Nsb3NlX3RpbWUsIDQpICtcbiAgICAgICAgaW50VG9IZXgobGVkZ2VySGVhZGVyLmNsb3NlX3RpbWUsIDQpICtcbiAgICAgICAgaW50VG9IZXgobGVkZ2VySGVhZGVyLmNsb3NlX3RpbWVfcmVzb2x1dGlvbiwgMSkgK1xuICAgICAgICBpbnRUb0hleChsZWRnZXJIZWFkZXIuY2xvc2VfZmxhZ3MsIDEpKTtcbn07XG5leHBvcnRzLmNvbXB1dGVFc2Nyb3dIYXNoID0gKGFkZHJlc3MsIHNlcXVlbmNlKSA9PiB7XG4gICAgcmV0dXJuIHNoYTUxMkhhbGZfMS5kZWZhdWx0KGxlZGdlclNwYWNlSGV4KCdlc2Nyb3cnKSArIGFkZHJlc3NUb0hleChhZGRyZXNzKSArIGludFRvSGV4KHNlcXVlbmNlLCA0KSk7XG59O1xuZXhwb3J0cy5jb21wdXRlUGF5bWVudENoYW5uZWxIYXNoID0gKGFkZHJlc3MsIGRzdEFkZHJlc3MsIHNlcXVlbmNlKSA9PiB7XG4gICAgcmV0dXJuIHNoYTUxMkhhbGZfMS5kZWZhdWx0KGxlZGdlclNwYWNlSGV4KCdwYXljaGFuJykgK1xuICAgICAgICBhZGRyZXNzVG9IZXgoYWRkcmVzcykgK1xuICAgICAgICBhZGRyZXNzVG9IZXgoZHN0QWRkcmVzcykgK1xuICAgICAgICBpbnRUb0hleChzZXF1ZW5jZSwgNCkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIGFjY291bnQ6ICdhJyxcbiAgICBkaXJOb2RlOiAnZCcsXG4gICAgZ2VuZXJhdG9yTWFwOiAnZycsXG4gICAgcmlwcGxlU3RhdGU6ICdyJyxcbiAgICBvZmZlcjogJ28nLFxuICAgIG93bmVyRGlyOiAnTycsXG4gICAgYm9va0RpcjogJ0InLFxuICAgIGNvbnRyYWN0OiAnYycsXG4gICAgc2tpcExpc3Q6ICdzJyxcbiAgICBlc2Nyb3c6ICd1JyxcbiAgICBhbWVuZG1lbnQ6ICdmJyxcbiAgICBmZWVTZXR0aW5nczogJ2UnLFxuICAgIHRpY2tldDogJ1QnLFxuICAgIHNpZ25lckxpc3Q6ICdTJyxcbiAgICBwYXljaGFuOiAneCcsXG4gICAgY2hlY2s6ICdDJyxcbiAgICBkZXBvc2l0UHJlYXV0aDogJ3AnXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVkZ2Vyc3BhY2VzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3Qgc2hhNTEySGFsZiA9IChoZXgpID0+IHtcbiAgICByZXR1cm4gY3J5cHRvXzEuY3JlYXRlSGFzaCgnc2hhNTEyJylcbiAgICAgICAgLnVwZGF0ZShCdWZmZXIuZnJvbShoZXgsICdoZXgnKSlcbiAgICAgICAgLmRpZ2VzdCgnaGV4JylcbiAgICAgICAgLnRvVXBwZXJDYXNlKClcbiAgICAgICAgLnNsaWNlKDAsIDY0KTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBzaGE1MTJIYWxmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhNTEySGFsZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU0hBTWFwID0gZXhwb3J0cy5MZWFmID0gZXhwb3J0cy5Jbm5lck5vZGUgPSBleHBvcnRzLk5vZGUgPSBleHBvcnRzLk5vZGVUeXBlID0gdm9pZCAwO1xuY29uc3QgaGFzaF9wcmVmaXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9oYXNoLXByZWZpeFwiKSk7XG5jb25zdCBzaGE1MTJIYWxmXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2hhNTEySGFsZlwiKSk7XG5jb25zdCBIRVhfWkVSTyA9ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcbnZhciBOb2RlVHlwZTtcbihmdW5jdGlvbiAoTm9kZVR5cGUpIHtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIklOTkVSXCJdID0gMV0gPSBcIklOTkVSXCI7XG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJUUkFOU0FDVElPTl9OT19NRVRBREFUQVwiXSA9IDJdID0gXCJUUkFOU0FDVElPTl9OT19NRVRBREFUQVwiO1xuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiVFJBTlNBQ1RJT05fTUVUQURBVEFcIl0gPSAzXSA9IFwiVFJBTlNBQ1RJT05fTUVUQURBVEFcIjtcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkFDQ09VTlRfU1RBVEVcIl0gPSA0XSA9IFwiQUNDT1VOVF9TVEFURVwiO1xufSkoTm9kZVR5cGUgPSBleHBvcnRzLk5vZGVUeXBlIHx8IChleHBvcnRzLk5vZGVUeXBlID0ge30pKTtcbmNsYXNzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgYWRkSXRlbShfdGFnLCBfbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxlZCB1bmltcGxlbWVudGVkIHZpcnR1YWwgbWV0aG9kIFNIQU1hcFRyZWVOb2RlI2FkZEl0ZW0uJyk7XG4gICAgfVxuICAgIGdldCBoYXNoKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxlZCB1bmltcGxlbWVudGVkIHZpcnR1YWwgbWV0aG9kIFNIQU1hcFRyZWVOb2RlI2hhc2guJyk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbmNsYXNzIElubmVyTm9kZSBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGRlcHRoID0gMCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmxlYXZlcyA9IHt9O1xuICAgICAgICB0aGlzLnR5cGUgPSBOb2RlVHlwZS5JTk5FUjtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmVtcHR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgYWRkSXRlbSh0YWcsIG5vZGUpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdOb2RlID0gdGhpcy5nZXROb2RlKHBhcnNlSW50KHRhZ1t0aGlzLmRlcHRoXSwgMTYpKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nTm9kZSkge1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nTm9kZSBpbnN0YW5jZW9mIElubmVyTm9kZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nTm9kZS5hZGRJdGVtKHRhZywgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleGlzdGluZ05vZGUgaW5zdGFuY2VvZiBMZWFmKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nTm9kZS50YWcgPT09IHRhZykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGFkZCBhIG5vZGUgdG8gYSBTSEFNYXAgdGhhdCB3YXMgYWxyZWFkeSBpbiB0aGVyZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0lubmVyTm9kZSA9IG5ldyBJbm5lck5vZGUodGhpcy5kZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBuZXdJbm5lck5vZGUuYWRkSXRlbShleGlzdGluZ05vZGUudGFnLCBleGlzdGluZ05vZGUpO1xuICAgICAgICAgICAgICAgICAgICBuZXdJbm5lck5vZGUuYWRkSXRlbSh0YWcsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGUocGFyc2VJbnQodGFnW3RoaXMuZGVwdGhdLCAxNiksIG5ld0lubmVyTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXROb2RlKHBhcnNlSW50KHRhZ1t0aGlzLmRlcHRoXSwgMTYpLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXROb2RlKHNsb3QsIG5vZGUpIHtcbiAgICAgICAgaWYgKHNsb3QgPCAwIHx8IHNsb3QgPiAxNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNsb3Q6IHNsb3QgbXVzdCBiZSBiZXR3ZWVuIDAtMTUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZWF2ZXNbc2xvdF0gPSBub2RlO1xuICAgICAgICB0aGlzLmVtcHR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGdldE5vZGUoc2xvdCkge1xuICAgICAgICBpZiAoc2xvdCA8IDAgfHwgc2xvdCA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2xvdDogc2xvdCBtdXN0IGJlIGJldHdlZW4gMC0xNS4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sZWF2ZXNbc2xvdF07XG4gICAgfVxuICAgIGdldCBoYXNoKCkge1xuICAgICAgICBpZiAodGhpcy5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBIRVhfWkVSTztcbiAgICAgICAgbGV0IGhleCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIGhleCArPSB0aGlzLmxlYXZlc1tpXSA/IHRoaXMubGVhdmVzW2ldLmhhc2ggOiBIRVhfWkVSTztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmVmaXggPSBoYXNoX3ByZWZpeF8xLmRlZmF1bHQuSU5ORVJfTk9ERS50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiBzaGE1MTJIYWxmXzEuZGVmYXVsdChwcmVmaXggKyBoZXgpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5uZXJOb2RlID0gSW5uZXJOb2RlO1xuY2xhc3MgTGVhZiBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKHRhZywgZGF0YSwgdHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB9XG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLkFDQ09VTlRfU1RBVEU6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWFmUHJlZml4ID0gaGFzaF9wcmVmaXhfMS5kZWZhdWx0LkxFQUZfTk9ERS50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYTUxMkhhbGZfMS5kZWZhdWx0KGxlYWZQcmVmaXggKyB0aGlzLmRhdGEgKyB0aGlzLnRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE5vZGVUeXBlLlRSQU5TQUNUSU9OX05PX01FVEFEQVRBOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhJRFByZWZpeCA9IGhhc2hfcHJlZml4XzEuZGVmYXVsdC5UUkFOU0FDVElPTl9JRC50b1N0cmluZygxNik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYTUxMkhhbGZfMS5kZWZhdWx0KHR4SURQcmVmaXggKyB0aGlzLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBOb2RlVHlwZS5UUkFOU0FDVElPTl9NRVRBREFUQToge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4Tm9kZVByZWZpeCA9IGhhc2hfcHJlZml4XzEuZGVmYXVsdC5UUkFOU0FDVElPTl9OT0RFLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhNTEySGFsZl8xLmRlZmF1bHQodHhOb2RlUHJlZml4ICsgdGhpcy5kYXRhICsgdGhpcy50YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWVkIHRvIGhhc2ggYSBTSEFNYXAgbm9kZSBvZiB1bmtub3duIHR5cGUuJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxlYWYgPSBMZWFmO1xuY2xhc3MgU0hBTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yb290ID0gbmV3IElubmVyTm9kZSgwKTtcbiAgICB9XG4gICAgYWRkSXRlbSh0YWcsIGRhdGEsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5yb290LmFkZEl0ZW0odGFnLCBuZXcgTGVhZih0YWcsIGRhdGEsIHR5cGUpKTtcbiAgICB9XG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuaGFzaDtcbiAgICB9XG59XG5leHBvcnRzLlNIQU1hcCA9IFNIQU1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYW1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlcnZlckluZm8gPSBleHBvcnRzLnZhbGlkYXRlID0gZXhwb3J0cy5lcnJvcnMgPSBleHBvcnRzLmNvbnN0YW50cyA9IGV4cG9ydHMuZW5zdXJlQ2xhc3NpY0FkZHJlc3MgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vY29uc3RhbnRzXCIpKTtcbmV4cG9ydHMuY29uc3RhbnRzID0gY29uc3RhbnRzO1xuY29uc3QgZXJyb3JzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2Vycm9yc1wiKSk7XG5leHBvcnRzLmVycm9ycyA9IGVycm9ycztcbmNvbnN0IHZhbGlkYXRlID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZhbGlkYXRlXCIpKTtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmNvbnN0IHNlcnZlckluZm8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2VydmVyaW5mb1wiKSk7XG5leHBvcnRzLnNlcnZlckluZm8gPSBzZXJ2ZXJJbmZvO1xuY29uc3QgcmlwcGxlX2FkZHJlc3NfY29kZWNfMSA9IHJlcXVpcmUoXCJyaXBwbGUtYWRkcmVzcy1jb2RlY1wiKTtcbmZ1bmN0aW9uIGVuc3VyZUNsYXNzaWNBZGRyZXNzKGFjY291bnQpIHtcbiAgICBpZiAocmlwcGxlX2FkZHJlc3NfY29kZWNfMS5pc1ZhbGlkWEFkZHJlc3MoYWNjb3VudCkpIHtcbiAgICAgICAgY29uc3QgeyBjbGFzc2ljQWRkcmVzcywgdGFnIH0gPSByaXBwbGVfYWRkcmVzc19jb2RlY18xLnhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyhhY2NvdW50KTtcbiAgICAgICAgaWYgKHRhZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBjb21tYW5kIGRvZXMgbm90IHN1cHBvcnQgdGhlIHVzZSBvZiBhIHRhZy4gVXNlIGFuIGFkZHJlc3Mgd2l0aG91dCBhIHRhZy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NpY0FkZHJlc3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYWNjb3VudDtcbiAgICB9XG59XG5leHBvcnRzLmVuc3VyZUNsYXNzaWNBZGRyZXNzID0gZW5zdXJlQ2xhc3NpY0FkZHJlc3M7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZHJvcHNUb1hycFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5kcm9wc1RvWHJwOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwieHJwVG9Ecm9wc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS54cnBUb0Ryb3BzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9SaXBwbGVkQW1vdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnRvUmlwcGxlZEFtb3VudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbW92ZVVuZGVmaW5lZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5yZW1vdmVVbmRlZmluZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb252ZXJ0S2V5c0Zyb21TbmFrZUNhc2VUb0NhbWVsQ2FzZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5jb252ZXJ0S2V5c0Zyb21TbmFrZUNhc2VUb0NhbWVsQ2FzZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzbzg2MDFUb1JpcHBsZVRpbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuaXNvODYwMVRvUmlwcGxlVGltZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJpcHBsZVRpbWVUb0lTTzg2MDFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEucmlwcGxlVGltZVRvSVNPODYwMTsgfSB9KTtcbnZhciBjb25uZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGlvbl8xLkNvbm5lY3Rpb247IH0gfSk7XG52YXIgdHhmbGFnc18xID0gcmVxdWlyZShcIi4vdHhmbGFnc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInR4RmxhZ3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR4ZmxhZ3NfMS50eEZsYWdzOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgXyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibG9kYXNoXCIpKTtcbmNvbnN0IGFzc2VydCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmZ1bmN0aW9uIG1lcmdlSW50ZXJ2YWxzKGludGVydmFscykge1xuICAgIGNvbnN0IHN0YWNrID0gW1stSW5maW5pdHksIC1JbmZpbml0eV1dO1xuICAgIF8uc29ydEJ5KGludGVydmFscywgKHgpID0+IHhbMF0pLmZvckVhY2goKGludGVydmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RJbnRlcnZhbCA9IHN0YWNrLnBvcCgpO1xuICAgICAgICBpZiAoaW50ZXJ2YWxbMF0gPD0gbGFzdEludGVydmFsWzFdICsgMSkge1xuICAgICAgICAgICAgc3RhY2sucHVzaChbbGFzdEludGVydmFsWzBdLCBNYXRoLm1heChpbnRlcnZhbFsxXSwgbGFzdEludGVydmFsWzFdKV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhY2sucHVzaChsYXN0SW50ZXJ2YWwpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChpbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3RhY2suc2xpY2UoMSk7XG59XG5jbGFzcyBSYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgfVxuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzXG4gICAgICAgICAgICAubWFwKChyYW5nZSkgPT4gcmFuZ2VbMF0udG9TdHJpbmcoKSArICctJyArIHJhbmdlWzFdLnRvU3RyaW5nKCkpXG4gICAgICAgICAgICAuam9pbignLCcpO1xuICAgIH1cbiAgICBhZGRSYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICAgIGFzc2VydC5vayhzdGFydCA8PSBlbmQsIGBpbnZhbGlkIHJhbmdlICR7c3RhcnR9IDw9ICR7ZW5kfWApO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IG1lcmdlSW50ZXJ2YWxzKHRoaXMucmFuZ2VzLmNvbmNhdChbW3N0YXJ0LCBlbmRdXSkpO1xuICAgIH1cbiAgICBhZGRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZFJhbmdlKHZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHBhcnNlQW5kQWRkUmFuZ2VzKHJhbmdlc1N0cmluZykge1xuICAgICAgICBjb25zdCByYW5nZVN0cmluZ3MgPSByYW5nZXNTdHJpbmcuc3BsaXQoJywnKTtcbiAgICAgICAgcmFuZ2VTdHJpbmdzLmZvckVhY2goKHJhbmdlU3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHJhbmdlU3RyaW5nLnNwbGl0KCctJykubWFwKE51bWJlcik7XG4gICAgICAgICAgICB0aGlzLmFkZFJhbmdlKHJhbmdlWzBdLCByYW5nZS5sZW5ndGggPT09IDEgPyByYW5nZVswXSA6IHJhbmdlWzFdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnRhaW5zUmFuZ2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXMuc29tZSgocmFuZ2UpID0+IHJhbmdlWzBdIDw9IHN0YXJ0ICYmIHJhbmdlWzFdID49IGVuZCk7XG4gICAgfVxuICAgIGNvbnRhaW5zVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnNSYW5nZSh2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFJhbmdlU2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFuZ2VzZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGV4cG9ydHMuaXNWYWxpZFNlY3JldCA9IGV4cG9ydHMuc2NoZW1hVmFsaWRhdGUgPSB2b2lkIDA7XG5jb25zdCBfID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgeyBWYWxpZGF0b3IgfSA9IHJlcXVpcmUoJ2pzb25zY2hlbWEnKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgcmlwcGxlX2FkZHJlc3NfY29kZWNfMSA9IHJlcXVpcmUoXCJyaXBwbGUtYWRkcmVzcy1jb2RlY1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWRTZWNyZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuaXNWYWxpZFNlY3JldDsgfSB9KTtcbmZ1bmN0aW9uIGxvYWRTY2hlbWFzKCkge1xuICAgIGNvbnN0IHNjaGVtYXMgPSBbXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL3R4LWpzb24uanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy90cmFuc2FjdGlvbi10eXBlLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL29iamVjdHMvaGFzaDEyOC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL2hhc2gyNTYuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9zZXF1ZW5jZS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL3RpY2tldC1zZXF1ZW5jZS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL3NpZ25hdHVyZS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL2lzc3VlLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL29iamVjdHMvbGVkZ2VyLXZlcnNpb24uanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9tYXgtYWRqdXN0bWVudC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL21lbW8uanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9tZW1vcy5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL3B1YmxpYy1rZXkuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9wcml2YXRlLWtleS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL3VpbnQzMi5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL3ZhbHVlLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL29iamVjdHMvc291cmNlLWFkanVzdG1lbnQuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9kZXN0aW5hdGlvbi1hZGp1c3RtZW50Lmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL29iamVjdHMvdGFnLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL29iamVjdHMvbGF4LWFtb3VudC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL2xheC1sYXgtYW1vdW50Lmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL29iamVjdHMvbWluLWFkanVzdG1lbnQuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9zb3VyY2UtZXhhY3QtYWRqdXN0bWVudC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL2Rlc3RpbmF0aW9uLWV4YWN0LWFkanVzdG1lbnQuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9kZXN0aW5hdGlvbi1hZGRyZXNzLXRhZy5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL3RyYW5zYWN0aW9uLWhhc2guanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9hZGRyZXNzLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL29iamVjdHMveC1hZGRyZXNzLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL29iamVjdHMvY2xhc3NpYy1hZGRyZXNzLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL29iamVjdHMvYWRqdXN0bWVudC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL3F1YWxpdHkuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9hbW91bnQuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9hbW91bnRiYXNlLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL29iamVjdHMvYmFsYW5jZS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL2Jsb2IuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb2JqZWN0cy9jdXJyZW5jeS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL3NpZ25lZC12YWx1ZS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL29yZGVyYm9vay5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL2luc3RydWN0aW9ucy5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vYmplY3RzL3NldHRpbmdzLXBsdXMtbWVtb3MuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvc2V0dGluZ3MuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvcGF5bWVudC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9nZXQtcGF5bWVudC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9lc2Nyb3ctY2FuY2VsbGF0aW9uLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL3NwZWNpZmljYXRpb25zL29yZGVyLWNhbmNlbGxhdGlvbi5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9vcmRlci5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9lc2Nyb3ctZXhlY3V0aW9uLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL3NwZWNpZmljYXRpb25zL2VzY3Jvdy1jcmVhdGlvbi5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9wYXltZW50LWNoYW5uZWwtY3JlYXRlLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL3NwZWNpZmljYXRpb25zL3BheW1lbnQtY2hhbm5lbC1mdW5kLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL3NwZWNpZmljYXRpb25zL3BheW1lbnQtY2hhbm5lbC1jbGFpbS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9jaGVjay1jcmVhdGUuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvY2hlY2stY2FzaC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9jaGVjay1jYW5jZWwuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvc3BlY2lmaWNhdGlvbnMvdHJ1c3RsaW5lLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL3NwZWNpZmljYXRpb25zL2RlcG9zaXQtcHJlYXV0aC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9zcGVjaWZpY2F0aW9ucy9hY2NvdW50LWRlbGV0ZS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vdXRwdXQvc2lnbi5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vdXRwdXQvc3VibWl0Lmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL291dHB1dC9nZXQtYWNjb3VudC1pbmZvLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL291dHB1dC9nZXQtYWNjb3VudC1vYmplY3RzLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL291dHB1dC9nZXQtYmFsYW5jZXMuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb3V0cHV0L2dldC1iYWxhbmNlLXNoZWV0Lmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL291dHB1dC9nZXQtbGVkZ2VyLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL291dHB1dC9nZXQtb3JkZXJib29rLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL291dHB1dC9nZXQtb3JkZXJzLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL291dHB1dC9vcmRlci1jaGFuZ2UuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb3V0cHV0L2dldC1wYXltZW50LWNoYW5uZWwuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb3V0cHV0L3ByZXBhcmUuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb3V0cHV0L2xlZGdlci1ldmVudC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vdXRwdXQvZ2V0LXBhdGhzLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL291dHB1dC9nZXQtc2VydmVyLWluZm8uanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb3V0cHV0L2dldC1zZXR0aW5ncy5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vdXRwdXQvb3JkZXJib29rLW9yZGVycy5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vdXRwdXQvb3V0Y29tZS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vdXRwdXQvZ2V0LXRyYW5zYWN0aW9uLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL291dHB1dC9nZXQtdHJhbnNhY3Rpb25zLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL291dHB1dC9nZXQtdHJ1c3RsaW5lcy5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9vdXRwdXQvc2lnbi1wYXltZW50LWNoYW5uZWwtY2xhaW0uanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvb3V0cHV0L3ZlcmlmeS1wYXltZW50LWNoYW5uZWwtY2xhaW0uanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvZ2V0LWJhbGFuY2VzLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L2dldC1iYWxhbmNlLXNoZWV0Lmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L2dldC1sZWRnZXIuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvZ2V0LW9yZGVycy5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9pbnB1dC9nZXQtb3JkZXJib29rLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L2dldC1wYXRocy5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9pbnB1dC9nZXQtcGF5bWVudC1jaGFubmVsLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L2FwaS1vcHRpb25zLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L2dldC1zZXR0aW5ncy5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9pbnB1dC9nZXQtYWNjb3VudC1pbmZvLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L2dldC1hY2NvdW50LW9iamVjdHMuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvZ2V0LXRyYW5zYWN0aW9uLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L2dldC10cmFuc2FjdGlvbnMuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvZ2V0LXRydXN0bGluZXMuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS1wYXltZW50Lmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtb3JkZXIuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS10cnVzdGxpbmUuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS1vcmRlci1jYW5jZWxsYXRpb24uanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS1zZXR0aW5ncy5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9pbnB1dC9wcmVwYXJlLWVzY3Jvdy1jcmVhdGlvbi5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9pbnB1dC9wcmVwYXJlLWVzY3Jvdy1jYW5jZWxsYXRpb24uanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvcHJlcGFyZS1lc2Nyb3ctZXhlY3V0aW9uLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtcGF5bWVudC1jaGFubmVsLWNyZWF0ZS5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9pbnB1dC9wcmVwYXJlLXBheW1lbnQtY2hhbm5lbC1mdW5kLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtcGF5bWVudC1jaGFubmVsLWNsYWltLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtY2hlY2stY3JlYXRlLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L3ByZXBhcmUtY2hlY2stY2FzaC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9pbnB1dC9wcmVwYXJlLWNoZWNrLWNhbmNlbC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9pbnB1dC9wcmVwYXJlLXRpY2tldC1jcmVhdGUuanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvY29tcHV0ZS1sZWRnZXItaGFzaC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9pbnB1dC9zaWduLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L3N1Ym1pdC5qc29uJyksXG4gICAgICAgIHJlcXVpcmUoJy4vc2NoZW1hcy9pbnB1dC9nZW5lcmF0ZS1hZGRyZXNzLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L3NpZ24tcGF5bWVudC1jaGFubmVsLWNsYWltLmpzb24nKSxcbiAgICAgICAgcmVxdWlyZSgnLi9zY2hlbWFzL2lucHV0L3ZlcmlmeS1wYXltZW50LWNoYW5uZWwtY2xhaW0uanNvbicpLFxuICAgICAgICByZXF1aXJlKCcuL3NjaGVtYXMvaW5wdXQvY29tYmluZS5qc29uJylcbiAgICBdO1xuICAgIGNvbnN0IHRpdGxlcyA9IHNjaGVtYXMubWFwKChzY2hlbWEpID0+IHNjaGVtYS50aXRsZSk7XG4gICAgY29uc3QgZHVwbGljYXRlcyA9IE9iamVjdC5rZXlzKF8ucGlja0J5KF8uY291bnRCeSh0aXRsZXMpLCAoY291bnQpID0+IGNvdW50ID4gMSkpO1xuICAgIGFzc2VydC5vayhkdXBsaWNhdGVzLmxlbmd0aCA9PT0gMCwgJ0R1cGxpY2F0ZSBzY2hlbWFzIGZvcjogJyArIGR1cGxpY2F0ZXMpO1xuICAgIGNvbnN0IHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3IoKTtcbiAgICB2YWxpZGF0b3IuY3VzdG9tRm9ybWF0cy54QWRkcmVzcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuaXNWYWxpZFhBZGRyZXNzKGluc3RhbmNlKTtcbiAgICB9O1xuICAgIHZhbGlkYXRvci5jdXN0b21Gb3JtYXRzLmNsYXNzaWNBZGRyZXNzID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWYWxpZEFkZHJlc3MoaW5zdGFuY2UpO1xuICAgIH07XG4gICAgdmFsaWRhdG9yLmN1c3RvbUZvcm1hdHMuc2VjcmV0ID0gZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHNfMS5pc1ZhbGlkU2VjcmV0KGluc3RhbmNlKTtcbiAgICB9O1xuICAgIHNjaGVtYXMuZm9yRWFjaCgoc2NoZW1hKSA9PiB2YWxpZGF0b3IuYWRkU2NoZW1hKHNjaGVtYSwgJy8nICsgc2NoZW1hLnRpdGxlKSk7XG4gICAgcmV0dXJuIHZhbGlkYXRvcjtcbn1cbmNvbnN0IHNjaGVtYVZhbGlkYXRvciA9IGxvYWRTY2hlbWFzKCk7XG5mdW5jdGlvbiBzY2hlbWFWYWxpZGF0ZShzY2hlbWFOYW1lLCBvYmplY3QpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBzY2hlbWFWYWxpZGF0b3IuZ2V0U2NoZW1hKCcvJyArIHNjaGVtYU5hbWUpO1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsaWRhdGlvbkVycm9yKCdubyBzY2hlbWEgZm9yICcgKyBzY2hlbWFOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hVmFsaWRhdG9yLnZhbGlkYXRlKG9iamVjdCwgc2NoZW1hKTtcbiAgICBpZiAoIXJlc3VsdC52YWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsaWRhdGlvbkVycm9yKHJlc3VsdC5lcnJvcnMuam9pbigpKTtcbiAgICB9XG59XG5leHBvcnRzLnNjaGVtYVZhbGlkYXRlID0gc2NoZW1hVmFsaWRhdGU7XG5mdW5jdGlvbiBpc1ZhbGlkQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgcmV0dXJuIHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuaXNWYWxpZFhBZGRyZXNzKGFkZHJlc3MpIHx8IHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuaXNWYWxpZENsYXNzaWNBZGRyZXNzKGFkZHJlc3MpO1xufVxuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGlzVmFsaWRBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NoZW1hLXZhbGlkYXRvci5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiYXBpLW9wdGlvbnNcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJ0cmFjZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgdHJ1ZSwgbG9nIHJpcHBsZWQgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcyB0byBzdGRvdXQuXCJcbiAgICB9LFxuICAgIFwiZmVlQ3VzaGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAxLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkZhY3RvciB0byBtdWx0aXBseSBlc3RpbWF0ZWQgZmVlIGJ5IHRvIHByb3ZpZGUgYSBjdXNoaW9uIGluIGNhc2UgdGhlIHJlcXVpcmVkIGZlZSByaXNlcyBkdXJpbmcgc3VibWlzc2lvbiBvZiBhIHRyYW5zYWN0aW9uLiBEZWZhdWx0cyB0byBgMS4yYC5cIlxuICAgIH0sXG4gICAgXCJtYXhGZWVYUlBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTWF4aW11bSBmZWUgdG8gdXNlIHdpdGggdHJhbnNhY3Rpb25zLCBpbiBYUlAuIE11c3QgYmUgYSBzdHJpbmctZW5jb2RlZCBudW1iZXIuIERlZmF1bHRzIHRvIGAnMidgLlwiXG4gICAgfSxcbiAgICBcInNlcnZlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJVUkkgZm9yIHJpcHBsZWQgd2Vic29ja2V0IHBvcnQgdG8gY29ubmVjdCB0by4gTXVzdCBzdGFydCB3aXRoIGB3c3M6Ly9gLCBgd3M6Ly9gLCBgd3NzK3VuaXg6Ly9gLCBvciBgd3MrdW5peDovL2AuXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaVwiLFxuICAgICAgXCJwYXR0ZXJuXCI6IFwiXih3c3M/fHdzcz9cXFxcK3VuaXgpOi8vXCJcbiAgICB9LFxuICAgIFwicHJveHlcIjoge1xuICAgICAgXCJmb3JtYXRcIjogXCJ1cmlcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJVUkkgZm9yIEhUVFAvSFRUUFMgcHJveHkgdG8gdXNlIHRvIGNvbm5lY3QgdG8gdGhlIHJpcHBsZWQgc2VydmVyLlwiXG4gICAgfSxcbiAgICBcInRpbWVvdXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlJlcXVlc3QgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgYmVmb3JlIGNvbnNpZGVyaW5nIGEgcmVxdWVzdCB0byBoYXZlIGZhaWxlZC4gU2VlIGFsc286IGNvbm5lY3Rpb25UaW1lb3V0LlwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDFcbiAgICB9LFxuICAgIFwiY29ubmVjdGlvblRpbWVvdXRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkNvbm5lY3Rpb24gdGltZW91dCwgaW4gbWlsbGlzZWNvbmRzLCBiZWZvcmUgY29uc2lkZXJpbmcgY29ubmVjdCgpIHRvIGhhdmUgZmFpbGVkLlwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDFcbiAgICB9LFxuICAgIFwicHJveHlBdXRob3JpemF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlVzZXJuYW1lIGFuZCBwYXNzd29yZCBmb3IgSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvbiB0byB0aGUgcHJveHkgaW4gdGhlIGZvcm1hdCAqKnVzZXJuYW1lOnBhc3N3b3JkKiouXCJcbiAgICB9LFxuICAgIFwiYXV0aG9yaXphdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJVc2VybmFtZSBhbmQgcGFzc3dvcmQgZm9yIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb24gdG8gdGhlIHJpcHBsZWQgc2VydmVyIGluIHRoZSBmb3JtYXQgKip1c2VybmFtZTpwYXNzd29yZCoqLlwiXG4gICAgfSxcbiAgICBcInRydXN0ZWRDZXJ0aWZpY2F0ZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBcnJheSBvZiBQRU0tZm9ybWF0dGVkIFNTTCBjZXJ0aWZpY2F0ZXMgdG8gdHJ1c3Qgd2hlbiBjb25uZWN0aW5nIHRvIGEgcHJveHkuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHVzZSBhIHNlbGYtc2lnbmVkIGNlcnRpZmljYXRlIG9uIHRoZSBwcm94eSBzZXJ2ZXIuIE5vdGU6IEVhY2ggZWxlbWVudCBtdXN0IGNvbnRhaW4gYSBzaW5nbGUgY2VydGlmaWNhdGU7IGNvbmNhdGVuYXRlZCBjZXJ0aWZpY2F0ZXMgYXJlIG5vdCB2YWxpZC5cIixcbiAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgUEVNLWZvcm1hdHRlZCBTU0wgY2VydGlmaWNhdGUgdG8gdHJ1c3Qgd2hlbiBjb25uZWN0aW5nIHRvIGEgcHJveHkuXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIFwia2V5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIHByaXZhdGUga2V5IG9mIHRoZSBjbGllbnQgaW4gUEVNIGZvcm1hdC4gKENhbiBiZSBhbiBhcnJheSBvZiBrZXlzKS5cIlxuICAgIH0sXG4gICAgXCJwYXNzcGhyYXNlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBwYXNzcGhyYXNlIGZvciB0aGUgcHJpdmF0ZSBrZXkgb2YgdGhlIGNsaWVudC5cIlxuICAgIH0sXG4gICAgXCJjZXJ0aWZpY2F0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIHN0cmluZyBjb250YWluaW5nIHRoZSBjZXJ0aWZpY2F0ZSBrZXkgb2YgdGhlIGNsaWVudCBpbiBQRU0gZm9ybWF0LiAoQ2FuIGJlIGFuIGFycmF5IG9mIGNlcnRpZmljYXRlcykuXCJcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJjb21iaW5lUGFyYW1ldGVyc1wiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInNpZ25lZFRyYW5zYWN0aW9uc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFuIGFycmF5IG9mIHNpZ25lZCB0cmFuc2FjdGlvbnMgKGZyb20gdGhlIG91dHB1dCBvZiBbc2lnbl0oI3NpZ24pKSB0byBjb21iaW5lLlwiLFxuICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICBcInBhdHRlcm5cIjogXCJeW0EtRjAtOV0rJFwiLFxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBzaW5nbGUtc2lnbmVkIHRyYW5zYWN0aW9uIHJlcHJlc2VudGVkIGFzIGFuIHVwcGVyY2FzZSBoZXhhZGVjaW1hbCBzdHJpbmcgKGZyb20gdGhlIG91dHB1dCBvZiBbc2lnbl0oI3NpZ24pKVwiXG4gICAgICB9LFxuICAgICAgXCJtaW5MZW5ndGhcIjogMVxuICAgIH1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJzaWduZWRUcmFuc2FjdGlvbnNcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJjb21wdXRlTGVkZ2VySGFzaFBhcmFtZXRlcnNcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJsZWRnZXJcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiZ2V0TGVkZ2VyXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGxlZGdlciBoZWFkZXIgdG8gaGFzaC5cIlxuICAgIH1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJsZWRnZXJcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZW5lcmF0ZUFkZHJlc3NQYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwib3B0aW9uc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJPcHRpb25zIHRvIGNvbnRyb2wgaG93IHRoZSBhZGRyZXNzIGFuZCBzZWNyZXQgYXJlIGdlbmVyYXRlZC5cIixcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiZW50cm9weVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgICAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgICAgICAgXCJtYXhpbXVtXCI6IDI1NVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBlbnRyb3B5IHRvIHVzZSB0byBnZW5lcmF0ZSB0aGUgc2VlZC4gTXVzdCBiZSBhbiBhcnJheSBvZiBsZW5ndGggMTYgd2l0aCB2YWx1ZXMgZnJvbSAwLTI1NSAoMTYgYnl0ZXMgb2YgZW50cm9weSlcIlxuICAgICAgICB9LFxuICAgICAgICBcImFsZ29yaXRobVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgXCJlbnVtXCI6IFtcImVjZHNhLXNlY3AyNTZrMVwiLCBcImVkMjU1MTlcIl0sXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBkaWdpdGFsIHNpZ25hdHVyZSBhbGdvcml0aG0gdG8gZ2VuZXJhdGUgYW4gYWRkcmVzcyBmb3IuIENhbiBiZSBgZWNkc2Etc2VjcDI1NmsxYCAoZGVmYXVsdCkgb3IgYGVkMjU1MTlgLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwidGVzdFwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJTcGVjaWZpZXMgd2hldGhlciB0aGUgYWRkcmVzcyBpcyBpbnRlbmRlZCBmb3IgdXNlIG9uIGEgdGVzdCBuZXR3b3JrIHN1Y2ggYXMgVGVzdG5ldCBvciBEZXZuZXQuIElmIGB0cnVlYCwgdGhlIGFkZHJlc3Mgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgdGVzdGluZywgYW5kIHN0YXJ0cyB3aXRoIGBUYC4gSWYgYGZhbHNlYCwgdGhlIGFkZHJlc3Mgc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiBNYWlubmV0LCBhbmQgc3RhcnRzIHdpdGggYFhgLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaW5jbHVkZUNsYXNzaWNBZGRyZXNzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIGB0cnVlYCwgYWxzbyByZXR1cm4gdGhlIGNsYXNzaWMgYWRkcmVzcy5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImdldEFjY291bnRJbmZvUGFyYW1ldGVyc1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiUGFyYW1ldGVycyBmb3IgZ2V0QWNjb3VudEluZm9cIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0byBnZXQgdGhlIGFjY291bnQgaW5mbyBvZi5cIlxuICAgIH0sXG4gICAgXCJvcHRpb25zXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJPcHRpb25zIHRoYXQgYWZmZWN0IHdoYXQgdG8gcmV0dXJuLlwiLFxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJsZWRnZXJWZXJzaW9uXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJsZWRnZXJWZXJzaW9uXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkdldCB0aGUgYWNjb3VudCBpbmZvIGFzIG9mIHRoaXMgaGlzdG9yaWNhbCBsZWRnZXIgdmVyc2lvbi5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiZ2V0QWNjb3VudE9iamVjdHNPcHRpb25zXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJSZXF1ZXN0IG9wdGlvbnMgZm9yIGdldEFjY291bnRPYmplY3RzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gZ2V0IHRoZSBhY2NvdW50IG9iamVjdHMgb2YuXCJcbiAgICB9LFxuICAgIFwib3B0aW9uc1wiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiT3B0aW9ucyB0aGF0IGFmZmVjdCB3aGF0IHRvIHJldHVybi5cIixcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiY2hlY2tcIixcbiAgICAgICAgICAgIFwiZXNjcm93XCIsXG4gICAgICAgICAgICBcIm9mZmVyXCIsXG4gICAgICAgICAgICBcInBheW1lbnRfY2hhbm5lbFwiLFxuICAgICAgICAgICAgXCJzaWduZXJfbGlzdFwiLFxuICAgICAgICAgICAgXCJzdGF0ZVwiXG4gICAgICAgICAgXSxcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgICAgICBcIihPcHRpb25hbCkgRmlsdGVyIHJlc3VsdHMgdG8gaW5jbHVkZSBvbmx5IHRoaXMgdHlwZSBvZiBsZWRnZXIgb2JqZWN0LiBUaGUgdmFsaWQgdHlwZXMgYXJlOiBgY2hlY2tgLCBgZXNjcm93YCwgYG9mZmVyYCwgYHBheW1lbnRfY2hhbm5lbGAsIGBzaWduZXJfbGlzdGAsIGFuZCBgc3RhdGVgICh0cnVzdCBsaW5lKS5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxlZGdlckhhc2hcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjpcbiAgICAgICAgICAgIFwiKE9wdGlvbmFsKSBBIDIwLWJ5dGUgaGV4IHN0cmluZyBmb3IgdGhlIGxlZGdlciB2ZXJzaW9uIHRvIHVzZS5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxlZGdlckluZGV4XCI6IHtcbiAgICAgICAgICBcIm9uZU9mXCI6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOlxuICAgICAgICAgICAgXCIoT3B0aW9uYWwpIFRoZSBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIGxlZGdlciB0byB1c2UsIG9yIGEgc2hvcnRjdXQgc3RyaW5nIHRvIGNob29zZSBhIGxlZGdlciBhdXRvbWF0aWNhbGx5LlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGltaXRcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgICAgICBcIm1pbmltdW1cIjogMSxcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgICAgICBcIihPcHRpb25hbCkgVGhlIG1heGltdW0gbnVtYmVyIG9mIG9iamVjdHMgdG8gaW5jbHVkZSBpbiB0aGUgcmVzdWx0cy5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiZ2V0QmFsYW5jZVNoZWV0UGFyYW1ldGVyc1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiUGFyYW1ldGVycyBmb3IgZ2V0QmFsYW5jZVNoZWV0XCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIFhSUCBMZWRnZXIgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0byBnZXQgdGhlIGJhbGFuY2Ugc2hlZXQgb2YuXCJcbiAgICB9LFxuICAgIFwib3B0aW9uc1wiOiB7XG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImV4Y2x1ZGVBZGRyZXNzZXNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwiYWRkcmVzc1wifSxcbiAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWUsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFkZHJlc3NlcyB0byBleGNsdWRlIGZyb20gdGhlIGJhbGFuY2UgdG90YWxzLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGVkZ2VyVmVyc2lvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJHZXQgdGhlIGJhbGFuY2Ugc2hlZXQgYXMgb2YgdGhpcyBoaXN0b3JpY2FsIGxlZGdlciB2ZXJzaW9uLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiT3B0aW9ucyB0byBkZXRlcm1pbmUgaG93IHRoZSBiYWxhbmNlcyBhcmUgY2FsY3VsYXRlZC5cIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2VcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiYWRkcmVzc1wiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImdldEJhbGFuY2VzUGFyYW1ldGVyc1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiUGFyYW1ldGVycyBmb3IgZ2V0QmFsYW5jZXNcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0byBnZXQgYmFsYW5jZXMgZm9yLlwiXG4gICAgfSxcbiAgICBcIm9wdGlvbnNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk9wdGlvbnMgdG8gZmlsdGVyIGFuZCBkZXRlcm1pbmUgd2hpY2ggYmFsYW5jZXMgdG8gcmV0dXJuLlwiLFxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJjb3VudGVycGFydHlcIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiT25seSByZXR1cm4gYmFsYW5jZXMgd2l0aCB0aGlzIGNvdW50ZXJwYXJ0eS5cIlxuICAgICAgICB9LFxuICAgICAgICBcImN1cnJlbmN5XCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJjdXJyZW5jeVwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJPbmx5IHJldHVybiBiYWxhbmNlcyBmb3IgdGhpcyBjdXJyZW5jeS5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbWl0XCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgXCJtaW5pbXVtXCI6IDEsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlJldHVybiBhdCBtb3N0IHRoaXMgbWFueSBiYWxhbmNlcy5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxlZGdlclZlcnNpb25cIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImxlZGdlclZlcnNpb25cIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUmV0dXJuIGJhbGFuY2VzIGFzIHRoZXkgd2VyZSBpbiB0aGlzIGhpc3RvcmljYWwgbGVkZ2VyIHZlcnNpb24uXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2VcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiYWRkcmVzc1wiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImdldExlZGdlclBhcmFtZXRlcnNcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlBhcmFtZXRlcnMgZm9yIGdldExlZGdlclwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIm9wdGlvbnNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk9wdGlvbnMgYWZmZWN0aW5nIHdoYXQgbGVkZ2VyIGFuZCBob3cgbXVjaCBkYXRhIHRvIHJldHVybi5cIixcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwibGVkZ2VySGFzaFwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkdldCBsZWRnZXIgZGF0YSBmb3IgdGhpcyBoaXN0b3JpY2FsIGxlZGdlciBoYXNoLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGVkZ2VyVmVyc2lvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJHZXQgbGVkZ2VyIGRhdGEgZm9yIHRoaXMgaGlzdG9yaWNhbCBsZWRnZXIgdmVyc2lvbi5cIlxuICAgICAgICB9LFxuICAgICAgICBcImluY2x1ZGVBbGxEYXRhXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkluY2x1ZGUgdGhlIGRldGFpbHMgb2YgdGhlIHRyYW5zYWN0aW9ucyBvciBzdGF0ZSBpbmZvcm1hdGlvbiBpZiBgaW5jbHVkZVRyYW5zYWN0aW9uc2Agb3IgYGluY2x1ZGVTdGF0ZWAgaXMgc2V0LlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaW5jbHVkZVRyYW5zYWN0aW9uc1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJSZXR1cm4gYW4gYXJyYXkgb2YgdHJhbnNhY3Rpb25zIGluIHRoaXMgbGVkZ2VyLiBCeSBkZWZhdWx0LCBwcm92aWRlcyB0aGUgaWRlbnRpZnlpbmcgaGFzaGVzIGZvciBlYWNoIHRyYW5zYWN0aW9uLiBJZiBgaW5jbHVkZUFsbERhdGFgIGlzIHRydWUsIGluY2x1ZGUgdGhlIGVudGlyZSB0cmFuc2FjdGlvbiBKU09OIGZvciBlYWNoIHRyYW5zYWN0aW9uIGluc3RlYWQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJpbmNsdWRlU3RhdGVcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUmV0dXJuIGFuIGFycmF5IG9mIHN0YXRlIGRhdGEgaW4gdGhpcyBsZWRnZXIuIEJ5IGRlZmF1bHQsIHByb3ZpZGVzIHRoZSBpZGVudGlmeWluZyBoYXNoZXMgb2Ygc3RhdGUgZGF0YS4gSWYgYGluY2x1ZGVBbGxEYXRhYCBpcyB0cnVlLCByZXR1cm4gdGhlIHN0YXRlIGRhdGEgaW4gSlNPTiBmb3JtIGluc3RlYWQuICoqQWRtaW4gcmVxdWlyZWQ6KiogVGhpcyBpcyBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIGRhdGEuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2VcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRPcmRlcmJvb2tQYXJhbWV0ZXJzXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJQYXJhbWV0ZXJzIGZvciBnZXRPcmRlcmJvb2tcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBZGRyZXNzIG9mIGFuIGFjY291bnQgdG8gdXNlIGFzIHBvaW50LW9mLXZpZXcuIChUaGlzIGFmZmVjdHMgd2hpY2ggdW5mdW5kZWQgb2ZmZXJzIGFyZSByZXR1cm5lZC4pXCJcbiAgICB9LFxuICAgIFwib3JkZXJib29rXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcIm9yZGVyYm9va1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBvcmRlciBib29rIHRvIGdldC5cIlxuICAgIH0sXG4gICAgXCJvcHRpb25zXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJPcHRpb25zIHRvIGRldGVybWluZSB3aGF0IHRvIHJldHVybi5cIixcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwibGltaXRcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgICAgICBcIm1pbmltdW1cIjogMSxcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUmV0dXJuIGF0IG1vc3QgdGhpcyBtYW55IG9yZGVycyBmcm9tIHRoZSBvcmRlciBib29rLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGVkZ2VyVmVyc2lvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJSZXR1cm4gdGhlIG9yZGVyIGJvb2sgYXMgb2YgdGhpcyBoaXN0b3JpY2FsIGxlZGdlciB2ZXJzaW9uLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIiwgXCJvcmRlcmJvb2tcIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRPcmRlcnNQYXJhbWV0ZXJzXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJQYXJhbWV0ZXJzIGZvciBnZXRPcmRlcnNcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgWFJQIExlZGdlciBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRvIGdldCBvcGVuIG9yZGVycyBmb3IuXCJcbiAgICB9LFxuICAgIFwib3B0aW9uc1wiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiT3B0aW9ucyB0aGF0IGRldGVybWluZSB3aGF0IG9yZGVycyB0byByZXR1cm4uXCIsXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImxpbWl0XCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgXCJtaW5pbXVtXCI6IDEsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlJldHVybiBhdCBtb3N0IHRoaXMgbWFueSBvcmRlcnMuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJsZWRnZXJWZXJzaW9uXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJsZWRnZXJWZXJzaW9uXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlJldHVybiBvcmRlcnMgYXMgb2YgdGhpcyBoaXN0b3JpY2FsIGxlZGdlciB2ZXJzaW9uLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRQYXRoc1BhcmFtZXRlcnNcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJwYXRoZmluZFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiU3BlY2lmaWNhdGlvbiBvZiBhIHBhdGhmaW5kIHJlcXVlc3QuXCIsXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcInNvdXJjZVwiOiB7XG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvZiBmdW5kcy5cIixcbiAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIFhSUCBMZWRnZXIgYWRkcmVzcyBvZiB0aGUgcGxhbm5lZCBzZW5kZXIuXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFtb3VudFwiOiB7XG4gICAgICAgICAgICAgIFwiJHJlZlwiOiBcImxheEFtb3VudFwiLFxuICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFtb3VudCBvZiBmdW5kcyB0byBzZW5kLlwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJjdXJyZW5jaWVzXCI6IHtcbiAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFuIGFycmF5IG9mIGN1cnJlbmNpZXMgKHdpdGggb3B0aW9uYWwgY291bnRlcnBhcnR5KSB0aGF0IG1heSBiZSB1c2VkIGluIHRoZSBwYXltZW50IHBhdGhzLlwiLFxuICAgICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBjdXJyZW5jeSB3aXRoIG9wdGlvbmFsIGNvdW50ZXJwYXJ0eS5cIixcbiAgICAgICAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgICAgICAgXCJjdXJyZW5jeVwiOiB7XCIkcmVmXCI6IFwiY3VycmVuY3lcIn0sXG4gICAgICAgICAgICAgICAgICBcImNvdW50ZXJwYXJ0eVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBjb3VudGVycGFydHkgZm9yIHRoZSBjdXJyZW5jeTsgaWYgb21pdHRlZCBhbnkgY291bnRlcnBhcnR5IG1heSBiZSB1c2VkLlwiXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcImN1cnJlbmN5XCJdLFxuICAgICAgICAgICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2VcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm5vdFwiOiB7XG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcImFtb3VudFwiLCBcImN1cnJlbmNpZXNcIl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gICAgICAgICAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCJdXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVzdGluYXRpb25cIjoge1xuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJQcm9wZXJ0aWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBvZiBmdW5kcy5cIixcbiAgICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW4gYWRkcmVzcyByZXByZXNlbnRpbmcgdGhlIGRlc3RpbmF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvbi5cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYW1vdW50XCI6IHtcbiAgICAgICAgICAgICAgXCIkcmVmXCI6IFwibGF4TGF4QW1vdW50XCIsXG4gICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYW1vdW50IHRvIGJlIHJlY2VpdmVkIGJ5IHRoZSByZWNlaXZlciAoYHZhbHVlYCBtYXkgYmUgb21taXR0ZWQgaWYgYSBzb3VyY2UgYW1vdW50IGlzIHNwZWNpZmllZCkuXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVxdWlyZWRcIjogW1wiYWRkcmVzc1wiLCBcImFtb3VudFwiXSxcbiAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IFtcInNvdXJjZVwiLCBcImRlc3RpbmF0aW9uXCJdLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJwYXRoZmluZFwiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImdldFBheW1lbnRDaGFubmVsUGFyYW1ldGVyc1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiUGFyYW1ldGVycyBmb3IgZ2V0UGF5bWVudENoYW5uZWxcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJpZFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJoYXNoMjU2XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiMjU2LWJpdCBoZXhhZGVjaW1hbCBjaGFubmVsIGlkZW50aWZpZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiaWRcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRTZXR0aW5nc1BhcmFtZXRlcnNcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlBhcmFtZXRlcnMgZm9yIGdldFNldHRpbmdzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gZ2V0IHRoZSBzZXR0aW5ncyBvZi5cIlxuICAgIH0sXG4gICAgXCJvcHRpb25zXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJPcHRpb25zIHRoYXQgYWZmZWN0IHdoYXQgdG8gcmV0dXJuLlwiLFxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJsZWRnZXJWZXJzaW9uXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJsZWRnZXJWZXJzaW9uXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkdldCB0aGUgc2V0dGluZ3MgYXMgb2YgdGhpcyBoaXN0b3JpY2FsIGxlZGdlciB2ZXJzaW9uLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRUcmFuc2FjdGlvblBhcmFtZXRlcnNcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlBhcmFtZXRlcnMgZm9yIGdldFRyYW5zYWN0aW9uXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiaWRcIjoge1wiJHJlZlwiOiBcInRyYW5zYWN0aW9uSGFzaFwifSxcbiAgICBcIm9wdGlvbnNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk9wdGlvbnMgdG8gbGltaXQgdGhlIGxlZGdlciB2ZXJzaW9ucyB0byBzZWFyY2ggb3IgaW5jbHVkZSByYXcgdHJhbnNhY3Rpb24gZGF0YS5cIixcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwibWluTGVkZ2VyVmVyc2lvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgbG93ZXN0IGxlZGdlciB2ZXJzaW9uIHRvIHNlYXJjaC4gVGhpcyBtdXN0IGJlIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIDAsIG9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHN0cmluZ3M6ICd2YWxpZGF0ZWQnLCAnY2xvc2VkJywgJ2N1cnJlbnQnLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4TGVkZ2VyVmVyc2lvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgaGlnaGVzdCBsZWRnZXIgdmVyc2lvbiB0byBzZWFyY2guIFRoaXMgbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwLCBvciBvbmUgb2YgdGhlIGZvbGxvd2luZyBzdHJpbmdzOiAndmFsaWRhdGVkJywgJ2Nsb3NlZCcsICdjdXJyZW50Jy5cIlxuICAgICAgICB9LFxuICAgICAgICBcImluY2x1ZGVSYXdUcmFuc2FjdGlvblwiOiB7XG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkluY2x1ZGUgcmF3IHRyYW5zYWN0aW9uIGRhdGEuIEZvciBhZHZhbmNlZCB1c2VyczsgZXhlcmNpc2UgY2F1dGlvbiB3aGVuIGludGVycHJldGluZyB0aGlzIGRhdGEuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2VcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiaWRcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRUcmFuc2FjdGlvbnNQYXJhbWV0ZXJzXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJQYXJhbWV0ZXJzIGZvciBnZXRUcmFuc2FjdGlvbnNcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0byBnZXQgdHJhbnNhY3Rpb25zIGZvci5cIlxuICAgIH0sXG4gICAgXCJvcHRpb25zXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJPcHRpb25zIHRvIGZpbHRlciB0aGUgcmVzdWx0aW5nIHRyYW5zYWN0aW9ucy5cIixcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwic3RhcnRcIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImhhc2gyNTZcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgc3BlY2lmaWVkLCBzdGFydCB0aGUgcmVzdWx0cyBmcm9tIHRoaXMgdHJhbnNhY3Rpb24uIFlvdSBjYW5ub3QgdXNlIGBzdGFydGAgd2l0aCBgbWluTGVkZ2VyVmVyc2lvbmAgb3IgYG1heExlZGdlclZlcnNpb25gLiBXaGVuIGBzdGFydGAgaXMgc3BlY2lmaWVkLCB0aGVzZSBsZWRnZXIgdmVyc2lvbnMgYXJlIGRldGVybWluZWQgaW50ZXJuYWxseS5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbWl0XCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgXCJtaW5pbXVtXCI6IDEsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHNwZWNpZmllZCwgcmV0dXJuIGF0IG1vc3QgdGhpcyBtYW55IHRyYW5zYWN0aW9ucy5cIlxuICAgICAgICB9LFxuICAgICAgICBcIm1pbkxlZGdlclZlcnNpb25cIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImxlZGdlclZlcnNpb25cIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUmV0dXJuIG9ubHkgdHJhbnNhY3Rpb25zIGluIHRoaXMgbGVkZ2VyIHZlcnNpb24gb3IgaGlnaGVyLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibWF4TGVkZ2VyVmVyc2lvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJSZXR1cm4gb25seSB0cmFuc2FjdGlvbnMgaW4gdGhpcyBsZWRnZXIgdmVyc2lvbiBvciBsb3dlci5cIlxuICAgICAgICB9LFxuICAgICAgICBcImVhcmxpZXN0Rmlyc3RcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgdHJ1ZSwgc29ydCB0cmFuc2FjdGlvbnMgc28gdGhhdCB0aGUgZWFybGllc3Qgb25lcyBjb21lIGZpcnN0LiBCeSBkZWZhdWx0LCB0aGUgbmV3ZXN0IHRyYW5zYWN0aW9ucyBjb21lIGZpcnN0LlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZXhjbHVkZUZhaWx1cmVzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHRydWUsIHRoZSByZXN1bHQgb21pdHMgdHJhbnNhY3Rpb25zIHRoYXQgZGlkIG5vdCBzdWNjZWVkLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiaW5pdGlhdGVkXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHRydWUsIHJldHVybiBvbmx5IHRyYW5zYWN0aW9ucyBpbml0aWF0ZWQgYnkgdGhlIGFjY291bnQgc3BlY2lmaWVkIGJ5IGBhZGRyZXNzYC4gSWYgZmFsc2UsIHJldHVybiBvbmx5IHRyYW5zYWN0aW9ucyBub3QgaW5pdGlhdGVkIGJ5IHRoZSBhY2NvdW50IHNwZWNpZmllZCBieSBgYWRkcmVzc2AuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjb3VudGVycGFydHlcIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgcHJvdmlkZWQsIG9ubHkgcmV0dXJuIHRyYW5zYWN0aW9ucyB3aXRoIHRoaXMgYWNjb3VudCBhcyBhIGNvdW50ZXJwYXJ0eSB0byB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0eXBlc1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCJ0cmFuc2FjdGlvblR5cGVcIn0sXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk9ubHkgcmV0dXJuIHRyYW5zYWN0aW9ucyBvZiB0aGUgc3BlY2lmaWVkIFtUcmFuc2FjdGlvbiBUeXBlc10oI3RyYW5zYWN0aW9uLXR5cGVzKS5cIlxuICAgICAgICB9LFxuICAgICAgICBcImluY2x1ZGVSYXdUcmFuc2FjdGlvbnNcIjoge1xuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJbmNsdWRlIHJhdyB0cmFuc2FjdGlvbiBkYXRhLiBGb3IgYWR2YW5jZWQgdXNlcnM7IGV4ZXJjaXNlIGNhdXRpb24gd2hlbiBpbnRlcnByZXRpbmcgdGhpcyBkYXRhLiBcIlxuICAgICAgICB9LFxuICAgICAgICBcImJpbmFyeVwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiB0cnVlLCByZXR1cm4gdHJhbnNhY3Rpb25zIGluIGJpbmFyeSBmb3JtYXQgcmF0aGVyIHRoYW4gSlNPTi5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgICAgIFwibm90XCI6IHtcbiAgICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgICAge1wicmVxdWlyZWRcIjogW1wic3RhcnRcIiwgXCJtaW5MZWRnZXJWZXJzaW9uXCJdfSxcbiAgICAgICAgICB7XCJyZXF1aXJlZFwiOiBbXCJzdGFydFwiLCBcIm1heExlZGdlclZlcnNpb25cIl19XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiYWRkcmVzc1wiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImdldFRydXN0bGluZXNQYXJhbWV0ZXJzXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJQYXJhbWV0ZXJzIGZvciBnZXRUcnVzdGxpbmVzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gZ2V0IHRydXN0bGluZXMgZm9yLlwiXG4gICAgfSxcbiAgICBcIm9wdGlvbnNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk9wdGlvbnMgdG8gZmlsdGVyIGFuZCBkZXRlcm1pbmUgd2hpY2ggdHJ1c3RsaW5lcyB0byByZXR1cm4uXCIsXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImNvdW50ZXJwYXJ0eVwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJPbmx5IHJldHVybiB0cnVzdGxpbmVzIHdpdGggdGhpcyBjb3VudGVycGFydHkuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJjdXJyZW5jeVwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwiY3VycmVuY3lcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiT25seSByZXR1cm4gdHJ1c3RsaW5lcyBmb3IgdGhpcyBjdXJyZW5jeS5cIlxuICAgICAgICB9LFxuICAgICAgICBcImxpbWl0XCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgXCJtaW5pbXVtXCI6IDEsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlJldHVybiBhdCBtb3N0IHRoaXMgbWFueSB0cnVzdGxpbmVzLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGVkZ2VyVmVyc2lvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJSZXR1cm4gdHJ1c3RsaW5lcyBhcyB0aGV5IHdlcmUgaW4gdGhpcyBoaXN0b3JpY2FsIGxlZGdlciB2ZXJzaW9uLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgfVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwcmVwYXJlQ2hlY2tDYW5jZWxQYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBpcyBjcmVhdGluZyB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwiY2hlY2tDYW5jZWxcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiY2hlY2tDYW5jZWxcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgQ2hlY2sgY2FuY2VsbGF0aW9uIHRvIHByZXBhcmUuXCJcbiAgICB9LFxuICAgIFwiaW5zdHJ1Y3Rpb25zXCI6IHtcIiRyZWZcIjogXCJpbnN0cnVjdGlvbnNcIn1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCIsIFwiY2hlY2tDYW5jZWxcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwcmVwYXJlQ2hlY2tDYXNoUGFyYW1ldGVyc1wiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImFkZHJlc3NcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgaXMgY3JlYXRpbmcgdGhlIHRyYW5zYWN0aW9uLlwiXG4gICAgfSxcbiAgICBcImNoZWNrQ2FzaFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJjaGVja0Nhc2hcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgQ2hlY2sgY2FzaCB0byBwcmVwYXJlLlwiXG4gICAgfSxcbiAgICBcImluc3RydWN0aW9uc1wiOiB7XCIkcmVmXCI6IFwiaW5zdHJ1Y3Rpb25zXCJ9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiYWRkcmVzc1wiLCBcImNoZWNrQ2FzaFwiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInByZXBhcmVDaGVja0NyZWF0ZVBhcmFtZXRlcnNcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0aGF0IGlzIGNyZWF0aW5nIHRoZSB0cmFuc2FjdGlvbi5cIlxuICAgIH0sXG4gICAgXCJjaGVja0NyZWF0ZVwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJjaGVja0NyZWF0ZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBzcGVjaWZpY2F0aW9uIG9mIHRoZSBDaGVjayBjcmVhdGUgY3JlYXRpb24gdG8gcHJlcGFyZS5cIlxuICAgIH0sXG4gICAgXCJpbnN0cnVjdGlvbnNcIjoge1wiJHJlZlwiOiBcImluc3RydWN0aW9uc1wifVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIiwgXCJjaGVja0NyZWF0ZVwiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInByZXBhcmVFc2Nyb3dDYW5jZWxsYXRpb25QYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBpcyBjcmVhdGluZyB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwiZXNjcm93Q2FuY2VsbGF0aW9uXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImVzY3Jvd0NhbmNlbGxhdGlvblwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBzcGVjaWZpY2F0aW9uIG9mIHRoZSBlc2Nyb3cgY2FuY2VsbGF0aW9uIHRvIHByZXBhcmUuXCJcbiAgICB9LFxuICAgIFwiaW5zdHJ1Y3Rpb25zXCI6IHtcIiRyZWZcIjogXCJpbnN0cnVjdGlvbnNcIn1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCIsIFwiZXNjcm93Q2FuY2VsbGF0aW9uXCJdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwicHJlcGFyZUVzY3Jvd0NyZWF0aW9uUGFyYW1ldGVyc1wiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImFkZHJlc3NcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgaXMgY3JlYXRpbmcgdGhlIHRyYW5zYWN0aW9uLlwiXG4gICAgfSxcbiAgICBcImVzY3Jvd0NyZWF0aW9uXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImVzY3Jvd0NyZWF0aW9uXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIGVzY3JvdyBjcmVhdGlvbiB0byBwcmVwYXJlLlwiXG4gICAgfSxcbiAgICBcImluc3RydWN0aW9uc1wiOiB7XCIkcmVmXCI6IFwiaW5zdHJ1Y3Rpb25zXCJ9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiYWRkcmVzc1wiLCBcImVzY3Jvd0NyZWF0aW9uXCJdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwicHJlcGFyZUVzY3Jvd0V4ZWN1dGlvblBhcmFtZXRlcnNcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0aGF0IGlzIGNyZWF0aW5nIHRoZSB0cmFuc2FjdGlvbi5cIlxuICAgIH0sXG4gICAgXCJlc2Nyb3dFeGVjdXRpb25cIjoge1xuICAgICAgXCIkcmVmXCI6IFwiZXNjcm93RXhlY3V0aW9uXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHNwZWNpZmljYXRpb24gb2YgdGhlIGVzY3JvdyBleGVjdXRpb24gdG8gcHJlcGFyZS5cIlxuICAgIH0sXG4gICAgXCJpbnN0cnVjdGlvbnNcIjoge1wiJHJlZlwiOiBcImluc3RydWN0aW9uc1wifVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIiwgXCJlc2Nyb3dFeGVjdXRpb25cIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwcmVwYXJlT3JkZXJDYW5jZWxsYXRpb25QYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBpcyBjcmVhdGluZyB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwib3JkZXJDYW5jZWxsYXRpb25cIjoge1xuICAgICAgXCIkcmVmXCI6IFwib3JkZXJDYW5jZWxsYXRpb25cIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgb3JkZXIgY2FuY2VsbGF0aW9uIHRvIHByZXBhcmUuXCJcbiAgICB9LFxuICAgIFwiaW5zdHJ1Y3Rpb25zXCI6IHtcIiRyZWZcIjogXCJpbnN0cnVjdGlvbnNcIn1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCIsIFwib3JkZXJDYW5jZWxsYXRpb25cIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwcmVwYXJlT3JkZXJQYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBpcyBjcmVhdGluZyB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwib3JkZXJcIjoge1xuICAgICAgXCIkcmVmXCI6IFwib3JkZXJcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgb3JkZXIgdG8gcHJlcGFyZS5cIlxuICAgIH0sXG4gICAgXCJpbnN0cnVjdGlvbnNcIjoge1wiJHJlZlwiOiBcImluc3RydWN0aW9uc1wifVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIiwgXCJvcmRlclwiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInByZXBhcmVQYXltZW50Q2hhbm5lbENsYWltUGFyYW1ldGVyc1wiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImFkZHJlc3NcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgaXMgY3JlYXRpbmcgdGhlIHRyYW5zYWN0aW9uLlwiXG4gICAgfSxcbiAgICBcInBheW1lbnRDaGFubmVsQ2xhaW1cIjoge1xuICAgICAgXCIkcmVmXCI6IFwicGF5bWVudENoYW5uZWxDbGFpbVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkRldGFpbHMgb2YgdGhlIGNoYW5uZWwgYW5kIGNsYWltLlwiXG4gICAgfSxcbiAgICBcImluc3RydWN0aW9uc1wiOiB7XCIkcmVmXCI6IFwiaW5zdHJ1Y3Rpb25zXCJ9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiYWRkcmVzc1wiLCBcInBheW1lbnRDaGFubmVsQ2xhaW1cIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwcmVwYXJlUGF5bWVudENoYW5uZWxDcmVhdGVQYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBpcyBjcmVhdGluZyB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwicGF5bWVudENoYW5uZWxDcmVhdGVcIjoge1xuICAgICAgXCIkcmVmXCI6IFwicGF5bWVudENoYW5uZWxDcmVhdGVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgcGF5bWVudCBjaGFubmVsIHRvIGNyZWF0ZS5cIlxuICAgIH0sXG4gICAgXCJpbnN0cnVjdGlvbnNcIjoge1wiJHJlZlwiOiBcImluc3RydWN0aW9uc1wifVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIiwgXCJwYXltZW50Q2hhbm5lbENyZWF0ZVwiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInByZXBhcmVQYXltZW50Q2hhbm5lbEZ1bmRQYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBpcyBjcmVhdGluZyB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwicGF5bWVudENoYW5uZWxGdW5kXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInBheW1lbnRDaGFubmVsRnVuZFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBjaGFubmVsIHRvIGZ1bmQsIGFuZCB0aGUgZGV0YWlscyBvZiBob3cgdG8gZnVuZCBpdC5cIlxuICAgIH0sXG4gICAgXCJpbnN0cnVjdGlvbnNcIjoge1wiJHJlZlwiOiBcImluc3RydWN0aW9uc1wifVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIiwgXCJwYXltZW50Q2hhbm5lbEZ1bmRcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwcmVwYXJlUGF5bWVudFBhcmFtZXRlcnNcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0aGF0IGlzIGNyZWF0aW5nIHRoZSB0cmFuc2FjdGlvbi5cIlxuICAgIH0sXG4gICAgXCJwYXltZW50XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInBheW1lbnRcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgcGF5bWVudCB0byBwcmVwYXJlLlwiXG4gICAgfSxcbiAgICBcImluc3RydWN0aW9uc1wiOiB7XCIkcmVmXCI6IFwiaW5zdHJ1Y3Rpb25zXCJ9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiYWRkcmVzc1wiLCBcInBheW1lbnRcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwcmVwYXJlU2V0dGluZ3NQYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBpcyBjcmVhdGluZyB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwic2V0dGluZ3NcIjoge1xuICAgICAgXCIkcmVmXCI6IFwic2V0dGluZ3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgc2V0dGluZ3MgdG8gcHJlcGFyZS5cIlxuICAgIH0sXG4gICAgXCJpbnN0cnVjdGlvbnNcIjoge1wiJHJlZlwiOiBcImluc3RydWN0aW9uc1wifVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIiwgXCJzZXR0aW5nc1wiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInByZXBhcmVUaWNrZXRQYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBpcyBjcmVhdGluZyB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwidGlja2V0Q291bnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIG51bWJlciBvZiB0aWNrZXRzIHRvIGJlIGNyZWF0ZWQuXCJcbiAgICB9LFxuICAgIFwiaW5zdHJ1Y3Rpb25zXCI6IHtcIiRyZWZcIjogXCJpbnN0cnVjdGlvbnNcIn1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCIsIFwidGlja2V0Q291bnRcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwcmVwYXJlVHJ1c3RsaW5lUGFyYW1ldGVyc1wiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImFkZHJlc3NcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgaXMgY3JlYXRpbmcgdGhlIHRyYW5zYWN0aW9uLlwiXG4gICAgfSxcbiAgICBcInRydXN0bGluZVwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJ0cnVzdGxpbmVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgdHJ1c3RsaW5lIHRvIHByZXBhcmUuXCJcbiAgICB9LFxuICAgIFwiaW5zdHJ1Y3Rpb25zXCI6IHtcIiRyZWZcIjogXCJpbnN0cnVjdGlvbnNcIn1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCIsIFwidHJ1c3RsaW5lXCJdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwic2lnblBheW1lbnRDaGFubmVsQ2xhaW1QYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiY2hhbm5lbFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJoYXNoMjU2XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiMjU2LWJpdCBoZXhhZGVjaW1hbCBjaGFubmVsIGlkZW50aWZpZXIuXCJcbiAgICB9LFxuICAgIFwiYW1vdW50XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInZhbHVlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW1vdW50IG9mIFhSUCBhdXRob3JpemVkIGJ5IHRoZSBjbGFpbS5cIlxuICAgIH0sXG4gICAgXCJwcml2YXRlS2V5XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInB1YmxpY0tleVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBwcml2YXRlIGtleSB0byBzaWduIHRoZSBwYXltZW50IGNoYW5uZWwgY2xhaW0uXCJcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiY2hhbm5lbFwiLCBcImFtb3VudFwiLCBcInByaXZhdGVLZXlcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJzaWduUGFyYW1ldGVyc1wiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInR4SlNPTlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUcmFuc2FjdGlvbiByZXByZXNlbnRlZCBhcyBhIEpTT04gc3RyaW5nIGluIHJpcHBsZWQgZm9ybWF0LlwiXG4gICAgfSxcbiAgICBcInNlY3JldFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwic2VjcmV0XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHNlY3JldCBvZiB0aGUgYWNjb3VudCB0aGF0IGlzIGluaXRpYXRpbmcgdGhlIHRyYW5zYWN0aW9uLiAoVGhpcyBmaWVsZCBjYW5ub3QgYmUgdXNlZCB3aXRoIGtleXBhaXIpLlwiXG4gICAgfSxcbiAgICBcImtleXBhaXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcInByaXZhdGVLZXlcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcInByaXZhdGVLZXlcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHVwcGVyY2FzZSBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VjcDI1NmsxIG9yIEVkMjU1MTkgcHJpdmF0ZSBrZXkuIEVkMjU1MTkga2V5cyBhcmUgcHJlZml4ZWQgd2l0aCAweEVELiBZb3UgY2FuIHJlYWQgYWJvdXQgaG93IGtleXMgYXJlIGRlcml2ZWQgW2hlcmVdKGh0dHBzOi8veHJwbC5vcmcvY3J5cHRvZ3JhcGhpYy1rZXlzLmh0bWwpLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicHVibGljS2V5XCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJwdWJsaWNLZXlcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHVwcGVyY2FzZSBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VjcDI1NmsxIG9yIEVkMjU1MTkgcHVibGljIGtleS4gRWQyNTUxOSBrZXlzIGFyZSBwcmVmaXhlZCB3aXRoIDB4RUQuIFlvdSBjYW4gcmVhZCBhYm91dCBob3cga2V5cyBhcmUgZGVyaXZlZCBbaGVyZV0oaHR0cHM6Ly94cnBsLm9yZy9jcnlwdG9ncmFwaGljLWtleXMuaHRtbCkuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgcHJpdmF0ZSBhbmQgcHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB0aGF0IGlzIGluaXRpYXRpbmcgdGhlIHRyYW5zYWN0aW9uLiAoVGhpcyBmaWVsZCBjYW5ub3QgYmUgdXNlZCB3aXRoIHNlY3JldCkuXCIsXG4gICAgICBcInJlcXVpcmVkXCI6IFtcInByaXZhdGVLZXlcIiwgXCJwdWJsaWNLZXlcIl0sXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgfSxcbiAgICBcIm9wdGlvbnNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiT3B0aW9ucyB0aGF0IGNvbnRyb2wgdGhlIHR5cGUgb2Ygc2lnbmF0dXJlIHRvIGNyZWF0ZS5cIixcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwic2lnbkFzXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBhY2NvdW50IHRoYXQgdGhlIHNpZ25hdHVyZSBzaG91bGQgY291bnQgZm9yIGluIG11bHRpc2lnbmluZy5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJ0eEpTT05cIl0sXG4gIFwib25lT2ZcIjogW1xuICAgIHtcbiAgICAgIFwicmVxdWlyZWRcIjogW1wic2VjcmV0XCJdLFxuICAgICAgXCJub3RcIjoge1wicmVxdWlyZWRcIjogW1wia2V5cGFpclwiXX1cbiAgICB9LFxuICAgIHtcbiAgICAgIFwicmVxdWlyZWRcIjogW1wia2V5cGFpclwiXSxcbiAgICAgIFwibm90XCI6IHtcInJlcXVpcmVkXCI6IFtcInNlY3JldFwiXX1cbiAgICB9XG4gIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJzdWJtaXRQYXJhbWV0ZXJzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwic2lnbmVkVHJhbnNhY3Rpb25cIjoge1xuICAgICAgXCIkcmVmXCI6IFwiYmxvYlwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgc2lnbmVkIHRyYW5zYWN0aW9uIGFzIHJldHVybmVkIGJ5IFtzaWduXSgjc2lnbikuXCJcbiAgICB9LFxuICAgIFwiZmFpbEhhcmRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIGB0cnVlYCwgYW5kIHRoZSB0cmFuc2FjdGlvbiBmYWlscyBsb2NhbGx5LCBkbyBub3QgcmV0cnkgb3IgcmVsYXkgdGhlIHRyYW5zYWN0aW9uIHRvIG90aGVyIHNlcnZlcnMuIERlZmF1bHRzIHRvIGBmYWxzZWAuXCJcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wic2lnbmVkVHJhbnNhY3Rpb25cIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJ2ZXJpZnlQYXltZW50Q2hhbm5lbENsYWltUGFyYW1ldGVyc1wiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImNoYW5uZWxcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiaGFzaDI1NlwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIjI1Ni1iaXQgaGV4YWRlY2ltYWwgY2hhbm5lbCBpZGVudGlmaWVyLlwiXG4gICAgfSxcbiAgICBcImFtb3VudFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJ2YWx1ZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFtb3VudCBvZiBYUlAgYXV0aG9yaXplZCBieSB0aGUgY2xhaW0uXCJcbiAgICB9LFxuICAgIFwic2lnbmF0dXJlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInNpZ25hdHVyZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlNpZ25hdHVyZSBvZiB0aGlzIGNsYWltLlwiXG4gICAgfSxcbiAgICBcInB1YmxpY0tleVwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJwdWJsaWNLZXlcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJQdWJsaWMga2V5IG9mIHRoZSBjaGFubmVsJ3Mgc2VuZGVyXCJcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiY2hhbm5lbFwiLCBcImFtb3VudFwiLCBcInNpZ25hdHVyZVwiLCBcInB1YmxpY0tleVwiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImFkZHJlc3NcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkFuIGFjY291bnQgYWRkcmVzcyBvbiB0aGUgWFJQIExlZGdlclwiLFxuICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgXCJmb3JtYXRcIjogXCJhZGRyZXNzXCIsXG4gIFwibGlua1wiOiBcImFkZHJlc3NcIixcbiAgXCJvbmVPZlwiOiBbXG4gICAge1wiJHJlZlwiOiBcInhBZGRyZXNzXCJ9LFxuICAgIHtcIiRyZWZcIjogXCJjbGFzc2ljQWRkcmVzc1wifVxuICBdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiYWRqdXN0bWVudFwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImFkZHJlc3NcIjoge1wiJHJlZlwiOiBcImFkZHJlc3NcIn0sXG4gICAgXCJhbW91bnRcIjoge1wiJHJlZlwiOiBcImFtb3VudFwifSxcbiAgICBcInRhZ1wiOiB7XCIkcmVmXCI6IFwidGFnXCJ9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogW1wiYWRkcmVzc1wiLCBcImFtb3VudFwiXSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImFtb3VudFwiLFxuICBcImxpbmtcIjogXCJhbW91bnRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkFuIEFtb3VudCBvbiB0aGUgWFJQIExlZGdlclwiLFxuICBcImFsbE9mXCI6IFtcbiAgICB7XCIkcmVmXCI6IFwiYW1vdW50YmFzZVwifSxcbiAgICB7XCJyZXF1aXJlZFwiOiBbXCJ2YWx1ZVwiXX1cbiAgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImFtb3VudGJhc2VcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkJhc2UgY2xhc3MgZm9yIGFtb3VudCBhbmQgaXNzdWVcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJ2YWx1ZVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHF1YW50aXR5IG9mIHRoZSBjdXJyZW5jeSwgZGVub3RlZCBhcyBhIHN0cmluZyBzbyB0aGF0IGl0IGRvZXMgbm90IGxvc2UgcHJlY2lzaW9uXCIsXG4gICAgICBcIiRyZWZcIjogXCJ2YWx1ZVwiXG4gICAgfSxcbiAgICBcImN1cnJlbmN5XCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgdGhyZWUtY2hhcmFjdGVyIGNvZGUgb3IgaGV4YWRlY2ltYWwgc3RyaW5nIHVzZWQgdG8gZGVub3RlIGN1cnJlbmNpZXMsIG9yIFxcXCJkcm9wc1xcXCIgZm9yIHRoZSBzbWFsbGVzdCB1bml0IG9mIFhSUC5cIixcbiAgICAgIFwiJHJlZlwiOiBcImN1cnJlbmN5XCJcbiAgICB9LFxuICAgIFwiY291bnRlcnBhcnR5XCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgWFJQIExlZGdlciBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgb3dlcyBvciBpcyBvd2VkIHRoZSBmdW5kcyAob21pdHRlZCBpZiBgY3VycmVuY3lgIGlzIFxcXCJYUlBcXFwiIG9yIFxcXCJkcm9wc1xcXCIpXCIsXG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCJcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiY3VycmVuY3lcIl0sXG4gIFwib25lT2ZcIjogW1xuICAgIHtcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiY3VycmVuY3lcIjoge1xuICAgICAgICAgIFwibm90XCI6IHtcbiAgICAgICAgICAgIFwiZW51bVwiOiBbXCJYUlBcIiwgXCJkcm9wc1wiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogW1wiY291bnRlcnBhcnR5XCJdXG4gICAgfSxcbiAgICB7XG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImN1cnJlbmN5XCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1wiWFJQXCIsIFwiZHJvcHNcIl1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwibm90XCI6IHtcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXCJjb3VudGVycGFydHlcIl1cbiAgICAgIH1cbiAgICB9XG4gIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJiYWxhbmNlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJCYWxhbmNlIGFtb3VudFwiLFxuICBcImxpbmtcIjogXCJhbW91bnRcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJ2YWx1ZVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGJhbGFuY2Ugb24gdGhlIHRydXN0bGluZVwiLFxuICAgICAgXCIkcmVmXCI6IFwic2lnbmVkVmFsdWVcIlxuICAgIH0sXG4gICAgXCJjdXJyZW5jeVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHRocmVlLWNoYXJhY3RlciBjb2RlIG9yIGhleGFkZWNpbWFsIHN0cmluZyB1c2VkIHRvIGRlbm90ZSBjdXJyZW5jaWVzXCIsXG4gICAgICBcIiRyZWZcIjogXCJjdXJyZW5jeVwiXG4gICAgfSxcbiAgICBcImNvdW50ZXJwYXJ0eVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIFhSUCBMZWRnZXIgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0aGF0IG93ZXMgb3IgaXMgb3dlZCB0aGUgZnVuZHMuXCIsXG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCJcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiY3VycmVuY3lcIiwgXCJ2YWx1ZVwiXSxcbiAgXCJvbmVPZlwiOiBbXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJjdXJyZW5jeVwiOiB7XG4gICAgICAgICAgXCJub3RcIjoge1xuICAgICAgICAgICAgXCJlbnVtXCI6IFtcIlhSUFwiXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogW1wiY291bnRlcnBhcnR5XCJdXG4gICAgfSxcbiAgICB7XG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImN1cnJlbmN5XCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1wiWFJQXCJdXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcIm5vdFwiOiB7XG4gICAgICAgIFwicmVxdWlyZWRcIjogW1wiY291bnRlcnBhcnR5XCJdXG4gICAgICB9XG4gICAgfVxuICBdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiYmxvYlwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQW4gdXBwZXJjYXNlIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHRyYW5zYWN0aW9uXCIsXG4gIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICBcIm1pbkxlbmd0aFwiOiAxLFxuICBcInBhdHRlcm5cIjogXCJeWzAtOUEtRl0qJFwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiY2xhc3NpY0FkZHJlc3NcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgY2xhc3NpYyBhZGRyZXNzIChBY2NvdW50IElEKSBmb3IgdGhlIFhSUCBMZWRnZXJcIixcbiAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gIFwiZm9ybWF0XCI6IFwiY2xhc3NpY0FkZHJlc3NcIixcbiAgXCJsaW5rXCI6IFwiY2xhc3NpYy1hZGRyZXNzXCIsXG4gIFwicGF0dGVyblwiOiBcIl5yWzEtOUEtSEotTlAtWmEta20tel17MjQsMzR9JFwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiY3VycmVuY3lcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB0aHJlZS1jaGFyYWN0ZXIgY29kZSBvciBoZXhhZGVjaW1hbCBzdHJpbmcgdXNlZCB0byBkZW5vdGUgY3VycmVuY2llc1wiLFxuICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgXCJsaW5rXCI6IFwiY3VycmVuY3lcIixcbiAgXCJwYXR0ZXJuXCI6IFwiXihbYS16QS1aMC05PD4oKXt9W1xcXFxdfD8hQCMkJV4mKl17M318W0EtRjAtOV17NDB9fGRyb3BzKSRcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImRlc3RpbmF0aW9uQWRkcmVzc1RhZ1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBkZXN0aW5hdGlvbiBhZGRyZXNzIGFuZCBvcHRpb25hbCB0YWcsIHdpdGggbm8gYW1vdW50IGluY2x1ZGVkLiBXaGVuIHBhcnNpbmcgYW4gaW5jb21pbmcgdHJhbnNhY3Rpb24sIHRoZSBvcmlnaW5hbCBzcGVjaWZpY2F0aW9uJ3MgYW1vdW50IGlzIGhpZGRlbiB0byBwcmV2ZW50IG1pc2ludGVycHJldGF0aW9uLiBGb3IgdGhlIGFtb3VudCB0aGF0IHRoZSB0cmFuc2FjdGlvbiBkZWxpdmVyZWQsIHNlZSBgb3V0Y29tZS5kZWxpdmVyZWRBbW91bnRgLlwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImFkZHJlc3NcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFuIGFkZHJlc3MgcmVwcmVzZW50aW5nIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwidGFnXCI6IHtcIiRyZWZcIjogXCJ0YWdcIn1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiZGVzdGluYXRpb25BZGp1c3RtZW50XCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcIm9uZU9mXCI6IFtcbiAgICB7XCIkcmVmXCI6IFwiZGVzdGluYXRpb25FeGFjdEFkanVzdG1lbnRcIn0sXG4gICAge1wiJHJlZlwiOiBcIm1pbkFkanVzdG1lbnRcIn1cbiAgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImRlc3RpbmF0aW9uRXhhY3RBZGp1c3RtZW50XCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW4gYWRkcmVzcyByZXByZXNlbnRpbmcgdGhlIGRlc3RpbmF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvbi5cIlxuICAgIH0sXG4gICAgXCJhbW91bnRcIjoge1xuICAgICAgXCIkcmVmXCI6IFwibGF4QW1vdW50XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW4gZXhhY3QgYW1vdW50IHRvIGRlbGl2ZXIgdG8gdGhlIHJlY2lwaWVudC4gSWYgdGhlIGNvdW50ZXJwYXJ0eSBpcyBub3Qgc3BlY2lmaWVkLCBhbW91bnRzIHdpdGggYW55IGNvdW50ZXJwYXJ0eSBtYXkgYmUgdXNlZC4gKFRoaXMgZmllbGQgY2Fubm90IGJlIHVzZWQgd2l0aCBgZGVzdGluYXRpb24ubWluQW1vdW50YC4pXCJcbiAgICB9LFxuICAgIFwidGFnXCI6IHtcIiRyZWZcIjogXCJ0YWdcIn1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCIsIFwiYW1vdW50XCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiaGFzaDEyOFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgMTI4LWJpdCBoYXNoXCIsXG4gIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICBcInBhdHRlcm5cIjogXCJeW0EtRjAtOV17MzJ9JFwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiaGFzaDI1NlwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgMjU2LWJpdCBoYXNoXCIsXG4gIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICBcInBhdHRlcm5cIjogXCJeW0EtRjAtOV17NjR9JFwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiaW5zdHJ1Y3Rpb25zXCIsXG4gIFwibGlua1wiOiBcInRyYW5zYWN0aW9uLWluc3RydWN0aW9uc1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSW5zdHJ1Y3Rpb25zIGZvciBleGVjdXRpbmcgdGhlIHRyYW5zYWN0aW9uXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwic2VxdWVuY2VcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBpbml0aWF0aW5nIGFjY291bnQncyBzZXF1ZW5jZSBudW1iZXIgZm9yIHRoaXMgdHJhbnNhY3Rpb24uIGBzZXF1ZW5jZWAgYW5kIGB0aWNrZXRTZXF1ZW5jZWAgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgb25seSBvbmUgb2YgdGhlbSBjYW4gYmUgc2V0LlwiLFxuICAgICAgXCIkcmVmXCI6IFwic2VxdWVuY2VcIlxuICAgIH0sXG4gICAgXCJ0aWNrZXRTZXF1ZW5jZVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHRpY2tldCBzZXF1ZW5jZSB0byBiZSB1c2VkIGZvciB0aGlzIHRyYW5zYWN0aW9uLiBgc2VxdWVuY2VgIGFuZCBgdGlja2V0U2VxdWVuY2VgIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIG9ubHkgb25lIG9mIHRoZW0gY2FuIGJlIHNldC5cIixcbiAgICAgIFwiJHJlZlwiOiBcInRpY2tldC1zZXF1ZW5jZVwiXG4gICAgfSxcbiAgICBcImZlZVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW4gZXhhY3QgZmVlIHRvIHBheSBmb3IgdGhlIHRyYW5zYWN0aW9uLCBiZWZvcmUgbXVsdGlwbHlpbmcgZm9yIG11bHRpLXNpZ25lZCB0cmFuc2FjdGlvbnMuIFNlZSBbVHJhbnNhY3Rpb24gRmVlc10oI3RyYW5zYWN0aW9uLWZlZXMpIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiLFxuICAgICAgXCIkcmVmXCI6IFwidmFsdWVcIlxuICAgIH0sXG4gICAgXCJtYXhGZWVcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlcHJlY2F0ZWQ6IFVzZSBgbWF4RmVlWFJQYCBpbiB0aGUgUmlwcGxlQVBJIGNvbnN0cnVjdG9yIGluc3RlYWQuIFRoZSBtYXhpbXVtIGZlZSB0byBwYXkgZm9yIHRoaXMgdHJhbnNhY3Rpb24uIElmIHRoaXMgZXhjZWVkcyBgbWF4RmVlWFJQYCwgdXNlIGBtYXhGZWVYUlBgIGluc3RlYWQuIFNlZSBbVHJhbnNhY3Rpb24gRmVlc10oI3RyYW5zYWN0aW9uLWZlZXMpIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiLFxuICAgICAgXCIkcmVmXCI6IFwidmFsdWVcIlxuICAgIH0sXG4gICAgXCJtYXhMZWRnZXJWZXJzaW9uXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgaGlnaGVzdCBsZWRnZXIgdmVyc2lvbiB0aGF0IHRoZSB0cmFuc2FjdGlvbiBjYW4gYmUgaW5jbHVkZWQgaW4uIElmIHRoaXMgb3B0aW9uIGFuZCBgbWF4TGVkZ2VyVmVyc2lvbk9mZnNldGAgYXJlIGJvdGggb21pdHRlZCwgdGhlIGRlZmF1bHQgaXMgMyBncmVhdGVyIHRoYW4gdGhlIGN1cnJlbnQgdmFsaWRhdGVkIGxlZGdlciB2ZXJzaW9uIChlcXVpdmFsZW50IHRvIGBtYXhMZWRnZXJWZXJzaW9uT2Zmc2V0PTNgKS4gVXNlIGBudWxsYCB0byBub3Qgc2V0IGEgbWF4aW11bSBsZWRnZXIgdmVyc2lvbi4gSWYgbm90IG51bGwsIHRoaXMgbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiAwLCBvciBvbmUgb2YgdGhlIGZvbGxvd2luZyBzdHJpbmdzOiAndmFsaWRhdGVkJywgJ2Nsb3NlZCcsICdjdXJyZW50Jy5cIixcbiAgICAgIFwib25lT2ZcIjogW1xuICAgICAgICB7XCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwifSxcbiAgICAgICAge1widHlwZVwiOiBcIm51bGxcIn1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwibWF4TGVkZ2VyVmVyc2lvbk9mZnNldFwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiT2Zmc2V0IGZyb20gY3VycmVudCB2YWxpZGF0ZWQgbGVkZ2VyIHZlcnNpb24gdG8gaGlnaGVzdCBsZWRnZXIgdmVyc2lvbiB0aGF0IHRoZSB0cmFuc2FjdGlvbiBjYW4gYmUgaW5jbHVkZWQgaW4uXCIsXG4gICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMFxuICAgIH0sXG4gICAgXCJzaWduZXJzQ291bnRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk51bWJlciBvZiBzaWduZXJzIHRoYXQgY2FuIG11bHRpLXNpZ24gdGhpcyB0cmFuc2FjdGlvbi5cIixcbiAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAxXG4gICAgfVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICBcIm5vdFwiOiB7XG4gICAgXCJhbnlPZlwiOiBbXG4gICAgICB7XG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJmZWUgYW5kIG1heEZlZSBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1wiZmVlXCIsIFwibWF4RmVlXCJdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwibWF4TGVkZ2VyVmVyc2lvbiBhbmQgbWF4TGVkZ2VyVmVyc2lvbk9mZnNldCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlXCIsXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1wibWF4TGVkZ2VyVmVyc2lvblwiLCBcIm1heExlZGdlclZlcnNpb25PZmZzZXRcIl1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJzZXF1ZW5jZSBhbmQgdGlja2V0U2VxdWVuY2UgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZVwiLFxuICAgICAgICBcInJlcXVpcmVkXCI6IFtcInNlcXVlbmNlXCIsIFwidGlja2V0U2VxdWVuY2VcIl1cbiAgICAgIH1cbiAgICBdXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJpc3N1ZVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGN1cnJlbmN5IGNvZGUsIGFuZCB0aGUgY291bnRlcnBhcnR5IGlmIGl0J3Mgbm90IFhSUC5cIixcbiAgXCJhbGxPZlwiOiBbXG4gICAge1wiJHJlZlwiOiBcImFtb3VudGJhc2VcIn0sXG4gICAge1wibm90XCI6IHtcInJlcXVpcmVkXCI6IFtcInZhbHVlXCJdfX1cbiAgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImxheEFtb3VudFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQW1vdW50IHdoZXJlIGNvdW50ZXJwYXJ0eSBpcyBvcHRpb25hbFwiLFxuICBcImxpbmtcIjogXCJhbW91bnRcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJjdXJyZW5jeVwiOiB7XCIkcmVmXCI6IFwiY3VycmVuY3lcIn0sXG4gICAgXCJjb3VudGVycGFydHlcIjoge1wiJHJlZlwiOiBcImFkZHJlc3NcIn0sXG4gICAgXCJ2YWx1ZVwiOiB7XCIkcmVmXCI6IFwidmFsdWVcIn1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJjdXJyZW5jeVwiLCBcInZhbHVlXCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwibGF4TGF4QW1vdW50XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBbW91bnQgd2hlcmUgY291bnRlcnBhcnR5IGFuZCB2YWx1ZSBhcmUgb3B0aW9uYWxcIixcbiAgXCJsaW5rXCI6IFwiYW1vdW50XCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiY3VycmVuY3lcIjoge1wiJHJlZlwiOiBcImN1cnJlbmN5XCJ9LFxuICAgIFwiY291bnRlcnBhcnR5XCI6IHtcIiRyZWZcIjogXCJhZGRyZXNzXCJ9LFxuICAgIFwidmFsdWVcIjoge1wiJHJlZlwiOiBcInZhbHVlXCJ9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogW1wiY3VycmVuY3lcIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJsZWRnZXJWZXJzaW9uXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIGxlZGdlciB2ZXJzaW9uIG51bWJlclwiLFxuICBcIm9uZU9mXCI6IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMVxuICAgIH0sXG4gICAge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImVudW1cIjogW1widmFsaWRhdGVkXCIsIFwiY2xvc2VkXCIsIFwiY3VycmVudFwiXVxuICAgIH1cbiAgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcIm1heEFkanVzdG1lbnRcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhZGRyZXNzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYWRkcmVzcyB0byBzZW5kIGZyb20uXCJcbiAgICB9LFxuICAgIFwibWF4QW1vdW50XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImxheEFtb3VudFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBtYXhpbXVtIGFtb3VudCB0byBzZW5kLiAoVGhpcyBmaWVsZCBjYW5ub3QgYmUgdXNlZCB3aXRoIHNvdXJjZS5hbW91bnQpXCJcbiAgICB9LFxuICAgIFwidGFnXCI6IHtcIiRyZWZcIjogXCJ0YWdcIn1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCIsIFwibWF4QW1vdW50XCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwibWVtb1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiTWVtbyBvYmplY3RzIHJlcHJlc2VudCBhcmJpdHJhcnkgZGF0YSB0aGF0IGNhbiBiZSBpbmNsdWRlZCBpbiBhIHRyYW5zYWN0aW9uXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwidHlwZVwiOiB7XG4gICAgICBcInBhdHRlcm5cIjogXCJeW0EtWmEtejAtOVxcXFwtLl9+Oi8/I1tcXFxcXUAhJCYnKCkqKyw7PSVdKiRcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJDb252ZW50aW9uYWxseSwgYSB1bmlxdWUgcmVsYXRpb24gKGFjY29yZGluZyB0byBbUkZDIDU5ODhdKGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU5ODgjc2VjdGlvbi00KSkgdGhhdCBkZWZpbmVzIHRoZSBmb3JtYXQgb2YgdGhpcyBtZW1vLiBPbmx5IGNoYXJhY3RlcnMgYWxsb3dlZCBpbiBVUkxzIGFyZSBwZXJtaXR0ZWQuXCJcbiAgICB9LFxuICAgIFwiZm9ybWF0XCI6IHtcbiAgICAgIFwicGF0dGVyblwiOiBcIl5bQS1aYS16MC05XFxcXC0uX346Lz8jW1xcXFxdQCEkJicoKSorLDs9JV0qJFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkNvbnZlbnRpb25hbGx5IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gb24gaG93IHRoZSBtZW1vIGlzIGVuY29kZWQsIGZvciBleGFtcGxlIGFzIGEgW01JTUUgdHlwZV0oaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9tZWRpYS10eXBlcy9tZWRpYS10eXBlcy54aHRtbCkuIE9ubHkgY2hhcmFjdGVycyBhbGxvd2VkIGluIFVSTHMgYXJlIHBlcm1pdHRlZC5cIlxuICAgIH0sXG4gICAgXCJkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFyYml0cmFyeSBzdHJpbmcsIGNvbnZlbnRpb25hbGx5IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnQgb2YgdGhlIG1lbW8uXCJcbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwiYW55T2ZcIjogW1xuICAgIHtcInJlcXVpcmVkXCI6IFtcImRhdGFcIl19LFxuICAgIHtcInJlcXVpcmVkXCI6IFtcInR5cGVcIl19XG4gIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJtZW1vc1wiLFxuICBcImxpbmtcIjogXCJ0cmFuc2FjdGlvbi1tZW1vc1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQXJyYXkgb2YgbWVtb3MgdG8gYXR0YWNoIHRvIHRoZSB0cmFuc2FjdGlvbi5cIixcbiAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgXCJpdGVtc1wiOiB7XG4gICAgXCIkcmVmXCI6IFwibWVtb1wiXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJtaW5BZGp1c3RtZW50XCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW4gYWRkcmVzcyByZXByZXNlbnRpbmcgdGhlIGRlc3RpbmF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvbi5cIlxuICAgIH0sXG4gICAgXCJtaW5BbW91bnRcIjoge1xuICAgICAgXCIkcmVmXCI6IFwibGF4QW1vdW50XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIG1pbmltdW0gYW1vdW50IHRvIGJlIGRlbGl2ZXJlZC4gKFRoaXMgZmllbGQgY2Fubm90IGJlIHVzZWQgd2l0aCBkZXN0aW5hdGlvbi5hbW91bnQpXCJcbiAgICB9LFxuICAgIFwidGFnXCI6IHtcIiRyZWZcIjogXCJ0YWdcIn1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhZGRyZXNzXCIsIFwibWluQW1vdW50XCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwib3JkZXJib29rXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYmFzZVwiOiB7XCIkcmVmXCI6IFwiaXNzdWVcIn0sXG4gICAgXCJjb3VudGVyXCI6IHtcIiRyZWZcIjogXCJpc3N1ZVwifVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImJhc2VcIiwgXCJjb3VudGVyXCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwicHJpdmF0ZUtleVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgc2VjcDI1NmsxIG9yIEVkMjU1MTkgcHJpdmF0ZSBrZXkuXCIsXG4gIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICBcInBhdHRlcm5cIjogXCJeW0EtRjAtOV0rJFwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwicHVibGljS2V5XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgaGV4YWRlY2ltYWwgcmVwcmVzZW50YXRpb24gb2YgYSBzZWNwMjU2azEgb3IgRWQyNTUxOSBwdWJsaWMga2V5LlwiLFxuICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgXCJwYXR0ZXJuXCI6IFwiXltBLUYwLTldKyRcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInF1YWxpdHlcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlJhdGlvIGZvciBpbmNvbWluZy9vdXRnb2luZyB0cmFuc2l0IGZlZXMuXCIsXG4gIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICBcIm1pbmltdW1cIjogMC4wMDAwMDAwMDEsXG4gIFwibWF4aW11bVwiOiA0LjI5NDk2NzI5NVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInNlcXVlbmNlXCIsXG4gIFwibGlua1wiOiBcImFjY291bnQtc2VxdWVuY2UtbnVtYmVyXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBbiBhY2NvdW50IHRyYW5zYWN0aW9uIHNlcXVlbmNlIG51bWJlclwiLFxuICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gIFwibWluaW11bVwiOiAwXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwic2V0dGluZ3NQbHVzTWVtb3NcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJkZWZhdWx0UmlwcGxlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJFbmFibGUgW3JpcHBsaW5nXShodHRwczovL3hycGwub3JnL3JpcHBsaW5nLmh0bWwpIG9uIHRoaXMgYWNjb3VudOKAmXMgdHJ1c3QgbGluZXMgYnkgZGVmYXVsdC4gQ3VycmVuY3kgaXNzdWVycyBzaG91bGQgZW5hYmxlIHRoaXMgc2V0dGluZzsgbW9zdCBvdGhlcnMgc2hvdWxkIG5vdC5cIlxuICAgIH0sXG4gICAgXCJkZXBvc2l0QXV0aFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiRW5hYmxlIFtEZXBvc2l0IEF1dGhvcml6YXRpb25dKGh0dHBzOi8veHJwbC5vcmcvZGVwb3NpdGF1dGguaHRtbCkgb24gdGhpcyBhY2NvdW50LiBJZiBzZXQsIHRyYW5zYWN0aW9ucyBjYW5ub3Qgc2VuZCB2YWx1ZSBvZiBhbnkga2luZCB0byB0aGlzIGFjY291bnQgdW5sZXNzIHRoZSBzZW5kZXIgb2YgdGhvc2UgdHJhbnNhY3Rpb25zIGlzIHRoZSBhY2NvdW50IGl0c2VsZi4gKFJlcXVpcmVzIHRoZSBbRGVwb3NpdEF1dGggYW1lbmRtZW50XShodHRwczovL3hycGwub3JnL2tub3duLWFtZW5kbWVudHMuaHRtbCNkZXBvc2l0YXV0aCkpXCJcbiAgICB9LFxuICAgIFwiZGlzYWJsZU1hc3RlcktleVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGlzYWxsb3dzIHVzZSBvZiB0aGUgbWFzdGVyIGtleSB0byBzaWduIHRyYW5zYWN0aW9ucyBmb3IgdGhpcyBhY2NvdW50LiBUbyBkaXNhYmxlIHRoZSBtYXN0ZXIga2V5LCB5b3UgbXVzdCBhdXRob3JpemUgdGhlIHRyYW5zYWN0aW9uIGJ5IHNpZ25pbmcgaXQgd2l0aCB0aGUgbWFzdGVyIGtleSBwYWlyLiBZb3UgY2Fubm90IHVzZSBhIHJlZ3VsYXIga2V5IHBhaXIgb3IgYSBtdWx0aS1zaWduYXR1cmUuIFlvdSBjYW4gcmUtZW5hYmxlIHRoZSBtYXN0ZXIga2V5IHBhaXIgdXNpbmcgYSByZWd1bGFyIGtleSBwYWlyIG9yIG11bHRpLXNpZ25hdHVyZS4gU2VlIFtBY2NvdW50U2V0XShodHRwczovL3hycGwub3JnL2FjY291bnRzZXQuaHRtbCkuXCJcbiAgICB9LFxuICAgIFwiZGlzYWxsb3dJbmNvbWluZ1hSUFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSW5kaWNhdGVzIHRoYXQgY2xpZW50IGFwcGxpY2F0aW9ucyBzaG91bGQgbm90IHNlbmQgWFJQIHRvIHRoaXMgYWNjb3VudC4gTm90IGVuZm9yY2VkIGJ5IHJpcHBsZWQuXCJcbiAgICB9LFxuICAgIFwiZG9tYWluXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBkb21haW4gdGhhdCBvd25zIHRoaXMgYWNjb3VudCwgYXMgYSBoZXhhZGVjaW1hbCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBBU0NJSSBmb3IgdGhlIGRvbWFpbiBpbiBsb3dlcmNhc2UuXCJcbiAgICB9LFxuICAgIFwiZW1haWxIYXNoXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJIYXNoIG9mIGFuIGVtYWlsIGFkZHJlc3MgdG8gYmUgdXNlZCBmb3IgZ2VuZXJhdGluZyBhbiBhdmF0YXIgaW1hZ2UuIENvbnZlbnRpb25hbGx5LCBjbGllbnRzIHVzZSBHcmF2YXRhciB0byBkaXNwbGF5IHRoaXMgaW1hZ2UuIFVzZSBgbnVsbGAgdG8gY2xlYXIuXCIsXG4gICAgICBcIm9uZU9mXCI6IFtcbiAgICAgICAge1widHlwZVwiOiBcIm51bGxcIn0sXG4gICAgICAgIHtcIiRyZWZcIjogXCJoYXNoMTI4XCJ9XG4gICAgICBdXG4gICAgfSxcbiAgICBcIndhbGxldExvY2F0b3JcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRyYW5zYWN0aW9uIGhhc2ggb3IgYW55IG90aGVyIDY0IGNoYXJhY3RlciBoZXhhZGVjaW1hbCBzdHJpbmcsIHRoYXQgbWF5IG9yIG1heSBub3QgcmVwcmVzZW50IHRoZSByZXN1bHQgb2YgYSBoYXNoIG9wZXJhdGlvbi4gVXNlIGBudWxsYCB0byBjbGVhci5cIixcbiAgICAgIFwib25lT2ZcIjogW1xuICAgICAgICB7XCJ0eXBlXCI6IFwibnVsbFwifSxcbiAgICAgICAge1wiJHJlZlwiOiBcImhhc2gyNTZcIn1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZW5hYmxlVHJhbnNhY3Rpb25JRFRyYWNraW5nXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUcmFjayB0aGUgSUQgb2YgdGhpcyBhY2NvdW504oCZcyBtb3N0IHJlY2VudCB0cmFuc2FjdGlvbi5cIlxuICAgIH0sXG4gICAgXCJnbG9iYWxGcmVlemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkZyZWV6ZSBhbGwgYXNzZXRzIGlzc3VlZCBieSB0aGlzIGFjY291bnQuXCJcbiAgICB9LFxuICAgIFwibWVtb3NcIjoge1wiJHJlZlwiOiBcIm1lbW9zXCJ9LFxuICAgIFwibWVzc2FnZUtleVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJQdWJsaWMga2V5IGZvciBzZW5kaW5nIGVuY3J5cHRlZCBtZXNzYWdlcyB0byB0aGlzIGFjY291bnQuIENvbnZlbnRpb25hbGx5LCBpdCBzaG91bGQgYmUgYSBzZWNwMjU2azEga2V5LCB0aGUgc2FtZSBlbmNyeXB0aW9uIHRoYXQgaXMgdXNlZCBieSB0aGUgcmVzdCBvZiBSaXBwbGUuXCJcbiAgICB9LFxuICAgIFwibm9GcmVlemVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlBlcm1hbmVudGx5IGdpdmUgdXAgdGhlIGFiaWxpdHkgdG8gZnJlZXplIGluZGl2aWR1YWwgdHJ1c3QgbGluZXMuIFRoaXMgZmxhZyBjYW4gbmV2ZXIgYmUgZGlzYWJsZWQgYWZ0ZXIgYmVpbmcgZW5hYmxlZC5cIlxuICAgIH0sXG4gICAgXCJwYXNzd29yZFNwZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJbmRpY2F0ZXMgdGhhdCB0aGUgYWNjb3VudCBoYXMgdXNlZCBpdHMgZnJlZSBTZXRSZWd1bGFyS2V5IHRyYW5zYWN0aW9uLlwiXG4gICAgfSxcbiAgICBcInJlZ3VsYXJLZXlcIjoge1xuICAgICAgXCJvbmVPZlwiOiBbXG4gICAgICAgIHtcIiRyZWZcIjogXCJhZGRyZXNzXCJ9LFxuICAgICAgICB7XCJ0eXBlXCI6IFwibnVsbFwifVxuICAgICAgXSxcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgcHVibGljIGtleSBvZiBhIG5ldyBrZXlwYWlyLCB0byB1c2UgYXMgdGhlIHJlZ3VsYXIga2V5IHRvIHRoaXMgYWNjb3VudCwgYXMgYSBiYXNlLTU4LWVuY29kZWQgc3RyaW5nIGluIHRoZSBzYW1lIGZvcm1hdCBhcyBhbiBhY2NvdW50IGFkZHJlc3MuIFVzZSBgbnVsbGAgdG8gcmVtb3ZlIHRoZSByZWd1bGFyIGtleS5cIlxuICAgIH0sXG4gICAgXCJyZXF1aXJlQXV0aG9yaXphdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgc2V0LCB0aGlzIGFjY291bnQgbXVzdCBpbmRpdmlkdWFsbHkgZ2l2ZSBvdGhlciB1c2VycyBwZXJtaXNzaW9uIHRvIGhvbGQgdGhpcyBhY2NvdW504oCZcyBpc3N1ZWQgdG9rZW5zLlwiXG4gICAgfSxcbiAgICBcInJlcXVpcmVEZXN0aW5hdGlvblRhZ1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUmVxdWlyZXMgaW5jb21pbmcgcGF5bWVudHMgdG8gc3BlY2lmeSBhIGRlc3RpbmF0aW9uIHRhZy5cIlxuICAgIH0sXG4gICAgXCJzaWduZXJzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlNldHRpbmdzIHRoYXQgZGV0ZXJtaW5lIHdoYXQgc2V0cyBvZiBhY2NvdW50cyBjYW4gYmUgdXNlZCB0byBzaWduIGEgdHJhbnNhY3Rpb24gb24gYmVoYWxmIG9mIHRoaXMgYWNjb3VudCB1c2luZyBtdWx0aXNpZ25pbmcuXCIsXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcInRocmVzaG9sZFwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwidWludDMyXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgdGFyZ2V0IG51bWJlciBmb3IgdGhlIHNpZ25lciB3ZWlnaHRzLiBBIG11bHRpLXNpZ25hdHVyZSBmcm9tIHRoaXMgbGlzdCBpcyB2YWxpZCBvbmx5IGlmIHRoZSBzdW0gd2VpZ2h0cyBvZiB0aGUgc2lnbmF0dXJlcyBwcm92aWRlZCBpcyBlcXVhbCBvciBncmVhdGVyIHRoYW4gdGhpcyB2YWx1ZS4gVG8gZGVsZXRlIHRoZSBzaWduZXJzIHNldHRpbmcsIHVzZSB0aGUgdmFsdWUgYDBgLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwid2VpZ2h0c1wiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiV2VpZ2h0cyBvZiBzaWduYXR1cmVzIGZvciBlYWNoIHNpZ25lci5cIixcbiAgICAgICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFuIGFzc29jaWF0aW9uIG9mIGFuIGFkZHJlc3MgYW5kIGEgd2VpZ2h0LlwiLFxuICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgXCJhZGRyZXNzXCI6IHtcIiRyZWZcIjogXCJhZGRyZXNzXCJ9LFxuICAgICAgICAgICAgICBcIndlaWdodFwiOiB7XG4gICAgICAgICAgICAgICAgXCIkcmVmXCI6IFwidWludDMyXCIsXG4gICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB3ZWlnaHQgdGhhdCB0aGUgc2lnbmF0dXJlIG9mIHRoaXMgYWNjb3VudCBjb3VudHMgYXMgdG93YXJkcyB0aGUgdGhyZXNob2xkLlwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJlcXVpcmVkXCI6IFtcImFkZHJlc3NcIiwgXCJ3ZWlnaHRcIl0sXG4gICAgICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgXCJtYXhJdGVtc1wiOiA4XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IFtcInRocmVzaG9sZFwiXSxcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2VcbiAgICB9LFxuICAgIFwidHJhbnNmZXJSYXRlXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgZmVlIHRvIGNoYXJnZSB3aGVuIHVzZXJzIHRyYW5zZmVyIHRoaXMgYWNjb3VudOKAmXMgaXNzdWFuY2VzLCBhcyB0aGUgZGVjaW1hbCBhbW91bnQgdGhhdCBtdXN0IGJlIHNlbnQgdG8gZGVsaXZlciAxIHVuaXQuIEhhcyBwcmVjaXNpb24gdXAgdG8gOSBkaWdpdHMgYmV5b25kIHRoZSBkZWNpbWFsIHBvaW50LiBVc2UgYG51bGxgIHRvIHNldCBubyBmZWUuXCIsXG4gICAgICBcIm9uZU9mXCI6IFtcbiAgICAgICAge1widHlwZVwiOiBcIm51bGxcIn0sXG4gICAgICAgIHtcInR5cGVcIjogXCJudW1iZXJcIiwgXCJtaW5pbXVtXCI6IDEsIFwibWF4aW11bVwiOiA0LjI5NDk2NzI5NX1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwidGlja1NpemVcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRpY2sgc2l6ZSB0byB1c2UgZm9yIG9mZmVycyBpbnZvbHZpbmcgYSBjdXJyZW5jeSBpc3N1ZWQgYnkgdGhpcyBhZGRyZXNzLiBUaGUgZXhjaGFuZ2UgcmF0ZXMgb2YgdGhvc2Ugb2ZmZXJzIGlzIHJvdW5kZWQgdG8gdGhpcyBtYW55IHNpZ25pZmljYW50IGRpZ2l0cy4gVmFsaWQgdmFsdWVzIGFyZSAzIHRvIDE1IGluY2x1c2l2ZSwgb3IgMCB0byBkaXNhYmxlLlwiLFxuICAgICAgXCJlbnVtXCI6IFswLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1XVxuICAgIH1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInNpZ25hdHVyZVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGEgc2lnbmF0dXJlLlwiLFxuICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgXCJwYXR0ZXJuXCI6IFwiXltBLUYwLTldKyRcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInNpZ25lZFZhbHVlXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGZsb2F0aW5nIHBvaW50IG51bWJlclwiLFxuICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgXCJsaW5rXCI6IFwidmFsdWVcIixcbiAgXCJwYXR0ZXJuXCI6IFwiXlstXT9bMC05XSpbLl0/WzAtOV0rKFtlRV1bLStdP1swLTldKyk/JFwiXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwic291cmNlQWRqdXN0bWVudFwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJvbmVPZlwiOiBbXG4gICAge1wiJHJlZlwiOiBcInNvdXJjZUV4YWN0QWRqdXN0bWVudFwifSxcbiAgICB7XCIkcmVmXCI6IFwibWF4QWRqdXN0bWVudFwifVxuICBdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwic291cmNlRXhhY3RBZGp1c3RtZW50XCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWRkcmVzc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3MgdG8gc2VuZCBmcm9tLlwiXG4gICAgfSxcbiAgICBcImFtb3VudFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJsYXhBbW91bnRcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbiBleGFjdCBhbW91bnQgdG8gc2VuZC4gSWYgdGhlIGNvdW50ZXJwYXJ0eSBpcyBub3Qgc3BlY2lmaWVkLCBhbW91bnRzIHdpdGggYW55IGNvdW50ZXJwYXJ0eSBtYXkgYmUgdXNlZC4gKFRoaXMgZmllbGQgY2Fubm90IGJlIHVzZWQgd2l0aCBzb3VyY2UubWF4QW1vdW50KVwiXG4gICAgfSxcbiAgICBcInRhZ1wiOiB7XCIkcmVmXCI6IFwidGFnXCJ9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogW1wiYWRkcmVzc1wiLCBcImFtb3VudFwiXSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInRhZ1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQW4gYXJiaXRyYXJ5IDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyLiBJdCB0eXBpY2FsbHkgbWFwcyB0byBhbiBvZmYtbGVkZ2VyIGFjY291bnQ7IGZvciBleGFtcGxlLCBhIGhvc3RlZCB3YWxsZXQgb3IgZXhjaGFuZ2UgYWNjb3VudC5cIixcbiAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICBcIiRyZWZcIjogXCJ1aW50MzJcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInRpY2tldC1zZXF1ZW5jZVwiLFxuICBcImxpbmtcIjogXCJhY2NvdW50LXNlcXVlbmNlLW51bWJlclwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQW4gYWNjb3VudCB0cmFuc2FjdGlvbiB0aWNrdCBzZXF1ZW5jZSBudW1iZXJcIixcbiAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICBcIm1pbmltdW1cIjogMVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInRyYW5zYWN0aW9uSGFzaFwiLFxuICBcImxpbmtcIjogXCJ0cmFuc2FjdGlvbi1pZFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBoYXNoIG9mIGEgdHJhbnNhY3Rpb24gdXNlZCB0byBpZGVudGlmeSB0aGUgdHJhbnNhY3Rpb24sIHJlcHJlc2VudGVkIGluIGhleGFkZWNpbWFsLlwiLFxuICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgXCJwYXR0ZXJuXCI6IFwiXltBLUYwLTldezY0fSRcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInRyYW5zYWN0aW9uVHlwZVwiLFxuICBcImxpbmtcIjogXCJ0cmFuc2FjdGlvbi10eXBlc1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHR5cGUgb2YgdGhlIHRyYW5zYWN0aW9uLlwiLFxuICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgXCJlbnVtXCI6IFtcbiAgICBcInBheW1lbnRcIixcbiAgICBcIm9yZGVyXCIsXG4gICAgXCJvcmRlckNhbmNlbGxhdGlvblwiLFxuICAgIFwidHJ1c3RsaW5lXCIsXG4gICAgXCJzZXR0aW5nc1wiLFxuICAgIFwiZXNjcm93Q3JlYXRpb25cIixcbiAgICBcImVzY3Jvd0NhbmNlbGxhdGlvblwiLFxuICAgIFwiZXNjcm93RXhlY3V0aW9uXCIsXG4gICAgXCJwYXltZW50Q2hhbm5lbENyZWF0ZVwiLFxuICAgIFwicGF5bWVudENoYW5uZWxGdW5kXCIsXG4gICAgXCJwYXltZW50Q2hhbm5lbENsYWltXCIsXG4gICAgXCJjaGVja0NyZWF0ZVwiLFxuICAgIFwiY2hlY2tDYW5jZWxcIixcbiAgICBcImNoZWNrQ2FzaFwiLFxuICAgIFwiZGVwb3NpdFByZWF1dGhcIixcbiAgICBcImFjY291bnREZWxldGVcIlxuICBdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwidHgtanNvblwiLFxuICBcImxpbmtcIjogXCJodHRwczovL3hycGwub3JnL3RyYW5zYWN0aW9uLWZvcm1hdHMuaHRtbFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQW4gb2JqZWN0IGluIHJpcHBsZWQgdHhKU09OIGZvcm1hdFwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIkFjY291bnRcIjoge1wiJHJlZlwiOiBcImFkZHJlc3NcIn0sXG4gICAgXCJUcmFuc2FjdGlvblR5cGVcIjoge1widHlwZVwiOiBcInN0cmluZ1wifVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcIkFjY291bnRcIiwgXCJUcmFuc2FjdGlvblR5cGVcIl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJ1aW50MzJcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgMzItYml0IHVuc2lnbmVkIGludGVnZXJcIixcbiAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICBcIm1pbmltdW1cIjogMCxcbiAgXCJtYXhpbXVtXCI6IDQyOTQ5NjcyOTVcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJ2YWx1ZVwiLFxuICBcImxpbmtcIjogXCJ2YWx1ZVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBub24tbmVnYXRpdmUgZmxvYXRpbmcgcG9pbnQgbnVtYmVyXCIsXG4gIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICBcInBhdHRlcm5cIjogXCJeWzAtOV0qWy5dP1swLTldKyhbZUVdWy0rXT9bMC05XSspPyRcIlxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInhBZGRyZXNzXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBbiBYUlAgTGVkZ2VyIGFkZHJlc3MgaW4gWC1hZGRyZXNzIGZvcm1hdFwiLFxuICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgXCJmb3JtYXRcIjogXCJ4QWRkcmVzc1wiLFxuICBcImxpbmtcIjogXCJ4LWFkZHJlc3NcIixcbiAgXCJwYXR0ZXJuXCI6IFwiXltYVF1bMS05QS1ISi1OUC1aYS1rbS16XXs0Nn0kXCJcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRBY2NvdW50SW5mb1wiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInNlcXVlbmNlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInNlcXVlbmNlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIG5leHQgKHNtYWxsZXN0IHVudXNlZCkgc2VxdWVuY2UgbnVtYmVyIGZvciB0aGlzIGFjY291bnQuXCJcbiAgICB9LFxuICAgIFwieHJwQmFsYW5jZVwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJ2YWx1ZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBYUlAgYmFsYW5jZSBvd25lZCBieSB0aGUgYWNjb3VudC5cIlxuICAgIH0sXG4gICAgXCJvd25lckNvdW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk51bWJlciBvZiBvdGhlciBsZWRnZXIgZW50cmllcyAoc3BlY2lmaWNhbGx5LCB0cnVzdCBsaW5lcyBhbmQgb2ZmZXJzKSBhdHRyaWJ1dGVkIHRvIHRoaXMgYWNjb3VudC4gVGhpcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgdG90YWwgcmVzZXJ2ZSByZXF1aXJlZCB0byB1c2UgdGhlIGFjY291bnQuXCJcbiAgICB9LFxuICAgIFwicHJldmlvdXNJbml0aWF0ZWRUcmFuc2FjdGlvbklEXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImhhc2gyNTZcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJIYXNoIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgbW9zdCByZWNlbnQgdHJhbnNhY3Rpb24gdGhhdCB3YXMgaW5pdGlhdGVkIGJ5IHRoaXMgYWNjb3VudC5cIlxuICAgIH0sXG4gICAgXCJwcmV2aW91c0FmZmVjdGluZ1RyYW5zYWN0aW9uSURcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiaGFzaDI1NlwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkhhc2ggdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBtb3N0IHJlY2VudCB0cmFuc2FjdGlvbiB0aGF0IGFmZmVjdGVkIHRoaXMgYWNjb3VudCBub2RlIGRpcmVjdGx5LiAqKk5vdGU6KiogVGhpcyBkb2VzIG5vdCBpbmNsdWRlIGNoYW5nZXMgdG8gdGhlIGFjY291bnTigJlzIHRydXN0IGxpbmVzIGFuZCBvZmZlcnMuXCJcbiAgICB9LFxuICAgIFwicHJldmlvdXNBZmZlY3RpbmdUcmFuc2FjdGlvbkxlZGdlclZlcnNpb25cIjoge1xuICAgICAgXCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBsZWRnZXIgdmVyc2lvbiB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpZGVudGlmaWVkIGJ5IHRoZSBgcHJldmlvdXNBZmZlY3RpbmdUcmFuc2FjdGlvbklEYCB3YXMgdmFsaWRhdGVkIGluLlwiXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcbiAgICBcInNlcXVlbmNlXCIsXG4gICAgXCJ4cnBCYWxhbmNlXCIsXG4gICAgXCJvd25lckNvdW50XCIsXG4gICAgXCJwcmV2aW91c0FmZmVjdGluZ1RyYW5zYWN0aW9uSURcIixcbiAgICBcInByZXZpb3VzQWZmZWN0aW5nVHJhbnNhY3Rpb25MZWRnZXJWZXJzaW9uXCJcbiAgXSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcIkFjY291bnRPYmplY3RzUmVzcG9uc2VcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlJlc3BvbnNlIGZvcm1hdCBmb3IgYWNjb3VudF9vYmplY3RzXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWNjb3VudFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgIFwiVW5pcXVlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhpcyByZXF1ZXN0IGNvcnJlc3BvbmRzIHRvLlwiXG4gICAgfSxcbiAgICBcImFjY291bnRfb2JqZWN0c1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiXG4gICAgICB9LFxuICAgICAgXCJkZXNjcmlwdGlvblwiOlxuICAgICAgICBcIkFycmF5IG9mIG9iamVjdHMgb3duZWQgYnkgdGhpcyBhY2NvdW50LiBFYWNoIG9iamVjdCBpcyBpbiBpdHMgcmF3IGxlZGdlciBmb3JtYXQuXCJcbiAgICB9LFxuICAgIFwibGVkZ2VyX2hhc2hcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgIFwiKE1heSBiZSBvbWl0dGVkKSBUaGUgaWRlbnRpZnlpbmcgaGFzaCBvZiB0aGUgbGVkZ2VyIHRoYXQgd2FzIHVzZWQgdG8gZ2VuZXJhdGUgdGhpcyByZXNwb25zZS5cIlxuICAgIH0sXG4gICAgXCJsZWRnZXJfaW5kZXhcIjoge1xuICAgICAgXCIkcmVmXCI6IFwibGVkZ2VyVmVyc2lvblwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOlxuICAgICAgICBcIihNYXkgYmUgb21pdHRlZCkgVGhlIHNlcXVlbmNlIG51bWJlciBvZiB0aGUgbGVkZ2VyIHRoYXQgd2FzIHVzZWQgdG8gZ2VuZXJhdGUgdGhpcyByZXNwb25zZS5cIlxuICAgIH0sXG4gICAgXCJsZWRnZXJfY3VycmVudF9pbmRleFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJsZWRnZXJWZXJzaW9uXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgIFwiKE1heSBiZSBvbWl0dGVkKSBUaGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBsZWRnZXIgdGhhdCB3YXMgdXNlZCB0byBnZW5lcmF0ZSB0aGlzIHJlc3BvbnNlLlwiXG4gICAgfSxcbiAgICBcImxpbWl0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjpcbiAgICAgICAgXCIoTWF5IGJlIG9taXR0ZWQpIFRoZSBsaW1pdCB0aGF0IHdhcyB1c2VkIGluIHRoaXMgcmVxdWVzdCwgaWYgYW55LlwiXG4gICAgfSxcbiAgICBcInZhbGlkYXRlZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6XG4gICAgICAgIFwiSWYgaW5jbHVkZWQgYW5kIHNldCB0byB0cnVlLCB0aGUgaW5mb3JtYXRpb24gaW4gdGhpcyByZXF1ZXN0IGNvbWVzIGZyb20gYSB2YWxpZGF0ZWQgbGVkZ2VyIHZlcnNpb24uIE90aGVyd2lzZSwgdGhlIGluZm9ybWF0aW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlwiXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImFjY291bnRcIiwgXCJhY2NvdW50X29iamVjdHNcIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRCYWxhbmNlU2hlZXRcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcImdldEJhbGFuY2VTaGVldCByZXNwb25zZVwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImJhbGFuY2VzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCJhbW91bnRcIn0sXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW1vdW50cyBpc3N1ZWQgdG8gdGhlIFxcXCJob3R3YWxsZXRcXFwiIGFjY291bnRzIGZyb20gdGhlIHJlcXVlc3QuIFRoZSBrZXlzIGFyZSB0aGUgYWNjb3VudHMnIGFkZHJlc3NlcywgYW5kIHRoZSB2YWx1ZXMgYXJlIGFycmF5cyBvZiBjdXJyZW5jeSBhbW91bnRzIHRoZXkgaG9sZC4gVGhlIGlzc3VlciAob21pdHRlZCBmcm9tIHRoZSBjdXJyZW5jeSBhbW91bnRzKSBpcyB0aGUgYWNjb3VudCBmcm9tIHRoZSByZXF1ZXN0LlwiXG4gICAgfSxcbiAgICBcImFzc2V0c1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwiYW1vdW50XCJ9LFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRvdGFsIGFtb3VudHMgaGVsZCB0aGF0IGFyZSBpc3N1ZWQgYnkgb3RoZXJzLiBGb3IgdGhlIHJlY29tbWVuZGVkIGdhdGV3YXkgY29uZmlndXJhdGlvbiwgdGhlcmUgc2hvdWxkIGJlIG5vbmUuXCJcbiAgICB9LFxuICAgIFwib2JsaWdhdGlvbnNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXCJjdXJyZW5jeVwiLCBcInZhbHVlXCJdLFxuICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgIFwiY3VycmVuY3lcIjoge1wiJHJlZlwiOiBcImN1cnJlbmN5XCJ9LFxuICAgICAgICAgIFwidmFsdWVcIjoge1wiJHJlZlwiOiBcInZhbHVlXCJ9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbiBhbW91bnQgdGhhdCBpcyBvd2VkLlwiXG4gICAgICB9LFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRvdGFsIGFtb3VudHMgaXNzdWVkIHRvIGFjY291bnRzIHRoYXQgYXJlIG5vdCBob3Qgd2FsbGV0cywgYXMgYSBtYXAgb2YgY3VycmVuY2llcyB0byB0aGUgdG90YWwgdmFsdWUgaXNzdWVkLlwiXG4gICAgfVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiZ2V0QmFsYW5jZXNcIixcbiAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwiYmFsYW5jZVwifVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImdldExlZGdlclwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInN0YXRlSGFzaFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJoYXNoMjU2XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSGFzaCBvZiBhbGwgc3RhdGUgaW5mb3JtYXRpb24gaW4gdGhpcyBsZWRnZXIuXCJcbiAgICB9LFxuICAgIFwiY2xvc2VUaW1lXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJkYXRlLXRpbWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYXBwcm94aW1hdGUgdGltZSB3aGVuIHRoaXMgbGVkZ2VyIHdhcyBjbG9zZWQuIFRoaXMgbnVtYmVyIGlzIHJvdW5kZWQgYmFzZWQgb24gdGhlIGBjbG9zZVRpbWVSZXNvbHV0aW9uYC4gSWYgaXQgd291bGQgaGF2ZSBiZWVuIHJvdW5kZWQgdG8gdGhlIHNhbWUgdGltZSBhcyBhIHByZXZpb3VzIGxlZGdlciwgdGhlIGNsb3NlIHRpbWUgaXMgcmVjb3JkZWQgYXMgMSBzZWNvbmQgbGF0ZXIgaW5zdGVhZC5cIlxuICAgIH0sXG4gICAgXCJjbG9zZVRpbWVSZXNvbHV0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAxLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgbnVtYmVyIG9mIHNlY29uZHMsIGluZGljYXRpbmcgaG93IG11Y2ggdGhlIGBjbG9zZVRpbWVgIGNvdWxkIGJlIHJvdW5kZWQuIExlZGdlciBjbG9zZSB0aW1lcyBhcmUgYXBwcm94aW1hdGUgc28gdGhhdCBzbWFsbCBkaWZmZXJlbmNlcyBpbiBzZXJ2ZXJzIGNsb2NrcyBkb24ndCBoaW5kZXIgY29uc2Vuc3VzLlwiXG4gICAgfSxcbiAgICBcImNsb3NlRmxhZ3NcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBiaXQtbWFwIG9mIGZsYWdzIHJlbGF0aW5nIHRvIHRoZSBjbG9zaW5nIG9mIHRoaXMgbGVkZ2VyLiBDdXJyZW50bHksIHRoZSBsZWRnZXIgaGFzIG9ubHkgb25lIGZsYWcgZGVmaW5lZCBmb3IgYGNsb3NlRmxhZ3NgOiAqKnNMQ0ZfTm9Db25zZW5zdXNUaW1lKiogKHZhbHVlIDEpLiBJZiB0aGlzIGZsYWcgaXMgZW5hYmxlZCwgaXQgbWVhbnMgdGhhdCB2YWxpZGF0b3JzIGRpc2FncmVlZCBvbiB0aGUgY29ycmVjdCBjbG9zZSB0aW1lIGZvciB0aGUgbGVkZ2VyLCBidXQgYnVpbHQgb3RoZXJ3aXNlIHRoZSBzYW1lIGxlZGdlciwgc28gdGhleSBkZWNsYXJlZCBjb25zZW5zdXMgd2hpbGUgXFxcImFncmVlaW5nIHRvIGRpc2FncmVlXFxcIiBvbiB0aGUgY2xvc2UgdGltZS4gSW4gdGhpcyBjYXNlLCB0aGUgY29uc2Vuc3VzIGxlZGdlciBjb250YWlucyBhIGBjbG9zZVRpbWVgIHZhbHVlIHRoYXQgaXMgMSBzZWNvbmQgYWZ0ZXIgdGhhdCBvZiB0aGUgcHJldmlvdXMgbGVkZ2VyLiAoSW4gdGhpcyBjYXNlLCB0aGVyZSBpcyBubyBvZmZpY2lhbCBjbG9zZSB0aW1lLCBidXQgdGhlIGFjdHVhbCByZWFsLXdvcmxkIGNsb3NlIHRpbWUgaXMgcHJvYmFibHkgMy02IHNlY29uZHMgbGF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkIGBjbG9zZVRpbWVgLilcIlxuICAgIH0sXG4gICAgXCJsZWRnZXJIYXNoXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImhhc2gyNTZcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJVbmlxdWUgaWRlbnRpZnlpbmcgaGFzaCBvZiB0aGUgZW50aXJlIGxlZGdlci5cIlxuICAgIH0sXG4gICAgXCJsZWRnZXJWZXJzaW9uXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImxlZGdlclZlcnNpb25cIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgbGVkZ2VyIHZlcnNpb24gb2YgdGhpcyBsZWRnZXIuXCJcbiAgICB9LFxuICAgIFwicGFyZW50TGVkZ2VySGFzaFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJoYXNoMjU2XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVW5pcXVlIGlkZW50aWZ5aW5nIGhhc2ggb2YgdGhlIGxlZGdlciB0aGF0IGNhbWUgaW1tZWRpYXRlbHkgYmVmb3JlIHRoaXMgb25lLlwiXG4gICAgfSxcbiAgICBcInBhcmVudENsb3NlVGltZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHByZXZpb3VzIGxlZGdlcidzIHJlY29yZGVkIGNsb3NlIHRpbWUuXCJcbiAgICB9LFxuICAgIFwidG90YWxEcm9wc1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJ2YWx1ZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRvdGFsIG51bWJlciBvZiBkcm9wcyAoMS8xLDAwMCwwMDB0aCBvZiBhbiBYUlApIGluIHRoZSBuZXR3b3JrLCBhcyBhIHF1b3RlZCBpbnRlZ2VyLiAoVGhpcyBkZWNyZWFzZXMgYXMgdHJhbnNhY3Rpb24gZmVlcyBjYXVzZSBYUlAgdG8gYmUgZGVzdHJveWVkLilcIlxuICAgIH0sXG4gICAgXCJ0cmFuc2FjdGlvbkhhc2hcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiaGFzaDI1NlwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGluZm9ybWF0aW9uIGluY2x1ZGVkIGluIHRoaXMgbGVkZ2VyLlwiXG4gICAgfSxcbiAgICBcInRyYW5zYWN0aW9uc1wiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQXJyYXkgb2YgYWxsIHRyYW5zYWN0aW9ucyB0aGF0IHdlcmUgdmFsaWRhdGVkIGluIHRoaXMgbGVkZ2VyLiBUcmFuc2FjdGlvbnMgYXJlIHJlcHJlc2VudGVkIGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgcmV0dXJuIHZhbHVlIG9mIFtnZXRUcmFuc2FjdGlvbl0oI2dldHRyYW5zYWN0aW9uKS5cIixcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgXCIkcmVmXCI6IFwiZ2V0VHJhbnNhY3Rpb25cIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgdHJhbnNhY3Rpb24gaW4gdGhlIHNhbWUgZm9ybWF0IGFzIHRoZSByZXR1cm4gdmFsdWUgb2YgW2dldFRyYW5zYWN0aW9uXSgjZ2V0dHJhbnNhY3Rpb24pLlwiXG4gICAgICB9XG4gICAgfSxcbiAgICBcInRyYW5zYWN0aW9uSGFzaGVzXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbiBhcnJheSBvZiBoYXNoZXMgb2YgYWxsIHRyYW5zYWN0aW9ucyB0aGF0IHdlcmUgdmFsaWRhdGVkIGluIHRoaXMgbGVkZ2VyLlwiLFxuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjoge1xuICAgICAgICBcIiRyZWZcIjogXCJ0cmFuc2FjdGlvbkhhc2hcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJyYXdTdGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgYWxsIHN0YXRlIGRhdGEgZm9yIHRoaXMgbGVkZ2VyIGluIHJpcHBsZWQgSlNPTiBmb3JtYXQuXCJcbiAgICB9LFxuICAgIFwic3RhdGVIYXNoZXNcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFuIGFycmF5IG9mIGhhc2hlcyBvZiBhbGwgc3RhdGUgZGF0YSBpbiB0aGlzIGxlZGdlci5cIixcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIml0ZW1zXCI6IHtcbiAgICAgICAgXCIkcmVmXCI6IFwiaGFzaDI1NlwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcbiAgICBcInN0YXRlSGFzaFwiLFxuICAgIFwiY2xvc2VUaW1lXCIsXG4gICAgXCJjbG9zZVRpbWVSZXNvbHV0aW9uXCIsXG4gICAgXCJjbG9zZUZsYWdzXCIsXG4gICAgXCJsZWRnZXJIYXNoXCIsXG4gICAgXCJsZWRnZXJWZXJzaW9uXCIsXG4gICAgXCJwYXJlbnRMZWRnZXJIYXNoXCIsXG4gICAgXCJwYXJlbnRDbG9zZVRpbWVcIixcbiAgICBcInRvdGFsRHJvcHNcIixcbiAgICBcInRyYW5zYWN0aW9uSGFzaFwiXG4gIF0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRPcmRlcmJvb2tcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJiaWRzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcIm9yZGVyYm9va09yZGVyc1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBidXkgb3JkZXJzIGluIHRoZSBvcmRlciBib29rLlwiXG4gICAgfSxcbiAgICBcImFza3NcIjoge1xuICAgICAgXCIkcmVmXCI6IFwib3JkZXJib29rT3JkZXJzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHNlbGwgb3JkZXJzIGluIHRoZSBvcmRlciBib29rLlwiXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImJpZHNcIiwgXCJhc2tzXCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiZ2V0T3JkZXJzXCIsXG4gIFwidHlwZVwiOiBcImFycmF5XCIsXG4gIFwiaXRlbXNcIjoge1xuICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICBcInNwZWNpZmljYXRpb25cIjoge1xuICAgICAgICBcIiRyZWZcIjogXCJvcmRlclwiLFxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW4gb3JkZXIgc3BlY2lmaWNhdGlvbiB0aGF0IHdvdWxkIGNyZWF0ZSBhbiBvcmRlciBlcXVpdmFsZW50IHRvIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgb3JkZXIuXCJcbiAgICAgIH0sXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUHJvcGVydGllcyBvZiB0aGUgb3JkZXIgbm90IGluIHRoZSBzcGVjaWZpY2F0aW9uLlwiLFxuICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICBcIm1ha2VyXCI6IHtcbiAgICAgICAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0aGF0IHN1Ym1pdHRlZCB0aGUgb3JkZXIuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VxdWVuY2VcIjoge1xuICAgICAgICAgICAgXCIkcmVmXCI6IFwic2VxdWVuY2VcIixcbiAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYWNjb3VudCBzZXF1ZW5jZSBudW1iZXIgb2YgdGhlIHRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlZCB0aGlzIG9yZGVyLlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1ha2VyRXhjaGFuZ2VSYXRlXCI6IHtcbiAgICAgICAgICAgIFwiJHJlZlwiOiBcInZhbHVlXCIsXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGV4Y2hhbmdlIHJhdGUgZnJvbSB0aGUgcG9pbnQgb2YgdmlldyBvZiB0aGUgYWNjb3VudCB0aGF0IHN1Ym1pdHRlZCB0aGUgb3JkZXIgKGFsc28ga25vd24gYXMgXFxcInF1YWxpdHlcXFwiKS5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXCJtYWtlclwiLCBcInNlcXVlbmNlXCIsIFwibWFrZXJFeGNoYW5nZVJhdGVcIl0sXG4gICAgICAgIFwiYWRkdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJyZXF1aXJlZFwiOiBbXCJzcGVjaWZpY2F0aW9uXCIsIFwicHJvcGVydGllc1wiXSxcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRQYXRoc1wiLFxuICBcInR5cGVcIjogXCJhcnJheVwiLFxuICBcIml0ZW1zXCI6IHtcbiAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgXCJzb3VyY2VcIjoge1xuICAgICAgICBcIiRyZWZcIjogXCJzb3VyY2VBZGp1c3RtZW50XCIsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJQcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2YgdGhlIHBheW1lbnQuXCJcbiAgICAgIH0sXG4gICAgICBcImRlc3RpbmF0aW9uXCI6IHtcbiAgICAgICAgXCIkcmVmXCI6IFwiZGVzdGluYXRpb25BZGp1c3RtZW50XCIsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJQcm9wZXJ0aWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgcGF5bWVudC5cIlxuICAgICAgfSxcbiAgICAgIFwicGF0aHNcIjoge1xuICAgICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBwYXRocyBvZiB0cnVzdGxpbmVzIGFuZCBvcmRlcnMgdG8gdXNlIGluIGV4ZWN1dGluZyB0aGUgcGF5bWVudC5cIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCJyZXF1aXJlZFwiOiBbXCJzb3VyY2VcIiwgXCJkZXN0aW5hdGlvblwiLCBcInBhdGhzXCJdLFxuICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2VcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImdldFBheW1lbnRDaGFubmVsXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYWNjb3VudFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQWRkcmVzcyB0aGF0IGNyZWF0ZWQgdGhlIHBheW1lbnQgY2hhbm5lbC5cIlxuICAgIH0sXG4gICAgXCJkZXN0aW5hdGlvblwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQWRkcmVzcyB0byByZWNlaXZlIFhSUCBjbGFpbXMgYWdhaW5zdCB0aGlzIGNoYW5uZWwuXCJcbiAgICB9LFxuICAgIFwiYW1vdW50XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInZhbHVlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHRvdGFsIGFtb3VudCBvZiBYUlAgZnVuZGVkIGluIHRoaXMgY2hhbm5lbC5cIlxuICAgIH0sXG4gICAgXCJiYWxhbmNlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInZhbHVlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHRvdGFsIGFtb3VudCBvZiBYUlAgZGVsaXZlcmVkIGJ5IHRoaXMgY2hhbm5lbC5cIlxuICAgIH0sXG4gICAgXCJzZXR0bGVEZWxheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbW91bnQgb2Ygc2Vjb25kcyB0aGUgc291cmNlIGFkZHJlc3MgbXVzdCB3YWl0IGJlZm9yZSBjbG9zaW5nIHRoZSBjaGFubmVsIGlmIGl0IGhhcyB1bmNsYWltZWQgWFJQLlwiXG4gICAgfSxcbiAgICBcImV4cGlyYXRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcImRhdGUtdGltZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRpbWUgd2hlbiB0aGlzIGNoYW5uZWwgZXhwaXJlcy5cIlxuICAgIH0sXG4gICAgXCJwdWJsaWNLZXlcIjoge1xuICAgICAgXCIkcmVmXCI6IFwicHVibGljS2V5XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUHVibGljIGtleSBvZiB0aGUga2V5IHBhaXIgdGhlIHNvdXJjZSB1c2VzIHRvIHNpZ24gY2xhaW1zIGFnYWluc3QgdGhpcyBjaGFubmVsLlwiXG4gICAgfSxcbiAgICBcImNhbmNlbEFmdGVyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJkYXRlLXRpbWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaW1lIHdoZW4gdGhpcyBjaGFubmVsIGV4cGlyZXMgYXMgc3BlY2lmaWVkIGF0IGNyZWF0aW9uLlwiXG4gICAgfSxcbiAgICBcInNvdXJjZVRhZ1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJ0YWdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJTb3VyY2UgdGFnLlwiXG4gICAgfSxcbiAgICBcImRlc3RpbmF0aW9uVGFnXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInRhZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkRlc3RpbmF0aW9uIHRhZy5cIlxuICAgIH0sXG4gICAgXCJwcmV2aW91c0FmZmVjdGluZ1RyYW5zYWN0aW9uSURcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiaGFzaDI1NlwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkhhc2ggdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBtb3N0IHJlY2VudCB0cmFuc2FjdGlvbiB0aGF0IGFmZmVjdGVkIHRoaXMgcGF5bWVudCBjaGFubmVsLlwiXG4gICAgfSxcbiAgICBcInByZXZpb3VzQWZmZWN0aW5nVHJhbnNhY3Rpb25MZWRnZXJWZXJzaW9uXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImxlZGdlclZlcnNpb25cIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgbGVkZ2VyIHZlcnNpb24gdGhhdCB0aGUgdHJhbnNhY3Rpb24gaWRlbnRpZmllZCBieSB0aGUgYHByZXZpb3VzQWZmZWN0aW5nVHJhbnNhY3Rpb25JRGAgd2FzIHZhbGlkYXRlZCBpbi5cIlxuICAgIH1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXG4gICAgXCJhY2NvdW50XCIsXG4gICAgXCJkZXN0aW5hdGlvblwiLFxuICAgIFwiYW1vdW50XCIsXG4gICAgXCJiYWxhbmNlXCIsXG4gICAgXCJzZXR0bGVEZWxheVwiLFxuICAgIFwicHJldmlvdXNBZmZlY3RpbmdUcmFuc2FjdGlvbklEXCIsXG4gICAgXCJwcmV2aW91c0FmZmVjdGluZ1RyYW5zYWN0aW9uTGVkZ2VyVmVyc2lvblwiXG4gIF0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRTZXJ2ZXJJbmZvXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYnVpbGRWZXJzaW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB2ZXJzaW9uIG51bWJlciBvZiB0aGUgcnVubmluZyByaXBwbGVkIHZlcnNpb24uXCJcbiAgICB9LFxuICAgIFwiY29tcGxldGVMZWRnZXJzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJwYXR0ZXJuXCI6IFwiWzAtOSwtXStcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJSYW5nZSBleHByZXNzaW9uIGluZGljYXRpbmcgdGhlIHNlcXVlbmNlIG51bWJlcnMgb2YgdGhlIGxlZGdlciB2ZXJzaW9ucyB0aGUgbG9jYWwgcmlwcGxlZCBoYXMgaW4gaXRzIGRhdGFiYXNlLiBJdCBpcyBwb3NzaWJsZSB0byBiZSBhIGRpc2pvaW50IHNlcXVlbmNlLCBlLmcuIOKAnDI1MDAtNTAwMCwzMjU3MC03Njk1NDMy4oCdLlwiXG4gICAgfSxcbiAgICBcImhvc3RJRFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJPbiBhbiBhZG1pbiByZXF1ZXN0LCByZXR1cm5zIHRoZSBob3N0bmFtZSBvZiB0aGUgc2VydmVyIHJ1bm5pbmcgdGhlIHJpcHBsZWQgaW5zdGFuY2U7IG90aGVyd2lzZSwgcmV0dXJucyBhIHVuaXF1ZSBmb3VyIGxldHRlciB3b3JkLlwiXG4gICAgfSxcbiAgICBcImlvTGF0ZW5jeU1zXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFtb3VudCBvZiB0aW1lIHNwZW50IHdhaXRpbmcgZm9yIEkvTyBvcGVyYXRpb25zLCBpbiBtaWxsaXNlY29uZHMuIElmIHRoaXMgbnVtYmVyIGlzIG5vdCB2ZXJ5LCB2ZXJ5IGxvdywgdGhlbiB0aGUgcmlwcGxlZCBzZXJ2ZXIgaXMgcHJvYmFibHkgaGF2aW5nIHNlcmlvdXMgbG9hZCBpc3N1ZXMuXCJcbiAgICB9LFxuICAgIFwibG9hZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCIqKEFkbWluIG9ubHkpKiBEZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBsb2FkIHN0YXRlIG9mIHRoZSBzZXJ2ZXIuXCIsXG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImpvYlR5cGVzXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCIqKEFkbWluIG9ubHkpKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgcmF0ZSBvZiBkaWZmZXJlbnQgdHlwZXMgb2Ygam9icyB0aGUgc2VydmVyIGlzIGRvaW5nIGFuZCBob3cgbXVjaCB0aW1lIGl0IHNwZW5kcyBvbiBlYWNoLlwiLFxuICAgICAgICAgIFwiaXRlbXNcIjoge1widHlwZVwiOiBcIm9iamVjdFwifVxuICAgICAgICB9LFxuICAgICAgICBcInRocmVhZHNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCIqKEFkbWluIG9ubHkpKiBUaGUgbnVtYmVyIG9mIHRocmVhZHMgaW4gdGhlIHNlcnZlcuKAmXMgbWFpbiBqb2IgcG9vbCwgcGVyZm9ybWluZyB2YXJpb3VzIG9wZXJhdGlvbnMuXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFwicmVxdWlyZWRcIjogW1wiam9iVHlwZXNcIiwgXCJ0aHJlYWRzXCJdXG4gICAgfSxcbiAgICBcImxhc3RDbG9zZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJbmZvcm1hdGlvbiBhYm91dCB0aGUgbGFzdCB0aW1lIHRoZSBzZXJ2ZXIgY2xvc2VkIGEgbGVkZ2VyLlwiLFxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJjb252ZXJnZVRpbWVTXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHRpbWUgaXQgdG9vayB0byByZWFjaCBhIGNvbnNlbnN1cyBmb3IgdGhlIGxhc3QgbGVkZ2VyIGNsb3NpbmcsIGluIHNlY29uZHMuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJwcm9wb3NlcnNcIjoge1xuICAgICAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTnVtYmVyIG9mIHRydXN0ZWQgdmFsaWRhdG9ycyBwYXJ0aWNpcGF0aW5nIGluIHRoZSBsZWRnZXIgY2xvc2luZy5cIn1cbiAgICAgIH0sXG4gICAgICBcInJlcXVpcmVkXCI6IFtcImNvbnZlcmdlVGltZVNcIiwgXCJwcm9wb3NlcnNcIl1cbiAgICB9LFxuICAgIFwibG9hZEZhY3RvclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgbG9hZCBmYWN0b3IgdGhlIHNlcnZlciBpcyBjdXJyZW50bHkgZW5mb3JjaW5nLCBhcyBhIG11bHRpcGxpZXIgb24gdGhlIGJhc2UgdHJhbnNhY3Rpb24gZmVlLiBUaGUgbG9hZCBmYWN0b3IgaXMgZGV0ZXJtaW5lZCBieSB0aGUgaGlnaGVzdCBvZiB0aGUgaW5kaXZpZHVhbCBzZXJ2ZXLigJlzIGxvYWQgZmFjdG9yLCBjbHVzdGVy4oCZcyBsb2FkIGZhY3RvciwgYW5kIHRoZSBvdmVyYWxsIG5ldHdvcmvigJlzIGxvYWQgZmFjdG9yLlwiXG4gICAgfSxcbiAgICBcInBlZXJzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkhvdyBtYW55IG90aGVyIHJpcHBsZWQgc2VydmVycyB0aGUgbm9kZSBpcyBjdXJyZW50bHkgY29ubmVjdGVkIHRvLlwiXG4gICAgfSxcbiAgICBcInB1YmtleU5vZGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUHVibGljIGtleSB1c2VkIHRvIHZlcmlmeSB0aGlzIG5vZGUgZm9yIGludGVybmFsIGNvbW11bmljYXRpb25zOyB0aGlzIGtleSBpcyBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBieSB0aGUgc2VydmVyIHRoZSBmaXJzdCB0aW1lIGl0IHN0YXJ0cyB1cC5cIlxuICAgIH0sXG4gICAgXCJwdWJrZXlWYWxpZGF0b3JcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiKihBZG1pbiBvbmx5KSogUHVibGljIGtleSB1c2VkIGJ5IHRoaXMgbm9kZSB0byBzaWduIGxlZGdlciB2YWxpZGF0aW9ucy5cIlxuICAgIH0sXG4gICAgXCJzZXJ2ZXJTdGF0ZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIHN0cmluZyBpbmRpY2F0aW5nIHRvIHdoYXQgZXh0ZW50IHRoZSBzZXJ2ZXIgaXMgcGFydGljaXBhdGluZyBpbiB0aGUgbmV0d29yay4gU2VlIFtQb3NzaWJsZSBTZXJ2ZXIgU3RhdGVzXShodHRwczovL3hycGwub3JnL3JpcHBsZWQtc2VydmVyLXN0YXRlcy5odG1sKSBmb3IgbW9yZSBkZXRhaWxzLlwiLFxuICAgICAgXCJlbnVtXCI6IFtcImRpc2Nvbm5lY3RlZFwiLCBcImNvbm5lY3RlZFwiLCBcInN5bmNpbmdcIiwgXCJ0cmFja2luZ1wiLCBcImZ1bGxcIiwgXCJ2YWxpZGF0aW5nXCIsIFwicHJvcG9zaW5nXCJdXG4gICAgfSxcbiAgICBcInZhbGlkYXRlZExlZGdlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJbmZvcm1hdGlvbiBhYm91dCB0aGUgZnVsbHktdmFsaWRhdGVkIGxlZGdlciB3aXRoIHRoZSBoaWdoZXN0IHNlcXVlbmNlIG51bWJlciAodGhlIG1vc3QgcmVjZW50KS5cIixcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiYWdlXCI6IHtcbiAgICAgICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgXCJtaW5pbXVtXCI6IDAsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB0aW1lIHNpbmNlIHRoZSBsZWRnZXIgd2FzIGNsb3NlZCwgaW4gc2Vjb25kcy5cIlxuICAgICAgICB9LFxuICAgICAgICBcImJhc2VGZWVYUlBcIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcInZhbHVlXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkJhc2UgZmVlLCBpbiBYUlAuIFRoaXMgbWF5IGJlIHJlcHJlc2VudGVkIGluIHNjaWVudGlmaWMgbm90YXRpb24gc3VjaCBhcyAxZS0wNSBmb3IgMC4wMDAwNS5cIlxuICAgICAgICB9LFxuICAgICAgICBcImhhc2hcIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImhhc2gyNTZcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVW5pcXVlIGhhc2ggZm9yIHRoZSBsZWRnZXIsIGFzIGFuIHVwcGVyY2FzZSBoZXhhZGVjaW1hbCBzdHJpbmcuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXNlcnZlQmFzZVhSUFwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwidmFsdWVcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTWluaW11bSBhbW91bnQgb2YgWFJQIG5lY2Vzc2FyeSBmb3IgZXZlcnkgYWNjb3VudCB0byBrZWVwIGluIHJlc2VydmUuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXNlcnZlSW5jcmVtZW50WFJQXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJ2YWx1ZVwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbW91bnQgb2YgWFJQIGFkZGVkIHRvIHRoZSBhY2NvdW50IHJlc2VydmUgZm9yIGVhY2ggb2JqZWN0IGFuIGFjY291bnQgb3ducyBpbiB0aGUgbGVkZ2VyLlwiXG4gICAgICAgIH0sXG4gICAgICAgIFwibGVkZ2VyVmVyc2lvblwiOiB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgICAgICAgIFwibWluaW11bVwiOiAwLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZGVudGlmeWluZyBsZWRnZXIgaW5kZXggb2YgdGhpcyBsZWRnZXIgdmVyc2lvbi5cIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgICAgIFwicmVxdWlyZWRcIjogW1wiYWdlXCIsIFwiYmFzZUZlZVhSUFwiLCBcImhhc2hcIiwgXCJyZXNlcnZlQmFzZVhSUFwiLCBcInJlc2VydmVJbmNyZW1lbnRYUlBcIiwgXCJsZWRnZXJWZXJzaW9uXCJdXG4gICAgfSxcbiAgICBcInZhbGlkYXRpb25RdW9ydW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTWluaW11bSBudW1iZXIgb2YgdHJ1c3RlZCB2YWxpZGF0aW9ucyByZXF1aXJlZCB0byB2YWxpZGF0ZSBhIGxlZGdlciB2ZXJzaW9uLiBTb21lIGNpcmN1bXN0YW5jZXMgbWF5IGNhdXNlIHRoZSBzZXJ2ZXIgdG8gcmVxdWlyZSBtb3JlIHZhbGlkYXRpb25zLlwiXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImJ1aWxkVmVyc2lvblwiLCBcImNvbXBsZXRlTGVkZ2Vyc1wiLCBcImhvc3RJRFwiLCBcImlvTGF0ZW5jeU1zXCIsIFwibGFzdENsb3NlXCIsIFwibG9hZEZhY3RvclwiLCBcInBlZXJzXCIsIFwicHVia2V5Tm9kZVwiLCBcInNlcnZlclN0YXRlXCIsIFwidmFsaWRhdGVkTGVkZ2VyXCIsIFwidmFsaWRhdGlvblF1b3J1bVwiXSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImdldFNldHRpbmdzXCIsXG4gIFwiJHJlZlwiOiBcInNldHRpbmdzUGx1c01lbW9zXCIsXG4gIFwibm90XCI6IHtcbiAgICBcInJlcXVpcmVkXCI6IFtcIm1lbW9zXCJdXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRUcmFuc2FjdGlvblwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiZ2V0VHJhbnNhY3Rpb24gcmVzcG9uc2VcIixcbiAgXCJsaW5rXCI6IFwiZ2V0dHJhbnNhY3Rpb25cIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCIkcmVmXCI6IFwidHJhbnNhY3Rpb25UeXBlXCJcbiAgICB9LFxuICAgIFwic3BlY2lmaWNhdGlvblwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBzcGVjaWZpY2F0aW9uIHRoYXQgd291bGQgcHJvZHVjZSB0aGUgc2FtZSBvdXRjb21lIGFzIHRoaXMgdHJhbnNhY3Rpb24uICpFeGNlcHRpb246KiBGb3IgcGF5bWVudCB0cmFuc2FjdGlvbnMsIHRoaXMgb21pdHMgdGhlIGBkZXN0aW5hdGlvbi5hbW91bnRgIGZpZWxkLCB0byBwcmV2ZW50IG1pc3VuZGVyc3RhbmRpbmcuIFRoZSBzdHJ1Y3R1cmUgb2YgdGhlIHNwZWNpZmljYXRpb24gZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgdGhlIGB0eXBlYCBmaWVsZCAoc2VlIFtUcmFuc2FjdGlvbiBUeXBlc10oI3RyYW5zYWN0aW9uLXR5cGVzKSBmb3IgZGV0YWlscykuICpOb3RlOiogVGhpcyBpcyAqKm5vdCoqIG5lY2Vzc2FyaWx5IHRoZSBzYW1lIGFzIHRoZSBvcmlnaW5hbCBzcGVjaWZpY2F0aW9uLlwiXG4gICAgfSxcbiAgICBcIm91dGNvbWVcIjoge1xuICAgICAgXCIkcmVmXCI6IFwib3V0Y29tZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBvdXRjb21lIG9mIHRoZSB0cmFuc2FjdGlvbiAod2hhdCBlZmZlY3RzIGl0IGhhZCkuXCJcbiAgICB9LFxuICAgIFwiaWRcIjoge1xuICAgICAgXCIkcmVmXCI6IFwidHJhbnNhY3Rpb25IYXNoXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0LlwiXG4gICAgfSxcbiAgICBcImFkZHJlc3NcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgaW5pdGlhdGVkIHRoZSB0cmFuc2FjdGlvbi5cIlxuICAgIH0sXG4gICAgXCJzZXF1ZW5jZVwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJzZXF1ZW5jZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBhY2NvdW50IHNlcXVlbmNlIG51bWJlciBvZiB0aGUgdHJhbnNhY3Rpb24gZm9yIHRoZSBhY2NvdW50IHRoYXQgaW5pdGlhdGVkIGl0LlwiXG4gICAgfSxcbiAgICBcInJhd1RyYW5zYWN0aW9uXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgcmF3IHRyYW5zYWN0aW9uIGRhdGEgYXMgYSBKU09OIHN0cmluZy4gRm9yIGFkdmFuY2VkIHVzZXJzIG9ubHk7IGV4ZXJjaXNlIGNhdXRpb24gd2hlbiBpbnRlcnByZXRpbmcgdGhpcyBkYXRhLlwiLFxuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogW1xuICAgIFwiaWRcIixcbiAgICBcImFkZHJlc3NcIixcbiAgICBcInNlcXVlbmNlXCIsXG4gICAgXCJ0eXBlXCIsXG4gICAgXCJzcGVjaWZpY2F0aW9uXCIsXG4gICAgXCJvdXRjb21lXCJcbiAgXSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZSxcbiAgXCJvbmVPZlwiOiBbXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJwYXltZW50XCJcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BlY2lmaWNhdGlvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwiZ2V0UGF5bWVudFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwib3JkZXJcIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcGVjaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJvcmRlclwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwib3JkZXJDYW5jZWxsYXRpb25cIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcGVjaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJvcmRlckNhbmNlbGxhdGlvblwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwidHJ1c3RsaW5lXCJcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BlY2lmaWNhdGlvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwidHJ1c3RsaW5lXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJzZXR0aW5nc1wiXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcInNwZWNpZmljYXRpb25cIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImdldFNldHRpbmdzXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJjaGVja0NyZWF0ZVwiXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcInNwZWNpZmljYXRpb25cIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImNoZWNrQ3JlYXRlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJjaGVja0NhbmNlbFwiXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcInNwZWNpZmljYXRpb25cIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImNoZWNrQ2FuY2VsXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJjaGVja0Nhc2hcIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcGVjaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJjaGVja0Nhc2hcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcInR5cGVcIjoge1xuICAgICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcImVzY3Jvd0NyZWF0aW9uXCJcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BlY2lmaWNhdGlvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwiZXNjcm93Q3JlYXRpb25cIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcInR5cGVcIjoge1xuICAgICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcImVzY3Jvd0NhbmNlbGxhdGlvblwiXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcInNwZWNpZmljYXRpb25cIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImVzY3Jvd0NhbmNlbGxhdGlvblwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwidHlwZVwiOiB7XG4gICAgICAgICAgXCJlbnVtXCI6IFtcbiAgICAgICAgICAgIFwiZXNjcm93RXhlY3V0aW9uXCJcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BlY2lmaWNhdGlvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwiZXNjcm93RXhlY3V0aW9uXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJwYXltZW50Q2hhbm5lbENyZWF0ZVwiXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcInNwZWNpZmljYXRpb25cIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcInBheW1lbnRDaGFubmVsQ3JlYXRlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJwYXltZW50Q2hhbm5lbEZ1bmRcIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcGVjaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJwYXltZW50Q2hhbm5lbEZ1bmRcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICBcInR5cGVcIjoge1xuICAgICAgICAgIFwiZW51bVwiOiBbXG4gICAgICAgICAgICBcInBheW1lbnRDaGFubmVsQ2xhaW1cIlxuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcGVjaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJwYXltZW50Q2hhbm5lbENsYWltXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJkZXBvc2l0UHJlYXV0aFwiXG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBcInNwZWNpZmljYXRpb25cIjoge1xuICAgICAgICAgIFwiJHJlZlwiOiBcImRlcG9zaXRQcmVhdXRoXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IHtcbiAgICAgICAgICBcImVudW1cIjogW1xuICAgICAgICAgICAgXCJhY2NvdW50RGVsZXRlXCJcbiAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BlY2lmaWNhdGlvblwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwiYWNjb3VudERlbGV0ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIF1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRUcmFuc2FjdGlvbnNcIixcbiAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgXCJpdGVtc1wiOiB7XG4gICAgXCIkcmVmXCI6IFwiZ2V0VHJhbnNhY3Rpb25cIlxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiZ2V0VHJ1c3RsaW5lc1wiLFxuICBcInR5cGVcIjogXCJhcnJheVwiLFxuICBcIml0ZW1zXCI6IHtcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgXCJzcGVjaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgXCIkcmVmXCI6IFwidHJ1c3RsaW5lXCIsXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIHRydXN0IGxpbmUgc3BlY2lmaWNhdGlvbiB0aGF0IHdvdWxkIHByb2R1Y2UgdGhpcyB0cnVzdCBsaW5lIGluIGl0cyBjdXJyZW50IHN0YXRlLlwiXG4gICAgICB9LFxuICAgICAgXCJjb3VudGVycGFydHlcIjoge1xuICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgIFwibGltaXRcIjoge1xuICAgICAgICAgICAgXCIkcmVmXCI6IFwidmFsdWVcIixcbiAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgbWF4aW11bSBhbW91bnQgdGhhdCB0aGUgY291bnRlcnBhcnR5IGNhbiBiZSBvd2VkIHRocm91Z2ggdGhlIHRydXN0IGxpbmUuXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmlwcGxpbmdEaXNhYmxlZFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgdHJ1ZSwgcGF5bWVudHMgY2Fubm90IHJpcHBsZSB0aHJvdWdoIHRoaXMgdHJ1c3RsaW5lLlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImZyb3plblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgdHJ1ZSwgdGhlIHRydXN0IGxpbmUgaXMgZnJvemVuLCB3aGljaCBtZWFucyB0aGF0IGZ1bmRzIGNhbiBvbmx5IGJlIHNlbnQgZGlyZWN0bHkgdG8gdGhlIGNvdW50ZXJwYXJ0eS5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJhdXRob3JpemVkXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiB0cnVlLCB0aGUgY291bnRlcnBhcnR5IGF1dGhvcml6ZXMgdGhpcyBwYXJ0eSB0byBob2xkIGlzc3VhbmNlcyBmcm9tIHRoZSBjb3VudGVycGFydHkuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJQcm9wZXJ0aWVzIG9mIHRoZSB0cnVzdGxpbmUgZnJvbSB0aGUgcGVyc3BlY3RpdmUgb2YgdGhlIGNvdW50ZXJwYXJ0eS5cIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXCJsaW1pdFwiXSxcbiAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIFwic3RhdGVcIjoge1xuICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgIFwiYmFsYW5jZVwiOiB7XG4gICAgICAgICAgICBcIiRyZWZcIjogXCJzaWduZWRWYWx1ZVwiLFxuICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBiYWxhbmNlIG9uIHRoZSB0cnVzdCBsaW5lLCByZXByZXNlbnRpbmcgd2hpY2ggcGFydHkgb3dlcyB0aGUgb3RoZXIgYW5kIGJ5IGhvdyBtdWNoLlwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTm9uLXNldHRpbmdzIGRldGFpbHMgb2YgdGhlIHRydXN0IGxpbmUncyBzdGF0ZS5cIixcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXCJiYWxhbmNlXCJdLFxuICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlcXVpcmVkXCI6IFtcInNwZWNpZmljYXRpb25cIiwgXCJjb3VudGVycGFydHlcIiwgXCJzdGF0ZVwiXSxcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJsZWRnZXJFdmVudFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBsZWRnZXIgZXZlbnQgbWVzc2FnZVwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImJhc2VGZWVYUlBcIjoge1xuICAgICAgXCIkcmVmXCI6IFwidmFsdWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJCYXNlIGZlZSwgaW4gWFJQLlwiXG4gICAgfSxcbiAgICBcImxlZGdlckhhc2hcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiaGFzaDI1NlwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlVuaXF1ZSBoYXNoIG9mIHRoZSBsZWRnZXIgdGhhdCB3YXMgY2xvc2VkLCBhcyBoZXguXCJcbiAgICB9LFxuICAgIFwibGVkZ2VyVmVyc2lvblwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJsZWRnZXJWZXJzaW9uXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTGVkZ2VyIHZlcnNpb24gb2YgdGhlIGxlZGdlciB0aGF0IGNsb3NlZC5cIlxuICAgIH0sXG4gICAgXCJsZWRnZXJUaW1lc3RhbXBcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcImRhdGUtdGltZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB0aW1lIGF0IHdoaWNoIHRoaXMgbGVkZ2VyIGNsb3NlZC5cIlxuICAgIH0sXG4gICAgXCJyZXNlcnZlQmFzZVhSUFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJ2YWx1ZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBtaW5pbXVtIHJlc2VydmUsIGluIFhSUCwgdGhhdCBpcyByZXF1aXJlZCBmb3IgYW4gYWNjb3VudC5cIlxuICAgIH0sXG4gICAgXCJyZXNlcnZlSW5jcmVtZW50WFJQXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInZhbHVlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGluY3JlYXNlIGluIGFjY291bnQgcmVzZXJ2ZSB0aGF0IGlzIGFkZGVkIGZvciBlYWNoIGl0ZW0gdGhlIGFjY291bnQgb3ducywgc3VjaCBhcyBvZmZlcnMgb3IgdHJ1c3QgbGluZXMuXCJcbiAgICB9LFxuICAgIFwidHJhbnNhY3Rpb25Db3VudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJOdW1iZXIgb2YgbmV3IHRyYW5zYWN0aW9ucyBpbmNsdWRlZCBpbiB0aGlzIGxlZGdlci5cIlxuICAgIH0sXG4gICAgXCJ2YWxpZGF0ZWRMZWRnZXJWZXJzaW9uc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJSYW5nZSBvZiBsZWRnZXJzIHRoYXQgdGhlIHNlcnZlciBoYXMgYXZhaWxhYmxlLiBUaGlzIG1heSBiZSBkaXNjb250aWd1b3VzLlwiXG4gICAgfVxuICB9LFxuICBcImFkZHRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwicmVxdWlyZWRcIjogW1wiYmFzZUZlZVhSUFwiLCBcImxlZGdlckhhc2hcIiwgXCJsZWRnZXJUaW1lc3RhbXBcIixcbiAgICBcInJlc2VydmVCYXNlWFJQXCIsIFwicmVzZXJ2ZUluY3JlbWVudFhSUFwiLCBcInRyYW5zYWN0aW9uQ291bnRcIixcbiAgICBcImxlZGdlclZlcnNpb25cIiwgXCJ2YWxpZGF0ZWRMZWRnZXJWZXJzaW9uc1wiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcIm9yZGVyQ2hhbmdlXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQSBjaGFuZ2UgdG8gYW4gb3JkZXIuXCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJkaXJlY3Rpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImVudW1cIjogW1wiYnV5XCIsIFwic2VsbFwiXSxcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJFcXVhbCB0byBcXFwiYnV5XFxcIiBmb3IgYnV5IG9yZGVycyBhbmQgXFxcInNlbGxcXFwiIGZvciBzZWxsIG9yZGVycy5cIlxuICAgIH0sXG4gICAgXCJxdWFudGl0eVwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhbW91bnRcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYW1vdW50IHRvIGJlIGJvdWdodCBvciBzb2xkIGJ5IHRoZSBtYWtlci5cIlxuICAgIH0sXG4gICAgXCJ0b3RhbFByaWNlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFtb3VudFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB0b3RhbCBhbW91bnQgdG8gYmUgcGFpZCBvciByZWNlaXZlZCBieSB0aGUgdGFrZXIuXCJcbiAgICB9LFxuICAgIFwibWFrZXJFeGNoYW5nZVJhdGVcIjoge1xuICAgICAgXCIkcmVmXCI6IFwidmFsdWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgZXhjaGFuZ2UgcmF0ZSBiZXR3ZWVuIHRoZSBgcXVhbnRpdHlgIGN1cnJlbmN5IGFuZCB0aGUgYHRvdGFsUHJpY2VgIGN1cnJlbmN5IGZyb20gdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIG1ha2VyLlwiXG4gICAgfSxcbiAgICBcInNlcXVlbmNlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInNlcXVlbmNlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIG9yZGVyIHNlcXVlbmNlIG51bWJlciwgdXNlZCB0byBpZGVudGlmeSB0aGUgb3JkZXIgZm9yIGNhbmNlbGxhdGlvblwiXG4gICAgfSxcbiAgICBcInN0YXR1c1wiOiB7XG4gICAgICBcImVudW1cIjogW1wiY3JlYXRlZFwiLCBcImZpbGxlZFwiLCBcInBhcnRpYWxseS1maWxsZWRcIiwgXCJjYW5jZWxsZWRcIl0sXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHN0YXR1cyBvZiB0aGUgb3JkZXIuIE9uZSBvZiBcXFwiY3JlYXRlZFxcXCIsIFxcXCJmaWxsZWRcXFwiLCBcXFwicGFydGlhbGx5LWZpbGxlZFxcXCIsIFxcXCJjYW5jZWxsZWRcXFwiLlwiXG4gICAgfSxcbiAgICBcImV4cGlyYXRpb25UaW1lXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJkYXRlLXRpbWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgdGltZSBhZnRlciB3aGljaCB0aGUgb3JkZXIgZXhwaXJlcywgaWYgYW55LlwiXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImRpcmVjdGlvblwiLCBcInF1YW50aXR5XCIsIFwidG90YWxQcmljZVwiLCBcInNlcXVlbmNlXCIsIFwic3RhdHVzXCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwib3JkZXJib29rT3JkZXJzXCIsXG4gIFwidHlwZVwiOiBcImFycmF5XCIsXG4gIFwiaXRlbXNcIjoge1xuICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbiBvcmRlciBpbiB0aGUgb3JkZXIgYm9vay5cIixcbiAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgXCJzcGVjaWZpY2F0aW9uXCI6IHtcbiAgICAgICAgXCIkcmVmXCI6IFwib3JkZXJcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFuIG9yZGVyIHNwZWNpZmljYXRpb24gdGhhdCB3b3VsZCBjcmVhdGUgYW4gb3JkZXIgZXF1aXZhbGVudCB0byB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIG9yZGVyLlwiXG4gICAgICB9LFxuICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlByb3BlcnRpZXMgb2YgdGhlIG9yZGVyIG5vdCBpbiB0aGUgc3BlY2lmaWNhdGlvbi5cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgICAgXCJtYWtlclwiOiB7XG4gICAgICAgICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBzdWJtaXR0ZWQgdGhlIG9yZGVyLlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlcXVlbmNlXCI6IHtcbiAgICAgICAgICAgIFwiJHJlZlwiOiBcInNlcXVlbmNlXCIsXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFjY291bnQgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZWQgdGhpcyBvcmRlci5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJtYWtlckV4Y2hhbmdlUmF0ZVwiOiB7XG4gICAgICAgICAgICBcIiRyZWZcIjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBleGNoYW5nZSByYXRlIGZyb20gdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIGFjY291bnQgdGhhdCBzdWJtaXR0ZWQgdGhlIG9yZGVyIChhbHNvIGtub3duIGFzIFxcXCJxdWFsaXR5XFxcIikuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicmVxdWlyZWRcIjogW1wibWFrZXJcIiwgXCJzZXF1ZW5jZVwiLCBcIm1ha2VyRXhjaGFuZ2VSYXRlXCJdLFxuICAgICAgICBcImFkZHRpb25hbFByb3BlcnRpZXNcIjogZmFsc2VcbiAgICAgIH0sXG4gICAgICBcInN0YXRlXCI6IHtcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBzdGF0ZSBvZiB0aGUgb3JkZXIuXCIsXG4gICAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgICAgIFwiZnVuZGVkQW1vdW50XCI6IHtcbiAgICAgICAgICAgIFwiJHJlZlwiOiBcImFtb3VudFwiLFxuICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkhvdyBtdWNoIG9mIHRoZSBhbW91bnQgdGhlIG1ha2VyIHdvdWxkIGhhdmUgdG8gcGF5IHRoYXQgdGhlIG1ha2VyIGN1cnJlbnRseSBob2xkcy5cIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJwcmljZU9mRnVuZGVkQW1vdW50XCI6IHtcbiAgICAgICAgICAgIFwiJHJlZlwiOiBcImFtb3VudFwiLFxuICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkhvdyBtdWNoIHRoZSBgZnVuZGVkQW1vdW50YCB3b3VsZCBjb252ZXJ0IHRvIHRocm91Z2ggdGhlIGV4Y2hhbmdlIHJhdGUgb2YgdGhpcyBvcmRlci5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJyZXF1aXJlZFwiOiBbXCJmdW5kZWRBbW91bnRcIiwgXCJwcmljZU9mRnVuZGVkQW1vdW50XCJdLFxuICAgICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gICAgICB9LFxuICAgICAgXCJkYXRhXCI6IHtcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSByYXcgb3JkZXIgZGF0YS4gVGhpcyBtYXkgaW5jbHVkZSBgb3duZXJfZnVuZHNgLCBgRmxhZ3NgLCBhbmQgb3RoZXIgZmllbGRzLlwiLFxuICAgICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBcInJlcXVpcmVkXCI6IFtcInNwZWNpZmljYXRpb25cIiwgXCJwcm9wZXJ0aWVzXCIsIFwiZGF0YVwiXSxcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJvdXRjb21lXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIG91dGNvbWUgb2YgdGhlIHRyYW5zYWN0aW9uICh3aGF0IGVmZmVjdHMgaXQgaGFkKS5cIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcInJlc3VsdFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJSZXN1bHQgY29kZSByZXR1cm5lZCBieSByaXBwbGVkLiBTZWUgW1RyYW5zYWN0aW9uIFJlc3VsdHNdKGh0dHBzOi8veHJwbC5vcmcvdHJhbnNhY3Rpb24tcmVzdWx0cy5odG1sKSBmb3IgYSBjb21wbGV0ZSBsaXN0LlwiXG4gICAgfSxcbiAgICBcInRpbWVzdGFtcFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHRpbWVzdGFtcCB3aGVuIHRoZSB0cmFuc2FjdGlvbiB3YXMgdmFsaWRhdGVkLiAoTWF5IGJlIG1pc3Npbmcgd2hlbiByZXF1ZXN0aW5nIHRyYW5zYWN0aW9ucyBpbiBiaW5hcnkgbW9kZS4pXCJcbiAgICB9LFxuICAgIFwiZmVlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInZhbHVlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIFhSUCBmZWUgdGhhdCB3YXMgY2hhcmdlZCBmb3IgdGhlIHRyYW5zYWN0aW9uLlwiXG4gICAgfSxcbiAgICBcImRlbGl2ZXJlZEFtb3VudFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhbW91bnRcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJGb3IgcGF5bWVudCB0cmFuc2FjdGlvbnMsIGl0IGlzIGltcG9zc2libGUgdG8gcmVsaWFibHkgY29tcHV0ZSB0aGUgYWN0dWFsIGRlbGl2ZXJlZCBhbW91bnQgZnJvbSB0aGUgYmFsYW5jZUNoYW5nZXMgZHVlIHRvIGZpeGVkIHByZWNpc2lvbi4gSWYgdGhlIHBheW1lbnQgaXMgbm90IGEgcGFydGlhbCBwYXltZW50IGFuZCB0aGUgdHJhbnNhY3Rpb24gc3VjY2VlZGVkLCB0aGUgZGVsaXZlcmVkQW1vdW50IHNob3VsZCBhbHdheXMgYmUgY29uc2lkZXJlZCB0byBiZSB0aGUgYW1vdW50IHNwZWNpZmllZCBpbiB0aGUgdHJhbnNhY3Rpb24uXCJcbiAgICB9LFxuICAgIFwiYmFsYW5jZUNoYW5nZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIktleSBpcyB0aGUgWFJQIExlZGdlciBhZGRyZXNzOyB2YWx1ZSBpcyBhbiBhcnJheSBvZiBzaWduZWQgYW1vdW50cyByZXByZXNlbnRpbmcgY2hhbmdlcyBvZiBiYWxhbmNlcyBmb3IgdGhhdCBhZGRyZXNzLlwiLFxuICAgICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCJiYWxhbmNlXCJ9XG4gICAgICB9XG4gICAgfSxcbiAgICBcIm9yZGVyYm9va0NoYW5nZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIktleSBpcyB0aGUgbWFrZXIncyBYUlAgTGVkZ2VyIGFkZHJlc3M7IHZhbHVlIGlzIGFuIGFycmF5IG9mIGNoYW5nZXNcIixcbiAgICAgICAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwib3JkZXJDaGFuZ2VcIn1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2hhbm5lbENoYW5nZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUHJvcGVydGllcyByZWZsZWN0aW5nIHRoZSBkZXRhaWxzIG9mIHRoZSBwYXltZW50IGNoYW5uZWwuXCJcbiAgICB9LFxuICAgIFwibGVkZ2VyVmVyc2lvblwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJsZWRnZXJWZXJzaW9uXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGxlZGdlciB2ZXJzaW9uIHRoYXQgdGhlIHRyYW5zYWN0aW9uIHdhcyB2YWxpZGF0ZWQgaW4uXCJcbiAgICB9LFxuICAgIFwiaW5kZXhJbkxlZGdlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMCxcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgb3JkZXJpbmcgaW5kZXggb2YgdGhlIHRyYW5zYWN0aW9uIGluIHRoZSBsZWRnZXIuXCJcbiAgICB9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogW1wicmVzdWx0XCIsIFwiZmVlXCIsIFwiYmFsYW5jZUNoYW5nZXNcIixcbiAgICBcIm9yZGVyYm9va0NoYW5nZXNcIiwgXCJsZWRnZXJWZXJzaW9uXCIsIFwiaW5kZXhJbkxlZGdlclwiXSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInByZXBhcmVcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlJlc3VsdCBvZiBwcmVwYXJlIGZ1bmN0aW9uXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwidHhKU09OXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBwcmVwYXJlZCB0cmFuc2FjdGlvbiBpbiByaXBwbGVkIEpTT04gZm9ybWF0LlwiXG4gICAgfSxcbiAgICBcImluc3RydWN0aW9uc1wiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGluc3RydWN0aW9ucyBmb3IgaG93IHRvIGV4ZWN1dGUgdGhlIHRyYW5zYWN0aW9uIGFmdGVyIGFkZGluZyBhdXRvbWF0aWMgZGVmYXVsdHMuXCIsXG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiZmVlXCI6IHtcbiAgICAgICAgICBcIiRyZWZcIjogXCJ2YWx1ZVwiLFxuICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgZmVlIHRvIHBheSBmb3IgdGhlIHRyYW5zYWN0aW9uLiBTZWUgW1RyYW5zYWN0aW9uIEZlZXNdKCN0cmFuc2FjdGlvbi1mZWVzKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi4gRm9yIG11bHRpLXNpZ25lZCB0cmFuc2FjdGlvbnMsIHRoaXMgZmVlIGlzIG11bHRpcGxpZWQgYnkgKE4rMSksIHdoZXJlIE4gaXMgdGhlIG51bWJlciBvZiBzaWduYXR1cmVzIHlvdSBwbGFuIHRvIHByb3ZpZGUuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXF1ZW5jZVwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwic2VxdWVuY2VcIixcbiAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGluaXRpYXRpbmcgYWNjb3VudCdzIHNlcXVlbmNlIG51bWJlciBmb3IgdGhpcyB0cmFuc2FjdGlvbi4gYHNlcXVlbmNlYCBhbmQgYHRpY2tldFNlcXVlbmNlYCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLCBvbmx5IG9uZSBvZiB0aGVtIGNhbiBiZSBzZXQuXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJ0aWNrZXRTZXF1ZW5jZVwiOiB7XG4gICAgICAgICAgXCIkcmVmXCI6IFwidGlja2V0LXNlcXVlbmNlXCIsXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBpbml0aWF0aW5nIGFjY291bnQncyB0aWNrZXQgc2VxdWVuY2UgbnVtYmVyIGZvciB0aGlzIHRyYW5zYWN0aW9uLiBgc2VxdWVuY2VgIGFuZCBgdGlja2V0U2VxdWVuY2VgIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIG9ubHkgb25lIG9mIHRoZW0gY2FuIGJlIHNldC5cIlxuICAgICAgICB9LFxuICAgICAgICBcIm1heExlZGdlclZlcnNpb25cIjoge1xuICAgICAgICAgIFwib25lT2ZcIjogW1xuICAgICAgICAgICAge1wiJHJlZlwiOiBcImxlZGdlclZlcnNpb25cIn0sXG4gICAgICAgICAgICB7XCJ0eXBlXCI6IFwibnVsbFwifVxuICAgICAgICAgIF0sXG4gICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBoaWdoZXN0IGxlZGdlciB2ZXJzaW9uIHRoYXQgdGhlIHRyYW5zYWN0aW9uIGNhbiBiZSBpbmNsdWRlZCBpbi4gU2V0IHRvIGBudWxsYCBpZiB0aGVyZSBpcyBubyBtYXhpbXVtLiBJZiBub3QgbnVsbCwgdGhpcyBtdXN0IGJlIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIDAsIG9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHN0cmluZ3M6ICd2YWxpZGF0ZWQnLCAnY2xvc2VkJywgJ2N1cnJlbnQnLlwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICAgICAgXCJyZXF1aXJlZFwiOiBbXCJmZWVcIiwgXCJtYXhMZWRnZXJWZXJzaW9uXCJdLFxuICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgICAgeyBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICBbIFwic2VxdWVuY2VcIiBdIH0sXG4gICAgICAgICAgeyBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICBbIFwidGlja2V0U2VxdWVuY2VcIiBdIH1cbiAgICAgICAgXVxuICAgICAgfVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlLFxuICBcInJlcXVpcmVkXCI6IFtcInR4SlNPTlwiLCBcImluc3RydWN0aW9uc1wiXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInNpZ25QYXltZW50Q2hhbm5lbENsYWltXCIsXG4gIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICBcIiRyZWZcIjogXCJzaWduYXR1cmVcIixcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInNpZ25cIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJzaWduZWRUcmFuc2FjdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwicGF0dGVyblwiOiBcIl5bQS1GMC05XSskXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIHNpZ25lZCB0cmFuc2FjdGlvbiByZXByZXNlbnRlZCBhcyBhbiB1cHBlcmNhc2UgaGV4YWRlY2ltYWwgc3RyaW5nLlwiXG4gICAgfSxcbiAgICBcImlkXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInRyYW5zYWN0aW9uSGFzaFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBbVHJhbnNhY3Rpb24gSURdKCN0cmFuc2FjdGlvbi1pZCkgb2YgdGhlIHNpZ25lZCB0cmFuc2FjdGlvbi5cIlxuICAgIH1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJzaWduZWRUcmFuc2FjdGlvblwiLCBcImlkXCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwic3VibWl0XCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwicmVzdWx0Q29kZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZXByZWNhdGVkOiBVc2UgYGVuZ2luZV9yZXN1bHRgIGluc3RlYWQuXCJcbiAgICB9LFxuICAgIFwicmVzdWx0TWVzc2FnZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZXByZWNhdGVkOiBVc2UgYGVuZ2luZV9yZXN1bHRfbWVzc2FnZWAgaW5zdGVhZC5cIlxuICAgIH0sXG4gICAgXCJlbmdpbmVfcmVzdWx0XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkNvZGUgaW5kaWNhdGluZyB0aGUgcHJlbGltaW5hcnkgcmVzdWx0IG9mIHRoZSB0cmFuc2FjdGlvbiwgZm9yIGV4YW1wbGUgYHRlc1NVQ0NFU1NgLiBbTGlzdCBvZiB0cmFuc2FjdGlvbiByZXNwb25zZXNdKGh0dHBzOi8veHJwbC5vcmcvdHJhbnNhY3Rpb24tcmVzdWx0cy5odG1sKVwiXG4gICAgfSxcbiAgICBcImVuZ2luZV9yZXN1bHRfY29kZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiTnVtZXJpYyBjb2RlIGluZGljYXRpbmcgdGhlIHByZWxpbWluYXJ5IHJlc3VsdCBvZiB0aGUgdHJhbnNhY3Rpb24sIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gYGVuZ2luZV9yZXN1bHRgXCJcbiAgICB9LFxuICAgIFwiZW5naW5lX3Jlc3VsdF9tZXNzYWdlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkh1bWFuLXJlYWRhYmxlIGV4cGxhbmF0aW9uIG9mIHRoZSB0cmFuc2FjdGlvbidzIHByZWxpbWluYXJ5IHJlc3VsdC5cIlxuICAgIH0sXG4gICAgXCJ0eF9ibG9iXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBjb21wbGV0ZSB0cmFuc2FjdGlvbiBpbiBoZXggc3RyaW5nIGZvcm1hdC5cIlxuICAgIH0sXG4gICAgXCJ0eF9qc29uXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInR4LWpzb25cIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgY29tcGxldGUgdHJhbnNhY3Rpb24gaW4gSlNPTiBmb3JtYXQuXCJcbiAgICB9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogW1wicmVzdWx0Q29kZVwiLCBcInJlc3VsdE1lc3NhZ2VcIiwgXCJlbmdpbmVfcmVzdWx0XCIsIFwiZW5naW5lX3Jlc3VsdF9jb2RlXCIsIFwiZW5naW5lX3Jlc3VsdF9tZXNzYWdlXCIsIFwidHhfYmxvYlwiLCBcInR4X2pzb25cIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJ2ZXJpZnlQYXltZW50Q2hhbm5lbENsYWltXCIsXG4gIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImFjY291bnREZWxldGVcIixcbiAgXCJsaW5rXCI6IFwiYWNjb3VudC1kZWxldGVcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJkZXN0aW5hdGlvblwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQWRkcmVzcyBvZiBhbiBhY2NvdW50IHRvIHJlY2VpdmUgYW55IGxlZnRvdmVyIFhSUCBhZnRlciBkZWxldGluZyB0aGUgc2VuZGluZyBhY2NvdW50LiBNdXN0IGJlIGEgZnVuZGVkIGFjY291bnQgaW4gdGhlIGxlZGdlciwgYW5kIG11c3Qgbm90IGJlIHRoZSBzZW5kaW5nIGFjY291bnQuXCJcbiAgICB9LFxuICAgIFwiZGVzdGluYXRpb25UYWdcIjoge1xuICAgICAgXCIkcmVmXCI6IFwidGFnXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiKE9wdGlvbmFsKSBBcmJpdHJhcnkgZGVzdGluYXRpb24gdGFnIHRoYXQgaWRlbnRpZmllcyBhIGhvc3RlZCByZWNpcGllbnQgb3Igb3RoZXIgaW5mb3JtYXRpb24gZm9yIHRoZSByZWNpcGllbnQgb2YgdGhlIGRlbGV0ZWQgYWNjb3VudCdzIGxlZnRvdmVyIFhSUC5cIlxuICAgIH0sXG4gICAgXCJkZXN0aW5hdGlvblhBZGRyZXNzXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJYLWFkZHJlc3Mgb2YgYW4gYWNjb3VudCB0byByZWNlaXZlIGFueSBsZWZ0b3ZlciBYUlAgYWZ0ZXIgZGVsZXRpbmcgdGhlIHNlbmRpbmcgYWNjb3VudC4gTXVzdCBiZSBhIGZ1bmRlZCBhY2NvdW50IGluIHRoZSBsZWRnZXIsIGFuZCBtdXN0IG5vdCBiZSB0aGUgc2VuZGluZyBhY2NvdW50LlwiXG4gICAgfSxcbiAgICBcIm1lbW9zXCI6IHtcIiRyZWZcIjogXCJtZW1vc1wifVxuICB9LFxuICBcImFueU9mXCI6IFtcbiAgICB7XG4gICAgICBcInJlcXVpcmVkXCI6IFtcImRlc3RpbmF0aW9uXCJdXG4gICAgfSxcbiAgICB7XG4gICAgICBcInJlcXVpcmVkXCI6IFtcImRlc3RpbmF0aW9uWEFkZHJlc3NcIl1cbiAgICB9XG4gIF0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJjaGVja0NhbmNlbFwiLFxuICBcImxpbmtcIjogXCJjaGVjay1jYW5jZWxcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJjaGVja0lEXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImhhc2gyNTZcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgSUQgb2YgdGhlIENoZWNrIGxlZGdlciBvYmplY3QgdG8gY2FuY2VsLCBhcyBhIDY0LWNoYXJhY3RlciBoZXhhZGVjaW1hbCBzdHJpbmcuXCJcbiAgICB9LFxuICAgIFwibWVtb3NcIjoge1wiJHJlZlwiOiBcIm1lbW9zXCJ9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogW1wiY2hlY2tJRFwiXSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcImNoZWNrQ2FzaFwiLFxuICBcImxpbmtcIjogXCJjaGVjay1jYXNoXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiY2hlY2tJRFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJoYXNoMjU2XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIElEIG9mIHRoZSBDaGVjayBsZWRnZXIgb2JqZWN0IHRvIGNhc2gsIGFzIGEgNjQtY2hhcmFjdGVyIGhleGFkZWNpbWFsIHN0cmluZy5cIlxuICAgIH0sXG4gICAgXCJhbW91bnRcIjoge1xuICAgICAgXCIkcmVmXCI6IFwibGF4QW1vdW50XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUmVkZWVtIHRoZSBDaGVjayBmb3IgZXhhY3RseSB0aGlzIGFtb3VudCwgaWYgcG9zc2libGUuIFRoZSBjdXJyZW5jeSBtdXN0IG1hdGNoIHRoYXQgb2YgdGhlIHNlbmRNYXggb2YgdGhlIGNvcnJlc3BvbmRpbmcgQ2hlY2tDcmVhdGUgdHJhbnNhY3Rpb24uIFlvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIHRoaXMgZmllbGQgb3IgZGVsaXZlck1pbi5cIlxuICAgIH0sXG4gICAgXCJkZWxpdmVyTWluXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImxheEFtb3VudFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlJlZGVlbSB0aGUgQ2hlY2sgZm9yIGF0IGxlYXN0IHRoaXMgYW1vdW50IGFuZCBmb3IgYXMgbXVjaCBhcyBwb3NzaWJsZS4gVGhlIGN1cnJlbmN5IG11c3QgbWF0Y2ggdGhhdCBvZiB0aGUgc2VuZE1heCBvZiB0aGUgY29ycmVzcG9uZGluZyBDaGVja0NyZWF0ZSB0cmFuc2FjdGlvbi4gWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgdGhpcyBmaWVsZCBvciBhbW91bnQuXCJcbiAgICB9LFxuICAgIFwibWVtb3NcIjoge1wiJHJlZlwiOiBcIm1lbW9zXCJ9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogW1wiY2hlY2tJRFwiXSxcbiAgXCJvbmVPZlwiOiBbXG4gICAge1wicmVxdWlyZWRcIjogW1wiYW1vdW50XCJdfSxcbiAgICB7XCJyZXF1aXJlZFwiOiBbXCJkZWxpdmVyTWluXCJdfVxuICBdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiY2hlY2tDcmVhdGVcIixcbiAgXCJsaW5rXCI6IFwiY2hlY2stY3JlYXRlXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiZGVzdGluYXRpb25cIjoge1xuICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBjYW4gY2FzaCB0aGUgY2hlY2suXCJcbiAgICB9LFxuICAgIFwic2VuZE1heFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJsYXhBbW91bnRcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbW91bnQgb2Ygc291cmNlIGN1cnJlbmN5IHRoZSBjaGVjayBpcyBhbGxvd2VkIHRvIGRlYml0IHRoZSBzZW5kZXIsIGluY2x1ZGluZyB0cmFuc2ZlciBmZWVzIG9uIG5vbi1YUlAgY3VycmVuY2llcy5cIlxuICAgIH0sXG4gICAgXCJkZXN0aW5hdGlvblRhZ1wiOiB7XG4gICAgICBcIiRyZWZcIjogXCJ0YWdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJEZXN0aW5hdGlvbiB0YWcgdGhhdCBpZGVudGlmaWVzIHRoZSByZWFzb24gZm9yIHRoZSBjaGVjaywgb3IgYSBob3N0ZWQgcmVjaXBpZW50IHRvIHBheS5cIlxuICAgIH0sXG4gICAgXCJleHBpcmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJkYXRlLXRpbWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaW1lIGFmdGVyIHdoaWNoIHRoZSBjaGVjayBpcyBubyBsb25nZXIgdmFsaWQuXCJcbiAgICB9LFxuICAgIFwiaW52b2ljZUlEXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImhhc2gyNTZcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCIyNTYtYml0IGhhc2gsIGFzIGEgNjQtY2hhcmFjdGVyIGhleGFkZWNpbWFsIHN0cmluZywgcmVwcmVzZW50aW5nIGEgc3BlY2lmaWMgcmVhc29uIG9yIGlkZW50aWZpZXIgZm9yIHRoaXMgY2hlY2suXCJcbiAgICB9LFxuICAgIFwibWVtb3NcIjoge1wiJHJlZlwiOiBcIm1lbW9zXCJ9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogW1wiZGVzdGluYXRpb25cIiwgXCJzZW5kTWF4XCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiZGVwb3NpdFByZWF1dGhcIixcbiAgXCJsaW5rXCI6IFwiZGVwb3NpdC1wcmVhdXRoXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYXV0aG9yaXplXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgY2FuIGNhc2ggdGhlIGNoZWNrLlwiXG4gICAgfSxcbiAgICBcInVuYXV0aG9yaXplXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgY2FuIGNhc2ggdGhlIGNoZWNrLlwiXG4gICAgfSxcbiAgICBcIm1lbW9zXCI6IHtcIiRyZWZcIjogXCJtZW1vc1wifVxuICB9LFxuICBcIm9uZU9mXCI6IFtcbiAgICB7XCJyZXF1aXJlZFwiOiBbXCJhdXRob3JpemVcIl19LFxuICAgIHtcInJlcXVpcmVkXCI6IFtcInVuYXV0aG9yaXplXCJdfVxuICBdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiZXNjcm93Q2FuY2VsbGF0aW9uXCIsXG4gIFwibGlua1wiOiBcImVzY3Jvdy1jYW5jZWxsYXRpb25cIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJtZW1vc1wiOiB7XCIkcmVmXCI6IFwibWVtb3NcIn0sXG4gICAgXCJvd25lclwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIG93bmVyIG9mIHRoZSBlc2Nyb3cgdG8gY2FuY2VsLlwiXG4gICAgfSxcbiAgICBcImVzY3Jvd1NlcXVlbmNlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInNlcXVlbmNlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIFthY2NvdW50IHNlcXVlbmNlIG51bWJlcl0oI2FjY291bnQtc2VxdWVuY2UtbnVtYmVyKSBvZiB0aGUgW0VzY3JvdyBDcmVhdGlvbl0oI2VzY3Jvdy1jcmVhdGlvbikgdHJhbnNhY3Rpb24gZm9yIHRoZSBlc2Nyb3cgdG8gY2FuY2VsLlwiXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcIm93bmVyXCIsIFwiZXNjcm93U2VxdWVuY2VcIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJlc2Nyb3dDcmVhdGlvblwiLFxuICBcImxpbmtcIjogXCJlc2Nyb3ctY3JlYXRpb25cIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhbW91bnRcIjoge1xuICAgICAgXCIkcmVmXCI6IFwidmFsdWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbW91bnQgb2YgWFJQIGZvciBzZW5kZXIgdG8gZXNjcm93LlwiXG4gICAgfSxcbiAgICBcImRlc3RpbmF0aW9uXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBZGRyZXNzIHRvIHJlY2VpdmUgZXNjcm93ZWQgWFJQLlwiXG4gICAgfSxcbiAgICBcIm1lbW9zXCI6IHtcIiRyZWZcIjogXCJtZW1vc1wifSxcbiAgICBcImNvbmRpdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIGhleCB2YWx1ZSByZXByZXNlbnRpbmcgYSBbUFJFSU1BR0UtU0hBLTI1NiBjcnlwdG8tY29uZGl0aW9uXShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtdGhvbWFzLWNyeXB0by1jb25kaXRpb25zLTAyI3NlY3Rpb24tOC4xKS4gSWYgcHJlc2VudCwgYGZ1bGZpbGxtZW50YCBpcyByZXF1aXJlZCB1cG9uIGV4ZWN1dGlvbi5cIixcbiAgICAgIFwicGF0dGVyblwiOiBcIl5bQS1GMC05XXswLDI1Nn0kXCJcbiAgICB9LFxuICAgIFwiYWxsb3dDYW5jZWxBZnRlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgcHJlc2VudCwgdGhlIGVzY3JvdyBtYXkgYmUgY2FuY2VsbGVkIGFmdGVyIHRoaXMgdGltZS5cIlxuICAgIH0sXG4gICAgXCJhbGxvd0V4ZWN1dGVBZnRlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgcHJlc2VudCwgdGhlIGVzY3JvdyBjYW4gbm90IGJlIGV4ZWN1dGVkIGJlZm9yZSB0aGlzIHRpbWUuXCJcbiAgICB9LFxuICAgIFwic291cmNlVGFnXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInRhZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlNvdXJjZSB0YWcuXCJcbiAgICB9LFxuICAgIFwiZGVzdGluYXRpb25UYWdcIjoge1xuICAgICAgXCIkcmVmXCI6IFwidGFnXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGVzdGluYXRpb24gdGFnLlwiXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImFtb3VudFwiLCBcImRlc3RpbmF0aW9uXCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiZXNjcm93RXhlY3V0aW9uXCIsXG4gIFwibGlua1wiOiBcImVzY3Jvdy1leGVjdXRpb25cIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJtZW1vc1wiOiB7XCIkcmVmXCI6IFwibWVtb3NcIn0sXG4gICAgXCJvd25lclwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJhZGRyZXNzXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFkZHJlc3Mgb2YgdGhlIG93bmVyIG9mIHRoZSBlc2Nyb3cgdG8gZXhlY3V0ZS5cIlxuICAgIH0sXG4gICAgXCJlc2Nyb3dTZXF1ZW5jZVwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJzZXF1ZW5jZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBbYWNjb3VudCBzZXF1ZW5jZSBudW1iZXJdKCNhY2NvdW50LXNlcXVlbmNlLW51bWJlcikgb2YgdGhlIFtFc2Nyb3cgQ3JlYXRpb25dKCNlc2Nyb3ctY3JlYXRpb24pIHRyYW5zYWN0aW9uIGZvciB0aGUgZXNjcm93IHRvIGV4ZWN1dGUuXCJcbiAgICB9LFxuICAgIFwiY29uZGl0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkEgaGV4IHZhbHVlIHJlcHJlc2VudGluZyBhIFtQUkVJTUFHRS1TSEEtMjU2IGNyeXB0by1jb25kaXRpb25dKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC10aG9tYXMtY3J5cHRvLWNvbmRpdGlvbnMtMDIjc2VjdGlvbi04LjEpLiBUaGlzIG11c3QgbWF0Y2ggdGhlIG9yaWdpbmFsIGBjb25kaXRpb25gIGZyb20gdGhlIGVzY3JvdyBjcmVhdGlvbiB0cmFuc2FjdGlvbi5cIixcbiAgICAgIFwicGF0dGVyblwiOiBcIl5bQS1GMC05XXswLDI1Nn0kXCJcbiAgICB9LFxuICAgIFwiZnVsZmlsbG1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQSBoZXggdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBbUFJFSU1BR0UtU0hBLTI1NiBjcnlwdG8tY29uZGl0aW9uXShodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtdGhvbWFzLWNyeXB0by1jb25kaXRpb25zLTAyI3NlY3Rpb24tOC4xKSBmdWxmaWxsbWVudCBmb3IgYGNvbmRpdGlvbmAuXCIsXG4gICAgICBcInBhdHRlcm5cIjogXCJeW0EtRjAtOV0rJFwiXG4gICAgfVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcIm93bmVyXCIsIFwiZXNjcm93U2VxdWVuY2VcIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJnZXRQYXltZW50XCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIHNwZWNpZmljYXRpb24gb2YgYSBwYXltZW50IGluIGEgcmVzcG9uc2UgZm9yIGdldFRyYW5zYWN0aW9uIG9yIGdldFRyYW5zYWN0aW9ucy5cIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJzb3VyY2VcIjoge1xuICAgICAgXCIkcmVmXCI6IFwic291cmNlQWRqdXN0bWVudFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBzb3VyY2Ugb2YgdGhlIGZ1bmRzIHRvIGJlIHNlbnQuXCJcbiAgICB9LFxuICAgIFwiZGVzdGluYXRpb25cIjoge1xuICAgICAgXCIkcmVmXCI6IFwiZGVzdGluYXRpb25BZGRyZXNzVGFnXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGRlc3RpbmF0aW9uIG9mIHRoZSBmdW5kcyB0byBiZSBzZW50LiBTaW5jZSB0aGlzIGlzIGEgcGF5bWVudCByZXNwb25zZSwgdGhlIGFtb3VudCBpcyBub3Qgc2hvd24gaGVyZS4gRm9yIHRoZSBhbW91bnQgdGhhdCB0aGUgdHJhbnNhY3Rpb24gZGVsaXZlcmVkLCBzZWUgYG91dGNvbWUuZGVsaXZlcmVkQW1vdW50YC5cIlxuICAgIH0sXG4gICAgXCJwYXRoc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgcGF0aHMgb2YgdHJ1c3RsaW5lcyBhbmQgb3JkZXJzIHRvIHVzZSBpbiBleGVjdXRpbmcgdGhlIHBheW1lbnQuXCJcbiAgICB9LFxuICAgIFwibWVtb3NcIjoge1wiJHJlZlwiOiBcIm1lbW9zXCJ9LFxuICAgIFwiaW52b2ljZUlEXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIDI1Ni1iaXQgaGFzaCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGEgcGFydGljdWxhciBwYXltZW50LlwiLFxuICAgICAgXCIkcmVmXCI6IFwiaGFzaDI1NlwiXG4gICAgfSxcbiAgICBcImFsbG93UGFydGlhbFBheW1lbnRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHRydWUsIHRoaXMgcGF5bWVudCBjYW4gZGVsaXZlciBsZXNzIHRoYW4gdGhlIGZ1bGwgYW1vdW50LlwiLFxuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgfSxcbiAgICBcIm5vRGlyZWN0UmlwcGxlXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiB0cnVlIGFuZCBwYXRocyBhcmUgc3BlY2lmaWVkLCB0aGUgc2VuZGVyIHdvdWxkIGxpa2UgdGhlIFhSUCBMZWRnZXIgdG8gZGlzcmVnYXJkIGFueSBkaXJlY3QgcGF0aHMgZnJvbSB0aGUgc291cmNlIGFjY291bnQgdG8gdGhlIGRlc3RpbmF0aW9uIGFjY291bnQuIFRoaXMgbWF5IGJlIHVzZWQgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgYW4gYXJiaXRyYWdlIG9wcG9ydHVuaXR5IG9yIGJ5IGdhdGV3YXlzIHdpc2hpbmcgdG8gaXNzdWUgYmFsYW5jZXMgZnJvbSBhIGhvdCB3YWxsZXQgdG8gYSB1c2VyIHdobyBoYXMgbWlzdGFrZW5seSBzZXQgYSB0cnVzdGxpbmUgZGlyZWN0bHkgdG8gdGhlIGhvdCB3YWxsZXQuXCIsXG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICB9LFxuICAgIFwibGltaXRRdWFsaXR5XCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJPbmx5IHRha2UgcGF0aHMgd2hlcmUgYWxsIHRoZSBjb252ZXJzaW9ucyBoYXZlIGFuIGlucHV0Om91dHB1dCByYXRpbyB0aGF0IGlzIGVxdWFsIG9yIGJldHRlciB0aGFuIHRoZSByYXRpbyBvZiBkZXN0aW5hdGlvbi5hbW91bnQ6c291cmNlLm1heEFtb3VudC5cIixcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgIH1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJzb3VyY2VcIiwgXCJkZXN0aW5hdGlvblwiXSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcIm9yZGVyQ2FuY2VsbGF0aW9uXCIsXG4gIFwibGlua1wiOiBcIm9yZGVyLWNhbmNlbGxhdGlvblwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIm9yZGVyU2VxdWVuY2VcIjoge1xuICAgICAgXCIkcmVmXCI6IFwic2VxdWVuY2VcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgW2FjY291bnQgc2VxdWVuY2UgbnVtYmVyXSgjYWNjb3VudC1zZXF1ZW5jZS1udW1iZXIpIG9mIHRoZSBvcmRlciB0byBjYW5jZWwuXCJcbiAgICB9LFxuICAgIFwibWVtb3NcIjoge1wiJHJlZlwiOiBcIm1lbW9zXCJ9XG4gIH0sXG4gIFwicmVxdWlyZWRcIjogW1wib3JkZXJTZXF1ZW5jZVwiXSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcIm9yZGVyXCIsXG4gIFwibGlua1wiOiBcIm9yZGVyXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiZGlyZWN0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJlbnVtXCI6IFtcImJ1eVwiLCBcInNlbGxcIl0sXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiRXF1YWwgdG8gXFxcImJ1eVxcXCIgZm9yIGJ1eSBvcmRlcnMgYW5kIFxcXCJzZWxsXFxcIiBmb3Igc2VsbCBvcmRlcnMuXCJcbiAgICB9LFxuICAgIFwicXVhbnRpdHlcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiYW1vdW50XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGFtb3VudCBvZiBjdXJyZW5jeSB0byBidXkgb3Igc2VsbC5cIlxuICAgIH0sXG4gICAgXCJ0b3RhbFByaWNlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFtb3VudFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSB0b3RhbCBwcmljZSB0byBiZSBwYWlkIGZvciB0aGUgYHF1YW50aXR5YCB0byBiZSBib3VnaHQgb3Igc29sZC5cIlxuICAgIH0sXG4gICAgXCJpbW1lZGlhdGVPckNhbmNlbFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVHJlYXQgdGhlIG9mZmVyIGFzIGFuIFtJbW1lZGlhdGUgb3IgQ2FuY2VsIG9yZGVyXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ltbWVkaWF0ZV9vcl9jYW5jZWwpLiBJZiBlbmFibGVkLCBkbyBub3QgY3JlYXRlIGFuIG9iamVjdCBpbiB0aGUgbGVkZ2VyIHRoYXQgY2FuIGJlIG1hdGNoZWQgbGF0ZXI6IGluc3RlYWQsIG9ubHkgZXhlY3V0ZSBhcyBtdWNoIGFzIGNhbiBiZSBmdWxmaWxsZWQgaW1tZWRpYXRlbHkuIFRoaXMgY2Fubm90IGJlIHVzZWQgd2l0aCBgZmlsbE9yS2lsbGAuXCJcbiAgICB9LFxuICAgIFwiZmlsbE9yS2lsbFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVHJlYXQgdGhlIG9mZmVyIGFzIGEgW0ZpbGwgb3IgS2lsbCBvcmRlcl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaWxsX29yX2tpbGwpLiBPbmx5IGF0dGVtcHQgdG8gbWF0Y2ggZXhpc3Rpbmcgb2ZmZXJzIGluIHRoZSBsZWRnZXIsIGFuZCBvbmx5IGRvIHNvIGlmIHRoZSBlbnRpcmUgcXVhbnRpdHkgY2FuIGJlIGV4Y2hhbmdlZC4gVGhpcyBjYW5ub3QgYmUgdXNlZCB3aXRoIGBpbW1lZGlhdGVPckNhbmNlbGAuXCJcbiAgICB9LFxuICAgIFwicGFzc2l2ZVwiOiB7XG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgZW5hYmxlZCwgdGhlIG9mZmVyIGRvZXMgbm90IGNvbnN1bWUgb2ZmZXJzIHRoYXQgZXhhY3RseSBtYXRjaCBpdCwgYW5kIGluc3RlYWQgYmVjb21lcyBhbiBPZmZlciBub2RlIGluIHRoZSBsZWRnZXIuIEl0IHN0aWxsIGNvbnN1bWVzIG9mZmVycyB0aGF0IGNyb3NzIGl0LlwiLFxuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgfSxcbiAgICBcImV4cGlyYXRpb25UaW1lXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJkYXRlLXRpbWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaW1lIGFmdGVyIHdoaWNoIHRoZSBvZmZlciBpcyBubyBsb25nZXIgYWN0aXZlLCBhcyBhbiBbSVNPIDg2MDEgZGF0ZS10aW1lXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fODYwMSkuXCJcbiAgICB9LFxuICAgIFwib3JkZXJUb1JlcGxhY2VcIjoge1xuICAgICAgXCIkcmVmXCI6IFwic2VxdWVuY2VcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgW2FjY291bnQgc2VxdWVuY2UgbnVtYmVyXSgjYWNjb3VudC1zZXF1ZW5jZS1udW1iZXIpIG9mIGFuIG9yZGVyIHRvIGNhbmNlbCBiZWZvcmUgdGhlIG5ldyBvcmRlciBpcyBjcmVhdGVkLCBlZmZlY3RpdmVseSByZXBsYWNpbmcgdGhlIG9sZCBvcmRlci5cIlxuICAgIH0sXG4gICAgXCJtZW1vc1wiOiB7XCIkcmVmXCI6IFwibWVtb3NcIn1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJkaXJlY3Rpb25cIiwgXCJxdWFudGl0eVwiLCBcInRvdGFsUHJpY2VcIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2UsXG4gIFwibm90XCI6IHtcbiAgICBcImRlc2NyaXB0aW9uXCI6IFwiaW1tZWRpYXRlT3JDYW5jZWwgYW5kIGZpbGxPcktpbGwgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZVwiLFxuICAgIFwicmVxdWlyZWRcIjogW1wiaW1tZWRpYXRlT3JDYW5jZWxcIiwgXCJmaWxsT3JLaWxsXCJdXG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwYXltZW50Q2hhbm5lbENsYWltXCIsXG4gIFwibGlua1wiOiBcInBheW1lbnQtY2hhbm5lbC1jbGFpbVwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImNoYW5uZWxcIjoge1xuICAgICAgXCIkcmVmXCI6IFwiaGFzaDI1NlwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIjI1Ni1iaXQgaGV4YWRlY2ltYWwgY2hhbm5lbCBpZGVudGlmaWVyLlwiXG4gICAgfSxcbiAgICBcImFtb3VudFwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJ2YWx1ZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFtb3VudCBvZiBYUlAgYXV0aG9yaXplZCBieSB0aGlzIHNpZ25hdHVyZS5cIlxuICAgIH0sXG4gICAgXCJiYWxhbmNlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInZhbHVlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVG90YWwgWFJQIGJhbGFuY2UgZGVsaXZlcmVkIGJ5IHRoaXMgY2hhbm5lbCBhZnRlciBjbGFpbSBpcyBwcm9jZXNzZWQuXCJcbiAgICB9LFxuICAgIFwic2lnbmF0dXJlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInNpZ25hdHVyZVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlNpZ25lZCBjbGFpbSBhdXRob3JpemluZyB3aXRoZHJhd2FsIG9mIFhSUCBmcm9tIHRoZSBjaGFubmVsLiAoUmVxdWlyZWQgZXhjZXB0IGZyb20gdGhlIGNoYW5uZWwncyBzb3VyY2UgYWRkcmVzcy4pXCJcbiAgICB9LFxuICAgIFwicHVibGljS2V5XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInB1YmxpY0tleVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlB1YmxpYyBrZXkgb2YgdGhlIGNoYW5uZWwuIChGb3IgdmVyaWZ5aW5nIHRoZSBzaWduYXR1cmUuKVwiXG4gICAgfSxcbiAgICBcInJlbmV3XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJDbGVhciB0aGUgY2hhbm5lbCdzIGV4cGlyYXRpb24gdGltZS5cIlxuICAgIH0sXG4gICAgXCJjbG9zZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUmVxdWVzdCB0byBjbG9zZSB0aGUgY2hhbm5lbC4gSWYgdGhlIGNoYW5uZWwgaGFzIG5vIFhSUCByZW1haW5pbmcgb3IgdGhlIGRlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWVzdHMgaXQsIGNsb3NlcyB0aGUgY2hhbm5lbCBpbW1lZGlhdGVseSAocmV0dXJuaW5nIHVuY2xhaW1lZCBYUlAgdG8gdGhlIHNvdXJjZSBhZGRyZXNzKS4gT3RoZXJ3aXNlLCBzZXRzIHRoZSBjaGFubmVsIHRvIGV4cGlyZSBhZnRlciBzZXR0bGVEZWxheSBzZWNvbmRzIGhhdmUgcGFzc2VkLlwiXG4gICAgfSxcbiAgICBcIm1lbW9zXCI6IHtcIiRyZWZcIjogXCJtZW1vc1wifVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImNoYW5uZWxcIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwYXltZW50Q2hhbm5lbENyZWF0ZVwiLFxuICBcImxpbmtcIjogXCJwYXltZW50LWNoYW5uZWwtY3JlYXRlXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiYW1vdW50XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInZhbHVlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiQW1vdW50IG9mIFhSUCBmb3Igc2VuZGVyIHRvIHNldCBhc2lkZSBpbiB0aGlzIGNoYW5uZWwuXCJcbiAgICB9LFxuICAgIFwiZGVzdGluYXRpb25cIjoge1xuICAgICAgXCIkcmVmXCI6IFwiYWRkcmVzc1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFkZHJlc3MgdG8gcmVjZWl2ZSBYUlAgY2xhaW1zIGFnYWluc3QgdGhpcyBjaGFubmVsLlwiXG4gICAgfSxcbiAgICBcInNldHRsZURlbGF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIkFtb3VudCBvZiBzZWNvbmRzIHRoZSBzb3VyY2UgYWRkcmVzcyBtdXN0IHdhaXQgYmVmb3JlIGNsb3NpbmcgdGhlIGNoYW5uZWwgaWYgaXQgaGFzIHVuY2xhaW1lZCBYUlAuXCJcbiAgICB9LFxuICAgIFwicHVibGljS2V5XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInB1YmxpY0tleVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlB1YmxpYyBrZXkgb2YgdGhlIGtleSBwYWlyIHRoZSBzb3VyY2UgbWF5IHVzZSB0byBzaWduIGNsYWltcyBhZ2FpbnN0IHRoaXMgY2hhbm5lbC5cIlxuICAgIH0sXG4gICAgXCJjYW5jZWxBZnRlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwiZGF0ZS10aW1lXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGltZSB3aGVuIHRoaXMgY2hhbm5lbCBleHBpcmVzLiBUaGlzIGV4cGlyYXRpb24gY2Fubm90IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpbmcgdGhlIGNoYW5uZWwuXCJcbiAgICB9LFxuICAgIFwic291cmNlVGFnXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInRhZ1wiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlNvdXJjZSB0YWcuXCJcbiAgICB9LFxuICAgIFwiZGVzdGluYXRpb25UYWdcIjoge1xuICAgICAgXCIkcmVmXCI6IFwidGFnXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiRGVzdGluYXRpb24gdGFnLlwiXG4gICAgfSxcbiAgICBcIm1lbW9zXCI6IHtcIiRyZWZcIjogXCJtZW1vc1wifVxuICB9LFxuICBcInJlcXVpcmVkXCI6IFtcImFtb3VudFwiLCBcImRlc3RpbmF0aW9uXCIsIFwic2V0dGxlRGVsYXlcIiwgXCJwdWJsaWNLZXlcIl0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJwYXltZW50Q2hhbm5lbEZ1bmRcIixcbiAgXCJsaW5rXCI6IFwicGF5bWVudC1jaGFubmVsLWZ1bmRcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCJhbW91bnRcIjoge1xuICAgICAgXCIkcmVmXCI6IFwidmFsdWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBbW91bnQgb2YgWFJQIHRvIGZ1bmQgdGhlIGNoYW5uZWwgd2l0aC5cIlxuICAgIH0sXG4gICAgXCJjaGFubmVsXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImhhc2gyNTZcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCIyNTYtYml0IGhleGFkZWNpbWFsIGNoYW5uZWwgaWRlbnRpZmllci5cIlxuICAgIH0sXG4gICAgXCJleHBpcmF0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJkYXRlLXRpbWVcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJOZXcgZXhwaXJhdGlvbiBmb3IgdGhpcyBjaGFubmVsLiAoVGhpcyBkb2VzIG5vdCBjaGFuZ2UgdGhlIGNhbmNlbEFmdGVyIGV4cGlyYXRpb24sIGlmIHRoZSBjaGFubmVsIGhhcyBvbmUuKSBDYW5ub3QgbW92ZSB0aGUgZXhwaXJhdGlvbiBzb29uZXIgdGhhbiBzZXR0bGVEZWxheSBzZWNvbmRzIGZyb20gdGltZSBvZiB0aGUgcmVxdWVzdC5cIlxuICAgIH0sXG4gICAgXCJtZW1vc1wiOiB7XCIkcmVmXCI6IFwibWVtb3NcIn1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJhbW91bnRcIiwgXCJjaGFubmVsXCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwicGF5bWVudFwiLFxuICBcImxpbmtcIjogXCJwYXltZW50XCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwic291cmNlXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInNvdXJjZUFkanVzdG1lbnRcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgc291cmNlIG9mIHRoZSBmdW5kcyB0byBiZSBzZW50LlwiXG4gICAgfSxcbiAgICBcImRlc3RpbmF0aW9uXCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImRlc3RpbmF0aW9uQWRqdXN0bWVudFwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlRoZSBkZXN0aW5hdGlvbiBvZiB0aGUgZnVuZHMgdG8gYmUgc2VudC5cIlxuICAgIH0sXG4gICAgXCJwYXRoc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgcGF0aHMgb2YgdHJ1c3RsaW5lcyBhbmQgb3JkZXJzIHRvIHVzZSBpbiBleGVjdXRpbmcgdGhlIHBheW1lbnQuXCJcbiAgICB9LFxuICAgIFwibWVtb3NcIjoge1wiJHJlZlwiOiBcIm1lbW9zXCJ9LFxuICAgIFwiaW52b2ljZUlEXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIDI1Ni1iaXQgaGFzaCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGEgcGFydGljdWxhciBwYXltZW50LlwiLFxuICAgICAgXCIkcmVmXCI6IFwiaGFzaDI1NlwiXG4gICAgfSxcbiAgICBcImFsbG93UGFydGlhbFBheW1lbnRcIjoge1xuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIklmIHRydWUsIHRoaXMgcGF5bWVudCBjYW4gZGVsaXZlciBsZXNzIHRoYW4gdGhlIGZ1bGwgYW1vdW50LlwiLFxuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiXG4gICAgfSxcbiAgICBcIm5vRGlyZWN0UmlwcGxlXCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiB0cnVlIGFuZCBwYXRocyBhcmUgc3BlY2lmaWVkLCB0aGUgc2VuZGVyIHdvdWxkIGxpa2UgdGhlIFhSUCBMZWRnZXIgdG8gZGlzcmVnYXJkIGFueSBkaXJlY3QgcGF0aHMgZnJvbSB0aGUgc291cmNlIGFjY291bnQgdG8gdGhlIGRlc3RpbmF0aW9uIGFjY291bnQuIFRoaXMgbWF5IGJlIHVzZWQgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgYW4gYXJiaXRyYWdlIG9wcG9ydHVuaXR5IG9yIGJ5IGdhdGV3YXlzIHdpc2hpbmcgdG8gaXNzdWUgYmFsYW5jZXMgZnJvbSBhIGhvdCB3YWxsZXQgdG8gYSB1c2VyIHdobyBoYXMgbWlzdGFrZW5seSBzZXQgYSB0cnVzdGxpbmUgZGlyZWN0bHkgdG8gdGhlIGhvdCB3YWxsZXQuXCIsXG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCJcbiAgICB9LFxuICAgIFwibGltaXRRdWFsaXR5XCI6IHtcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJPbmx5IHRha2UgcGF0aHMgd2hlcmUgYWxsIHRoZSBjb252ZXJzaW9ucyBoYXZlIGFuIGlucHV0Om91dHB1dCByYXRpbyB0aGF0IGlzIGVxdWFsIG9yIGJldHRlciB0aGFuIHRoZSByYXRpbyBvZiBkZXN0aW5hdGlvbi5hbW91bnQ6c291cmNlLm1heEFtb3VudC5cIixcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIlxuICAgIH1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJzb3VyY2VcIiwgXCJkZXN0aW5hdGlvblwiXSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcInNldHRpbmdzXCIsXG4gIFwibGlua1wiOiBcInNldHRpbmdzXCIsXG4gIFwiJHJlZlwiOiBcInNldHRpbmdzUGx1c01lbW9zXCIsXG4gIFwib25lT2ZcIjogW1xuICAgIHtcbiAgICAgIFwicmVxdWlyZWRcIjogW1wibWVtb3NcIl0sXG4gICAgICBcIm1pblByb3BlcnRpZXNcIjogMixcbiAgICAgIFwibWF4UHJvcGVydGllc1wiOiAyXG4gICAgfSxcbiAgICB7XG4gICAgICBcIm5vdFwiOiB7XG4gICAgICAgIFwicmVxdWlyZWRcIjogW1wibWVtb3NcIl1cbiAgICAgIH0sXG4gICAgICBcIm1pblByb3BlcnRpZXNcIjogMSxcbiAgICAgIFwibWF4UHJvcGVydGllc1wiOiAxXG4gICAgfVxuICBdXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwidHJ1c3RsaW5lXCIsXG4gIFwibGlua1wiOiBcInRydXN0bGluZVwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcImN1cnJlbmN5XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImN1cnJlbmN5XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIGN1cnJlbmN5IHRoaXMgdHJ1c3RsaW5lIGFwcGxpZXMgdG8uXCJcbiAgICB9LFxuICAgIFwiY291bnRlcnBhcnR5XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcImFkZHJlc3NcIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0aGlzIHRydXN0bGluZSBleHRlbmRzIHRydXN0IHRvLlwiXG4gICAgfSxcbiAgICBcImxpbWl0XCI6IHtcbiAgICAgIFwiJHJlZlwiOiBcInZhbHVlXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiVGhlIG1heGltdW0gYW1vdW50IHRoYXQgdGhlIG93bmVyIG9mIHRoZSB0cnVzdGxpbmUgY2FuIGJlIG93ZWQgdGhyb3VnaCB0aGUgdHJ1c3RsaW5lLlwiXG4gICAgfSxcbiAgICBcInF1YWxpdHlJblwiOiB7XG4gICAgICBcIiRyZWZcIjogXCJxdWFsaXR5XCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSW5jb21pbmcgYmFsYW5jZXMgb24gdGhpcyB0cnVzdGxpbmUgYXJlIHZhbHVlZCBhdCB0aGlzIHJhdGlvLlwiXG4gICAgfSxcbiAgICBcInF1YWxpdHlPdXRcIjoge1xuICAgICAgXCIkcmVmXCI6IFwicXVhbGl0eVwiLFxuICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIk91dGdvaW5nIGJhbGFuY2VzIG9uIHRoaXMgdHJ1c3RsaW5lIGFyZSB2YWx1ZWQgYXQgdGhpcyByYXRpby5cIlxuICAgIH0sXG4gICAgXCJyaXBwbGluZ0Rpc2FibGVkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiB0cnVlLCBwYXltZW50cyBjYW5ub3QgcmlwcGxlIHRocm91Z2ggdGhpcyB0cnVzdGxpbmUuXCJcbiAgICB9LFxuICAgIFwiYXV0aG9yaXplZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlc2NyaXB0aW9uXCI6IFwiSWYgdHJ1ZSwgYXV0aG9yaXplIHRoZSBjb3VudGVycGFydHkgdG8gaG9sZCBpc3N1YW5jZXMgZnJvbSB0aGlzIGFjY291bnQuXCJcbiAgICB9LFxuICAgIFwiZnJvemVuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJJZiB0cnVlLCB0aGUgdHJ1c3RsaW5lIGlzIGZyb3plbiwgd2hpY2ggbWVhbnMgdGhhdCBmdW5kcyBjYW4gb25seSBiZSBzZW50IHRvIHRoZSBvd25lci5cIlxuICAgIH0sXG4gICAgXCJtZW1vc1wiOiB7XCIkcmVmXCI6IFwibWVtb3NcIn1cbiAgfSxcbiAgXCJyZXF1aXJlZFwiOiBbXCJjdXJyZW5jeVwiLCBcImNvdW50ZXJwYXJ0eVwiLCBcImxpbWl0XCJdLFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRGZWUgPSBleHBvcnRzLmdldFNlcnZlckluZm8gPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpKTtcbmZ1bmN0aW9uIHJlbmFtZUtleXMob2JqZWN0LCBtYXBwaW5nKSB7XG4gICAgT2JqZWN0LmVudHJpZXMobWFwcGluZykuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IFtmcm9tLCB0b10gPSBlbnRyeTtcbiAgICAgICAgb2JqZWN0W3RvXSA9IG9iamVjdFtmcm9tXTtcbiAgICAgICAgZGVsZXRlIG9iamVjdFtmcm9tXTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFNlcnZlckluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCgnc2VydmVyX2luZm8nKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCBpbmZvID0gdXRpbHNfMS5jb252ZXJ0S2V5c0Zyb21TbmFrZUNhc2VUb0NhbWVsQ2FzZShyZXNwb25zZS5pbmZvKTtcbiAgICAgICAgcmVuYW1lS2V5cyhpbmZvLCB7IGhvc3RpZDogJ2hvc3RJRCcgfSk7XG4gICAgICAgIGlmIChpbmZvLnZhbGlkYXRlZExlZGdlcikge1xuICAgICAgICAgICAgcmVuYW1lS2V5cyhpbmZvLnZhbGlkYXRlZExlZGdlciwge1xuICAgICAgICAgICAgICAgIGJhc2VGZWVYcnA6ICdiYXNlRmVlWFJQJyxcbiAgICAgICAgICAgICAgICByZXNlcnZlQmFzZVhycDogJ3Jlc2VydmVCYXNlWFJQJyxcbiAgICAgICAgICAgICAgICByZXNlcnZlSW5jWHJwOiAncmVzZXJ2ZUluY3JlbWVudFhSUCcsXG4gICAgICAgICAgICAgICAgc2VxOiAnbGVkZ2VyVmVyc2lvbidcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5mby52YWxpZGF0ZWRMZWRnZXIuYmFzZUZlZVhSUCA9IGluZm8udmFsaWRhdGVkTGVkZ2VyLmJhc2VGZWVYUlAudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGluZm8udmFsaWRhdGVkTGVkZ2VyLnJlc2VydmVCYXNlWFJQID0gaW5mby52YWxpZGF0ZWRMZWRnZXIucmVzZXJ2ZUJhc2VYUlAudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGluZm8udmFsaWRhdGVkTGVkZ2VyLnJlc2VydmVJbmNyZW1lbnRYUlAgPSBpbmZvLnZhbGlkYXRlZExlZGdlci5yZXNlcnZlSW5jcmVtZW50WFJQLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgfSk7XG59XG5leHBvcnRzLmdldFNlcnZlckluZm8gPSBnZXRTZXJ2ZXJJbmZvO1xuZnVuY3Rpb24gZ2V0RmVlKGN1c2hpb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoY3VzaGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBjdXNoaW9uID0gdGhpcy5fZmVlQ3VzaGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VzaGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBjdXNoaW9uID0gMS4yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlckluZm8gPSAoeWllbGQgdGhpcy5yZXF1ZXN0KCdzZXJ2ZXJfaW5mbycpKS5pbmZvO1xuICAgICAgICBjb25zdCBiYXNlRmVlWHJwID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoc2VydmVySW5mby52YWxpZGF0ZWRfbGVkZ2VyLmJhc2VfZmVlX3hycCk7XG4gICAgICAgIGlmIChzZXJ2ZXJJbmZvLmxvYWRfZmFjdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHNlcnZlckluZm8ubG9hZF9mYWN0b3IgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmZWUgPSBiYXNlRmVlWHJwLnRpbWVzKHNlcnZlckluZm8ubG9hZF9mYWN0b3IpLnRpbWVzKGN1c2hpb24pO1xuICAgICAgICBmZWUgPSBiaWdudW1iZXJfanNfMS5kZWZhdWx0Lm1pbihmZWUsIHRoaXMuX21heEZlZVhSUCk7XG4gICAgICAgIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChmZWUudG9GaXhlZCg2KSkudG9TdHJpbmcoMTApO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRGZWUgPSBnZXRGZWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXJpbmZvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50eEZsYWdJbmRpY2VzID0gZXhwb3J0cy50eEZsYWdzID0gdm9pZCAwO1xuY29uc3QgdHhGbGFncyA9IHtcbiAgICBVbml2ZXJzYWw6IHtcbiAgICAgICAgRnVsbHlDYW5vbmljYWxTaWc6IDB4ODAwMDAwMDBcbiAgICB9LFxuICAgIEFjY291bnRTZXQ6IHtcbiAgICAgICAgUmVxdWlyZURlc3RUYWc6IDB4MDAwMTAwMDAsXG4gICAgICAgIE9wdGlvbmFsRGVzdFRhZzogMHgwMDAyMDAwMCxcbiAgICAgICAgUmVxdWlyZUF1dGg6IDB4MDAwNDAwMDAsXG4gICAgICAgIE9wdGlvbmFsQXV0aDogMHgwMDA4MDAwMCxcbiAgICAgICAgRGlzYWxsb3dYUlA6IDB4MDAxMDAwMDAsXG4gICAgICAgIEFsbG93WFJQOiAweDAwMjAwMDAwXG4gICAgfSxcbiAgICBUcnVzdFNldDoge1xuICAgICAgICBTZXRBdXRoOiAweDAwMDEwMDAwLFxuICAgICAgICBOb1JpcHBsZTogMHgwMDAyMDAwMCxcbiAgICAgICAgU2V0Tm9SaXBwbGU6IDB4MDAwMjAwMDAsXG4gICAgICAgIENsZWFyTm9SaXBwbGU6IDB4MDAwNDAwMDAsXG4gICAgICAgIFNldEZyZWV6ZTogMHgwMDEwMDAwMCxcbiAgICAgICAgQ2xlYXJGcmVlemU6IDB4MDAyMDAwMDBcbiAgICB9LFxuICAgIE9mZmVyQ3JlYXRlOiB7XG4gICAgICAgIFBhc3NpdmU6IDB4MDAwMTAwMDAsXG4gICAgICAgIEltbWVkaWF0ZU9yQ2FuY2VsOiAweDAwMDIwMDAwLFxuICAgICAgICBGaWxsT3JLaWxsOiAweDAwMDQwMDAwLFxuICAgICAgICBTZWxsOiAweDAwMDgwMDAwXG4gICAgfSxcbiAgICBQYXltZW50OiB7XG4gICAgICAgIE5vUmlwcGxlRGlyZWN0OiAweDAwMDEwMDAwLFxuICAgICAgICBQYXJ0aWFsUGF5bWVudDogMHgwMDAyMDAwMCxcbiAgICAgICAgTGltaXRRdWFsaXR5OiAweDAwMDQwMDAwXG4gICAgfSxcbiAgICBQYXltZW50Q2hhbm5lbENsYWltOiB7XG4gICAgICAgIFJlbmV3OiAweDAwMDEwMDAwLFxuICAgICAgICBDbG9zZTogMHgwMDAyMDAwMFxuICAgIH1cbn07XG5leHBvcnRzLnR4RmxhZ3MgPSB0eEZsYWdzO1xuY29uc3QgdHhGbGFnSW5kaWNlcyA9IHtcbiAgICBBY2NvdW50U2V0OiB7XG4gICAgICAgIGFzZlJlcXVpcmVEZXN0OiAxLFxuICAgICAgICBhc2ZSZXF1aXJlQXV0aDogMixcbiAgICAgICAgYXNmRGlzYWxsb3dYUlA6IDMsXG4gICAgICAgIGFzZkRpc2FibGVNYXN0ZXI6IDQsXG4gICAgICAgIGFzZkFjY291bnRUeG5JRDogNSxcbiAgICAgICAgYXNmTm9GcmVlemU6IDYsXG4gICAgICAgIGFzZkdsb2JhbEZyZWV6ZTogNyxcbiAgICAgICAgYXNmRGVmYXVsdFJpcHBsZTogOCxcbiAgICAgICAgYXNmRGVwb3NpdEF1dGg6IDlcbiAgICB9XG59O1xuZXhwb3J0cy50eEZsYWdJbmRpY2VzID0gdHhGbGFnSW5kaWNlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR4ZmxhZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWRnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkU2VjcmV0ID0gZXhwb3J0cy5pc284NjAxVG9SaXBwbGVUaW1lID0gZXhwb3J0cy5yaXBwbGVUaW1lVG9JU084NjAxID0gZXhwb3J0cy5yZW1vdmVVbmRlZmluZWQgPSBleHBvcnRzLmNvbnZlcnRLZXlzRnJvbVNuYWtlQ2FzZVRvQ2FtZWxDYXNlID0gZXhwb3J0cy50b1JpcHBsZWRBbW91bnQgPSBleHBvcnRzLnhycFRvRHJvcHMgPSBleHBvcnRzLmRyb3BzVG9YcnAgPSB2b2lkIDA7XG5jb25zdCBfID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuY29uc3QgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG5jb25zdCByaXBwbGVfa2V5cGFpcnNfMSA9IHJlcXVpcmUoXCJyaXBwbGUta2V5cGFpcnNcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEgPSByZXF1aXJlKFwicmlwcGxlLWFkZHJlc3MtY29kZWNcIik7XG5mdW5jdGlvbiBpc1ZhbGlkU2VjcmV0KHNlY3JldCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJpcHBsZV9rZXlwYWlyc18xLmRlcml2ZUtleXBhaXIoc2VjcmV0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNWYWxpZFNlY3JldCA9IGlzVmFsaWRTZWNyZXQ7XG5mdW5jdGlvbiBkcm9wc1RvWHJwKGRyb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBkcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFkcm9wcy5tYXRjaCgvXi0/WzAtOV0qXFwuP1swLTldKiQvKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbGlkYXRpb25FcnJvcihgZHJvcHNUb1hycDogaW52YWxpZCB2YWx1ZSAnJHtkcm9wc30nLGAgK1xuICAgICAgICAgICAgICAgIGAgc2hvdWxkIGJlIGEgbnVtYmVyIG1hdGNoaW5nICheLT9bMC05XSpcXFxcLj9bMC05XSokKS5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkcm9wcyA9PT0gJy4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsaWRhdGlvbkVycm9yKGBkcm9wc1RvWHJwOiBpbnZhbGlkIHZhbHVlICcke2Ryb3BzfScsYCArXG4gICAgICAgICAgICAgICAgYCBzaG91bGQgYmUgYSBCaWdOdW1iZXIgb3Igc3RyaW5nLWVuY29kZWQgbnVtYmVyLmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyb3BzID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoZHJvcHMpLnRvU3RyaW5nKDEwKTtcbiAgICBpZiAoZHJvcHMuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsaWRhdGlvbkVycm9yKGBkcm9wc1RvWHJwOiB2YWx1ZSAnJHtkcm9wc30nIGhhc2AgKyBgIHRvbyBtYW55IGRlY2ltYWwgcGxhY2VzLmApO1xuICAgIH1cbiAgICBpZiAoIWRyb3BzLm1hdGNoKC9eLT9bMC05XSskLykpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbGlkYXRpb25FcnJvcihgZHJvcHNUb1hycDogZmFpbGVkIHNhbml0eSBjaGVjayAtYCArXG4gICAgICAgICAgICBgIHZhbHVlICcke2Ryb3BzfScsYCArXG4gICAgICAgICAgICBgIGRvZXMgbm90IG1hdGNoICheLT9bMC05XSskKS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KGRyb3BzKS5kaXZpZGVkQnkoMTAwMDAwMC4wKS50b1N0cmluZygxMCk7XG59XG5leHBvcnRzLmRyb3BzVG9YcnAgPSBkcm9wc1RvWHJwO1xuZnVuY3Rpb24geHJwVG9Ecm9wcyh4cnApIHtcbiAgICBpZiAodHlwZW9mIHhycCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCF4cnAubWF0Y2goL14tP1swLTldKlxcLj9bMC05XSokLykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoYHhycFRvRHJvcHM6IGludmFsaWQgdmFsdWUgJyR7eHJwfScsYCArXG4gICAgICAgICAgICAgICAgYCBzaG91bGQgYmUgYSBudW1iZXIgbWF0Y2hpbmcgKF4tP1swLTldKlxcXFwuP1swLTldKiQpLmApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHhycCA9PT0gJy4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsaWRhdGlvbkVycm9yKGB4cnBUb0Ryb3BzOiBpbnZhbGlkIHZhbHVlICcke3hycH0nLGAgK1xuICAgICAgICAgICAgICAgIGAgc2hvdWxkIGJlIGEgQmlnTnVtYmVyIG9yIHN0cmluZy1lbmNvZGVkIG51bWJlci5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB4cnAgPSBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdCh4cnApLnRvU3RyaW5nKDEwKTtcbiAgICBpZiAoIXhycC5tYXRjaCgvXi0/WzAtOS5dKyQvKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsaWRhdGlvbkVycm9yKGB4cnBUb0Ryb3BzOiBmYWlsZWQgc2FuaXR5IGNoZWNrIC1gICtcbiAgICAgICAgICAgIGAgdmFsdWUgJyR7eHJwfScsYCArXG4gICAgICAgICAgICBgIGRvZXMgbm90IG1hdGNoICheLT9bMC05Ll0rJCkuYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBvbmVudHMgPSB4cnAuc3BsaXQoJy4nKTtcbiAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoYHhycFRvRHJvcHM6IGZhaWxlZCBzYW5pdHkgY2hlY2sgLWAgK1xuICAgICAgICAgICAgYCB2YWx1ZSAnJHt4cnB9JyBoYXNgICtcbiAgICAgICAgICAgIGAgdG9vIG1hbnkgZGVjaW1hbCBwb2ludHMuYCk7XG4gICAgfVxuICAgIGNvbnN0IGZyYWN0aW9uID0gY29tcG9uZW50c1sxXSB8fCAnMCc7XG4gICAgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlZhbGlkYXRpb25FcnJvcihgeHJwVG9Ecm9wczogdmFsdWUgJyR7eHJwfScgaGFzYCArIGAgdG9vIG1hbnkgZGVjaW1hbCBwbGFjZXMuYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdCh4cnApXG4gICAgICAgIC50aW1lcygxMDAwMDAwLjApXG4gICAgICAgIC5pbnRlZ2VyVmFsdWUoYmlnbnVtYmVyX2pzXzEuZGVmYXVsdC5ST1VORF9GTE9PUilcbiAgICAgICAgLnRvU3RyaW5nKDEwKTtcbn1cbmV4cG9ydHMueHJwVG9Ecm9wcyA9IHhycFRvRHJvcHM7XG5mdW5jdGlvbiB0b1JpcHBsZWRBbW91bnQoYW1vdW50KSB7XG4gICAgaWYgKHR5cGVvZiBhbW91bnQgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gYW1vdW50O1xuICAgIGlmIChhbW91bnQuY3VycmVuY3kgPT09ICdYUlAnKSB7XG4gICAgICAgIHJldHVybiB4cnBUb0Ryb3BzKGFtb3VudC52YWx1ZSk7XG4gICAgfVxuICAgIGlmIChhbW91bnQuY3VycmVuY3kgPT09ICdkcm9wcycpIHtcbiAgICAgICAgcmV0dXJuIGFtb3VudC52YWx1ZTtcbiAgICB9XG4gICAgbGV0IGlzc3VlciA9IGFtb3VudC5jb3VudGVycGFydHkgfHwgYW1vdW50Lmlzc3VlcjtcbiAgICBsZXQgdGFnID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgKHsgY2xhc3NpY0FkZHJlc3M6IGlzc3VlciwgdGFnIH0gPSByaXBwbGVfYWRkcmVzc19jb2RlY18xLnhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyhpc3N1ZXIpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIGlmICh0YWcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoXCJJc3N1ZXIgWC1hZGRyZXNzIGluY2x1ZGVzIGEgdGFnXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW5jeTogYW1vdW50LmN1cnJlbmN5LFxuICAgICAgICBpc3N1ZXIsXG4gICAgICAgIHZhbHVlOiBhbW91bnQudmFsdWVcbiAgICB9O1xufVxuZXhwb3J0cy50b1JpcHBsZWRBbW91bnQgPSB0b1JpcHBsZWRBbW91bnQ7XG5mdW5jdGlvbiBjb252ZXJ0S2V5c0Zyb21TbmFrZUNhc2VUb0NhbWVsQ2FzZShvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgY29uc3QgYWNjdW11bGF0b3IgPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9O1xuICAgICAgICBsZXQgbmV3S2V5O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoKHJlc3VsdCwgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBuZXdLZXkgPSBrZXk7XG4gICAgICAgICAgICBjb25zdCBGSU5EU05BS0UgPSAvKFthLXpBLVpdX1thLXpBLVpdKS9nO1xuICAgICAgICAgICAgaWYgKEZJTkRTTkFLRS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICBuZXdLZXkgPSBrZXkucmVwbGFjZShGSU5EU05BS0UsIChyKSA9PiByWzBdICsgclsyXS50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtuZXdLZXldID0gY29udmVydEtleXNGcm9tU25ha2VDYXNlVG9DYW1lbENhc2UodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgYWNjdW11bGF0b3IpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuZXhwb3J0cy5jb252ZXJ0S2V5c0Zyb21TbmFrZUNhc2VUb0NhbWVsQ2FzZSA9IGNvbnZlcnRLZXlzRnJvbVNuYWtlQ2FzZVRvQ2FtZWxDYXNlO1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkKG9iaikge1xuICAgIHJldHVybiBfLm9taXRCeShvYmosIHZhbHVlID0+IHZhbHVlID09IG51bGwpO1xufVxuZXhwb3J0cy5yZW1vdmVVbmRlZmluZWQgPSByZW1vdmVVbmRlZmluZWQ7XG5mdW5jdGlvbiByaXBwbGVUb1VuaXhUaW1lc3RhbXAocnBlcG9jaCkge1xuICAgIHJldHVybiAocnBlcG9jaCArIDB4Mzg2ZDQzODApICogMTAwMDtcbn1cbmZ1bmN0aW9uIHVuaXhUb1JpcHBsZVRpbWVzdGFtcCh0aW1lc3RhbXApIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh0aW1lc3RhbXAgLyAxMDAwKSAtIDB4Mzg2ZDQzODA7XG59XG5mdW5jdGlvbiByaXBwbGVUaW1lVG9JU084NjAxKHJpcHBsZVRpbWUpIHtcbiAgICByZXR1cm4gbmV3IERhdGUocmlwcGxlVG9Vbml4VGltZXN0YW1wKHJpcHBsZVRpbWUpKS50b0lTT1N0cmluZygpO1xufVxuZXhwb3J0cy5yaXBwbGVUaW1lVG9JU084NjAxID0gcmlwcGxlVGltZVRvSVNPODYwMTtcbmZ1bmN0aW9uIGlzbzg2MDFUb1JpcHBsZVRpbWUoaXNvODYwMSkge1xuICAgIHJldHVybiB1bml4VG9SaXBwbGVUaW1lc3RhbXAoRGF0ZS5wYXJzZShpc284NjAxKSk7XG59XG5leHBvcnRzLmlzbzg2MDFUb1JpcHBsZVRpbWUgPSBpc284NjAxVG9SaXBwbGVUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50eF9qc29uID0gZXhwb3J0cy5pbnN0cnVjdGlvbnMgPSBleHBvcnRzLmFwaU9wdGlvbnMgPSBleHBvcnRzLnZlcmlmeVBheW1lbnRDaGFubmVsQ2xhaW0gPSBleHBvcnRzLnNpZ25QYXltZW50Q2hhbm5lbENsYWltID0gZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBleHBvcnRzLmNvbXB1dGVMZWRnZXJIYXNoID0gZXhwb3J0cy5zdWJtaXQgPSBleHBvcnRzLmNvbWJpbmUgPSBleHBvcnRzLnNpZ24gPSBleHBvcnRzLnByZXBhcmVUaWNrZXRDcmVhdGUgPSBleHBvcnRzLnByZXBhcmVDaGVja0NhbmNlbCA9IGV4cG9ydHMucHJlcGFyZUNoZWNrQ2FzaCA9IGV4cG9ydHMucHJlcGFyZUNoZWNrQ3JlYXRlID0gZXhwb3J0cy5wcmVwYXJlUGF5bWVudENoYW5uZWxDbGFpbSA9IGV4cG9ydHMucHJlcGFyZVBheW1lbnRDaGFubmVsRnVuZCA9IGV4cG9ydHMucHJlcGFyZVBheW1lbnRDaGFubmVsQ3JlYXRlID0gZXhwb3J0cy5wcmVwYXJlRXNjcm93RXhlY3V0aW9uID0gZXhwb3J0cy5wcmVwYXJlRXNjcm93Q2FuY2VsbGF0aW9uID0gZXhwb3J0cy5wcmVwYXJlRXNjcm93Q3JlYXRpb24gPSBleHBvcnRzLnByZXBhcmVTZXR0aW5ncyA9IGV4cG9ydHMucHJlcGFyZVRydXN0bGluZSA9IGV4cG9ydHMucHJlcGFyZU9yZGVyQ2FuY2VsbGF0aW9uID0gZXhwb3J0cy5wcmVwYXJlT3JkZXIgPSBleHBvcnRzLnByZXBhcmVQYXltZW50ID0gZXhwb3J0cy5nZXRMZWRnZXIgPSBleHBvcnRzLmdldFBheW1lbnRDaGFubmVsID0gZXhwb3J0cy5nZXRUcmFuc2FjdGlvbiA9IGV4cG9ydHMuZ2V0T3JkZXJib29rID0gZXhwb3J0cy5nZXRPcmRlcnMgPSBleHBvcnRzLmdldEJhbGFuY2VTaGVldCA9IGV4cG9ydHMuZ2V0QmFsYW5jZXMgPSBleHBvcnRzLmdldFRydXN0bGluZXMgPSBleHBvcnRzLmdldEFjY291bnRJbmZvID0gZXhwb3J0cy5nZXRTZXR0aW5ncyA9IGV4cG9ydHMuZ2V0VHJhbnNhY3Rpb25zID0gZXhwb3J0cy5nZXRQYXRocyA9IHZvaWQgMDtcbmNvbnN0IF8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImxvZGFzaFwiKSk7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IHNjaGVtYV92YWxpZGF0b3JfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYS12YWxpZGF0b3JcIik7XG5mdW5jdGlvbiBlcnJvcih0ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IodGV4dCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUxlZGdlclJhbmdlKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmXG4gICAgICAgIG9wdGlvbnMubWluTGVkZ2VyVmVyc2lvbiAhPSBudWxsICYmXG4gICAgICAgIG9wdGlvbnMubWF4TGVkZ2VyVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChOdW1iZXIob3B0aW9ucy5taW5MZWRnZXJWZXJzaW9uKSA+IE51bWJlcihvcHRpb25zLm1heExlZGdlclZlcnNpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcignbWluTGVkZ2VyVmVyc2lvbiBtdXN0IG5vdCBiZSBncmVhdGVyIHRoYW4gbWF4TGVkZ2VyVmVyc2lvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKHNjaGVtYSwgaW5zdGFuY2UpIHtcbiAgICBzY2hlbWFfdmFsaWRhdG9yXzEuc2NoZW1hVmFsaWRhdGUoc2NoZW1hLCBpbnN0YW5jZSk7XG4gICAgdmFsaWRhdGVMZWRnZXJSYW5nZShpbnN0YW5jZS5vcHRpb25zKTtcbn1cbmV4cG9ydHMuZ2V0UGF0aHMgPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAnZ2V0UGF0aHNQYXJhbWV0ZXJzJyk7XG5leHBvcnRzLmdldFRyYW5zYWN0aW9ucyA9IF8ucGFydGlhbCh2YWxpZGF0ZU9wdGlvbnMsICdnZXRUcmFuc2FjdGlvbnNQYXJhbWV0ZXJzJyk7XG5leHBvcnRzLmdldFNldHRpbmdzID0gXy5wYXJ0aWFsKHZhbGlkYXRlT3B0aW9ucywgJ2dldFNldHRpbmdzUGFyYW1ldGVycycpO1xuZXhwb3J0cy5nZXRBY2NvdW50SW5mbyA9IF8ucGFydGlhbCh2YWxpZGF0ZU9wdGlvbnMsICdnZXRBY2NvdW50SW5mb1BhcmFtZXRlcnMnKTtcbmV4cG9ydHMuZ2V0VHJ1c3RsaW5lcyA9IF8ucGFydGlhbCh2YWxpZGF0ZU9wdGlvbnMsICdnZXRUcnVzdGxpbmVzUGFyYW1ldGVycycpO1xuZXhwb3J0cy5nZXRCYWxhbmNlcyA9IF8ucGFydGlhbCh2YWxpZGF0ZU9wdGlvbnMsICdnZXRCYWxhbmNlc1BhcmFtZXRlcnMnKTtcbmV4cG9ydHMuZ2V0QmFsYW5jZVNoZWV0ID0gXy5wYXJ0aWFsKHZhbGlkYXRlT3B0aW9ucywgJ2dldEJhbGFuY2VTaGVldFBhcmFtZXRlcnMnKTtcbmV4cG9ydHMuZ2V0T3JkZXJzID0gXy5wYXJ0aWFsKHZhbGlkYXRlT3B0aW9ucywgJ2dldE9yZGVyc1BhcmFtZXRlcnMnKTtcbmV4cG9ydHMuZ2V0T3JkZXJib29rID0gXy5wYXJ0aWFsKHZhbGlkYXRlT3B0aW9ucywgJ2dldE9yZGVyYm9va1BhcmFtZXRlcnMnKTtcbmV4cG9ydHMuZ2V0VHJhbnNhY3Rpb24gPSBfLnBhcnRpYWwodmFsaWRhdGVPcHRpb25zLCAnZ2V0VHJhbnNhY3Rpb25QYXJhbWV0ZXJzJyk7XG5leHBvcnRzLmdldFBheW1lbnRDaGFubmVsID0gXy5wYXJ0aWFsKHZhbGlkYXRlT3B0aW9ucywgJ2dldFBheW1lbnRDaGFubmVsUGFyYW1ldGVycycpO1xuZXhwb3J0cy5nZXRMZWRnZXIgPSBfLnBhcnRpYWwodmFsaWRhdGVPcHRpb25zLCAnZ2V0TGVkZ2VyUGFyYW1ldGVycycpO1xuZXhwb3J0cy5wcmVwYXJlUGF5bWVudCA9IF8ucGFydGlhbChzY2hlbWFfdmFsaWRhdG9yXzEuc2NoZW1hVmFsaWRhdGUsICdwcmVwYXJlUGF5bWVudFBhcmFtZXRlcnMnKTtcbmV4cG9ydHMucHJlcGFyZU9yZGVyID0gXy5wYXJ0aWFsKHNjaGVtYV92YWxpZGF0b3JfMS5zY2hlbWFWYWxpZGF0ZSwgJ3ByZXBhcmVPcmRlclBhcmFtZXRlcnMnKTtcbmV4cG9ydHMucHJlcGFyZU9yZGVyQ2FuY2VsbGF0aW9uID0gXy5wYXJ0aWFsKHNjaGVtYV92YWxpZGF0b3JfMS5zY2hlbWFWYWxpZGF0ZSwgJ3ByZXBhcmVPcmRlckNhbmNlbGxhdGlvblBhcmFtZXRlcnMnKTtcbmV4cG9ydHMucHJlcGFyZVRydXN0bGluZSA9IF8ucGFydGlhbChzY2hlbWFfdmFsaWRhdG9yXzEuc2NoZW1hVmFsaWRhdGUsICdwcmVwYXJlVHJ1c3RsaW5lUGFyYW1ldGVycycpO1xuZXhwb3J0cy5wcmVwYXJlU2V0dGluZ3MgPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAncHJlcGFyZVNldHRpbmdzUGFyYW1ldGVycycpO1xuZXhwb3J0cy5wcmVwYXJlRXNjcm93Q3JlYXRpb24gPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAncHJlcGFyZUVzY3Jvd0NyZWF0aW9uUGFyYW1ldGVycycpO1xuZXhwb3J0cy5wcmVwYXJlRXNjcm93Q2FuY2VsbGF0aW9uID0gXy5wYXJ0aWFsKHNjaGVtYV92YWxpZGF0b3JfMS5zY2hlbWFWYWxpZGF0ZSwgJ3ByZXBhcmVFc2Nyb3dDYW5jZWxsYXRpb25QYXJhbWV0ZXJzJyk7XG5leHBvcnRzLnByZXBhcmVFc2Nyb3dFeGVjdXRpb24gPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAncHJlcGFyZUVzY3Jvd0V4ZWN1dGlvblBhcmFtZXRlcnMnKTtcbmV4cG9ydHMucHJlcGFyZVBheW1lbnRDaGFubmVsQ3JlYXRlID0gXy5wYXJ0aWFsKHNjaGVtYV92YWxpZGF0b3JfMS5zY2hlbWFWYWxpZGF0ZSwgJ3ByZXBhcmVQYXltZW50Q2hhbm5lbENyZWF0ZVBhcmFtZXRlcnMnKTtcbmV4cG9ydHMucHJlcGFyZVBheW1lbnRDaGFubmVsRnVuZCA9IF8ucGFydGlhbChzY2hlbWFfdmFsaWRhdG9yXzEuc2NoZW1hVmFsaWRhdGUsICdwcmVwYXJlUGF5bWVudENoYW5uZWxGdW5kUGFyYW1ldGVycycpO1xuZXhwb3J0cy5wcmVwYXJlUGF5bWVudENoYW5uZWxDbGFpbSA9IF8ucGFydGlhbChzY2hlbWFfdmFsaWRhdG9yXzEuc2NoZW1hVmFsaWRhdGUsICdwcmVwYXJlUGF5bWVudENoYW5uZWxDbGFpbVBhcmFtZXRlcnMnKTtcbmV4cG9ydHMucHJlcGFyZUNoZWNrQ3JlYXRlID0gXy5wYXJ0aWFsKHNjaGVtYV92YWxpZGF0b3JfMS5zY2hlbWFWYWxpZGF0ZSwgJ3ByZXBhcmVDaGVja0NyZWF0ZVBhcmFtZXRlcnMnKTtcbmV4cG9ydHMucHJlcGFyZUNoZWNrQ2FzaCA9IF8ucGFydGlhbChzY2hlbWFfdmFsaWRhdG9yXzEuc2NoZW1hVmFsaWRhdGUsICdwcmVwYXJlQ2hlY2tDYXNoUGFyYW1ldGVycycpO1xuZXhwb3J0cy5wcmVwYXJlQ2hlY2tDYW5jZWwgPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAncHJlcGFyZUNoZWNrQ2FuY2VsUGFyYW1ldGVycycpO1xuZXhwb3J0cy5wcmVwYXJlVGlja2V0Q3JlYXRlID0gXy5wYXJ0aWFsKHNjaGVtYV92YWxpZGF0b3JfMS5zY2hlbWFWYWxpZGF0ZSwgJ3ByZXBhcmVUaWNrZXRQYXJhbWV0ZXJzJyk7XG5leHBvcnRzLnNpZ24gPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAnc2lnblBhcmFtZXRlcnMnKTtcbmV4cG9ydHMuY29tYmluZSA9IF8ucGFydGlhbChzY2hlbWFfdmFsaWRhdG9yXzEuc2NoZW1hVmFsaWRhdGUsICdjb21iaW5lUGFyYW1ldGVycycpO1xuZXhwb3J0cy5zdWJtaXQgPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAnc3VibWl0UGFyYW1ldGVycycpO1xuZXhwb3J0cy5jb21wdXRlTGVkZ2VySGFzaCA9IF8ucGFydGlhbChzY2hlbWFfdmFsaWRhdG9yXzEuc2NoZW1hVmFsaWRhdGUsICdjb21wdXRlTGVkZ2VySGFzaFBhcmFtZXRlcnMnKTtcbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gXy5wYXJ0aWFsKHNjaGVtYV92YWxpZGF0b3JfMS5zY2hlbWFWYWxpZGF0ZSwgJ2dlbmVyYXRlQWRkcmVzc1BhcmFtZXRlcnMnKTtcbmV4cG9ydHMuc2lnblBheW1lbnRDaGFubmVsQ2xhaW0gPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAnc2lnblBheW1lbnRDaGFubmVsQ2xhaW1QYXJhbWV0ZXJzJyk7XG5leHBvcnRzLnZlcmlmeVBheW1lbnRDaGFubmVsQ2xhaW0gPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAndmVyaWZ5UGF5bWVudENoYW5uZWxDbGFpbVBhcmFtZXRlcnMnKTtcbmV4cG9ydHMuYXBpT3B0aW9ucyA9IF8ucGFydGlhbChzY2hlbWFfdmFsaWRhdG9yXzEuc2NoZW1hVmFsaWRhdGUsICdhcGktb3B0aW9ucycpO1xuZXhwb3J0cy5pbnN0cnVjdGlvbnMgPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAnaW5zdHJ1Y3Rpb25zJyk7XG5leHBvcnRzLnR4X2pzb24gPSBfLnBhcnRpYWwoc2NoZW1hX3ZhbGlkYXRvcl8xLnNjaGVtYVZhbGlkYXRlLCAndHgtanNvbicpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jbGFzcyBXU1dyYXBwZXIgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgX3Byb3RvY29scywgX3dlYnNvY2tldE9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuICAgICAgICB0aGlzLl93cyA9IG5ldyBXZWJTb2NrZXQodXJsKTtcbiAgICAgICAgdGhpcy5fd3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fd3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3dzLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3dzLm9ubWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fd3MuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5fd3Muc2VuZChtZXNzYWdlKTtcbiAgICB9XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cy5yZWFkeVN0YXRlO1xuICAgIH1cbn1cbldTV3JhcHBlci5DT05ORUNUSU5HID0gMDtcbldTV3JhcHBlci5PUEVOID0gMTtcbldTV3JhcHBlci5DTE9TSU5HID0gMjtcbldTV3JhcHBlci5DTE9TRUQgPSAzO1xubW9kdWxlLmV4cG9ydHMgPSBXU1dyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13c3dyYXBwZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXBpXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi90eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tbW9uL3R5cGVzL29iamVjdHMvbGVkZ2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vZmZsaW5lL3V0aWxzXCIpLCBleHBvcnRzKTtcbnZhciBicm9hZGNhc3RfMSA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJpcHBsZUFQSUJyb2FkY2FzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYnJvYWRjYXN0XzEuUmlwcGxlQVBJQnJvYWRjYXN0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmZ1bmN0aW9uIGZvcm1hdEFjY291bnRJbmZvKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlLmFjY291bnRfZGF0YTtcbiAgICByZXR1cm4gY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgc2VxdWVuY2U6IGRhdGEuU2VxdWVuY2UsXG4gICAgICAgIHhycEJhbGFuY2U6IGNvbW1vbl8xLmRyb3BzVG9YcnAoZGF0YS5CYWxhbmNlKSxcbiAgICAgICAgb3duZXJDb3VudDogZGF0YS5Pd25lckNvdW50LFxuICAgICAgICBwcmV2aW91c0luaXRpYXRlZFRyYW5zYWN0aW9uSUQ6IGRhdGEuQWNjb3VudFR4bklELFxuICAgICAgICBwcmV2aW91c0FmZmVjdGluZ1RyYW5zYWN0aW9uSUQ6IGRhdGEuUHJldmlvdXNUeG5JRCxcbiAgICAgICAgcHJldmlvdXNBZmZlY3RpbmdUcmFuc2FjdGlvbkxlZGdlclZlcnNpb246IGRhdGEuUHJldmlvdXNUeG5MZ3JTZXFcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFjY291bnRJbmZvKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbW1vbl8xLnZhbGlkYXRlLmdldEFjY291bnRJbmZvKHsgYWRkcmVzcywgb3B0aW9ucyB9KTtcbiAgICAgICAgYWRkcmVzcyA9IGNvbW1vbl8xLmVuc3VyZUNsYXNzaWNBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCgnYWNjb3VudF9pbmZvJywge1xuICAgICAgICAgICAgYWNjb3VudDogYWRkcmVzcyxcbiAgICAgICAgICAgIGxlZGdlcl9pbmRleDogb3B0aW9ucy5sZWRnZXJWZXJzaW9uIHx8ICd2YWxpZGF0ZWQnXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm9ybWF0QWNjb3VudEluZm8ocmVzcG9uc2UpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0QWNjb3VudEluZm87XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvdW50aW5mby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuZnVuY3Rpb24gZ2V0QWNjb3VudE9iamVjdHMoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3QoJ2FjY291bnRfb2JqZWN0cycsIGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgICAgICBhY2NvdW50OiBhZGRyZXNzLFxuICAgICAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlLFxuICAgICAgICAgICAgbGVkZ2VyX2hhc2g6IG9wdGlvbnMubGVkZ2VySGFzaCxcbiAgICAgICAgICAgIGxlZGdlcl9pbmRleDogb3B0aW9ucy5sZWRnZXJJbmRleCxcbiAgICAgICAgICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0LFxuICAgICAgICAgICAgbWFya2VyOiBvcHRpb25zLm1hcmtlclxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEFjY291bnRPYmplY3RzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudG9iamVjdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmZ1bmN0aW9uIGZvcm1hdEJhbGFuY2VTaGVldChiYWxhbmNlU2hlZXQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBpZiAoYmFsYW5jZVNoZWV0LmJhbGFuY2VzICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmJhbGFuY2VzID0gW107XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGJhbGFuY2VTaGVldC5iYWxhbmNlcykuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbY291bnRlcnBhcnR5LCBiYWxhbmNlc10gPSBlbnRyeTtcbiAgICAgICAgICAgIGJhbGFuY2VzLmZvckVhY2goKGJhbGFuY2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYmFsYW5jZXMucHVzaChPYmplY3QuYXNzaWduKHsgY291bnRlcnBhcnR5IH0sIGJhbGFuY2UpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJhbGFuY2VTaGVldC5hc3NldHMgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQuYXNzZXRzID0gW107XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGJhbGFuY2VTaGVldC5hc3NldHMpLmZvckVhY2goKFtjb3VudGVycGFydHksIGFzc2V0c10pID0+IHtcbiAgICAgICAgICAgIGFzc2V0cy5mb3JFYWNoKChiYWxhbmNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFzc2V0cy5wdXNoKE9iamVjdC5hc3NpZ24oeyBjb3VudGVycGFydHkgfSwgYmFsYW5jZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYmFsYW5jZVNoZWV0Lm9ibGlnYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0Lm9ibGlnYXRpb25zID0gT2JqZWN0LmVudHJpZXMoYmFsYW5jZVNoZWV0Lm9ibGlnYXRpb25zKS5tYXAoKFtjdXJyZW5jeSwgdmFsdWVdKSA9PiAoeyBjdXJyZW5jeSwgdmFsdWUgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0QmFsYW5jZVNoZWV0KGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbW1vbl8xLnZhbGlkYXRlLmdldEJhbGFuY2VTaGVldCh7IGFkZHJlc3MsIG9wdGlvbnMgfSk7XG4gICAgICAgIG9wdGlvbnMgPSB5aWVsZCB1dGlsc18xLmVuc3VyZUxlZGdlclZlcnNpb24uY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3QoJ2dhdGV3YXlfYmFsYW5jZXMnLCB7XG4gICAgICAgICAgICBhY2NvdW50OiBhZGRyZXNzLFxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgaG90d2FsbGV0OiBvcHRpb25zLmV4Y2x1ZGVBZGRyZXNzZXMsXG4gICAgICAgICAgICBsZWRnZXJfaW5kZXg6IG9wdGlvbnMubGVkZ2VyVmVyc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdEJhbGFuY2VTaGVldChyZXNwb25zZSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRCYWxhbmNlU2hlZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWxhbmNlLXNoZWV0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmZ1bmN0aW9uIGdldFRydXN0bGluZUJhbGFuY2VBbW91bnQodHJ1c3RsaW5lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3VycmVuY3k6IHRydXN0bGluZS5zcGVjaWZpY2F0aW9uLmN1cnJlbmN5LFxuICAgICAgICBjb3VudGVycGFydHk6IHRydXN0bGluZS5zcGVjaWZpY2F0aW9uLmNvdW50ZXJwYXJ0eSxcbiAgICAgICAgdmFsdWU6IHRydXN0bGluZS5zdGF0ZS5iYWxhbmNlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEJhbGFuY2VzKG9wdGlvbnMsIGJhbGFuY2VzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYmFsYW5jZXMudHJ1c3RsaW5lcy5tYXAoZ2V0VHJ1c3RsaW5lQmFsYW5jZUFtb3VudCk7XG4gICAgaWYgKCEob3B0aW9ucy5jb3VudGVycGFydHkgfHwgKG9wdGlvbnMuY3VycmVuY3kgJiYgb3B0aW9ucy5jdXJyZW5jeSAhPT0gJ1hSUCcpKSkge1xuICAgICAgICBjb25zdCB4cnBCYWxhbmNlID0ge1xuICAgICAgICAgICAgY3VycmVuY3k6ICdYUlAnLFxuICAgICAgICAgICAgdmFsdWU6IGJhbGFuY2VzLnhycFxuICAgICAgICB9O1xuICAgICAgICByZXN1bHQudW5zaGlmdCh4cnBCYWxhbmNlKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubGltaXQgJiYgcmVzdWx0Lmxlbmd0aCA+IG9wdGlvbnMubGltaXQpIHtcbiAgICAgICAgY29uc3QgdG9SZW1vdmUgPSByZXN1bHQubGVuZ3RoIC0gb3B0aW9ucy5saW1pdDtcbiAgICAgICAgcmVzdWx0LnNwbGljZSgtdG9SZW1vdmUsIHRvUmVtb3ZlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldExlZGdlclZlcnNpb25IZWxwZXIoY29ubmVjdGlvbiwgb3B0aW9uVmFsdWUpIHtcbiAgICBpZiAob3B0aW9uVmFsdWUgIT0gbnVsbCAmJiBvcHRpb25WYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdGlvblZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3Rpb24uZ2V0TGVkZ2VyVmVyc2lvbigpO1xufVxuZnVuY3Rpb24gZ2V0QmFsYW5jZXMoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29tbW9uXzEudmFsaWRhdGUuZ2V0VHJ1c3RsaW5lcyh7IGFkZHJlc3MsIG9wdGlvbnMgfSk7XG4gICAgYWRkcmVzcyA9IGNvbW1vbl8xLmVuc3VyZUNsYXNzaWNBZGRyZXNzKGFkZHJlc3MpO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldExlZGdlclZlcnNpb25IZWxwZXIodGhpcy5jb25uZWN0aW9uLCBvcHRpb25zLmxlZGdlclZlcnNpb24pLnRoZW4oKGxlZGdlclZlcnNpb24pID0+IHV0aWxzLmdldFhSUEJhbGFuY2UodGhpcy5jb25uZWN0aW9uLCBhZGRyZXNzLCBsZWRnZXJWZXJzaW9uKSksXG4gICAgICAgIHRoaXMuZ2V0VHJ1c3RsaW5lcyhhZGRyZXNzLCBvcHRpb25zKVxuICAgIF0pLnRoZW4oKHJlc3VsdHMpID0+IGZvcm1hdEJhbGFuY2VzKG9wdGlvbnMsIHsgeHJwOiByZXN1bHRzWzBdLCB0cnVzdGxpbmVzOiByZXN1bHRzWzFdIH0pKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldEJhbGFuY2VzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFsYW5jZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmNvbnN0IGxlZGdlcl8xID0gcmVxdWlyZShcIi4vcGFyc2UvbGVkZ2VyXCIpO1xuZnVuY3Rpb24gZ2V0TGVkZ2VyKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbW1vbl8xLnZhbGlkYXRlLmdldExlZGdlcih7IG9wdGlvbnMgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5yZXF1ZXN0KCdsZWRnZXInLCB7XG4gICAgICAgICAgICBsZWRnZXJfaGFzaDogb3B0aW9ucy5sZWRnZXJIYXNoLFxuICAgICAgICAgICAgbGVkZ2VyX2luZGV4OiBvcHRpb25zLmxlZGdlclZlcnNpb24gfHwgJ3ZhbGlkYXRlZCcsXG4gICAgICAgICAgICBleHBhbmQ6IG9wdGlvbnMuaW5jbHVkZUFsbERhdGEsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IG9wdGlvbnMuaW5jbHVkZVRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgIGFjY291bnRzOiBvcHRpb25zLmluY2x1ZGVTdGF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxlZGdlcl8xLnBhcnNlTGVkZ2VyKHJlc3BvbnNlLmxlZGdlcik7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRMZWRnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWRnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE9yZGVyYm9vayA9IGV4cG9ydHMuZm9ybWF0Qmlkc0FuZEFza3MgPSB2b2lkIDA7XG5jb25zdCBfID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3Qgb3JkZXJib29rX29yZGVyXzEgPSByZXF1aXJlKFwiLi9wYXJzZS9vcmRlcmJvb2stb3JkZXJcIik7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpKTtcbmZ1bmN0aW9uIGlzU2FtZUlzc3VlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5jdXJyZW5jeSA9PT0gYi5jdXJyZW5jeSAmJiBhLmNvdW50ZXJwYXJ0eSA9PT0gYi5jb3VudGVycGFydHk7XG59XG5mdW5jdGlvbiBkaXJlY3Rpb25GaWx0ZXIoZGlyZWN0aW9uLCBvcmRlcikge1xuICAgIHJldHVybiBvcmRlci5zcGVjaWZpY2F0aW9uLmRpcmVjdGlvbiA9PT0gZGlyZWN0aW9uO1xufVxuZnVuY3Rpb24gZmxpcE9yZGVyKG9yZGVyKSB7XG4gICAgY29uc3Qgc3BlY2lmaWNhdGlvbiA9IG9yZGVyLnNwZWNpZmljYXRpb247XG4gICAgY29uc3QgZmxpcHBlZFNwZWNpZmljYXRpb24gPSB7XG4gICAgICAgIHF1YW50aXR5OiBzcGVjaWZpY2F0aW9uLnRvdGFsUHJpY2UsXG4gICAgICAgIHRvdGFsUHJpY2U6IHNwZWNpZmljYXRpb24ucXVhbnRpdHksXG4gICAgICAgIGRpcmVjdGlvbjogc3BlY2lmaWNhdGlvbi5kaXJlY3Rpb24gPT09ICdidXknID8gJ3NlbGwnIDogJ2J1eSdcbiAgICB9O1xuICAgIGNvbnN0IG5ld1NwZWNpZmljYXRpb24gPSBfLm1lcmdlKHt9LCBzcGVjaWZpY2F0aW9uLCBmbGlwcGVkU3BlY2lmaWNhdGlvbik7XG4gICAgcmV0dXJuIF8ubWVyZ2Uoe30sIG9yZGVyLCB7IHNwZWNpZmljYXRpb246IG5ld1NwZWNpZmljYXRpb24gfSk7XG59XG5mdW5jdGlvbiBhbGlnbk9yZGVyKGJhc2UsIG9yZGVyKSB7XG4gICAgY29uc3QgcXVhbnRpdHkgPSBvcmRlci5zcGVjaWZpY2F0aW9uLnF1YW50aXR5O1xuICAgIHJldHVybiBpc1NhbWVJc3N1ZShxdWFudGl0eSwgYmFzZSkgPyBvcmRlciA6IGZsaXBPcmRlcihvcmRlcik7XG59XG5mdW5jdGlvbiBmb3JtYXRCaWRzQW5kQXNrcyhvcmRlcmJvb2ssIG9mZmVycykge1xuICAgIGNvbnN0IG9yZGVycyA9IG9mZmVyc1xuICAgICAgICAuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoYS5xdWFsaXR5KS5jb21wYXJlZFRvKGIucXVhbGl0eSk7XG4gICAgfSlcbiAgICAgICAgLm1hcChvcmRlcmJvb2tfb3JkZXJfMS5wYXJzZU9yZGVyYm9va09yZGVyKTtcbiAgICBjb25zdCBhbGlnbmVkT3JkZXJzID0gb3JkZXJzLm1hcChfLnBhcnRpYWwoYWxpZ25PcmRlciwgb3JkZXJib29rLmJhc2UpKTtcbiAgICBjb25zdCBiaWRzID0gYWxpZ25lZE9yZGVycy5maWx0ZXIoXy5wYXJ0aWFsKGRpcmVjdGlvbkZpbHRlciwgJ2J1eScpKTtcbiAgICBjb25zdCBhc2tzID0gYWxpZ25lZE9yZGVycy5maWx0ZXIoXy5wYXJ0aWFsKGRpcmVjdGlvbkZpbHRlciwgJ3NlbGwnKSk7XG4gICAgcmV0dXJuIHsgYmlkcywgYXNrcyB9O1xufVxuZXhwb3J0cy5mb3JtYXRCaWRzQW5kQXNrcyA9IGZvcm1hdEJpZHNBbmRBc2tzO1xuZnVuY3Rpb24gbWFrZVJlcXVlc3QoYXBpLCB0YWtlciwgb3B0aW9ucywgdGFrZXJHZXRzLCB0YWtlclBheXMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBvcmRlckRhdGEgPSB1dGlscy5yZW5hbWVDb3VudGVycGFydHlUb0lzc3VlckluT3JkZXIoe1xuICAgICAgICAgICAgdGFrZXJfZ2V0czogdGFrZXJHZXRzLFxuICAgICAgICAgICAgdGFrZXJfcGF5czogdGFrZXJQYXlzXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXBpLl9yZXF1ZXN0QWxsKCdib29rX29mZmVycycsIHtcbiAgICAgICAgICAgIHRha2VyX2dldHM6IG9yZGVyRGF0YS50YWtlcl9nZXRzLFxuICAgICAgICAgICAgdGFrZXJfcGF5czogb3JkZXJEYXRhLnRha2VyX3BheXMsXG4gICAgICAgICAgICBsZWRnZXJfaW5kZXg6IG9wdGlvbnMubGVkZ2VyVmVyc2lvbiB8fCAndmFsaWRhdGVkJyxcbiAgICAgICAgICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0LFxuICAgICAgICAgICAgdGFrZXJcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRPcmRlcmJvb2soYWRkcmVzcywgb3JkZXJib29rLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb21tb25fMS52YWxpZGF0ZS5nZXRPcmRlcmJvb2soeyBhZGRyZXNzLCBvcmRlcmJvb2ssIG9wdGlvbnMgfSk7XG4gICAgICAgIGNvbnN0IFtkaXJlY3RPZmZlclJlc3VsdHMsIHJldmVyc2VPZmZlclJlc3VsdHNdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgbWFrZVJlcXVlc3QodGhpcywgYWRkcmVzcywgb3B0aW9ucywgb3JkZXJib29rLmJhc2UsIG9yZGVyYm9vay5jb3VudGVyKSxcbiAgICAgICAgICAgIG1ha2VSZXF1ZXN0KHRoaXMsIGFkZHJlc3MsIG9wdGlvbnMsIG9yZGVyYm9vay5jb3VudGVyLCBvcmRlcmJvb2suYmFzZSlcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGRpcmVjdE9mZmVycyA9IF8uZmxhdE1hcChkaXJlY3RPZmZlclJlc3VsdHMsIChkaXJlY3RPZmZlclJlc3VsdCkgPT4gZGlyZWN0T2ZmZXJSZXN1bHQub2ZmZXJzKTtcbiAgICAgICAgY29uc3QgcmV2ZXJzZU9mZmVycyA9IF8uZmxhdE1hcChyZXZlcnNlT2ZmZXJSZXN1bHRzLCAocmV2ZXJzZU9mZmVyUmVzdWx0KSA9PiByZXZlcnNlT2ZmZXJSZXN1bHQub2ZmZXJzKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdEJpZHNBbmRBc2tzKG9yZGVyYm9vaywgWy4uLmRpcmVjdE9mZmVycywgLi4ucmV2ZXJzZU9mZmVyc10pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRPcmRlcmJvb2sgPSBnZXRPcmRlcmJvb2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcmRlcmJvb2suanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBfID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuY29uc3QgYWNjb3VudF9vcmRlcl8xID0gcmVxdWlyZShcIi4vcGFyc2UvYWNjb3VudC1vcmRlclwiKTtcbmZ1bmN0aW9uIGZvcm1hdFJlc3BvbnNlKGFkZHJlc3MsIHJlc3BvbnNlcykge1xuICAgIGxldCBvcmRlcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJlc3BvbnNlIG9mIHJlc3BvbnNlcykge1xuICAgICAgICBjb25zdCBvZmZlcnMgPSByZXNwb25zZS5vZmZlcnMubWFwKChvZmZlcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRfb3JkZXJfMS5wYXJzZUFjY291bnRPcmRlcihhZGRyZXNzLCBvZmZlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMuY29uY2F0KG9mZmVycyk7XG4gICAgfVxuICAgIHJldHVybiBfLnNvcnRCeShvcmRlcnMsIChvcmRlcikgPT4gb3JkZXIucHJvcGVydGllcy5zZXF1ZW5jZSk7XG59XG5mdW5jdGlvbiBnZXRPcmRlcnMoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29tbW9uXzEudmFsaWRhdGUuZ2V0T3JkZXJzKHsgYWRkcmVzcywgb3B0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VzID0geWllbGQgdGhpcy5fcmVxdWVzdEFsbCgnYWNjb3VudF9vZmZlcnMnLCB7XG4gICAgICAgICAgICBhY2NvdW50OiBhZGRyZXNzLFxuICAgICAgICAgICAgbGVkZ2VyX2luZGV4OiBvcHRpb25zLmxlZGdlclZlcnNpb24gfHwgKHlpZWxkIHRoaXMuZ2V0TGVkZ2VyVmVyc2lvbigpKSxcbiAgICAgICAgICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm9ybWF0UmVzcG9uc2UoYWRkcmVzcywgcmVzcG9uc2VzKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldE9yZGVycztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yZGVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XG5jb25zdCByaXBwbGVfYWRkcmVzc19jb2RlY18xID0gcmVxdWlyZShcInJpcHBsZS1hZGRyZXNzLWNvZGVjXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gcGFyc2VBY2NvdW50RGVsZXRlKHR4KSB7XG4gICAgYXNzZXJ0Lm9rKHR4LlRyYW5zYWN0aW9uVHlwZSA9PT0gJ0FjY291bnREZWxldGUnKTtcbiAgICByZXR1cm4gY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgbWVtb3M6IHV0aWxzXzEucGFyc2VNZW1vcyh0eCksXG4gICAgICAgIGRlc3RpbmF0aW9uOiB0eC5EZXN0aW5hdGlvbixcbiAgICAgICAgZGVzdGluYXRpb25UYWc6IHR4LkRlc3RpbmF0aW9uVGFnLFxuICAgICAgICBkZXN0aW5hdGlvblhBZGRyZXNzOiByaXBwbGVfYWRkcmVzc19jb2RlY18xLmNsYXNzaWNBZGRyZXNzVG9YQWRkcmVzcyh0eC5EZXN0aW5hdGlvbiwgdHguRGVzdGluYXRpb25UYWcgPT0gbnVsbCA/IGZhbHNlIDogdHguRGVzdGluYXRpb25UYWcsIGZhbHNlKVxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VBY2NvdW50RGVsZXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjb3VudC1kZWxldGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlQWNjb3VudE9yZGVyID0gdm9pZCAwO1xuY29uc3QgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG5jb25zdCBhbW91bnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hbW91bnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uXCIpO1xuY29uc3QgZmxhZ3NfMSA9IHJlcXVpcmUoXCIuL2ZsYWdzXCIpO1xuZnVuY3Rpb24gY29tcHV0ZVF1YWxpdHkodGFrZXJHZXRzLCB0YWtlclBheXMpIHtcbiAgICBjb25zdCBxdW90aWVudCA9IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHRha2VyUGF5cy52YWx1ZSkuZGl2aWRlZEJ5KHRha2VyR2V0cy52YWx1ZSk7XG4gICAgcmV0dXJuIHF1b3RpZW50LnByZWNpc2lvbigxNiwgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdC5ST1VORF9IQUxGX1VQKS50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gcGFyc2VBY2NvdW50T3JkZXIoYWRkcmVzcywgb3JkZXIpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSAob3JkZXIuZmxhZ3MgJiBmbGFnc18xLm9yZGVyRmxhZ3MuU2VsbCkgPT09IDAgPyAnYnV5JyA6ICdzZWxsJztcbiAgICBjb25zdCB0YWtlckdldHNBbW91bnQgPSBhbW91bnRfMS5kZWZhdWx0KG9yZGVyLnRha2VyX2dldHMpO1xuICAgIGNvbnN0IHRha2VyUGF5c0Ftb3VudCA9IGFtb3VudF8xLmRlZmF1bHQob3JkZXIudGFrZXJfcGF5cyk7XG4gICAgY29uc3QgcXVhbnRpdHkgPSBkaXJlY3Rpb24gPT09ICdidXknID8gdGFrZXJQYXlzQW1vdW50IDogdGFrZXJHZXRzQW1vdW50O1xuICAgIGNvbnN0IHRvdGFsUHJpY2UgPSBkaXJlY3Rpb24gPT09ICdidXknID8gdGFrZXJHZXRzQW1vdW50IDogdGFrZXJQYXlzQW1vdW50O1xuICAgIGNvbnN0IHNwZWNpZmljYXRpb24gPSBjb21tb25fMS5yZW1vdmVVbmRlZmluZWQoe1xuICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgcXVhbnRpdHk6IHF1YW50aXR5LFxuICAgICAgICB0b3RhbFByaWNlOiB0b3RhbFByaWNlLFxuICAgICAgICBwYXNzaXZlOiAob3JkZXIuZmxhZ3MgJiBmbGFnc18xLm9yZGVyRmxhZ3MuUGFzc2l2ZSkgIT09IDAgfHwgdW5kZWZpbmVkLFxuICAgICAgICBleHBpcmF0aW9uVGltZTogdXRpbHNfMS5wYXJzZVRpbWVzdGFtcChvcmRlci5leHBpcmF0aW9uKVxuICAgIH0pO1xuICAgIGNvbnN0IG1ha2VyRXhjaGFuZ2VSYXRlID0gb3JkZXIucXVhbGl0eVxuICAgICAgICA/IHV0aWxzXzEuYWRqdXN0UXVhbGl0eUZvclhSUChvcmRlci5xdWFsaXR5LnRvU3RyaW5nKCksIHRha2VyR2V0c0Ftb3VudC5jdXJyZW5jeSwgdGFrZXJQYXlzQW1vdW50LmN1cnJlbmN5KVxuICAgICAgICA6IGNvbXB1dGVRdWFsaXR5KHRha2VyR2V0c0Ftb3VudCwgdGFrZXJQYXlzQW1vdW50KTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBtYWtlcjogYWRkcmVzcyxcbiAgICAgICAgc2VxdWVuY2U6IG9yZGVyLnNlcSxcbiAgICAgICAgbWFrZXJFeGNoYW5nZVJhdGU6IG1ha2VyRXhjaGFuZ2VSYXRlXG4gICAgfTtcbiAgICByZXR1cm4geyBzcGVjaWZpY2F0aW9uLCBwcm9wZXJ0aWVzIH07XG59XG5leHBvcnRzLnBhcnNlQWNjb3VudE9yZGVyID0gcGFyc2VBY2NvdW50T3JkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvdW50LW9yZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uXCIpO1xuZnVuY3Rpb24gcGFyc2VBY2NvdW50VHJ1c3RsaW5lKHRydXN0bGluZSkge1xuICAgIGNvbnN0IHNwZWNpZmljYXRpb24gPSBjb21tb25fMS5yZW1vdmVVbmRlZmluZWQoe1xuICAgICAgICBsaW1pdDogdHJ1c3RsaW5lLmxpbWl0LFxuICAgICAgICBjdXJyZW5jeTogdHJ1c3RsaW5lLmN1cnJlbmN5LFxuICAgICAgICBjb3VudGVycGFydHk6IHRydXN0bGluZS5hY2NvdW50LFxuICAgICAgICBxdWFsaXR5SW46IHV0aWxzXzEucGFyc2VRdWFsaXR5KHRydXN0bGluZS5xdWFsaXR5X2luKSB8fCB1bmRlZmluZWQsXG4gICAgICAgIHF1YWxpdHlPdXQ6IHV0aWxzXzEucGFyc2VRdWFsaXR5KHRydXN0bGluZS5xdWFsaXR5X291dCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICByaXBwbGluZ0Rpc2FibGVkOiB0cnVzdGxpbmUubm9fcmlwcGxlLFxuICAgICAgICBmcm96ZW46IHRydXN0bGluZS5mcmVlemUsXG4gICAgICAgIGF1dGhvcml6ZWQ6IHRydXN0bGluZS5hdXRob3JpemVkXG4gICAgfSk7XG4gICAgY29uc3QgY291bnRlcnBhcnR5ID0gY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgbGltaXQ6IHRydXN0bGluZS5saW1pdF9wZWVyLFxuICAgICAgICByaXBwbGluZ0Rpc2FibGVkOiB0cnVzdGxpbmUubm9fcmlwcGxlX3BlZXIsXG4gICAgICAgIGZyb3plbjogdHJ1c3RsaW5lLmZyZWV6ZV9wZWVyLFxuICAgICAgICBhdXRob3JpemVkOiB0cnVzdGxpbmUucGVlcl9hdXRob3JpemVkXG4gICAgfSk7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGJhbGFuY2U6IHRydXN0bGluZS5iYWxhbmNlXG4gICAgfTtcbiAgICByZXR1cm4geyBzcGVjaWZpY2F0aW9uLCBjb3VudGVycGFydHksIHN0YXRlIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZUFjY291bnRUcnVzdGxpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2NvdW50LXRydXN0bGluZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHBhcnNlQW1lbmRtZW50KHR4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYW1lbmRtZW50OiB0eC5BbWVuZG1lbnRcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VBbWVuZG1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbWVuZG1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29tbW9uID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIikpO1xuZnVuY3Rpb24gcGFyc2VBbW91bnQoYW1vdW50KSB7XG4gICAgaWYgKHR5cGVvZiBhbW91bnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjdXJyZW5jeTogJ1hSUCcsXG4gICAgICAgICAgICB2YWx1ZTogY29tbW9uLmRyb3BzVG9YcnAoYW1vdW50KVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW5jeTogYW1vdW50LmN1cnJlbmN5LFxuICAgICAgICB2YWx1ZTogYW1vdW50LnZhbHVlLFxuICAgICAgICBjb3VudGVycGFydHk6IGFtb3VudC5pc3N1ZXJcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VBbW91bnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbW91bnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gcGFyc2VPcmRlckNhbmNlbGxhdGlvbih0eCkge1xuICAgIGFzc2VydC5vayh0eC5UcmFuc2FjdGlvblR5cGUgPT09ICdPZmZlckNhbmNlbCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lbW9zOiB1dGlsc18xLnBhcnNlTWVtb3ModHgpLFxuICAgICAgICBvcmRlclNlcXVlbmNlOiB0eC5PZmZlclNlcXVlbmNlXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlT3JkZXJDYW5jZWxsYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYW5jZWxsYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gcGFyc2VDaGVja0NhbmNlbCh0eCkge1xuICAgIGFzc2VydC5vayh0eC5UcmFuc2FjdGlvblR5cGUgPT09ICdDaGVja0NhbmNlbCcpO1xuICAgIHJldHVybiBjb21tb25fMS5yZW1vdmVVbmRlZmluZWQoe1xuICAgICAgICBtZW1vczogdXRpbHNfMS5wYXJzZU1lbW9zKHR4KSxcbiAgICAgICAgY2hlY2tJRDogdHguQ2hlY2tJRFxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VDaGVja0NhbmNlbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrLWNhbmNlbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XG5jb25zdCBhbW91bnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hbW91bnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gcGFyc2VDaGVja0Nhc2godHgpIHtcbiAgICBhc3NlcnQub2sodHguVHJhbnNhY3Rpb25UeXBlID09PSAnQ2hlY2tDYXNoJyk7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgIG1lbW9zOiB1dGlsc18xLnBhcnNlTWVtb3ModHgpLFxuICAgICAgICBjaGVja0lEOiB0eC5DaGVja0lELFxuICAgICAgICBhbW91bnQ6IHR4LkFtb3VudCAmJiBhbW91bnRfMS5kZWZhdWx0KHR4LkFtb3VudCksXG4gICAgICAgIGRlbGl2ZXJNaW46IHR4LkRlbGl2ZXJNaW4gJiYgYW1vdW50XzEuZGVmYXVsdCh0eC5EZWxpdmVyTWluKVxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VDaGVja0Nhc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVjay1jYXNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFzc2VydCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vblwiKTtcbmNvbnN0IGFtb3VudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Ftb3VudFwiKSk7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5mdW5jdGlvbiBwYXJzZUNoZWNrQ3JlYXRlKHR4KSB7XG4gICAgYXNzZXJ0Lm9rKHR4LlRyYW5zYWN0aW9uVHlwZSA9PT0gJ0NoZWNrQ3JlYXRlJyk7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgIG1lbW9zOiB1dGlsc18yLnBhcnNlTWVtb3ModHgpLFxuICAgICAgICBkZXN0aW5hdGlvbjogdHguRGVzdGluYXRpb24sXG4gICAgICAgIHNlbmRNYXg6IGFtb3VudF8xLmRlZmF1bHQodHguU2VuZE1heCksXG4gICAgICAgIGRlc3RpbmF0aW9uVGFnOiB0eC5EZXN0aW5hdGlvblRhZyxcbiAgICAgICAgZXhwaXJhdGlvbjogdHguRXhwaXJhdGlvbiAmJiB1dGlsc18xLnBhcnNlVGltZXN0YW1wKHR4LkV4cGlyYXRpb24pLFxuICAgICAgICBpbnZvaWNlSUQ6IHR4Lkludm9pY2VJRFxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VDaGVja0NyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrLWNyZWF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5mdW5jdGlvbiBwYXJzZURlcG9zaXRQcmVhdXRoKHR4KSB7XG4gICAgYXNzZXJ0Lm9rKHR4LlRyYW5zYWN0aW9uVHlwZSA9PT0gJ0RlcG9zaXRQcmVhdXRoJyk7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgIG1lbW9zOiB1dGlsc18xLnBhcnNlTWVtb3ModHgpLFxuICAgICAgICBhdXRob3JpemU6IHR4LkF1dGhvcml6ZSxcbiAgICAgICAgdW5hdXRob3JpemU6IHR4LlVuYXV0aG9yaXplXG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZURlcG9zaXRQcmVhdXRoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVwb3NpdC1wcmVhdXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFzc2VydCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vblwiKTtcbmZ1bmN0aW9uIHBhcnNlRXNjcm93Q2FuY2VsbGF0aW9uKHR4KSB7XG4gICAgYXNzZXJ0Lm9rKHR4LlRyYW5zYWN0aW9uVHlwZSA9PT0gJ0VzY3Jvd0NhbmNlbCcpO1xuICAgIHJldHVybiBjb21tb25fMS5yZW1vdmVVbmRlZmluZWQoe1xuICAgICAgICBtZW1vczogdXRpbHNfMS5wYXJzZU1lbW9zKHR4KSxcbiAgICAgICAgb3duZXI6IHR4Lk93bmVyLFxuICAgICAgICBlc2Nyb3dTZXF1ZW5jZTogdHguT2ZmZXJTZXF1ZW5jZVxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VFc2Nyb3dDYW5jZWxsYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lc2Nyb3ctY2FuY2VsbGF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFzc2VydCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IGFtb3VudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Ftb3VudFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XG5mdW5jdGlvbiBwYXJzZUVzY3Jvd0NyZWF0aW9uKHR4KSB7XG4gICAgYXNzZXJ0Lm9rKHR4LlRyYW5zYWN0aW9uVHlwZSA9PT0gJ0VzY3Jvd0NyZWF0ZScpO1xuICAgIHJldHVybiBjb21tb25fMS5yZW1vdmVVbmRlZmluZWQoe1xuICAgICAgICBhbW91bnQ6IGFtb3VudF8xLmRlZmF1bHQodHguQW1vdW50KS52YWx1ZSxcbiAgICAgICAgZGVzdGluYXRpb246IHR4LkRlc3RpbmF0aW9uLFxuICAgICAgICBtZW1vczogdXRpbHNfMS5wYXJzZU1lbW9zKHR4KSxcbiAgICAgICAgY29uZGl0aW9uOiB0eC5Db25kaXRpb24sXG4gICAgICAgIGFsbG93Q2FuY2VsQWZ0ZXI6IHV0aWxzXzEucGFyc2VUaW1lc3RhbXAodHguQ2FuY2VsQWZ0ZXIpLFxuICAgICAgICBhbGxvd0V4ZWN1dGVBZnRlcjogdXRpbHNfMS5wYXJzZVRpbWVzdGFtcCh0eC5GaW5pc2hBZnRlciksXG4gICAgICAgIHNvdXJjZVRhZzogdHguU291cmNlVGFnLFxuICAgICAgICBkZXN0aW5hdGlvblRhZzogdHguRGVzdGluYXRpb25UYWdcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlRXNjcm93Q3JlYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lc2Nyb3ctY3JlYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uXCIpO1xuZnVuY3Rpb24gcGFyc2VFc2Nyb3dFeGVjdXRpb24odHgpIHtcbiAgICBhc3NlcnQub2sodHguVHJhbnNhY3Rpb25UeXBlID09PSAnRXNjcm93RmluaXNoJyk7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgIG1lbW9zOiB1dGlsc18xLnBhcnNlTWVtb3ModHgpLFxuICAgICAgICBvd25lcjogdHguT3duZXIsXG4gICAgICAgIGVzY3Jvd1NlcXVlbmNlOiB0eC5PZmZlclNlcXVlbmNlLFxuICAgICAgICBjb25kaXRpb246IHR4LkNvbmRpdGlvbixcbiAgICAgICAgZnVsZmlsbG1lbnQ6IHR4LkZ1bGZpbGxtZW50XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZUVzY3Jvd0V4ZWN1dGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzY3Jvdy1leGVjdXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vblwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmZ1bmN0aW9uIHBhcnNlRmVlVXBkYXRlKHR4KSB7XG4gICAgY29uc3QgYmFzZUZlZURyb3BzID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQodHguQmFzZUZlZSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWVtb3M6IHV0aWxzXzEucGFyc2VNZW1vcyh0eCksXG4gICAgICAgIGJhc2VGZWVYUlA6IGNvbW1vbl8xLmRyb3BzVG9YcnAoYmFzZUZlZURyb3BzKSxcbiAgICAgICAgcmVmZXJlbmNlRmVlVW5pdHM6IHR4LlJlZmVyZW5jZUZlZVVuaXRzLFxuICAgICAgICByZXNlcnZlQmFzZVhSUDogY29tbW9uXzEuZHJvcHNUb1hycCh0eC5SZXNlcnZlQmFzZSksXG4gICAgICAgIHJlc2VydmVJbmNyZW1lbnRYUlA6IGNvbW1vbl8xLmRyb3BzVG9YcnAodHguUmVzZXJ2ZUluY3JlbWVudClcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VGZWVVcGRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZWUtdXBkYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XG5jb25zdCBBY2NvdW50RmllbGRzID0gY29tbW9uXzEuY29uc3RhbnRzLkFjY291bnRGaWVsZHM7XG5mdW5jdGlvbiBwYXJzZUZpZWxkKGluZm8sIHZhbHVlKSB7XG4gICAgaWYgKGluZm8uZW5jb2RpbmcgPT09ICdoZXgnICYmICFpbmZvLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICdoZXgnKS50b1N0cmluZygnYXNjaWknKTtcbiAgICB9XG4gICAgaWYgKGluZm8uc2hpZnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHZhbHVlKS5zaGlmdGVkQnkoLWluZm8uc2hpZnQpLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmllbGRzKGRhdGEpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHt9O1xuICAgIGZvciAoY29uc3QgZmllbGROYW1lIGluIEFjY291bnRGaWVsZHMpIHtcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGRhdGFbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IEFjY291bnRGaWVsZHNbZmllbGROYW1lXTtcbiAgICAgICAgICAgIHNldHRpbmdzW2luZm8ubmFtZV0gPSBwYXJzZUZpZWxkKGluZm8sIGZpZWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLlJlZ3VsYXJLZXkpIHtcbiAgICAgICAgc2V0dGluZ3MucmVndWxhcktleSA9IGRhdGEuUmVndWxhcktleTtcbiAgICB9XG4gICAgaWYgKGRhdGEuc2lnbmVyX2xpc3RzICYmIGRhdGEuc2lnbmVyX2xpc3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzZXR0aW5ncy5zaWduZXJzID0ge307XG4gICAgICAgIGlmIChkYXRhLnNpZ25lcl9saXN0c1swXS5TaWduZXJRdW9ydW0pIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNpZ25lcnMudGhyZXNob2xkID0gZGF0YS5zaWduZXJfbGlzdHNbMF0uU2lnbmVyUXVvcnVtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLnNpZ25lcl9saXN0c1swXS5TaWduZXJFbnRyaWVzKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zaWduZXJzLndlaWdodHMgPSBkYXRhLnNpZ25lcl9saXN0c1swXS5TaWduZXJFbnRyaWVzLm1hcCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBlbnRyeS5TaWduZXJFbnRyeS5BY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICB3ZWlnaHQ6IGVudHJ5LlNpZ25lckVudHJ5LlNpZ25lcldlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2V0dGluZ3M7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZUZpZWxkcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpZWxkcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJ1c3RsaW5lRmxhZ3MgPSBleHBvcnRzLm9yZGVyRmxhZ3MgPSB2b2lkIDA7XG5jb25zdCBvcmRlckZsYWdzID0ge1xuICAgIFBhc3NpdmU6IDB4MDAwMTAwMDAsXG4gICAgU2VsbDogMHgwMDAyMDAwMFxufTtcbmV4cG9ydHMub3JkZXJGbGFncyA9IG9yZGVyRmxhZ3M7XG5jb25zdCB0cnVzdGxpbmVGbGFncyA9IHtcbiAgICBMb3dSZXNlcnZlOiAweDAwMDEwMDAwLFxuICAgIEhpZ2hSZXNlcnZlOiAweDAwMDIwMDAwLFxuICAgIExvd0F1dGg6IDB4MDAwNDAwMDAsXG4gICAgSGlnaEF1dGg6IDB4MDAwODAwMDAsXG4gICAgTG93Tm9SaXBwbGU6IDB4MDAxMDAwMDAsXG4gICAgSGlnaE5vUmlwcGxlOiAweDAwMjAwMDAwLFxuICAgIExvd0ZyZWV6ZTogMHgwMDQwMDAwMCxcbiAgICBIaWdoRnJlZXplOiAweDAwODAwMDAwXG59O1xuZXhwb3J0cy50cnVzdGxpbmVGbGFncyA9IHRydXN0bGluZUZsYWdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmxhZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUxlZGdlciA9IHZvaWQgMDtcbmNvbnN0IF8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImxvZGFzaFwiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RyYW5zYWN0aW9uXCIpKTtcbmZ1bmN0aW9uIHBhcnNlVHJhbnNhY3Rpb25XcmFwcGVyKGxlZGdlclZlcnNpb24sIHR4KSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBPYmplY3QuYXNzaWduKHt9LCBfLm9taXQodHgsICdtZXRhRGF0YScpLCB7XG4gICAgICAgIG1ldGE6IHR4Lm1ldGFEYXRhLFxuICAgICAgICBsZWRnZXJfaW5kZXg6IGxlZGdlclZlcnNpb25cbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc2FjdGlvbl8xLmRlZmF1bHQodHJhbnNhY3Rpb24sIHRydWUpO1xuICAgIGlmICghcmVzdWx0Lm91dGNvbWUubGVkZ2VyVmVyc2lvbikge1xuICAgICAgICByZXN1bHQub3V0Y29tZS5sZWRnZXJWZXJzaW9uID0gbGVkZ2VyVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucywgbGVkZ2VyVmVyc2lvbikge1xuICAgIGlmIChfLmlzRW1wdHkodHJhbnNhY3Rpb25zKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25zWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyB0cmFuc2FjdGlvbkhhc2hlczogdHJhbnNhY3Rpb25zIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zYWN0aW9uczogdHJhbnNhY3Rpb25zLm1hcChfLnBhcnRpYWwocGFyc2VUcmFuc2FjdGlvbldyYXBwZXIsIGxlZGdlclZlcnNpb24pKVxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZVN0YXRlKHN0YXRlKSB7XG4gICAgaWYgKF8uaXNFbXB0eShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0YXRlWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4geyBzdGF0ZUhhc2hlczogc3RhdGUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmF3U3RhdGU6IEpTT04uc3RyaW5naWZ5KHN0YXRlKSB9O1xufVxuZnVuY3Rpb24gcGFyc2VMZWRnZXIobGVkZ2VyKSB7XG4gICAgY29uc3QgbGVkZ2VyVmVyc2lvbiA9IHBhcnNlSW50KGxlZGdlci5sZWRnZXJfaW5kZXgsIDEwKTtcbiAgICByZXR1cm4gY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBzdGF0ZUhhc2g6IGxlZGdlci5hY2NvdW50X2hhc2gsXG4gICAgICAgIGNsb3NlVGltZTogY29tbW9uXzEucmlwcGxlVGltZVRvSVNPODYwMShsZWRnZXIuY2xvc2VfdGltZSksXG4gICAgICAgIGNsb3NlVGltZVJlc29sdXRpb246IGxlZGdlci5jbG9zZV90aW1lX3Jlc29sdXRpb24sXG4gICAgICAgIGNsb3NlRmxhZ3M6IGxlZGdlci5jbG9zZV9mbGFncyxcbiAgICAgICAgbGVkZ2VySGFzaDogbGVkZ2VyLmxlZGdlcl9oYXNoLFxuICAgICAgICBsZWRnZXJWZXJzaW9uOiBsZWRnZXJWZXJzaW9uLFxuICAgICAgICBwYXJlbnRMZWRnZXJIYXNoOiBsZWRnZXIucGFyZW50X2hhc2gsXG4gICAgICAgIHBhcmVudENsb3NlVGltZTogY29tbW9uXzEucmlwcGxlVGltZVRvSVNPODYwMShsZWRnZXIucGFyZW50X2Nsb3NlX3RpbWUpLFxuICAgICAgICB0b3RhbERyb3BzOiBsZWRnZXIudG90YWxfY29pbnMsXG4gICAgICAgIHRyYW5zYWN0aW9uSGFzaDogbGVkZ2VyLnRyYW5zYWN0aW9uX2hhc2hcbiAgICB9LCBwYXJzZVRyYW5zYWN0aW9ucyhsZWRnZXIudHJhbnNhY3Rpb25zLCBsZWRnZXJWZXJzaW9uKSwgcGFyc2VTdGF0ZShsZWRnZXIuYWNjb3VudFN0YXRlKSkpO1xufVxuZXhwb3J0cy5wYXJzZUxlZGdlciA9IHBhcnNlTGVkZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGVkZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGFzc2VydCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGFtb3VudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Ftb3VudFwiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XG5jb25zdCBmbGFncyA9IGNvbW1vbl8xLnR4RmxhZ3MuT2ZmZXJDcmVhdGU7XG5mdW5jdGlvbiBwYXJzZU9yZGVyKHR4KSB7XG4gICAgYXNzZXJ0Lm9rKHR4LlRyYW5zYWN0aW9uVHlwZSA9PT0gJ09mZmVyQ3JlYXRlJyk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gKHR4LkZsYWdzICYgZmxhZ3MuU2VsbCkgPT09IDAgPyAnYnV5JyA6ICdzZWxsJztcbiAgICBjb25zdCB0YWtlckdldHNBbW91bnQgPSBhbW91bnRfMS5kZWZhdWx0KHR4LlRha2VyR2V0cyk7XG4gICAgY29uc3QgdGFrZXJQYXlzQW1vdW50ID0gYW1vdW50XzEuZGVmYXVsdCh0eC5UYWtlclBheXMpO1xuICAgIGNvbnN0IHF1YW50aXR5ID0gZGlyZWN0aW9uID09PSAnYnV5JyA/IHRha2VyUGF5c0Ftb3VudCA6IHRha2VyR2V0c0Ftb3VudDtcbiAgICBjb25zdCB0b3RhbFByaWNlID0gZGlyZWN0aW9uID09PSAnYnV5JyA/IHRha2VyR2V0c0Ftb3VudCA6IHRha2VyUGF5c0Ftb3VudDtcbiAgICByZXR1cm4gY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgbWVtb3M6IHV0aWxzXzIucGFyc2VNZW1vcyh0eCksXG4gICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICBxdWFudGl0eTogcXVhbnRpdHksXG4gICAgICAgIHRvdGFsUHJpY2U6IHRvdGFsUHJpY2UsXG4gICAgICAgIHBhc3NpdmU6ICh0eC5GbGFncyAmIGZsYWdzLlBhc3NpdmUpICE9PSAwIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgaW1tZWRpYXRlT3JDYW5jZWw6ICh0eC5GbGFncyAmIGZsYWdzLkltbWVkaWF0ZU9yQ2FuY2VsKSAhPT0gMCB8fCB1bmRlZmluZWQsXG4gICAgICAgIGZpbGxPcktpbGw6ICh0eC5GbGFncyAmIGZsYWdzLkZpbGxPcktpbGwpICE9PSAwIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IHV0aWxzXzEucGFyc2VUaW1lc3RhbXAodHguRXhwaXJhdGlvbilcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlT3JkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcmRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlT3JkZXJib29rT3JkZXIgPSB2b2lkIDA7XG5jb25zdCBfID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uXCIpO1xuY29uc3QgZmxhZ3NfMSA9IHJlcXVpcmUoXCIuL2ZsYWdzXCIpO1xuY29uc3QgYW1vdW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYW1vdW50XCIpKTtcbmZ1bmN0aW9uIHBhcnNlT3JkZXJib29rT3JkZXIoZGF0YSkge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IChkYXRhLkZsYWdzICYgZmxhZ3NfMS5vcmRlckZsYWdzLlNlbGwpID09PSAwID8gJ2J1eScgOiAnc2VsbCc7XG4gICAgY29uc3QgdGFrZXJHZXRzQW1vdW50ID0gYW1vdW50XzEuZGVmYXVsdChkYXRhLlRha2VyR2V0cyk7XG4gICAgY29uc3QgdGFrZXJQYXlzQW1vdW50ID0gYW1vdW50XzEuZGVmYXVsdChkYXRhLlRha2VyUGF5cyk7XG4gICAgY29uc3QgcXVhbnRpdHkgPSBkaXJlY3Rpb24gPT09ICdidXknID8gdGFrZXJQYXlzQW1vdW50IDogdGFrZXJHZXRzQW1vdW50O1xuICAgIGNvbnN0IHRvdGFsUHJpY2UgPSBkaXJlY3Rpb24gPT09ICdidXknID8gdGFrZXJHZXRzQW1vdW50IDogdGFrZXJQYXlzQW1vdW50O1xuICAgIGNvbnN0IHNwZWNpZmljYXRpb24gPSBjb21tb25fMS5yZW1vdmVVbmRlZmluZWQoe1xuICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgcXVhbnRpdHk6IHF1YW50aXR5LFxuICAgICAgICB0b3RhbFByaWNlOiB0b3RhbFByaWNlLFxuICAgICAgICBwYXNzaXZlOiAoZGF0YS5GbGFncyAmIGZsYWdzXzEub3JkZXJGbGFncy5QYXNzaXZlKSAhPT0gMCB8fCB1bmRlZmluZWQsXG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiB1dGlsc18xLnBhcnNlVGltZXN0YW1wKGRhdGEuRXhwaXJhdGlvbilcbiAgICB9KTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBtYWtlcjogZGF0YS5BY2NvdW50LFxuICAgICAgICBzZXF1ZW5jZTogZGF0YS5TZXF1ZW5jZSxcbiAgICAgICAgbWFrZXJFeGNoYW5nZVJhdGU6IHV0aWxzXzEuYWRqdXN0UXVhbGl0eUZvclhSUChkYXRhLnF1YWxpdHksIHRha2VyR2V0c0Ftb3VudC5jdXJyZW5jeSwgdGFrZXJQYXlzQW1vdW50LmN1cnJlbmN5KVxuICAgIH07XG4gICAgY29uc3QgdGFrZXJHZXRzRnVuZGVkID0gZGF0YS50YWtlcl9nZXRzX2Z1bmRlZFxuICAgICAgICA/IGFtb3VudF8xLmRlZmF1bHQoZGF0YS50YWtlcl9nZXRzX2Z1bmRlZClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgdGFrZXJQYXlzRnVuZGVkID0gZGF0YS50YWtlcl9wYXlzX2Z1bmRlZFxuICAgICAgICA/IGFtb3VudF8xLmRlZmF1bHQoZGF0YS50YWtlcl9wYXlzX2Z1bmRlZClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgYXZhaWxhYmxlID0gY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgZnVuZGVkQW1vdW50OiB0YWtlckdldHNGdW5kZWQsXG4gICAgICAgIHByaWNlT2ZGdW5kZWRBbW91bnQ6IHRha2VyUGF5c0Z1bmRlZFxuICAgIH0pO1xuICAgIGNvbnN0IHN0YXRlID0gXy5pc0VtcHR5KGF2YWlsYWJsZSkgPyB1bmRlZmluZWQgOiBhdmFpbGFibGU7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZCh7IHNwZWNpZmljYXRpb24sIHByb3BlcnRpZXMsIHN0YXRlLCBkYXRhIH0pO1xufVxuZXhwb3J0cy5wYXJzZU9yZGVyYm9va09yZGVyID0gcGFyc2VPcmRlcmJvb2tPcmRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yZGVyYm9vay1vcmRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBfID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuY29uc3QgYW1vdW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYW1vdW50XCIpKTtcbmZ1bmN0aW9uIHBhcnNlUGF0aHMocGF0aHMpIHtcbiAgICByZXR1cm4gcGF0aHMubWFwKChzdGVwcykgPT4gc3RlcHMubWFwKChzdGVwKSA9PiBfLm9taXQoc3RlcCwgWyd0eXBlJywgJ3R5cGVfaGV4J10pKSk7XG59XG5mdW5jdGlvbiByZW1vdmVBbnlDb3VudGVycGFydHlFbmNvZGluZyhhZGRyZXNzLCBhbW91bnQpIHtcbiAgICByZXR1cm4gYW1vdW50LmNvdW50ZXJwYXJ0eSA9PT0gYWRkcmVzc1xuICAgICAgICA/IF8ub21pdChhbW91bnQsICdjb3VudGVycGFydHknKVxuICAgICAgICA6IGFtb3VudDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFkanVzdG1lbnQoYWRkcmVzcywgYWRqdXN0bWVudFdpdGhvdXRBZGRyZXNzKSB7XG4gICAgY29uc3QgYW1vdW50S2V5ID0gT2JqZWN0LmtleXMoYWRqdXN0bWVudFdpdGhvdXRBZGRyZXNzKVswXTtcbiAgICBjb25zdCBhbW91bnQgPSBhZGp1c3RtZW50V2l0aG91dEFkZHJlc3NbYW1vdW50S2V5XTtcbiAgICByZXR1cm4gXy5zZXQoeyBhZGRyZXNzOiBhZGRyZXNzIH0sIGFtb3VudEtleSwgcmVtb3ZlQW55Q291bnRlcnBhcnR5RW5jb2RpbmcoYWRkcmVzcywgYW1vdW50KSk7XG59XG5mdW5jdGlvbiBwYXJzZUFsdGVybmF0aXZlKHNvdXJjZUFkZHJlc3MsIGRlc3RpbmF0aW9uQWRkcmVzcywgZGVzdGluYXRpb25BbW91bnQsIGFsdGVybmF0aXZlKSB7XG4gICAgY29uc3QgYW1vdW50cyA9IGFsdGVybmF0aXZlLmRlc3RpbmF0aW9uX2Ftb3VudCAhPSBudWxsXG4gICAgICAgID8ge1xuICAgICAgICAgICAgc291cmNlOiB7IGFtb3VudDogYW1vdW50XzEuZGVmYXVsdChhbHRlcm5hdGl2ZS5zb3VyY2VfYW1vdW50KSB9LFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHsgbWluQW1vdW50OiBhbW91bnRfMS5kZWZhdWx0KGFsdGVybmF0aXZlLmRlc3RpbmF0aW9uX2Ftb3VudCkgfVxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgc291cmNlOiB7IG1heEFtb3VudDogYW1vdW50XzEuZGVmYXVsdChhbHRlcm5hdGl2ZS5zb3VyY2VfYW1vdW50KSB9LFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHsgYW1vdW50OiBhbW91bnRfMS5kZWZhdWx0KGRlc3RpbmF0aW9uQW1vdW50KSB9XG4gICAgICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBjcmVhdGVBZGp1c3RtZW50KHNvdXJjZUFkZHJlc3MsIGFtb3VudHMuc291cmNlKSxcbiAgICAgICAgZGVzdGluYXRpb246IGNyZWF0ZUFkanVzdG1lbnQoZGVzdGluYXRpb25BZGRyZXNzLCBhbW91bnRzLmRlc3RpbmF0aW9uKSxcbiAgICAgICAgcGF0aHM6IEpTT04uc3RyaW5naWZ5KHBhcnNlUGF0aHMoYWx0ZXJuYXRpdmUucGF0aHNfY29tcHV0ZWQpKVxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZVBhdGhmaW5kKHBhdGhmaW5kUmVzdWx0KSB7XG4gICAgY29uc3Qgc291cmNlQWRkcmVzcyA9IHBhdGhmaW5kUmVzdWx0LnNvdXJjZV9hY2NvdW50O1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uQWRkcmVzcyA9IHBhdGhmaW5kUmVzdWx0LmRlc3RpbmF0aW9uX2FjY291bnQ7XG4gICAgY29uc3QgZGVzdGluYXRpb25BbW91bnQgPSBwYXRoZmluZFJlc3VsdC5kZXN0aW5hdGlvbl9hbW91bnQ7XG4gICAgcmV0dXJuIHBhdGhmaW5kUmVzdWx0LmFsdGVybmF0aXZlcy5tYXAoKGFsdCkgPT4gcGFyc2VBbHRlcm5hdGl2ZShzb3VyY2VBZGRyZXNzLCBkZXN0aW5hdGlvbkFkZHJlc3MsIGRlc3RpbmF0aW9uQW1vdW50LCBhbHQpKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlUGF0aGZpbmQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoZmluZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XG5jb25zdCBhbW91bnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hbW91bnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY2xhaW1GbGFncyA9IGNvbW1vbl8xLnR4RmxhZ3MuUGF5bWVudENoYW5uZWxDbGFpbTtcbmZ1bmN0aW9uIHBhcnNlUGF5bWVudENoYW5uZWxDbGFpbSh0eCkge1xuICAgIGFzc2VydC5vayh0eC5UcmFuc2FjdGlvblR5cGUgPT09ICdQYXltZW50Q2hhbm5lbENsYWltJyk7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgIG1lbW9zOiB1dGlsc18xLnBhcnNlTWVtb3ModHgpLFxuICAgICAgICBjaGFubmVsOiB0eC5DaGFubmVsLFxuICAgICAgICBiYWxhbmNlOiB0eC5CYWxhbmNlICYmIGFtb3VudF8xLmRlZmF1bHQodHguQmFsYW5jZSkudmFsdWUsXG4gICAgICAgIGFtb3VudDogdHguQW1vdW50ICYmIGFtb3VudF8xLmRlZmF1bHQodHguQW1vdW50KS52YWx1ZSxcbiAgICAgICAgc2lnbmF0dXJlOiB0eC5TaWduYXR1cmUsXG4gICAgICAgIHB1YmxpY0tleTogdHguUHVibGljS2V5LFxuICAgICAgICByZW5ldzogQm9vbGVhbih0eC5GbGFncyAmIGNsYWltRmxhZ3MuUmVuZXcpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgY2xvc2U6IEJvb2xlYW4odHguRmxhZ3MgJiBjbGFpbUZsYWdzLkNsb3NlKSB8fCB1bmRlZmluZWRcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlUGF5bWVudENoYW5uZWxDbGFpbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBheW1lbnQtY2hhbm5lbC1jbGFpbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XG5jb25zdCBhbW91bnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hbW91bnRcIikpO1xuZnVuY3Rpb24gcGFyc2VQYXltZW50Q2hhbm5lbENyZWF0ZSh0eCkge1xuICAgIGFzc2VydC5vayh0eC5UcmFuc2FjdGlvblR5cGUgPT09ICdQYXltZW50Q2hhbm5lbENyZWF0ZScpO1xuICAgIHJldHVybiBjb21tb25fMS5yZW1vdmVVbmRlZmluZWQoe1xuICAgICAgICBtZW1vczogdXRpbHNfMS5wYXJzZU1lbW9zKHR4KSxcbiAgICAgICAgYW1vdW50OiBhbW91bnRfMS5kZWZhdWx0KHR4LkFtb3VudCkudmFsdWUsXG4gICAgICAgIGRlc3RpbmF0aW9uOiB0eC5EZXN0aW5hdGlvbixcbiAgICAgICAgc2V0dGxlRGVsYXk6IHR4LlNldHRsZURlbGF5LFxuICAgICAgICBwdWJsaWNLZXk6IHR4LlB1YmxpY0tleSxcbiAgICAgICAgY2FuY2VsQWZ0ZXI6IHR4LkNhbmNlbEFmdGVyICYmIHV0aWxzXzEucGFyc2VUaW1lc3RhbXAodHguQ2FuY2VsQWZ0ZXIpLFxuICAgICAgICBzb3VyY2VUYWc6IHR4LlNvdXJjZVRhZyxcbiAgICAgICAgZGVzdGluYXRpb25UYWc6IHR4LkRlc3RpbmF0aW9uVGFnXG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZVBheW1lbnRDaGFubmVsQ3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF5bWVudC1jaGFubmVsLWNyZWF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIik7XG5jb25zdCBhbW91bnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hbW91bnRcIikpO1xuZnVuY3Rpb24gcGFyc2VQYXltZW50Q2hhbm5lbEZ1bmQodHgpIHtcbiAgICBhc3NlcnQub2sodHguVHJhbnNhY3Rpb25UeXBlID09PSAnUGF5bWVudENoYW5uZWxGdW5kJyk7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgIG1lbW9zOiB1dGlsc18xLnBhcnNlTWVtb3ModHgpLFxuICAgICAgICBjaGFubmVsOiB0eC5DaGFubmVsLFxuICAgICAgICBhbW91bnQ6IGFtb3VudF8xLmRlZmF1bHQodHguQW1vdW50KS52YWx1ZSxcbiAgICAgICAgZXhwaXJhdGlvbjogdHguRXhwaXJhdGlvbiAmJiB1dGlsc18xLnBhcnNlVGltZXN0YW1wKHR4LkV4cGlyYXRpb24pXG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZVBheW1lbnRDaGFubmVsRnVuZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBheW1lbnQtY2hhbm5lbC1mdW5kLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZVBheW1lbnRDaGFubmVsID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uXCIpO1xuZnVuY3Rpb24gcGFyc2VQYXltZW50Q2hhbm5lbChkYXRhKSB7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgIG1lbW9zOiB1dGlsc18xLnBhcnNlTWVtb3MoZGF0YSksXG4gICAgICAgIGFjY291bnQ6IGRhdGEuQWNjb3VudCxcbiAgICAgICAgYW1vdW50OiBjb21tb25fMS5kcm9wc1RvWHJwKGRhdGEuQW1vdW50KSxcbiAgICAgICAgYmFsYW5jZTogY29tbW9uXzEuZHJvcHNUb1hycChkYXRhLkJhbGFuY2UpLFxuICAgICAgICBkZXN0aW5hdGlvbjogZGF0YS5EZXN0aW5hdGlvbixcbiAgICAgICAgcHVibGljS2V5OiBkYXRhLlB1YmxpY0tleSxcbiAgICAgICAgc2V0dGxlRGVsYXk6IGRhdGEuU2V0dGxlRGVsYXksXG4gICAgICAgIGV4cGlyYXRpb246IHV0aWxzXzEucGFyc2VUaW1lc3RhbXAoZGF0YS5FeHBpcmF0aW9uKSxcbiAgICAgICAgY2FuY2VsQWZ0ZXI6IHV0aWxzXzEucGFyc2VUaW1lc3RhbXAoZGF0YS5DYW5jZWxBZnRlciksXG4gICAgICAgIHNvdXJjZVRhZzogZGF0YS5Tb3VyY2VUYWcsXG4gICAgICAgIGRlc3RpbmF0aW9uVGFnOiBkYXRhLkRlc3RpbmF0aW9uVGFnLFxuICAgICAgICBwcmV2aW91c0FmZmVjdGluZ1RyYW5zYWN0aW9uSUQ6IGRhdGEuUHJldmlvdXNUeG5JRCxcbiAgICAgICAgcHJldmlvdXNBZmZlY3RpbmdUcmFuc2FjdGlvbkxlZGdlclZlcnNpb246IGRhdGEuUHJldmlvdXNUeG5MZ3JTZXFcbiAgICB9KTtcbn1cbmV4cG9ydHMucGFyc2VQYXltZW50Q2hhbm5lbCA9IHBhcnNlUGF5bWVudENoYW5uZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXltZW50LWNoYW5uZWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgXyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibG9kYXNoXCIpKTtcbmNvbnN0IGFzc2VydCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiYXNzZXJ0XCIpKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vblwiKTtcbmNvbnN0IGFtb3VudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2Ftb3VudFwiKSk7XG5mdW5jdGlvbiBpc05vRGlyZWN0UmlwcGxlKHR4KSB7XG4gICAgcmV0dXJuICh0eC5GbGFncyAmIGNvbW1vbl8xLnR4RmxhZ3MuUGF5bWVudC5Ob1JpcHBsZURpcmVjdCkgIT09IDA7XG59XG5mdW5jdGlvbiBpc1F1YWxpdHlMaW1pdGVkKHR4KSB7XG4gICAgcmV0dXJuICh0eC5GbGFncyAmIGNvbW1vbl8xLnR4RmxhZ3MuUGF5bWVudC5MaW1pdFF1YWxpdHkpICE9PSAwO1xufVxuZnVuY3Rpb24gcmVtb3ZlR2VuZXJpY0NvdW50ZXJwYXJ0eShhbW91bnQsIGFkZHJlc3MpIHtcbiAgICByZXR1cm4gYW1vdW50LmNvdW50ZXJwYXJ0eSA9PT0gYWRkcmVzc1xuICAgICAgICA/IF8ub21pdChhbW91bnQsICdjb3VudGVycGFydHknKVxuICAgICAgICA6IGFtb3VudDtcbn1cbmZ1bmN0aW9uIHBhcnNlUGF5bWVudCh0eCkge1xuICAgIGFzc2VydC5vayh0eC5UcmFuc2FjdGlvblR5cGUgPT09ICdQYXltZW50Jyk7XG4gICAgY29uc3Qgc291cmNlID0ge1xuICAgICAgICBhZGRyZXNzOiB0eC5BY2NvdW50LFxuICAgICAgICBtYXhBbW91bnQ6IHJlbW92ZUdlbmVyaWNDb3VudGVycGFydHkoYW1vdW50XzEuZGVmYXVsdCh0eC5TZW5kTWF4IHx8IHR4LkFtb3VudCksIHR4LkFjY291bnQpLFxuICAgICAgICB0YWc6IHR4LlNvdXJjZVRhZ1xuICAgIH07XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB7XG4gICAgICAgIGFkZHJlc3M6IHR4LkRlc3RpbmF0aW9uLFxuICAgICAgICB0YWc6IHR4LkRlc3RpbmF0aW9uVGFnXG4gICAgfTtcbiAgICByZXR1cm4gY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgc291cmNlOiBjb21tb25fMS5yZW1vdmVVbmRlZmluZWQoc291cmNlKSxcbiAgICAgICAgZGVzdGluYXRpb246IGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZChkZXN0aW5hdGlvbiksXG4gICAgICAgIG1lbW9zOiB1dGlscy5wYXJzZU1lbW9zKHR4KSxcbiAgICAgICAgaW52b2ljZUlEOiB0eC5JbnZvaWNlSUQsXG4gICAgICAgIHBhdGhzOiB0eC5QYXRocyA/IEpTT04uc3RyaW5naWZ5KHR4LlBhdGhzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgYWxsb3dQYXJ0aWFsUGF5bWVudDogdXRpbHMuaXNQYXJ0aWFsUGF5bWVudCh0eCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBub0RpcmVjdFJpcHBsZTogaXNOb0RpcmVjdFJpcHBsZSh0eCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICBsaW1pdFF1YWxpdHk6IGlzUXVhbGl0eUxpbWl0ZWQodHgpIHx8IHVuZGVmaW5lZFxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VQYXltZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF5bWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBfID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uXCIpO1xuY29uc3QgQWNjb3VudEZsYWdzID0gY29tbW9uXzEuY29uc3RhbnRzLkFjY291bnRGbGFncztcbmNvbnN0IGZpZWxkc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZpZWxkc1wiKSk7XG5mdW5jdGlvbiBnZXRBY2NvdW50Um9vdE1vZGlmaWVkTm9kZSh0eCkge1xuICAgIGNvbnN0IG1vZGlmaWVkTm9kZXMgPSB0eC5tZXRhLkFmZmVjdGVkTm9kZXMuZmlsdGVyKG5vZGUgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gbm9kZS5Nb2RpZmllZE5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5MZWRnZXJFbnRyeVR5cGUpID09PSAnQWNjb3VudFJvb3QnOyB9KTtcbiAgICBhc3NlcnQub2sobW9kaWZpZWROb2Rlcy5sZW5ndGggPT09IDEpO1xuICAgIHJldHVybiBtb2RpZmllZE5vZGVzWzBdLk1vZGlmaWVkTm9kZTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmxhZ3ModHgpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHt9O1xuICAgIGlmICh0eC5UcmFuc2FjdGlvblR5cGUgIT09ICdBY2NvdW50U2V0Jykge1xuICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBnZXRBY2NvdW50Um9vdE1vZGlmaWVkTm9kZSh0eCk7XG4gICAgY29uc3Qgb2xkRmxhZ3MgPSBfLmdldChub2RlLlByZXZpb3VzRmllbGRzLCAnRmxhZ3MnKTtcbiAgICBjb25zdCBuZXdGbGFncyA9IF8uZ2V0KG5vZGUuRmluYWxGaWVsZHMsICdGbGFncycpO1xuICAgIGlmIChvbGRGbGFncyAhPSBudWxsICYmIG5ld0ZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlZEZsYWdzID0gb2xkRmxhZ3MgXiBuZXdGbGFncztcbiAgICAgICAgY29uc3Qgc2V0RmxhZ3MgPSBuZXdGbGFncyAmIGNoYW5nZWRGbGFncztcbiAgICAgICAgY29uc3QgY2xlYXJlZEZsYWdzID0gb2xkRmxhZ3MgJiBjaGFuZ2VkRmxhZ3M7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKEFjY291bnRGbGFncykuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbZmxhZ05hbWUsIGZsYWdWYWx1ZV0gPSBlbnRyeTtcbiAgICAgICAgICAgIGlmIChzZXRGbGFncyAmIGZsYWdWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW2ZsYWdOYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbGVhcmVkRmxhZ3MgJiBmbGFnVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1tmbGFnTmFtZV0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG9sZEZpZWxkID0gXy5nZXQobm9kZS5QcmV2aW91c0ZpZWxkcywgJ0FjY291bnRUeG5JRCcpO1xuICAgIGNvbnN0IG5ld0ZpZWxkID0gXy5nZXQobm9kZS5GaW5hbEZpZWxkcywgJ0FjY291bnRUeG5JRCcpO1xuICAgIGlmIChuZXdGaWVsZCAmJiAhb2xkRmllbGQpIHtcbiAgICAgICAgc2V0dGluZ3MuZW5hYmxlVHJhbnNhY3Rpb25JRFRyYWNraW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2xkRmllbGQgJiYgIW5ld0ZpZWxkKSB7XG4gICAgICAgIHNldHRpbmdzLmVuYWJsZVRyYW5zYWN0aW9uSURUcmFja2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc2V0dGluZ3M7XG59XG5mdW5jdGlvbiBwYXJzZVNldHRpbmdzKHR4KSB7XG4gICAgY29uc3QgdHhUeXBlID0gdHguVHJhbnNhY3Rpb25UeXBlO1xuICAgIGFzc2VydC5vayh0eFR5cGUgPT09ICdBY2NvdW50U2V0JyB8fFxuICAgICAgICB0eFR5cGUgPT09ICdTZXRSZWd1bGFyS2V5JyB8fFxuICAgICAgICB0eFR5cGUgPT09ICdTaWduZXJMaXN0U2V0Jyk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHBhcnNlRmxhZ3ModHgpLCBmaWVsZHNfMS5kZWZhdWx0KHR4KSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZVNldHRpbmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gcGFyc2VUaWNrZXRDcmVhdGUodHgpIHtcbiAgICBhc3NlcnQub2sodHguVHJhbnNhY3Rpb25UeXBlID09PSAnVGlja2V0Q3JlYXRlJyk7XG4gICAgcmV0dXJuIGNvbW1vbl8xLnJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgIG1lbW9zOiB1dGlsc18xLnBhcnNlTWVtb3ModHgpLFxuICAgICAgICB0aWNrZXRDb3VudDogdHguVGlja2V0Q291bnRcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlVGlja2V0Q3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGlja2V0LWNyZWF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vblwiKTtcbmNvbnN0IHNldHRpbmdzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vc2V0dGluZ3NcIikpO1xuY29uc3QgYWNjb3VudF9kZWxldGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9hY2NvdW50LWRlbGV0ZVwiKSk7XG5jb25zdCBjaGVja19jYW5jZWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jaGVjay1jYW5jZWxcIikpO1xuY29uc3QgY2hlY2tfY2FzaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NoZWNrLWNhc2hcIikpO1xuY29uc3QgY2hlY2tfY3JlYXRlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY2hlY2stY3JlYXRlXCIpKTtcbmNvbnN0IGRlcG9zaXRfcHJlYXV0aF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2RlcG9zaXQtcHJlYXV0aFwiKSk7XG5jb25zdCBlc2Nyb3dfY2FuY2VsbGF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZXNjcm93LWNhbmNlbGxhdGlvblwiKSk7XG5jb25zdCBlc2Nyb3dfY3JlYXRpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9lc2Nyb3ctY3JlYXRpb25cIikpO1xuY29uc3QgZXNjcm93X2V4ZWN1dGlvbl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2VzY3Jvdy1leGVjdXRpb25cIikpO1xuY29uc3QgY2FuY2VsbGF0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY2FuY2VsbGF0aW9uXCIpKTtcbmNvbnN0IG9yZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vb3JkZXJcIikpO1xuY29uc3QgcGF5bWVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BheW1lbnRcIikpO1xuY29uc3QgcGF5bWVudF9jaGFubmVsX2NsYWltXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGF5bWVudC1jaGFubmVsLWNsYWltXCIpKTtcbmNvbnN0IHBheW1lbnRfY2hhbm5lbF9jcmVhdGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXltZW50LWNoYW5uZWwtY3JlYXRlXCIpKTtcbmNvbnN0IHBheW1lbnRfY2hhbm5lbF9mdW5kXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGF5bWVudC1jaGFubmVsLWZ1bmRcIikpO1xuY29uc3QgdGlja2V0X2NyZWF0ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RpY2tldC1jcmVhdGVcIikpO1xuY29uc3QgdHJ1c3RsaW5lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdHJ1c3RsaW5lXCIpKTtcbmNvbnN0IGFtZW5kbWVudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2FtZW5kbWVudFwiKSk7XG5jb25zdCBmZWVfdXBkYXRlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZmVlLXVwZGF0ZVwiKSk7XG5mdW5jdGlvbiBwYXJzZVRyYW5zYWN0aW9uVHlwZSh0eXBlKSB7XG4gICAgY29uc3QgbWFwcGluZyA9IHtcbiAgICAgICAgQWNjb3VudFNldDogJ3NldHRpbmdzJyxcbiAgICAgICAgQWNjb3VudERlbGV0ZTogJ2FjY291bnREZWxldGUnLFxuICAgICAgICBDaGVja0NhbmNlbDogJ2NoZWNrQ2FuY2VsJyxcbiAgICAgICAgQ2hlY2tDYXNoOiAnY2hlY2tDYXNoJyxcbiAgICAgICAgQ2hlY2tDcmVhdGU6ICdjaGVja0NyZWF0ZScsXG4gICAgICAgIERlcG9zaXRQcmVhdXRoOiAnZGVwb3NpdFByZWF1dGgnLFxuICAgICAgICBFc2Nyb3dDYW5jZWw6ICdlc2Nyb3dDYW5jZWxsYXRpb24nLFxuICAgICAgICBFc2Nyb3dDcmVhdGU6ICdlc2Nyb3dDcmVhdGlvbicsXG4gICAgICAgIEVzY3Jvd0ZpbmlzaDogJ2VzY3Jvd0V4ZWN1dGlvbicsXG4gICAgICAgIE9mZmVyQ2FuY2VsOiAnb3JkZXJDYW5jZWxsYXRpb24nLFxuICAgICAgICBPZmZlckNyZWF0ZTogJ29yZGVyJyxcbiAgICAgICAgUGF5bWVudDogJ3BheW1lbnQnLFxuICAgICAgICBQYXltZW50Q2hhbm5lbENsYWltOiAncGF5bWVudENoYW5uZWxDbGFpbScsXG4gICAgICAgIFBheW1lbnRDaGFubmVsQ3JlYXRlOiAncGF5bWVudENoYW5uZWxDcmVhdGUnLFxuICAgICAgICBQYXltZW50Q2hhbm5lbEZ1bmQ6ICdwYXltZW50Q2hhbm5lbEZ1bmQnLFxuICAgICAgICBTZXRSZWd1bGFyS2V5OiAnc2V0dGluZ3MnLFxuICAgICAgICBTaWduZXJMaXN0U2V0OiAnc2V0dGluZ3MnLFxuICAgICAgICBUaWNrZXRDcmVhdGU6ICd0aWNrZXRDcmVhdGUnLFxuICAgICAgICBUcnVzdFNldDogJ3RydXN0bGluZScsXG4gICAgICAgIEVuYWJsZUFtZW5kbWVudDogJ2FtZW5kbWVudCcsXG4gICAgICAgIFNldEZlZTogJ2ZlZVVwZGF0ZSdcbiAgICB9O1xuICAgIHJldHVybiBtYXBwaW5nW3R5cGVdIHx8IG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZVRyYW5zYWN0aW9uKHR4LCBpbmNsdWRlUmF3VHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCB0eXBlID0gcGFyc2VUcmFuc2FjdGlvblR5cGUodHguVHJhbnNhY3Rpb25UeXBlKTtcbiAgICBjb25zdCBtYXBwaW5nID0ge1xuICAgICAgICBzZXR0aW5nczogc2V0dGluZ3NfMS5kZWZhdWx0LFxuICAgICAgICBhY2NvdW50RGVsZXRlOiBhY2NvdW50X2RlbGV0ZV8xLmRlZmF1bHQsXG4gICAgICAgIGNoZWNrQ2FuY2VsOiBjaGVja19jYW5jZWxfMS5kZWZhdWx0LFxuICAgICAgICBjaGVja0Nhc2g6IGNoZWNrX2Nhc2hfMS5kZWZhdWx0LFxuICAgICAgICBjaGVja0NyZWF0ZTogY2hlY2tfY3JlYXRlXzEuZGVmYXVsdCxcbiAgICAgICAgZGVwb3NpdFByZWF1dGg6IGRlcG9zaXRfcHJlYXV0aF8xLmRlZmF1bHQsXG4gICAgICAgIGVzY3Jvd0NhbmNlbGxhdGlvbjogZXNjcm93X2NhbmNlbGxhdGlvbl8xLmRlZmF1bHQsXG4gICAgICAgIGVzY3Jvd0NyZWF0aW9uOiBlc2Nyb3dfY3JlYXRpb25fMS5kZWZhdWx0LFxuICAgICAgICBlc2Nyb3dFeGVjdXRpb246IGVzY3Jvd19leGVjdXRpb25fMS5kZWZhdWx0LFxuICAgICAgICBvcmRlckNhbmNlbGxhdGlvbjogY2FuY2VsbGF0aW9uXzEuZGVmYXVsdCxcbiAgICAgICAgb3JkZXI6IG9yZGVyXzEuZGVmYXVsdCxcbiAgICAgICAgcGF5bWVudDogcGF5bWVudF8xLmRlZmF1bHQsXG4gICAgICAgIHBheW1lbnRDaGFubmVsQ2xhaW06IHBheW1lbnRfY2hhbm5lbF9jbGFpbV8xLmRlZmF1bHQsXG4gICAgICAgIHBheW1lbnRDaGFubmVsQ3JlYXRlOiBwYXltZW50X2NoYW5uZWxfY3JlYXRlXzEuZGVmYXVsdCxcbiAgICAgICAgcGF5bWVudENoYW5uZWxGdW5kOiBwYXltZW50X2NoYW5uZWxfZnVuZF8xLmRlZmF1bHQsXG4gICAgICAgIHRpY2tldENyZWF0ZTogdGlja2V0X2NyZWF0ZV8xLmRlZmF1bHQsXG4gICAgICAgIHRydXN0bGluZTogdHJ1c3RsaW5lXzEuZGVmYXVsdCxcbiAgICAgICAgYW1lbmRtZW50OiBhbWVuZG1lbnRfMS5kZWZhdWx0LFxuICAgICAgICBmZWVVcGRhdGU6IGZlZV91cGRhdGVfMS5kZWZhdWx0XG4gICAgfTtcbiAgICBjb25zdCBwYXJzZXIgPSBtYXBwaW5nW3R5cGVdO1xuICAgIGNvbnN0IHNwZWNpZmljYXRpb24gPSBwYXJzZXJcbiAgICAgICAgPyBwYXJzZXIodHgpXG4gICAgICAgIDoge1xuICAgICAgICAgICAgVU5BVkFJTEFCTEU6ICdVbnJlY29nbml6ZWQgdHJhbnNhY3Rpb24gdHlwZS4nLFxuICAgICAgICAgICAgU0VFX1JBV19UUkFOU0FDVElPTjogJ1NpbmNlIHRoaXMgdHlwZSBpcyB1bnJlY29nbml6ZWQsIGByYXdUcmFuc2FjdGlvbmAgaXMgaW5jbHVkZWQgaW4gdGhpcyByZXNwb25zZS4nXG4gICAgICAgIH07XG4gICAgaWYgKCFwYXJzZXIpIHtcbiAgICAgICAgaW5jbHVkZVJhd1RyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgb3V0Y29tZSA9IHV0aWxzXzEucGFyc2VPdXRjb21lKHR4KTtcbiAgICByZXR1cm4gY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgYWRkcmVzczogdHguQWNjb3VudCxcbiAgICAgICAgc2VxdWVuY2U6IHR4LlNlcXVlbmNlLFxuICAgICAgICBpZDogdHguaGFzaCxcbiAgICAgICAgc3BlY2lmaWNhdGlvbjogY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKHNwZWNpZmljYXRpb24pLFxuICAgICAgICBvdXRjb21lOiBvdXRjb21lID8gY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKG91dGNvbWUpIDogdW5kZWZpbmVkLFxuICAgICAgICByYXdUcmFuc2FjdGlvbjogaW5jbHVkZVJhd1RyYW5zYWN0aW9uID8gSlNPTi5zdHJpbmdpZnkodHgpIDogdW5kZWZpbmVkXG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZVRyYW5zYWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uXCIpO1xuY29uc3QgZmxhZ3MgPSBjb21tb25fMS50eEZsYWdzLlRydXN0U2V0O1xuZnVuY3Rpb24gcGFyc2VGbGFnKGZsYWdzVmFsdWUsIHRydWVWYWx1ZSwgZmFsc2VWYWx1ZSkge1xuICAgIGlmIChmbGFnc1ZhbHVlICYgdHJ1ZVZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZmxhZ3NWYWx1ZSAmIGZhbHNlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcGFyc2VUcnVzdGxpbmUodHgpIHtcbiAgICBhc3NlcnQub2sodHguVHJhbnNhY3Rpb25UeXBlID09PSAnVHJ1c3RTZXQnKTtcbiAgICByZXR1cm4gY29tbW9uXzEucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgbGltaXQ6IHR4LkxpbWl0QW1vdW50LnZhbHVlLFxuICAgICAgICBjdXJyZW5jeTogdHguTGltaXRBbW91bnQuY3VycmVuY3ksXG4gICAgICAgIGNvdW50ZXJwYXJ0eTogdHguTGltaXRBbW91bnQuaXNzdWVyLFxuICAgICAgICBtZW1vczogdXRpbHNfMS5wYXJzZU1lbW9zKHR4KSxcbiAgICAgICAgcXVhbGl0eUluOiB1dGlsc18xLnBhcnNlUXVhbGl0eSh0eC5RdWFsaXR5SW4pLFxuICAgICAgICBxdWFsaXR5T3V0OiB1dGlsc18xLnBhcnNlUXVhbGl0eSh0eC5RdWFsaXR5T3V0KSxcbiAgICAgICAgcmlwcGxpbmdEaXNhYmxlZDogcGFyc2VGbGFnKHR4LkZsYWdzLCBmbGFncy5TZXROb1JpcHBsZSwgZmxhZ3MuQ2xlYXJOb1JpcHBsZSksXG4gICAgICAgIGZyb3plbjogcGFyc2VGbGFnKHR4LkZsYWdzLCBmbGFncy5TZXRGcmVlemUsIGZsYWdzLkNsZWFyRnJlZXplKSxcbiAgICAgICAgYXV0aG9yaXplZDogcGFyc2VGbGFnKHR4LkZsYWdzLCBmbGFncy5TZXRBdXRoLCAwKVxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gcGFyc2VUcnVzdGxpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cnVzdGxpbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1BhcnRpYWxQYXltZW50ID0gZXhwb3J0cy5hZGp1c3RRdWFsaXR5Rm9yWFJQID0gZXhwb3J0cy5wYXJzZVRpbWVzdGFtcCA9IGV4cG9ydHMuaGV4VG9TdHJpbmcgPSBleHBvcnRzLnBhcnNlTWVtb3MgPSBleHBvcnRzLnBhcnNlT3V0Y29tZSA9IGV4cG9ydHMucGFyc2VRdWFsaXR5ID0gdm9pZCAwO1xuY29uc3QgcmlwcGxlX2xpYl90cmFuc2FjdGlvbnBhcnNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyaXBwbGUtbGliLXRyYW5zYWN0aW9ucGFyc2VyXCIpKTtcbmNvbnN0IGJpZ251bWJlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiaWdudW1iZXIuanNcIikpO1xuY29uc3QgY29tbW9uID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi8uLi9jb21tb25cIikpO1xuY29uc3QgYW1vdW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYW1vdW50XCIpKTtcbmZ1bmN0aW9uIGFkanVzdFF1YWxpdHlGb3JYUlAocXVhbGl0eSwgdGFrZXJHZXRzQ3VycmVuY3ksIHRha2VyUGF5c0N1cnJlbmN5KSB7XG4gICAgY29uc3QgbnVtZXJhdG9yU2hpZnQgPSB0YWtlclBheXNDdXJyZW5jeSA9PT0gJ1hSUCcgPyAtNiA6IDA7XG4gICAgY29uc3QgZGVub21pbmF0b3JTaGlmdCA9IHRha2VyR2V0c0N1cnJlbmN5ID09PSAnWFJQJyA/IC02IDogMDtcbiAgICBjb25zdCBzaGlmdCA9IG51bWVyYXRvclNoaWZ0IC0gZGVub21pbmF0b3JTaGlmdDtcbiAgICByZXR1cm4gc2hpZnQgPT09IDBcbiAgICAgICAgPyBxdWFsaXR5XG4gICAgICAgIDogbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQocXVhbGl0eSkuc2hpZnRlZEJ5KHNoaWZ0KS50b1N0cmluZygpO1xufVxuZXhwb3J0cy5hZGp1c3RRdWFsaXR5Rm9yWFJQID0gYWRqdXN0UXVhbGl0eUZvclhSUDtcbmZ1bmN0aW9uIHBhcnNlUXVhbGl0eShxdWFsaXR5KSB7XG4gICAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQocXVhbGl0eSkuc2hpZnRlZEJ5KC05KS50b051bWJlcigpO1xufVxuZXhwb3J0cy5wYXJzZVF1YWxpdHkgPSBwYXJzZVF1YWxpdHk7XG5mdW5jdGlvbiBwYXJzZVRpbWVzdGFtcChyaXBwbGVUaW1lKSB7XG4gICAgaWYgKHR5cGVvZiByaXBwbGVUaW1lICE9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gY29tbW9uLnJpcHBsZVRpbWVUb0lTTzg2MDEocmlwcGxlVGltZSk7XG59XG5leHBvcnRzLnBhcnNlVGltZXN0YW1wID0gcGFyc2VUaW1lc3RhbXA7XG5mdW5jdGlvbiByZW1vdmVFbXB0eUNvdW50ZXJwYXJ0eShhbW91bnQpIHtcbiAgICBpZiAoYW1vdW50LmNvdW50ZXJwYXJ0eSA9PT0gJycpIHtcbiAgICAgICAgZGVsZXRlIGFtb3VudC5jb3VudGVycGFydHk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlRW1wdHlDb3VudGVycGFydHlJbkJhbGFuY2VDaGFuZ2VzKGJhbGFuY2VDaGFuZ2VzKSB7XG4gICAgT2JqZWN0LmVudHJpZXMoYmFsYW5jZUNoYW5nZXMpLmZvckVhY2goKFtfLCBjaGFuZ2VzXSkgPT4ge1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2gocmVtb3ZlRW1wdHlDb3VudGVycGFydHkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlRW1wdHlDb3VudGVycGFydHlJbk9yZGVyYm9va0NoYW5nZXMob3JkZXJib29rQ2hhbmdlcykge1xuICAgIE9iamVjdC5lbnRyaWVzKG9yZGVyYm9va0NoYW5nZXMpLmZvckVhY2goKFtfLCBjaGFuZ2VzXSkgPT4ge1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoY2hhbmdlKS5mb3JFYWNoKHJlbW92ZUVtcHR5Q291bnRlcnBhcnR5KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc1BhcnRpYWxQYXltZW50KHR4KSB7XG4gICAgcmV0dXJuICh0eC5GbGFncyAmIGNvbW1vbi50eEZsYWdzLlBheW1lbnQuUGFydGlhbFBheW1lbnQpICE9PSAwO1xufVxuZXhwb3J0cy5pc1BhcnRpYWxQYXltZW50ID0gaXNQYXJ0aWFsUGF5bWVudDtcbmZ1bmN0aW9uIHBhcnNlRGVsaXZlcmVkQW1vdW50KHR4KSB7XG4gICAgaWYgKHR4LlRyYW5zYWN0aW9uVHlwZSAhPT0gJ1BheW1lbnQnIHx8XG4gICAgICAgIHR4Lm1ldGEuVHJhbnNhY3Rpb25SZXN1bHQgIT09ICd0ZXNTVUNDRVNTJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHgubWV0YS5kZWxpdmVyZWRfYW1vdW50ICYmIHR4Lm1ldGEuZGVsaXZlcmVkX2Ftb3VudCA9PT0gJ3VuYXZhaWxhYmxlJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHgubWV0YS5kZWxpdmVyZWRfYW1vdW50KSB7XG4gICAgICAgIHJldHVybiBhbW91bnRfMS5kZWZhdWx0KHR4Lm1ldGEuZGVsaXZlcmVkX2Ftb3VudCk7XG4gICAgfVxuICAgIGlmICh0eC5tZXRhLkRlbGl2ZXJlZEFtb3VudCkge1xuICAgICAgICByZXR1cm4gYW1vdW50XzEuZGVmYXVsdCh0eC5tZXRhLkRlbGl2ZXJlZEFtb3VudCk7XG4gICAgfVxuICAgIGlmICh0eC5BbW91bnQgJiYgIWlzUGFydGlhbFBheW1lbnQodHgpKSB7XG4gICAgICAgIHJldHVybiBhbW91bnRfMS5kZWZhdWx0KHR4LkFtb3VudCk7XG4gICAgfVxuICAgIGlmICh0eC5BbW91bnQgJiYgdHgubGVkZ2VyX2luZGV4ID4gNDU5NDA5NCkge1xuICAgICAgICByZXR1cm4gYW1vdW50XzEuZGVmYXVsdCh0eC5BbW91bnQpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcGFyc2VPdXRjb21lKHR4KSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB0eC5tZXRhIHx8IHR4Lm1ldGFEYXRhO1xuICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgYmFsYW5jZUNoYW5nZXMgPSByaXBwbGVfbGliX3RyYW5zYWN0aW9ucGFyc2VyXzEuZGVmYXVsdC5wYXJzZUJhbGFuY2VDaGFuZ2VzKG1ldGFkYXRhKTtcbiAgICBjb25zdCBvcmRlcmJvb2tDaGFuZ2VzID0gcmlwcGxlX2xpYl90cmFuc2FjdGlvbnBhcnNlcl8xLmRlZmF1bHQucGFyc2VPcmRlcmJvb2tDaGFuZ2VzKG1ldGFkYXRhKTtcbiAgICBjb25zdCBjaGFubmVsQ2hhbmdlcyA9IHJpcHBsZV9saWJfdHJhbnNhY3Rpb25wYXJzZXJfMS5kZWZhdWx0LnBhcnNlQ2hhbm5lbENoYW5nZXMobWV0YWRhdGEpO1xuICAgIHJlbW92ZUVtcHR5Q291bnRlcnBhcnR5SW5CYWxhbmNlQ2hhbmdlcyhiYWxhbmNlQ2hhbmdlcyk7XG4gICAgcmVtb3ZlRW1wdHlDb3VudGVycGFydHlJbk9yZGVyYm9va0NoYW5nZXMob3JkZXJib29rQ2hhbmdlcyk7XG4gICAgcmV0dXJuIGNvbW1vbi5yZW1vdmVVbmRlZmluZWQoe1xuICAgICAgICByZXN1bHQ6IHR4Lm1ldGEuVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgICAgIHRpbWVzdGFtcDogcGFyc2VUaW1lc3RhbXAodHguZGF0ZSksXG4gICAgICAgIGZlZTogY29tbW9uLmRyb3BzVG9YcnAodHguRmVlKSxcbiAgICAgICAgYmFsYW5jZUNoYW5nZXM6IGJhbGFuY2VDaGFuZ2VzLFxuICAgICAgICBvcmRlcmJvb2tDaGFuZ2VzOiBvcmRlcmJvb2tDaGFuZ2VzLFxuICAgICAgICBjaGFubmVsQ2hhbmdlczogY2hhbm5lbENoYW5nZXMsXG4gICAgICAgIGxlZGdlclZlcnNpb246IHR4LmxlZGdlcl9pbmRleCxcbiAgICAgICAgaW5kZXhJbkxlZGdlcjogdHgubWV0YS5UcmFuc2FjdGlvbkluZGV4LFxuICAgICAgICBkZWxpdmVyZWRBbW91bnQ6IHBhcnNlRGVsaXZlcmVkQW1vdW50KHR4KVxuICAgIH0pO1xufVxuZXhwb3J0cy5wYXJzZU91dGNvbWUgPSBwYXJzZU91dGNvbWU7XG5mdW5jdGlvbiBoZXhUb1N0cmluZyhoZXgpIHtcbiAgICByZXR1cm4gaGV4ID8gQnVmZmVyLmZyb20oaGV4LCAnaGV4JykudG9TdHJpbmcoJ3V0Zi04JykgOiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmhleFRvU3RyaW5nID0gaGV4VG9TdHJpbmc7XG5mdW5jdGlvbiBwYXJzZU1lbW9zKHR4KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR4Lk1lbW9zKSB8fCB0eC5NZW1vcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHR4Lk1lbW9zLm1hcCgobSkgPT4ge1xuICAgICAgICByZXR1cm4gY29tbW9uLnJlbW92ZVVuZGVmaW5lZCh7XG4gICAgICAgICAgICB0eXBlOiBtLk1lbW8ucGFyc2VkX21lbW9fdHlwZSB8fCBoZXhUb1N0cmluZyhtLk1lbW8uTWVtb1R5cGUpLFxuICAgICAgICAgICAgZm9ybWF0OiBtLk1lbW8ucGFyc2VkX21lbW9fZm9ybWF0IHx8IGhleFRvU3RyaW5nKG0uTWVtby5NZW1vRm9ybWF0KSxcbiAgICAgICAgICAgIGRhdGE6IG0uTWVtby5wYXJzZWRfbWVtb19kYXRhIHx8IGhleFRvU3RyaW5nKG0uTWVtby5NZW1vRGF0YSlcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnBhcnNlTWVtb3MgPSBwYXJzZU1lbW9zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgXyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibG9kYXNoXCIpKTtcbmNvbnN0IGJpZ251bWJlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiaWdudW1iZXIuanNcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuY29uc3QgcGF0aGZpbmRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZS9wYXRoZmluZFwiKSk7XG5jb25zdCBOb3RGb3VuZEVycm9yID0gY29tbW9uXzEuZXJyb3JzLk5vdEZvdW5kRXJyb3I7XG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSBjb21tb25fMS5lcnJvcnMuVmFsaWRhdGlvbkVycm9yO1xuZnVuY3Rpb24gYWRkUGFyYW1zKHJlcXVlc3QsIHJlc3VsdCkge1xuICAgIHJldHVybiBfLmRlZmF1bHRzKE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdCwge1xuICAgICAgICBzb3VyY2VfYWNjb3VudDogcmVxdWVzdC5zb3VyY2VfYWNjb3VudCxcbiAgICAgICAgc291cmNlX2N1cnJlbmNpZXM6IHJlcXVlc3Quc291cmNlX2N1cnJlbmNpZXNcbiAgICB9KSwgeyBkZXN0aW5hdGlvbl9hbW91bnQ6IHJlcXVlc3QuZGVzdGluYXRpb25fYW1vdW50IH0pO1xufVxuZnVuY3Rpb24gcmVxdWVzdFBhdGhGaW5kKGNvbm5lY3Rpb24sIHBhdGhmaW5kKSB7XG4gICAgY29uc3QgZGVzdGluYXRpb25BbW91bnQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgdmFsdWU6IHBhdGhmaW5kLmRlc3RpbmF0aW9uLmFtb3VudC5jdXJyZW5jeSA9PT0gJ1hSUCcgPyBjb21tb25fMS5kcm9wc1RvWHJwKCctMScpIDogJy0xJ1xuICAgIH0sIHBhdGhmaW5kLmRlc3RpbmF0aW9uLmFtb3VudCk7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgY29tbWFuZDogJ3JpcHBsZV9wYXRoX2ZpbmQnLFxuICAgICAgICBzb3VyY2VfYWNjb3VudDogcGF0aGZpbmQuc291cmNlLmFkZHJlc3MsXG4gICAgICAgIGRlc3RpbmF0aW9uX2FjY291bnQ6IHBhdGhmaW5kLmRlc3RpbmF0aW9uLmFkZHJlc3MsXG4gICAgICAgIGRlc3RpbmF0aW9uX2Ftb3VudDogY29tbW9uXzEudG9SaXBwbGVkQW1vdW50KGRlc3RpbmF0aW9uQW1vdW50KVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0LmRlc3RpbmF0aW9uX2Ftb3VudCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIXJlcXVlc3QuZGVzdGluYXRpb25fYW1vdW50Lmlzc3Vlcikge1xuICAgICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uX2Ftb3VudC5pc3N1ZXIgPSByZXF1ZXN0LmRlc3RpbmF0aW9uX2FjY291bnQ7XG4gICAgfVxuICAgIGlmIChwYXRoZmluZC5zb3VyY2UuY3VycmVuY2llcyAmJiBwYXRoZmluZC5zb3VyY2UuY3VycmVuY2llcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlcXVlc3Quc291cmNlX2N1cnJlbmNpZXMgPSBwYXRoZmluZC5zb3VyY2UuY3VycmVuY2llcy5tYXAoKGFtb3VudCkgPT4gdXRpbHNfMS5yZW5hbWVDb3VudGVycGFydHlUb0lzc3VlcihhbW91bnQpKTtcbiAgICB9XG4gICAgaWYgKHBhdGhmaW5kLnNvdXJjZS5hbW91bnQpIHtcbiAgICAgICAgaWYgKHBhdGhmaW5kLmRlc3RpbmF0aW9uLmFtb3VudC52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdDYW5ub3Qgc3BlY2lmeSBib3RoIHNvdXJjZS5hbW91bnQnICtcbiAgICAgICAgICAgICAgICAnIGFuZCBkZXN0aW5hdGlvbi5hbW91bnQudmFsdWUgaW4gZ2V0UGF0aHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LnNlbmRfbWF4ID0gY29tbW9uXzEudG9SaXBwbGVkQW1vdW50KHBhdGhmaW5kLnNvdXJjZS5hbW91bnQpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3Quc2VuZF9tYXggIT09ICdzdHJpbmcnICYmICFyZXF1ZXN0LnNlbmRfbWF4Lmlzc3Vlcikge1xuICAgICAgICAgICAgcmVxdWVzdC5zZW5kX21heC5pc3N1ZXIgPSBwYXRoZmluZC5zb3VyY2UuYWRkcmVzcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29ubmVjdGlvbi5yZXF1ZXN0KHJlcXVlc3QpLnRoZW4oKHBhdGhzKSA9PiBhZGRQYXJhbXMocmVxdWVzdCwgcGF0aHMpKTtcbn1cbmZ1bmN0aW9uIGFkZERpcmVjdFhycFBhdGgocGF0aHMsIHhycEJhbGFuY2UpIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkFtb3VudCA9IHBhdGhzLmRlc3RpbmF0aW9uX2Ftb3VudDtcbiAgICBpZiAobmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQoeHJwQmFsYW5jZSkuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyhkZXN0aW5hdGlvbkFtb3VudCkpIHtcbiAgICAgICAgcGF0aHMuYWx0ZXJuYXRpdmVzLnVuc2hpZnQoe1xuICAgICAgICAgICAgcGF0aHNfY29tcHV0ZWQ6IFtdLFxuICAgICAgICAgICAgc291cmNlX2Ftb3VudDogcGF0aHMuZGVzdGluYXRpb25fYW1vdW50XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aHM7XG59XG5mdW5jdGlvbiBpc1JpcHBsZWRJT1VBbW91bnQoYW1vdW50KSB7XG4gICAgcmV0dXJuICh0eXBlb2YgYW1vdW50ID09PSAnb2JqZWN0JyAmJiBhbW91bnQuY3VycmVuY3kgJiYgYW1vdW50LmN1cnJlbmN5ICE9PSAnWFJQJyk7XG59XG5mdW5jdGlvbiBjb25kaXRpb25hbGx5QWRkRGlyZWN0WFJQUGF0aChjb25uZWN0aW9uLCBhZGRyZXNzLCBwYXRocykge1xuICAgIGlmIChpc1JpcHBsZWRJT1VBbW91bnQocGF0aHMuZGVzdGluYXRpb25fYW1vdW50KSB8fFxuICAgICAgICAhcGF0aHMuZGVzdGluYXRpb25fY3VycmVuY2llcy5pbmNsdWRlcygnWFJQJykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYXRocyk7XG4gICAgfVxuICAgIHJldHVybiB1dGlsc18xLmdldFhSUEJhbGFuY2UoY29ubmVjdGlvbiwgYWRkcmVzcywgdW5kZWZpbmVkKS50aGVuKCh4cnBCYWxhbmNlKSA9PiBhZGREaXJlY3RYcnBQYXRoKHBhdGhzLCB4cnBCYWxhbmNlKSk7XG59XG5mdW5jdGlvbiBmaWx0ZXJTb3VyY2VGdW5kc0xvd1BhdGhzKHBhdGhmaW5kLCBwYXRocykge1xuICAgIGlmIChwYXRoZmluZC5zb3VyY2UuYW1vdW50ICYmXG4gICAgICAgIHBhdGhmaW5kLmRlc3RpbmF0aW9uLmFtb3VudC52YWx1ZSA9PSBudWxsICYmXG4gICAgICAgIHBhdGhzLmFsdGVybmF0aXZlcykge1xuICAgICAgICBwYXRocy5hbHRlcm5hdGl2ZXMgPSBwYXRocy5hbHRlcm5hdGl2ZXMuZmlsdGVyKChhbHQpID0+IHtcbiAgICAgICAgICAgIGlmICghYWx0LnNvdXJjZV9hbW91bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXRoZmluZFNvdXJjZUFtb3VudFZhbHVlID0gbmV3IGJpZ251bWJlcl9qc18xLmRlZmF1bHQocGF0aGZpbmQuc291cmNlLmFtb3VudC5jdXJyZW5jeSA9PT0gJ1hSUCdcbiAgICAgICAgICAgICAgICA/IGNvbW1vbl8xLnhycFRvRHJvcHMocGF0aGZpbmQuc291cmNlLmFtb3VudC52YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHBhdGhmaW5kLnNvdXJjZS5hbW91bnQudmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgYWx0U291cmNlQW1vdW50VmFsdWUgPSBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdCh0eXBlb2YgYWx0LnNvdXJjZV9hbW91bnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgPyBhbHQuc291cmNlX2Ftb3VudFxuICAgICAgICAgICAgICAgIDogYWx0LnNvdXJjZV9hbW91bnQudmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIGFsdFNvdXJjZUFtb3VudFZhbHVlLmVxKHBhdGhmaW5kU291cmNlQW1vdW50VmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhzO1xufVxuZnVuY3Rpb24gZm9ybWF0UmVzcG9uc2UocGF0aGZpbmQsIHBhdGhzKSB7XG4gICAgaWYgKHBhdGhzLmFsdGVybmF0aXZlcyAmJiBwYXRocy5hbHRlcm5hdGl2ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gcGF0aGZpbmRfMS5kZWZhdWx0KHBhdGhzKTtcbiAgICB9XG4gICAgaWYgKHBhdGhzLmRlc3RpbmF0aW9uX2N1cnJlbmNpZXMgIT0gbnVsbCAmJlxuICAgICAgICAhcGF0aHMuZGVzdGluYXRpb25fY3VycmVuY2llcy5pbmNsdWRlcyhwYXRoZmluZC5kZXN0aW5hdGlvbi5hbW91bnQuY3VycmVuY3kpKSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKCdObyBwYXRocyBmb3VuZC4gJyArXG4gICAgICAgICAgICAnVGhlIGRlc3RpbmF0aW9uX2FjY291bnQgZG9lcyBub3QgYWNjZXB0ICcgK1xuICAgICAgICAgICAgcGF0aGZpbmQuZGVzdGluYXRpb24uYW1vdW50LmN1cnJlbmN5ICtcbiAgICAgICAgICAgICcsIHRoZXkgb25seSBhY2NlcHQ6ICcgK1xuICAgICAgICAgICAgcGF0aHMuZGVzdGluYXRpb25fY3VycmVuY2llcy5qb2luKCcsICcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGF0aHMuc291cmNlX2N1cnJlbmNpZXMgJiYgcGF0aHMuc291cmNlX2N1cnJlbmNpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcignTm8gcGF0aHMgZm91bmQuIFBsZWFzZSBlbnN1cmUnICtcbiAgICAgICAgICAgICcgdGhhdCB0aGUgc291cmNlX2FjY291bnQgaGFzIHN1ZmZpY2llbnQgZnVuZHMgdG8gZXhlY3V0ZScgK1xuICAgICAgICAgICAgJyB0aGUgcGF5bWVudCBpbiBvbmUgb2YgdGhlIHNwZWNpZmllZCBzb3VyY2VfY3VycmVuY2llcy4gSWYgaXQgZG9lcycgK1xuICAgICAgICAgICAgJyB0aGVyZSBtYXkgYmUgaW5zdWZmaWNpZW50IGxpcXVpZGl0eSBpbiB0aGUgbmV0d29yayB0byBleGVjdXRlJyArXG4gICAgICAgICAgICAnIHRoaXMgcGF5bWVudCByaWdodCBub3cnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKCdObyBwYXRocyBmb3VuZC4nICtcbiAgICAgICAgICAgICcgUGxlYXNlIGVuc3VyZSB0aGF0IHRoZSBzb3VyY2VfYWNjb3VudCBoYXMgc3VmZmljaWVudCBmdW5kcyB0bycgK1xuICAgICAgICAgICAgJyBleGVjdXRlIHRoZSBwYXltZW50LiBJZiBpdCBkb2VzIHRoZXJlIG1heSBiZSBpbnN1ZmZpY2llbnQgbGlxdWlkaXR5JyArXG4gICAgICAgICAgICAnIGluIHRoZSBuZXR3b3JrIHRvIGV4ZWN1dGUgdGhpcyBwYXltZW50IHJpZ2h0IG5vdycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFBhdGhzKHBhdGhmaW5kKSB7XG4gICAgY29tbW9uXzEudmFsaWRhdGUuZ2V0UGF0aHMoeyBwYXRoZmluZCB9KTtcbiAgICBjb25zdCBhZGRyZXNzID0gcGF0aGZpbmQuc291cmNlLmFkZHJlc3M7XG4gICAgcmV0dXJuIHJlcXVlc3RQYXRoRmluZCh0aGlzLmNvbm5lY3Rpb24sIHBhdGhmaW5kKVxuICAgICAgICAudGhlbigocGF0aHMpID0+IGNvbmRpdGlvbmFsbHlBZGREaXJlY3RYUlBQYXRoKHRoaXMuY29ubmVjdGlvbiwgYWRkcmVzcywgcGF0aHMpKVxuICAgICAgICAudGhlbigocGF0aHMpID0+IGZpbHRlclNvdXJjZUZ1bmRzTG93UGF0aHMocGF0aGZpbmQsIHBhdGhzKSlcbiAgICAgICAgLnRoZW4oKHBhdGhzKSA9PiBmb3JtYXRSZXNwb25zZShwYXRoZmluZCwgcGF0aHMpKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGdldFBhdGhzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aGZpbmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBheW1lbnRfY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vcGFyc2UvcGF5bWVudC1jaGFubmVsXCIpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuY29uc3QgTm90Rm91bmRFcnJvciA9IGNvbW1vbl8xLmVycm9ycy5Ob3RGb3VuZEVycm9yO1xuZnVuY3Rpb24gZm9ybWF0UmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uubm9kZSA9PSBudWxsIHx8XG4gICAgICAgIHJlc3BvbnNlLm5vZGUuTGVkZ2VyRW50cnlUeXBlICE9PSAnUGF5Q2hhbm5lbCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kRXJyb3IoJ1BheW1lbnQgY2hhbm5lbCBsZWRnZXIgZW50cnkgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiBwYXltZW50X2NoYW5uZWxfMS5wYXJzZVBheW1lbnRDaGFubmVsKHJlc3BvbnNlLm5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0UGF5bWVudENoYW5uZWwoaWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb21tb25fMS52YWxpZGF0ZS5nZXRQYXltZW50Q2hhbm5lbCh7IGlkIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMucmVxdWVzdCgnbGVkZ2VyX2VudHJ5Jywge1xuICAgICAgICAgICAgaW5kZXg6IGlkLFxuICAgICAgICAgICAgYmluYXJ5OiBmYWxzZSxcbiAgICAgICAgICAgIGxlZGdlcl9pbmRleDogJ3ZhbGlkYXRlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3JtYXRSZXNwb25zZShyZXNwb25zZSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRQYXltZW50Q2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBheW1lbnQtY2hhbm5lbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTZXR0aW5ncyA9IGV4cG9ydHMucGFyc2VBY2NvdW50RmxhZ3MgPSB2b2lkIDA7XG5jb25zdCBmaWVsZHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZS9maWVsZHNcIikpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuY29uc3QgQWNjb3VudEZsYWdzID0gY29tbW9uXzEuY29uc3RhbnRzLkFjY291bnRGbGFncztcbmZ1bmN0aW9uIHBhcnNlQWNjb3VudEZsYWdzKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IHt9O1xuICAgIGZvciAoY29uc3QgZmxhZ05hbWUgaW4gQWNjb3VudEZsYWdzKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmIEFjY291bnRGbGFnc1tmbGFnTmFtZV0pIHtcbiAgICAgICAgICAgIHNldHRpbmdzW2ZsYWdOYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuZXhjbHVkZUZhbHNlKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NbZmxhZ05hbWVdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldHRpbmdzO1xufVxuZXhwb3J0cy5wYXJzZUFjY291bnRGbGFncyA9IHBhcnNlQWNjb3VudEZsYWdzO1xuZnVuY3Rpb24gZm9ybWF0U2V0dGluZ3MocmVzcG9uc2UpIHtcbiAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuYWNjb3VudF9kYXRhO1xuICAgIGNvbnN0IHBhcnNlZEZsYWdzID0gcGFyc2VBY2NvdW50RmxhZ3MoZGF0YS5GbGFncywgeyBleGNsdWRlRmFsc2U6IHRydWUgfSk7XG4gICAgY29uc3QgcGFyc2VkRmllbGRzID0gZmllbGRzXzEuZGVmYXVsdChkYXRhKTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VkRmxhZ3MsIHBhcnNlZEZpZWxkcyk7XG59XG5mdW5jdGlvbiBnZXRTZXR0aW5ncyhhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb21tb25fMS52YWxpZGF0ZS5nZXRTZXR0aW5ncyh7IGFkZHJlc3MsIG9wdGlvbnMgfSk7XG4gICAgICAgIGFkZHJlc3MgPSBjb21tb25fMS5lbnN1cmVDbGFzc2ljQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3QoJ2FjY291bnRfaW5mbycsIHtcbiAgICAgICAgICAgIGFjY291bnQ6IGFkZHJlc3MsXG4gICAgICAgICAgICBsZWRnZXJfaW5kZXg6IG9wdGlvbnMubGVkZ2VyVmVyc2lvbiB8fCAndmFsaWRhdGVkJyxcbiAgICAgICAgICAgIHNpZ25lcl9saXN0czogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFNldHRpbmdzKHJlc3BvbnNlKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0U2V0dGluZ3MgPSBnZXRTZXR0aW5ncztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNldHRpbmdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgdHJhbnNhY3Rpb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZS90cmFuc2FjdGlvblwiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBhdHRhY2hUcmFuc2FjdGlvbkRhdGUoY29ubmVjdGlvbiwgdHgpIHtcbiAgICBpZiAodHguZGF0ZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHR4KTtcbiAgICB9XG4gICAgY29uc3QgbGVkZ2VyVmVyc2lvbiA9IHR4LmxlZGdlcl9pbmRleCB8fCB0eC5MZWRnZXJTZXF1ZW5jZTtcbiAgICBpZiAoIWxlZGdlclZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IGNvbW1vbl8xLmVycm9ycy5Ob3RGb3VuZEVycm9yKCdUcmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gdmFsaWRhdGVkIHlldDsgdHJ5IGFnYWluIGxhdGVyJyk7XG4gICAgICAgICAgICBlcnJvci5kYXRhID0ge1xuICAgICAgICAgICAgICAgIGRldGFpbHM6ICcobGVkZ2VyX2luZGV4IGFuZCBMZWRnZXJTZXF1ZW5jZSBub3QgZm91bmQgaW4gdHgpJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgY29tbWFuZDogJ2xlZGdlcicsXG4gICAgICAgIGxlZGdlcl9pbmRleDogbGVkZ2VyVmVyc2lvblxuICAgIH07XG4gICAgcmV0dXJuIGNvbm5lY3Rpb25cbiAgICAgICAgLnJlcXVlc3QocmVxdWVzdClcbiAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmxlZGdlci5jbG9zZV90aW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBkYXRlOiBkYXRhLmxlZGdlci5jbG9zZV90aW1lIH0sIHR4KTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgY29tbW9uXzEuZXJyb3JzLlVuZXhwZWN0ZWRFcnJvcignTGVkZ2VyIG1pc3NpbmcgY2xvc2VfdGltZScpO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgY29tbW9uXzEuZXJyb3JzLlVuZXhwZWN0ZWRFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IGNvbW1vbl8xLmVycm9ycy5Ob3RGb3VuZEVycm9yKCdUcmFuc2FjdGlvbiBsZWRnZXIgbm90IGZvdW5kJyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpc1RyYW5zYWN0aW9uSW5SYW5nZSh0eCwgb3B0aW9ucykge1xuICAgIHJldHVybiAoKCFvcHRpb25zLm1pbkxlZGdlclZlcnNpb24gfHxcbiAgICAgICAgdHgubGVkZ2VyX2luZGV4ID49IG9wdGlvbnMubWluTGVkZ2VyVmVyc2lvbikgJiZcbiAgICAgICAgKCFvcHRpb25zLm1heExlZGdlclZlcnNpb24gfHwgdHgubGVkZ2VyX2luZGV4IDw9IG9wdGlvbnMubWF4TGVkZ2VyVmVyc2lvbikpO1xufVxuZnVuY3Rpb24gY29udmVydEVycm9yKGNvbm5lY3Rpb24sIG9wdGlvbnMsIGVycm9yKSB7XG4gICAgbGV0IHNob3VsZFVzZU5vdEZvdW5kRXJyb3IgPSBmYWxzZTtcbiAgICBpZiAoKGVycm9yLmRhdGEgJiYgZXJyb3IuZGF0YS5lcnJvciA9PT0gJ3R4bk5vdEZvdW5kJykgfHxcbiAgICAgICAgZXJyb3IubWVzc2FnZSA9PT0gJ3R4bk5vdEZvdW5kJykge1xuICAgICAgICBzaG91bGRVc2VOb3RGb3VuZEVycm9yID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgX2Vycm9yID0gc2hvdWxkVXNlTm90Rm91bmRFcnJvclxuICAgICAgICA/IG5ldyBjb21tb25fMS5lcnJvcnMuTm90Rm91bmRFcnJvcignVHJhbnNhY3Rpb24gbm90IGZvdW5kJylcbiAgICAgICAgOiBlcnJvcjtcbiAgICBpZiAoX2Vycm9yIGluc3RhbmNlb2YgY29tbW9uXzEuZXJyb3JzLk5vdEZvdW5kRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHV0aWxzXG4gICAgICAgICAgICAuaGFzQ29tcGxldGVMZWRnZXJSYW5nZShjb25uZWN0aW9uLCBvcHRpb25zLm1pbkxlZGdlclZlcnNpb24sIG9wdGlvbnMubWF4TGVkZ2VyVmVyc2lvbilcbiAgICAgICAgICAgIC50aGVuKChoYXNDb21wbGV0ZUxlZGdlclJhbmdlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhc0NvbXBsZXRlTGVkZ2VyUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbHNcbiAgICAgICAgICAgICAgICAgICAgLmlzUGVuZGluZ0xlZGdlclZlcnNpb24oY29ubmVjdGlvbiwgb3B0aW9ucy5tYXhMZWRnZXJWZXJzaW9uKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaXNQZW5kaW5nTGVkZ2VyVmVyc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNQZW5kaW5nTGVkZ2VyVmVyc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgY29tbW9uXzEuZXJyb3JzLlBlbmRpbmdMZWRnZXJWZXJzaW9uRXJyb3IoKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgY29tbW9uXzEuZXJyb3JzLk1pc3NpbmdMZWRnZXJIaXN0b3J5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfZXJyb3I7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF9lcnJvcik7XG59XG5mdW5jdGlvbiBmb3JtYXRSZXNwb25zZShvcHRpb25zLCB0eCkge1xuICAgIGlmICh0eC52YWxpZGF0ZWQgIT09IHRydWUgfHwgIWlzVHJhbnNhY3Rpb25JblJhbmdlKHR4LCBvcHRpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgY29tbW9uXzEuZXJyb3JzLk5vdEZvdW5kRXJyb3IoJ1RyYW5zYWN0aW9uIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNhY3Rpb25fMS5kZWZhdWx0KHR4LCBvcHRpb25zLmluY2x1ZGVSYXdUcmFuc2FjdGlvbik7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvbihpZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29tbW9uXzEudmFsaWRhdGUuZ2V0VHJhbnNhY3Rpb24oeyBpZCwgb3B0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgX29wdGlvbnMgPSB5aWVsZCB1dGlscy5lbnN1cmVMZWRnZXJWZXJzaW9uLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMucmVxdWVzdCgndHgnLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IGlkLFxuICAgICAgICAgICAgICAgIGJpbmFyeTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHhXaXRoRGF0ZSA9IHlpZWxkIGF0dGFjaFRyYW5zYWN0aW9uRGF0ZSh0aGlzLmNvbm5lY3Rpb24sIHR4KTtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRSZXNwb25zZShfb3B0aW9ucywgdHhXaXRoRGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyB5aWVsZCBjb252ZXJ0RXJyb3IodGhpcy5jb25uZWN0aW9uLCBfb3B0aW9ucywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBnZXRUcmFuc2FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zYWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IF8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImxvZGFzaFwiKSk7XG5jb25zdCByaXBwbGVfYmluYXJ5X2NvZGVjXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJpcHBsZS1iaW5hcnktY29kZWNcIikpO1xuY29uc3QgaGFzaGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hhc2hlc1wiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFyc2UvdHJhbnNhY3Rpb25cIikpO1xuY29uc3QgdHJhbnNhY3Rpb25fMiA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBwYXJzZUJpbmFyeVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgdHggPSByaXBwbGVfYmluYXJ5X2NvZGVjXzEuZGVmYXVsdC5kZWNvZGUodHJhbnNhY3Rpb24udHhfYmxvYik7XG4gICAgdHguaGFzaCA9IGhhc2hlc18xLmNvbXB1dGVUcmFuc2FjdGlvbkhhc2godHgpO1xuICAgIHR4LmxlZGdlcl9pbmRleCA9IHRyYW5zYWN0aW9uLmxlZGdlcl9pbmRleDtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eDogdHgsXG4gICAgICAgIG1ldGE6IHJpcHBsZV9iaW5hcnlfY29kZWNfMS5kZWZhdWx0LmRlY29kZSh0cmFuc2FjdGlvbi5tZXRhKSxcbiAgICAgICAgdmFsaWRhdGVkOiB0cmFuc2FjdGlvbi52YWxpZGF0ZWRcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VBY2NvdW50VHhUcmFuc2FjdGlvbih0eCwgaW5jbHVkZVJhd1RyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgX3R4ID0gdHgudHhfYmxvYiA/IHBhcnNlQmluYXJ5VHJhbnNhY3Rpb24odHgpIDogdHg7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uXzEuZGVmYXVsdChPYmplY3QuYXNzaWduKHt9LCBfdHgudHgsIHsgbWV0YTogX3R4Lm1ldGEsIHZhbGlkYXRlZDogX3R4LnZhbGlkYXRlZCB9KSwgaW5jbHVkZVJhd1RyYW5zYWN0aW9uKTtcbn1cbmZ1bmN0aW9uIGNvdW50ZXJwYXJ0eUZpbHRlcihmaWx0ZXJzLCB0eCkge1xuICAgIGlmICh0eC5hZGRyZXNzID09PSBmaWx0ZXJzLmNvdW50ZXJwYXJ0eSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWNhdGlvbiA9IHR4LnNwZWNpZmljYXRpb247XG4gICAgaWYgKHNwZWNpZmljYXRpb24gJiZcbiAgICAgICAgKChzcGVjaWZpY2F0aW9uLmRlc3RpbmF0aW9uICYmXG4gICAgICAgICAgICBzcGVjaWZpY2F0aW9uLmRlc3RpbmF0aW9uLmFkZHJlc3MgPT09IGZpbHRlcnMuY291bnRlcnBhcnR5KSB8fFxuICAgICAgICAgICAgc3BlY2lmaWNhdGlvbi5jb3VudGVycGFydHkgPT09IGZpbHRlcnMuY291bnRlcnBhcnR5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHJhbnNhY3Rpb25GaWx0ZXIoYWRkcmVzcywgZmlsdGVycywgdHgpIHtcbiAgICBpZiAoZmlsdGVycy5leGNsdWRlRmFpbHVyZXMgJiYgdHgub3V0Y29tZS5yZXN1bHQgIT09ICd0ZXNTVUNDRVNTJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChmaWx0ZXJzLnR5cGVzICYmICFmaWx0ZXJzLnR5cGVzLmluY2x1ZGVzKHR4LnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGZpbHRlcnMuaW5pdGlhdGVkID09PSB0cnVlICYmIHR4LmFkZHJlc3MgIT09IGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycy5pbml0aWF0ZWQgPT09IGZhbHNlICYmIHR4LmFkZHJlc3MgPT09IGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmlsdGVycy5jb3VudGVycGFydHkgJiYgIWNvdW50ZXJwYXJ0eUZpbHRlcihmaWx0ZXJzLCB0eCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG9yZGVyRmlsdGVyKG9wdGlvbnMsIHR4KSB7XG4gICAgcmV0dXJuICghb3B0aW9ucy5zdGFydFR4IHx8XG4gICAgICAgIChvcHRpb25zLmVhcmxpZXN0Rmlyc3RcbiAgICAgICAgICAgID8gdXRpbHMuY29tcGFyZVRyYW5zYWN0aW9ucyh0eCwgb3B0aW9ucy5zdGFydFR4KSA+IDBcbiAgICAgICAgICAgIDogdXRpbHMuY29tcGFyZVRyYW5zYWN0aW9ucyh0eCwgb3B0aW9ucy5zdGFydFR4KSA8IDApKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFBhcnRpYWxSZXNwb25zZShhZGRyZXNzLCBvcHRpb25zLCBkYXRhKSB7XG4gICAgY29uc3QgcGFyc2UgPSAodHgpID0+IHBhcnNlQWNjb3VudFR4VHJhbnNhY3Rpb24odHgsIG9wdGlvbnMuaW5jbHVkZVJhd1RyYW5zYWN0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFya2VyOiBkYXRhLm1hcmtlcixcbiAgICAgICAgcmVzdWx0czogZGF0YS50cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoKHR4KSA9PiB0eC52YWxpZGF0ZWQpXG4gICAgICAgICAgICAubWFwKHBhcnNlKVxuICAgICAgICAgICAgLmZpbHRlcihfLnBhcnRpYWwodHJhbnNhY3Rpb25GaWx0ZXIsIGFkZHJlc3MsIG9wdGlvbnMpKVxuICAgICAgICAgICAgLmZpbHRlcihfLnBhcnRpYWwob3JkZXJGaWx0ZXIsIG9wdGlvbnMpKVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRBY2NvdW50VHgoY29ubmVjdGlvbiwgYWRkcmVzcywgb3B0aW9ucywgbWFya2VyLCBsaW1pdCkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGNvbW1hbmQ6ICdhY2NvdW50X3R4JyxcbiAgICAgICAgYWNjb3VudDogYWRkcmVzcyxcbiAgICAgICAgbGVkZ2VyX2luZGV4X21pbjogb3B0aW9ucy5taW5MZWRnZXJWZXJzaW9uIHx8IC0xLFxuICAgICAgICBsZWRnZXJfaW5kZXhfbWF4OiBvcHRpb25zLm1heExlZGdlclZlcnNpb24gfHwgLTEsXG4gICAgICAgIGZvcndhcmQ6IG9wdGlvbnMuZWFybGllc3RGaXJzdCxcbiAgICAgICAgYmluYXJ5OiBvcHRpb25zLmJpbmFyeSxcbiAgICAgICAgbGltaXQ6IHV0aWxzLmNsYW1wKGxpbWl0LCAxMCwgNDAwKSxcbiAgICAgICAgbWFya2VyOiBtYXJrZXJcbiAgICB9O1xuICAgIHJldHVybiBjb25uZWN0aW9uXG4gICAgICAgIC5yZXF1ZXN0KHJlcXVlc3QpXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gZm9ybWF0UGFydGlhbFJlc3BvbnNlKGFkZHJlc3MsIG9wdGlvbnMsIHJlc3BvbnNlKSk7XG59XG5mdW5jdGlvbiBjaGVja0ZvckxlZGdlckdhcHMoY29ubmVjdGlvbiwgb3B0aW9ucywgdHJhbnNhY3Rpb25zKSB7XG4gICAgbGV0IHsgbWluTGVkZ2VyVmVyc2lvbiwgbWF4TGVkZ2VyVmVyc2lvbiB9ID0gb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5saW1pdCAmJiB0cmFuc2FjdGlvbnMubGVuZ3RoID09PSBvcHRpb25zLmxpbWl0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmVhcmxpZXN0Rmlyc3QpIHtcbiAgICAgICAgICAgIG1heExlZGdlclZlcnNpb24gPSB0cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLm91dGNvbWUubGVkZ2VyVmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1pbkxlZGdlclZlcnNpb24gPSB0cmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25zLmxlbmd0aCAtIDFdLm91dGNvbWUubGVkZ2VyVmVyc2lvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXRpbHNcbiAgICAgICAgLmhhc0NvbXBsZXRlTGVkZ2VyUmFuZ2UoY29ubmVjdGlvbiwgbWluTGVkZ2VyVmVyc2lvbiwgbWF4TGVkZ2VyVmVyc2lvbilcbiAgICAgICAgLnRoZW4oKGhhc0NvbXBsZXRlTGVkZ2VyUmFuZ2UpID0+IHtcbiAgICAgICAgaWYgKCFoYXNDb21wbGV0ZUxlZGdlclJhbmdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29tbW9uXzEuZXJyb3JzLk1pc3NpbmdMZWRnZXJIaXN0b3J5RXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0UmVzcG9uc2UoY29ubmVjdGlvbiwgb3B0aW9ucywgdHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3Qgc29ydGVkVHJhbnNhY3Rpb25zID0gb3B0aW9ucy5lYXJsaWVzdEZpcnN0XG4gICAgICAgID8gdHJhbnNhY3Rpb25zLnNvcnQodXRpbHMuY29tcGFyZVRyYW5zYWN0aW9ucylcbiAgICAgICAgOiB0cmFuc2FjdGlvbnMuc29ydCh1dGlscy5jb21wYXJlVHJhbnNhY3Rpb25zKS5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGNoZWNrRm9yTGVkZ2VyR2Fwcyhjb25uZWN0aW9uLCBvcHRpb25zLCBzb3J0ZWRUcmFuc2FjdGlvbnMpLnRoZW4oKCkgPT4gc29ydGVkVHJhbnNhY3Rpb25zKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uc0ludGVybmFsKGNvbm5lY3Rpb24sIGFkZHJlc3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBnZXR0ZXIgPSBfLnBhcnRpYWwoZ2V0QWNjb3VudFR4LCBjb25uZWN0aW9uLCBhZGRyZXNzLCBvcHRpb25zKTtcbiAgICBjb25zdCBmb3JtYXQgPSBfLnBhcnRpYWwoZm9ybWF0UmVzcG9uc2UsIGNvbm5lY3Rpb24sIG9wdGlvbnMpO1xuICAgIHJldHVybiB1dGlscy5nZXRSZWN1cnNpdmUoZ2V0dGVyLCBvcHRpb25zLmxpbWl0KS50aGVuKGZvcm1hdCk7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvbnMoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29tbW9uXzEudmFsaWRhdGUuZ2V0VHJhbnNhY3Rpb25zKHsgYWRkcmVzcywgb3B0aW9ucyB9KTtcbiAgICBhZGRyZXNzID0gY29tbW9uXzEuZW5zdXJlQ2xhc3NpY0FkZHJlc3MoYWRkcmVzcyk7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7IG1heExlZGdlclZlcnNpb246IC0xIH07XG4gICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uXzIuZGVmYXVsdC5jYWxsKHRoaXMsIG9wdGlvbnMuc3RhcnQpLnRoZW4oKHR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZWRnZXJWZXJzaW9uID0gdHgub3V0Y29tZS5sZWRnZXJWZXJzaW9uO1xuICAgICAgICAgICAgY29uc3QgYm91bmQgPSBvcHRpb25zLmVhcmxpZXN0Rmlyc3RcbiAgICAgICAgICAgICAgICA/IHsgbWluTGVkZ2VyVmVyc2lvbjogbGVkZ2VyVmVyc2lvbiB9XG4gICAgICAgICAgICAgICAgOiB7IG1heExlZGdlclZlcnNpb246IGxlZGdlclZlcnNpb24gfTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zLCB7IHN0YXJ0VHg6IHR4IH0sIGJvdW5kKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRUcmFuc2FjdGlvbnNJbnRlcm5hbCh0aGlzLmNvbm5lY3Rpb24sIGFkZHJlc3MsIHN0YXJ0T3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBuZXdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBnZXRUcmFuc2FjdGlvbnNJbnRlcm5hbCh0aGlzLmNvbm5lY3Rpb24sIGFkZHJlc3MsIG5ld09wdGlvbnMpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0VHJhbnNhY3Rpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgXyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibG9kYXNoXCIpKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmNvbnN0IGFjY291bnRfdHJ1c3RsaW5lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFyc2UvYWNjb3VudC10cnVzdGxpbmVcIikpO1xuZnVuY3Rpb24gY3VycmVuY3lGaWx0ZXIoY3VycmVuY3ksIHRydXN0bGluZSkge1xuICAgIHJldHVybiBjdXJyZW5jeSA9PT0gbnVsbCB8fCB0cnVzdGxpbmUuc3BlY2lmaWNhdGlvbi5jdXJyZW5jeSA9PT0gY3VycmVuY3k7XG59XG5mdW5jdGlvbiBnZXRUcnVzdGxpbmVzKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb21tb25fMS52YWxpZGF0ZS5nZXRUcnVzdGxpbmVzKHsgYWRkcmVzcywgb3B0aW9ucyB9KTtcbiAgICAgICAgYWRkcmVzcyA9IGNvbW1vbl8xLmVuc3VyZUNsYXNzaWNBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCByZXNwb25zZXMgPSB5aWVsZCB0aGlzLl9yZXF1ZXN0QWxsKCdhY2NvdW50X2xpbmVzJywge1xuICAgICAgICAgICAgYWNjb3VudDogYWRkcmVzcyxcbiAgICAgICAgICAgIGxlZGdlcl9pbmRleDogKF9hID0gb3B0aW9ucy5sZWRnZXJWZXJzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB5aWVsZCB0aGlzLmdldExlZGdlclZlcnNpb24oKSxcbiAgICAgICAgICAgIGxpbWl0OiBvcHRpb25zLmxpbWl0LFxuICAgICAgICAgICAgcGVlcjogb3B0aW9ucy5jb3VudGVycGFydHlcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRydXN0bGluZXMgPSBfLmZsYXRNYXAocmVzcG9uc2VzLCAocmVzcG9uc2UpID0+IHJlc3BvbnNlLmxpbmVzKTtcbiAgICAgICAgcmV0dXJuIHRydXN0bGluZXMubWFwKGFjY291bnRfdHJ1c3RsaW5lXzEuZGVmYXVsdCkuZmlsdGVyKCh0cnVzdGxpbmUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW5jeUZpbHRlcihvcHRpb25zLmN1cnJlbmN5IHx8IG51bGwsIHRydXN0bGluZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0VHJ1c3RsaW5lcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRydXN0bGluZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21tb24gPSBleHBvcnRzLmNsYW1wID0gZXhwb3J0cy5pc1BlbmRpbmdMZWRnZXJWZXJzaW9uID0gZXhwb3J0cy5oYXNDb21wbGV0ZUxlZGdlclJhbmdlID0gZXhwb3J0cy5nZXRSZWN1cnNpdmUgPSBleHBvcnRzLnJlbmFtZUNvdW50ZXJwYXJ0eVRvSXNzdWVySW5PcmRlciA9IGV4cG9ydHMucmVuYW1lQ291bnRlcnBhcnR5VG9Jc3N1ZXIgPSBleHBvcnRzLmNvbXBhcmVUcmFuc2FjdGlvbnMgPSBleHBvcnRzLmVuc3VyZUxlZGdlclZlcnNpb24gPSBleHBvcnRzLmdldFhSUEJhbGFuY2UgPSB2b2lkIDA7XG5jb25zdCBfID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJsb2Rhc2hcIikpO1xuY29uc3QgYXNzZXJ0ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJhc3NlcnRcIikpO1xuY29uc3QgY29tbW9uID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9jb21tb25cIikpO1xuZXhwb3J0cy5jb21tb24gPSBjb21tb247XG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICBhc3NlcnQub2sobWluIDw9IG1heCwgJ0lsbGVnYWwgY2xhbXAgYm91bmRzJyk7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuZnVuY3Rpb24gZ2V0WFJQQmFsYW5jZShjb25uZWN0aW9uLCBhZGRyZXNzLCBsZWRnZXJWZXJzaW9uKSB7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgY29tbWFuZDogJ2FjY291bnRfaW5mbycsXG4gICAgICAgIGFjY291bnQ6IGFkZHJlc3MsXG4gICAgICAgIGxlZGdlcl9pbmRleDogbGVkZ2VyVmVyc2lvblxuICAgIH07XG4gICAgcmV0dXJuIGNvbm5lY3Rpb25cbiAgICAgICAgLnJlcXVlc3QocmVxdWVzdClcbiAgICAgICAgLnRoZW4oKGRhdGEpID0+IGNvbW1vbi5kcm9wc1RvWHJwKGRhdGEuYWNjb3VudF9kYXRhLkJhbGFuY2UpKTtcbn1cbmV4cG9ydHMuZ2V0WFJQQmFsYW5jZSA9IGdldFhSUEJhbGFuY2U7XG5mdW5jdGlvbiBnZXRSZWN1cnNpdmVSZWN1cihnZXR0ZXIsIG1hcmtlciwgbGltaXQpIHtcbiAgICByZXR1cm4gZ2V0dGVyKG1hcmtlciwgbGltaXQpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgcmVtYWluaW5nID0gbGltaXQgLSBkYXRhLnJlc3VsdHMubGVuZ3RoO1xuICAgICAgICBpZiAocmVtYWluaW5nID4gMCAmJiBkYXRhLm1hcmtlciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmVjdXJzaXZlUmVjdXIoZ2V0dGVyLCBkYXRhLm1hcmtlciwgcmVtYWluaW5nKS50aGVuKChyZXN1bHRzKSA9PiBkYXRhLnJlc3VsdHMuY29uY2F0KHJlc3VsdHMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5yZXN1bHRzLnNsaWNlKDAsIGxpbWl0KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJlY3Vyc2l2ZShnZXR0ZXIsIGxpbWl0KSB7XG4gICAgcmV0dXJuIGdldFJlY3Vyc2l2ZVJlY3VyKGdldHRlciwgdW5kZWZpbmVkLCBsaW1pdCB8fCBJbmZpbml0eSk7XG59XG5leHBvcnRzLmdldFJlY3Vyc2l2ZSA9IGdldFJlY3Vyc2l2ZTtcbmZ1bmN0aW9uIHJlbmFtZUNvdW50ZXJwYXJ0eVRvSXNzdWVyKG9iaikge1xuICAgIGNvbnN0IGlzc3VlciA9IG9iai5jb3VudGVycGFydHkgIT0gbnVsbFxuICAgICAgICA/IG9iai5jb3VudGVycGFydHlcbiAgICAgICAgOiBvYmouaXNzdWVyICE9IG51bGxcbiAgICAgICAgICAgID8gb2JqLmlzc3VlclxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgd2l0aElzc3VlciA9IE9iamVjdC5hc3NpZ24oe30sIG9iaiwgeyBpc3N1ZXIgfSk7XG4gICAgZGVsZXRlIHdpdGhJc3N1ZXIuY291bnRlcnBhcnR5O1xuICAgIHJldHVybiB3aXRoSXNzdWVyO1xufVxuZXhwb3J0cy5yZW5hbWVDb3VudGVycGFydHlUb0lzc3VlciA9IHJlbmFtZUNvdW50ZXJwYXJ0eVRvSXNzdWVyO1xuZnVuY3Rpb24gcmVuYW1lQ291bnRlcnBhcnR5VG9Jc3N1ZXJJbk9yZGVyKG9yZGVyKSB7XG4gICAgY29uc3QgdGFrZXJfZ2V0cyA9IHJlbmFtZUNvdW50ZXJwYXJ0eVRvSXNzdWVyKG9yZGVyLnRha2VyX2dldHMpO1xuICAgIGNvbnN0IHRha2VyX3BheXMgPSByZW5hbWVDb3VudGVycGFydHlUb0lzc3VlcihvcmRlci50YWtlcl9wYXlzKTtcbiAgICBjb25zdCBjaGFuZ2VzID0geyB0YWtlcl9nZXRzLCB0YWtlcl9wYXlzIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG9yZGVyLCBfLm9taXRCeShjaGFuZ2VzLCB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsKSk7XG59XG5leHBvcnRzLnJlbmFtZUNvdW50ZXJwYXJ0eVRvSXNzdWVySW5PcmRlciA9IHJlbmFtZUNvdW50ZXJwYXJ0eVRvSXNzdWVySW5PcmRlcjtcbmZ1bmN0aW9uIHNpZ251bShudW0pIHtcbiAgICByZXR1cm4gbnVtID09PSAwID8gMCA6IG51bSA+IDAgPyAxIDogLTE7XG59XG5mdW5jdGlvbiBjb21wYXJlVHJhbnNhY3Rpb25zKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoIWZpcnN0Lm91dGNvbWUgfHwgIXNlY29uZC5vdXRjb21lKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoZmlyc3Qub3V0Y29tZS5sZWRnZXJWZXJzaW9uID09PSBzZWNvbmQub3V0Y29tZS5sZWRnZXJWZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiBzaWdudW0oZmlyc3Qub3V0Y29tZS5pbmRleEluTGVkZ2VyIC0gc2Vjb25kLm91dGNvbWUuaW5kZXhJbkxlZGdlcik7XG4gICAgfVxuICAgIHJldHVybiBmaXJzdC5vdXRjb21lLmxlZGdlclZlcnNpb24gPCBzZWNvbmQub3V0Y29tZS5sZWRnZXJWZXJzaW9uID8gLTEgOiAxO1xufVxuZXhwb3J0cy5jb21wYXJlVHJhbnNhY3Rpb25zID0gY29tcGFyZVRyYW5zYWN0aW9ucztcbmZ1bmN0aW9uIGhhc0NvbXBsZXRlTGVkZ2VyUmFuZ2UoY29ubmVjdGlvbiwgbWluTGVkZ2VyVmVyc2lvbiwgbWF4TGVkZ2VyVmVyc2lvbikge1xuICAgIGNvbnN0IGZpcnN0TGVkZ2VyVmVyc2lvbiA9IDMyNTcwO1xuICAgIHJldHVybiBjb25uZWN0aW9uLmhhc0xlZGdlclZlcnNpb25zKG1pbkxlZGdlclZlcnNpb24gfHwgZmlyc3RMZWRnZXJWZXJzaW9uLCBtYXhMZWRnZXJWZXJzaW9uKTtcbn1cbmV4cG9ydHMuaGFzQ29tcGxldGVMZWRnZXJSYW5nZSA9IGhhc0NvbXBsZXRlTGVkZ2VyUmFuZ2U7XG5mdW5jdGlvbiBpc1BlbmRpbmdMZWRnZXJWZXJzaW9uKGNvbm5lY3Rpb24sIG1heExlZGdlclZlcnNpb24pIHtcbiAgICByZXR1cm4gY29ubmVjdGlvblxuICAgICAgICAuZ2V0TGVkZ2VyVmVyc2lvbigpXG4gICAgICAgIC50aGVuKChsZWRnZXJWZXJzaW9uKSA9PiBsZWRnZXJWZXJzaW9uIDwgKG1heExlZGdlclZlcnNpb24gfHwgMCkpO1xufVxuZXhwb3J0cy5pc1BlbmRpbmdMZWRnZXJWZXJzaW9uID0gaXNQZW5kaW5nTGVkZ2VyVmVyc2lvbjtcbmZ1bmN0aW9uIGVuc3VyZUxlZGdlclZlcnNpb24ob3B0aW9ucykge1xuICAgIGlmIChCb29sZWFuKG9wdGlvbnMpICYmXG4gICAgICAgIG9wdGlvbnMubGVkZ2VyVmVyc2lvbiAhPSBudWxsICYmXG4gICAgICAgIG9wdGlvbnMubGVkZ2VyVmVyc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRMZWRnZXJWZXJzaW9uKCkudGhlbigobGVkZ2VyVmVyc2lvbikgPT4gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgeyBsZWRnZXJWZXJzaW9uIH0pKTtcbn1cbmV4cG9ydHMuZW5zdXJlTGVkZ2VyVmVyc2lvbiA9IGVuc3VyZUxlZGdlclZlcnNpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVyaXZlWEFkZHJlc3MgPSBleHBvcnRzLmRlcml2ZUFkZHJlc3MgPSBleHBvcnRzLmRlcml2ZUtleXBhaXIgPSB2b2lkIDA7XG5jb25zdCByaXBwbGVfa2V5cGFpcnNfMSA9IHJlcXVpcmUoXCJyaXBwbGUta2V5cGFpcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXJpdmVLZXlwYWlyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByaXBwbGVfa2V5cGFpcnNfMS5kZXJpdmVLZXlwYWlyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVyaXZlQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmlwcGxlX2tleXBhaXJzXzEuZGVyaXZlQWRkcmVzczsgfSB9KTtcbmNvbnN0IHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEgPSByZXF1aXJlKFwicmlwcGxlLWFkZHJlc3MtY29kZWNcIik7XG5mdW5jdGlvbiBkZXJpdmVYQWRkcmVzcyhvcHRpb25zKSB7XG4gICAgY29uc3QgY2xhc3NpY0FkZHJlc3MgPSByaXBwbGVfa2V5cGFpcnNfMS5kZXJpdmVBZGRyZXNzKG9wdGlvbnMucHVibGljS2V5KTtcbiAgICByZXR1cm4gcmlwcGxlX2FkZHJlc3NfY29kZWNfMS5jbGFzc2ljQWRkcmVzc1RvWEFkZHJlc3MoY2xhc3NpY0FkZHJlc3MsIG9wdGlvbnMudGFnLCBvcHRpb25zLnRlc3QpO1xufVxuZXhwb3J0cy5kZXJpdmVYQWRkcmVzcyA9IGRlcml2ZVhBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVyaXZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3NBUEkgPSB2b2lkIDA7XG5jb25zdCByaXBwbGVfYWRkcmVzc19jb2RlY18xID0gcmVxdWlyZShcInJpcHBsZS1hZGRyZXNzLWNvZGVjXCIpO1xuY29uc3QgcmlwcGxlX2tleXBhaXJzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJpcHBsZS1rZXlwYWlyc1wiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBnZW5lcmF0ZUFkZHJlc3NBUEkob3B0aW9ucyA9IHt9KSB7XG4gICAgY29tbW9uXzEudmFsaWRhdGUuZ2VuZXJhdGVBZGRyZXNzKHsgb3B0aW9ucyB9KTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBnZW5lcmF0ZVNlZWRPcHRpb25zID0ge1xuICAgICAgICAgICAgYWxnb3JpdGhtOiBvcHRpb25zLmFsZ29yaXRobVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy5lbnRyb3B5KSB7XG4gICAgICAgICAgICBnZW5lcmF0ZVNlZWRPcHRpb25zLmVudHJvcHkgPSBVaW50OEFycmF5LmZyb20ob3B0aW9ucy5lbnRyb3B5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWNyZXQgPSByaXBwbGVfa2V5cGFpcnNfMS5kZWZhdWx0LmdlbmVyYXRlU2VlZChnZW5lcmF0ZVNlZWRPcHRpb25zKTtcbiAgICAgICAgY29uc3Qga2V5cGFpciA9IHJpcHBsZV9rZXlwYWlyc18xLmRlZmF1bHQuZGVyaXZlS2V5cGFpcihzZWNyZXQpO1xuICAgICAgICBjb25zdCBjbGFzc2ljQWRkcmVzcyA9IHJpcHBsZV9rZXlwYWlyc18xLmRlZmF1bHQuZGVyaXZlQWRkcmVzcyhrZXlwYWlyLnB1YmxpY0tleSk7XG4gICAgICAgIGNvbnN0IHJldHVyblZhbHVlID0ge1xuICAgICAgICAgICAgeEFkZHJlc3M6IHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuY2xhc3NpY0FkZHJlc3NUb1hBZGRyZXNzKGNsYXNzaWNBZGRyZXNzLCBmYWxzZSwgb3B0aW9ucyAmJiBvcHRpb25zLnRlc3QpLFxuICAgICAgICAgICAgc2VjcmV0XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLmluY2x1ZGVDbGFzc2ljQWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUuY2xhc3NpY0FkZHJlc3MgPSBjbGFzc2ljQWRkcmVzcztcbiAgICAgICAgICAgIHJldHVyblZhbHVlLmFkZHJlc3MgPSBjbGFzc2ljQWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgY29tbW9uXzEuZXJyb3JzLlVuZXhwZWN0ZWRFcnJvcihlcnJvci5tZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLmdlbmVyYXRlQWRkcmVzc0FQSSA9IGdlbmVyYXRlQWRkcmVzc0FQSTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlbmVyYXRlLWFkZHJlc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgXyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibG9kYXNoXCIpKTtcbmNvbnN0IGhhc2hlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9oYXNoZXNcIik7XG5jb25zdCBjb21tb24gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2NvbW1vblwiKSk7XG5mdW5jdGlvbiBjb252ZXJ0TGVkZ2VySGVhZGVyKGhlYWRlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjY291bnRfaGFzaDogaGVhZGVyLnN0YXRlSGFzaCxcbiAgICAgICAgY2xvc2VfdGltZTogY29tbW9uLmlzbzg2MDFUb1JpcHBsZVRpbWUoaGVhZGVyLmNsb3NlVGltZSksXG4gICAgICAgIGNsb3NlX3RpbWVfcmVzb2x1dGlvbjogaGVhZGVyLmNsb3NlVGltZVJlc29sdXRpb24sXG4gICAgICAgIGNsb3NlX2ZsYWdzOiBoZWFkZXIuY2xvc2VGbGFncyxcbiAgICAgICAgaGFzaDogaGVhZGVyLmxlZGdlckhhc2gsXG4gICAgICAgIGxlZGdlcl9oYXNoOiBoZWFkZXIubGVkZ2VySGFzaCxcbiAgICAgICAgbGVkZ2VyX2luZGV4OiBoZWFkZXIubGVkZ2VyVmVyc2lvbi50b1N0cmluZygpLFxuICAgICAgICBwYXJlbnRfaGFzaDogaGVhZGVyLnBhcmVudExlZGdlckhhc2gsXG4gICAgICAgIHBhcmVudF9jbG9zZV90aW1lOiBjb21tb24uaXNvODYwMVRvUmlwcGxlVGltZShoZWFkZXIucGFyZW50Q2xvc2VUaW1lKSxcbiAgICAgICAgdG90YWxfY29pbnM6IGhlYWRlci50b3RhbERyb3BzLFxuICAgICAgICB0cmFuc2FjdGlvbl9oYXNoOiBoZWFkZXIudHJhbnNhY3Rpb25IYXNoXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhc2hMZWRnZXJIZWFkZXIobGVkZ2VySGVhZGVyKSB7XG4gICAgY29uc3QgaGVhZGVyID0gY29udmVydExlZGdlckhlYWRlcihsZWRnZXJIZWFkZXIpO1xuICAgIHJldHVybiBoYXNoZXNfMS5jb21wdXRlTGVkZ2VySGFzaChoZWFkZXIpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVRyYW5zYWN0aW9uSGFzaChsZWRnZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgdHJhbnNhY3Rpb25zO1xuICAgIGlmIChsZWRnZXIucmF3VHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHRyYW5zYWN0aW9ucyA9IEpTT04ucGFyc2UobGVkZ2VyLnJhd1RyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlZGdlci50cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucyA9IGxlZGdlci50cmFuc2FjdGlvbnMubWFwKCh0eCkgPT4gSlNPTi5wYXJzZSh0eC5yYXdUcmFuc2FjdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZS50b1N0cmluZygpID09PVxuICAgICAgICAgICAgICAgICdTeW50YXhFcnJvcjogVW5leHBlY3RlZCcgKyAnIHRva2VuIHUgaW4gSlNPTiBhdCBwb3NpdGlvbiAwJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb21tb24uZXJyb3JzLlZhbGlkYXRpb25FcnJvcignbGVkZ2VyJyArICcgaXMgbWlzc2luZyByYXcgdHJhbnNhY3Rpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbXB1dGVUcmVlSGFzaGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29tbW9uLmVycm9ycy5WYWxpZGF0aW9uRXJyb3IoJ3RyYW5zYWN0aW9ucycgKyAnIHByb3BlcnR5IGlzIG1pc3NpbmcgZnJvbSB0aGUgbGVkZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZGdlci50cmFuc2FjdGlvbkhhc2g7XG4gICAgfVxuICAgIGNvbnN0IHR4cyA9IHRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgIGNvbnN0IG1lcmdlVHggPSBPYmplY3QuYXNzaWduKHt9LCBfLm9taXQodHgsICd0eCcpLCB0eC50eCB8fCB7fSk7XG4gICAgICAgIGNvbnN0IHJlbmFtZU1ldGEgPSBPYmplY3QuYXNzaWduKHt9LCBfLm9taXQobWVyZ2VUeCwgJ21ldGEnKSwgdHgubWV0YSA/IHsgbWV0YURhdGE6IHR4Lm1ldGEgfSA6IHt9KTtcbiAgICAgICAgcmV0dXJuIHJlbmFtZU1ldGE7XG4gICAgfSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25IYXNoID0gaGFzaGVzXzEuY29tcHV0ZVRyYW5zYWN0aW9uVHJlZUhhc2godHhzKTtcbiAgICBpZiAobGVkZ2VyLnRyYW5zYWN0aW9uSGFzaCAhPSBudWxsICYmXG4gICAgICAgIGxlZGdlci50cmFuc2FjdGlvbkhhc2ggIT09IHRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgY29tbW9uLmVycm9ycy5WYWxpZGF0aW9uRXJyb3IoJ3RyYW5zYWN0aW9uSGFzaCBpbiBoZWFkZXInICtcbiAgICAgICAgICAgICcgZG9lcyBub3QgbWF0Y2ggY29tcHV0ZWQgaGFzaCBvZiB0cmFuc2FjdGlvbnMnLCB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2hJbkhlYWRlcjogbGVkZ2VyLnRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgIGNvbXB1dGVkSGFzaE9mVHJhbnNhY3Rpb25zOiB0cmFuc2FjdGlvbkhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2FjdGlvbkhhc2g7XG59XG5mdW5jdGlvbiBjb21wdXRlU3RhdGVIYXNoKGxlZGdlciwgb3B0aW9ucykge1xuICAgIGlmIChsZWRnZXIucmF3U3RhdGUgPT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5jb21wdXRlVHJlZUhhc2hlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvbW1vbi5lcnJvcnMuVmFsaWRhdGlvbkVycm9yKCdyYXdTdGF0ZScgKyAnIHByb3BlcnR5IGlzIG1pc3NpbmcgZnJvbSB0aGUgbGVkZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlZGdlci5zdGF0ZUhhc2g7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShsZWRnZXIucmF3U3RhdGUpO1xuICAgIGNvbnN0IHN0YXRlSGFzaCA9IGhhc2hlc18xLmNvbXB1dGVTdGF0ZVRyZWVIYXNoKHN0YXRlKTtcbiAgICBpZiAobGVkZ2VyLnN0YXRlSGFzaCAhPSBudWxsICYmIGxlZGdlci5zdGF0ZUhhc2ggIT09IHN0YXRlSGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgY29tbW9uLmVycm9ycy5WYWxpZGF0aW9uRXJyb3IoJ3N0YXRlSGFzaCBpbiBoZWFkZXInICsgJyBkb2VzIG5vdCBtYXRjaCBjb21wdXRlZCBoYXNoIG9mIHN0YXRlJyk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZUhhc2g7XG59XG5mdW5jdGlvbiBjb21wdXRlTGVkZ2VySGVhZGVySGFzaChsZWRnZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHN1Ymhhc2hlcyA9IHtcbiAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBjb21wdXRlVHJhbnNhY3Rpb25IYXNoKGxlZGdlciwgb3B0aW9ucyksXG4gICAgICAgIHN0YXRlSGFzaDogY29tcHV0ZVN0YXRlSGFzaChsZWRnZXIsIG9wdGlvbnMpXG4gICAgfTtcbiAgICByZXR1cm4gaGFzaExlZGdlckhlYWRlcihPYmplY3QuYXNzaWduKHt9LCBsZWRnZXIsIHN1Ymhhc2hlcykpO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gY29tcHV0ZUxlZGdlckhlYWRlckhhc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWRnZXJoYXNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1vbiA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vY29tbW9uXCIpKTtcbmNvbnN0IHJpcHBsZV9rZXlwYWlyc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyaXBwbGUta2V5cGFpcnNcIikpO1xuY29uc3QgcmlwcGxlX2JpbmFyeV9jb2RlY18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyaXBwbGUtYmluYXJ5LWNvZGVjXCIpKTtcbmNvbnN0IHsgdmFsaWRhdGUsIHhycFRvRHJvcHMgfSA9IGNvbW1vbjtcbmZ1bmN0aW9uIHNpZ25QYXltZW50Q2hhbm5lbENsYWltKGNoYW5uZWwsIGFtb3VudCwgcHJpdmF0ZUtleSkge1xuICAgIHZhbGlkYXRlLnNpZ25QYXltZW50Q2hhbm5lbENsYWltKHsgY2hhbm5lbCwgYW1vdW50LCBwcml2YXRlS2V5IH0pO1xuICAgIGNvbnN0IHNpZ25pbmdEYXRhID0gcmlwcGxlX2JpbmFyeV9jb2RlY18xLmRlZmF1bHQuZW5jb2RlRm9yU2lnbmluZ0NsYWltKHtcbiAgICAgICAgY2hhbm5lbDogY2hhbm5lbCxcbiAgICAgICAgYW1vdW50OiB4cnBUb0Ryb3BzKGFtb3VudClcbiAgICB9KTtcbiAgICByZXR1cm4gcmlwcGxlX2tleXBhaXJzXzEuZGVmYXVsdC5zaWduKHNpZ25pbmdEYXRhLCBwcml2YXRlS2V5KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHNpZ25QYXltZW50Q2hhbm5lbENsYWltO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbi1wYXltZW50LWNoYW5uZWwtY2xhaW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcmlmeVBheW1lbnRDaGFubmVsQ2xhaW0gPSBleHBvcnRzLnNpZ25QYXltZW50Q2hhbm5lbENsYWltID0gZXhwb3J0cy5kZXJpdmVYQWRkcmVzcyA9IGV4cG9ydHMuZGVyaXZlQWRkcmVzcyA9IGV4cG9ydHMuZGVyaXZlS2V5cGFpciA9IGV4cG9ydHMuZ2VuZXJhdGVYQWRkcmVzcyA9IGV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZXhwb3J0cy5jb21wdXRlUGF5bWVudENoYW5uZWxIYXNoID0gZXhwb3J0cy5jb21wdXRlRXNjcm93SGFzaCA9IGV4cG9ydHMuY29tcHV0ZUxlZGdlckhhc2ggPSBleHBvcnRzLmNvbXB1dGVTdGF0ZVRyZWVIYXNoID0gZXhwb3J0cy5jb21wdXRlVHJhbnNhY3Rpb25UcmVlSGFzaCA9IGV4cG9ydHMuY29tcHV0ZVRydXN0bGluZUhhc2ggPSBleHBvcnRzLmNvbXB1dGVPcmRlcklEID0gZXhwb3J0cy5jb21wdXRlU2lnbmVyTGlzdExlZGdlck9iamVjdElEID0gZXhwb3J0cy5jb21wdXRlQWNjb3VudExlZGdlck9iamVjdElEID0gZXhwb3J0cy5jb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25TaWduaW5nSGFzaCA9IGV4cG9ydHMuY29tcHV0ZVRyYW5zYWN0aW9uSGFzaCA9IGV4cG9ydHMuY29tcHV0ZUJpbmFyeVRyYW5zYWN0aW9uSGFzaCA9IGV4cG9ydHMuaXNWYWxpZFNlY3JldCA9IGV4cG9ydHMuaXNvODYwMVRvUmlwcGxlVGltZSA9IGV4cG9ydHMucmlwcGxlVGltZVRvSVNPODYwMSA9IGV4cG9ydHMucmVtb3ZlVW5kZWZpbmVkID0gZXhwb3J0cy5jb252ZXJ0S2V5c0Zyb21TbmFrZUNhc2VUb0NhbWVsQ2FzZSA9IGV4cG9ydHMudG9SaXBwbGVkQW1vdW50ID0gZXhwb3J0cy54cnBUb0Ryb3BzID0gZXhwb3J0cy5kcm9wc1RvWHJwID0gZXhwb3J0cy5jb21wdXRlTGVkZ2VySGVhZGVySGFzaCA9IHZvaWQgMDtcbmNvbnN0IGRlcml2ZV8xID0gcmVxdWlyZShcIi4vZGVyaXZlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVyaXZlS2V5cGFpclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVyaXZlXzEuZGVyaXZlS2V5cGFpcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlcml2ZUFkZHJlc3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlcml2ZV8xLmRlcml2ZUFkZHJlc3M7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXJpdmVYQWRkcmVzc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZGVyaXZlXzEuZGVyaXZlWEFkZHJlc3M7IH0gfSk7XG5jb25zdCBsZWRnZXJoYXNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbGVkZ2VyaGFzaFwiKSk7XG5leHBvcnRzLmNvbXB1dGVMZWRnZXJIZWFkZXJIYXNoID0gbGVkZ2VyaGFzaF8xLmRlZmF1bHQ7XG5jb25zdCBzaWduX3BheW1lbnRfY2hhbm5lbF9jbGFpbV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3NpZ24tcGF5bWVudC1jaGFubmVsLWNsYWltXCIpKTtcbmV4cG9ydHMuc2lnblBheW1lbnRDaGFubmVsQ2xhaW0gPSBzaWduX3BheW1lbnRfY2hhbm5lbF9jbGFpbV8xLmRlZmF1bHQ7XG5jb25zdCB2ZXJpZnlfcGF5bWVudF9jaGFubmVsX2NsYWltXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdmVyaWZ5LXBheW1lbnQtY2hhbm5lbC1jbGFpbVwiKSk7XG5leHBvcnRzLnZlcmlmeVBheW1lbnRDaGFubmVsQ2xhaW0gPSB2ZXJpZnlfcGF5bWVudF9jaGFubmVsX2NsYWltXzEuZGVmYXVsdDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZHJvcHNUb1hycFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5kcm9wc1RvWHJwOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwieHJwVG9Ecm9wc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS54cnBUb0Ryb3BzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidG9SaXBwbGVkQW1vdW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnRvUmlwcGxlZEFtb3VudDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnZlcnRLZXlzRnJvbVNuYWtlQ2FzZVRvQ2FtZWxDYXNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNvbnZlcnRLZXlzRnJvbVNuYWtlQ2FzZVRvQ2FtZWxDYXNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVtb3ZlVW5kZWZpbmVkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnJlbW92ZVVuZGVmaW5lZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJpcHBsZVRpbWVUb0lTTzg2MDFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEucmlwcGxlVGltZVRvSVNPODYwMTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzbzg2MDFUb1JpcHBsZVRpbWVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuaXNvODYwMVRvUmlwcGxlVGltZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzVmFsaWRTZWNyZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuaXNWYWxpZFNlY3JldDsgfSB9KTtcbmNvbnN0IGhhc2hlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9oYXNoZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoZXNfMS5jb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZVRyYW5zYWN0aW9uSGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaGVzXzEuY29tcHV0ZVRyYW5zYWN0aW9uSGFzaDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXB1dGVCaW5hcnlUcmFuc2FjdGlvblNpZ25pbmdIYXNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoZXNfMS5jb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25TaWduaW5nSGFzaDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXB1dGVBY2NvdW50TGVkZ2VyT2JqZWN0SURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlc18xLmNvbXB1dGVBY2NvdW50TGVkZ2VyT2JqZWN0SUQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wdXRlU2lnbmVyTGlzdExlZGdlck9iamVjdElEXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoYXNoZXNfMS5jb21wdXRlU2lnbmVyTGlzdExlZGdlck9iamVjdElEOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZU9yZGVySURcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlc18xLmNvbXB1dGVPcmRlcklEOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZVRydXN0bGluZUhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlc18xLmNvbXB1dGVUcnVzdGxpbmVIYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZVRyYW5zYWN0aW9uVHJlZUhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlc18xLmNvbXB1dGVUcmFuc2FjdGlvblRyZWVIYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZVN0YXRlVHJlZUhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlc18xLmNvbXB1dGVTdGF0ZVRyZWVIYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZUxlZGdlckhhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlc18xLmNvbXB1dGVMZWRnZXJIYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZUVzY3Jvd0hhc2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc2hlc18xLmNvbXB1dGVFc2Nyb3dIYXNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHV0ZVBheW1lbnRDaGFubmVsSGFzaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzaGVzXzEuY29tcHV0ZVBheW1lbnRDaGFubmVsSGFzaDsgfSB9KTtcbmNvbnN0IGdlbmVyYXRlX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuLi9vZmZsaW5lL2dlbmVyYXRlLWFkZHJlc3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZW5lcmF0ZVhBZGRyZXNzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZW5lcmF0ZV9hZGRyZXNzXzEuZ2VuZXJhdGVBZGRyZXNzQVBJOyB9IH0pO1xuY29uc3QgZ2VuZXJhdGVBZGRyZXNzID0gKG9wdGlvbnMgPSB7fSkgPT4gKGdlbmVyYXRlX2FkZHJlc3NfMS5nZW5lcmF0ZUFkZHJlc3NBUEkoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBpbmNsdWRlQ2xhc3NpY0FkZHJlc3M6IHRydWUgfSkpKTtcbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZ2VuZXJhdGVBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByaXBwbGVfa2V5cGFpcnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmlwcGxlLWtleXBhaXJzXCIpKTtcbmNvbnN0IHJpcHBsZV9iaW5hcnlfY29kZWNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmlwcGxlLWJpbmFyeS1jb2RlY1wiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiB2ZXJpZnlQYXltZW50Q2hhbm5lbENsYWltKGNoYW5uZWwsIGFtb3VudCwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgICBjb21tb25fMS52YWxpZGF0ZS52ZXJpZnlQYXltZW50Q2hhbm5lbENsYWltKHsgY2hhbm5lbCwgYW1vdW50LCBzaWduYXR1cmUsIHB1YmxpY0tleSB9KTtcbiAgICBjb25zdCBzaWduaW5nRGF0YSA9IHJpcHBsZV9iaW5hcnlfY29kZWNfMS5kZWZhdWx0LmVuY29kZUZvclNpZ25pbmdDbGFpbSh7XG4gICAgICAgIGNoYW5uZWw6IGNoYW5uZWwsXG4gICAgICAgIGFtb3VudDogY29tbW9uXzEueHJwVG9Ecm9wcyhhbW91bnQpXG4gICAgfSk7XG4gICAgcmV0dXJuIHJpcHBsZV9rZXlwYWlyc18xLmRlZmF1bHQudmVyaWZ5KHNpZ25pbmdEYXRhLCBzaWduYXR1cmUsIHB1YmxpY0tleSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB2ZXJpZnlQYXltZW50Q2hhbm5lbENsYWltO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyaWZ5LXBheW1lbnQtY2hhbm5lbC1jbGFpbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZm9ybWF0TGVkZ2VyQ2xvc2UgPSBleHBvcnRzLmdldExlZGdlclZlcnNpb24gPSBleHBvcnRzLmlzQ29ubmVjdGVkID0gZXhwb3J0cy5kaXNjb25uZWN0ID0gZXhwb3J0cy5jb25uZWN0ID0gdm9pZCAwO1xuY29uc3QgY29tbW9uID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9jb21tb25cIikpO1xuZnVuY3Rpb24gaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi5pc0Nvbm5lY3RlZCgpO1xufVxuZXhwb3J0cy5pc0Nvbm5lY3RlZCA9IGlzQ29ubmVjdGVkO1xuZnVuY3Rpb24gZ2V0TGVkZ2VyVmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLmdldExlZGdlclZlcnNpb24oKTtcbn1cbmV4cG9ydHMuZ2V0TGVkZ2VyVmVyc2lvbiA9IGdldExlZGdlclZlcnNpb247XG5mdW5jdGlvbiBjb25uZWN0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdDtcbmZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGlzY29ubmVjdCA9IGRpc2Nvbm5lY3Q7XG5mdW5jdGlvbiBmb3JtYXRMZWRnZXJDbG9zZShsZWRnZXJDbG9zZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VGZWVYUlA6IGNvbW1vbi5kcm9wc1RvWHJwKGxlZGdlckNsb3NlLmZlZV9iYXNlKSxcbiAgICAgICAgbGVkZ2VySGFzaDogbGVkZ2VyQ2xvc2UubGVkZ2VyX2hhc2gsXG4gICAgICAgIGxlZGdlclZlcnNpb246IGxlZGdlckNsb3NlLmxlZGdlcl9pbmRleCxcbiAgICAgICAgbGVkZ2VyVGltZXN0YW1wOiBjb21tb24ucmlwcGxlVGltZVRvSVNPODYwMShsZWRnZXJDbG9zZS5sZWRnZXJfdGltZSksXG4gICAgICAgIHJlc2VydmVCYXNlWFJQOiBjb21tb24uZHJvcHNUb1hycChsZWRnZXJDbG9zZS5yZXNlcnZlX2Jhc2UpLFxuICAgICAgICByZXNlcnZlSW5jcmVtZW50WFJQOiBjb21tb24uZHJvcHNUb1hycChsZWRnZXJDbG9zZS5yZXNlcnZlX2luYyksXG4gICAgICAgIHRyYW5zYWN0aW9uQ291bnQ6IGxlZGdlckNsb3NlLnR4bl9jb3VudCxcbiAgICAgICAgdmFsaWRhdGVkTGVkZ2VyVmVyc2lvbnM6IGxlZGdlckNsb3NlLnZhbGlkYXRlZF9sZWRnZXJzXG4gICAgfTtcbn1cbmV4cG9ydHMuZm9ybWF0TGVkZ2VyQ2xvc2UgPSBmb3JtYXRMZWRnZXJDbG9zZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUNoZWNrQ2FuY2VsVHJhbnNhY3Rpb24oYWNjb3VudCwgY2FuY2VsKSB7XG4gICAgY29uc3QgdHhKU09OID0ge1xuICAgICAgICBBY2NvdW50OiBhY2NvdW50LFxuICAgICAgICBUcmFuc2FjdGlvblR5cGU6ICdDaGVja0NhbmNlbCcsXG4gICAgICAgIENoZWNrSUQ6IGNhbmNlbC5jaGVja0lEXG4gICAgfTtcbiAgICByZXR1cm4gdHhKU09OO1xufVxuZnVuY3Rpb24gcHJlcGFyZUNoZWNrQ2FuY2VsKGFkZHJlc3MsIGNoZWNrQ2FuY2VsLCBpbnN0cnVjdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbW1vbl8xLnZhbGlkYXRlLnByZXBhcmVDaGVja0NhbmNlbCh7IGFkZHJlc3MsIGNoZWNrQ2FuY2VsLCBpbnN0cnVjdGlvbnMgfSk7XG4gICAgICAgIGNvbnN0IHR4SlNPTiA9IGNyZWF0ZUNoZWNrQ2FuY2VsVHJhbnNhY3Rpb24oYWRkcmVzcywgY2hlY2tDYW5jZWwpO1xuICAgICAgICByZXR1cm4gdXRpbHNfMS5wcmVwYXJlVHJhbnNhY3Rpb24odHhKU09OLCB0aGlzLCBpbnN0cnVjdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gcHJlcGFyZUNoZWNrQ2FuY2VsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2stY2FuY2VsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHV0aWxzLmNvbW1vbi5lcnJvcnMuVmFsaWRhdGlvbkVycm9yO1xuY29uc3QgdG9SaXBwbGVkQW1vdW50ID0gdXRpbHMuY29tbW9uLnRvUmlwcGxlZEFtb3VudDtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUNoZWNrQ2FzaFRyYW5zYWN0aW9uKGFjY291bnQsIGNoZWNrQ2FzaCkge1xuICAgIGlmIChjaGVja0Nhc2guYW1vdW50ICYmIGNoZWNrQ2FzaC5kZWxpdmVyTWluKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ1wiYW1vdW50XCIgYW5kIFwiZGVsaXZlck1pblwiIHByb3BlcnRpZXMgb24gJyArXG4gICAgICAgICAgICAnQ2hlY2tDYXNoIGFyZSBtdXR1YWxseSBleGNsdXNpdmUnKTtcbiAgICB9XG4gICAgY29uc3QgdHhKU09OID0ge1xuICAgICAgICBBY2NvdW50OiBhY2NvdW50LFxuICAgICAgICBUcmFuc2FjdGlvblR5cGU6ICdDaGVja0Nhc2gnLFxuICAgICAgICBDaGVja0lEOiBjaGVja0Nhc2guY2hlY2tJRFxuICAgIH07XG4gICAgaWYgKGNoZWNrQ2FzaC5hbW91bnQgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uQW1vdW50ID0gdG9SaXBwbGVkQW1vdW50KGNoZWNrQ2FzaC5hbW91bnQpO1xuICAgIH1cbiAgICBpZiAoY2hlY2tDYXNoLmRlbGl2ZXJNaW4gIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uRGVsaXZlck1pbiA9IHRvUmlwcGxlZEFtb3VudChjaGVja0Nhc2guZGVsaXZlck1pbik7XG4gICAgfVxuICAgIHJldHVybiB0eEpTT047XG59XG5mdW5jdGlvbiBwcmVwYXJlQ2hlY2tDYXNoKGFkZHJlc3MsIGNoZWNrQ2FzaCwgaW5zdHJ1Y3Rpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBjb21tb25fMS52YWxpZGF0ZS5wcmVwYXJlQ2hlY2tDYXNoKHsgYWRkcmVzcywgY2hlY2tDYXNoLCBpbnN0cnVjdGlvbnMgfSk7XG4gICAgICAgIGNvbnN0IHR4SlNPTiA9IGNyZWF0ZUNoZWNrQ2FzaFRyYW5zYWN0aW9uKGFkZHJlc3MsIGNoZWNrQ2FzaCk7XG4gICAgICAgIHJldHVybiB1dGlscy5wcmVwYXJlVHJhbnNhY3Rpb24odHhKU09OLCB0aGlzLCBpbnN0cnVjdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gcHJlcGFyZUNoZWNrQ2FzaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoZWNrLWNhc2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgdG9SaXBwbGVkQW1vdW50ID0gdXRpbHMuY29tbW9uLnRvUmlwcGxlZEFtb3VudDtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUNoZWNrQ3JlYXRlVHJhbnNhY3Rpb24oYWNjb3VudCwgY2hlY2spIHtcbiAgICBjb25zdCB0eEpTT04gPSB7XG4gICAgICAgIEFjY291bnQ6IGFjY291bnQsXG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ0NoZWNrQ3JlYXRlJyxcbiAgICAgICAgRGVzdGluYXRpb246IGNoZWNrLmRlc3RpbmF0aW9uLFxuICAgICAgICBTZW5kTWF4OiB0b1JpcHBsZWRBbW91bnQoY2hlY2suc2VuZE1heClcbiAgICB9O1xuICAgIGlmIChjaGVjay5kZXN0aW5hdGlvblRhZyAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5EZXN0aW5hdGlvblRhZyA9IGNoZWNrLmRlc3RpbmF0aW9uVGFnO1xuICAgIH1cbiAgICBpZiAoY2hlY2suZXhwaXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5FeHBpcmF0aW9uID0gY29tbW9uXzEuaXNvODYwMVRvUmlwcGxlVGltZShjaGVjay5leHBpcmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKGNoZWNrLmludm9pY2VJRCAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5JbnZvaWNlSUQgPSBjaGVjay5pbnZvaWNlSUQ7XG4gICAgfVxuICAgIHJldHVybiB0eEpTT047XG59XG5mdW5jdGlvbiBwcmVwYXJlQ2hlY2tDcmVhdGUoYWRkcmVzcywgY2hlY2tDcmVhdGUsIGluc3RydWN0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29tbW9uXzEudmFsaWRhdGUucHJlcGFyZUNoZWNrQ3JlYXRlKHsgYWRkcmVzcywgY2hlY2tDcmVhdGUsIGluc3RydWN0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgdHhKU09OID0gY3JlYXRlQ2hlY2tDcmVhdGVUcmFuc2FjdGlvbihhZGRyZXNzLCBjaGVja0NyZWF0ZSk7XG4gICAgICAgIHJldHVybiB1dGlscy5wcmVwYXJlVHJhbnNhY3Rpb24odHhKU09OLCB0aGlzLCBpbnN0cnVjdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gcHJlcGFyZUNoZWNrQ3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlY2stY3JlYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IF8gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImxvZGFzaFwiKSk7XG5jb25zdCByaXBwbGVfYmluYXJ5X2NvZGVjXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInJpcHBsZS1iaW5hcnktY29kZWNcIikpO1xuY29uc3QgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZXJyb3JzXCIpO1xuY29uc3QgcmlwcGxlX2FkZHJlc3NfY29kZWNfMSA9IHJlcXVpcmUoXCJyaXBwbGUtYWRkcmVzcy1jb2RlY1wiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmNvbnN0IGhhc2hlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9oYXNoZXNcIik7XG5mdW5jdGlvbiB2YWxpZGF0ZVRyYW5zYWN0aW9uRXF1aXZhbGVuY2UodHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgZXhhbXBsZVRyYW5zYWN0aW9uID0gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbnNbMF0pLCB7IFNpZ25lcnM6IG51bGwgfSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbnMuc2xpY2UoMSkuc29tZSh0eCA9PiBKU09OLnN0cmluZ2lmeShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHR4KSwgeyBTaWduZXJzOiBudWxsIH0pKSAhPT0gZXhhbXBsZVRyYW5zYWN0aW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsaWRhdGlvbkVycm9yKCd0eEpTT04gaXMgbm90IHRoZSBzYW1lIGZvciBhbGwgc2lnbmVkVHJhbnNhY3Rpb25zJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYWRkcmVzc1RvQmlnTnVtYmVyKGFkZHJlc3MpIHtcbiAgICBjb25zdCBoZXggPSBCdWZmZXIuZnJvbShyaXBwbGVfYWRkcmVzc19jb2RlY18xLmRlY29kZUFjY291bnRJRChhZGRyZXNzKSkudG9TdHJpbmcoJ2hleCcpO1xuICAgIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChoZXgsIDE2KTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVTaWduZXJzKGEsIGIpIHtcbiAgICByZXR1cm4gYWRkcmVzc1RvQmlnTnVtYmVyKGEuU2lnbmVyLkFjY291bnQpLmNvbXBhcmVkVG8oYWRkcmVzc1RvQmlnTnVtYmVyKGIuU2lnbmVyLkFjY291bnQpKTtcbn1cbmZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uV2l0aEFsbFNpZ25lcnModHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3Qgc29ydGVkU2lnbmVycyA9IF8uZmxhdE1hcCh0cmFuc2FjdGlvbnMsIHR4ID0+IHR4LlNpZ25lcnMpXG4gICAgICAgIC5maWx0ZXIoc2lnbmVyID0+IHNpZ25lcilcbiAgICAgICAgLnNvcnQoY29tcGFyZVNpZ25lcnMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uc1swXSksIHsgU2lnbmVyczogc29ydGVkU2lnbmVycyB9KTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmUoc2lnbmVkVHJhbnNhY3Rpb25zKSB7XG4gICAgY29tbW9uXzEudmFsaWRhdGUuY29tYmluZSh7IHNpZ25lZFRyYW5zYWN0aW9ucyB9KTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzaWduZWRUcmFuc2FjdGlvbnMubWFwKHJpcHBsZV9iaW5hcnlfY29kZWNfMS5kZWZhdWx0LmRlY29kZSk7XG4gICAgdmFsaWRhdGVUcmFuc2FjdGlvbkVxdWl2YWxlbmNlKHRyYW5zYWN0aW9ucyk7XG4gICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSByaXBwbGVfYmluYXJ5X2NvZGVjXzEuZGVmYXVsdC5lbmNvZGUoZ2V0VHJhbnNhY3Rpb25XaXRoQWxsU2lnbmVycyh0cmFuc2FjdGlvbnMpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaWduZWRUcmFuc2FjdGlvbjogc2lnbmVkVHJhbnNhY3Rpb24sXG4gICAgICAgIGlkOiBoYXNoZXNfMS5jb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoKHNpZ25lZFRyYW5zYWN0aW9uKVxuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjb21iaW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tYmluZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCB2YWxpZGF0ZSA9IHV0aWxzLmNvbW1vbi52YWxpZGF0ZTtcbmZ1bmN0aW9uIGNyZWF0ZUVzY3Jvd0NhbmNlbGxhdGlvblRyYW5zYWN0aW9uKGFjY291bnQsIHBheW1lbnQpIHtcbiAgICBjb25zdCB0eEpTT04gPSB7XG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ0VzY3Jvd0NhbmNlbCcsXG4gICAgICAgIEFjY291bnQ6IGFjY291bnQsXG4gICAgICAgIE93bmVyOiBwYXltZW50Lm93bmVyLFxuICAgICAgICBPZmZlclNlcXVlbmNlOiBwYXltZW50LmVzY3Jvd1NlcXVlbmNlXG4gICAgfTtcbiAgICBpZiAocGF5bWVudC5tZW1vcyAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5NZW1vcyA9IHBheW1lbnQubWVtb3MubWFwKHV0aWxzLmNvbnZlcnRNZW1vKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4SlNPTjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVFc2Nyb3dDYW5jZWxsYXRpb24oYWRkcmVzcywgZXNjcm93Q2FuY2VsbGF0aW9uLCBpbnN0cnVjdGlvbnMgPSB7fSkge1xuICAgIHZhbGlkYXRlLnByZXBhcmVFc2Nyb3dDYW5jZWxsYXRpb24oe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBlc2Nyb3dDYW5jZWxsYXRpb24sXG4gICAgICAgIGluc3RydWN0aW9uc1xuICAgIH0pO1xuICAgIGNvbnN0IHR4SlNPTiA9IGNyZWF0ZUVzY3Jvd0NhbmNlbGxhdGlvblRyYW5zYWN0aW9uKGFkZHJlc3MsIGVzY3Jvd0NhbmNlbGxhdGlvbik7XG4gICAgcmV0dXJuIHV0aWxzLnByZXBhcmVUcmFuc2FjdGlvbih0eEpTT04sIHRoaXMsIGluc3RydWN0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwcmVwYXJlRXNjcm93Q2FuY2VsbGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXNjcm93LWNhbmNlbGxhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSB1dGlscy5jb21tb24uZXJyb3JzLlZhbGlkYXRpb25FcnJvcjtcbmZ1bmN0aW9uIGNyZWF0ZUVzY3Jvd0NyZWF0aW9uVHJhbnNhY3Rpb24oYWNjb3VudCwgcGF5bWVudCkge1xuICAgIGNvbnN0IHR4SlNPTiA9IHtcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlOiAnRXNjcm93Q3JlYXRlJyxcbiAgICAgICAgQWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgRGVzdGluYXRpb246IHBheW1lbnQuZGVzdGluYXRpb24sXG4gICAgICAgIEFtb3VudDogY29tbW9uXzEueHJwVG9Ecm9wcyhwYXltZW50LmFtb3VudClcbiAgICB9O1xuICAgIGlmIChwYXltZW50LmNvbmRpdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5Db25kaXRpb24gPSBwYXltZW50LmNvbmRpdGlvbjtcbiAgICB9XG4gICAgaWYgKHBheW1lbnQuYWxsb3dDYW5jZWxBZnRlciAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5DYW5jZWxBZnRlciA9IGNvbW1vbl8xLmlzbzg2MDFUb1JpcHBsZVRpbWUocGF5bWVudC5hbGxvd0NhbmNlbEFmdGVyKTtcbiAgICB9XG4gICAgaWYgKHBheW1lbnQuYWxsb3dFeGVjdXRlQWZ0ZXIgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uRmluaXNoQWZ0ZXIgPSBjb21tb25fMS5pc284NjAxVG9SaXBwbGVUaW1lKHBheW1lbnQuYWxsb3dFeGVjdXRlQWZ0ZXIpO1xuICAgIH1cbiAgICBpZiAocGF5bWVudC5zb3VyY2VUYWcgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uU291cmNlVGFnID0gcGF5bWVudC5zb3VyY2VUYWc7XG4gICAgfVxuICAgIGlmIChwYXltZW50LmRlc3RpbmF0aW9uVGFnICE9IG51bGwpIHtcbiAgICAgICAgdHhKU09OLkRlc3RpbmF0aW9uVGFnID0gcGF5bWVudC5kZXN0aW5hdGlvblRhZztcbiAgICB9XG4gICAgaWYgKHBheW1lbnQubWVtb3MgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uTWVtb3MgPSBwYXltZW50Lm1lbW9zLm1hcCh1dGlscy5jb252ZXJ0TWVtbyk7XG4gICAgfVxuICAgIGlmIChCb29sZWFuKHBheW1lbnQuYWxsb3dDYW5jZWxBZnRlcikgJiZcbiAgICAgICAgQm9vbGVhbihwYXltZW50LmFsbG93RXhlY3V0ZUFmdGVyKSAmJlxuICAgICAgICB0eEpTT04uQ2FuY2VsQWZ0ZXIgPD0gdHhKU09OLkZpbmlzaEFmdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3ByZXBhcmVFc2Nyb3dDcmVhdGlvbjogJyArXG4gICAgICAgICAgICAnXCJhbGxvd0NhbmNlbEFmdGVyXCIgbXVzdCBiZSBhZnRlciBcImFsbG93RXhlY3V0ZUFmdGVyXCInKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4SlNPTjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVFc2Nyb3dDcmVhdGlvbihhZGRyZXNzLCBlc2Nyb3dDcmVhdGlvbiwgaW5zdHJ1Y3Rpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBjb21tb25fMS52YWxpZGF0ZS5wcmVwYXJlRXNjcm93Q3JlYXRpb24oeyBhZGRyZXNzLCBlc2Nyb3dDcmVhdGlvbiwgaW5zdHJ1Y3Rpb25zIH0pO1xuICAgICAgICBjb25zdCB0eEpTT04gPSBjcmVhdGVFc2Nyb3dDcmVhdGlvblRyYW5zYWN0aW9uKGFkZHJlc3MsIGVzY3Jvd0NyZWF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnByZXBhcmVUcmFuc2FjdGlvbih0eEpTT04sIHRoaXMsIGluc3RydWN0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwcmVwYXJlRXNjcm93Q3JlYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lc2Nyb3ctY3JlYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgdmFsaWRhdGUgPSB1dGlscy5jb21tb24udmFsaWRhdGU7XG5jb25zdCBWYWxpZGF0aW9uRXJyb3IgPSB1dGlscy5jb21tb24uZXJyb3JzLlZhbGlkYXRpb25FcnJvcjtcbmZ1bmN0aW9uIGNyZWF0ZUVzY3Jvd0V4ZWN1dGlvblRyYW5zYWN0aW9uKGFjY291bnQsIHBheW1lbnQpIHtcbiAgICBjb25zdCB0eEpTT04gPSB7XG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ0VzY3Jvd0ZpbmlzaCcsXG4gICAgICAgIEFjY291bnQ6IGFjY291bnQsXG4gICAgICAgIE93bmVyOiBwYXltZW50Lm93bmVyLFxuICAgICAgICBPZmZlclNlcXVlbmNlOiBwYXltZW50LmVzY3Jvd1NlcXVlbmNlXG4gICAgfTtcbiAgICBpZiAoQm9vbGVhbihwYXltZW50LmNvbmRpdGlvbikgIT09IEJvb2xlYW4ocGF5bWVudC5mdWxmaWxsbWVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignXCJjb25kaXRpb25cIiBhbmQgXCJmdWxmaWxsbWVudFwiIGZpZWxkcyBvbicgK1xuICAgICAgICAgICAgJyBFc2Nyb3dGaW5pc2ggbXVzdCBvbmx5IGJlIHNwZWNpZmllZCB0b2dldGhlci4nKTtcbiAgICB9XG4gICAgaWYgKHBheW1lbnQuY29uZGl0aW9uICE9IG51bGwpIHtcbiAgICAgICAgdHhKU09OLkNvbmRpdGlvbiA9IHBheW1lbnQuY29uZGl0aW9uO1xuICAgIH1cbiAgICBpZiAocGF5bWVudC5mdWxmaWxsbWVudCAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5GdWxmaWxsbWVudCA9IHBheW1lbnQuZnVsZmlsbG1lbnQ7XG4gICAgfVxuICAgIGlmIChwYXltZW50Lm1lbW9zICE9IG51bGwpIHtcbiAgICAgICAgdHhKU09OLk1lbW9zID0gcGF5bWVudC5tZW1vcy5tYXAodXRpbHMuY29udmVydE1lbW8pO1xuICAgIH1cbiAgICByZXR1cm4gdHhKU09OO1xufVxuZnVuY3Rpb24gcHJlcGFyZUVzY3Jvd0V4ZWN1dGlvbihhZGRyZXNzLCBlc2Nyb3dFeGVjdXRpb24sIGluc3RydWN0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFsaWRhdGUucHJlcGFyZUVzY3Jvd0V4ZWN1dGlvbih7IGFkZHJlc3MsIGVzY3Jvd0V4ZWN1dGlvbiwgaW5zdHJ1Y3Rpb25zIH0pO1xuICAgICAgICBjb25zdCB0eEpTT04gPSBjcmVhdGVFc2Nyb3dFeGVjdXRpb25UcmFuc2FjdGlvbihhZGRyZXNzLCBlc2Nyb3dFeGVjdXRpb24pO1xuICAgICAgICByZXR1cm4gdXRpbHMucHJlcGFyZVRyYW5zYWN0aW9uKHR4SlNPTiwgdGhpcywgaW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHByZXBhcmVFc2Nyb3dFeGVjdXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lc2Nyb3ctZXhlY3V0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IG9mZmVyRmxhZ3MgPSB1dGlscy5jb21tb24udHhGbGFncy5PZmZlckNyZWF0ZTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmZ1bmN0aW9uIGNyZWF0ZU9yZGVyVHJhbnNhY3Rpb24oYWNjb3VudCwgb3JkZXIpIHtcbiAgICBjb25zdCB0YWtlclBheXMgPSBjb21tb25fMS50b1JpcHBsZWRBbW91bnQob3JkZXIuZGlyZWN0aW9uID09PSAnYnV5JyA/IG9yZGVyLnF1YW50aXR5IDogb3JkZXIudG90YWxQcmljZSk7XG4gICAgY29uc3QgdGFrZXJHZXRzID0gY29tbW9uXzEudG9SaXBwbGVkQW1vdW50KG9yZGVyLmRpcmVjdGlvbiA9PT0gJ2J1eScgPyBvcmRlci50b3RhbFByaWNlIDogb3JkZXIucXVhbnRpdHkpO1xuICAgIGNvbnN0IHR4SlNPTiA9IHtcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlOiAnT2ZmZXJDcmVhdGUnLFxuICAgICAgICBBY2NvdW50OiBhY2NvdW50LFxuICAgICAgICBUYWtlckdldHM6IHRha2VyR2V0cyxcbiAgICAgICAgVGFrZXJQYXlzOiB0YWtlclBheXMsXG4gICAgICAgIEZsYWdzOiAwXG4gICAgfTtcbiAgICBpZiAob3JkZXIuZGlyZWN0aW9uID09PSAnc2VsbCcpIHtcbiAgICAgICAgdHhKU09OLkZsYWdzIHw9IG9mZmVyRmxhZ3MuU2VsbDtcbiAgICB9XG4gICAgaWYgKG9yZGVyLnBhc3NpdmUgPT09IHRydWUpIHtcbiAgICAgICAgdHhKU09OLkZsYWdzIHw9IG9mZmVyRmxhZ3MuUGFzc2l2ZTtcbiAgICB9XG4gICAgaWYgKG9yZGVyLmltbWVkaWF0ZU9yQ2FuY2VsID09PSB0cnVlKSB7XG4gICAgICAgIHR4SlNPTi5GbGFncyB8PSBvZmZlckZsYWdzLkltbWVkaWF0ZU9yQ2FuY2VsO1xuICAgIH1cbiAgICBpZiAob3JkZXIuZmlsbE9yS2lsbCA9PT0gdHJ1ZSkge1xuICAgICAgICB0eEpTT04uRmxhZ3MgfD0gb2ZmZXJGbGFncy5GaWxsT3JLaWxsO1xuICAgIH1cbiAgICBpZiAob3JkZXIuZXhwaXJhdGlvblRpbWUgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uRXhwaXJhdGlvbiA9IGNvbW1vbl8xLmlzbzg2MDFUb1JpcHBsZVRpbWUob3JkZXIuZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICBpZiAob3JkZXIub3JkZXJUb1JlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uT2ZmZXJTZXF1ZW5jZSA9IG9yZGVyLm9yZGVyVG9SZXBsYWNlO1xuICAgIH1cbiAgICBpZiAob3JkZXIubWVtb3MgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uTWVtb3MgPSBvcmRlci5tZW1vcy5tYXAodXRpbHMuY29udmVydE1lbW8pO1xuICAgIH1cbiAgICByZXR1cm4gdHhKU09OO1xufVxuZnVuY3Rpb24gcHJlcGFyZU9yZGVyKGFkZHJlc3MsIG9yZGVyLCBpbnN0cnVjdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbW1vbl8xLnZhbGlkYXRlLnByZXBhcmVPcmRlcih7IGFkZHJlc3MsIG9yZGVyLCBpbnN0cnVjdGlvbnMgfSk7XG4gICAgICAgIGNvbnN0IHR4SlNPTiA9IGNyZWF0ZU9yZGVyVHJhbnNhY3Rpb24oYWRkcmVzcywgb3JkZXIpO1xuICAgICAgICByZXR1cm4gdXRpbHMucHJlcGFyZVRyYW5zYWN0aW9uKHR4SlNPTiwgdGhpcywgaW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHByZXBhcmVPcmRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IHZhbGlkYXRlID0gdXRpbHMuY29tbW9uLnZhbGlkYXRlO1xuZnVuY3Rpb24gY3JlYXRlT3JkZXJDYW5jZWxsYXRpb25UcmFuc2FjdGlvbihhY2NvdW50LCBvcmRlckNhbmNlbGxhdGlvbikge1xuICAgIGNvbnN0IHR4SlNPTiA9IHtcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlOiAnT2ZmZXJDYW5jZWwnLFxuICAgICAgICBBY2NvdW50OiBhY2NvdW50LFxuICAgICAgICBPZmZlclNlcXVlbmNlOiBvcmRlckNhbmNlbGxhdGlvbi5vcmRlclNlcXVlbmNlXG4gICAgfTtcbiAgICBpZiAob3JkZXJDYW5jZWxsYXRpb24ubWVtb3MgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uTWVtb3MgPSBvcmRlckNhbmNlbGxhdGlvbi5tZW1vcy5tYXAodXRpbHMuY29udmVydE1lbW8pO1xuICAgIH1cbiAgICByZXR1cm4gdHhKU09OO1xufVxuZnVuY3Rpb24gcHJlcGFyZU9yZGVyQ2FuY2VsbGF0aW9uKGFkZHJlc3MsIG9yZGVyQ2FuY2VsbGF0aW9uLCBpbnN0cnVjdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRlLnByZXBhcmVPcmRlckNhbmNlbGxhdGlvbih7XG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgb3JkZXJDYW5jZWxsYXRpb24sXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHR4SlNPTiA9IGNyZWF0ZU9yZGVyQ2FuY2VsbGF0aW9uVHJhbnNhY3Rpb24oYWRkcmVzcywgb3JkZXJDYW5jZWxsYXRpb24pO1xuICAgICAgICByZXR1cm4gdXRpbHMucHJlcGFyZVRyYW5zYWN0aW9uKHR4SlNPTiwgdGhpcywgaW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHByZXBhcmVPcmRlckNhbmNlbGxhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9yZGVyY2FuY2VsbGF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHV0aWxzLmNvbW1vbi5lcnJvcnMuVmFsaWRhdGlvbkVycm9yO1xuY29uc3QgY2xhaW1GbGFncyA9IHV0aWxzLmNvbW1vbi50eEZsYWdzLlBheW1lbnRDaGFubmVsQ2xhaW07XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBjcmVhdGVQYXltZW50Q2hhbm5lbENsYWltVHJhbnNhY3Rpb24oYWNjb3VudCwgY2xhaW0pIHtcbiAgICBjb25zdCB0eEpTT04gPSB7XG4gICAgICAgIEFjY291bnQ6IGFjY291bnQsXG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ1BheW1lbnRDaGFubmVsQ2xhaW0nLFxuICAgICAgICBDaGFubmVsOiBjbGFpbS5jaGFubmVsLFxuICAgICAgICBGbGFnczogMFxuICAgIH07XG4gICAgaWYgKGNsYWltLmJhbGFuY2UgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uQmFsYW5jZSA9IGNvbW1vbl8xLnhycFRvRHJvcHMoY2xhaW0uYmFsYW5jZSk7XG4gICAgfVxuICAgIGlmIChjbGFpbS5hbW91bnQgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uQW1vdW50ID0gY29tbW9uXzEueHJwVG9Ecm9wcyhjbGFpbS5hbW91bnQpO1xuICAgIH1cbiAgICBpZiAoQm9vbGVhbihjbGFpbS5zaWduYXR1cmUpICE9PSBCb29sZWFuKGNsYWltLnB1YmxpY0tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignXCJzaWduYXR1cmVcIiBhbmQgXCJwdWJsaWNLZXlcIiBmaWVsZHMgb24nICtcbiAgICAgICAgICAgICcgUGF5bWVudENoYW5uZWxDbGFpbSBtdXN0IG9ubHkgYmUgc3BlY2lmaWVkIHRvZ2V0aGVyLicpO1xuICAgIH1cbiAgICBpZiAoY2xhaW0uc2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgdHhKU09OLlNpZ25hdHVyZSA9IGNsYWltLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgaWYgKGNsYWltLnB1YmxpY0tleSAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5QdWJsaWNLZXkgPSBjbGFpbS5wdWJsaWNLZXk7XG4gICAgfVxuICAgIGlmIChjbGFpbS5yZW5ldyA9PT0gdHJ1ZSAmJiBjbGFpbS5jbG9zZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKCdcInJlbmV3XCIgYW5kIFwiY2xvc2VcIiBmbGFncyBvbiBQYXltZW50Q2hhbm5lbENsYWltJyArXG4gICAgICAgICAgICAnIGFyZSBtdXR1YWxseSBleGNsdXNpdmUnKTtcbiAgICB9XG4gICAgaWYgKGNsYWltLnJlbmV3ID09PSB0cnVlKSB7XG4gICAgICAgIHR4SlNPTi5GbGFncyB8PSBjbGFpbUZsYWdzLlJlbmV3O1xuICAgIH1cbiAgICBpZiAoY2xhaW0uY2xvc2UgPT09IHRydWUpIHtcbiAgICAgICAgdHhKU09OLkZsYWdzIHw9IGNsYWltRmxhZ3MuQ2xvc2U7XG4gICAgfVxuICAgIHJldHVybiB0eEpTT047XG59XG5mdW5jdGlvbiBwcmVwYXJlUGF5bWVudENoYW5uZWxDbGFpbShhZGRyZXNzLCBwYXltZW50Q2hhbm5lbENsYWltLCBpbnN0cnVjdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbW1vbl8xLnZhbGlkYXRlLnByZXBhcmVQYXltZW50Q2hhbm5lbENsYWltKHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBwYXltZW50Q2hhbm5lbENsYWltLFxuICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eEpTT04gPSBjcmVhdGVQYXltZW50Q2hhbm5lbENsYWltVHJhbnNhY3Rpb24oYWRkcmVzcywgcGF5bWVudENoYW5uZWxDbGFpbSk7XG4gICAgICAgIHJldHVybiB1dGlscy5wcmVwYXJlVHJhbnNhY3Rpb24odHhKU09OLCB0aGlzLCBpbnN0cnVjdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gcHJlcGFyZVBheW1lbnRDaGFubmVsQ2xhaW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXltZW50LWNoYW5uZWwtY2xhaW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuZnVuY3Rpb24gY3JlYXRlUGF5bWVudENoYW5uZWxDcmVhdGVUcmFuc2FjdGlvbihhY2NvdW50LCBwYXltZW50Q2hhbm5lbCkge1xuICAgIGNvbnN0IHR4SlNPTiA9IHtcbiAgICAgICAgQWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlOiAnUGF5bWVudENoYW5uZWxDcmVhdGUnLFxuICAgICAgICBBbW91bnQ6IGNvbW1vbl8xLnhycFRvRHJvcHMocGF5bWVudENoYW5uZWwuYW1vdW50KSxcbiAgICAgICAgRGVzdGluYXRpb246IHBheW1lbnRDaGFubmVsLmRlc3RpbmF0aW9uLFxuICAgICAgICBTZXR0bGVEZWxheTogcGF5bWVudENoYW5uZWwuc2V0dGxlRGVsYXksXG4gICAgICAgIFB1YmxpY0tleTogcGF5bWVudENoYW5uZWwucHVibGljS2V5LnRvVXBwZXJDYXNlKClcbiAgICB9O1xuICAgIGlmIChwYXltZW50Q2hhbm5lbC5jYW5jZWxBZnRlciAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5DYW5jZWxBZnRlciA9IGNvbW1vbl8xLmlzbzg2MDFUb1JpcHBsZVRpbWUocGF5bWVudENoYW5uZWwuY2FuY2VsQWZ0ZXIpO1xuICAgIH1cbiAgICBpZiAocGF5bWVudENoYW5uZWwuc291cmNlVGFnICE9IG51bGwpIHtcbiAgICAgICAgdHhKU09OLlNvdXJjZVRhZyA9IHBheW1lbnRDaGFubmVsLnNvdXJjZVRhZztcbiAgICB9XG4gICAgaWYgKHBheW1lbnRDaGFubmVsLmRlc3RpbmF0aW9uVGFnICE9IG51bGwpIHtcbiAgICAgICAgdHhKU09OLkRlc3RpbmF0aW9uVGFnID0gcGF5bWVudENoYW5uZWwuZGVzdGluYXRpb25UYWc7XG4gICAgfVxuICAgIHJldHVybiB0eEpTT047XG59XG5mdW5jdGlvbiBwcmVwYXJlUGF5bWVudENoYW5uZWxDcmVhdGUoYWRkcmVzcywgcGF5bWVudENoYW5uZWxDcmVhdGUsIGluc3RydWN0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29tbW9uXzEudmFsaWRhdGUucHJlcGFyZVBheW1lbnRDaGFubmVsQ3JlYXRlKHtcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBwYXltZW50Q2hhbm5lbENyZWF0ZSxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHhKU09OID0gY3JlYXRlUGF5bWVudENoYW5uZWxDcmVhdGVUcmFuc2FjdGlvbihhZGRyZXNzLCBwYXltZW50Q2hhbm5lbENyZWF0ZSk7XG4gICAgICAgIHJldHVybiB1dGlscy5wcmVwYXJlVHJhbnNhY3Rpb24odHhKU09OLCB0aGlzLCBpbnN0cnVjdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gcHJlcGFyZVBheW1lbnRDaGFubmVsQ3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF5bWVudC1jaGFubmVsLWNyZWF0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBjcmVhdGVQYXltZW50Q2hhbm5lbEZ1bmRUcmFuc2FjdGlvbihhY2NvdW50LCBmdW5kKSB7XG4gICAgY29uc3QgdHhKU09OID0ge1xuICAgICAgICBBY2NvdW50OiBhY2NvdW50LFxuICAgICAgICBUcmFuc2FjdGlvblR5cGU6ICdQYXltZW50Q2hhbm5lbEZ1bmQnLFxuICAgICAgICBDaGFubmVsOiBmdW5kLmNoYW5uZWwsXG4gICAgICAgIEFtb3VudDogY29tbW9uXzEueHJwVG9Ecm9wcyhmdW5kLmFtb3VudClcbiAgICB9O1xuICAgIGlmIChmdW5kLmV4cGlyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uRXhwaXJhdGlvbiA9IGNvbW1vbl8xLmlzbzg2MDFUb1JpcHBsZVRpbWUoZnVuZC5leHBpcmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4SlNPTjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVQYXltZW50Q2hhbm5lbEZ1bmQoYWRkcmVzcywgcGF5bWVudENoYW5uZWxGdW5kLCBpbnN0cnVjdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbW1vbl8xLnZhbGlkYXRlLnByZXBhcmVQYXltZW50Q2hhbm5lbEZ1bmQoe1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIHBheW1lbnRDaGFubmVsRnVuZCxcbiAgICAgICAgICAgIGluc3RydWN0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdHhKU09OID0gY3JlYXRlUGF5bWVudENoYW5uZWxGdW5kVHJhbnNhY3Rpb24oYWRkcmVzcywgcGF5bWVudENoYW5uZWxGdW5kKTtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnByZXBhcmVUcmFuc2FjdGlvbih0eEpTT04sIHRoaXMsIGluc3RydWN0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwcmVwYXJlUGF5bWVudENoYW5uZWxGdW5kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF5bWVudC1jaGFubmVsLWZ1bmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgXyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibG9kYXNoXCIpKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IHZhbGlkYXRlID0gdXRpbHMuY29tbW9uLnZhbGlkYXRlO1xuY29uc3QgcGF5bWVudEZsYWdzID0gdXRpbHMuY29tbW9uLnR4RmxhZ3MuUGF5bWVudDtcbmNvbnN0IFZhbGlkYXRpb25FcnJvciA9IHV0aWxzLmNvbW1vbi5lcnJvcnMuVmFsaWRhdGlvbkVycm9yO1xuY29uc3QgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZnVuY3Rpb24gaXNNYXhBZGp1c3RtZW50KHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UubWF4QW1vdW50ICE9IG51bGw7XG59XG5mdW5jdGlvbiBpc01pbkFkanVzdG1lbnQoZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb24ubWluQW1vdW50ICE9IG51bGw7XG59XG5mdW5jdGlvbiBpc1hSUFRvWFJQUGF5bWVudChwYXltZW50KSB7XG4gICAgY29uc3QgeyBzb3VyY2UsIGRlc3RpbmF0aW9uIH0gPSBwYXltZW50O1xuICAgIGNvbnN0IHNvdXJjZUN1cnJlbmN5ID0gaXNNYXhBZGp1c3RtZW50KHNvdXJjZSlcbiAgICAgICAgPyBzb3VyY2UubWF4QW1vdW50LmN1cnJlbmN5XG4gICAgICAgIDogc291cmNlLmFtb3VudC5jdXJyZW5jeTtcbiAgICBjb25zdCBkZXN0aW5hdGlvbkN1cnJlbmN5ID0gaXNNaW5BZGp1c3RtZW50KGRlc3RpbmF0aW9uKVxuICAgICAgICA/IGRlc3RpbmF0aW9uLm1pbkFtb3VudC5jdXJyZW5jeVxuICAgICAgICA6IGRlc3RpbmF0aW9uLmFtb3VudC5jdXJyZW5jeTtcbiAgICByZXR1cm4gKChzb3VyY2VDdXJyZW5jeSA9PT0gJ1hSUCcgfHwgc291cmNlQ3VycmVuY3kgPT09ICdkcm9wcycpICYmXG4gICAgICAgIChkZXN0aW5hdGlvbkN1cnJlbmN5ID09PSAnWFJQJyB8fCBkZXN0aW5hdGlvbkN1cnJlbmN5ID09PSAnZHJvcHMnKSk7XG59XG5mdW5jdGlvbiBpc0lPVVdpdGhvdXRDb3VudGVycGFydHkoYW1vdW50KSB7XG4gICAgcmV0dXJuIChhbW91bnQgJiZcbiAgICAgICAgYW1vdW50LmN1cnJlbmN5ICE9PSAnWFJQJyAmJlxuICAgICAgICBhbW91bnQuY3VycmVuY3kgIT09ICdkcm9wcycgJiZcbiAgICAgICAgYW1vdW50LmNvdW50ZXJwYXJ0eSA9PSBudWxsKTtcbn1cbmZ1bmN0aW9uIGFwcGx5QW55Q291bnRlcnBhcnR5RW5jb2RpbmcocGF5bWVudCkge1xuICAgIFtwYXltZW50LnNvdXJjZSwgcGF5bWVudC5kZXN0aW5hdGlvbl0uZm9yRWFjaCgoYWRqdXN0bWVudCkgPT4ge1xuICAgICAgICBbJ2Ftb3VudCcsICdtaW5BbW91bnQnLCAnbWF4QW1vdW50J10uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNJT1VXaXRob3V0Q291bnRlcnBhcnR5KGFkanVzdG1lbnRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBhZGp1c3RtZW50W2tleV0uY291bnRlcnBhcnR5ID0gYWRqdXN0bWVudC5hZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1heGltYWxBbW91bnQoYW1vdW50KSB7XG4gICAgY29uc3QgbWF4WFJQVmFsdWUgPSAnMTAwMDAwMDAwMDAwJztcbiAgICBjb25zdCBtYXhJT1VWYWx1ZSA9ICc5OTk5OTk5OTk5OTk5OTk5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xuICAgIGxldCBtYXhWYWx1ZTtcbiAgICBpZiAoYW1vdW50LmN1cnJlbmN5ID09PSAnWFJQJykge1xuICAgICAgICBtYXhWYWx1ZSA9IG1heFhSUFZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbW91bnQuY3VycmVuY3kgPT09ICdkcm9wcycpIHtcbiAgICAgICAgbWF4VmFsdWUgPSBjb21tb25fMS54cnBUb0Ryb3BzKG1heFhSUFZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1heFZhbHVlID0gbWF4SU9VVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBhbW91bnQsIHsgdmFsdWU6IG1heFZhbHVlIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBbmROb3JtYWxpemVBZGRyZXNzKGFkZHJlc3MsIGV4cGVjdGVkVGFnKSB7XG4gICAgY29uc3QgY2xhc3NpY0FkZHJlc3MgPSB1dGlsc18xLmdldENsYXNzaWNBY2NvdW50QW5kVGFnKGFkZHJlc3MsIGV4cGVjdGVkVGFnKTtcbiAgICBjbGFzc2ljQWRkcmVzcy50YWcgPVxuICAgICAgICBjbGFzc2ljQWRkcmVzcy50YWcgPT09IGZhbHNlID8gdW5kZWZpbmVkIDogY2xhc3NpY0FkZHJlc3MudGFnO1xuICAgIHJldHVybiBjbGFzc2ljQWRkcmVzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBheW1lbnRUcmFuc2FjdGlvbihhZGRyZXNzLCBwYXltZW50QXJndW1lbnQpIHtcbiAgICBjb25zdCBwYXltZW50ID0gXy5jbG9uZURlZXAocGF5bWVudEFyZ3VtZW50KTtcbiAgICBhcHBseUFueUNvdW50ZXJwYXJ0eUVuY29kaW5nKHBheW1lbnQpO1xuICAgIGNvbnN0IHNvdXJjZUFkZHJlc3NBbmRUYWcgPSB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUFkZHJlc3MocGF5bWVudC5zb3VyY2UuYWRkcmVzcywgcGF5bWVudC5zb3VyY2UudGFnKTtcbiAgICBjb25zdCBhZGRyZXNzVG9WZXJpZnlBZ2FpbnN0ID0gdmFsaWRhdGVBbmROb3JtYWxpemVBZGRyZXNzKGFkZHJlc3MsIHVuZGVmaW5lZCk7XG4gICAgaWYgKGFkZHJlc3NUb1ZlcmlmeUFnYWluc3QuY2xhc3NpY0FjY291bnQgIT09IHNvdXJjZUFkZHJlc3NBbmRUYWcuY2xhc3NpY0FjY291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignYWRkcmVzcyBtdXN0IG1hdGNoIHBheW1lbnQuc291cmNlLmFkZHJlc3MnKTtcbiAgICB9XG4gICAgaWYgKGFkZHJlc3NUb1ZlcmlmeUFnYWluc3QudGFnICE9IG51bGwgJiZcbiAgICAgICAgc291cmNlQWRkcmVzc0FuZFRhZy50YWcgIT0gbnVsbCAmJlxuICAgICAgICBhZGRyZXNzVG9WZXJpZnlBZ2FpbnN0LnRhZyAhPT0gc291cmNlQWRkcmVzc0FuZFRhZy50YWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignYWRkcmVzcyBpbmNsdWRlcyBhIHRhZyB0aGF0IGRvZXMgbm90IG1hdGNoIHBheW1lbnQuc291cmNlLnRhZycpO1xuICAgIH1cbiAgICBjb25zdCBkZXN0aW5hdGlvbkFkZHJlc3NBbmRUYWcgPSB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUFkZHJlc3MocGF5bWVudC5kZXN0aW5hdGlvbi5hZGRyZXNzLCBwYXltZW50LmRlc3RpbmF0aW9uLnRhZyk7XG4gICAgaWYgKChpc01heEFkanVzdG1lbnQocGF5bWVudC5zb3VyY2UpICYmIGlzTWluQWRqdXN0bWVudChwYXltZW50LmRlc3RpbmF0aW9uKSkgfHxcbiAgICAgICAgKCFpc01heEFkanVzdG1lbnQocGF5bWVudC5zb3VyY2UpICYmICFpc01pbkFkanVzdG1lbnQocGF5bWVudC5kZXN0aW5hdGlvbikpKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ3BheW1lbnQgbXVzdCBzcGVjaWZ5IGVpdGhlciAoc291cmNlLm1heEFtb3VudCAnICtcbiAgICAgICAgICAgICdhbmQgZGVzdGluYXRpb24uYW1vdW50KSBvciAoc291cmNlLmFtb3VudCBhbmQgZGVzdGluYXRpb24ubWluQW1vdW50KScpO1xuICAgIH1cbiAgICBjb25zdCBkZXN0aW5hdGlvbkFtb3VudCA9IGlzTWluQWRqdXN0bWVudChwYXltZW50LmRlc3RpbmF0aW9uKVxuICAgICAgICA/IHBheW1lbnQuZGVzdGluYXRpb24ubWluQW1vdW50XG4gICAgICAgIDogcGF5bWVudC5kZXN0aW5hdGlvbi5hbW91bnQ7XG4gICAgY29uc3Qgc291cmNlQW1vdW50ID0gaXNNYXhBZGp1c3RtZW50KHBheW1lbnQuc291cmNlKVxuICAgICAgICA/IHBheW1lbnQuc291cmNlLm1heEFtb3VudFxuICAgICAgICA6IHBheW1lbnQuc291cmNlLmFtb3VudDtcbiAgICBjb25zdCBhbW91bnQgPSBpc01pbkFkanVzdG1lbnQocGF5bWVudC5kZXN0aW5hdGlvbikgJiYgIWlzWFJQVG9YUlBQYXltZW50KHBheW1lbnQpXG4gICAgICAgID8gY3JlYXRlTWF4aW1hbEFtb3VudChkZXN0aW5hdGlvbkFtb3VudClcbiAgICAgICAgOiBkZXN0aW5hdGlvbkFtb3VudDtcbiAgICBjb25zdCB0eEpTT04gPSB7XG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ1BheW1lbnQnLFxuICAgICAgICBBY2NvdW50OiBzb3VyY2VBZGRyZXNzQW5kVGFnLmNsYXNzaWNBY2NvdW50LFxuICAgICAgICBEZXN0aW5hdGlvbjogZGVzdGluYXRpb25BZGRyZXNzQW5kVGFnLmNsYXNzaWNBY2NvdW50LFxuICAgICAgICBBbW91bnQ6IGNvbW1vbl8xLnRvUmlwcGxlZEFtb3VudChhbW91bnQpLFxuICAgICAgICBGbGFnczogMFxuICAgIH07XG4gICAgaWYgKHBheW1lbnQuaW52b2ljZUlEICE9IG51bGwpIHtcbiAgICAgICAgdHhKU09OLkludm9pY2VJRCA9IHBheW1lbnQuaW52b2ljZUlEO1xuICAgIH1cbiAgICBpZiAoc291cmNlQWRkcmVzc0FuZFRhZy50YWcgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uU291cmNlVGFnID0gc291cmNlQWRkcmVzc0FuZFRhZy50YWc7XG4gICAgfVxuICAgIGlmIChkZXN0aW5hdGlvbkFkZHJlc3NBbmRUYWcudGFnICE9IG51bGwpIHtcbiAgICAgICAgdHhKU09OLkRlc3RpbmF0aW9uVGFnID0gZGVzdGluYXRpb25BZGRyZXNzQW5kVGFnLnRhZztcbiAgICB9XG4gICAgaWYgKHBheW1lbnQubWVtb3MgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uTWVtb3MgPSBwYXltZW50Lm1lbW9zLm1hcCh1dGlscy5jb252ZXJ0TWVtbyk7XG4gICAgfVxuICAgIGlmIChwYXltZW50Lm5vRGlyZWN0UmlwcGxlID09PSB0cnVlKSB7XG4gICAgICAgIHR4SlNPTi5GbGFncyB8PSBwYXltZW50RmxhZ3MuTm9SaXBwbGVEaXJlY3Q7XG4gICAgfVxuICAgIGlmIChwYXltZW50LmxpbWl0UXVhbGl0eSA9PT0gdHJ1ZSkge1xuICAgICAgICB0eEpTT04uRmxhZ3MgfD0gcGF5bWVudEZsYWdzLkxpbWl0UXVhbGl0eTtcbiAgICB9XG4gICAgaWYgKCFpc1hSUFRvWFJQUGF5bWVudChwYXltZW50KSkge1xuICAgICAgICBpZiAocGF5bWVudC5hbGxvd1BhcnRpYWxQYXltZW50IHx8IGlzTWluQWRqdXN0bWVudChwYXltZW50LmRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgdHhKU09OLkZsYWdzIHw9IHBheW1lbnRGbGFncy5QYXJ0aWFsUGF5bWVudDtcbiAgICAgICAgfVxuICAgICAgICB0eEpTT04uU2VuZE1heCA9IGNvbW1vbl8xLnRvUmlwcGxlZEFtb3VudChzb3VyY2VBbW91bnQpO1xuICAgICAgICBpZiAoaXNNaW5BZGp1c3RtZW50KHBheW1lbnQuZGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICB0eEpTT04uRGVsaXZlck1pbiA9IGNvbW1vbl8xLnRvUmlwcGxlZEFtb3VudChkZXN0aW5hdGlvbkFtb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBheW1lbnQucGF0aHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHhKU09OLlBhdGhzID0gSlNPTi5wYXJzZShwYXltZW50LnBhdGhzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXltZW50LmFsbG93UGFydGlhbFBheW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbGlkYXRpb25FcnJvcignWFJQIHRvIFhSUCBwYXltZW50cyBjYW5ub3QgYmUgcGFydGlhbCBwYXltZW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gdHhKU09OO1xufVxuZnVuY3Rpb24gcHJlcGFyZVBheW1lbnQoYWRkcmVzcywgcGF5bWVudCwgaW5zdHJ1Y3Rpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICB2YWxpZGF0ZS5wcmVwYXJlUGF5bWVudCh7IGFkZHJlc3MsIHBheW1lbnQsIGluc3RydWN0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgdHhKU09OID0gY3JlYXRlUGF5bWVudFRyYW5zYWN0aW9uKGFkZHJlc3MsIHBheW1lbnQpO1xuICAgICAgICByZXR1cm4gdXRpbHMucHJlcGFyZVRyYW5zYWN0aW9uKHR4SlNPTiwgdGhpcywgaW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHByZXBhcmVQYXltZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF5bWVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBhc3NlcnQgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImFzc2VydFwiKSk7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmlnbnVtYmVyLmpzXCIpKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IHZhbGlkYXRlID0gdXRpbHMuY29tbW9uLnZhbGlkYXRlO1xuY29uc3QgQWNjb3VudFNldEZsYWdzID0gdXRpbHMuY29tbW9uLmNvbnN0YW50cy5BY2NvdW50U2V0RmxhZ3M7XG5jb25zdCBBY2NvdW50RmllbGRzID0gdXRpbHMuY29tbW9uLmNvbnN0YW50cy5BY2NvdW50RmllbGRzO1xuZnVuY3Rpb24gc2V0VHJhbnNhY3Rpb25GbGFncyh0eEpTT04sIHZhbHVlcykge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpLmZpbHRlcigoa2V5KSA9PiBBY2NvdW50U2V0RmxhZ3Nba2V5XSAhPSBudWxsKTtcbiAgICBhc3NlcnQub2soa2V5cy5sZW5ndGggPD0gMSwgJ0VSUk9SOiBjYW4gb25seSBzZXQgb25lIHNldHRpbmcgcGVyIHRyYW5zYWN0aW9uJyk7XG4gICAgY29uc3QgZmxhZ05hbWUgPSBrZXlzWzBdO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ZsYWdOYW1lXTtcbiAgICBjb25zdCBpbmRleCA9IEFjY291bnRTZXRGbGFnc1tmbGFnTmFtZV07XG4gICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0eEpTT04uU2V0RmxhZyA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHhKU09OLkNsZWFyRmxhZyA9IGluZGV4O1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0VHJhbnNhY3Rpb25GaWVsZHModHhKU09OLCBpbnB1dCkge1xuICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gQWNjb3VudEZpZWxkcztcbiAgICBmb3IgKGNvbnN0IGZpZWxkTmFtZSBpbiBmaWVsZFNjaGVtYSkge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkU2NoZW1hW2ZpZWxkTmFtZV07XG4gICAgICAgIGxldCB2YWx1ZSA9IGlucHV0W2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsICYmIGZpZWxkLmhhc093blByb3BlcnR5KCdkZWZhdWx0cycpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZC5lbmNvZGluZyA9PT0gJ2hleCcgJiYgIWZpZWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ2FzY2lpJykudG9TdHJpbmcoJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdHhKU09OW2ZpZWxkTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb252ZXJ0VHJhbnNmZXJSYXRlKHRyYW5zZmVyUmF0ZSkge1xuICAgIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdCh0cmFuc2ZlclJhdGUpLnNoaWZ0ZWRCeSg5KS50b051bWJlcigpO1xufVxuZnVuY3Rpb24gZm9ybWF0U2lnbmVyRW50cnkoc2lnbmVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgU2lnbmVyRW50cnk6IHtcbiAgICAgICAgICAgIEFjY291bnQ6IHNpZ25lci5hZGRyZXNzLFxuICAgICAgICAgICAgU2lnbmVyV2VpZ2h0OiBzaWduZXIud2VpZ2h0XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2V0dGluZ3NUcmFuc2FjdGlvbldpdGhvdXRNZW1vcyhhY2NvdW50LCBzZXR0aW5ncykge1xuICAgIGlmIChzZXR0aW5ncy5yZWd1bGFyS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcmVtb3ZlUmVndWxhcktleSA9IHtcbiAgICAgICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ1NldFJlZ3VsYXJLZXknLFxuICAgICAgICAgICAgQWNjb3VudDogYWNjb3VudFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2V0dGluZ3MucmVndWxhcktleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVJlZ3VsYXJLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlbW92ZVJlZ3VsYXJLZXksIHtcbiAgICAgICAgICAgIFJlZ3VsYXJLZXk6IHNldHRpbmdzLnJlZ3VsYXJLZXlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy5zaWduZXJzICE9IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc2V0U2lnbmVyTGlzdCA9IHtcbiAgICAgICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ1NpZ25lckxpc3RTZXQnLFxuICAgICAgICAgICAgQWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgICAgIFNpZ25lckVudHJpZXM6IFtdLFxuICAgICAgICAgICAgU2lnbmVyUXVvcnVtOiBzZXR0aW5ncy5zaWduZXJzLnRocmVzaG9sZFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2lnbmVycy53ZWlnaHRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFNpZ25lckxpc3QuU2lnbmVyRW50cmllcyA9IHNldHRpbmdzLnNpZ25lcnMud2VpZ2h0cy5tYXAoZm9ybWF0U2lnbmVyRW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRTaWduZXJMaXN0O1xuICAgIH1cbiAgICBjb25zdCB0eEpTT04gPSB7XG4gICAgICAgIFRyYW5zYWN0aW9uVHlwZTogJ0FjY291bnRTZXQnLFxuICAgICAgICBBY2NvdW50OiBhY2NvdW50XG4gICAgfTtcbiAgICBjb25zdCBzZXR0aW5nc1dpdGhvdXRNZW1vcyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzKTtcbiAgICBkZWxldGUgc2V0dGluZ3NXaXRob3V0TWVtb3MubWVtb3M7XG4gICAgc2V0VHJhbnNhY3Rpb25GbGFncyh0eEpTT04sIHNldHRpbmdzV2l0aG91dE1lbW9zKTtcbiAgICBzZXRUcmFuc2FjdGlvbkZpZWxkcyh0eEpTT04sIHNldHRpbmdzKTtcbiAgICBpZiAodHhKU09OLlRyYW5zZmVyUmF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5UcmFuc2ZlclJhdGUgPSBjb252ZXJ0VHJhbnNmZXJSYXRlKHR4SlNPTi5UcmFuc2ZlclJhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHhKU09OO1xufVxuZnVuY3Rpb24gY3JlYXRlU2V0dGluZ3NUcmFuc2FjdGlvbihhY2NvdW50LCBzZXR0aW5ncykge1xuICAgIGNvbnN0IHR4SlNPTiA9IGNyZWF0ZVNldHRpbmdzVHJhbnNhY3Rpb25XaXRob3V0TWVtb3MoYWNjb3VudCwgc2V0dGluZ3MpO1xuICAgIGlmIChzZXR0aW5ncy5tZW1vcyAhPSBudWxsKSB7XG4gICAgICAgIHR4SlNPTi5NZW1vcyA9IHNldHRpbmdzLm1lbW9zLm1hcCh1dGlscy5jb252ZXJ0TWVtbyk7XG4gICAgfVxuICAgIHJldHVybiB0eEpTT047XG59XG5mdW5jdGlvbiBwcmVwYXJlU2V0dGluZ3MoYWRkcmVzcywgc2V0dGluZ3MsIGluc3RydWN0aW9ucyA9IHt9KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFsaWRhdGUucHJlcGFyZVNldHRpbmdzKHsgYWRkcmVzcywgc2V0dGluZ3MsIGluc3RydWN0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgdHhKU09OID0gY3JlYXRlU2V0dGluZ3NUcmFuc2FjdGlvbihhZGRyZXNzLCBzZXR0aW5ncyk7XG4gICAgICAgIHJldHVybiB1dGlscy5wcmVwYXJlVHJhbnNhY3Rpb24odHhKU09OLCB0aGlzLCBpbnN0cnVjdGlvbnMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gcHJlcGFyZVNldHRpbmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2V0dGluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgbG9kYXNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaFwiKSk7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCByaXBwbGVfa2V5cGFpcnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmlwcGxlLWtleXBhaXJzXCIpKTtcbmNvbnN0IHJpcHBsZV9iaW5hcnlfY29kZWNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicmlwcGxlLWJpbmFyeS1jb2RlY1wiKSk7XG5jb25zdCBoYXNoZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaGFzaGVzXCIpO1xuY29uc3QgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5jb25zdCB2YWxpZGF0ZSA9IHV0aWxzLmNvbW1vbi52YWxpZGF0ZTtcbmZ1bmN0aW9uIGNvbXB1dGVTaWduYXR1cmUodHgsIHByaXZhdGVLZXksIHNpZ25Bcykge1xuICAgIGNvbnN0IHNpZ25pbmdEYXRhID0gc2lnbkFzXG4gICAgICAgID8gcmlwcGxlX2JpbmFyeV9jb2RlY18xLmRlZmF1bHQuZW5jb2RlRm9yTXVsdGlzaWduaW5nKHR4LCBzaWduQXMpXG4gICAgICAgIDogcmlwcGxlX2JpbmFyeV9jb2RlY18xLmRlZmF1bHQuZW5jb2RlRm9yU2lnbmluZyh0eCk7XG4gICAgcmV0dXJuIHJpcHBsZV9rZXlwYWlyc18xLmRlZmF1bHQuc2lnbihzaWduaW5nRGF0YSwgcHJpdmF0ZUtleSk7XG59XG5mdW5jdGlvbiBzaWduV2l0aEtleXBhaXIoYXBpLCB0eEpTT04sIGtleXBhaXIsIG9wdGlvbnMgPSB7XG4gICAgc2lnbkFzOiAnJ1xufSkge1xuICAgIHZhbGlkYXRlLnNpZ24oeyB0eEpTT04sIGtleXBhaXIgfSk7XG4gICAgY29uc3QgdHggPSBKU09OLnBhcnNlKHR4SlNPTik7XG4gICAgaWYgKHR4LlR4blNpZ25hdHVyZSB8fCB0eC5TaWduZXJzKSB7XG4gICAgICAgIHRocm93IG5ldyB1dGlscy5jb21tb24uZXJyb3JzLlZhbGlkYXRpb25FcnJvcigndHhKU09OIG11c3Qgbm90IGNvbnRhaW4gXCJUeG5TaWduYXR1cmVcIiBvciBcIlNpZ25lcnNcIiBwcm9wZXJ0aWVzJyk7XG4gICAgfVxuICAgIGNoZWNrRmVlKGFwaSwgdHguRmVlKTtcbiAgICBjb25zdCB0eFRvU2lnbkFuZEVuY29kZSA9IE9iamVjdC5hc3NpZ24oe30sIHR4KTtcbiAgICB0eFRvU2lnbkFuZEVuY29kZS5TaWduaW5nUHViS2V5ID0gb3B0aW9ucy5zaWduQXMgPyAnJyA6IGtleXBhaXIucHVibGljS2V5O1xuICAgIGlmIChvcHRpb25zLnNpZ25Bcykge1xuICAgICAgICBjb25zdCBzaWduZXIgPSB7XG4gICAgICAgICAgICBBY2NvdW50OiBvcHRpb25zLnNpZ25BcyxcbiAgICAgICAgICAgIFNpZ25pbmdQdWJLZXk6IGtleXBhaXIucHVibGljS2V5LFxuICAgICAgICAgICAgVHhuU2lnbmF0dXJlOiBjb21wdXRlU2lnbmF0dXJlKHR4VG9TaWduQW5kRW5jb2RlLCBrZXlwYWlyLnByaXZhdGVLZXksIG9wdGlvbnMuc2lnbkFzKVxuICAgICAgICB9O1xuICAgICAgICB0eFRvU2lnbkFuZEVuY29kZS5TaWduZXJzID0gW3sgU2lnbmVyOiBzaWduZXIgfV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0eFRvU2lnbkFuZEVuY29kZS5UeG5TaWduYXR1cmUgPSBjb21wdXRlU2lnbmF0dXJlKHR4VG9TaWduQW5kRW5jb2RlLCBrZXlwYWlyLnByaXZhdGVLZXkpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkID0gcmlwcGxlX2JpbmFyeV9jb2RlY18xLmRlZmF1bHQuZW5jb2RlKHR4VG9TaWduQW5kRW5jb2RlKTtcbiAgICBjaGVja1R4U2VyaWFsaXphdGlvbihzZXJpYWxpemVkLCB0eCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2lnbmVkVHJhbnNhY3Rpb246IHNlcmlhbGl6ZWQsXG4gICAgICAgIGlkOiBoYXNoZXNfMS5jb21wdXRlQmluYXJ5VHJhbnNhY3Rpb25IYXNoKHNlcmlhbGl6ZWQpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG9iamVjdERpZmYoYSwgYikge1xuICAgIGNvbnN0IGRpZmZzID0ge307XG4gICAgY29uc3QgY29tcGFyZSA9IGZ1bmN0aW9uIChpMSwgaTIsIGspIHtcbiAgICAgICAgY29uc3QgdHlwZTEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaTEpO1xuICAgICAgICBjb25zdCB0eXBlMiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpMik7XG4gICAgICAgIGlmICh0eXBlMiA9PT0gJ1tvYmplY3QgVW5kZWZpbmVkXScpIHtcbiAgICAgICAgICAgIGRpZmZzW2tdID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZTEgIT09IHR5cGUyKSB7XG4gICAgICAgICAgICBkaWZmc1trXSA9IGkyO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlMSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICAgIGNvbnN0IG9iakRpZmYgPSBvYmplY3REaWZmKGkxLCBpMik7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMob2JqRGlmZikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGRpZmZzW2tdID0gb2JqRGlmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZTEgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgIGlmICghbG9kYXNoXzEuZGVmYXVsdC5pc0VxdWFsKGkxLCBpMikpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1trXSA9IGkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlMSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJykge1xuICAgICAgICAgICAgaWYgKGkxLnRvU3RyaW5nKCkgIT09IGkyLnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBkaWZmc1trXSA9IGkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpMSAhPT0gaTIpIHtcbiAgICAgICAgICAgIGRpZmZzW2tdID0gaTI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGEpIHtcbiAgICAgICAgaWYgKGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29tcGFyZShhW2tleV0sIGJba2V5XSwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBiKSB7XG4gICAgICAgIGlmIChiLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGlmICghYVtrZXldICYmIGFba2V5XSAhPT0gYltrZXldKSB7XG4gICAgICAgICAgICAgICAgZGlmZnNba2V5XSA9IGJba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZnM7XG59XG5mdW5jdGlvbiBjaGVja1R4U2VyaWFsaXphdGlvbihzZXJpYWxpemVkLCB0eCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBkZWNvZGVkID0gcmlwcGxlX2JpbmFyeV9jb2RlY18xLmRlZmF1bHQuZGVjb2RlKHNlcmlhbGl6ZWQpO1xuICAgIGlmICghZGVjb2RlZC5UeG5TaWduYXR1cmUgJiYgIWRlY29kZWQuU2lnbmVycykge1xuICAgICAgICB0aHJvdyBuZXcgdXRpbHMuY29tbW9uLmVycm9ycy5WYWxpZGF0aW9uRXJyb3IoJ1NlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gbXVzdCBoYXZlIGEgVHhuU2lnbmF0dXJlIG9yIFNpZ25lcnMgcHJvcGVydHknKTtcbiAgICB9XG4gICAgZGVsZXRlIGRlY29kZWQuVHhuU2lnbmF0dXJlO1xuICAgIGRlbGV0ZSBkZWNvZGVkLlNpZ25lcnM7XG4gICAgaWYgKCF0eC5TaWduaW5nUHViS2V5KSB7XG4gICAgICAgIGRlbGV0ZSBkZWNvZGVkLlNpZ25pbmdQdWJLZXk7XG4gICAgfVxuICAgIChfYSA9IHR4Lk1lbW9zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKG1lbW8gPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKChfYSA9IG1lbW8gPT09IG51bGwgfHwgbWVtbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVtby5NZW1vKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuTWVtb0RhdGEpIHtcbiAgICAgICAgICAgIG1lbW8uTWVtby5NZW1vRGF0YSA9IG1lbW8uTWVtby5NZW1vRGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoX2IgPSBtZW1vID09PSBudWxsIHx8IG1lbW8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lbW8uTWVtbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLk1lbW9UeXBlKSB7XG4gICAgICAgICAgICBtZW1vLk1lbW8uTWVtb1R5cGUgPSBtZW1vLk1lbW8uTWVtb1R5cGUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKF9jID0gbWVtbyA9PT0gbnVsbCB8fCBtZW1vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZW1vLk1lbW8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5NZW1vRm9ybWF0KSB7XG4gICAgICAgICAgICBtZW1vLk1lbW8uTWVtb0Zvcm1hdCA9IG1lbW8uTWVtby5NZW1vRm9ybWF0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSk7XG4gICAgaWYgKCFsb2Rhc2hfMS5kZWZhdWx0LmlzRXF1YWwoZGVjb2RlZCwgdHgpKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IHV0aWxzLmNvbW1vbi5lcnJvcnMuVmFsaWRhdGlvbkVycm9yKCdTZXJpYWxpemVkIHRyYW5zYWN0aW9uIGRvZXMgbm90IG1hdGNoIG9yaWdpbmFsIHR4SlNPTi4gU2VlIGBlcnJvci5kYXRhYCcpO1xuICAgICAgICBlcnJvci5kYXRhID0ge1xuICAgICAgICAgICAgZGVjb2RlZCxcbiAgICAgICAgICAgIHR4LFxuICAgICAgICAgICAgZGlmZjogb2JqZWN0RGlmZih0eCwgZGVjb2RlZClcbiAgICAgICAgfTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tGZWUoYXBpLCB0eEZlZSkge1xuICAgIGNvbnN0IGZlZSA9IG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHR4RmVlKTtcbiAgICBjb25zdCBtYXhGZWVEcm9wcyA9IGNvbW1vbl8xLnhycFRvRHJvcHMoYXBpLl9tYXhGZWVYUlApO1xuICAgIGlmIChmZWUuaXNHcmVhdGVyVGhhbihtYXhGZWVEcm9wcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IHV0aWxzLmNvbW1vbi5lcnJvcnMuVmFsaWRhdGlvbkVycm9yKGBcIkZlZVwiIHNob3VsZCBub3QgZXhjZWVkIFwiJHttYXhGZWVEcm9wc31cIi4gYCArXG4gICAgICAgICAgICAnVG8gdXNlIGEgaGlnaGVyIGZlZSwgc2V0IGBtYXhGZWVYUlBgIGluIHRoZSBSaXBwbGVBUEkgY29uc3RydWN0b3IuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2lnbih0eEpTT04sIHNlY3JldCwgb3B0aW9ucywga2V5cGFpcikge1xuICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWxpZGF0ZS5zaWduKHsgdHhKU09OLCBzZWNyZXQgfSk7XG4gICAgICAgIHJldHVybiBzaWduV2l0aEtleXBhaXIodGhpcywgdHhKU09OLCByaXBwbGVfa2V5cGFpcnNfMS5kZWZhdWx0LmRlcml2ZUtleXBhaXIoc2VjcmV0KSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWtleXBhaXIgJiYgIXNlY3JldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHV0aWxzLmNvbW1vbi5lcnJvcnMuVmFsaWRhdGlvbkVycm9yKCdzaWduOiBNaXNzaW5nIHNlY3JldCBvciBrZXlwYWlyLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduV2l0aEtleXBhaXIodGhpcywgdHhKU09OLCBrZXlwYWlyID8ga2V5cGFpciA6IHNlY3JldCwgb3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gc2lnbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5mdW5jdGlvbiBpc0ltbWVkaWF0ZVJlamVjdGlvbihlbmdpbmVSZXN1bHQpIHtcbiAgICByZXR1cm4gZW5naW5lUmVzdWx0LnN0YXJ0c1dpdGgoJ3RlbScpO1xufVxuZnVuY3Rpb24gZm9ybWF0U3VibWl0UmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICByZXN1bHRDb2RlOiByZXNwb25zZS5lbmdpbmVfcmVzdWx0LFxuICAgICAgICByZXN1bHRNZXNzYWdlOiByZXNwb25zZS5lbmdpbmVfcmVzdWx0X21lc3NhZ2UsXG4gICAgICAgIGVuZ2luZV9yZXN1bHQ6IHJlc3BvbnNlLmVuZ2luZV9yZXN1bHQsXG4gICAgICAgIGVuZ2luZV9yZXN1bHRfY29kZTogcmVzcG9uc2UuZW5naW5lX3Jlc3VsdF9jb2RlLFxuICAgICAgICBlbmdpbmVfcmVzdWx0X21lc3NhZ2U6IHJlc3BvbnNlLmVuZ2luZV9yZXN1bHRfbWVzc2FnZSxcbiAgICAgICAgdHhfYmxvYjogcmVzcG9uc2UudHhfYmxvYixcbiAgICAgICAgdHhfanNvbjogcmVzcG9uc2UudHhfanNvblxuICAgIH07XG4gICAgaWYgKGlzSW1tZWRpYXRlUmVqZWN0aW9uKHJlc3BvbnNlLmVuZ2luZV9yZXN1bHQpKSB7XG4gICAgICAgIHRocm93IG5ldyB1dGlscy5jb21tb24uZXJyb3JzLlJpcHBsZWRFcnJvcignU3VibWl0IGZhaWxlZCcsIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIHN1Ym1pdChzaWduZWRUcmFuc2FjdGlvbiwgZmFpbEhhcmQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb21tb25fMS52YWxpZGF0ZS5zdWJtaXQoeyBzaWduZWRUcmFuc2FjdGlvbiB9KTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnJlcXVlc3QoJ3N1Ym1pdCcsIE9iamVjdC5hc3NpZ24oeyB0eF9ibG9iOiBzaWduZWRUcmFuc2FjdGlvbiB9LCAoZmFpbEhhcmQgPyB7IGZhaWxfaGFyZDogZmFpbEhhcmQgfSA6IHt9KSkpO1xuICAgICAgICByZXR1cm4gZm9ybWF0U3VibWl0UmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gc3VibWl0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3VibWl0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IHZhbGlkYXRlID0gdXRpbHMuY29tbW9uLnZhbGlkYXRlO1xuY29uc3QgVmFsaWRhdGlvbkVycm9yID0gdXRpbHMuY29tbW9uLmVycm9ycy5WYWxpZGF0aW9uRXJyb3I7XG5mdW5jdGlvbiBjcmVhdGVUaWNrZXRUcmFuc2FjdGlvbihhY2NvdW50LCB0aWNrZXRDb3VudCkge1xuICAgIGlmICghdGlja2V0Q291bnQgfHwgdGlja2V0Q291bnQgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IoJ1RpY2tldCBjb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xuICAgIGNvbnN0IHR4SlNPTiA9IHtcbiAgICAgICAgVHJhbnNhY3Rpb25UeXBlOiAnVGlja2V0Q3JlYXRlJyxcbiAgICAgICAgQWNjb3VudDogYWNjb3VudCxcbiAgICAgICAgVGlja2V0Q291bnQ6IHRpY2tldENvdW50XG4gICAgfTtcbiAgICByZXR1cm4gdHhKU09OO1xufVxuZnVuY3Rpb24gcHJlcGFyZVRpY2tldENyZWF0ZShhZGRyZXNzLCB0aWNrZXRDb3VudCwgaW5zdHJ1Y3Rpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICB2YWxpZGF0ZS5wcmVwYXJlVGlja2V0Q3JlYXRlKHsgYWRkcmVzcywgdGlja2V0Q291bnQsIGluc3RydWN0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgdHhKU09OID0gY3JlYXRlVGlja2V0VHJhbnNhY3Rpb24oYWRkcmVzcywgdGlja2V0Q291bnQpO1xuICAgICAgICByZXR1cm4gdXRpbHMucHJlcGFyZVRyYW5zYWN0aW9uKHR4SlNPTiwgdGhpcywgaW5zdHJ1Y3Rpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHByZXBhcmVUaWNrZXRDcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aWNrZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmlnbnVtYmVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJpZ251bWJlci5qc1wiKSk7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCB2YWxpZGF0ZSA9IHV0aWxzLmNvbW1vbi52YWxpZGF0ZTtcbmNvbnN0IHRydXN0bGluZUZsYWdzID0gdXRpbHMuY29tbW9uLnR4RmxhZ3MuVHJ1c3RTZXQ7XG5mdW5jdGlvbiBjb252ZXJ0UXVhbGl0eShxdWFsaXR5KSB7XG4gICAgcmV0dXJuIG5ldyBiaWdudW1iZXJfanNfMS5kZWZhdWx0KHF1YWxpdHkpXG4gICAgICAgIC5zaGlmdGVkQnkoOSlcbiAgICAgICAgLmludGVnZXJWYWx1ZShiaWdudW1iZXJfanNfMS5kZWZhdWx0LlJPVU5EX0RPV04pXG4gICAgICAgIC50b051bWJlcigpO1xufVxuZnVuY3Rpb24gY3JlYXRlVHJ1c3RsaW5lVHJhbnNhY3Rpb24oYWNjb3VudCwgdHJ1c3RsaW5lKSB7XG4gICAgY29uc3QgbGltaXQgPSB7XG4gICAgICAgIGN1cnJlbmN5OiB0cnVzdGxpbmUuY3VycmVuY3ksXG4gICAgICAgIGlzc3VlcjogdHJ1c3RsaW5lLmNvdW50ZXJwYXJ0eSxcbiAgICAgICAgdmFsdWU6IHRydXN0bGluZS5saW1pdFxuICAgIH07XG4gICAgY29uc3QgdHhKU09OID0ge1xuICAgICAgICBUcmFuc2FjdGlvblR5cGU6ICdUcnVzdFNldCcsXG4gICAgICAgIEFjY291bnQ6IGFjY291bnQsXG4gICAgICAgIExpbWl0QW1vdW50OiBsaW1pdCxcbiAgICAgICAgRmxhZ3M6IDBcbiAgICB9O1xuICAgIGlmICh0cnVzdGxpbmUucXVhbGl0eUluICE9IG51bGwpIHtcbiAgICAgICAgdHhKU09OLlF1YWxpdHlJbiA9IGNvbnZlcnRRdWFsaXR5KHRydXN0bGluZS5xdWFsaXR5SW4pO1xuICAgIH1cbiAgICBpZiAodHJ1c3RsaW5lLnF1YWxpdHlPdXQgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uUXVhbGl0eU91dCA9IGNvbnZlcnRRdWFsaXR5KHRydXN0bGluZS5xdWFsaXR5T3V0KTtcbiAgICB9XG4gICAgaWYgKHRydXN0bGluZS5hdXRob3JpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHR4SlNPTi5GbGFncyB8PSB0cnVzdGxpbmVGbGFncy5TZXRBdXRoO1xuICAgIH1cbiAgICBpZiAodHJ1c3RsaW5lLnJpcHBsaW5nRGlzYWJsZWQgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uRmxhZ3MgfD0gdHJ1c3RsaW5lLnJpcHBsaW5nRGlzYWJsZWRcbiAgICAgICAgICAgID8gdHJ1c3RsaW5lRmxhZ3MuTm9SaXBwbGVcbiAgICAgICAgICAgIDogdHJ1c3RsaW5lRmxhZ3MuQ2xlYXJOb1JpcHBsZTtcbiAgICB9XG4gICAgaWYgKHRydXN0bGluZS5mcm96ZW4gIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uRmxhZ3MgfD0gdHJ1c3RsaW5lLmZyb3plblxuICAgICAgICAgICAgPyB0cnVzdGxpbmVGbGFncy5TZXRGcmVlemVcbiAgICAgICAgICAgIDogdHJ1c3RsaW5lRmxhZ3MuQ2xlYXJGcmVlemU7XG4gICAgfVxuICAgIGlmICh0cnVzdGxpbmUubWVtb3MgIT0gbnVsbCkge1xuICAgICAgICB0eEpTT04uTWVtb3MgPSB0cnVzdGxpbmUubWVtb3MubWFwKHV0aWxzLmNvbnZlcnRNZW1vKTtcbiAgICB9XG4gICAgcmV0dXJuIHR4SlNPTjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVUcnVzdGxpbmUoYWRkcmVzcywgdHJ1c3RsaW5lLCBpbnN0cnVjdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhbGlkYXRlLnByZXBhcmVUcnVzdGxpbmUoeyBhZGRyZXNzLCB0cnVzdGxpbmUsIGluc3RydWN0aW9ucyB9KTtcbiAgICAgICAgY29uc3QgdHhKU09OID0gY3JlYXRlVHJ1c3RsaW5lVHJhbnNhY3Rpb24oYWRkcmVzcywgdHJ1c3RsaW5lKTtcbiAgICAgICAgcmV0dXJuIHV0aWxzLnByZXBhcmVUcmFuc2FjdGlvbih0eEpTT04sIHRoaXMsIGluc3RydWN0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBwcmVwYXJlVHJ1c3RsaW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJ1c3RsaW5lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldENsYXNzaWNBY2NvdW50QW5kVGFnID0gZXhwb3J0cy5zZXRDYW5vbmljYWxGbGFnID0gZXhwb3J0cy5jb21tb24gPSBleHBvcnRzLnByZXBhcmVUcmFuc2FjdGlvbiA9IGV4cG9ydHMuY29udmVydE1lbW8gPSBleHBvcnRzLmNvbnZlcnRTdHJpbmdUb0hleCA9IHZvaWQgMDtcbmNvbnN0IGJpZ251bWJlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiaWdudW1iZXIuanNcIikpO1xuY29uc3QgY29tbW9uID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9jb21tb25cIikpO1xuZXhwb3J0cy5jb21tb24gPSBjb21tb247XG5jb25zdCBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZXJyb3JzXCIpO1xuY29uc3QgcmlwcGxlX2FkZHJlc3NfY29kZWNfMSA9IHJlcXVpcmUoXCJyaXBwbGUtYWRkcmVzcy1jb2RlY1wiKTtcbmNvbnN0IHR4RmxhZ3MgPSBjb21tb24udHhGbGFncztcbmNvbnN0IFRSQU5TQUNUSU9OX1RZUEVTX1dJVEhfREVTVElOQVRJT05fVEFHX0ZJRUxEID0gW1xuICAgICdQYXltZW50JyxcbiAgICAnQ2hlY2tDcmVhdGUnLFxuICAgICdFc2Nyb3dDcmVhdGUnLFxuICAgICdQYXltZW50Q2hhbm5lbENyZWF0ZSdcbl07XG5mdW5jdGlvbiBmb3JtYXRQcmVwYXJlUmVzcG9uc2UodHhKU09OKSB7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0ge1xuICAgICAgICBmZWU6IGNvbW1vbi5kcm9wc1RvWHJwKHR4SlNPTi5GZWUpLFxuICAgICAgICBtYXhMZWRnZXJWZXJzaW9uOiB0eEpTT04uTGFzdExlZGdlclNlcXVlbmNlID09IG51bGwgPyBudWxsIDogdHhKU09OLkxhc3RMZWRnZXJTZXF1ZW5jZVxuICAgIH07XG4gICAgaWYgKHR4SlNPTi5UaWNrZXRTZXF1ZW5jZSAhPSBudWxsKSB7XG4gICAgICAgIGluc3RydWN0aW9uc1sndGlja2V0U2VxdWVuY2UnXSA9IHR4SlNPTi5UaWNrZXRTZXF1ZW5jZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluc3RydWN0aW9uc1snc2VxdWVuY2UnXSA9IHR4SlNPTi5TZXF1ZW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHhKU09OOiBKU09OLnN0cmluZ2lmeSh0eEpTT04pLFxuICAgICAgICBpbnN0cnVjdGlvbnNcbiAgICB9O1xufVxuZnVuY3Rpb24gc2V0Q2Fub25pY2FsRmxhZyh0eEpTT04pIHtcbiAgICB0eEpTT04uRmxhZ3MgfD0gdHhGbGFncy5Vbml2ZXJzYWwuRnVsbHlDYW5vbmljYWxTaWc7XG4gICAgdHhKU09OLkZsYWdzID0gdHhKU09OLkZsYWdzID4+PiAwO1xufVxuZXhwb3J0cy5zZXRDYW5vbmljYWxGbGFnID0gc2V0Q2Fub25pY2FsRmxhZztcbmZ1bmN0aW9uIHNjYWxlVmFsdWUodmFsdWUsIG11bHRpcGxpZXIsIGV4dHJhID0gMCkge1xuICAgIHJldHVybiBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdCh2YWx1ZSkudGltZXMobXVsdGlwbGllcikucGx1cyhleHRyYSkudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGdldENsYXNzaWNBY2NvdW50QW5kVGFnKEFjY291bnQsIGV4cGVjdGVkVGFnKSB7XG4gICAgaWYgKHJpcHBsZV9hZGRyZXNzX2NvZGVjXzEuaXNWYWxpZFhBZGRyZXNzKEFjY291bnQpKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzaWMgPSByaXBwbGVfYWRkcmVzc19jb2RlY18xLnhBZGRyZXNzVG9DbGFzc2ljQWRkcmVzcyhBY2NvdW50KTtcbiAgICAgICAgaWYgKGV4cGVjdGVkVGFnICE9IG51bGwgJiYgY2xhc3NpYy50YWcgIT09IGV4cGVjdGVkVGFnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVmFsaWRhdGlvbkVycm9yKCdhZGRyZXNzIGluY2x1ZGVzIGEgdGFnIHRoYXQgZG9lcyBub3QgbWF0Y2ggdGhlIHRhZyBzcGVjaWZpZWQgaW4gdGhlIHRyYW5zYWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsYXNzaWNBY2NvdW50OiBjbGFzc2ljLmNsYXNzaWNBZGRyZXNzLFxuICAgICAgICAgICAgdGFnOiBjbGFzc2ljLnRhZ1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNsYXNzaWNBY2NvdW50OiBBY2NvdW50LFxuICAgICAgICAgICAgdGFnOiBleHBlY3RlZFRhZ1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Q2xhc3NpY0FjY291bnRBbmRUYWcgPSBnZXRDbGFzc2ljQWNjb3VudEFuZFRhZztcbmZ1bmN0aW9uIHByZXBhcmVUcmFuc2FjdGlvbih0eEpTT04sIGFwaSwgaW5zdHJ1Y3Rpb25zKSB7XG4gICAgY29tbW9uLnZhbGlkYXRlLmluc3RydWN0aW9ucyhpbnN0cnVjdGlvbnMpO1xuICAgIGNvbW1vbi52YWxpZGF0ZS50eF9qc29uKHR4SlNPTik7XG4gICAgaWYgKGluc3RydWN0aW9ucy5zZXF1ZW5jZSAhPSBudWxsICYmIGluc3RydWN0aW9ucy5zZXF1ZW5jZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGVycm9yc18xLlZhbGlkYXRpb25FcnJvcignYHNlcXVlbmNlYCBjYW5ub3QgYmUgMCcpKTtcbiAgICB9XG4gICAgY29uc3QgZGlzYWxsb3dlZEZpZWxkc0luVHhKU09OID0gW1xuICAgICAgICAnbWF4TGVkZ2VyVmVyc2lvbicsXG4gICAgICAgICdtYXhMZWRnZXJWZXJzaW9uT2Zmc2V0JyxcbiAgICAgICAgJ2ZlZScsXG4gICAgICAgICdzZXF1ZW5jZScsXG4gICAgICAgICd0aWNrZXRTZXF1ZW5jZSdcbiAgICBdO1xuICAgIGNvbnN0IGJhZEZpZWxkcyA9IGRpc2FsbG93ZWRGaWVsZHNJblR4SlNPTi5maWx0ZXIoKGZpZWxkKSA9PiB0eEpTT05bZmllbGRdKTtcbiAgICBpZiAoYmFkRmllbGRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGVycm9yc18xLlZhbGlkYXRpb25FcnJvcigndHhKU09OIGFkZGl0aW9uYWxQcm9wZXJ0eSBcIicgK1xuICAgICAgICAgICAgYmFkRmllbGRzWzBdICtcbiAgICAgICAgICAgICdcIiBleGlzdHMgaW4gaW5zdGFuY2Ugd2hlbiBub3QgYWxsb3dlZCcpKTtcbiAgICB9XG4gICAgY29uc3QgbmV3VHhKU09OID0gT2JqZWN0LmFzc2lnbih7fSwgdHhKU09OKTtcbiAgICBpZiAodHhKU09OWydTaWduZXJRdW9ydW0nXSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgbmV3VHhKU09OLlNpZ25lckVudHJpZXM7XG4gICAgfVxuICAgIGNvbnN0IHsgY2xhc3NpY0FjY291bnQsIHRhZzogc291cmNlVGFnIH0gPSBnZXRDbGFzc2ljQWNjb3VudEFuZFRhZyh0eEpTT04uQWNjb3VudCk7XG4gICAgbmV3VHhKU09OLkFjY291bnQgPSBjbGFzc2ljQWNjb3VudDtcbiAgICBpZiAoc291cmNlVGFnICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHR4SlNPTi5Tb3VyY2VUYWcgJiYgdHhKU09OLlNvdXJjZVRhZyAhPT0gc291cmNlVGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGVycm9yc18xLlZhbGlkYXRpb25FcnJvcignVGhlIGBTb3VyY2VUYWdgLCBpZiBwcmVzZW50LCBtdXN0IG1hdGNoIHRoZSB0YWcgb2YgdGhlIGBBY2NvdW50YCBYLWFkZHJlc3MnKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVRhZykge1xuICAgICAgICAgICAgbmV3VHhKU09OLlNvdXJjZVRhZyA9IHNvdXJjZVRhZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHR4SlNPTi5EZXN0aW5hdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgeyBjbGFzc2ljQWNjb3VudDogZGVzdGluYXRpb25BY2NvdW50LCB0YWc6IGRlc3RpbmF0aW9uVGFnIH0gPSBnZXRDbGFzc2ljQWNjb3VudEFuZFRhZyh0eEpTT04uRGVzdGluYXRpb24pO1xuICAgICAgICBuZXdUeEpTT04uRGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbkFjY291bnQ7XG4gICAgICAgIGlmIChkZXN0aW5hdGlvblRhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoVFJBTlNBQ1RJT05fVFlQRVNfV0lUSF9ERVNUSU5BVElPTl9UQUdfRklFTEQuaW5jbHVkZXModHhKU09OLlRyYW5zYWN0aW9uVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHhKU09OLkRlc3RpbmF0aW9uVGFnICYmIHR4SlNPTi5EZXN0aW5hdGlvblRhZyAhPT0gZGVzdGluYXRpb25UYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoJ1RoZSBQYXltZW50IGBEZXN0aW5hdGlvblRhZ2AsIGlmIHByZXNlbnQsIG11c3QgbWF0Y2ggdGhlIHRhZyBvZiB0aGUgYERlc3RpbmF0aW9uYCBYLWFkZHJlc3MnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvblRhZykge1xuICAgICAgICAgICAgICAgICAgICBuZXdUeEpTT04uRGVzdGluYXRpb25UYWcgPSBkZXN0aW5hdGlvblRhZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFRvQ2xhc3NpY0FjY291bnRJZlByZXNlbnQoZmllbGROYW1lKSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSB0eEpTT05bZmllbGROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBhY2NvdW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgeyBjbGFzc2ljQWNjb3VudDogY2EgfSA9IGdldENsYXNzaWNBY2NvdW50QW5kVGFnKGFjY291bnQpO1xuICAgICAgICAgICAgbmV3VHhKU09OW2ZpZWxkTmFtZV0gPSBjYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0SXNzdWVkQ3VycmVuY3lUb0FjY291bnRJZlByZXNlbnQoZmllbGROYW1lKSB7XG4gICAgICAgIGNvbnN0IGFtb3VudCA9IHR4SlNPTltmaWVsZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGFtb3VudCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgIHx8IGFtb3VudCBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICB8fCBhbW91bnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbmV3VHhKU09OW2ZpZWxkTmFtZV0gPSBjb21tb25fMS50b1JpcHBsZWRBbW91bnQoYW1vdW50KTtcbiAgICB9XG4gICAgY29udmVydFRvQ2xhc3NpY0FjY291bnRJZlByZXNlbnQoJ0F1dGhvcml6ZScpO1xuICAgIGNvbnZlcnRUb0NsYXNzaWNBY2NvdW50SWZQcmVzZW50KCdVbmF1dGhvcml6ZScpO1xuICAgIGNvbnZlcnRUb0NsYXNzaWNBY2NvdW50SWZQcmVzZW50KCdPd25lcicpO1xuICAgIGNvbnZlcnRUb0NsYXNzaWNBY2NvdW50SWZQcmVzZW50KCdSZWd1bGFyS2V5Jyk7XG4gICAgY29udmVydElzc3VlZEN1cnJlbmN5VG9BY2NvdW50SWZQcmVzZW50KCdBbW91bnQnKTtcbiAgICBjb252ZXJ0SXNzdWVkQ3VycmVuY3lUb0FjY291bnRJZlByZXNlbnQoJ1NlbmRNYXgnKTtcbiAgICBjb252ZXJ0SXNzdWVkQ3VycmVuY3lUb0FjY291bnRJZlByZXNlbnQoJ0RlbGl2ZXJNaW4nKTtcbiAgICBjb252ZXJ0SXNzdWVkQ3VycmVuY3lUb0FjY291bnRJZlByZXNlbnQoJ1Rha2VyUGF5cycpO1xuICAgIGNvbnZlcnRJc3N1ZWRDdXJyZW5jeVRvQWNjb3VudElmUHJlc2VudCgnVGFrZXJHZXRzJyk7XG4gICAgY29udmVydElzc3VlZEN1cnJlbmN5VG9BY2NvdW50SWZQcmVzZW50KCdMaW1pdEFtb3VudCcpO1xuICAgIHNldENhbm9uaWNhbEZsYWcobmV3VHhKU09OKTtcbiAgICBmdW5jdGlvbiBwcmVwYXJlTWF4TGVkZ2VyVmVyc2lvbigpIHtcbiAgICAgICAgaWYgKG5ld1R4SlNPTi5MYXN0TGVkZ2VyU2VxdWVuY2UgJiYgaW5zdHJ1Y3Rpb25zLm1heExlZGdlclZlcnNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3JzXzEuVmFsaWRhdGlvbkVycm9yKCdgTGFzdExlZGdlclNlcXVlbmNlYCBpbiB0eEpTT04gYW5kIGBtYXhMZWRnZXJWZXJzaW9uYCcgK1xuICAgICAgICAgICAgICAgICcgaW4gYGluc3RydWN0aW9uc2AgY2Fubm90IGJvdGggYmUgc2V0JykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeEpTT04uTGFzdExlZGdlclNlcXVlbmNlICYmIGluc3RydWN0aW9ucy5tYXhMZWRnZXJWZXJzaW9uT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGVycm9yc18xLlZhbGlkYXRpb25FcnJvcignYExhc3RMZWRnZXJTZXF1ZW5jZWAgaW4gdHhKU09OIGFuZCBgbWF4TGVkZ2VyVmVyc2lvbk9mZnNldGAnICtcbiAgICAgICAgICAgICAgICAnIGluIGBpbnN0cnVjdGlvbnNgIGNhbm5vdCBib3RoIGJlIHNldCcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VHhKU09OLkxhc3RMZWRnZXJTZXF1ZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0cnVjdGlvbnMubWF4TGVkZ2VyVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zLm1heExlZGdlclZlcnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdUeEpTT04uTGFzdExlZGdlclNlcXVlbmNlID0gaW5zdHJ1Y3Rpb25zLm1heExlZGdlclZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5zdHJ1Y3Rpb25zLm1heExlZGdlclZlcnNpb25PZmZzZXQgIT0gbnVsbFxuICAgICAgICAgICAgPyBpbnN0cnVjdGlvbnMubWF4TGVkZ2VyVmVyc2lvbk9mZnNldFxuICAgICAgICAgICAgOiAzO1xuICAgICAgICByZXR1cm4gYXBpLmNvbm5lY3Rpb24uZ2V0TGVkZ2VyVmVyc2lvbigpLnRoZW4oKGxlZGdlclZlcnNpb24pID0+IHtcbiAgICAgICAgICAgIG5ld1R4SlNPTi5MYXN0TGVkZ2VyU2VxdWVuY2UgPSBsZWRnZXJWZXJzaW9uICsgb2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJlcGFyZUZlZSgpIHtcbiAgICAgICAgaWYgKG5ld1R4SlNPTi5GZWUgJiYgaW5zdHJ1Y3Rpb25zLmZlZSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBlcnJvcnNfMS5WYWxpZGF0aW9uRXJyb3IoJ2BGZWVgIGluIHR4SlNPTiBhbmQgYGZlZWAgaW4gYGluc3RydWN0aW9uc2AgY2Fubm90IGJvdGggYmUgc2V0JykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUeEpTT04uRmVlKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbXVsdGlwbGllciA9IGluc3RydWN0aW9ucy5zaWduZXJzQ291bnQgPT0gbnVsbFxuICAgICAgICAgICAgPyAxXG4gICAgICAgICAgICA6IGluc3RydWN0aW9ucy5zaWduZXJzQ291bnQgKyAxO1xuICAgICAgICBpZiAoaW5zdHJ1Y3Rpb25zLmZlZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBmZWUgPSBuZXcgYmlnbnVtYmVyX2pzXzEuZGVmYXVsdChpbnN0cnVjdGlvbnMuZmVlKTtcbiAgICAgICAgICAgIGlmIChmZWUuaXNHcmVhdGVyVGhhbihhcGkuX21heEZlZVhSUCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IGVycm9yc18xLlZhbGlkYXRpb25FcnJvcihgRmVlIG9mICR7ZmVlLnRvU3RyaW5nKDEwKX0gWFJQIGV4Y2VlZHMgYCArXG4gICAgICAgICAgICAgICAgICAgIGBtYXggb2YgJHthcGkuX21heEZlZVhSUH0gWFJQLiBUbyB1c2UgdGhpcyBmZWUsIGluY3JlYXNlIGAgK1xuICAgICAgICAgICAgICAgICAgICAnYG1heEZlZVhSUGAgaW4gdGhlIFJpcHBsZUFQSSBjb25zdHJ1Y3Rvci4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeEpTT04uRmVlID0gc2NhbGVWYWx1ZShjb21tb24ueHJwVG9Ecm9wcyhpbnN0cnVjdGlvbnMuZmVlKSwgbXVsdGlwbGllcik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VzaGlvbiA9IGFwaS5fZmVlQ3VzaGlvbjtcbiAgICAgICAgcmV0dXJuIGFwaS5nZXRGZWUoY3VzaGlvbikudGhlbigoZmVlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXBpLmNvbm5lY3Rpb24uZ2V0RmVlUmVmKCkudGhlbigoZmVlUmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmFGZWUgPSBuZXdUeEpTT04uVHJhbnNhY3Rpb25UeXBlICE9PSAnRXNjcm93RmluaXNoJyB8fFxuICAgICAgICAgICAgICAgICAgICBuZXdUeEpTT04uRnVsZmlsbG1lbnQgPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgOiBjdXNoaW9uICpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlZVJlZiAqXG4gICAgICAgICAgICAgICAgICAgICAgICAoMzIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoQnVmZmVyLmZyb20obmV3VHhKU09OLkZ1bGZpbGxtZW50LCAnaGV4JykubGVuZ3RoIC8gMTYpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmZWVEcm9wcyA9IGNvbW1vbi54cnBUb0Ryb3BzKGZlZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4RmVlWFJQID0gaW5zdHJ1Y3Rpb25zLm1heEZlZVxuICAgICAgICAgICAgICAgICAgICA/IGJpZ251bWJlcl9qc18xLmRlZmF1bHQubWluKGFwaS5fbWF4RmVlWFJQLCBpbnN0cnVjdGlvbnMubWF4RmVlKVxuICAgICAgICAgICAgICAgICAgICA6IGFwaS5fbWF4RmVlWFJQO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heEZlZURyb3BzID0gY29tbW9uLnhycFRvRHJvcHMobWF4RmVlWFJQKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxGZWUgPSBzY2FsZVZhbHVlKGZlZURyb3BzLCBtdWx0aXBsaWVyLCBleHRyYUZlZSk7XG4gICAgICAgICAgICAgICAgbmV3VHhKU09OLkZlZSA9IGJpZ251bWJlcl9qc18xLmRlZmF1bHQubWluKG5vcm1hbEZlZSwgbWF4RmVlRHJvcHMpLnRvU3RyaW5nKDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHByZXBhcmVTZXF1ZW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbnMuc2VxdWVuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdUeEpTT04uU2VxdWVuY2UgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbnMuc2VxdWVuY2UgPT09IG5ld1R4SlNPTi5TZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdUeEpTT04uU2VxdWVuY2UgPSBpbnN0cnVjdGlvbnMuc2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgZXJyb3JzXzEuVmFsaWRhdGlvbkVycm9yKCdgU2VxdWVuY2VgIGluIHR4SlNPTiBtdXN0IG1hdGNoIGBzZXF1ZW5jZWAgaW4gYGluc3RydWN0aW9uc2AnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1R4SlNPTi5TZXF1ZW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluc3RydWN0aW9ucy50aWNrZXRTZXF1ZW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmV3VHhKU09OLlNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgICAgICBuZXdUeEpTT04uVGlja2V0U2VxdWVuY2UgPSBpbnN0cnVjdGlvbnMudGlja2V0U2VxdWVuY2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGFwaS5yZXF1ZXN0KCdhY2NvdW50X2luZm8nLCB7XG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQ6IGNsYXNzaWNBY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICBsZWRnZXJfaW5kZXg6ICdjdXJyZW50J1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5ld1R4SlNPTi5TZXF1ZW5jZSA9IHJlc3BvbnNlLmFjY291bnRfZGF0YS5TZXF1ZW5jZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgIHByZXBhcmVNYXhMZWRnZXJWZXJzaW9uKCksXG4gICAgICAgIHByZXBhcmVGZWUoKSxcbiAgICAgICAgcHJlcGFyZVNlcXVlbmNlKClcbiAgICBdKS50aGVuKCgpID0+IGZvcm1hdFByZXBhcmVSZXNwb25zZShuZXdUeEpTT04pKTtcbn1cbmV4cG9ydHMucHJlcGFyZVRyYW5zYWN0aW9uID0gcHJlcGFyZVRyYW5zYWN0aW9uO1xuZnVuY3Rpb24gY29udmVydFN0cmluZ1RvSGV4KHN0cmluZykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHJpbmcsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpLnRvVXBwZXJDYXNlKCk7XG59XG5leHBvcnRzLmNvbnZlcnRTdHJpbmdUb0hleCA9IGNvbnZlcnRTdHJpbmdUb0hleDtcbmZ1bmN0aW9uIGNvbnZlcnRNZW1vKG1lbW8pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBNZW1vOiBjb21tb24ucmVtb3ZlVW5kZWZpbmVkKHtcbiAgICAgICAgICAgIE1lbW9EYXRhOiBtZW1vLmRhdGEgPyBjb252ZXJ0U3RyaW5nVG9IZXgobWVtby5kYXRhKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIE1lbW9UeXBlOiBtZW1vLnR5cGUgPyBjb252ZXJ0U3RyaW5nVG9IZXgobWVtby50eXBlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIE1lbW9Gb3JtYXQ6IG1lbW8uZm9ybWF0ID8gY29udmVydFN0cmluZ1RvSGV4KG1lbW8uZm9ybWF0KSA6IHVuZGVmaW5lZFxuICAgICAgICB9KVxuICAgIH07XG59XG5leHBvcnRzLmNvbnZlcnRNZW1vID0gY29udmVydE1lbW87XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRGYXVjZXRVcmwgPSBleHBvcnRzLkZhdWNldE5ldHdvcmsgPSB2b2lkIDA7XG5jb25zdCBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbmNvbnN0IGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbmNvbnN0IHNjaGVtYV92YWxpZGF0b3JfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc2NoZW1hLXZhbGlkYXRvclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9lcnJvcnNcIik7XG52YXIgRmF1Y2V0TmV0d29yaztcbihmdW5jdGlvbiAoRmF1Y2V0TmV0d29yaykge1xuICAgIEZhdWNldE5ldHdvcmtbXCJUZXN0bmV0XCJdID0gXCJmYXVjZXQuYWx0bmV0LnJpcHBsZXRlc3QubmV0XCI7XG4gICAgRmF1Y2V0TmV0d29ya1tcIkRldm5ldFwiXSA9IFwiZmF1Y2V0LmRldm5ldC5yaXBwbGV0ZXN0Lm5ldFwiO1xufSkoRmF1Y2V0TmV0d29yayA9IGV4cG9ydHMuRmF1Y2V0TmV0d29yayB8fCAoZXhwb3J0cy5GYXVjZXROZXR3b3JrID0ge30pKTtcbmNvbnN0IElOVEVSVkFMX1NFQ09ORFMgPSAxO1xuY29uc3QgTUFYX0FUVEVNUFRTID0gMjA7XG5mdW5jdGlvbiBnZW5lcmF0ZUZhdWNldFdhbGxldChhZGRyZXNzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUmlwcGxlZEVycm9yKFwiUmlwcGxlQVBJIG5vdCBjb25uZWN0ZWQsIGNhbm5vdCBjYWxsIGZhdWNldFwiKTtcbiAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgIGxldCBzdGFydGluZ0JhbGFuY2UgPSAwO1xuICAgICAgICBsZXQgZmF1Y2V0VXJsID0gZ2V0RmF1Y2V0VXJsKHRoaXMpO1xuICAgICAgICBpZiAoYWRkcmVzcyAmJiBzY2hlbWFfdmFsaWRhdG9yXzEuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIGJvZHkgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBhZGRyZXNzXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzVG9GdW5kQmFsYW5jZSA9IHlpZWxkIGdldEFkZHJlc3NYcnBCYWxhbmNlKHRoaXMsIGFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3NUb0Z1bmRCYWxhbmNlICYmICFpc05hTigrYWRkcmVzc1RvRnVuZEJhbGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdCYWxhbmNlID0gK2FkZHJlc3NUb0Z1bmRCYWxhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRpbmdCYWxhbmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgaG9zdG5hbWU6IGZhdWNldFVybCxcbiAgICAgICAgICAgIHBvcnQ6IDQ0MyxcbiAgICAgICAgICAgIHBhdGg6ICcvYWNjb3VudHMnLFxuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1MZW5ndGgnOiBib2R5ID8gYm9keS5sZW5ndGggOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gaHR0cHMucmVxdWVzdChvcHRpb25zLCAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5vbignZGF0YScsIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9uKCdlbmQnLCAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBCdWZmZXIuY29uY2F0KGNodW5rcykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddLnN0YXJ0c1dpdGgoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzaWNBZGRyZXNzID0gd2FsbGV0LmFjY291bnQuY2xhc3NpY0FkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NpY0FkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0Z1bmRlZCA9IHlpZWxkIGhhc0FkZHJlc3NCYWxhbmNlSW5jcmVhc2VkKHRoaXMsIGNsYXNzaWNBZGRyZXNzLCBzdGFydGluZ0JhbGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUod2FsbGV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgY29tbW9uXzEuZXJyb3JzLlhSUExGYXVjZXRFcnJvcihgVW5hYmxlIHRvIGZ1bmQgYWRkcmVzcyB3aXRoIGZhdWNldCBhZnRlciB3YWl0aW5nICR7SU5URVJWQUxfU0VDT05EUyAqIE1BWF9BVFRFTVBUU30gc2Vjb25kc2ApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgY29tbW9uXzEuZXJyb3JzLlhSUExGYXVjZXRFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IGNvbW1vbl8xLmVycm9ycy5YUlBMRmF1Y2V0RXJyb3IoYFRoZSBmYXVjZXQgYWNjb3VudCBjbGFzc2ljIGFkZHJlc3MgaXMgdW5kZWZpbmVkYCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiByZXNwb25zZS5oZWFkZXJzWydjb250ZW50LXR5cGUnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC53cml0ZShib2R5ID8gYm9keSA6ICcnKTtcbiAgICAgICAgICAgIHJlcXVlc3Qub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRBZGRyZXNzWHJwQmFsYW5jZShhcGksIGFkZHJlc3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmFsYW5jZXMgPSB5aWVsZCBhcGkuZ2V0QmFsYW5jZXMoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCB4cnBCYWxhbmNlID0gYmFsYW5jZXMuZmlsdGVyKChiYWxhbmNlKSA9PiBiYWxhbmNlLmN1cnJlbmN5LnRvVXBwZXJDYXNlKCkgPT09ICdYUlAnKTtcbiAgICAgICAgICAgIHJldHVybiB4cnBCYWxhbmNlWzBdLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBgVW5hYmxlIHRvIHJldHJpZXZlICR7YWRkcmVzc30gYmFsYW5jZS4gRXJyb3I6ICR7ZXJyfWA7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGhhc0FkZHJlc3NCYWxhbmNlSW5jcmVhc2VkKGFwaSwgYWRkcmVzcywgb3JpZ2luYWxCYWxhbmNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBhdHRlbXB0cyA9IE1BWF9BVFRFTVBUUztcbiAgICAgICAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0cyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdHMtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3QmFsYW5jZSA9ICsoeWllbGQgZ2V0QWRkcmVzc1hycEJhbGFuY2UoYXBpLCBhZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdCYWxhbmNlID4gb3JpZ2luYWxCYWxhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBjb21tb25fMS5lcnJvcnMuWFJQTEZhdWNldEVycm9yKGBVbmFibGUgdG8gY2hlY2sgaWYgdGhlIGFkZHJlc3MgJHthZGRyZXNzfSBiYWxhbmNlIGhhcyBpbmNyZWFzZWQuIEVycm9yOiAke2Vycn1gKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksIElOVEVSVkFMX1NFQ09ORFMgKiAxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRGYXVjZXRVcmwoYXBpKSB7XG4gICAgY29uc3QgY29ubmVjdGlvblVybCA9IGFwaS5jb25uZWN0aW9uLmdldFVybCgpO1xuICAgIGlmIChjb25uZWN0aW9uVXJsLmluY2x1ZGVzKCdhbHRuZXQnKSB8fCBjb25uZWN0aW9uVXJsLmluY2x1ZGVzKCd0ZXN0bmV0JykpIHtcbiAgICAgICAgcmV0dXJuIEZhdWNldE5ldHdvcmsuVGVzdG5ldDtcbiAgICB9XG4gICAgaWYgKGNvbm5lY3Rpb25VcmwuaW5jbHVkZXMoJ2Rldm5ldCcpKSB7XG4gICAgICAgIHJldHVybiBGYXVjZXROZXR3b3JrLkRldm5ldDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZ2V0RmF1Y2V0VXJsID0gZ2V0RmF1Y2V0VXJsO1xuZXhwb3J0cy5kZWZhdWx0ID0gZ2VuZXJhdGVGYXVjZXRXYWxsZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxsZXQtZ2VuZXJhdGlvbi5qcy5tYXAiLCI7KGZ1bmN0aW9uIChnbG9iYWxPYmplY3QpIHtcclxuICAndXNlIHN0cmljdCc7XHJcblxyXG4vKlxyXG4gKiAgICAgIGJpZ251bWJlci5qcyB2OS4xLjFcclxuICogICAgICBBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgYXJiaXRyYXJ5LXByZWNpc2lvbiBhcml0aG1ldGljLlxyXG4gKiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gKiAgICAgIENvcHlyaWdodCAoYykgMjAyMiBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgICAgIE1JVCBMaWNlbnNlZC5cclxuICpcclxuICogICAgICBCaWdOdW1iZXIucHJvdG90eXBlIG1ldGhvZHMgICAgIHwgIEJpZ051bWJlciBtZXRob2RzXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgIGFicyAgICB8ICBjbG9uZVxyXG4gKiAgICAgIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgICAgICAgfCAgY29uZmlnICAgICAgICAgICAgICAgc2V0XHJcbiAqICAgICAgZGVjaW1hbFBsYWNlcyAgICAgICAgICAgIGRwICAgICB8ICAgICAgREVDSU1BTF9QTEFDRVNcclxuICogICAgICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgZGl2ICAgIHwgICAgICBST1VORElOR19NT0RFXHJcbiAqICAgICAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgIGlkaXYgICB8ICAgICAgRVhQT05FTlRJQUxfQVRcclxuICogICAgICBleHBvbmVudGlhdGVkQnkgICAgICAgICAgcG93ICAgIHwgICAgICBSQU5HRVxyXG4gKiAgICAgIGludGVnZXJWYWx1ZSAgICAgICAgICAgICAgICAgICAgfCAgICAgIENSWVBUT1xyXG4gKiAgICAgIGlzRXF1YWxUbyAgICAgICAgICAgICAgICBlcSAgICAgfCAgICAgIE1PRFVMT19NT0RFXHJcbiAqICAgICAgaXNGaW5pdGUgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgUE9XX1BSRUNJU0lPTlxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW4gICAgICAgICAgICBndCAgICAgfCAgICAgIEZPUk1BVFxyXG4gKiAgICAgIGlzR3JlYXRlclRoYW5PckVxdWFsVG8gICBndGUgICAgfCAgICAgIEFMUEhBQkVUXHJcbiAqICAgICAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICAgICAgICB8ICBpc0JpZ051bWJlclxyXG4gKiAgICAgIGlzTGVzc1RoYW4gICAgICAgICAgICAgICBsdCAgICAgfCAgbWF4aW11bSAgICAgICAgICAgICAgbWF4XHJcbiAqICAgICAgaXNMZXNzVGhhbk9yRXF1YWxUbyAgICAgIGx0ZSAgICB8ICBtaW5pbXVtICAgICAgICAgICAgICBtaW5cclxuICogICAgICBpc05hTiAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgIHJhbmRvbVxyXG4gKiAgICAgIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgICAgICAgfCAgc3VtXHJcbiAqICAgICAgaXNQb3NpdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgaXNaZXJvICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbWludXMgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgbW9kdWxvICAgICAgICAgICAgICAgICAgIG1vZCAgICB8XHJcbiAqICAgICAgbXVsdGlwbGllZEJ5ICAgICAgICAgICAgIHRpbWVzICB8XHJcbiAqICAgICAgbmVnYXRlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcGx1cyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgcHJlY2lzaW9uICAgICAgICAgICAgICAgIHNkICAgICB8XHJcbiAqICAgICAgc2hpZnRlZEJ5ICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgIHNxcnQgICB8XHJcbiAqICAgICAgdG9FeHBvbmVudGlhbCAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GaXhlZCAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9Gb3JtYXQgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9GcmFjdGlvbiAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9KU09OICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9OdW1iZXIgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9QcmVjaXNpb24gICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdG9TdHJpbmcgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqICAgICAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAqXHJcbiAqL1xyXG5cclxuXHJcbiAgdmFyIEJpZ051bWJlcixcclxuICAgIGlzTnVtZXJpYyA9IC9eLT8oPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86ZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgbWF0aGNlaWwgPSBNYXRoLmNlaWwsXHJcbiAgICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICAgIGJpZ251bWJlckVycm9yID0gJ1tCaWdOdW1iZXIgRXJyb3JdICcsXHJcbiAgICB0b29NYW55RGlnaXRzID0gYmlnbnVtYmVyRXJyb3IgKyAnTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czogJyxcclxuXHJcbiAgICBCQVNFID0gMWUxNCxcclxuICAgIExPR19CQVNFID0gMTQsXHJcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gMHgxZmZmZmZmZmZmZmZmZiwgICAgICAgICAvLyAyXjUzIC0gMVxyXG4gICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgIFBPV1NfVEVOID0gWzEsIDEwLCAxMDAsIDFlMywgMWU0LCAxZTUsIDFlNiwgMWU3LCAxZTgsIDFlOSwgMWUxMCwgMWUxMSwgMWUxMiwgMWUxM10sXHJcbiAgICBTUVJUX0JBU0UgPSAxZTcsXHJcblxyXG4gICAgLy8gRURJVEFCTEVcclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgREVDSU1BTF9QTEFDRVMsIFRPX0VYUF9ORUcsIFRPX0VYUF9QT1MsIE1JTl9FWFAsIE1BWF9FWFAsIGFuZFxyXG4gICAgLy8gdGhlIGFyZ3VtZW50cyB0byB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCwgYW5kIHRvUHJlY2lzaW9uLlxyXG4gICAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUoY29uZmlnT2JqZWN0KSB7XHJcbiAgICB2YXIgZGl2LCBjb252ZXJ0QmFzZSwgcGFyc2VOdW1lcmljLFxyXG4gICAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgICAgT05FID0gbmV3IEJpZ051bWJlcigxKSxcclxuXHJcblxyXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVESVRBQkxFIENPTkZJRyBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgICAgLy8gVGhlIHZhbHVlcyBjYW4gYWxzbyBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIEJpZ051bWJlci5zZXQuXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIG9wZXJhdGlvbnMgaW52b2x2aW5nIGRpdmlzaW9uLlxyXG4gICAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gdGhlIGFib3ZlIGRlY2ltYWwgcGxhY2VzLCBhbmQgd2hlbiB1c2luZ1xyXG4gICAgICAvLyB0b0V4cG9uZW50aWFsLCB0b0ZpeGVkLCB0b0Zvcm1hdCBhbmQgdG9QcmVjaXNpb24sIGFuZCByb3VuZCAoZGVmYXVsdCB2YWx1ZSkuXHJcbiAgICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIEhBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBIQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBIQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgICAgQ1JZUFRPID0gZmFsc2UsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIG9yIGZhbHNlXHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgIDAgVGhlIHJlbWFpbmRlciBpcyBwb3NpdGl2ZSBpZiB0aGUgZGl2aWRlbmQgaXMgbmVnYXRpdmUsIGVsc2UgaXMgbmVnYXRpdmUuXHJcbiAgICAgIC8vIERPV04gICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgICAvLyAgICAgICAgICAgICBlcXVpdmFsZW50IHRvIChhICUgbikgaW4gSmF2YVNjcmlwdC5cclxuICAgICAgLy8gRkxPT1IgICAgIDMgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aXNvciAoUHl0aG9uICUpLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgICAgLy8gRVVDTElEICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLlxyXG4gICAgICAvLyAgICAgICAgICAgICBUaGUgcmVtYWluZGVyIGlzIGFsd2F5cyBwb3NpdGl2ZS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVGhlIHRydW5jYXRlZCBkaXZpc2lvbiwgZmxvb3JlZCBkaXZpc2lvbiwgRXVjbGlkaWFuIGRpdmlzaW9uIGFuZCBJRUVFIDc1NCByZW1haW5kZXJcclxuICAgICAgLy8gbW9kZXMgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi5cclxuICAgICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgICBNT0RVTE9fTU9ERSA9IDEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOVxyXG5cclxuICAgICAgLy8gVGhlIG1heGltdW0gbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZiB0aGUgcmVzdWx0IG9mIHRoZSBleHBvbmVudGlhdGVkQnkgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgUE9XX1BSRUNJU0lPTiA9IDAsICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgcHJlZml4OiAnJyxcclxuICAgICAgICBncm91cFNpemU6IDMsXHJcbiAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvcjogJy4nLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicsXHJcbiAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHRydWU7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKHYpO1xyXG4gICAgICAgICAgcmV0dXJuIHJvdW5kKHgsIERFQ0lNQUxfUExBQ0VTICsgeC5lICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSBTdHJpbmcodik7XHJcblxyXG4gICAgICAgIGlmIChpc051bSA9IHR5cGVvZiB2ID09ICdudW1iZXInKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgaWYgKHYgKiAwICE9IDApIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSwgYik7XHJcblxyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRyAmJiBzdHIucmVwbGFjZSgvXjBcXC4wKnxcXC4vLCAnJykubGVuZ3RoID4gMTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhbHBoYWJldCA9IEFMUEhBQkVULnNsaWNlKDAsIGIpO1xyXG4gICAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCBzdHIgaXMgYSB2YWxpZCBiYXNlIGIgbnVtYmVyLlxyXG4gICAgICAgIC8vIERvbid0IHVzZSBSZWdFeHAsIHNvIGFscGhhYmV0IGNhbiBjb250YWluIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICAgICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgaWYgKGFscGhhYmV0LmluZGV4T2YoYyA9IHN0ci5jaGFyQXQoaSkpIDwgMCkge1xyXG4gICAgICAgICAgICBpZiAoYyA9PSAnLicpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgICBpZiAoaSA+IGUpIHtcclxuICAgICAgICAgICAgICAgIGUgPSBsZW47XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhc2VDaGFuZ2VkKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgICAgaWYgKHN0ciA9PSBzdHIudG9VcHBlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvTG93ZXJDYXNlKCkpIHx8XHJcbiAgICAgICAgICAgICAgICAgIHN0ciA9PSBzdHIudG9Mb3dlckNhc2UoKSAmJiAoc3RyID0gc3RyLnRvVXBwZXJDYXNlKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpID0gLTE7XHJcbiAgICAgICAgICAgICAgICBlID0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgIGlzTnVtID0gZmFsc2U7XHJcbiAgICAgICAgc3RyID0gY29udmVydEJhc2Uoc3RyLCBiLCAxMCwgeC5zKTtcclxuXHJcbiAgICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICBlbHNlIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgc3RyLmNoYXJDb2RlQXQoaSkgPT09IDQ4OyBpKyspO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7KTtcclxuXHJcbiAgICAgIGlmIChzdHIgPSBzdHIuc2xpY2UoaSwgKytsZW4pKSB7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgaWYgKGlzTnVtICYmIEJpZ051bWJlci5ERUJVRyAmJlxyXG4gICAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICh0b29NYW55RGlnaXRzICsgKHgucyAqIHYpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICBpZiAoKGUgPSBlIC0gaSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgICAvLyBlIGlzIHRoZSBiYXNlIDEwIGV4cG9uZW50LlxyXG4gICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7ICAvLyBpIDwgMVxyXG5cclxuICAgICAgICAgIGlmIChpIDwgbGVuKSB7XHJcbiAgICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgICAgIHguYy5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpID0gTE9HX0JBU0UgLSAoc3RyID0gc3RyLnNsaWNlKGkpKS5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBmb3IgKDsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gQ09OU1RSVUNUT1IgUFJPUEVSVElFU1xyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIuY2xvbmUgPSBjbG9uZTtcclxuXHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0NFSUwgPSAyO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICAgIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ29uZmlndXJlIGluZnJlcXVlbnRseS1jaGFuZ2luZyBsaWJyYXJ5LXdpZGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQWNjZXB0IGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgb3B0aW9uYWwgcHJvcGVydGllcyAoaWYgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaXNcclxuICAgICAqIGEgbnVtYmVyLCBpdCBtdXN0IGJlIGFuIGludGVnZXIgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2Ugc3RhdGVkKTpcclxuICAgICAqXHJcbiAgICAgKiAgIERFQ0lNQUxfUExBQ0VTICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIFJPVU5ESU5HX01PREUgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOFxyXG4gICAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAgICogICBSQU5HRSAgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAobm90IHplcm8pICBvciAgWy1NQVggdG8gLTEsIDEgdG8gTUFYXVxyXG4gICAgICogICBDUllQVE8gICAgICAgICAgIHtib29sZWFufSAgICAgICAgICB0cnVlIG9yIGZhbHNlXHJcbiAgICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAgICogICBQT1dfUFJFQ0lTSU9OICAgICAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAgICogICBBTFBIQUJFVCAgICAgICAgIHtzdHJpbmd9ICAgICAgICAgICBBIHN0cmluZyBvZiB0d28gb3IgbW9yZSB1bmlxdWUgY2hhcmFjdGVycyB3aGljaCBkb2VzXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgICAqICAgRk9STUFUICAgICAgICAgICB7b2JqZWN0fSAgICAgICAgICAgQW4gb2JqZWN0IHdpdGggc29tZSBvZiB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XHJcbiAgICAgKiAgICAgcHJlZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgICAqICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZ3JvdXBTZXBhcmF0b3IgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgKiAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB7c3RyaW5nfVxyXG4gICAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgICAqXHJcbiAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICpcclxuICAgICAqIEUuZy5cclxuICAgICAqIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUyA6IDIwLCBST1VORElOR19NT0RFIDogNCB9KVxyXG4gICAgICpcclxuICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLCBleGNlcHQgZm9yIEFMUEhBQkVULlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLmNvbmZpZyA9IEJpZ051bWJlci5zZXQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgIHZhciBwLCB2O1xyXG5cclxuICAgICAgaWYgKG9iaiAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09ICdvYmplY3QnKSB7XHJcblxyXG4gICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIERFQ0lNQUxfUExBQ0VTIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdERUNJTUFMX1BMQUNFUycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBST1VORElOR19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUk9VTkRJTkdfTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDgsIHApO1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbHVzaXZlLCAwIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEVYUE9ORU5USUFMX0FUIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ICYmIHYucG9wKSB7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXTtcclxuICAgICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gLTEgaW5jbHVzaXZlLCBpbnRlZ2VyIDEgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUkFOR0Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfGNhbm5vdCBiZSB6ZXJvfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgICAgaW50Q2hlY2sodlsxXSwgMSwgTUFYLCBwKTtcclxuICAgICAgICAgICAgICBNSU5fRVhQID0gdlswXTtcclxuICAgICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2LCAtTUFYLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgICBNSU5fRVhQID0gLShNQVhfRVhQID0gdiA8IDAgPyAtdiA6IHYpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGNhbm5vdCBiZSB6ZXJvOiAnICsgdik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufSB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdDUllQVE8nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiA9PT0gISF2KSB7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgIENSWVBUTyA9ICF2O1xyXG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgdHJ1ZSBvciBmYWxzZTogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTU9EVUxPX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA5IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBNT0RVTE9fTU9ERSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCA5LCBwKTtcclxuICAgICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1BPV19QUkVDSVNJT04nKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICBQT1dfUFJFQ0lTSU9OID0gdjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBGT1JNQVQgbm90IGFuIG9iamVjdDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0ZPUk1BVCcpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnb2JqZWN0JykgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEFMUEhBQkVUIHtzdHJpbmd9XHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0FMUEhBQkVUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuXHJcbiAgICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgICAgLy8gb3IgaWYgaXQgY29udGFpbnMgJysnLCAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgYSByZXBlYXRlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdiA9PSAnc3RyaW5nJyAmJiAhL14uPyR8WytcXC0uXFxzXXwoLikuKlxcMS8udGVzdCh2KSkge1xyXG4gICAgICAgICAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHYuc2xpY2UoMCwgMTApID09ICcwMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgICBBTFBIQUJFVCA9IHY7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgaW52YWxpZDogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE9iamVjdCBleHBlY3RlZDoge3Z9J1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnT2JqZWN0IGV4cGVjdGVkOiAnICsgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgREVDSU1BTF9QTEFDRVM6IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgICAgRVhQT05FTlRJQUxfQVQ6IFtUT19FWFBfTkVHLCBUT19FWFBfUE9TXSxcclxuICAgICAgICBSQU5HRTogW01JTl9FWFAsIE1BWF9FWFBdLFxyXG4gICAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICAgIE1PRFVMT19NT0RFOiBNT0RVTE9fTU9ERSxcclxuICAgICAgICBQT1dfUFJFQ0lTSU9OOiBQT1dfUFJFQ0lTSU9OLFxyXG4gICAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICAgIEFMUEhBQkVUOiBBTFBIQUJFVFxyXG4gICAgICB9O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHYgaXMgYSBCaWdOdW1iZXIgaW5zdGFuY2UsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKlxyXG4gICAgICogSWYgQmlnTnVtYmVyLkRFQlVHIGlzIHRydWUsIHRocm93IGlmIGEgQmlnTnVtYmVyIGluc3RhbmNlIGlzIG5vdCB3ZWxsLWZvcm1lZC5cclxuICAgICAqXHJcbiAgICAgKiB2IHthbnl9XHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEludmFsaWQgQmlnTnVtYmVyOiB7dn0nXHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgIGlmICghdiB8fCB2Ll9pc0JpZ051bWJlciAhPT0gdHJ1ZSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICB2YXIgaSwgbixcclxuICAgICAgICBjID0gdi5jLFxyXG4gICAgICAgIGUgPSB2LmUsXHJcbiAgICAgICAgcyA9IHYucztcclxuXHJcbiAgICAgIG91dDogaWYgKHt9LnRvU3RyaW5nLmNhbGwoYykgPT0gJ1tvYmplY3QgQXJyYXldJykge1xyXG5cclxuICAgICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgZmlyc3QgZWxlbWVudCBpcyB6ZXJvLCB0aGUgQmlnTnVtYmVyIHZhbHVlIG11c3QgYmUgemVyby5cclxuICAgICAgICAgIGlmIChjWzBdID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChpIDwgMSkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgLy9pZiAoTWF0aC5jZWlsKE1hdGgubG9nKGNbMF0gKyAxKSAvIE1hdGguTE4xMCkgPT0gaSkge1xyXG4gICAgICAgICAgaWYgKFN0cmluZyhjWzBdKS5sZW5ndGggPT0gaSkge1xyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICBuID0gY1tpXTtcclxuICAgICAgICAgICAgICBpZiAobiA8IDAgfHwgbiA+PSBCQVNFIHx8IG4gIT09IG1hdGhmbG9vcihuKSkgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBMYXN0IGVsZW1lbnQgY2Fubm90IGJlIHplcm8sIHVubGVzcyBpdCBpcyB0aGUgb25seSBlbGVtZW50LlxyXG4gICAgICAgICAgICBpZiAobiAhPT0gMCkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkvTmFOXHJcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0ludmFsaWQgQmlnTnVtYmVyOiAnICsgdik7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5tYXhpbXVtID0gQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5sdCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5taW5pbXVtID0gQmlnTnVtYmVyLm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgUC5ndCk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICogemVyb3MgYXJlIHByb2R1Y2VkKS5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hdGhmbG9vcihNYXRoLnJhbmRvbSgpICogcG93Ml81Myk7IH1cclxuICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gKChNYXRoLnJhbmRvbSgpICogMHg0MDAwMDAwMCB8IDApICogMHg4MDAwMDApICtcclxuICAgICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkcCkge1xyXG4gICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgICBjID0gW10sXHJcbiAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgICBlbHNlIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG5cclxuICAgICAgICBrID0gbWF0aGNlaWwoZHAgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG5cclxuICAgICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDBcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAgIC8vIDB4MjAwMDAgaXMgMl4yMS5cclxuICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgYiA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDIpKTtcclxuICAgICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgICAgYVtpICsgMV0gPSBiWzFdO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyeXB0by5yYW5kb21CeXRlcykge1xyXG5cclxuICAgICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA3KTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwIGlzIDJeMzIsIDB4MTAwMDAwMCBpcyAyXjI0XHJcbiAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgdiA9ICgoYVtpXSAmIDMxKSAqIDB4MTAwMDAwMDAwMDAwMCkgKyAoYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDJdICogMHgxMDAwMDAwMDApICsgKGFbaSArIDNdICogMHgxMDAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgICBpZiAodiA+PSA5ZTE1KSB7XHJcbiAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weShhLCBpKTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgYy5wdXNoKHYgJSAxZTE0KTtcclxuICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgQ1JZUFRPID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVc2UgTWF0aC5yYW5kb20uXHJcbiAgICAgICAgaWYgKCFDUllQVE8pIHtcclxuXHJcbiAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICAgIHYgPSByYW5kb201M2JpdEludCgpO1xyXG4gICAgICAgICAgICBpZiAodiA8IDllMTUpIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgayA9IGNbLS1pXTtcclxuICAgICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgIGlmIChrICYmIGRwKSB7XHJcbiAgICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKGsgLyB2KSAqIHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgZm9yICg7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICBjID0gW2UgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBmb3IgKGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc3BsaWNlKDAsIDEpLCBlIC09IExPR19CQVNFKTtcclxuXHJcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIGMgdG8gZGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MsIGFuZC4uLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgICAgIGlmIChpIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICByYW5kLmMgPSBjO1xyXG4gICAgICAgIHJldHVybiByYW5kO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKlxyXG4gICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDspIHN1bSA9IHN1bS5wbHVzKGFyZ3NbaSsrXSk7XHJcbiAgICAgIHJldHVybiBzdW07XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvLyBQUklWQVRFIEZVTkNUSU9OU1xyXG5cclxuXHJcbiAgICAvLyBDYWxsZWQgYnkgQmlnTnVtYmVyIGFuZCBCaWdOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nLlxyXG4gICAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgZGVjaW1hbCA9ICcwMTIzNDU2Nzg5JztcclxuXHJcbiAgICAgIC8qXHJcbiAgICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAgICogRWcuIHRvQmFzZU91dCgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICAgKi9cclxuICAgICAgZnVuY3Rpb24gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBhbHBoYWJldCkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgICAgYXJyTCxcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yICg7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICBmb3IgKGFyckwgPSBhcnIubGVuZ3RoOyBhcnJMLS07IGFyclthcnJMXSAqPSBiYXNlSW4pO1xyXG5cclxuICAgICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFycltqXSA+IGJhc2VPdXQgLSAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgICAgICBhcnJbal0gJT0gYmFzZU91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyBCaWdOdW1iZXIsIHdlIGFyZSBjb252ZXJ0aW5nIGZyb20gYmFzZUluIHRvIGJhc2UgMTAuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIHNpZ24sIGNhbGxlcklzVG9TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCcuJyksXHJcbiAgICAgICAgICBkcCA9IERFQ0lNQUxfUExBQ0VTLFxyXG4gICAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGJhc2VJbik7XHJcbiAgICAgICAgICB4ID0geS5wb3coc3RyLmxlbmd0aCAtIGkpO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgICAgLy8gQ29udmVydCBzdHIgYXMgaWYgYW4gaW50ZWdlciwgdGhlbiByZXN0b3JlIHRoZSBmcmFjdGlvbiBwYXJ0IGJ5IGRpdmlkaW5nIHRoZVxyXG4gICAgICAgICAgLy8gcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyLlxyXG5cclxuICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgICAgMTAsIGJhc2VPdXQsIGRlY2ltYWwpO1xyXG4gICAgICAgICAgeS5lID0geS5jLmxlbmd0aDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIG51bWJlciBhcyBpbnRlZ2VyLlxyXG5cclxuICAgICAgICB4YyA9IHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgY2FsbGVySXNUb1N0cmluZ1xyXG4gICAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgICA6IChhbHBoYWJldCA9IGRlY2ltYWwsIEFMUEhBQkVUKSk7XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBhcyBhbiBpbnRlZ2VyIGFuZCBjb252ZXJ0ZWQgdG8gYmFzZU91dC4gZSBpcyB0aGUgZXhwb25lbnQuXHJcbiAgICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgeGNbLS1rXSA9PSAwOyB4Yy5wb3AoKSk7XHJcblxyXG4gICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSkgcmV0dXJuIGFscGhhYmV0LmNoYXJBdCgwKTtcclxuXHJcbiAgICAgICAgLy8gRG9lcyBzdHIgcmVwcmVzZW50IGFuIGludGVnZXI/IElmIHNvLCBubyBuZWVkIGZvciB0aGUgZGl2aXNpb24uXHJcbiAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAtLWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAvLyBUaGUgc2lnbiBpcyBuZWVkZWQgZm9yIGNvcnJlY3Qgcm91bmRpbmcuXHJcbiAgICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgICAgeCA9IGRpdih4LCB5LCBkcCwgcm0sIGJhc2VPdXQpO1xyXG4gICAgICAgICAgeGMgPSB4LmM7XHJcbiAgICAgICAgICByID0geC5yO1xyXG4gICAgICAgICAgZSA9IHguZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgICAgLy8gVEhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICBkID0gZSArIGRwICsgMTtcclxuXHJcbiAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4Y1tkXTtcclxuXHJcbiAgICAgICAgLy8gTG9vayBhdCB0aGUgcm91bmRpbmcgZGlnaXRzIGFuZCBtb2RlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJvdW5kIHVwLlxyXG5cclxuICAgICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgICAgciA9IHIgfHwgZCA8IDAgfHwgeGNbZCArIDFdICE9IG51bGw7XHJcblxyXG4gICAgICAgIHIgPSBybSA8IDQgPyAoaSAhPSBudWxsIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAvLyBJZiB0aGUgaW5kZXggb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG5vdCBncmVhdGVyIHRoYW4gemVybywgb3IgeGMgcmVwcmVzZW50c1xyXG4gICAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgICAgLy8gc3VjaCBhcyAwLjAwMDAxLlxyXG4gICAgICAgIGlmIChkIDwgMSB8fCAheGNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgICBzdHIgPSByID8gdG9GaXhlZFBvaW50KGFscGhhYmV0LmNoYXJBdCgxKSwgLWRwLCBhbHBoYWJldC5jaGFyQXQoMCkpIDogYWxwaGFiZXQuY2hhckF0KDApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgZm9yICgtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7KSB7XHJcbiAgICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgICBpZiAoIWQpIHtcclxuICAgICAgICAgICAgICAgICsrZTtcclxuICAgICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChrID0geGMubGVuZ3RoOyAheGNbLS1rXTspO1xyXG5cclxuICAgICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8PSBrOyBzdHIgKz0gYWxwaGFiZXQuY2hhckF0KHhjW2krK10pKTtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvcywgZGVjaW1hbCBwb2ludCBhbmQgdHJhaWxpbmcgemVyb3MgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIG0sIHRlbXAsIHhsbywgeGhpLFxyXG4gICAgICAgICAgY2FycnkgPSAwLFxyXG4gICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAga2xvID0gayAlIFNRUlRfQkFTRSxcclxuICAgICAgICAgIGtoaSA9IGsgLyBTUVJUX0JBU0UgfCAwO1xyXG5cclxuICAgICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICAgIHhsbyA9IHhbaV0gJSBTUVJUX0JBU0U7XHJcbiAgICAgICAgICB4aGkgPSB4W2ldIC8gU1FSVF9CQVNFIHwgMDtcclxuICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICB0ZW1wID0ga2xvICogeGxvICsgKChtICUgU1FSVF9CQVNFKSAqIFNRUlRfQkFTRSkgKyBjYXJyeTtcclxuICAgICAgICAgIGNhcnJ5ID0gKHRlbXAgLyBiYXNlIHwgMCkgKyAobSAvIFNRUlRfQkFTRSB8IDApICsga2hpICogeGhpO1xyXG4gICAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNhcnJ5KSB4ID0gW2NhcnJ5XS5jb25jYXQoeCk7XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBjb21wYXJlKGEsIGIsIGFMLCBiTCkge1xyXG4gICAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICAgIGlmIChhTCAhPSBiTCkge1xyXG4gICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGZvciAoaSA9IGNtcCA9IDA7IGkgPCBhTDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICAgIGFbYUxdIC09IGk7XHJcbiAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOyBhLnNwbGljZSgwLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHksIGRwLCBybSwgYmFzZSkge1xyXG4gICAgICAgIHZhciBjbXAsIGUsIGksIG1vcmUsIG4sIHByb2QsIHByb2RMLCBxLCBxYywgcmVtLCByZW1MLCByZW0wLCB4aSwgeEwsIHljMCxcclxuICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgIHMgPSB4LnMgPT0geS5zID8gMSA6IC0xLFxyXG4gICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIE5hTiwgSW5maW5pdHkgb3IgMD9cclxuICAgICAgICBpZiAoIXhjIHx8ICF4Y1swXSB8fCAheWMgfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICF4LnMgfHwgIXkucyB8fCAoeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YykgPyBOYU4gOlxyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgICB4YyAmJiB4Y1swXSA9PSAwIHx8ICF5YyA/IHMgKiAwIDogcyAvIDBcclxuICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHEgPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG4gICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgICBzID0gZHAgKyBlICsgMTtcclxuXHJcbiAgICAgICAgaWYgKCFiYXNlKSB7XHJcbiAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgLSBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhlbiB0aGUgY3VycmVudCB2YWx1ZSBvZiBlLlxyXG4gICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICAgIGlmICh5Y1tpXSA+ICh4Y1tpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgICAgICBpZiAocyA8IDApIHtcclxuICAgICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgICBtb3JlID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICBuID0gbWF0aGZsb29yKGJhc2UgLyAoeWNbMF0gKyAxKSk7XHJcblxyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgICAvLyBpZiAobiA+IDEgfHwgbisrID09IDEgJiYgeWNbMF0gPCBiYXNlIC8gMikge1xyXG4gICAgICAgICAgaWYgKG4gPiAxKSB7XHJcbiAgICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICB4YyA9IG11bHRpcGx5KHhjLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHhpID0geUw7XHJcbiAgICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAvLyBBZGQgemVyb3MgdG8gbWFrZSByZW1haW5kZXIgYXMgbG9uZyBhcyBkaXZpc29yLlxyXG4gICAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICAgIHl6ID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgIHl6ID0gWzBdLmNvbmNhdCh5eik7XHJcbiAgICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICAgIGlmICh5Y1sxXSA+PSBiYXNlIC8gMikgeWMwKys7XHJcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5LCBidXQgdG8gcHJldmVudCB0cmlhbCBkaWdpdCBuID4gYmFzZSwgd2hlbiB1c2luZyBiYXNlIDMuXHJcbiAgICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpO1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICByZW0wID0gcmVtWzBdO1xyXG4gICAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgICAvLyBuIGlzIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vcihyZW0wIC8geWMwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgICAvLyAgcHJvZHVjdCA9IGRpdmlzb3IgbXVsdGlwbGllZCBieSB0cmlhbCBkaWdpdCAobikuXHJcbiAgICAgICAgICAgICAgLy8gIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgICAgLy8gICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QsIGRlY3JlbWVudCB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAvLyAgU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAgIC8vICAgIENvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvci5cclxuICAgICAgICAgICAgICAvLyAgICBJZiByZW1haW5kZXIgaXMgZ3JlYXRlciB0aGFuIGRpdmlzb3I6XHJcbiAgICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICAgIGlmIChuID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yICogdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGhpZ2ggYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCBpcyBub3Qga25vd24gdG8gaGF2ZVxyXG4gICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICBuLS07XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcHJvZHVjdC5cclxuICAgICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgY21wID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMCBvciAxLCBjbXAgaXMgLTEuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgLy8gc28gY2hhbmdlIGNtcCB0byAxIHRvIGF2b2lkIGl0LlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAxLCBsZWF2ZSBjbXAgYXMgLTEsIHNvIHljIGFuZCByZW0gYXJlIGNvbXBhcmVkIGFnYWluLlxyXG4gICAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gZGl2aXNvciA8IHJlbWFpbmRlciwgc28gbiBtdXN0IGJlIGF0IGxlYXN0IDEuXHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IG4gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHByb2R1Y3QgPSBkaXZpc29yXHJcbiAgICAgICAgICAgICAgICBwcm9kID0geWMuc2xpY2UoKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kID0gWzBdLmNvbmNhdChwcm9kKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHByb2QsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBsb3cgYWJvdXQgNSUgb2YgdGhlIHRpbWUsIGFuZCB2ZXJ5IHJhcmVseSAyIHRvbyBsb3cuXHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgICB9IC8vIGVsc2UgY21wID09PSAxIGFuZCBuIHdpbGwgYmUgMFxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXh0IGRpZ2l0LCBuLCB0byB0aGUgcmVzdWx0IGFycmF5LlxyXG4gICAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAocmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGNbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSB3aGlsZSAoKHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCkgJiYgcy0tKTtcclxuXHJcbiAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gTGVhZGluZyB6ZXJvP1xyXG4gICAgICAgICAgaWYgKCFxY1swXSkgcWMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGJhc2UgPT0gQkFTRSkge1xyXG5cclxuICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgICByb3VuZChxLCBkcCArIChxLmUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgKyAxLCBybSwgbW9yZSk7XHJcblxyXG4gICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgIHEuciA9ICttb3JlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgIH07XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyIG4gaW4gZml4ZWQtcG9pbnQgb3IgZXhwb25lbnRpYWxcclxuICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgKlxyXG4gICAgICogbjogYSBCaWdOdW1iZXIuXHJcbiAgICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAgICogcm06IHRoZSByb3VuZGluZyBtb2RlLlxyXG4gICAgICogaWQ6IDEgKHRvRXhwb25lbnRpYWwpIG9yIDIgKHRvUHJlY2lzaW9uKS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZm9ybWF0KG4sIGksIHJtLCBpZCkge1xyXG4gICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgaWYgKCFuLmMpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBjMCA9IG4uY1swXTtcclxuICAgICAgbmUgPSBuLmU7XHJcblxyXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIHN0ciA9IGlkID09IDEgfHwgaWQgPT0gMiAmJiAobmUgPD0gVE9fRVhQX05FRyB8fCBuZSA+PSBUT19FWFBfUE9TKVxyXG4gICAgICAgICA/IHRvRXhwb25lbnRpYWwoc3RyLCBuZSlcclxuICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgaSwgcm0pO1xyXG5cclxuICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIHRvUHJlY2lzaW9uIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgaWYgKGlkID09IDEgfHwgaWQgPT0gMiAmJiAoaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRykpIHtcclxuXHJcbiAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICBmb3IgKDsgbGVuIDwgaTsgc3RyICs9ICcwJywgbGVuKyspO1xyXG4gICAgICAgICAgc3RyID0gdG9FeHBvbmVudGlhbChzdHIsIGUpO1xyXG5cclxuICAgICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSAtPSBuZTtcclxuICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgaWYgKGUgKyAxID4gbGVuKSB7XHJcbiAgICAgICAgICAgIGlmICgtLWkgPiAwKSBmb3IgKHN0ciArPSAnLic7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgZm9yICg7IGktLTsgc3RyICs9ICcwJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG1ldGhvZCkge1xyXG4gICAgICB2YXIgbixcclxuICAgICAgICBpID0gMSxcclxuICAgICAgICBtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG5cclxuICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICBpZiAoIW4ucykge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZC5jYWxsKG0sIG4pKSB7XHJcbiAgICAgICAgICBtID0gbjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogU3RyaXAgdHJhaWxpbmcgemVyb3MsIGNhbGN1bGF0ZSBiYXNlIDEwIGV4cG9uZW50IGFuZCBjaGVjayBhZ2FpbnN0IE1JTl9FWFAgYW5kIE1BWF9FWFAuXHJcbiAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpc2UobiwgYywgZSkge1xyXG4gICAgICB2YXIgaSA9IDEsXHJcbiAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFjWy0tal07IGMucG9wKCkpO1xyXG5cclxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgZm9yIChqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbi5lID0gZTtcclxuICAgICAgICBuLmMgPSBjO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIHZhbHVlcyB0aGF0IGZhaWwgdGhlIHZhbGlkaXR5IHRlc3QgaW4gQmlnTnVtYmVyLlxyXG4gICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICAgIGRvdEFmdGVyID0gL14oW14uXSspXFwuJC8sXHJcbiAgICAgICAgZG90QmVmb3JlID0gL15cXC4oW14uXSspJC8sXHJcbiAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgd2hpdGVzcGFjZU9yUGx1cyA9IC9eXFxzKlxcKyg/PVtcXHcuXSl8Xlxccyt8XFxzKyQvZztcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgc3RyLCBpc051bSwgYikge1xyXG4gICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgcyA9IGlzTnVtID8gc3RyIDogc3RyLnJlcGxhY2Uod2hpdGVzcGFjZU9yUGx1cywgJycpO1xyXG5cclxuICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgICB4LnMgPSBpc05hTihzKSA/IG51bGwgOiBzIDwgMCA/IC0xIDogMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgICAgLy8gYmFzZVByZWZpeCA9IC9eKC0/KTAoW3hib10pKD89XFx3W1xcdy5dKiQpL2lcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShiYXNlUHJlZml4LCBmdW5jdGlvbiAobSwgcDEsIHAyKSB7XHJcbiAgICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFiIHx8IGIgPT0gYmFzZSA/IHAxIDogbTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSBiO1xyXG5cclxuICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzdHIgIT0gcykgcmV0dXJuIG5ldyBCaWdOdW1iZXIocywgYmFzZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIG51bWJlcjoge259J1xyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdOb3QgYScgKyAoYiA/ICcgYmFzZSAnICsgYiA6ICcnKSArICcgbnVtYmVyOiAnICsgc3RyKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBOYU5cclxuICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUm91bmQgeCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybS4gQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHJvdW5kKHgsIHNkLCBybSwgcikge1xyXG4gICAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHBvd3MxMCA9IFBPV1NfVEVOO1xyXG5cclxuICAgICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICAgIGlmICh4Yykge1xyXG5cclxuICAgICAgICAvLyByZCBpcyB0aGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgLy8gbmkgaXMgdGhlIGluZGV4IG9mIG4gd2l0aGluIHguYy5cclxuICAgICAgICAvLyBkIGlzIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gaiBpcyB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiBuIChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuICAgICAgICBvdXQ6IHtcclxuXHJcbiAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgICBmb3IgKGQgPSAxLCBrID0geGNbMF07IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcbiAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgICAgIGkgKz0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgICAgbiA9IHhjW25pID0gMF07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCB8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmkgPj0geGMubGVuZ3RoKSB7XHJcblxyXG4gICAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgeGMubGVuZ3RoIDw9IG5pOyB4Yy5wdXNoKDApKTtcclxuICAgICAgICAgICAgICAgIG4gPSByZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBuID0gayA9IHhjW25pXTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIG4uXHJcbiAgICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbi5cclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAvLyBUaGUgbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2YgbiBpcyBnaXZlbiBieSBMT0dfQkFTRSAtIGQuXHJcbiAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICAgIHJkID0gaiA8IDAgPyAwIDogbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgciA9IHIgfHwgc2QgPCAwIHx8XHJcblxyXG4gICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgLy8gVGhlIGV4cHJlc3Npb24gIG4gJSBwb3dzMTBbZCAtIGogLSAxXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAvLyBvZiB0aGUgZGlnaXQgYXQgaiwgZS5nLiBpZiBuIGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvbiBnaXZlcyA3MTQuXHJcbiAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICAgIHIgPSBybSA8IDRcclxuICAgICAgICAgICA/IChyZCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZGlnaXQgdG8gdGhlIGxlZnQgb2YgdGhlIHJvdW5kaW5nIGRpZ2l0IGlzIG9kZC5cclxuICAgICAgICAgICAgKChpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFtkIC0gal0gOiAwIDogeGNbbmkgLSAxXSkgJSAxMCkgJiAxIHx8XHJcbiAgICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgICAgaWYgKHNkIDwgMSB8fCAheGNbMF0pIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgc2QgdG8gZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHBvd3MxMFsoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFXTtcclxuICAgICAgICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaTtcclxuICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgIG5pLS07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgIGsgPSBwb3dzMTBbTE9HX0JBU0UgLSBpXTtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gNTY3MDAgYmVjb21lcyA1NjAwMCBpZiA3IGlzIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICAgIHhjW25pXSA9IGogPiAwID8gbWF0aGZsb29yKG4gLyBwb3dzMTBbZCAtIGpdICUgcG93czEwW2pdKSAqIGsgOiAwO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgICAgaWYgKG5pID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICAgIGogPSB4Y1swXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgZm9yIChrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICBpZiAoeGNbbmldICE9IEJBU0UpIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBPdmVyZmxvdz8gSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIFVuZGVyZmxvdz8gWmVyby5cclxuICAgICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgICAgdmFyIHN0cixcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcblxyXG4gICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgICA6IHRvRml4ZWRQb2ludChzdHIsIGUsICcwJyk7XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICovXHJcbiAgICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuXHJcbiAgICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiAgIDAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gICAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICovXHJcbiAgICBQLmNvbXBhcmVkVG8gPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgICAqIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2YgZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzOiBpbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgICBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgbiA9ICgodiA9IGMubGVuZ3RoIC0gMSkgLSBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkpICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICAgIGlmIChuIDwgMCkgbiA9IDA7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgKiAgbiAvIE4gPSBOXHJcbiAgICAgKiAgbiAvIEkgPSAwXHJcbiAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgKiAgMCAvIDAgPSBOXHJcbiAgICAgKiAgMCAvIE4gPSBOXHJcbiAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgKiAgTiAvIG4gPSBOXHJcbiAgICAgKiAgTiAvIDAgPSBOXHJcbiAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgKiAgTiAvIEkgPSBOXHJcbiAgICAgKiAgSSAvIG4gPSBJXHJcbiAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgKiAgSSAvIE4gPSBOXHJcbiAgICAgKiAgSSAvIEkgPSBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICAgKi9cclxuICAgIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIERFQ0lNQUxfUExBQ0VTLCBST1VORElOR19NT0RFKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciBieSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuaWRpdiA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBkaXYodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSwgMCwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBleHBvbmVudGlhdGVkIGJ5IG4uXHJcbiAgICAgKlxyXG4gICAgICogSWYgbSBpcyBwcmVzZW50LCByZXR1cm4gdGhlIHJlc3VsdCBtb2R1bG8gbS5cclxuICAgICAqIElmIG4gaXMgbmVnYXRpdmUgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBtb2R1bGFyIHBvd2VyIG9wZXJhdGlvbiB3b3JrcyBlZmZpY2llbnRseSB3aGVuIHgsIG4sIGFuZCBtIGFyZSBpbnRlZ2Vycywgb3RoZXJ3aXNlIGl0XHJcbiAgICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAgICpcclxuICAgICAqIG4ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgZXhwb25lbnQuIEFuIGludGVnZXIuXHJcbiAgICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gRXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAqL1xyXG4gICAgUC5leHBvbmVudGlhdGVkQnkgPSBQLnBvdyA9IGZ1bmN0aW9uIChuLCBtKSB7XHJcbiAgICAgIHZhciBoYWxmLCBpc01vZEV4cCwgaSwgaywgbW9yZSwgbklzQmlnLCBuSXNOZWcsIG5Jc09kZCwgeSxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKG4pO1xyXG5cclxuICAgICAgLy8gQWxsb3cgTmFOIGFuZCDCsUluZmluaXR5LCBidXQgbm90IG90aGVyIG5vbi1pbnRlZ2Vycy5cclxuICAgICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnRXhwb25lbnQgbm90IGFuIGludGVnZXI6ICcgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG0gIT0gbnVsbCkgbSA9IG5ldyBCaWdOdW1iZXIobSk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudCBvZiBNQVhfU0FGRV9JTlRFR0VSIGlzIDE1LlxyXG4gICAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgTmFOLCDCsUluZmluaXR5LCDCsTAgb3IgwrExLCBvciBuIGlzIMKxSW5maW5pdHksIE5hTiBvciDCsTAuXHJcbiAgICAgIGlmICgheC5jIHx8ICF4LmNbMF0gfHwgeC5jWzBdID09IDEgJiYgIXguZSAmJiB4LmMubGVuZ3RoID09IDEgfHwgIW4uYyB8fCAhbi5jWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAgIC8vIElmICtuIG92ZXJmbG93cyB0byDCsUluZmluaXR5LCB0aGUgZXZlbm5lc3Mgb2YgbiB3b3VsZCBiZSBub3QgYmUga25vd24uXHJcbiAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoTWF0aC5wb3coK3ZhbHVlT2YoeCksIG5Jc0JpZyA/IG4ucyAqICgyIC0gaXNPZGQobikpIDogK3ZhbHVlT2YobikpKTtcclxuICAgICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbklzTmVnID0gbi5zIDwgMDtcclxuXHJcbiAgICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAgIC8vIHggJSBtIHJldHVybnMgTmFOIGlmIGFicyhtKSBpcyB6ZXJvLCBvciBtIGlzIE5hTi5cclxuICAgICAgICBpZiAobS5jID8gIW0uY1swXSA6ICFtLnMpIHJldHVybiBuZXcgQmlnTnVtYmVyKE5hTik7XHJcblxyXG4gICAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICAgIGlmIChpc01vZEV4cCkgeCA9IHgubW9kKG0pO1xyXG5cclxuICAgICAgLy8gT3ZlcmZsb3cgdG8gwrFJbmZpbml0eTogPj0yKioxZTEwIG9yID49MS4wMDAwMDI0KioxZTE1LlxyXG4gICAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICAgIH0gZWxzZSBpZiAobi5lID4gOSAmJiAoeC5lID4gMCB8fCB4LmUgPCAtMSB8fCAoeC5lID09IDBcclxuICAgICAgICAvLyBbMSwgMjQwMDAwMDAwXVxyXG4gICAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgICAvLyBbODAwMDAwMDAwMDAwMDBdICBbOTk5OTk3NTAwMDAwMDBdXHJcbiAgICAgICAgOiB4LmNbMF0gPCA4ZTEzIHx8IG5Jc0JpZyAmJiB4LmNbMF0gPD0gOTk5OTk3NWU3KSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgICBrID0geC5zIDwgMCAmJiBpc09kZChuKSA/IC0wIDogMDtcclxuXHJcbiAgICAgICAgLy8gSWYgeCA+PSAxLCBrID0gwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgICAgLy8gSWYgbiBpcyBuZWdhdGl2ZSByZXR1cm4gwrEwLCBlbHNlIHJldHVybiDCsUluZmluaXR5LlxyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG5Jc05lZyA/IDEgLyBrIDogayk7XHJcblxyXG4gICAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGluZyBlYWNoIGNvZWZmaWNpZW50IGFycmF5IHRvIGEgbGVuZ3RoIG9mIGsgYWZ0ZXIgZWFjaCBtdWx0aXBsaWNhdGlvblxyXG4gICAgICAgIC8vIGVxdWF0ZXMgdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLFxyXG4gICAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICAgIGsgPSBtYXRoY2VpbChQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKDAuNSk7XHJcbiAgICAgICAgaWYgKG5Jc05lZykgbi5zID0gMTtcclxuICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpID0gTWF0aC5hYnMoK3ZhbHVlT2YobikpO1xyXG4gICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcblxyXG4gICAgICAgIGlmIChuSXNPZGQpIHtcclxuICAgICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgICAgaWYgKCF5LmMpIGJyZWFrO1xyXG5cclxuICAgICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICAgIHkgPSB5Lm1vZChtKTsgICAgLy95ID0geS5taW51cyhkaXYoeSwgbSwgMCwgTU9EVUxPX01PREUpLnRpbWVzKG0pKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChpKSB7XHJcbiAgICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuID0gbi50aW1lcyhoYWxmKTtcclxuICAgICAgICAgIHJvdW5kKG4sIG4uZSArIDEsIDEpO1xyXG5cclxuICAgICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgICBuSXNPZGQgPSBpICUgMjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSB4LnRpbWVzKHgpO1xyXG5cclxuICAgICAgICBpZiAoaykge1xyXG4gICAgICAgICAgaWYgKHguYyAmJiB4LmMubGVuZ3RoID4gaykgeC5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgICAgaWYgKG5Jc05lZykgeSA9IE9ORS5kaXYoeSk7XHJcblxyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogayA/IHJvdW5kKHksIFBPV19QUkVDSVNJT04sIFJPVU5ESU5HX01PREUsIG1vcmUpIDogeTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGFuIGludGVnZXJcclxuICAgICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtybX0nXHJcbiAgICAgKi9cclxuICAgIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICAgIHJldHVybiByb3VuZChuLCBuLmUgKyAxLCBybSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRXF1YWxUbyA9IFAuZXEgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0dyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAxIHx8IGIgPT09IDA7XHJcblxyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIGJpdEZsb29yKHRoaXMuZSAvIExPR19CQVNFKSA+IHRoaXMuYy5sZW5ndGggLSAyO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNMZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gIXRoaXMucztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzUG9zaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBuIC0gMCA9IG5cclxuICAgICAqICBuIC0gTiA9IE5cclxuICAgICAqICBuIC0gSSA9IC1JXHJcbiAgICAgKiAgMCAtIG4gPSAtblxyXG4gICAgICogIDAgLSAwID0gMFxyXG4gICAgICogIDAgLSBOID0gTlxyXG4gICAgICogIDAgLSBJID0gLUlcclxuICAgICAqICBOIC0gbiA9IE5cclxuICAgICAqICBOIC0gMCA9IE5cclxuICAgICAqICBOIC0gTiA9IE5cclxuICAgICAqICBOIC0gSSA9IE5cclxuICAgICAqICBJIC0gbiA9IElcclxuICAgICAqICBJIC0gMCA9IElcclxuICAgICAqICBJIC0gTiA9IE5cclxuICAgICAqICBJIC0gSSA9IE5cclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5taW51cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBpLCBqLCB0LCB4TFR5LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiB4YyA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHljID8geCA6IE5hTik7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgICAvLyBJRUVFIDc1NCAoMjAwOCkgNi4zOiBuIC0gbiA9IC0wIHdoZW4gcm91bmRpbmcgdG8gLUluZmluaXR5XHJcbiAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgICAgaWYgKHhMVHkgPSBhIDwgMCkge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5ZSA9IHhlO1xyXG4gICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcblxyXG4gICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgIGZvciAoYiA9IGE7IGItLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gRXhwb25lbnRzIGVxdWFsLiBDaGVjayBkaWdpdCBieSBkaWdpdC5cclxuICAgICAgICBqID0gKHhMVHkgPSAoYSA9IHhjLmxlbmd0aCkgPCAoYiA9IHljLmxlbmd0aCkpID8gYSA6IGI7XHJcblxyXG4gICAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgICAgaWYgKHhjW2JdICE9IHljW2JdKSB7XHJcbiAgICAgICAgICAgIHhMVHkgPSB4Y1tiXSA8IHljW2JdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHggPCB5PyBQb2ludCB4YyB0byB0aGUgYXJyYXkgb2YgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmICh4TFR5KSB7XHJcbiAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIHhjID0geWM7XHJcbiAgICAgICAgeWMgPSB0O1xyXG4gICAgICAgIHkucyA9IC15LnM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGIgPSAoaiA9IHljLmxlbmd0aCkgLSAoaSA9IHhjLmxlbmd0aCk7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgaWYgKGIgPiAwKSBmb3IgKDsgYi0tOyB4Y1tpKytdID0gMCk7XHJcbiAgICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHljIGZyb20geGMuXHJcbiAgICAgIGZvciAoOyBqID4gYTspIHtcclxuXHJcbiAgICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgICAgZm9yIChpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiKTtcclxuICAgICAgICAgIC0teGNbaV07XHJcbiAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGNbal0gLT0geWNbal07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgIGZvciAoOyB4Y1swXSA9PSAwOyB4Yy5zcGxpY2UoMCwgMSksIC0teWUpO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKCF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBGb2xsb3dpbmcgSUVFRSA3NTQgKDIwMDgpIDYuMyxcclxuICAgICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgIHkuYyA9IFt5LmUgPSAwXTtcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICAgbiAlIDAgPSAgTlxyXG4gICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgKiAgIG4gJSBJID0gIG5cclxuICAgICAqICAgMCAlIG4gPSAgMFxyXG4gICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgKiAgIDAgJSAwID0gIE5cclxuICAgICAqICAgMCAlIE4gPSAgTlxyXG4gICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgKiAgIE4gJSBuID0gIE5cclxuICAgICAqICAgTiAlIDAgPSAgTlxyXG4gICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgKiAgIE4gJSBJID0gIE5cclxuICAgICAqICAgSSAlIG4gPSAgTlxyXG4gICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgKiAgIEkgJSBOID0gIE5cclxuICAgICAqICAgSSAlIEkgPSAgTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS4gVGhlIHJlc3VsdCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSBvZiBNT0RVTE9fTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIHggaXMgSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciB6ZXJvLlxyXG4gICAgICBpZiAoIXguYyB8fCAheS5zIHx8IHkuYyAmJiAheS5jWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgSW5maW5pdHkgb3IgeCBpcyB6ZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKCF5LmMgfHwgeC5jICYmICF4LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKE1PRFVMT19NT0RFID09IDkpIHtcclxuXHJcbiAgICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgcyA9IHkucztcclxuICAgICAgICB5LnMgPSAxO1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgMyk7XHJcbiAgICAgICAgeS5zID0gcztcclxuICAgICAgICBxLnMgKj0gcztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBxID0gZGl2KHgsIHksIDAsIE1PRFVMT19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeSA9IHgubWludXMocS50aW1lcyh5KSk7XHJcblxyXG4gICAgICAvLyBUbyBtYXRjaCBKYXZhU2NyaXB0ICUsIGVuc3VyZSBzaWduIG9mIHplcm8gaXMgc2lnbiBvZiBkaXZpZGVuZC5cclxuICAgICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKiAwID0gMFxyXG4gICAgICogIG4gKiBOID0gTlxyXG4gICAgICogIG4gKiBJID0gSVxyXG4gICAgICogIDAgKiBuID0gMFxyXG4gICAgICogIDAgKiAwID0gMFxyXG4gICAgICogIDAgKiBOID0gTlxyXG4gICAgICogIDAgKiBJID0gTlxyXG4gICAgICogIE4gKiBuID0gTlxyXG4gICAgICogIE4gKiAwID0gTlxyXG4gICAgICogIE4gKiBOID0gTlxyXG4gICAgICogIE4gKiBJID0gTlxyXG4gICAgICogIEkgKiBuID0gSVxyXG4gICAgICogIEkgKiAwID0gTlxyXG4gICAgICogIEkgKiBOID0gTlxyXG4gICAgICogIEkgKiBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG11bHRpcGxpZWQgYnkgdGhlIHZhbHVlXHJcbiAgICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAubXVsdGlwbGllZEJ5ID0gUC50aW1lcyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9ICh5ID0gbmV3IEJpZ051bWJlcih5LCBiKSkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIMKxSW5maW5pdHkgb3IgwrEwP1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTiwgb3Igb25lIGlzIDAgYW5kIHRoZSBvdGhlciBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXgucyB8fCAheS5zIHx8IHhjICYmICF4Y1swXSAmJiAheWMgfHwgeWMgJiYgIXljWzBdICYmICF4Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeS5zICo9IHgucztcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAgIGlmICgheGMgfHwgIXljKSB7XHJcbiAgICAgICAgICAgIHkuYyA9IHkuZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeS5jID0gWzBdO1xyXG4gICAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSBiaXRGbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBiaXRGbG9vcih5LmUgLyBMT0dfQkFTRSk7XHJcbiAgICAgIHkucyAqPSB4LnM7XHJcbiAgICAgIHhjTCA9IHhjLmxlbmd0aDtcclxuICAgICAgeWNMID0geWMubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgICBpZiAoeGNMIDwgeWNMKSB7XHJcbiAgICAgICAgemMgPSB4YztcclxuICAgICAgICB4YyA9IHljO1xyXG4gICAgICAgIHljID0gemM7XHJcbiAgICAgICAgaSA9IHhjTDtcclxuICAgICAgICB4Y0wgPSB5Y0w7XHJcbiAgICAgICAgeWNMID0gaTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICAgIGZvciAoaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApKTtcclxuXHJcbiAgICAgIGJhc2UgPSBCQVNFO1xyXG4gICAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICAgIGZvciAoaSA9IHljTDsgLS1pID49IDA7KSB7XHJcbiAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgZm9yIChrID0geGNMLCBqID0gaSArIGs7IGogPiBpOykge1xyXG4gICAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICBtID0geWhpICogeGxvICsgeGhpICogeWxvO1xyXG4gICAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgYyA9ICh4bG8gLyBiYXNlIHwgMCkgKyAobSAvIHNxcnRCYXNlIHwgMCkgKyB5aGkgKiB4aGk7XHJcbiAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHpjW2pdID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGMpIHtcclxuICAgICAgICArK2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHpjLCBlKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBuZWdhdGVkLFxyXG4gICAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAgICovXHJcbiAgICBQLm5lZ2F0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICByZXR1cm4geDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgKiAgbiArIE4gPSBOXHJcbiAgICAgKiAgbiArIEkgPSBJXHJcbiAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgKiAgMCArIDAgPSAwXHJcbiAgICAgKiAgMCArIE4gPSBOXHJcbiAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgKiAgTiArIG4gPSBOXHJcbiAgICAgKiAgTiArIDAgPSBOXHJcbiAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgKiAgTiArIEkgPSBOXHJcbiAgICAgKiAgSSArIG4gPSBJXHJcbiAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgKiAgSSArIE4gPSBOXHJcbiAgICAgKiAgSSArIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgICAqIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICAgIHkucyA9IC1iO1xyXG4gICAgICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgeGUgPSB4LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0geS5jO1xyXG5cclxuICAgICAgaWYgKCF4ZSB8fCAheWUpIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCF4YyB8fCAheWMpIHJldHVybiBuZXcgQmlnTnVtYmVyKGEgLyAwKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHJldHVybiB5Y1swXSA/IHkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6IGEgKiAwKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG4gICAgICAgIGlmIChhID4gMCkge1xyXG4gICAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICAgIHQgPSB5YztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgZm9yICg7IGEtLTsgdC5wdXNoKDApKTtcclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgYSA9IHhjLmxlbmd0aDtcclxuICAgICAgYiA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgICAgaWYgKGEgLSBiIDwgMCkge1xyXG4gICAgICAgIHQgPSB5YztcclxuICAgICAgICB5YyA9IHhjO1xyXG4gICAgICAgIHhjID0gdDtcclxuICAgICAgICBiID0gYTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgIGZvciAoYSA9IDA7IGI7KSB7XHJcbiAgICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgeGNbYl0gPSBCQVNFID09PSB4Y1tiXSA/IDAgOiB4Y1tiXSAlIEJBU0U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChhKSB7XHJcbiAgICAgICAgeGMgPSBbYV0uY29uY2F0KHhjKTtcclxuICAgICAgICArK3llO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICAgIC8vIHllID0gTUFYX0VYUCArIDEgcG9zc2libGVcclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAgICogdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAqIElmIHNkIGlzIHRydWUgaW5jbHVkZSBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3MgaW4gdGhlIGNvdW50LlxyXG4gICAgICpcclxuICAgICAqIE90aGVyd2lzZSwgaWYgc2QgaXMgYSBudW1iZXIsIHJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAqIEJpZ051bWJlciByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBzZCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3JcclxuICAgICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBzZCB7bnVtYmVyfGJvb2xlYW59IG51bWJlcjogc2lnbmlmaWNhbnQgZGlnaXRzOiBpbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnByZWNpc2lvbiA9IFAuc2QgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKHNkICE9IG51bGwgJiYgc2QgIT09ICEhc2QpIHtcclxuICAgICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCEoYyA9IHguYykpIHJldHVybiBudWxsO1xyXG4gICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkge1xyXG5cclxuICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQuXHJcbiAgICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHNkICYmIHguZSArIDEgPiBuKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgIHJldHVybiBuO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAqIChwb3dlcnMgb2YgMTApLiBTaGlmdCB0byB0aGUgcmlnaHQgaWYgbiA+IDAsIGFuZCB0byB0aGUgbGVmdCBpZiBuIDwgMC5cclxuICAgICAqXHJcbiAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7a30nXHJcbiAgICAgKi9cclxuICAgIFAuc2hpZnRlZEJ5ID0gZnVuY3Rpb24gKGspIHtcclxuICAgICAgaW50Q2hlY2soaywgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpO1xyXG4gICAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIHNxcnQoLW4pID0gIE5cclxuICAgICAqICBzcXJ0KE4pID0gIE5cclxuICAgICAqICBzcXJ0KC1JKSA9ICBOXHJcbiAgICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICAgKiAgc3FydCgwKSA9ICAwXHJcbiAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlcixcclxuICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtLCBuLCByLCByZXAsIHQsXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYyA9IHguYyxcclxuICAgICAgICBzID0geC5zLFxyXG4gICAgICAgIGUgPSB4LmUsXHJcbiAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoJzAuNScpO1xyXG5cclxuICAgICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICAgIGlmIChzICE9PSAxIHx8ICFjIHx8ICFjWzBdKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoIXMgfHwgcyA8IDAgJiYgKCFjIHx8IGNbMF0pID8gTmFOIDogYyA/IHggOiAxIC8gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluaXRpYWwgZXN0aW1hdGUuXHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK3ZhbHVlT2YoeCkpO1xyXG5cclxuICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKHMgPT0gMCB8fCBzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgICBzID0gTWF0aC5zcXJ0KCtuKTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihuKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgemVyby5cclxuICAgICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgICAgLy8gVGhpcyB3b3VsZCBjYXVzZSBhIGRpdmlzaW9uIGJ5IHplcm8gKHgvdCkgYW5kIGhlbmNlIEluZmluaXR5IGJlbG93LCB3aGljaCB3b3VsZCBjYXVzZVxyXG4gICAgICAvLyBjb2VmZlRvU3RyaW5nIHRvIHRocm93LlxyXG4gICAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICBzID0gZSArIGRwO1xyXG4gICAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAgIC8vIE5ld3Rvbi1SYXBoc29uIGl0ZXJhdGlvbi5cclxuICAgICAgICBmb3IgKDsgOykge1xyXG4gICAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgICByID0gaGFsZi50aW1lcyh0LnBsdXMoZGl2KHgsIHQsIGRwLCAxKSkpO1xyXG5cclxuICAgICAgICAgIGlmIChjb2VmZlRvU3RyaW5nKHQuYykuc2xpY2UoMCwgcykgPT09IChuID0gY29lZmZUb1N0cmluZyhyLmMpKS5zbGljZSgwLCBzKSkge1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tID4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikge1xyXG4gICAgICAgICAgaSA9IGcxO1xyXG4gICAgICAgICAgZzEgPSBnMjtcclxuICAgICAgICAgIGcyID0gaTtcclxuICAgICAgICAgIGxlbiAtPSBpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGcxID4gMCAmJiBsZW4gPiAwKSB7XHJcbiAgICAgICAgICBpID0gbGVuICUgZzEgfHwgZzE7XHJcbiAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICAgIGZvciAoOyBpIDwgbGVuOyBpICs9IGcxKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnN1YnN0cihpLCBnMSk7XHJcbiAgICAgICAgICBpZiAoZzIgPiAwKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IGZyYWN0aW9uUGFydFxyXG4gICAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgICA/IGZyYWN0aW9uUGFydC5yZXBsYWNlKG5ldyBSZWdFeHAoJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycpLFxyXG4gICAgICAgICAgICckJicgKyAoZm9ybWF0LmZyYWN0aW9uR3JvdXBTZXBhcmF0b3IgfHwgJycpKVxyXG4gICAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICAgIDogaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAgICogZnJhY3Rpb24gd2l0aCBhbiBpbnRlZ2VyIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWRcclxuICAgICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAgICogdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBudW1iZXIgZXhhY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9IDoge21kfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgIHZhciBkLCBkMCwgZDEsIGQyLCBlLCBleHAsIG4sIG4wLCBuMSwgcSwgciwgcyxcclxuICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICB4YyA9IHguYztcclxuXHJcbiAgICAgIGlmIChtZCAhPSBudWxsKSB7XHJcbiAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgICAvLyBUaHJvdyBpZiBtZCBpcyBsZXNzIHRoYW4gb25lIG9yIGlzIG5vdCBhbiBpbnRlZ2VyLCB1bmxlc3MgaXQgaXMgSW5maW5pdHkuXHJcbiAgICAgICAgaWYgKCFuLmlzSW50ZWdlcigpICYmIChuLmMgfHwgbi5zICE9PSAxKSB8fCBuLmx0KE9ORSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCAnICtcclxuICAgICAgICAgICAgICAobi5pc0ludGVnZXIoKSA/ICdvdXQgb2YgcmFuZ2U6ICcgOiAnbm90IGFuIGludGVnZXI6ICcpICsgdmFsdWVPZihuKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXhjKSByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuXHJcbiAgICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIGQxID0gbjAgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSBpbml0aWFsIGRlbm9taW5hdG9yLlxyXG4gICAgICAvLyBkIGlzIGEgcG93ZXIgb2YgMTAgYW5kIHRoZSBtaW5pbXVtIG1heCBkZW5vbWluYXRvciB0aGF0IHNwZWNpZmllcyB0aGUgdmFsdWUgZXhhY3RseS5cclxuICAgICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgICAgZC5jWzBdID0gUE9XU19URU5bKGV4cCA9IGUgJSBMT0dfQkFTRSkgPCAwID8gTE9HX0JBU0UgKyBleHAgOiBleHBdO1xyXG4gICAgICBtZCA9ICFtZCB8fCBuLmNvbXBhcmVkVG8oZCkgPiAwID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcblxyXG4gICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICBmb3IgKDsgOykgIHtcclxuICAgICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICAgIGQyID0gZDAucGx1cyhxLnRpbWVzKGQxKSk7XHJcbiAgICAgICAgaWYgKGQyLmNvbXBhcmVkVG8obWQpID09IDEpIGJyZWFrO1xyXG4gICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgZDEgPSBkMjtcclxuICAgICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMiA9IG4xKSk7XHJcbiAgICAgICAgbjAgPSBkMjtcclxuICAgICAgICBkID0gbi5taW51cyhxLnRpbWVzKGQyID0gZCkpO1xyXG4gICAgICAgIG4gPSBkMjtcclxuICAgICAgfVxyXG5cclxuICAgICAgZDIgPSBkaXYobWQubWludXMoZDApLCBkMSwgMCwgMSk7XHJcbiAgICAgIG4wID0gbjAucGx1cyhkMi50aW1lcyhuMSkpO1xyXG4gICAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgIGUgPSBlICogMjtcclxuXHJcbiAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgciA9IGRpdihuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpLmNvbXBhcmVkVG8oXHJcbiAgICAgICAgICBkaXYobjAsIGQwLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKSkgPCAxID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgICByZXR1cm4gcjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAgICAgKi9cclxuICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiArdmFsdWVPZih0aGlzKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICAgKiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgc2QsIHJtLCAyKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBiYXNlIGIsIG9yIGJhc2UgMTAgaWYgYiBpc1xyXG4gICAgICogb21pdHRlZC4gSWYgYSBiYXNlIGlzIHNwZWNpZmllZCwgaW5jbHVkaW5nIGJhc2UgMTAsIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmRcclxuICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAqIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIFRPX0VYUF9QT1MsIG9yIGEgbmVnYXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgbGVzcyB0aGFuXHJcbiAgICAgKiBUT19FWFBfTkVHLCByZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogW2JdIHtudW1iZXJ9IEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICAgKi9cclxuICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIG4gPSB0aGlzLFxyXG4gICAgICAgIHMgPSBuLnMsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgaWYgKGUgPT09IG51bGwpIHtcclxuICAgICAgICBpZiAocykge1xyXG4gICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgIGlmIChzIDwgMCkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG4gICAgICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYiA9PT0gMTAgJiYgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzKSB7XHJcbiAgICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBuLmUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICAgIHN0ciA9IGNvbnZlcnRCYXNlKHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyksIDEwLCBiLCBzLCB0cnVlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYXMgdG9TdHJpbmcsIGJ1dCBkbyBub3QgYWNjZXB0IGEgYmFzZSBhcmd1bWVudCwgYW5kIGluY2x1ZGUgdGhlIG1pbnVzIHNpZ24gZm9yXHJcbiAgICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAgICovXHJcbiAgICBQLnZhbHVlT2YgPSBQLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBQLl9pc0JpZ051bWJlciA9IHRydWU7XHJcblxyXG4gICAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICB9XHJcblxyXG5cclxuICAvLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbiAgLy8gVGhlc2UgZnVuY3Rpb25zIGRvbid0IG5lZWQgYWNjZXNzIHRvIHZhcmlhYmxlcyxcclxuICAvLyBlLmcuIERFQ0lNQUxfUExBQ0VTLCBpbiB0aGUgc2NvcGUgb2YgdGhlIGBjbG9uZWAgZnVuY3Rpb24gYWJvdmUuXHJcblxyXG5cclxuICBmdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgcmV0dXJuIG4gPiAwIHx8IG4gPT09IGkgPyBpIDogaSAtIDE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIGEgY29lZmZpY2llbnQgYXJyYXkgYXMgYSBzdHJpbmcgb2YgYmFzZSAxMCBkaWdpdHMuXHJcbiAgZnVuY3Rpb24gY29lZmZUb1N0cmluZyhhKSB7XHJcbiAgICB2YXIgcywgeixcclxuICAgICAgaSA9IDEsXHJcbiAgICAgIGogPSBhLmxlbmd0aCxcclxuICAgICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgICBmb3IgKDsgaSA8IGo7KSB7XHJcbiAgICAgIHMgPSBhW2krK10gKyAnJztcclxuICAgICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICAgIGZvciAoOyB6LS07IHMgPSAnMCcgKyBzKTtcclxuICAgICAgciArPSBzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoaiA9IHIubGVuZ3RoOyByLmNoYXJDb2RlQXQoLS1qKSA9PT0gNDg7KTtcclxuXHJcbiAgICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgICB2YXIgYSwgYixcclxuICAgICAgeGMgPSB4LmMsXHJcbiAgICAgIHljID0geS5jLFxyXG4gICAgICBpID0geC5zLFxyXG4gICAgICBqID0geS5zLFxyXG4gICAgICBrID0geC5lLFxyXG4gICAgICBsID0geS5lO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICAgIGEgPSB4YyAmJiAheGNbMF07XHJcbiAgICBiID0geWMgJiYgIXljWzBdO1xyXG5cclxuICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgaWYgKGEgfHwgYikgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgICBhID0gaSA8IDA7XHJcbiAgICBiID0gayA9PSBsO1xyXG5cclxuICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gYiA/IDAgOiAheGMgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZXhwb25lbnRzLlxyXG4gICAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIGogPSAoayA9IHhjLmxlbmd0aCkgPCAobCA9IHljLmxlbmd0aCkgPyBrIDogbDtcclxuXHJcbiAgICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayB0aGF0IG4gaXMgYSBwcmltaXRpdmUgbnVtYmVyLCBhbiBpbnRlZ2VyLCBhbmQgaW4gcmFuZ2UsIG90aGVyd2lzZSB0aHJvdy5cclxuICAgKi9cclxuICBmdW5jdGlvbiBpbnRDaGVjayhuLCBtaW4sIG1heCwgbmFtZSkge1xyXG4gICAgaWYgKG4gPCBtaW4gfHwgbiA+IG1heCB8fCBuICE9PSBtYXRoZmxvb3IobikpIHtcclxuICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgIChiaWdudW1iZXJFcnJvciArIChuYW1lIHx8ICdBcmd1bWVudCcpICsgKHR5cGVvZiBuID09ICdudW1iZXInXHJcbiAgICAgICAgID8gbiA8IG1pbiB8fCBuID4gbWF4ID8gJyBvdXQgb2YgcmFuZ2U6ICcgOiAnIG5vdCBhbiBpbnRlZ2VyOiAnXHJcbiAgICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuICBmdW5jdGlvbiBpc09kZChuKSB7XHJcbiAgICB2YXIgayA9IG4uYy5sZW5ndGggLSAxO1xyXG4gICAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB0b0V4cG9uZW50aWFsKHN0ciwgZSkge1xyXG4gICAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgICAoZSA8IDAgPyAnZScgOiAnZSsnKSArIGU7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gICAgdmFyIGxlbiwgenM7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUgZXhwb25lbnQ/XHJcbiAgICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MuXHJcbiAgICAgIGZvciAoenMgPSB6ICsgJy4nOyArK2U7IHpzICs9IHopO1xyXG4gICAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgICAvLyBQb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcy5cclxuICAgICAgaWYgKCsrZSA+IGxlbikge1xyXG4gICAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgICBzdHIgKz0genM7XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IGxlbikge1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gRVhQT1JUXHJcblxyXG5cclxuICBCaWdOdW1iZXIgPSBjbG9uZSgpO1xyXG4gIEJpZ051bWJlclsnZGVmYXVsdCddID0gQmlnTnVtYmVyLkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSk7XHJcblxyXG4gIC8vIE5vZGUuanMgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJpZ051bWJlcjtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxPYmplY3QpIHtcclxuICAgICAgZ2xvYmFsT2JqZWN0ID0gdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiA/IHNlbGYgOiB3aW5kb3c7XHJcbiAgICB9XHJcblxyXG4gICAgZ2xvYmFsT2JqZWN0LkJpZ051bWJlciA9IEJpZ051bWJlcjtcclxuICB9XHJcbn0pKHRoaXMpO1xyXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBoYXNPd25Qcm9wZXJ0eSB9ID0gT2JqZWN0LnByb3RvdHlwZVxuXG5jb25zdCBzdHJpbmdpZnkgPSBjb25maWd1cmUoKVxuXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5zdHJpbmdpZnkuY29uZmlndXJlID0gY29uZmlndXJlXG4vLyBAdHMtZXhwZWN0LWVycm9yXG5zdHJpbmdpZnkuc3RyaW5naWZ5ID0gc3RyaW5naWZ5XG5cbi8vIEB0cy1leHBlY3QtZXJyb3JcbnN0cmluZ2lmeS5kZWZhdWx0ID0gc3RyaW5naWZ5XG5cbi8vIEB0cy1leHBlY3QtZXJyb3IgdXNlZCBmb3IgbmFtZWQgZXhwb3J0XG5leHBvcnRzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeVxuLy8gQHRzLWV4cGVjdC1lcnJvciB1c2VkIGZvciBuYW1lZCBleHBvcnRcbmV4cG9ydHMuY29uZmlndXJlID0gY29uZmlndXJlXG5cbm1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG5jb25zdCBzdHJFc2NhcGVTZXF1ZW5jZXNSZWdFeHAgPSAvW1xcdTAwMDAtXFx1MDAxZlxcdTAwMjJcXHUwMDVjXFx1ZDgwMC1cXHVkZmZmXXxbXFx1ZDgwMC1cXHVkYmZmXSg/IVtcXHVkYzAwLVxcdWRmZmZdKXwoPzpbXlxcdWQ4MDAtXFx1ZGJmZl18XilbXFx1ZGMwMC1cXHVkZmZmXS9cblxuLy8gRXNjYXBlIEMwIGNvbnRyb2wgY2hhcmFjdGVycywgZG91YmxlIHF1b3RlcywgdGhlIGJhY2tzbGFzaCBhbmQgZXZlcnkgY29kZVxuLy8gdW5pdCB3aXRoIGEgbnVtZXJpYyB2YWx1ZSBpbiB0aGUgaW5jbHVzaXZlIHJhbmdlIDB4RDgwMCB0byAweERGRkYuXG5mdW5jdGlvbiBzdHJFc2NhcGUgKHN0cikge1xuICAvLyBTb21lIG1hZ2ljIG51bWJlcnMgdGhhdCB3b3JrZWQgb3V0IGZpbmUgd2hpbGUgYmVuY2htYXJraW5nIHdpdGggdjggOC4wXG4gIGlmIChzdHIubGVuZ3RoIDwgNTAwMCAmJiAhc3RyRXNjYXBlU2VxdWVuY2VzUmVnRXhwLnRlc3Qoc3RyKSkge1xuICAgIHJldHVybiBgXCIke3N0cn1cImBcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKVxufVxuXG5mdW5jdGlvbiBpbnNlcnRTb3J0IChhcnJheSkge1xuICAvLyBJbnNlcnRpb24gc29ydCBpcyB2ZXJ5IGVmZmljaWVudCBmb3Igc21hbGwgaW5wdXQgc2l6ZXMgYnV0IGl0IGhhcyBhIGJhZFxuICAvLyB3b3JzdCBjYXNlIGNvbXBsZXhpdHkuIFRodXMsIHVzZSBuYXRpdmUgYXJyYXkgc29ydCBmb3IgYmlnZ2VyIHZhbHVlcy5cbiAgaWYgKGFycmF5Lmxlbmd0aCA+IDJlMikge1xuICAgIHJldHVybiBhcnJheS5zb3J0KClcbiAgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gYXJyYXlbaV1cbiAgICBsZXQgcG9zaXRpb24gPSBpXG4gICAgd2hpbGUgKHBvc2l0aW9uICE9PSAwICYmIGFycmF5W3Bvc2l0aW9uIC0gMV0gPiBjdXJyZW50VmFsdWUpIHtcbiAgICAgIGFycmF5W3Bvc2l0aW9uXSA9IGFycmF5W3Bvc2l0aW9uIC0gMV1cbiAgICAgIHBvc2l0aW9uLS1cbiAgICB9XG4gICAgYXJyYXlbcG9zaXRpb25dID0gY3VycmVudFZhbHVlXG4gIH1cbiAgcmV0dXJuIGFycmF5XG59XG5cbmNvbnN0IHR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZyA9XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXG4gICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKFxuICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKFxuICAgICAgICBuZXcgSW50OEFycmF5KClcbiAgICAgIClcbiAgICApLFxuICAgIFN5bWJvbC50b1N0cmluZ1RhZ1xuICApLmdldFxuXG5mdW5jdGlvbiBpc1R5cGVkQXJyYXlXaXRoRW50cmllcyAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVkQXJyYXlQcm90b3R5cGVHZXRTeW1ib2xUb1N0cmluZ1RhZy5jYWxsKHZhbHVlKSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlLmxlbmd0aCAhPT0gMFxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlUeXBlZEFycmF5IChhcnJheSwgc2VwYXJhdG9yLCBtYXhpbXVtQnJlYWR0aCkge1xuICBpZiAoYXJyYXkubGVuZ3RoIDwgbWF4aW11bUJyZWFkdGgpIHtcbiAgICBtYXhpbXVtQnJlYWR0aCA9IGFycmF5Lmxlbmd0aFxuICB9XG4gIGNvbnN0IHdoaXRlc3BhY2UgPSBzZXBhcmF0b3IgPT09ICcsJyA/ICcnIDogJyAnXG4gIGxldCByZXMgPSBgXCIwXCI6JHt3aGl0ZXNwYWNlfSR7YXJyYXlbMF19YFxuICBmb3IgKGxldCBpID0gMTsgaSA8IG1heGltdW1CcmVhZHRoOyBpKyspIHtcbiAgICByZXMgKz0gYCR7c2VwYXJhdG9yfVwiJHtpfVwiOiR7d2hpdGVzcGFjZX0ke2FycmF5W2ldfWBcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldENpcmN1bGFyVmFsdWVPcHRpb24gKG9wdGlvbnMpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ2NpcmN1bGFyVmFsdWUnKSkge1xuICAgIGNvbnN0IGNpcmN1bGFyVmFsdWUgPSBvcHRpb25zLmNpcmN1bGFyVmFsdWVcbiAgICBpZiAodHlwZW9mIGNpcmN1bGFyVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYFwiJHtjaXJjdWxhclZhbHVlfVwiYFxuICAgIH1cbiAgICBpZiAoY2lyY3VsYXJWYWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2lyY3VsYXJWYWx1ZVxuICAgIH1cbiAgICBpZiAoY2lyY3VsYXJWYWx1ZSA9PT0gRXJyb3IgfHwgY2lyY3VsYXJWYWx1ZSA9PT0gVHlwZUVycm9yKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b1N0cmluZyAoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gSlNPTicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiY2lyY3VsYXJWYWx1ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgdGhlIHZhbHVlIG51bGwgb3IgdW5kZWZpbmVkJylcbiAgfVxuICByZXR1cm4gJ1wiW0NpcmN1bGFyXVwiJ1xufVxuXG5mdW5jdGlvbiBnZXRCb29sZWFuT3B0aW9uIChvcHRpb25zLCBrZXkpIHtcbiAgbGV0IHZhbHVlXG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGtleSkpIHtcbiAgICB2YWx1ZSA9IG9wdGlvbnNba2V5XVxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtrZXl9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW5gKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBnZXRQb3NpdGl2ZUludGVnZXJPcHRpb24gKG9wdGlvbnMsIGtleSkge1xuICBsZXQgdmFsdWVcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywga2V5KSkge1xuICAgIHZhbHVlID0gb3B0aW9uc1trZXldXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7a2V5fVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXJgKVxuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke2tleX1cIiBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXJgKVxuICAgIH1cbiAgICBpZiAodmFsdWUgPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlIFwiJHtrZXl9XCIgYXJndW1lbnQgbXVzdCBiZSA+PSAxYClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIGdldEl0ZW1Db3VudCAobnVtYmVyKSB7XG4gIGlmIChudW1iZXIgPT09IDEpIHtcbiAgICByZXR1cm4gJzEgaXRlbSdcbiAgfVxuICByZXR1cm4gYCR7bnVtYmVyfSBpdGVtc2Bcbn1cblxuZnVuY3Rpb24gZ2V0VW5pcXVlUmVwbGFjZXJTZXQgKHJlcGxhY2VyQXJyYXkpIHtcbiAgY29uc3QgcmVwbGFjZXJTZXQgPSBuZXcgU2V0KClcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiByZXBsYWNlckFycmF5KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgcmVwbGFjZXJTZXQuYWRkKFN0cmluZyh2YWx1ZSkpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXBsYWNlclNldFxufVxuXG5mdW5jdGlvbiBnZXRTdHJpY3RPcHRpb24gKG9wdGlvbnMpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3N0cmljdCcpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnN0cmljdFxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwic3RyaWN0XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIGJvb2xlYW4nKVxuICAgIH1cbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBgT2JqZWN0IGNhbiBub3Qgc2FmZWx5IGJlIHN0cmluZ2lmaWVkLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIHZhbHVlfWBcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykgbWVzc2FnZSArPSBgICgke3ZhbHVlLnRvU3RyaW5nKCl9KWBcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZSAob3B0aW9ucykge1xuICBvcHRpb25zID0geyAuLi5vcHRpb25zIH1cbiAgY29uc3QgZmFpbCA9IGdldFN0cmljdE9wdGlvbihvcHRpb25zKVxuICBpZiAoZmFpbCkge1xuICAgIGlmIChvcHRpb25zLmJpZ2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zLmJpZ2ludCA9IGZhbHNlXG4gICAgfVxuICAgIGlmICghKCdjaXJjdWxhclZhbHVlJyBpbiBvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucy5jaXJjdWxhclZhbHVlID0gRXJyb3JcbiAgICB9XG4gIH1cbiAgY29uc3QgY2lyY3VsYXJWYWx1ZSA9IGdldENpcmN1bGFyVmFsdWVPcHRpb24ob3B0aW9ucylcbiAgY29uc3QgYmlnaW50ID0gZ2V0Qm9vbGVhbk9wdGlvbihvcHRpb25zLCAnYmlnaW50JylcbiAgY29uc3QgZGV0ZXJtaW5pc3RpYyA9IGdldEJvb2xlYW5PcHRpb24ob3B0aW9ucywgJ2RldGVybWluaXN0aWMnKVxuICBjb25zdCBtYXhpbXVtRGVwdGggPSBnZXRQb3NpdGl2ZUludGVnZXJPcHRpb24ob3B0aW9ucywgJ21heGltdW1EZXB0aCcpXG4gIGNvbnN0IG1heGltdW1CcmVhZHRoID0gZ2V0UG9zaXRpdmVJbnRlZ2VyT3B0aW9uKG9wdGlvbnMsICdtYXhpbXVtQnJlYWR0aCcpXG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5Rm5SZXBsYWNlciAoa2V5LCBwYXJlbnQsIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbikge1xuICAgIGxldCB2YWx1ZSA9IHBhcmVudFtrZXldXG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpXG4gICAgfVxuICAgIHZhbHVlID0gcmVwbGFjZXIuY2FsbChwYXJlbnQsIGtleSwgdmFsdWUpXG5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHN0ckVzY2FwZSh2YWx1ZSlcbiAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gY2lyY3VsYXJWYWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlcyA9ICcnXG4gICAgICAgIGxldCBqb2luID0gJywnXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kZW50YXRpb24gPSBpbmRlbnRhdGlvblxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnW10nXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhpbXVtRGVwdGggPCBzdGFjay5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1wiW0FycmF5XVwiJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKVxuICAgICAgICAgIGlmIChzcGFjZXIgIT09ICcnKSB7XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSBzcGFjZXJcbiAgICAgICAgICAgIHJlcyArPSBgXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgICBqb2luID0gYCxcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5ID0gTWF0aC5taW4odmFsdWUubGVuZ3RoLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgICBsZXQgaSA9IDBcbiAgICAgICAgICBmb3IgKDsgaSA8IG1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5Rm5SZXBsYWNlcihTdHJpbmcoaSksIHZhbHVlLCBzdGFjaywgcmVwbGFjZXIsIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICAgIHJlcyArPSBqb2luXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUZuUmVwbGFjZXIoU3RyaW5nKGkpLCB2YWx1ZSwgc3RhY2ssIHJlcGxhY2VyLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgIHJlcyArPSB0bXAgIT09IHVuZGVmaW5lZCA/IHRtcCA6ICdudWxsJ1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggLSAxID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRLZXlzID0gdmFsdWUubGVuZ3RoIC0gbWF4aW11bUJyZWFkdGggLSAxXG4gICAgICAgICAgICByZXMgKz0gYCR7am9pbn1cIi4uLiAke2dldEl0ZW1Db3VudChyZW1vdmVkS2V5cyl9IG5vdCBzdHJpbmdpZmllZFwiYFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3BhY2VyICE9PSAnJykge1xuICAgICAgICAgICAgcmVzICs9IGBcXG4ke29yaWdpbmFsSW5kZW50YXRpb259YFxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgIHJldHVybiBgWyR7cmVzfV1gXG4gICAgICAgIH1cblxuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKVxuICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgICBpZiAoa2V5TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICd7fSdcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgIHJldHVybiAnXCJbT2JqZWN0XVwiJ1xuICAgICAgICB9XG4gICAgICAgIGxldCB3aGl0ZXNwYWNlID0gJydcbiAgICAgICAgbGV0IHNlcGFyYXRvciA9ICcnXG4gICAgICAgIGlmIChzcGFjZXIgIT09ICcnKSB7XG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gc3BhY2VyXG4gICAgICAgICAgam9pbiA9IGAsXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgd2hpdGVzcGFjZSA9ICcgJ1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heGltdW1Qcm9wZXJ0aWVzVG9TdHJpbmdpZnkgPSBNYXRoLm1pbihrZXlMZW5ndGgsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICBpZiAoZGV0ZXJtaW5pc3RpYyAmJiAhaXNUeXBlZEFycmF5V2l0aEVudHJpZXModmFsdWUpKSB7XG4gICAgICAgICAga2V5cyA9IGluc2VydFNvcnQoa2V5cylcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKHZhbHVlKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heGltdW1Qcm9wZXJ0aWVzVG9TdHJpbmdpZnk7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlGblJlcGxhY2VyKGtleSwgdmFsdWUsIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICBpZiAodG1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9JHtzdHJFc2NhcGUoa2V5KX06JHt3aGl0ZXNwYWNlfSR7dG1wfWBcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IGpvaW5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtleUxlbmd0aCA+IG1heGltdW1CcmVhZHRoKSB7XG4gICAgICAgICAgY29uc3QgcmVtb3ZlZEtleXMgPSBrZXlMZW5ndGggLSBtYXhpbXVtQnJlYWR0aFxuICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9XCIuLi5cIjoke3doaXRlc3BhY2V9XCIke2dldEl0ZW1Db3VudChyZW1vdmVkS2V5cyl9IG5vdCBzdHJpbmdpZmllZFwiYFxuICAgICAgICAgIHNlcGFyYXRvciA9IGpvaW5cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BhY2VyICE9PSAnJyAmJiBzZXBhcmF0b3IubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJlcyA9IGBcXG4ke2luZGVudGF0aW9ufSR7cmVzfVxcbiR7b3JpZ2luYWxJbmRlbnRhdGlvbn1gXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgcmV0dXJuIGB7JHtyZXN9fWBcbiAgICAgIH1cbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogZmFpbCA/IGZhaWwodmFsdWUpIDogJ251bGwnXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlID8gJ3RydWUnIDogJ2ZhbHNlJ1xuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgY2FzZSAnYmlnaW50JzpcbiAgICAgICAgaWYgKGJpZ2ludCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpXG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWlsID8gZmFpbCh2YWx1ZSkgOiB1bmRlZmluZWRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlBcnJheVJlcGxhY2VyIChrZXksIHZhbHVlLCBzdGFjaywgcmVwbGFjZXIsIHNwYWNlciwgaW5kZW50YXRpb24pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpXG4gICAgfVxuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIHJldHVybiBzdHJFc2NhcGUodmFsdWUpXG4gICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2suaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIGNpcmN1bGFyVmFsdWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9yaWdpbmFsSW5kZW50YXRpb24gPSBpbmRlbnRhdGlvblxuICAgICAgICBsZXQgcmVzID0gJydcbiAgICAgICAgbGV0IGpvaW4gPSAnLCdcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIltBcnJheV1cIidcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgICBpZiAoc3BhY2VyICE9PSAnJykge1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gc3BhY2VyXG4gICAgICAgICAgICByZXMgKz0gYFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICAgICAgam9pbiA9IGAsXFxuJHtpbmRlbnRhdGlvbn1gXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG1heGltdW1WYWx1ZXNUb1N0cmluZ2lmeSA9IE1hdGgubWluKHZhbHVlLmxlbmd0aCwgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgICAgZm9yICg7IGkgPCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUFycmF5UmVwbGFjZXIoU3RyaW5nKGkpLCB2YWx1ZVtpXSwgc3RhY2ssIHJlcGxhY2VyLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgICAgcmVzICs9IHRtcCAhPT0gdW5kZWZpbmVkID8gdG1wIDogJ251bGwnXG4gICAgICAgICAgICByZXMgKz0gam9pblxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlBcnJheVJlcGxhY2VyKFN0cmluZyhpKSwgdmFsdWVbaV0sIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIC0gMSA+IG1heGltdW1CcmVhZHRoKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IHZhbHVlLmxlbmd0aCAtIG1heGltdW1CcmVhZHRoIC0gMVxuICAgICAgICAgICAgcmVzICs9IGAke2pvaW59XCIuLi4gJHtnZXRJdGVtQ291bnQocmVtb3ZlZEtleXMpfSBub3Qgc3RyaW5naWZpZWRcImBcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNwYWNlciAhPT0gJycpIHtcbiAgICAgICAgICAgIHJlcyArPSBgXFxuJHtvcmlnaW5hbEluZGVudGF0aW9ufWBcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sucG9wKClcbiAgICAgICAgICByZXR1cm4gYFske3Jlc31dYFxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgIGxldCB3aGl0ZXNwYWNlID0gJydcbiAgICAgICAgaWYgKHNwYWNlciAhPT0gJycpIHtcbiAgICAgICAgICBpbmRlbnRhdGlvbiArPSBzcGFjZXJcbiAgICAgICAgICBqb2luID0gYCxcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICB3aGl0ZXNwYWNlID0gJyAnXG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNlcGFyYXRvciA9ICcnXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHJlcGxhY2VyKSB7XG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5QXJyYXlSZXBsYWNlcihrZXksIHZhbHVlW2tleV0sIHN0YWNrLCByZXBsYWNlciwgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICBpZiAodG1wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlcyArPSBgJHtzZXBhcmF0b3J9JHtzdHJFc2NhcGUoa2V5KX06JHt3aGl0ZXNwYWNlfSR7dG1wfWBcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IGpvaW5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwYWNlciAhPT0gJycgJiYgc2VwYXJhdG9yLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXMgPSBgXFxuJHtpbmRlbnRhdGlvbn0ke3Jlc31cXG4ke29yaWdpbmFsSW5kZW50YXRpb259YFxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgIHJldHVybiBgeyR7cmVzfX1gXG4gICAgICB9XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6IGZhaWwgPyBmYWlsKHZhbHVlKSA6ICdudWxsJ1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSA/ICd0cnVlJyA6ICdmYWxzZSdcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICAgIGlmIChiaWdpbnQpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKVxuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFpbCA/IGZhaWwodmFsdWUpIDogdW5kZWZpbmVkXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5SW5kZW50IChrZXksIHZhbHVlLCBzdGFjaywgc3BhY2VyLCBpbmRlbnRhdGlvbikge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXR1cm4gc3RyRXNjYXBlKHZhbHVlKVxuICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJ251bGwnXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpXG4gICAgICAgICAgLy8gUHJldmVudCBjYWxsaW5nIGB0b0pTT05gIGFnYWluLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5SW5kZW50KGtleSwgdmFsdWUsIHN0YWNrLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBjaXJjdWxhclZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxJbmRlbnRhdGlvbiA9IGluZGVudGF0aW9uXG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdbXSdcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heGltdW1EZXB0aCA8IHN0YWNrLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCJbQXJyYXldXCInXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gc3BhY2VyXG4gICAgICAgICAgbGV0IHJlcyA9IGBcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICBjb25zdCBqb2luID0gYCxcXG4ke2luZGVudGF0aW9ufWBcbiAgICAgICAgICBjb25zdCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgPSBNYXRoLm1pbih2YWx1ZS5sZW5ndGgsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICAgIGxldCBpID0gMFxuICAgICAgICAgIGZvciAoOyBpIDwgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlJbmRlbnQoU3RyaW5nKGkpLCB2YWx1ZVtpXSwgc3RhY2ssIHNwYWNlciwgaW5kZW50YXRpb24pXG4gICAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICAgIHJlcyArPSBqb2luXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUluZGVudChTdHJpbmcoaSksIHZhbHVlW2ldLCBzdGFjaywgc3BhY2VyLCBpbmRlbnRhdGlvbilcbiAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoIC0gMSA+IG1heGltdW1CcmVhZHRoKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IHZhbHVlLmxlbmd0aCAtIG1heGltdW1CcmVhZHRoIC0gMVxuICAgICAgICAgICAgcmVzICs9IGAke2pvaW59XCIuLi4gJHtnZXRJdGVtQ291bnQocmVtb3ZlZEtleXMpfSBub3Qgc3RyaW5naWZpZWRcImBcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzICs9IGBcXG4ke29yaWdpbmFsSW5kZW50YXRpb259YFxuICAgICAgICAgIHN0YWNrLnBvcCgpXG4gICAgICAgICAgcmV0dXJuIGBbJHtyZXN9XWBcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpXG4gICAgICAgIGNvbnN0IGtleUxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAgIGlmIChrZXlMZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gJ3t9J1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhpbXVtRGVwdGggPCBzdGFjay5sZW5ndGggKyAxKSB7XG4gICAgICAgICAgcmV0dXJuICdcIltPYmplY3RdXCInXG4gICAgICAgIH1cbiAgICAgICAgaW5kZW50YXRpb24gKz0gc3BhY2VyXG4gICAgICAgIGNvbnN0IGpvaW4gPSBgLFxcbiR7aW5kZW50YXRpb259YFxuICAgICAgICBsZXQgcmVzID0gJydcbiAgICAgICAgbGV0IHNlcGFyYXRvciA9ICcnXG4gICAgICAgIGxldCBtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5ID0gTWF0aC5taW4oa2V5TGVuZ3RoLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgaWYgKGlzVHlwZWRBcnJheVdpdGhFbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlUeXBlZEFycmF5KHZhbHVlLCBqb2luLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgICBrZXlzID0ga2V5cy5zbGljZSh2YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeSAtPSB2YWx1ZS5sZW5ndGhcbiAgICAgICAgICBzZXBhcmF0b3IgPSBqb2luXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldGVybWluaXN0aWMpIHtcbiAgICAgICAgICBrZXlzID0gaW5zZXJ0U29ydChrZXlzKVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2godmFsdWUpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeTsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICAgIGNvbnN0IHRtcCA9IHN0cmluZ2lmeUluZGVudChrZXksIHZhbHVlW2tleV0sIHN0YWNrLCBzcGFjZXIsIGluZGVudGF0aW9uKVxuICAgICAgICAgIGlmICh0bXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn0ke3N0ckVzY2FwZShrZXkpfTogJHt0bXB9YFxuICAgICAgICAgICAgc2VwYXJhdG9yID0gam9pblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5TGVuZ3RoID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IGtleUxlbmd0aCAtIG1heGltdW1CcmVhZHRoXG4gICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn1cIi4uLlwiOiBcIiR7Z2V0SXRlbUNvdW50KHJlbW92ZWRLZXlzKX0gbm90IHN0cmluZ2lmaWVkXCJgXG4gICAgICAgICAgc2VwYXJhdG9yID0gam9pblxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3IgIT09ICcnKSB7XG4gICAgICAgICAgcmVzID0gYFxcbiR7aW5kZW50YXRpb259JHtyZXN9XFxuJHtvcmlnaW5hbEluZGVudGF0aW9ufWBcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICByZXR1cm4gYHske3Jlc319YFxuICAgICAgfVxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiBmYWlsID8gZmFpbCh2YWx1ZSkgOiAnbnVsbCdcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICBpZiAoYmlnaW50KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhaWwgPyBmYWlsKHZhbHVlKSA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeVNpbXBsZSAoa2V5LCB2YWx1ZSwgc3RhY2spIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIHN0ckVzY2FwZSh2YWx1ZSlcbiAgICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICdudWxsJ1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KVxuICAgICAgICAgIC8vIFByZXZlbnQgY2FsbGluZyBgdG9KU09OYCBhZ2FpblxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5U2ltcGxlKGtleSwgdmFsdWUsIHN0YWNrKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnbnVsbCdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiBjaXJjdWxhclZhbHVlXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVzID0gJydcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1tdJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIltBcnJheV1cIidcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgICBjb25zdCBtYXhpbXVtVmFsdWVzVG9TdHJpbmdpZnkgPSBNYXRoLm1pbih2YWx1ZS5sZW5ndGgsIG1heGltdW1CcmVhZHRoKVxuICAgICAgICAgIGxldCBpID0gMFxuICAgICAgICAgIGZvciAoOyBpIDwgbWF4aW11bVZhbHVlc1RvU3RyaW5naWZ5IC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0bXAgPSBzdHJpbmdpZnlTaW1wbGUoU3RyaW5nKGkpLCB2YWx1ZVtpXSwgc3RhY2spXG4gICAgICAgICAgICByZXMgKz0gdG1wICE9PSB1bmRlZmluZWQgPyB0bXAgOiAnbnVsbCdcbiAgICAgICAgICAgIHJlcyArPSAnLCdcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5U2ltcGxlKFN0cmluZyhpKSwgdmFsdWVbaV0sIHN0YWNrKVxuICAgICAgICAgIHJlcyArPSB0bXAgIT09IHVuZGVmaW5lZCA/IHRtcCA6ICdudWxsJ1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggLSAxID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRLZXlzID0gdmFsdWUubGVuZ3RoIC0gbWF4aW11bUJyZWFkdGggLSAxXG4gICAgICAgICAgICByZXMgKz0gYCxcIi4uLiAke2dldEl0ZW1Db3VudChyZW1vdmVkS2V5cyl9IG5vdCBzdHJpbmdpZmllZFwiYFxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICAgIHJldHVybiBgWyR7cmVzfV1gXG4gICAgICAgIH1cblxuICAgICAgICBsZXQga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKVxuICAgICAgICBjb25zdCBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgICBpZiAoa2V5TGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuICd7fSdcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4aW11bURlcHRoIDwgc3RhY2subGVuZ3RoICsgMSkge1xuICAgICAgICAgIHJldHVybiAnXCJbT2JqZWN0XVwiJ1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZXBhcmF0b3IgPSAnJ1xuICAgICAgICBsZXQgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeSA9IE1hdGgubWluKGtleUxlbmd0aCwgbWF4aW11bUJyZWFkdGgpXG4gICAgICAgIGlmIChpc1R5cGVkQXJyYXlXaXRoRW50cmllcyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5VHlwZWRBcnJheSh2YWx1ZSwgJywnLCBtYXhpbXVtQnJlYWR0aClcbiAgICAgICAgICBrZXlzID0ga2V5cy5zbGljZSh2YWx1ZS5sZW5ndGgpXG4gICAgICAgICAgbWF4aW11bVByb3BlcnRpZXNUb1N0cmluZ2lmeSAtPSB2YWx1ZS5sZW5ndGhcbiAgICAgICAgICBzZXBhcmF0b3IgPSAnLCdcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0ZXJtaW5pc3RpYykge1xuICAgICAgICAgIGtleXMgPSBpbnNlcnRTb3J0KGtleXMpXG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhpbXVtUHJvcGVydGllc1RvU3RyaW5naWZ5OyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgICAgY29uc3QgdG1wID0gc3RyaW5naWZ5U2ltcGxlKGtleSwgdmFsdWVba2V5XSwgc3RhY2spXG4gICAgICAgICAgaWYgKHRtcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXMgKz0gYCR7c2VwYXJhdG9yfSR7c3RyRXNjYXBlKGtleSl9OiR7dG1wfWBcbiAgICAgICAgICAgIHNlcGFyYXRvciA9ICcsJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5TGVuZ3RoID4gbWF4aW11bUJyZWFkdGgpIHtcbiAgICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IGtleUxlbmd0aCAtIG1heGltdW1CcmVhZHRoXG4gICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn1cIi4uLlwiOlwiJHtnZXRJdGVtQ291bnQocmVtb3ZlZEtleXMpfSBub3Qgc3RyaW5naWZpZWRcImBcbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wb3AoKVxuICAgICAgICByZXR1cm4gYHske3Jlc319YFxuICAgICAgfVxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiBmYWlsID8gZmFpbCh2YWx1ZSkgOiAnbnVsbCdcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnXG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgICBpZiAoYmlnaW50KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhaWwgPyBmYWlsKHZhbHVlKSA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0cmluZ2lmeSAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgbGV0IHNwYWNlciA9ICcnXG4gICAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICBzcGFjZXIgPSAnICcucmVwZWF0KE1hdGgubWluKHNwYWNlLCAxMCkpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc3BhY2VyID0gc3BhY2Uuc2xpY2UoMCwgMTApXG4gICAgICB9XG4gICAgICBpZiAocmVwbGFjZXIgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUZuUmVwbGFjZXIoJycsIHsgJyc6IHZhbHVlIH0sIFtdLCByZXBsYWNlciwgc3BhY2VyLCAnJylcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5QXJyYXlSZXBsYWNlcignJywgdmFsdWUsIFtdLCBnZXRVbmlxdWVSZXBsYWNlclNldChyZXBsYWNlciksIHNwYWNlciwgJycpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzcGFjZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlJbmRlbnQoJycsIHZhbHVlLCBbXSwgc3BhY2VyLCAnJylcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ2lmeVNpbXBsZSgnJywgdmFsdWUsIFtdKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeVxufVxuIiwidmFyIHBia2RmMlN5bmMgPSByZXF1aXJlKCdwYmtkZjInKS5wYmtkZjJTeW5jXG5cbnZhciBNQVhfVkFMVUUgPSAweDdmZmZmZmZmXG5cbi8vIE4gPSBDcHUgY29zdCwgciA9IE1lbW9yeSBjb3N0LCBwID0gcGFyYWxsZWxpemF0aW9uIGNvc3RcbmZ1bmN0aW9uIHNjcnlwdCAoa2V5LCBzYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICBpZiAoTiA9PT0gMCB8fCAoTiAmIChOIC0gMSkpICE9PSAwKSB0aHJvdyBFcnJvcignTiBtdXN0IGJlID4gMCBhbmQgYSBwb3dlciBvZiAyJylcblxuICBpZiAoTiA+IE1BWF9WQUxVRSAvIDEyOCAvIHIpIHRocm93IEVycm9yKCdQYXJhbWV0ZXIgTiBpcyB0b28gbGFyZ2UnKVxuICBpZiAociA+IE1BWF9WQUxVRSAvIDEyOCAvIHApIHRocm93IEVycm9yKCdQYXJhbWV0ZXIgciBpcyB0b28gbGFyZ2UnKVxuXG4gIHZhciBYWSA9IG5ldyBCdWZmZXIoMjU2ICogcilcbiAgdmFyIFYgPSBuZXcgQnVmZmVyKDEyOCAqIHIgKiBOKVxuXG4gIC8vIHBzZXVkbyBnbG9iYWxcbiAgdmFyIEIzMiA9IG5ldyBJbnQzMkFycmF5KDE2KSAvLyBzYWxzYTIwXzhcbiAgdmFyIHggPSBuZXcgSW50MzJBcnJheSgxNikgLy8gc2Fsc2EyMF84XG4gIHZhciBfWCA9IG5ldyBCdWZmZXIoNjQpIC8vIGJsb2NrbWl4X3NhbHNhOFxuXG4gIC8vIHBzZXVkbyBnbG9iYWxcbiAgdmFyIEIgPSBwYmtkZjJTeW5jKGtleSwgc2FsdCwgMSwgcCAqIDEyOCAqIHIsICdzaGEyNTYnKVxuXG4gIHZhciB0aWNrQ2FsbGJhY2tcbiAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB2YXIgdG90YWxPcHMgPSBwICogTiAqIDJcbiAgICB2YXIgY3VycmVudE9wID0gMFxuXG4gICAgdGlja0NhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgKytjdXJyZW50T3BcblxuICAgICAgLy8gc2VuZCBwcm9ncmVzcyBub3RpZmljYXRpb25zIG9uY2UgZXZlcnkgMSwwMDAgb3BzXG4gICAgICBpZiAoY3VycmVudE9wICUgMTAwMCA9PT0gMCkge1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHtcbiAgICAgICAgICBjdXJyZW50OiBjdXJyZW50T3AsXG4gICAgICAgICAgdG90YWw6IHRvdGFsT3BzLFxuICAgICAgICAgIHBlcmNlbnQ6IChjdXJyZW50T3AgLyB0b3RhbE9wcykgKiAxMDAuMFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcDsgaSsrKSB7XG4gICAgc21peChCLCBpICogMTI4ICogciwgciwgTiwgViwgWFkpXG4gIH1cblxuICByZXR1cm4gcGJrZGYyU3luYyhrZXksIEIsIDEsIGRrTGVuLCAnc2hhMjU2JylcblxuICAvLyBhbGwgb2YgdGhlc2UgZnVuY3Rpb25zIGFyZSBhY3R1YWxseSBtb3ZlZCB0byB0aGUgdG9wXG4gIC8vIGR1ZSB0byBmdW5jdGlvbiBob2lzdGluZ1xuXG4gIGZ1bmN0aW9uIHNtaXggKEIsIEJpLCByLCBOLCBWLCBYWSkge1xuICAgIHZhciBYaSA9IDBcbiAgICB2YXIgWWkgPSAxMjggKiByXG4gICAgdmFyIGlcblxuICAgIEIuY29weShYWSwgWGksIEJpLCBCaSArIFlpKVxuXG4gICAgZm9yIChpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgWFkuY29weShWLCBpICogWWksIFhpLCBYaSArIFlpKVxuICAgICAgYmxvY2ttaXhfc2Fsc2E4KFhZLCBYaSwgWWksIHIpXG5cbiAgICAgIGlmICh0aWNrQ2FsbGJhY2spIHRpY2tDYWxsYmFjaygpXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIG9mZnNldCA9IFhpICsgKDIgKiByIC0gMSkgKiA2NFxuICAgICAgdmFyIGogPSBYWS5yZWFkVUludDMyTEUob2Zmc2V0KSAmIChOIC0gMSlcbiAgICAgIGJsb2NreG9yKFYsIGogKiBZaSwgWFksIFhpLCBZaSlcbiAgICAgIGJsb2NrbWl4X3NhbHNhOChYWSwgWGksIFlpLCByKVxuXG4gICAgICBpZiAodGlja0NhbGxiYWNrKSB0aWNrQ2FsbGJhY2soKVxuICAgIH1cblxuICAgIFhZLmNvcHkoQiwgQmksIFhpLCBYaSArIFlpKVxuICB9XG5cbiAgZnVuY3Rpb24gYmxvY2ttaXhfc2Fsc2E4IChCWSwgQmksIFlpLCByKSB7XG4gICAgdmFyIGlcblxuICAgIGFycmF5Y29weShCWSwgQmkgKyAoMiAqIHIgLSAxKSAqIDY0LCBfWCwgMCwgNjQpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMiAqIHI7IGkrKykge1xuICAgICAgYmxvY2t4b3IoQlksIGkgKiA2NCwgX1gsIDAsIDY0KVxuICAgICAgc2Fsc2EyMF84KF9YKVxuICAgICAgYXJyYXljb3B5KF9YLCAwLCBCWSwgWWkgKyAoaSAqIDY0KSwgNjQpXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHI7IGkrKykge1xuICAgICAgYXJyYXljb3B5KEJZLCBZaSArIChpICogMikgKiA2NCwgQlksIEJpICsgKGkgKiA2NCksIDY0KVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCByOyBpKyspIHtcbiAgICAgIGFycmF5Y29weShCWSwgWWkgKyAoaSAqIDIgKyAxKSAqIDY0LCBCWSwgQmkgKyAoaSArIHIpICogNjQsIDY0KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIFIgKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpXG4gIH1cblxuICBmdW5jdGlvbiBzYWxzYTIwXzggKEIpIHtcbiAgICB2YXIgaVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIEIzMltpXSA9IChCW2kgKiA0ICsgMF0gJiAweGZmKSA8PCAwXG4gICAgICBCMzJbaV0gfD0gKEJbaSAqIDQgKyAxXSAmIDB4ZmYpIDw8IDhcbiAgICAgIEIzMltpXSB8PSAoQltpICogNCArIDJdICYgMHhmZikgPDwgMTZcbiAgICAgIEIzMltpXSB8PSAoQltpICogNCArIDNdICYgMHhmZikgPDwgMjRcbiAgICAgIC8vIEIzMltpXSA9IEIucmVhZFVJbnQzMkxFKGkqNCkgICA8LS0tIHRoaXMgaXMgc2lnbmZpY2FudGx5IHNsb3dlciBldmVuIGluIE5vZGUuanNcbiAgICB9XG5cbiAgICBhcnJheWNvcHkoQjMyLCAwLCB4LCAwLCAxNilcblxuICAgIGZvciAoaSA9IDg7IGkgPiAwOyBpIC09IDIpIHtcbiAgICAgIHhbIDRdIF49IFIoeFsgMF0gKyB4WzEyXSwgNylcbiAgICAgIHhbIDhdIF49IFIoeFsgNF0gKyB4WyAwXSwgOSlcbiAgICAgIHhbMTJdIF49IFIoeFsgOF0gKyB4WyA0XSwgMTMpXG4gICAgICB4WyAwXSBePSBSKHhbMTJdICsgeFsgOF0sIDE4KVxuICAgICAgeFsgOV0gXj0gUih4WyA1XSArIHhbIDFdLCA3KVxuICAgICAgeFsxM10gXj0gUih4WyA5XSArIHhbIDVdLCA5KVxuICAgICAgeFsgMV0gXj0gUih4WzEzXSArIHhbIDldLCAxMylcbiAgICAgIHhbIDVdIF49IFIoeFsgMV0gKyB4WzEzXSwgMTgpXG4gICAgICB4WzE0XSBePSBSKHhbMTBdICsgeFsgNl0sIDcpXG4gICAgICB4WyAyXSBePSBSKHhbMTRdICsgeFsxMF0sIDkpXG4gICAgICB4WyA2XSBePSBSKHhbIDJdICsgeFsxNF0sIDEzKVxuICAgICAgeFsxMF0gXj0gUih4WyA2XSArIHhbIDJdLCAxOClcbiAgICAgIHhbIDNdIF49IFIoeFsxNV0gKyB4WzExXSwgNylcbiAgICAgIHhbIDddIF49IFIoeFsgM10gKyB4WzE1XSwgOSlcbiAgICAgIHhbMTFdIF49IFIoeFsgN10gKyB4WyAzXSwgMTMpXG4gICAgICB4WzE1XSBePSBSKHhbMTFdICsgeFsgN10sIDE4KVxuICAgICAgeFsgMV0gXj0gUih4WyAwXSArIHhbIDNdLCA3KVxuICAgICAgeFsgMl0gXj0gUih4WyAxXSArIHhbIDBdLCA5KVxuICAgICAgeFsgM10gXj0gUih4WyAyXSArIHhbIDFdLCAxMylcbiAgICAgIHhbIDBdIF49IFIoeFsgM10gKyB4WyAyXSwgMTgpXG4gICAgICB4WyA2XSBePSBSKHhbIDVdICsgeFsgNF0sIDcpXG4gICAgICB4WyA3XSBePSBSKHhbIDZdICsgeFsgNV0sIDkpXG4gICAgICB4WyA0XSBePSBSKHhbIDddICsgeFsgNl0sIDEzKVxuICAgICAgeFsgNV0gXj0gUih4WyA0XSArIHhbIDddLCAxOClcbiAgICAgIHhbMTFdIF49IFIoeFsxMF0gKyB4WyA5XSwgNylcbiAgICAgIHhbIDhdIF49IFIoeFsxMV0gKyB4WzEwXSwgOSlcbiAgICAgIHhbIDldIF49IFIoeFsgOF0gKyB4WzExXSwgMTMpXG4gICAgICB4WzEwXSBePSBSKHhbIDldICsgeFsgOF0sIDE4KVxuICAgICAgeFsxMl0gXj0gUih4WzE1XSArIHhbMTRdLCA3KVxuICAgICAgeFsxM10gXj0gUih4WzEyXSArIHhbMTVdLCA5KVxuICAgICAgeFsxNF0gXj0gUih4WzEzXSArIHhbMTJdLCAxMylcbiAgICAgIHhbMTVdIF49IFIoeFsxNF0gKyB4WzEzXSwgMTgpXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIEIzMltpXSA9IHhbaV0gKyBCMzJbaV1cblxuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB2YXIgYmkgPSBpICogNFxuICAgICAgQltiaSArIDBdID0gKEIzMltpXSA+PiAwICYgMHhmZilcbiAgICAgIEJbYmkgKyAxXSA9IChCMzJbaV0gPj4gOCAmIDB4ZmYpXG4gICAgICBCW2JpICsgMl0gPSAoQjMyW2ldID4+IDE2ICYgMHhmZilcbiAgICAgIEJbYmkgKyAzXSA9IChCMzJbaV0gPj4gMjQgJiAweGZmKVxuICAgICAgLy8gQi53cml0ZUludDMyTEUoQjMyW2ldLCBpKjQpICAvLzwtLS0gdGhpcyBpcyBzaWduZmljYW50bHkgc2xvd2VyIGV2ZW4gaW4gTm9kZS5qc1xuICAgIH1cbiAgfVxuXG4gIC8vIG5haXZlIGFwcHJvYWNoLi4uIGdvaW5nIGJhY2sgdG8gbG9vcCB1bnJvbGxpbmcgbWF5IHlpZWxkIGFkZGl0aW9uYWwgcGVyZm9ybWFuY2VcbiAgZnVuY3Rpb24gYmxvY2t4b3IgKFMsIFNpLCBELCBEaSwgbGVuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgRFtEaSArIGldIF49IFNbU2kgKyBpXVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcnJheWNvcHkgKHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zLCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzcmMpICYmIEJ1ZmZlci5pc0J1ZmZlcihkZXN0KSkge1xuICAgIHNyYy5jb3B5KGRlc3QsIGRlc3RQb3MsIHNyY1Bvcywgc3JjUG9zICsgbGVuZ3RoKVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNjcnlwdFxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbi8vIHRocm91Z2hcbi8vXG4vLyBhIHN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyBidXQgcmUtZW1pdCB0aGUgaW5wdXQuXG4vLyB1c2VmdWwgZm9yIGFnZ3JlZ2F0aW5nIGEgc2VyaWVzIG9mIGNoYW5naW5nIGJ1dCBub3QgZW5kaW5nIHN0cmVhbXMgaW50byBvbmUgc3RyZWFtKVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoXG50aHJvdWdoLnRocm91Z2ggPSB0aHJvdWdoXG5cbi8vY3JlYXRlIGEgcmVhZGFibGUgd3JpdGFibGUgc3RyZWFtLlxuXG5mdW5jdGlvbiB0aHJvdWdoICh3cml0ZSwgZW5kLCBvcHRzKSB7XG4gIHdyaXRlID0gd3JpdGUgfHwgZnVuY3Rpb24gKGRhdGEpIHsgdGhpcy5xdWV1ZShkYXRhKSB9XG4gIGVuZCA9IGVuZCB8fCBmdW5jdGlvbiAoKSB7IHRoaXMucXVldWUobnVsbCkgfVxuXG4gIHZhciBlbmRlZCA9IGZhbHNlLCBkZXN0cm95ZWQgPSBmYWxzZSwgYnVmZmVyID0gW10sIF9lbmRlZCA9IGZhbHNlXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKClcbiAgc3RyZWFtLnJlYWRhYmxlID0gc3RyZWFtLndyaXRhYmxlID0gdHJ1ZVxuICBzdHJlYW0ucGF1c2VkID0gZmFsc2VcblxuLy8gIHN0cmVhbS5hdXRvUGF1c2UgICA9ICEob3B0cyAmJiBvcHRzLmF1dG9QYXVzZSAgID09PSBmYWxzZSlcbiAgc3RyZWFtLmF1dG9EZXN0cm95ID0gIShvcHRzICYmIG9wdHMuYXV0b0Rlc3Ryb3kgPT09IGZhbHNlKVxuXG4gIHN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgd3JpdGUuY2FsbCh0aGlzLCBkYXRhKVxuICAgIHJldHVybiAhc3RyZWFtLnBhdXNlZFxuICB9XG5cbiAgZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgd2hpbGUoYnVmZmVyLmxlbmd0aCAmJiAhc3RyZWFtLnBhdXNlZCkge1xuICAgICAgdmFyIGRhdGEgPSBidWZmZXIuc2hpZnQoKVxuICAgICAgaWYobnVsbCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlbmQnKVxuICAgICAgZWxzZVxuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLnF1ZXVlID0gc3RyZWFtLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuLy8gICAgY29uc29sZS5lcnJvcihlbmRlZClcbiAgICBpZihfZW5kZWQpIHJldHVybiBzdHJlYW1cbiAgICBpZihkYXRhID09PSBudWxsKSBfZW5kZWQgPSB0cnVlXG4gICAgYnVmZmVyLnB1c2goZGF0YSlcbiAgICBkcmFpbigpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgLy90aGlzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0aGUgZmlyc3QgJ2VuZCcgbGlzdGVuZXJcbiAgLy9tdXN0IGNhbGwgZGVzdHJveSBuZXh0IHRpY2ssIHRvIG1ha2Ugc3VyZSB3ZSdyZSBhZnRlciBhbnlcbiAgLy9zdHJlYW0gcGlwZWQgZnJvbSBoZXJlLlxuICAvL3RoaXMgaXMgb25seSBhIHByb2JsZW0gaWYgZW5kIGlzIG5vdCBlbWl0dGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vYSBuaWNlciB3YXkgdG8gZG8gdGhpcyBpcyB0byBtYWtlIHN1cmUgdGhpcyBpcyB0aGUgbGFzdCBsaXN0ZW5lciBmb3IgJ2VuZCdcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmKCFzdHJlYW0ud3JpdGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gX2VuZCAoKSB7XG4gICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2VcbiAgICBlbmQuY2FsbChzdHJlYW0pXG4gICAgaWYoIXN0cmVhbS5yZWFkYWJsZSAmJiBzdHJlYW0uYXV0b0Rlc3Ryb3kpXG4gICAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBzdHJlYW0uZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihlbmRlZCkgcmV0dXJuXG4gICAgZW5kZWQgPSB0cnVlXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgX2VuZCgpIC8vIHdpbGwgZW1pdCBvciBxdWV1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgc3RyZWFtLndyaXRhYmxlID0gc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihzdHJlYW0ucGF1c2VkKSByZXR1cm5cbiAgICBzdHJlYW0ucGF1c2VkID0gdHJ1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkge1xuICAgICAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG4gICAgICBzdHJlYW0uZW1pdCgncmVzdW1lJylcbiAgICB9XG4gICAgZHJhaW4oKVxuICAgIC8vbWF5IGhhdmUgYmVjb21lIHBhdXNlZCBhZ2FpbixcbiAgICAvL2FzIGRyYWluIGVtaXRzICdkYXRhJy5cbiAgICBpZighc3RyZWFtLnBhdXNlZClcbiAgICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cblxuIiwiY29uc3QgQk4gPSByZXF1aXJlKCdibi5qcycpXG5jb25zdCBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcbmNvbnN0IHNlY3AyNTZrMSA9IG5ldyBFQygnc2VjcDI1NmsxJylcbmNvbnN0IGRldGVybWluaXN0aWNHZW5lcmF0ZUsgPSByZXF1aXJlKCcuL3JmYzY5NzknKVxuXG5jb25zdCBaRVJPMzIgPSBCdWZmZXIuYWxsb2MoMzIsIDApXG5jb25zdCBFQ19HUk9VUF9PUkRFUiA9IEJ1ZmZlci5mcm9tKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgJ2hleCcpXG5jb25zdCBFQ19QID0gQnVmZmVyLmZyb20oJ2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnLCAnaGV4JylcblxuY29uc3QgbiA9IHNlY3AyNTZrMS5jdXJ2ZS5uXG5jb25zdCBuRGl2MiA9IG4uc2hybigxKVxuY29uc3QgRyA9IHNlY3AyNTZrMS5jdXJ2ZS5nXG5cbmNvbnN0IFRIUk9XX0JBRF9QUklWQVRFID0gJ0V4cGVjdGVkIFByaXZhdGUnXG5jb25zdCBUSFJPV19CQURfUE9JTlQgPSAnRXhwZWN0ZWQgUG9pbnQnXG5jb25zdCBUSFJPV19CQURfVFdFQUsgPSAnRXhwZWN0ZWQgVHdlYWsnXG5jb25zdCBUSFJPV19CQURfSEFTSCA9ICdFeHBlY3RlZCBIYXNoJ1xuY29uc3QgVEhST1dfQkFEX1NJR05BVFVSRSA9ICdFeHBlY3RlZCBTaWduYXR1cmUnXG5jb25zdCBUSFJPV19CQURfRVhUUkFfREFUQSA9ICdFeHBlY3RlZCBFeHRyYSBEYXRhICgzMiBieXRlcyknXG5cbmZ1bmN0aW9uIGlzU2NhbGFyICh4KSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoeCkgJiYgeC5sZW5ndGggPT09IDMyXG59XG5cbmZ1bmN0aW9uIGlzT3JkZXJTY2FsYXIgKHgpIHtcbiAgaWYgKCFpc1NjYWxhcih4KSkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiB4LmNvbXBhcmUoRUNfR1JPVVBfT1JERVIpIDwgMCAvLyA8IEdcbn1cblxuZnVuY3Rpb24gaXNQb2ludCAocCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwKSkgcmV0dXJuIGZhbHNlXG4gIGlmIChwLmxlbmd0aCA8IDMzKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCB0ID0gcFswXVxuICBjb25zdCB4ID0gcC5zbGljZSgxLCAzMylcbiAgaWYgKHguY29tcGFyZShaRVJPMzIpID09PSAwKSByZXR1cm4gZmFsc2VcbiAgaWYgKHguY29tcGFyZShFQ19QKSA+PSAwKSByZXR1cm4gZmFsc2VcbiAgaWYgKCh0ID09PSAweDAyIHx8IHQgPT09IDB4MDMpICYmIHAubGVuZ3RoID09PSAzMykge1xuICAgIHRyeSB7IGRlY29kZUZyb20ocCkgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2UgfSAvLyBUT0RPOiB0ZW1wb3JhcnlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgeSA9IHAuc2xpY2UoMzMpXG4gIGlmICh5LmNvbXBhcmUoWkVSTzMyKSA9PT0gMCkgcmV0dXJuIGZhbHNlXG4gIGlmICh5LmNvbXBhcmUoRUNfUCkgPj0gMCkgcmV0dXJuIGZhbHNlXG4gIGlmICh0ID09PSAweDA0ICYmIHAubGVuZ3RoID09PSA2NSkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIF9faXNQb2ludENvbXByZXNzZWQgKHApIHtcbiAgcmV0dXJuIHBbMF0gIT09IDB4MDRcbn1cblxuZnVuY3Rpb24gaXNQb2ludENvbXByZXNzZWQgKHApIHtcbiAgaWYgKCFpc1BvaW50KHApKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIF9faXNQb2ludENvbXByZXNzZWQocClcbn1cblxuZnVuY3Rpb24gaXNQcml2YXRlICh4KSB7XG4gIGlmICghaXNTY2FsYXIoeCkpIHJldHVybiBmYWxzZVxuICByZXR1cm4geC5jb21wYXJlKFpFUk8zMikgPiAwICYmIC8vID4gMFxuICAgIHguY29tcGFyZShFQ19HUk9VUF9PUkRFUikgPCAwIC8vIDwgR1xufVxuXG5mdW5jdGlvbiBpc1NpZ25hdHVyZSAodmFsdWUpIHtcbiAgY29uc3QgciA9IHZhbHVlLnNsaWNlKDAsIDMyKVxuICBjb25zdCBzID0gdmFsdWUuc2xpY2UoMzIsIDY0KVxuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDY0ICYmXG4gICAgci5jb21wYXJlKEVDX0dST1VQX09SREVSKSA8IDAgJiZcbiAgICBzLmNvbXBhcmUoRUNfR1JPVVBfT1JERVIpIDwgMFxufVxuXG5mdW5jdGlvbiBhc3N1bWVDb21wcmVzc2lvbiAodmFsdWUsIHB1YmtleSkge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBwdWJrZXkgIT09IHVuZGVmaW5lZCkgcmV0dXJuIF9faXNQb2ludENvbXByZXNzZWQocHVia2V5KVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIHZhbHVlXG59XG5cbmZ1bmN0aW9uIGZyb21CdWZmZXIgKGQpIHsgcmV0dXJuIG5ldyBCTihkKSB9XG5mdW5jdGlvbiB0b0J1ZmZlciAoZCkgeyByZXR1cm4gZC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKSB9XG5mdW5jdGlvbiBkZWNvZGVGcm9tIChQKSB7IHJldHVybiBzZWNwMjU2azEuY3VydmUuZGVjb2RlUG9pbnQoUCkgfVxuZnVuY3Rpb24gZ2V0RW5jb2RlZCAoUCwgY29tcHJlc3NlZCkgeyByZXR1cm4gQnVmZmVyLmZyb20oUC5fZW5jb2RlKGNvbXByZXNzZWQpKSB9XG5cbmZ1bmN0aW9uIHBvaW50QWRkIChwQSwgcEIsIF9fY29tcHJlc3NlZCkge1xuICBpZiAoIWlzUG9pbnQocEEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9QT0lOVClcbiAgaWYgKCFpc1BvaW50KHBCKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUE9JTlQpXG5cbiAgY29uc3QgYSA9IGRlY29kZUZyb20ocEEpXG4gIGNvbnN0IGIgPSBkZWNvZGVGcm9tKHBCKVxuICBjb25zdCBwcCA9IGEuYWRkKGIpXG4gIGlmIChwcC5pc0luZmluaXR5KCkpIHJldHVybiBudWxsXG5cbiAgY29uc3QgY29tcHJlc3NlZCA9IGFzc3VtZUNvbXByZXNzaW9uKF9fY29tcHJlc3NlZCwgcEEpXG4gIHJldHVybiBnZXRFbmNvZGVkKHBwLCBjb21wcmVzc2VkKVxufVxuXG5mdW5jdGlvbiBwb2ludEFkZFNjYWxhciAocCwgdHdlYWssIF9fY29tcHJlc3NlZCkge1xuICBpZiAoIWlzUG9pbnQocCkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BPSU5UKVxuICBpZiAoIWlzT3JkZXJTY2FsYXIodHdlYWspKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9UV0VBSylcblxuICBjb25zdCBjb21wcmVzc2VkID0gYXNzdW1lQ29tcHJlc3Npb24oX19jb21wcmVzc2VkLCBwKVxuICBjb25zdCBwcCA9IGRlY29kZUZyb20ocClcbiAgaWYgKHR3ZWFrLmNvbXBhcmUoWkVSTzMyKSA9PT0gMCkgcmV0dXJuIGdldEVuY29kZWQocHAsIGNvbXByZXNzZWQpXG5cbiAgY29uc3QgdHQgPSBmcm9tQnVmZmVyKHR3ZWFrKVxuICBjb25zdCBxcSA9IEcubXVsKHR0KVxuICBjb25zdCB1dSA9IHBwLmFkZChxcSlcbiAgaWYgKHV1LmlzSW5maW5pdHkoKSkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZ2V0RW5jb2RlZCh1dSwgY29tcHJlc3NlZClcbn1cblxuZnVuY3Rpb24gcG9pbnRDb21wcmVzcyAocCwgX19jb21wcmVzc2VkKSB7XG4gIGlmICghaXNQb2ludChwKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUE9JTlQpXG5cbiAgY29uc3QgcHAgPSBkZWNvZGVGcm9tKHApXG4gIGlmIChwcC5pc0luZmluaXR5KCkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BPSU5UKVxuXG4gIGNvbnN0IGNvbXByZXNzZWQgPSBhc3N1bWVDb21wcmVzc2lvbihfX2NvbXByZXNzZWQsIHApXG5cbiAgcmV0dXJuIGdldEVuY29kZWQocHAsIGNvbXByZXNzZWQpXG59XG5cbmZ1bmN0aW9uIHBvaW50RnJvbVNjYWxhciAoZCwgX19jb21wcmVzc2VkKSB7XG4gIGlmICghaXNQcml2YXRlKGQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9QUklWQVRFKVxuXG4gIGNvbnN0IGRkID0gZnJvbUJ1ZmZlcihkKVxuICBjb25zdCBwcCA9IEcubXVsKGRkKVxuICBpZiAocHAuaXNJbmZpbml0eSgpKSByZXR1cm4gbnVsbFxuXG4gIGNvbnN0IGNvbXByZXNzZWQgPSBhc3N1bWVDb21wcmVzc2lvbihfX2NvbXByZXNzZWQpXG4gIHJldHVybiBnZXRFbmNvZGVkKHBwLCBjb21wcmVzc2VkKVxufVxuXG5mdW5jdGlvbiBwb2ludE11bHRpcGx5IChwLCB0d2VhaywgX19jb21wcmVzc2VkKSB7XG4gIGlmICghaXNQb2ludChwKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUE9JTlQpXG4gIGlmICghaXNPcmRlclNjYWxhcih0d2VhaykpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1RXRUFLKVxuXG4gIGNvbnN0IGNvbXByZXNzZWQgPSBhc3N1bWVDb21wcmVzc2lvbihfX2NvbXByZXNzZWQsIHApXG4gIGNvbnN0IHBwID0gZGVjb2RlRnJvbShwKVxuICBjb25zdCB0dCA9IGZyb21CdWZmZXIodHdlYWspXG4gIGNvbnN0IHFxID0gcHAubXVsKHR0KVxuICBpZiAocXEuaXNJbmZpbml0eSgpKSByZXR1cm4gbnVsbFxuXG4gIHJldHVybiBnZXRFbmNvZGVkKHFxLCBjb21wcmVzc2VkKVxufVxuXG5mdW5jdGlvbiBwcml2YXRlQWRkIChkLCB0d2Vhaykge1xuICBpZiAoIWlzUHJpdmF0ZShkKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfUFJJVkFURSlcbiAgaWYgKCFpc09yZGVyU2NhbGFyKHR3ZWFrKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfVFdFQUspXG5cbiAgY29uc3QgZGQgPSBmcm9tQnVmZmVyKGQpXG4gIGNvbnN0IHR0ID0gZnJvbUJ1ZmZlcih0d2VhaylcbiAgY29uc3QgZHQgPSB0b0J1ZmZlcihkZC5hZGQodHQpLnVtb2QobikpXG4gIGlmICghaXNQcml2YXRlKGR0KSkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZHRcbn1cblxuZnVuY3Rpb24gcHJpdmF0ZVN1YiAoZCwgdHdlYWspIHtcbiAgaWYgKCFpc1ByaXZhdGUoZCkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BSSVZBVEUpXG4gIGlmICghaXNPcmRlclNjYWxhcih0d2VhaykpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1RXRUFLKVxuXG4gIGNvbnN0IGRkID0gZnJvbUJ1ZmZlcihkKVxuICBjb25zdCB0dCA9IGZyb21CdWZmZXIodHdlYWspXG4gIGNvbnN0IGR0ID0gdG9CdWZmZXIoZGQuc3ViKHR0KS51bW9kKG4pKVxuICBpZiAoIWlzUHJpdmF0ZShkdCkpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGR0XG59XG5cbmZ1bmN0aW9uIHNpZ24gKGhhc2gsIHgpIHtcbiAgcmV0dXJuIF9fc2lnbihoYXNoLCB4KVxufVxuXG5mdW5jdGlvbiBzaWduV2l0aEVudHJvcHkgKGhhc2gsIHgsIGFkZERhdGEpIHtcbiAgcmV0dXJuIF9fc2lnbihoYXNoLCB4LCBhZGREYXRhKVxufVxuXG5mdW5jdGlvbiBfX3NpZ24gKGhhc2gsIHgsIGFkZERhdGEpIHtcbiAgaWYgKCFpc1NjYWxhcihoYXNoKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfSEFTSClcbiAgaWYgKCFpc1ByaXZhdGUoeCkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BSSVZBVEUpXG4gIGlmIChhZGREYXRhICE9PSB1bmRlZmluZWQgJiYgIWlzU2NhbGFyKGFkZERhdGEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9FWFRSQV9EQVRBKVxuXG4gIGNvbnN0IGQgPSBmcm9tQnVmZmVyKHgpXG4gIGNvbnN0IGUgPSBmcm9tQnVmZmVyKGhhc2gpXG5cbiAgbGV0IHIsIHNcbiAgY29uc3QgY2hlY2tTaWcgPSBmdW5jdGlvbiAoaykge1xuICAgIGNvbnN0IGtJID0gZnJvbUJ1ZmZlcihrKVxuICAgIGNvbnN0IFEgPSBHLm11bChrSSlcblxuICAgIGlmIChRLmlzSW5maW5pdHkoKSkgcmV0dXJuIGZhbHNlXG5cbiAgICByID0gUS54LnVtb2QobilcbiAgICBpZiAoci5pc1plcm8oKSA9PT0gMCkgcmV0dXJuIGZhbHNlXG5cbiAgICBzID0ga0lcbiAgICAgIC5pbnZtKG4pXG4gICAgICAubXVsKGUuYWRkKGQubXVsKHIpKSlcbiAgICAgIC51bW9kKG4pXG4gICAgaWYgKHMuaXNaZXJvKCkgPT09IDApIHJldHVybiBmYWxzZVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRldGVybWluaXN0aWNHZW5lcmF0ZUsoaGFzaCwgeCwgY2hlY2tTaWcsIGlzUHJpdmF0ZSwgYWRkRGF0YSlcblxuICAvLyBlbmZvcmNlIGxvdyBTIHZhbHVlcywgc2VlIGJpcDYyOiAnbG93IHMgdmFsdWVzIGluIHNpZ25hdHVyZXMnXG4gIGlmIChzLmNtcChuRGl2MikgPiAwKSB7XG4gICAgcyA9IG4uc3ViKHMpXG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoNjQpXG4gIHRvQnVmZmVyKHIpLmNvcHkoYnVmZmVyLCAwKVxuICB0b0J1ZmZlcihzKS5jb3B5KGJ1ZmZlciwgMzIpXG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gdmVyaWZ5IChoYXNoLCBxLCBzaWduYXR1cmUsIHN0cmljdCkge1xuICBpZiAoIWlzU2NhbGFyKGhhc2gpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFRIUk9XX0JBRF9IQVNIKVxuICBpZiAoIWlzUG9pbnQocSkpIHRocm93IG5ldyBUeXBlRXJyb3IoVEhST1dfQkFEX1BPSU5UKVxuXG4gIC8vIDEuNC4xIEVuZm9yY2UgciBhbmQgcyBhcmUgYm90aCBpbnRlZ2VycyBpbiB0aGUgaW50ZXJ2YWwgWzEsIG4g4oiSIDFdICgxLCBpc1NpZ25hdHVyZSBlbmZvcmNlcyAnPCBuIC0gMScpXG4gIGlmICghaXNTaWduYXR1cmUoc2lnbmF0dXJlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihUSFJPV19CQURfU0lHTkFUVVJFKVxuXG4gIGNvbnN0IFEgPSBkZWNvZGVGcm9tKHEpXG4gIGNvbnN0IHIgPSBmcm9tQnVmZmVyKHNpZ25hdHVyZS5zbGljZSgwLCAzMikpXG4gIGNvbnN0IHMgPSBmcm9tQnVmZmVyKHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpKVxuXG4gIGlmIChzdHJpY3QgJiYgcy5jbXAobkRpdjIpID4gMCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gMS40LjEgRW5mb3JjZSByIGFuZCBzIGFyZSBib3RoIGludGVnZXJzIGluIHRoZSBpbnRlcnZhbCBbMSwgbiDiiJIgMV0gKDIsIGVuZm9yY2VzICc+IDAnKVxuICBpZiAoci5ndG4oMCkgPD0gMCAvKiB8fCByLmNvbXBhcmVUbyhuKSA+PSAwICovKSByZXR1cm4gZmFsc2VcbiAgaWYgKHMuZ3RuKDApIDw9IDAgLyogfHwgcy5jb21wYXJlVG8obikgPj0gMCAqLykgcmV0dXJuIGZhbHNlXG5cbiAgLy8gMS40LjIgSCA9IEhhc2goTSksIGFscmVhZHkgZG9uZSBieSB0aGUgdXNlclxuICAvLyAxLjQuMyBlID0gSFxuICBjb25zdCBlID0gZnJvbUJ1ZmZlcihoYXNoKVxuXG4gIC8vIENvbXB1dGUgc14tMVxuICBjb25zdCBzSW52ID0gcy5pbnZtKG4pXG5cbiAgLy8gMS40LjQgQ29tcHV0ZSB1MSA9IGVzXuKIkjEgbW9kIG5cbiAgLy8gICAgICAgICAgICAgICB1MiA9IHJzXuKIkjEgbW9kIG5cbiAgY29uc3QgdTEgPSBlLm11bChzSW52KS51bW9kKG4pXG4gIGNvbnN0IHUyID0gci5tdWwoc0ludikudW1vZChuKVxuXG4gIC8vIDEuNC41IENvbXB1dGUgUiA9ICh4UiwgeVIpXG4gIC8vICAgICAgICAgICAgICAgUiA9IHUxRyArIHUyUVxuICBjb25zdCBSID0gRy5tdWxBZGQodTEsIFEsIHUyKVxuXG4gIC8vIDEuNC41IChjb250LikgRW5mb3JjZSBSIGlzIG5vdCBhdCBpbmZpbml0eVxuICBpZiAoUi5pc0luZmluaXR5KCkpIHJldHVybiBmYWxzZVxuXG4gIC8vIDEuNC42IENvbnZlcnQgdGhlIGZpZWxkIGVsZW1lbnQgUi54IHRvIGFuIGludGVnZXJcbiAgY29uc3QgeFIgPSBSLnhcblxuICAvLyAxLjQuNyBTZXQgdiA9IHhSIG1vZCBuXG4gIGNvbnN0IHYgPSB4Ui51bW9kKG4pXG5cbiAgLy8gMS40LjggSWYgdiA9IHIsIG91dHB1dCBcInZhbGlkXCIsIGFuZCBpZiB2ICE9IHIsIG91dHB1dCBcImludmFsaWRcIlxuICByZXR1cm4gdi5lcShyKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNQb2ludCxcbiAgaXNQb2ludENvbXByZXNzZWQsXG4gIGlzUHJpdmF0ZSxcbiAgcG9pbnRBZGQsXG4gIHBvaW50QWRkU2NhbGFyLFxuICBwb2ludENvbXByZXNzLFxuICBwb2ludEZyb21TY2FsYXIsXG4gIHBvaW50TXVsdGlwbHksXG4gIHByaXZhdGVBZGQsXG4gIHByaXZhdGVTdWIsXG4gIHNpZ24sXG4gIHNpZ25XaXRoRW50cm9weSxcbiAgdmVyaWZ5XG59XG4iLCJjb25zdCBjcmVhdGVIbWFjID0gcmVxdWlyZSgnY3JlYXRlLWhtYWMnKVxuXG5jb25zdCBPTkUxID0gQnVmZmVyLmFsbG9jKDEsIDEpXG5jb25zdCBaRVJPMSA9IEJ1ZmZlci5hbGxvYygxLCAwKVxuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjk3OSNzZWN0aW9uLTMuMlxuZnVuY3Rpb24gZGV0ZXJtaW5pc3RpY0dlbmVyYXRlSyAoaGFzaCwgeCwgY2hlY2tTaWcsIGlzUHJpdmF0ZSwgZXh0cmFFbnRyb3B5KSB7XG4gIC8vIFN0ZXAgQSwgaWdub3JlZCBhcyBoYXNoIGFscmVhZHkgcHJvdmlkZWRcbiAgLy8gU3RlcCBCXG4gIC8vIFN0ZXAgQ1xuICBsZXQgayA9IEJ1ZmZlci5hbGxvYygzMiwgMClcbiAgbGV0IHYgPSBCdWZmZXIuYWxsb2MoMzIsIDEpXG5cbiAgLy8gU3RlcCBEXG4gIGsgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKVxuICAgIC51cGRhdGUodilcbiAgICAudXBkYXRlKFpFUk8xKVxuICAgIC51cGRhdGUoeClcbiAgICAudXBkYXRlKGhhc2gpXG4gICAgLnVwZGF0ZShleHRyYUVudHJvcHkgfHwgJycpXG4gICAgLmRpZ2VzdCgpXG5cbiAgLy8gU3RlcCBFXG4gIHYgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKS51cGRhdGUodikuZGlnZXN0KClcblxuICAvLyBTdGVwIEZcbiAgayA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIGspXG4gICAgLnVwZGF0ZSh2KVxuICAgIC51cGRhdGUoT05FMSlcbiAgICAudXBkYXRlKHgpXG4gICAgLnVwZGF0ZShoYXNoKVxuICAgIC51cGRhdGUoZXh0cmFFbnRyb3B5IHx8ICcnKVxuICAgIC5kaWdlc3QoKVxuXG4gIC8vIFN0ZXAgR1xuICB2ID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG5cbiAgLy8gU3RlcCBIMS9IMmEsIGlnbm9yZWQgYXMgdGxlbiA9PT0gcWxlbiAoMjU2IGJpdClcbiAgLy8gU3RlcCBIMmJcbiAgdiA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIGspLnVwZGF0ZSh2KS5kaWdlc3QoKVxuXG4gIGxldCBUID0gdlxuXG4gIC8vIFN0ZXAgSDMsIHJlcGVhdCB1bnRpbCBUIGlzIHdpdGhpbiB0aGUgaW50ZXJ2YWwgWzEsIG4gLSAxXSBhbmQgaXMgc3VpdGFibGUgZm9yIEVDRFNBXG4gIHdoaWxlICghaXNQcml2YXRlKFQpIHx8ICFjaGVja1NpZyhUKSkge1xuICAgIGsgPSBjcmVhdGVIbWFjKCdzaGEyNTYnLCBrKVxuICAgICAgLnVwZGF0ZSh2KVxuICAgICAgLnVwZGF0ZShaRVJPMSlcbiAgICAgIC5kaWdlc3QoKVxuXG4gICAgdiA9IGNyZWF0ZUhtYWMoJ3NoYTI1NicsIGspLnVwZGF0ZSh2KS5kaWdlc3QoKVxuXG4gICAgLy8gU3RlcCBIMS9IMmEsIGFnYWluLCBpZ25vcmVkIGFzIHRsZW4gPT09IHFsZW4gKDI1NiBiaXQpXG4gICAgLy8gU3RlcCBIMmIgYWdhaW5cbiAgICB2ID0gY3JlYXRlSG1hYygnc2hhMjU2JywgaykudXBkYXRlKHYpLmRpZ2VzdCgpXG4gICAgVCA9IHZcbiAgfVxuXG4gIHJldHVybiBUXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGV0ZXJtaW5pc3RpY0dlbmVyYXRlS1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b0RhdGFWaWV3IChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgSW50OEFycmF5IHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKVxuICB9XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoZGF0YSlcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBkYXRhYCB0byBiZSBhbiBBcnJheUJ1ZmZlciwgQnVmZmVyLCBJbnQ4QXJyYXksIFVpbnQ4QXJyYXkgb3IgVWludDhDbGFtcGVkQXJyYXknKVxufVxuIiwiLy8gV3JpdHRlbiBpbiAyMDE0LTIwMTYgYnkgRG1pdHJ5IENoZXN0bnlraCBhbmQgRGV2aSBNYW5kaXJpLlxuLy8gUHVibGljIGRvbWFpbi5cbihmdW5jdGlvbihyb290LCBmKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSBtb2R1bGUuZXhwb3J0cyA9IGYoKTtcbiAgZWxzZSBpZiAocm9vdC5uYWNsKSByb290Lm5hY2wudXRpbCA9IGYoKTtcbiAgZWxzZSB7XG4gICAgcm9vdC5uYWNsID0ge307XG4gICAgcm9vdC5uYWNsLnV0aWwgPSBmKCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgdXRpbCA9IHt9O1xuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQmFzZTY0KHMpIHtcbiAgICBpZiAoISgvXig/OltBLVphLXowLTkrXFwvXXsyfVtBLVphLXowLTkrXFwvXXsyfSkqKD86W0EtWmEtejAtOStcXC9dezJ9PT18W0EtWmEtejAtOStcXC9dezN9PSk/JC8udGVzdChzKSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZW5jb2RpbmcnKTtcbiAgICB9XG4gIH1cblxuICB1dGlsLmRlY29kZVVURjggPSBmdW5jdGlvbihzKSB7XG4gICAgaWYgKHR5cGVvZiBzICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhwZWN0ZWQgc3RyaW5nJyk7XG4gICAgdmFyIGksIGQgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQocykpLCBiID0gbmV3IFVpbnQ4QXJyYXkoZC5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkLmxlbmd0aDsgaSsrKSBiW2ldID0gZC5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBiO1xuICB9O1xuXG4gIHV0aWwuZW5jb2RlVVRGOCA9IGZ1bmN0aW9uKGFycikge1xuICAgIHZhciBpLCBzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgcy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyW2ldKSk7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUocy5qb2luKCcnKSkpO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgYXRvYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOb2RlLmpzXG5cbiAgICBpZiAodHlwZW9mIEJ1ZmZlci5mcm9tICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgIC8vIE5vZGUgdjYgYW5kIGxhdGVyXG4gICAgICB1dGlsLmVuY29kZUJhc2U2NCA9IGZ1bmN0aW9uIChhcnIpIHsgLy8gdjYgYW5kIGxhdGVyXG4gICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgfTtcblxuICAgICAgdXRpbC5kZWNvZGVCYXNlNjQgPSBmdW5jdGlvbiAocykge1xuICAgICAgICB2YWxpZGF0ZUJhc2U2NChzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKEJ1ZmZlci5mcm9tKHMsICdiYXNlNjQnKSwgMCkpO1xuICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb2RlIGVhcmxpZXIgdGhhbiB2NlxuICAgICAgdXRpbC5lbmNvZGVCYXNlNjQgPSBmdW5jdGlvbiAoYXJyKSB7IC8vIHY2IGFuZCBsYXRlclxuICAgICAgICByZXR1cm4gKG5ldyBCdWZmZXIoYXJyKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgfTtcblxuICAgICAgdXRpbC5kZWNvZGVCYXNlNjQgPSBmdW5jdGlvbihzKSB7XG4gICAgICAgIHZhbGlkYXRlQmFzZTY0KHMpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobmV3IEJ1ZmZlcihzLCAnYmFzZTY0JyksIDApKTtcbiAgICAgIH07XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlcnNcblxuICAgIHV0aWwuZW5jb2RlQmFzZTY0ID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgICB2YXIgaSwgcyA9IFtdLCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSBzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShhcnJbaV0pKTtcbiAgICAgIHJldHVybiBidG9hKHMuam9pbignJykpO1xuICAgIH07XG5cbiAgICB1dGlsLmRlY29kZUJhc2U2NCA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhbGlkYXRlQmFzZTY0KHMpO1xuICAgICAgdmFyIGksIGQgPSBhdG9iKHMpLCBiID0gbmV3IFVpbnQ4QXJyYXkoZC5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGQubGVuZ3RoOyBpKyspIGJbaV0gPSBkLmNoYXJDb2RlQXQoaSk7XG4gICAgICByZXR1cm4gYjtcbiAgICB9O1xuXG4gIH1cblxuICByZXR1cm4gdXRpbDtcblxufSkpO1xuIiwiKGZ1bmN0aW9uKG5hY2wpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gUG9ydGVkIGluIDIwMTQgYnkgRG1pdHJ5IENoZXN0bnlraCBhbmQgRGV2aSBNYW5kaXJpLlxuLy8gUHVibGljIGRvbWFpbi5cbi8vXG4vLyBJbXBsZW1lbnRhdGlvbiBkZXJpdmVkIGZyb20gVHdlZXROYUNsIHZlcnNpb24gMjAxNDA0MjcuXG4vLyBTZWUgZm9yIGRldGFpbHM6IGh0dHA6Ly90d2VldG5hY2wuY3IueXAudG8vXG5cbnZhciBnZiA9IGZ1bmN0aW9uKGluaXQpIHtcbiAgdmFyIGksIHIgPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcbiAgaWYgKGluaXQpIGZvciAoaSA9IDA7IGkgPCBpbml0Lmxlbmd0aDsgaSsrKSByW2ldID0gaW5pdFtpXTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vLyAgUGx1Z2dhYmxlLCBpbml0aWFsaXplZCBpbiBoaWdoLWxldmVsIEFQSSBiZWxvdy5cbnZhciByYW5kb21ieXRlcyA9IGZ1bmN0aW9uKC8qIHgsIG4gKi8pIHsgdGhyb3cgbmV3IEVycm9yKCdubyBQUk5HJyk7IH07XG5cbnZhciBfMCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbnZhciBfOSA9IG5ldyBVaW50OEFycmF5KDMyKTsgXzlbMF0gPSA5O1xuXG52YXIgZ2YwID0gZ2YoKSxcbiAgICBnZjEgPSBnZihbMV0pLFxuICAgIF8xMjE2NjUgPSBnZihbMHhkYjQxLCAxXSksXG4gICAgRCA9IGdmKFsweDc4YTMsIDB4MTM1OSwgMHg0ZGNhLCAweDc1ZWIsIDB4ZDhhYiwgMHg0MTQxLCAweDBhNGQsIDB4MDA3MCwgMHhlODk4LCAweDc3NzksIDB4NDA3OSwgMHg4Y2M3LCAweGZlNzMsIDB4MmI2ZiwgMHg2Y2VlLCAweDUyMDNdKSxcbiAgICBEMiA9IGdmKFsweGYxNTksIDB4MjZiMiwgMHg5Yjk0LCAweGViZDYsIDB4YjE1NiwgMHg4MjgzLCAweDE0OWEsIDB4MDBlMCwgMHhkMTMwLCAweGVlZjMsIDB4ODBmMiwgMHgxOThlLCAweGZjZTcsIDB4NTZkZiwgMHhkOWRjLCAweDI0MDZdKSxcbiAgICBYID0gZ2YoWzB4ZDUxYSwgMHg4ZjI1LCAweDJkNjAsIDB4Yzk1NiwgMHhhN2IyLCAweDk1MjUsIDB4Yzc2MCwgMHg2OTJjLCAweGRjNWMsIDB4ZmRkNiwgMHhlMjMxLCAweGMwYTQsIDB4NTNmZSwgMHhjZDZlLCAweDM2ZDMsIDB4MjE2OV0pLFxuICAgIFkgPSBnZihbMHg2NjU4LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2LCAweDY2NjYsIDB4NjY2NiwgMHg2NjY2XSksXG4gICAgSSA9IGdmKFsweGEwYjAsIDB4NGEwZSwgMHgxYjI3LCAweGM0ZWUsIDB4ZTQ3OCwgMHhhZDJmLCAweDE4MDYsIDB4MmY0MywgMHhkN2E3LCAweDNkZmIsIDB4MDA5OSwgMHgyYjRkLCAweGRmMGIsIDB4NGZjMSwgMHgyNDgwLCAweDJiODNdKTtcblxuZnVuY3Rpb24gdHM2NCh4LCBpLCBoLCBsKSB7XG4gIHhbaV0gICA9IChoID4+IDI0KSAmIDB4ZmY7XG4gIHhbaSsxXSA9IChoID4+IDE2KSAmIDB4ZmY7XG4gIHhbaSsyXSA9IChoID4+ICA4KSAmIDB4ZmY7XG4gIHhbaSszXSA9IGggJiAweGZmO1xuICB4W2krNF0gPSAobCA+PiAyNCkgICYgMHhmZjtcbiAgeFtpKzVdID0gKGwgPj4gMTYpICAmIDB4ZmY7XG4gIHhbaSs2XSA9IChsID4+ICA4KSAgJiAweGZmO1xuICB4W2krN10gPSBsICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gdm4oeCwgeGksIHksIHlpLCBuKSB7XG4gIHZhciBpLGQgPSAwO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSBkIHw9IHhbeGkraV1eeVt5aStpXTtcbiAgcmV0dXJuICgxICYgKChkIC0gMSkgPj4+IDgpKSAtIDE7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b192ZXJpZnlfMTYoeCwgeGksIHksIHlpKSB7XG4gIHJldHVybiB2bih4LHhpLHkseWksMTYpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fdmVyaWZ5XzMyKHgsIHhpLCB5LCB5aSkge1xuICByZXR1cm4gdm4oeCx4aSx5LHlpLDMyKTtcbn1cblxuZnVuY3Rpb24gY29yZV9zYWxzYTIwKG8sIHAsIGssIGMpIHtcbiAgdmFyIGowICA9IGNbIDBdICYgMHhmZiB8IChjWyAxXSAmIDB4ZmYpPDw4IHwgKGNbIDJdICYgMHhmZik8PDE2IHwgKGNbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajEgID0ga1sgMF0gJiAweGZmIHwgKGtbIDFdICYgMHhmZik8PDggfCAoa1sgMl0gJiAweGZmKTw8MTYgfCAoa1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMiAgPSBrWyA0XSAmIDB4ZmYgfCAoa1sgNV0gJiAweGZmKTw8OCB8IChrWyA2XSAmIDB4ZmYpPDwxNiB8IChrWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGozICA9IGtbIDhdICYgMHhmZiB8IChrWyA5XSAmIDB4ZmYpPDw4IHwgKGtbMTBdICYgMHhmZik8PDE2IHwgKGtbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajQgID0ga1sxMl0gJiAweGZmIHwgKGtbMTNdICYgMHhmZik8PDggfCAoa1sxNF0gJiAweGZmKTw8MTYgfCAoa1sxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqNSAgPSBjWyA0XSAmIDB4ZmYgfCAoY1sgNV0gJiAweGZmKTw8OCB8IChjWyA2XSAmIDB4ZmYpPDwxNiB8IChjWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo2ICA9IHBbIDBdICYgMHhmZiB8IChwWyAxXSAmIDB4ZmYpPDw4IHwgKHBbIDJdICYgMHhmZik8PDE2IHwgKHBbIDNdICYgMHhmZik8PDI0LFxuICAgICAgajcgID0gcFsgNF0gJiAweGZmIHwgKHBbIDVdICYgMHhmZik8PDggfCAocFsgNl0gJiAweGZmKTw8MTYgfCAocFsgN10gJiAweGZmKTw8MjQsXG4gICAgICBqOCAgPSBwWyA4XSAmIDB4ZmYgfCAocFsgOV0gJiAweGZmKTw8OCB8IChwWzEwXSAmIDB4ZmYpPDwxNiB8IChwWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo5ICA9IHBbMTJdICYgMHhmZiB8IChwWzEzXSAmIDB4ZmYpPDw4IHwgKHBbMTRdICYgMHhmZik8PDE2IHwgKHBbMTVdICYgMHhmZik8PDI0LFxuICAgICAgajEwID0gY1sgOF0gJiAweGZmIHwgKGNbIDldICYgMHhmZik8PDggfCAoY1sxMF0gJiAweGZmKTw8MTYgfCAoY1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTEgPSBrWzE2XSAmIDB4ZmYgfCAoa1sxN10gJiAweGZmKTw8OCB8IChrWzE4XSAmIDB4ZmYpPDwxNiB8IChrWzE5XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMiA9IGtbMjBdICYgMHhmZiB8IChrWzIxXSAmIDB4ZmYpPDw4IHwgKGtbMjJdICYgMHhmZik8PDE2IHwgKGtbMjNdICYgMHhmZik8PDI0LFxuICAgICAgajEzID0ga1syNF0gJiAweGZmIHwgKGtbMjVdICYgMHhmZik8PDggfCAoa1syNl0gJiAweGZmKTw8MTYgfCAoa1syN10gJiAweGZmKTw8MjQsXG4gICAgICBqMTQgPSBrWzI4XSAmIDB4ZmYgfCAoa1syOV0gJiAweGZmKTw8OCB8IChrWzMwXSAmIDB4ZmYpPDwxNiB8IChrWzMxXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNSA9IGNbMTJdICYgMHhmZiB8IChjWzEzXSAmIDB4ZmYpPDw4IHwgKGNbMTRdICYgMHhmZik8PDE2IHwgKGNbMTVdICYgMHhmZik8PDI0O1xuXG4gIHZhciB4MCA9IGowLCB4MSA9IGoxLCB4MiA9IGoyLCB4MyA9IGozLCB4NCA9IGo0LCB4NSA9IGo1LCB4NiA9IGo2LCB4NyA9IGo3LFxuICAgICAgeDggPSBqOCwgeDkgPSBqOSwgeDEwID0gajEwLCB4MTEgPSBqMTEsIHgxMiA9IGoxMiwgeDEzID0gajEzLCB4MTQgPSBqMTQsXG4gICAgICB4MTUgPSBqMTUsIHU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDsgaSArPSAyKSB7XG4gICAgdSA9IHgwICsgeDEyIHwgMDtcbiAgICB4NCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDQgKyB4MCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDQgfCAwO1xuICAgIHgxMiBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MTIgKyB4OCB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHgxIHwgMDtcbiAgICB4OSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDkgKyB4NSB8IDA7XG4gICAgeDEzIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MTMgKyB4OSB8IDA7XG4gICAgeDEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDEgKyB4MTMgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDYgfCAwO1xuICAgIHgxNCBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDE0ICsgeDEwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MTQgfCAwO1xuICAgIHg2IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg2ICsgeDIgfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxMSB8IDA7XG4gICAgeDMgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgzICsgeDE1IHwgMDtcbiAgICB4NyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDcgKyB4MyB8IDA7XG4gICAgeDExIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMSArIHg3IHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MCArIHgzIHwgMDtcbiAgICB4MSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEgKyB4MCB8IDA7XG4gICAgeDIgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgyICsgeDEgfCAwO1xuICAgIHgzIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgzICsgeDIgfCAwO1xuICAgIHgwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDUgKyB4NCB8IDA7XG4gICAgeDYgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHg2ICsgeDUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHg2IHwgMDtcbiAgICB4NCBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4NCArIHg3IHwgMDtcbiAgICB4NSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxMCArIHg5IHwgMDtcbiAgICB4MTEgXj0gdTw8NyB8IHU+Pj4oMzItNyk7XG4gICAgdSA9IHgxMSArIHgxMCB8IDA7XG4gICAgeDggXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg4ICsgeDExIHwgMDtcbiAgICB4OSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4OSArIHg4IHwgMDtcbiAgICB4MTAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTUgKyB4MTQgfCAwO1xuICAgIHgxMiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDEyICsgeDE1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHgxMiB8IDA7XG4gICAgeDE0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxNCArIHgxMyB8IDA7XG4gICAgeDE1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG4gIH1cbiAgIHgwID0gIHgwICsgIGowIHwgMDtcbiAgIHgxID0gIHgxICsgIGoxIHwgMDtcbiAgIHgyID0gIHgyICsgIGoyIHwgMDtcbiAgIHgzID0gIHgzICsgIGozIHwgMDtcbiAgIHg0ID0gIHg0ICsgIGo0IHwgMDtcbiAgIHg1ID0gIHg1ICsgIGo1IHwgMDtcbiAgIHg2ID0gIHg2ICsgIGo2IHwgMDtcbiAgIHg3ID0gIHg3ICsgIGo3IHwgMDtcbiAgIHg4ID0gIHg4ICsgIGo4IHwgMDtcbiAgIHg5ID0gIHg5ICsgIGo5IHwgMDtcbiAgeDEwID0geDEwICsgajEwIHwgMDtcbiAgeDExID0geDExICsgajExIHwgMDtcbiAgeDEyID0geDEyICsgajEyIHwgMDtcbiAgeDEzID0geDEzICsgajEzIHwgMDtcbiAgeDE0ID0geDE0ICsgajE0IHwgMDtcbiAgeDE1ID0geDE1ICsgajE1IHwgMDtcblxuICBvWyAwXSA9IHgwID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDFdID0geDAgPj4+ICA4ICYgMHhmZjtcbiAgb1sgMl0gPSB4MCA+Pj4gMTYgJiAweGZmO1xuICBvWyAzXSA9IHgwID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgNF0gPSB4MSA+Pj4gIDAgJiAweGZmO1xuICBvWyA1XSA9IHgxID4+PiAgOCAmIDB4ZmY7XG4gIG9bIDZdID0geDEgPj4+IDE2ICYgMHhmZjtcbiAgb1sgN10gPSB4MSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bIDhdID0geDIgPj4+ICAwICYgMHhmZjtcbiAgb1sgOV0gPSB4MiA+Pj4gIDggJiAweGZmO1xuICBvWzEwXSA9IHgyID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTFdID0geDIgPj4+IDI0ICYgMHhmZjtcblxuICBvWzEyXSA9IHgzID4+PiAgMCAmIDB4ZmY7XG4gIG9bMTNdID0geDMgPj4+ICA4ICYgMHhmZjtcbiAgb1sxNF0gPSB4MyA+Pj4gMTYgJiAweGZmO1xuICBvWzE1XSA9IHgzID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sxNl0gPSB4NCA+Pj4gIDAgJiAweGZmO1xuICBvWzE3XSA9IHg0ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMThdID0geDQgPj4+IDE2ICYgMHhmZjtcbiAgb1sxOV0gPSB4NCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjBdID0geDUgPj4+ICAwICYgMHhmZjtcbiAgb1syMV0gPSB4NSA+Pj4gIDggJiAweGZmO1xuICBvWzIyXSA9IHg1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMjNdID0geDUgPj4+IDI0ICYgMHhmZjtcblxuICBvWzI0XSA9IHg2ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjVdID0geDYgPj4+ICA4ICYgMHhmZjtcbiAgb1syNl0gPSB4NiA+Pj4gMTYgJiAweGZmO1xuICBvWzI3XSA9IHg2ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syOF0gPSB4NyA+Pj4gIDAgJiAweGZmO1xuICBvWzI5XSA9IHg3ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMzBdID0geDcgPj4+IDE2ICYgMHhmZjtcbiAgb1szMV0gPSB4NyA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMzJdID0geDggPj4+ICAwICYgMHhmZjtcbiAgb1szM10gPSB4OCA+Pj4gIDggJiAweGZmO1xuICBvWzM0XSA9IHg4ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzVdID0geDggPj4+IDI0ICYgMHhmZjtcblxuICBvWzM2XSA9IHg5ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMzddID0geDkgPj4+ICA4ICYgMHhmZjtcbiAgb1szOF0gPSB4OSA+Pj4gMTYgJiAweGZmO1xuICBvWzM5XSA9IHg5ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s0MF0gPSB4MTAgPj4+ICAwICYgMHhmZjtcbiAgb1s0MV0gPSB4MTAgPj4+ICA4ICYgMHhmZjtcbiAgb1s0Ml0gPSB4MTAgPj4+IDE2ICYgMHhmZjtcbiAgb1s0M10gPSB4MTAgPj4+IDI0ICYgMHhmZjtcblxuICBvWzQ0XSA9IHgxMSA+Pj4gIDAgJiAweGZmO1xuICBvWzQ1XSA9IHgxMSA+Pj4gIDggJiAweGZmO1xuICBvWzQ2XSA9IHgxMSA+Pj4gMTYgJiAweGZmO1xuICBvWzQ3XSA9IHgxMSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNDhdID0geDEyID4+PiAgMCAmIDB4ZmY7XG4gIG9bNDldID0geDEyID4+PiAgOCAmIDB4ZmY7XG4gIG9bNTBdID0geDEyID4+PiAxNiAmIDB4ZmY7XG4gIG9bNTFdID0geDEyID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1s1Ml0gPSB4MTMgPj4+ICAwICYgMHhmZjtcbiAgb1s1M10gPSB4MTMgPj4+ICA4ICYgMHhmZjtcbiAgb1s1NF0gPSB4MTMgPj4+IDE2ICYgMHhmZjtcbiAgb1s1NV0gPSB4MTMgPj4+IDI0ICYgMHhmZjtcblxuICBvWzU2XSA9IHgxNCA+Pj4gIDAgJiAweGZmO1xuICBvWzU3XSA9IHgxNCA+Pj4gIDggJiAweGZmO1xuICBvWzU4XSA9IHgxNCA+Pj4gMTYgJiAweGZmO1xuICBvWzU5XSA9IHgxNCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bNjBdID0geDE1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bNjFdID0geDE1ID4+PiAgOCAmIDB4ZmY7XG4gIG9bNjJdID0geDE1ID4+PiAxNiAmIDB4ZmY7XG4gIG9bNjNdID0geDE1ID4+PiAyNCAmIDB4ZmY7XG59XG5cbmZ1bmN0aW9uIGNvcmVfaHNhbHNhMjAobyxwLGssYykge1xuICB2YXIgajAgID0gY1sgMF0gJiAweGZmIHwgKGNbIDFdICYgMHhmZik8PDggfCAoY1sgMl0gJiAweGZmKTw8MTYgfCAoY1sgM10gJiAweGZmKTw8MjQsXG4gICAgICBqMSAgPSBrWyAwXSAmIDB4ZmYgfCAoa1sgMV0gJiAweGZmKTw8OCB8IChrWyAyXSAmIDB4ZmYpPDwxNiB8IChrWyAzXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoyICA9IGtbIDRdICYgMHhmZiB8IChrWyA1XSAmIDB4ZmYpPDw4IHwgKGtbIDZdICYgMHhmZik8PDE2IHwgKGtbIDddICYgMHhmZik8PDI0LFxuICAgICAgajMgID0ga1sgOF0gJiAweGZmIHwgKGtbIDldICYgMHhmZik8PDggfCAoa1sxMF0gJiAweGZmKTw8MTYgfCAoa1sxMV0gJiAweGZmKTw8MjQsXG4gICAgICBqNCAgPSBrWzEyXSAmIDB4ZmYgfCAoa1sxM10gJiAweGZmKTw8OCB8IChrWzE0XSAmIDB4ZmYpPDwxNiB8IChrWzE1XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo1ICA9IGNbIDRdICYgMHhmZiB8IChjWyA1XSAmIDB4ZmYpPDw4IHwgKGNbIDZdICYgMHhmZik8PDE2IHwgKGNbIDddICYgMHhmZik8PDI0LFxuICAgICAgajYgID0gcFsgMF0gJiAweGZmIHwgKHBbIDFdICYgMHhmZik8PDggfCAocFsgMl0gJiAweGZmKTw8MTYgfCAocFsgM10gJiAweGZmKTw8MjQsXG4gICAgICBqNyAgPSBwWyA0XSAmIDB4ZmYgfCAocFsgNV0gJiAweGZmKTw8OCB8IChwWyA2XSAmIDB4ZmYpPDwxNiB8IChwWyA3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGo4ICA9IHBbIDhdICYgMHhmZiB8IChwWyA5XSAmIDB4ZmYpPDw4IHwgKHBbMTBdICYgMHhmZik8PDE2IHwgKHBbMTFdICYgMHhmZik8PDI0LFxuICAgICAgajkgID0gcFsxMl0gJiAweGZmIHwgKHBbMTNdICYgMHhmZik8PDggfCAocFsxNF0gJiAweGZmKTw8MTYgfCAocFsxNV0gJiAweGZmKTw8MjQsXG4gICAgICBqMTAgPSBjWyA4XSAmIDB4ZmYgfCAoY1sgOV0gJiAweGZmKTw8OCB8IChjWzEwXSAmIDB4ZmYpPDwxNiB8IChjWzExXSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxMSA9IGtbMTZdICYgMHhmZiB8IChrWzE3XSAmIDB4ZmYpPDw4IHwgKGtbMThdICYgMHhmZik8PDE2IHwgKGtbMTldICYgMHhmZik8PDI0LFxuICAgICAgajEyID0ga1syMF0gJiAweGZmIHwgKGtbMjFdICYgMHhmZik8PDggfCAoa1syMl0gJiAweGZmKTw8MTYgfCAoa1syM10gJiAweGZmKTw8MjQsXG4gICAgICBqMTMgPSBrWzI0XSAmIDB4ZmYgfCAoa1syNV0gJiAweGZmKTw8OCB8IChrWzI2XSAmIDB4ZmYpPDwxNiB8IChrWzI3XSAmIDB4ZmYpPDwyNCxcbiAgICAgIGoxNCA9IGtbMjhdICYgMHhmZiB8IChrWzI5XSAmIDB4ZmYpPDw4IHwgKGtbMzBdICYgMHhmZik8PDE2IHwgKGtbMzFdICYgMHhmZik8PDI0LFxuICAgICAgajE1ID0gY1sxMl0gJiAweGZmIHwgKGNbMTNdICYgMHhmZik8PDggfCAoY1sxNF0gJiAweGZmKTw8MTYgfCAoY1sxNV0gJiAweGZmKTw8MjQ7XG5cbiAgdmFyIHgwID0gajAsIHgxID0gajEsIHgyID0gajIsIHgzID0gajMsIHg0ID0gajQsIHg1ID0gajUsIHg2ID0gajYsIHg3ID0gajcsXG4gICAgICB4OCA9IGo4LCB4OSA9IGo5LCB4MTAgPSBqMTAsIHgxMSA9IGoxMSwgeDEyID0gajEyLCB4MTMgPSBqMTMsIHgxNCA9IGoxNCxcbiAgICAgIHgxNSA9IGoxNSwgdTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDIwOyBpICs9IDIpIHtcbiAgICB1ID0geDAgKyB4MTIgfCAwO1xuICAgIHg0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4NCArIHgwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4NCB8IDA7XG4gICAgeDEyIF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHgxMiArIHg4IHwgMDtcbiAgICB4MCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHg1ICsgeDEgfCAwO1xuICAgIHg5IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4OSArIHg1IHwgMDtcbiAgICB4MTMgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHgxMyArIHg5IHwgMDtcbiAgICB4MSBePSB1PDwxMyB8IHU+Pj4oMzItMTMpO1xuICAgIHUgPSB4MSArIHgxMyB8IDA7XG4gICAgeDUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4MTAgKyB4NiB8IDA7XG4gICAgeDE0IF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTQgKyB4MTAgfCAwO1xuICAgIHgyIF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4MiArIHgxNCB8IDA7XG4gICAgeDYgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDYgKyB4MiB8IDA7XG4gICAgeDEwIF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDE1ICsgeDExIHwgMDtcbiAgICB4MyBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDMgKyB4MTUgfCAwO1xuICAgIHg3IF49IHU8PDkgfCB1Pj4+KDMyLTkpO1xuICAgIHUgPSB4NyArIHgzIHwgMDtcbiAgICB4MTEgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDExICsgeDcgfCAwO1xuICAgIHgxNSBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgwICsgeDMgfCAwO1xuICAgIHgxIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MSArIHgwIHwgMDtcbiAgICB4MiBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDIgKyB4MSB8IDA7XG4gICAgeDMgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDMgKyB4MiB8IDA7XG4gICAgeDAgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcblxuICAgIHUgPSB4NSArIHg0IHwgMDtcbiAgICB4NiBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDYgKyB4NSB8IDA7XG4gICAgeDcgXj0gdTw8OSB8IHU+Pj4oMzItOSk7XG4gICAgdSA9IHg3ICsgeDYgfCAwO1xuICAgIHg0IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg0ICsgeDcgfCAwO1xuICAgIHg1IF49IHU8PDE4IHwgdT4+PigzMi0xOCk7XG5cbiAgICB1ID0geDEwICsgeDkgfCAwO1xuICAgIHgxMSBePSB1PDw3IHwgdT4+PigzMi03KTtcbiAgICB1ID0geDExICsgeDEwIHwgMDtcbiAgICB4OCBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDggKyB4MTEgfCAwO1xuICAgIHg5IF49IHU8PDEzIHwgdT4+PigzMi0xMyk7XG4gICAgdSA9IHg5ICsgeDggfCAwO1xuICAgIHgxMCBePSB1PDwxOCB8IHU+Pj4oMzItMTgpO1xuXG4gICAgdSA9IHgxNSArIHgxNCB8IDA7XG4gICAgeDEyIF49IHU8PDcgfCB1Pj4+KDMyLTcpO1xuICAgIHUgPSB4MTIgKyB4MTUgfCAwO1xuICAgIHgxMyBePSB1PDw5IHwgdT4+PigzMi05KTtcbiAgICB1ID0geDEzICsgeDEyIHwgMDtcbiAgICB4MTQgXj0gdTw8MTMgfCB1Pj4+KDMyLTEzKTtcbiAgICB1ID0geDE0ICsgeDEzIHwgMDtcbiAgICB4MTUgXj0gdTw8MTggfCB1Pj4+KDMyLTE4KTtcbiAgfVxuXG4gIG9bIDBdID0geDAgPj4+ICAwICYgMHhmZjtcbiAgb1sgMV0gPSB4MCA+Pj4gIDggJiAweGZmO1xuICBvWyAyXSA9IHgwID4+PiAxNiAmIDB4ZmY7XG4gIG9bIDNdID0geDAgPj4+IDI0ICYgMHhmZjtcblxuICBvWyA0XSA9IHg1ID4+PiAgMCAmIDB4ZmY7XG4gIG9bIDVdID0geDUgPj4+ICA4ICYgMHhmZjtcbiAgb1sgNl0gPSB4NSA+Pj4gMTYgJiAweGZmO1xuICBvWyA3XSA9IHg1ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1sgOF0gPSB4MTAgPj4+ICAwICYgMHhmZjtcbiAgb1sgOV0gPSB4MTAgPj4+ICA4ICYgMHhmZjtcbiAgb1sxMF0gPSB4MTAgPj4+IDE2ICYgMHhmZjtcbiAgb1sxMV0gPSB4MTAgPj4+IDI0ICYgMHhmZjtcblxuICBvWzEyXSA9IHgxNSA+Pj4gIDAgJiAweGZmO1xuICBvWzEzXSA9IHgxNSA+Pj4gIDggJiAweGZmO1xuICBvWzE0XSA9IHgxNSA+Pj4gMTYgJiAweGZmO1xuICBvWzE1XSA9IHgxNSA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMTZdID0geDYgPj4+ICAwICYgMHhmZjtcbiAgb1sxN10gPSB4NiA+Pj4gIDggJiAweGZmO1xuICBvWzE4XSA9IHg2ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMTldID0geDYgPj4+IDI0ICYgMHhmZjtcblxuICBvWzIwXSA9IHg3ID4+PiAgMCAmIDB4ZmY7XG4gIG9bMjFdID0geDcgPj4+ICA4ICYgMHhmZjtcbiAgb1syMl0gPSB4NyA+Pj4gMTYgJiAweGZmO1xuICBvWzIzXSA9IHg3ID4+PiAyNCAmIDB4ZmY7XG5cbiAgb1syNF0gPSB4OCA+Pj4gIDAgJiAweGZmO1xuICBvWzI1XSA9IHg4ID4+PiAgOCAmIDB4ZmY7XG4gIG9bMjZdID0geDggPj4+IDE2ICYgMHhmZjtcbiAgb1syN10gPSB4OCA+Pj4gMjQgJiAweGZmO1xuXG4gIG9bMjhdID0geDkgPj4+ICAwICYgMHhmZjtcbiAgb1syOV0gPSB4OSA+Pj4gIDggJiAweGZmO1xuICBvWzMwXSA9IHg5ID4+PiAxNiAmIDB4ZmY7XG4gIG9bMzFdID0geDkgPj4+IDI0ICYgMHhmZjtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2NvcmVfc2Fsc2EyMChvdXQsaW5wLGssYykge1xuICBjb3JlX3NhbHNhMjAob3V0LGlucCxrLGMpO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fY29yZV9oc2Fsc2EyMChvdXQsaW5wLGssYykge1xuICBjb3JlX2hzYWxzYTIwKG91dCxpbnAsayxjKTtcbn1cblxudmFyIHNpZ21hID0gbmV3IFVpbnQ4QXJyYXkoWzEwMSwgMTIwLCAxMTIsIDk3LCAxMTAsIDEwMCwgMzIsIDUxLCA1MCwgNDUsIDk4LCAxMjEsIDExNiwgMTAxLCAzMiwgMTA3XSk7XG4gICAgICAgICAgICAvLyBcImV4cGFuZCAzMi1ieXRlIGtcIlxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtX3NhbHNhMjBfeG9yKGMsY3BvcyxtLG1wb3MsYixuLGspIHtcbiAgdmFyIHogPSBuZXcgVWludDhBcnJheSgxNiksIHggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciB1LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgeltpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHpbaV0gPSBuW2ldO1xuICB3aGlsZSAoYiA+PSA2NCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSBjW2Nwb3MraV0gPSBtW21wb3MraV0gXiB4W2ldO1xuICAgIHUgPSAxO1xuICAgIGZvciAoaSA9IDg7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1ID0gdSArICh6W2ldICYgMHhmZikgfCAwO1xuICAgICAgeltpXSA9IHUgJiAweGZmO1xuICAgICAgdSA+Pj49IDg7XG4gICAgfVxuICAgIGIgLT0gNjQ7XG4gICAgY3BvcyArPSA2NDtcbiAgICBtcG9zICs9IDY0O1xuICB9XG4gIGlmIChiID4gMCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBiOyBpKyspIGNbY3BvcytpXSA9IG1bbXBvcytpXSBeIHhbaV07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zdHJlYW1fc2Fsc2EyMChjLGNwb3MsYixuLGspIHtcbiAgdmFyIHogPSBuZXcgVWludDhBcnJheSgxNiksIHggPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciB1LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgeltpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHpbaV0gPSBuW2ldO1xuICB3aGlsZSAoYiA+PSA2NCkge1xuICAgIGNyeXB0b19jb3JlX3NhbHNhMjAoeCx6LGssc2lnbWEpO1xuICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSBjW2Nwb3MraV0gPSB4W2ldO1xuICAgIHUgPSAxO1xuICAgIGZvciAoaSA9IDg7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB1ID0gdSArICh6W2ldICYgMHhmZikgfCAwO1xuICAgICAgeltpXSA9IHUgJiAweGZmO1xuICAgICAgdSA+Pj49IDg7XG4gICAgfVxuICAgIGIgLT0gNjQ7XG4gICAgY3BvcyArPSA2NDtcbiAgfVxuICBpZiAoYiA+IDApIHtcbiAgICBjcnlwdG9fY29yZV9zYWxzYTIwKHgseixrLHNpZ21hKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYjsgaSsrKSBjW2Nwb3MraV0gPSB4W2ldO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc3RyZWFtKGMsY3BvcyxkLG4saykge1xuICB2YXIgcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX2NvcmVfaHNhbHNhMjAocyxuLGssc2lnbWEpO1xuICB2YXIgc24gPSBuZXcgVWludDhBcnJheSg4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHNuW2ldID0gbltpKzE2XTtcbiAgcmV0dXJuIGNyeXB0b19zdHJlYW1fc2Fsc2EyMChjLGNwb3MsZCxzbixzKTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3N0cmVhbV94b3IoYyxjcG9zLG0sbXBvcyxkLG4saykge1xuICB2YXIgcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX2NvcmVfaHNhbHNhMjAocyxuLGssc2lnbWEpO1xuICB2YXIgc24gPSBuZXcgVWludDhBcnJheSg4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHNuW2ldID0gbltpKzE2XTtcbiAgcmV0dXJuIGNyeXB0b19zdHJlYW1fc2Fsc2EyMF94b3IoYyxjcG9zLG0sbXBvcyxkLHNuLHMpO1xufVxuXG4vKlxuKiBQb3J0IG9mIEFuZHJldyBNb29uJ3MgUG9seTEzMDUtZG9ubmEtMTYuIFB1YmxpYyBkb21haW4uXG4qIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYVxuKi9cblxudmFyIHBvbHkxMzA1ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICB0aGlzLnIgPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB0aGlzLmggPSBuZXcgVWludDE2QXJyYXkoMTApO1xuICB0aGlzLnBhZCA9IG5ldyBVaW50MTZBcnJheSg4KTtcbiAgdGhpcy5sZWZ0b3ZlciA9IDA7XG4gIHRoaXMuZmluID0gMDtcblxuICB2YXIgdDAsIHQxLCB0MiwgdDMsIHQ0LCB0NSwgdDYsIHQ3O1xuXG4gIHQwID0ga2V5WyAwXSAmIDB4ZmYgfCAoa2V5WyAxXSAmIDB4ZmYpIDw8IDg7IHRoaXMuclswXSA9ICggdDAgICAgICAgICAgICAgICAgICAgICApICYgMHgxZmZmO1xuICB0MSA9IGtleVsgMl0gJiAweGZmIHwgKGtleVsgM10gJiAweGZmKSA8PCA4OyB0aGlzLnJbMV0gPSAoKHQwID4+PiAxMykgfCAodDEgPDwgIDMpKSAmIDB4MWZmZjtcbiAgdDIgPSBrZXlbIDRdICYgMHhmZiB8IChrZXlbIDVdICYgMHhmZikgPDwgODsgdGhpcy5yWzJdID0gKCh0MSA+Pj4gMTApIHwgKHQyIDw8ICA2KSkgJiAweDFmMDM7XG4gIHQzID0ga2V5WyA2XSAmIDB4ZmYgfCAoa2V5WyA3XSAmIDB4ZmYpIDw8IDg7IHRoaXMuclszXSA9ICgodDIgPj4+ICA3KSB8ICh0MyA8PCAgOSkpICYgMHgxZmZmO1xuICB0NCA9IGtleVsgOF0gJiAweGZmIHwgKGtleVsgOV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbNF0gPSAoKHQzID4+PiAgNCkgfCAodDQgPDwgMTIpKSAmIDB4MDBmZjtcbiAgdGhpcy5yWzVdID0gKCh0NCA+Pj4gIDEpKSAmIDB4MWZmZTtcbiAgdDUgPSBrZXlbMTBdICYgMHhmZiB8IChrZXlbMTFdICYgMHhmZikgPDwgODsgdGhpcy5yWzZdID0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8ICAyKSkgJiAweDFmZmY7XG4gIHQ2ID0ga2V5WzEyXSAmIDB4ZmYgfCAoa2V5WzEzXSAmIDB4ZmYpIDw8IDg7IHRoaXMucls3XSA9ICgodDUgPj4+IDExKSB8ICh0NiA8PCAgNSkpICYgMHgxZjgxO1xuICB0NyA9IGtleVsxNF0gJiAweGZmIHwgKGtleVsxNV0gJiAweGZmKSA8PCA4OyB0aGlzLnJbOF0gPSAoKHQ2ID4+PiAgOCkgfCAodDcgPDwgIDgpKSAmIDB4MWZmZjtcbiAgdGhpcy5yWzldID0gKCh0NyA+Pj4gIDUpKSAmIDB4MDA3ZjtcblxuICB0aGlzLnBhZFswXSA9IGtleVsxNl0gJiAweGZmIHwgKGtleVsxN10gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFsxXSA9IGtleVsxOF0gJiAweGZmIHwgKGtleVsxOV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFsyXSA9IGtleVsyMF0gJiAweGZmIHwgKGtleVsyMV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFszXSA9IGtleVsyMl0gJiAweGZmIHwgKGtleVsyM10gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs0XSA9IGtleVsyNF0gJiAweGZmIHwgKGtleVsyNV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs1XSA9IGtleVsyNl0gJiAweGZmIHwgKGtleVsyN10gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs2XSA9IGtleVsyOF0gJiAweGZmIHwgKGtleVsyOV0gJiAweGZmKSA8PCA4O1xuICB0aGlzLnBhZFs3XSA9IGtleVszMF0gJiAweGZmIHwgKGtleVszMV0gJiAweGZmKSA8PCA4O1xufTtcblxucG9seTEzMDUucHJvdG90eXBlLmJsb2NrcyA9IGZ1bmN0aW9uKG0sIG1wb3MsIGJ5dGVzKSB7XG4gIHZhciBoaWJpdCA9IHRoaXMuZmluID8gMCA6ICgxIDw8IDExKTtcbiAgdmFyIHQwLCB0MSwgdDIsIHQzLCB0NCwgdDUsIHQ2LCB0NywgYztcbiAgdmFyIGQwLCBkMSwgZDIsIGQzLCBkNCwgZDUsIGQ2LCBkNywgZDgsIGQ5O1xuXG4gIHZhciBoMCA9IHRoaXMuaFswXSxcbiAgICAgIGgxID0gdGhpcy5oWzFdLFxuICAgICAgaDIgPSB0aGlzLmhbMl0sXG4gICAgICBoMyA9IHRoaXMuaFszXSxcbiAgICAgIGg0ID0gdGhpcy5oWzRdLFxuICAgICAgaDUgPSB0aGlzLmhbNV0sXG4gICAgICBoNiA9IHRoaXMuaFs2XSxcbiAgICAgIGg3ID0gdGhpcy5oWzddLFxuICAgICAgaDggPSB0aGlzLmhbOF0sXG4gICAgICBoOSA9IHRoaXMuaFs5XTtcblxuICB2YXIgcjAgPSB0aGlzLnJbMF0sXG4gICAgICByMSA9IHRoaXMuclsxXSxcbiAgICAgIHIyID0gdGhpcy5yWzJdLFxuICAgICAgcjMgPSB0aGlzLnJbM10sXG4gICAgICByNCA9IHRoaXMucls0XSxcbiAgICAgIHI1ID0gdGhpcy5yWzVdLFxuICAgICAgcjYgPSB0aGlzLnJbNl0sXG4gICAgICByNyA9IHRoaXMucls3XSxcbiAgICAgIHI4ID0gdGhpcy5yWzhdLFxuICAgICAgcjkgPSB0aGlzLnJbOV07XG5cbiAgd2hpbGUgKGJ5dGVzID49IDE2KSB7XG4gICAgdDAgPSBtW21wb3MrIDBdICYgMHhmZiB8IChtW21wb3MrIDFdICYgMHhmZikgPDwgODsgaDAgKz0gKCB0MCAgICAgICAgICAgICAgICAgICAgICkgJiAweDFmZmY7XG4gICAgdDEgPSBtW21wb3MrIDJdICYgMHhmZiB8IChtW21wb3MrIDNdICYgMHhmZikgPDwgODsgaDEgKz0gKCh0MCA+Pj4gMTMpIHwgKHQxIDw8ICAzKSkgJiAweDFmZmY7XG4gICAgdDIgPSBtW21wb3MrIDRdICYgMHhmZiB8IChtW21wb3MrIDVdICYgMHhmZikgPDwgODsgaDIgKz0gKCh0MSA+Pj4gMTApIHwgKHQyIDw8ICA2KSkgJiAweDFmZmY7XG4gICAgdDMgPSBtW21wb3MrIDZdICYgMHhmZiB8IChtW21wb3MrIDddICYgMHhmZikgPDwgODsgaDMgKz0gKCh0MiA+Pj4gIDcpIHwgKHQzIDw8ICA5KSkgJiAweDFmZmY7XG4gICAgdDQgPSBtW21wb3MrIDhdICYgMHhmZiB8IChtW21wb3MrIDldICYgMHhmZikgPDwgODsgaDQgKz0gKCh0MyA+Pj4gIDQpIHwgKHQ0IDw8IDEyKSkgJiAweDFmZmY7XG4gICAgaDUgKz0gKCh0NCA+Pj4gIDEpKSAmIDB4MWZmZjtcbiAgICB0NSA9IG1bbXBvcysxMF0gJiAweGZmIHwgKG1bbXBvcysxMV0gJiAweGZmKSA8PCA4OyBoNiArPSAoKHQ0ID4+PiAxNCkgfCAodDUgPDwgIDIpKSAmIDB4MWZmZjtcbiAgICB0NiA9IG1bbXBvcysxMl0gJiAweGZmIHwgKG1bbXBvcysxM10gJiAweGZmKSA8PCA4OyBoNyArPSAoKHQ1ID4+PiAxMSkgfCAodDYgPDwgIDUpKSAmIDB4MWZmZjtcbiAgICB0NyA9IG1bbXBvcysxNF0gJiAweGZmIHwgKG1bbXBvcysxNV0gJiAweGZmKSA8PCA4OyBoOCArPSAoKHQ2ID4+PiAgOCkgfCAodDcgPDwgIDgpKSAmIDB4MWZmZjtcbiAgICBoOSArPSAoKHQ3ID4+PiA1KSkgfCBoaWJpdDtcblxuICAgIGMgPSAwO1xuXG4gICAgZDAgPSBjO1xuICAgIGQwICs9IGgwICogcjA7XG4gICAgZDAgKz0gaDEgKiAoNSAqIHI5KTtcbiAgICBkMCArPSBoMiAqICg1ICogcjgpO1xuICAgIGQwICs9IGgzICogKDUgKiByNyk7XG4gICAgZDAgKz0gaDQgKiAoNSAqIHI2KTtcbiAgICBjID0gKGQwID4+PiAxMyk7IGQwICY9IDB4MWZmZjtcbiAgICBkMCArPSBoNSAqICg1ICogcjUpO1xuICAgIGQwICs9IGg2ICogKDUgKiByNCk7XG4gICAgZDAgKz0gaDcgKiAoNSAqIHIzKTtcbiAgICBkMCArPSBoOCAqICg1ICogcjIpO1xuICAgIGQwICs9IGg5ICogKDUgKiByMSk7XG4gICAgYyArPSAoZDAgPj4+IDEzKTsgZDAgJj0gMHgxZmZmO1xuXG4gICAgZDEgPSBjO1xuICAgIGQxICs9IGgwICogcjE7XG4gICAgZDEgKz0gaDEgKiByMDtcbiAgICBkMSArPSBoMiAqICg1ICogcjkpO1xuICAgIGQxICs9IGgzICogKDUgKiByOCk7XG4gICAgZDEgKz0gaDQgKiAoNSAqIHI3KTtcbiAgICBjID0gKGQxID4+PiAxMyk7IGQxICY9IDB4MWZmZjtcbiAgICBkMSArPSBoNSAqICg1ICogcjYpO1xuICAgIGQxICs9IGg2ICogKDUgKiByNSk7XG4gICAgZDEgKz0gaDcgKiAoNSAqIHI0KTtcbiAgICBkMSArPSBoOCAqICg1ICogcjMpO1xuICAgIGQxICs9IGg5ICogKDUgKiByMik7XG4gICAgYyArPSAoZDEgPj4+IDEzKTsgZDEgJj0gMHgxZmZmO1xuXG4gICAgZDIgPSBjO1xuICAgIGQyICs9IGgwICogcjI7XG4gICAgZDIgKz0gaDEgKiByMTtcbiAgICBkMiArPSBoMiAqIHIwO1xuICAgIGQyICs9IGgzICogKDUgKiByOSk7XG4gICAgZDIgKz0gaDQgKiAoNSAqIHI4KTtcbiAgICBjID0gKGQyID4+PiAxMyk7IGQyICY9IDB4MWZmZjtcbiAgICBkMiArPSBoNSAqICg1ICogcjcpO1xuICAgIGQyICs9IGg2ICogKDUgKiByNik7XG4gICAgZDIgKz0gaDcgKiAoNSAqIHI1KTtcbiAgICBkMiArPSBoOCAqICg1ICogcjQpO1xuICAgIGQyICs9IGg5ICogKDUgKiByMyk7XG4gICAgYyArPSAoZDIgPj4+IDEzKTsgZDIgJj0gMHgxZmZmO1xuXG4gICAgZDMgPSBjO1xuICAgIGQzICs9IGgwICogcjM7XG4gICAgZDMgKz0gaDEgKiByMjtcbiAgICBkMyArPSBoMiAqIHIxO1xuICAgIGQzICs9IGgzICogcjA7XG4gICAgZDMgKz0gaDQgKiAoNSAqIHI5KTtcbiAgICBjID0gKGQzID4+PiAxMyk7IGQzICY9IDB4MWZmZjtcbiAgICBkMyArPSBoNSAqICg1ICogcjgpO1xuICAgIGQzICs9IGg2ICogKDUgKiByNyk7XG4gICAgZDMgKz0gaDcgKiAoNSAqIHI2KTtcbiAgICBkMyArPSBoOCAqICg1ICogcjUpO1xuICAgIGQzICs9IGg5ICogKDUgKiByNCk7XG4gICAgYyArPSAoZDMgPj4+IDEzKTsgZDMgJj0gMHgxZmZmO1xuXG4gICAgZDQgPSBjO1xuICAgIGQ0ICs9IGgwICogcjQ7XG4gICAgZDQgKz0gaDEgKiByMztcbiAgICBkNCArPSBoMiAqIHIyO1xuICAgIGQ0ICs9IGgzICogcjE7XG4gICAgZDQgKz0gaDQgKiByMDtcbiAgICBjID0gKGQ0ID4+PiAxMyk7IGQ0ICY9IDB4MWZmZjtcbiAgICBkNCArPSBoNSAqICg1ICogcjkpO1xuICAgIGQ0ICs9IGg2ICogKDUgKiByOCk7XG4gICAgZDQgKz0gaDcgKiAoNSAqIHI3KTtcbiAgICBkNCArPSBoOCAqICg1ICogcjYpO1xuICAgIGQ0ICs9IGg5ICogKDUgKiByNSk7XG4gICAgYyArPSAoZDQgPj4+IDEzKTsgZDQgJj0gMHgxZmZmO1xuXG4gICAgZDUgPSBjO1xuICAgIGQ1ICs9IGgwICogcjU7XG4gICAgZDUgKz0gaDEgKiByNDtcbiAgICBkNSArPSBoMiAqIHIzO1xuICAgIGQ1ICs9IGgzICogcjI7XG4gICAgZDUgKz0gaDQgKiByMTtcbiAgICBjID0gKGQ1ID4+PiAxMyk7IGQ1ICY9IDB4MWZmZjtcbiAgICBkNSArPSBoNSAqIHIwO1xuICAgIGQ1ICs9IGg2ICogKDUgKiByOSk7XG4gICAgZDUgKz0gaDcgKiAoNSAqIHI4KTtcbiAgICBkNSArPSBoOCAqICg1ICogcjcpO1xuICAgIGQ1ICs9IGg5ICogKDUgKiByNik7XG4gICAgYyArPSAoZDUgPj4+IDEzKTsgZDUgJj0gMHgxZmZmO1xuXG4gICAgZDYgPSBjO1xuICAgIGQ2ICs9IGgwICogcjY7XG4gICAgZDYgKz0gaDEgKiByNTtcbiAgICBkNiArPSBoMiAqIHI0O1xuICAgIGQ2ICs9IGgzICogcjM7XG4gICAgZDYgKz0gaDQgKiByMjtcbiAgICBjID0gKGQ2ID4+PiAxMyk7IGQ2ICY9IDB4MWZmZjtcbiAgICBkNiArPSBoNSAqIHIxO1xuICAgIGQ2ICs9IGg2ICogcjA7XG4gICAgZDYgKz0gaDcgKiAoNSAqIHI5KTtcbiAgICBkNiArPSBoOCAqICg1ICogcjgpO1xuICAgIGQ2ICs9IGg5ICogKDUgKiByNyk7XG4gICAgYyArPSAoZDYgPj4+IDEzKTsgZDYgJj0gMHgxZmZmO1xuXG4gICAgZDcgPSBjO1xuICAgIGQ3ICs9IGgwICogcjc7XG4gICAgZDcgKz0gaDEgKiByNjtcbiAgICBkNyArPSBoMiAqIHI1O1xuICAgIGQ3ICs9IGgzICogcjQ7XG4gICAgZDcgKz0gaDQgKiByMztcbiAgICBjID0gKGQ3ID4+PiAxMyk7IGQ3ICY9IDB4MWZmZjtcbiAgICBkNyArPSBoNSAqIHIyO1xuICAgIGQ3ICs9IGg2ICogcjE7XG4gICAgZDcgKz0gaDcgKiByMDtcbiAgICBkNyArPSBoOCAqICg1ICogcjkpO1xuICAgIGQ3ICs9IGg5ICogKDUgKiByOCk7XG4gICAgYyArPSAoZDcgPj4+IDEzKTsgZDcgJj0gMHgxZmZmO1xuXG4gICAgZDggPSBjO1xuICAgIGQ4ICs9IGgwICogcjg7XG4gICAgZDggKz0gaDEgKiByNztcbiAgICBkOCArPSBoMiAqIHI2O1xuICAgIGQ4ICs9IGgzICogcjU7XG4gICAgZDggKz0gaDQgKiByNDtcbiAgICBjID0gKGQ4ID4+PiAxMyk7IGQ4ICY9IDB4MWZmZjtcbiAgICBkOCArPSBoNSAqIHIzO1xuICAgIGQ4ICs9IGg2ICogcjI7XG4gICAgZDggKz0gaDcgKiByMTtcbiAgICBkOCArPSBoOCAqIHIwO1xuICAgIGQ4ICs9IGg5ICogKDUgKiByOSk7XG4gICAgYyArPSAoZDggPj4+IDEzKTsgZDggJj0gMHgxZmZmO1xuXG4gICAgZDkgPSBjO1xuICAgIGQ5ICs9IGgwICogcjk7XG4gICAgZDkgKz0gaDEgKiByODtcbiAgICBkOSArPSBoMiAqIHI3O1xuICAgIGQ5ICs9IGgzICogcjY7XG4gICAgZDkgKz0gaDQgKiByNTtcbiAgICBjID0gKGQ5ID4+PiAxMyk7IGQ5ICY9IDB4MWZmZjtcbiAgICBkOSArPSBoNSAqIHI0O1xuICAgIGQ5ICs9IGg2ICogcjM7XG4gICAgZDkgKz0gaDcgKiByMjtcbiAgICBkOSArPSBoOCAqIHIxO1xuICAgIGQ5ICs9IGg5ICogcjA7XG4gICAgYyArPSAoZDkgPj4+IDEzKTsgZDkgJj0gMHgxZmZmO1xuXG4gICAgYyA9ICgoKGMgPDwgMikgKyBjKSkgfCAwO1xuICAgIGMgPSAoYyArIGQwKSB8IDA7XG4gICAgZDAgPSBjICYgMHgxZmZmO1xuICAgIGMgPSAoYyA+Pj4gMTMpO1xuICAgIGQxICs9IGM7XG5cbiAgICBoMCA9IGQwO1xuICAgIGgxID0gZDE7XG4gICAgaDIgPSBkMjtcbiAgICBoMyA9IGQzO1xuICAgIGg0ID0gZDQ7XG4gICAgaDUgPSBkNTtcbiAgICBoNiA9IGQ2O1xuICAgIGg3ID0gZDc7XG4gICAgaDggPSBkODtcbiAgICBoOSA9IGQ5O1xuXG4gICAgbXBvcyArPSAxNjtcbiAgICBieXRlcyAtPSAxNjtcbiAgfVxuICB0aGlzLmhbMF0gPSBoMDtcbiAgdGhpcy5oWzFdID0gaDE7XG4gIHRoaXMuaFsyXSA9IGgyO1xuICB0aGlzLmhbM10gPSBoMztcbiAgdGhpcy5oWzRdID0gaDQ7XG4gIHRoaXMuaFs1XSA9IGg1O1xuICB0aGlzLmhbNl0gPSBoNjtcbiAgdGhpcy5oWzddID0gaDc7XG4gIHRoaXMuaFs4XSA9IGg4O1xuICB0aGlzLmhbOV0gPSBoOTtcbn07XG5cbnBvbHkxMzA1LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbihtYWMsIG1hY3Bvcykge1xuICB2YXIgZyA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gIHZhciBjLCBtYXNrLCBmLCBpO1xuXG4gIGlmICh0aGlzLmxlZnRvdmVyKSB7XG4gICAgaSA9IHRoaXMubGVmdG92ZXI7XG4gICAgdGhpcy5idWZmZXJbaSsrXSA9IDE7XG4gICAgZm9yICg7IGkgPCAxNjsgaSsrKSB0aGlzLmJ1ZmZlcltpXSA9IDA7XG4gICAgdGhpcy5maW4gPSAxO1xuICAgIHRoaXMuYmxvY2tzKHRoaXMuYnVmZmVyLCAwLCAxNik7XG4gIH1cblxuICBjID0gdGhpcy5oWzFdID4+PiAxMztcbiAgdGhpcy5oWzFdICY9IDB4MWZmZjtcbiAgZm9yIChpID0gMjsgaSA8IDEwOyBpKyspIHtcbiAgICB0aGlzLmhbaV0gKz0gYztcbiAgICBjID0gdGhpcy5oW2ldID4+PiAxMztcbiAgICB0aGlzLmhbaV0gJj0gMHgxZmZmO1xuICB9XG4gIHRoaXMuaFswXSArPSAoYyAqIDUpO1xuICBjID0gdGhpcy5oWzBdID4+PiAxMztcbiAgdGhpcy5oWzBdICY9IDB4MWZmZjtcbiAgdGhpcy5oWzFdICs9IGM7XG4gIGMgPSB0aGlzLmhbMV0gPj4+IDEzO1xuICB0aGlzLmhbMV0gJj0gMHgxZmZmO1xuICB0aGlzLmhbMl0gKz0gYztcblxuICBnWzBdID0gdGhpcy5oWzBdICsgNTtcbiAgYyA9IGdbMF0gPj4+IDEzO1xuICBnWzBdICY9IDB4MWZmZjtcbiAgZm9yIChpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICBnW2ldID0gdGhpcy5oW2ldICsgYztcbiAgICBjID0gZ1tpXSA+Pj4gMTM7XG4gICAgZ1tpXSAmPSAweDFmZmY7XG4gIH1cbiAgZ1s5XSAtPSAoMSA8PCAxMyk7XG5cbiAgbWFzayA9IChjIF4gMSkgLSAxO1xuICBmb3IgKGkgPSAwOyBpIDwgMTA7IGkrKykgZ1tpXSAmPSBtYXNrO1xuICBtYXNrID0gfm1hc2s7XG4gIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSB0aGlzLmhbaV0gPSAodGhpcy5oW2ldICYgbWFzaykgfCBnW2ldO1xuXG4gIHRoaXMuaFswXSA9ICgodGhpcy5oWzBdICAgICAgICkgfCAodGhpcy5oWzFdIDw8IDEzKSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzFdID0gKCh0aGlzLmhbMV0gPj4+ICAzKSB8ICh0aGlzLmhbMl0gPDwgMTApICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuICB0aGlzLmhbMl0gPSAoKHRoaXMuaFsyXSA+Pj4gIDYpIHwgKHRoaXMuaFszXSA8PCAgNykgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFszXSA9ICgodGhpcy5oWzNdID4+PiAgOSkgfCAodGhpcy5oWzRdIDw8ICA0KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzRdID0gKCh0aGlzLmhbNF0gPj4+IDEyKSB8ICh0aGlzLmhbNV0gPDwgIDEpIHwgKHRoaXMuaFs2XSA8PCAxNCkpICYgMHhmZmZmO1xuICB0aGlzLmhbNV0gPSAoKHRoaXMuaFs2XSA+Pj4gIDIpIHwgKHRoaXMuaFs3XSA8PCAxMSkgICAgICAgICAgICAgICAgICAgICkgJiAweGZmZmY7XG4gIHRoaXMuaFs2XSA9ICgodGhpcy5oWzddID4+PiAgNSkgfCAodGhpcy5oWzhdIDw8ICA4KSAgICAgICAgICAgICAgICAgICAgKSAmIDB4ZmZmZjtcbiAgdGhpcy5oWzddID0gKCh0aGlzLmhbOF0gPj4+ICA4KSB8ICh0aGlzLmhbOV0gPDwgIDUpICAgICAgICAgICAgICAgICAgICApICYgMHhmZmZmO1xuXG4gIGYgPSB0aGlzLmhbMF0gKyB0aGlzLnBhZFswXTtcbiAgdGhpcy5oWzBdID0gZiAmIDB4ZmZmZjtcbiAgZm9yIChpID0gMTsgaSA8IDg7IGkrKykge1xuICAgIGYgPSAoKCh0aGlzLmhbaV0gKyB0aGlzLnBhZFtpXSkgfCAwKSArIChmID4+PiAxNikpIHwgMDtcbiAgICB0aGlzLmhbaV0gPSBmICYgMHhmZmZmO1xuICB9XG5cbiAgbWFjW21hY3BvcysgMF0gPSAodGhpcy5oWzBdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDFdID0gKHRoaXMuaFswXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyAyXSA9ICh0aGlzLmhbMV0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgM10gPSAodGhpcy5oWzFdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDRdID0gKHRoaXMuaFsyXSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA1XSA9ICh0aGlzLmhbMl0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysgNl0gPSAodGhpcy5oWzNdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrIDddID0gKHRoaXMuaFszXSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKyA4XSA9ICh0aGlzLmhbNF0gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysgOV0gPSAodGhpcy5oWzRdID4+PiA4KSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTBdID0gKHRoaXMuaFs1XSA+Pj4gMCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzExXSA9ICh0aGlzLmhbNV0gPj4+IDgpICYgMHhmZjtcbiAgbWFjW21hY3BvcysxMl0gPSAodGhpcy5oWzZdID4+PiAwKSAmIDB4ZmY7XG4gIG1hY1ttYWNwb3MrMTNdID0gKHRoaXMuaFs2XSA+Pj4gOCkgJiAweGZmO1xuICBtYWNbbWFjcG9zKzE0XSA9ICh0aGlzLmhbN10gPj4+IDApICYgMHhmZjtcbiAgbWFjW21hY3BvcysxNV0gPSAodGhpcy5oWzddID4+PiA4KSAmIDB4ZmY7XG59O1xuXG5wb2x5MTMwNS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24obSwgbXBvcywgYnl0ZXMpIHtcbiAgdmFyIGksIHdhbnQ7XG5cbiAgaWYgKHRoaXMubGVmdG92ZXIpIHtcbiAgICB3YW50ID0gKDE2IC0gdGhpcy5sZWZ0b3Zlcik7XG4gICAgaWYgKHdhbnQgPiBieXRlcylcbiAgICAgIHdhbnQgPSBieXRlcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgd2FudDsgaSsrKVxuICAgICAgdGhpcy5idWZmZXJbdGhpcy5sZWZ0b3ZlciArIGldID0gbVttcG9zK2ldO1xuICAgIGJ5dGVzIC09IHdhbnQ7XG4gICAgbXBvcyArPSB3YW50O1xuICAgIHRoaXMubGVmdG92ZXIgKz0gd2FudDtcbiAgICBpZiAodGhpcy5sZWZ0b3ZlciA8IDE2KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYmxvY2tzKHRoaXMuYnVmZmVyLCAwLCAxNik7XG4gICAgdGhpcy5sZWZ0b3ZlciA9IDA7XG4gIH1cblxuICBpZiAoYnl0ZXMgPj0gMTYpIHtcbiAgICB3YW50ID0gYnl0ZXMgLSAoYnl0ZXMgJSAxNik7XG4gICAgdGhpcy5ibG9ja3MobSwgbXBvcywgd2FudCk7XG4gICAgbXBvcyArPSB3YW50O1xuICAgIGJ5dGVzIC09IHdhbnQ7XG4gIH1cblxuICBpZiAoYnl0ZXMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYnl0ZXM7IGkrKylcbiAgICAgIHRoaXMuYnVmZmVyW3RoaXMubGVmdG92ZXIgKyBpXSA9IG1bbXBvcytpXTtcbiAgICB0aGlzLmxlZnRvdmVyICs9IGJ5dGVzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjcnlwdG9fb25ldGltZWF1dGgob3V0LCBvdXRwb3MsIG0sIG1wb3MsIG4sIGspIHtcbiAgdmFyIHMgPSBuZXcgcG9seTEzMDUoayk7XG4gIHMudXBkYXRlKG0sIG1wb3MsIG4pO1xuICBzLmZpbmlzaChvdXQsIG91dHBvcyk7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5KGgsIGhwb3MsIG0sIG1wb3MsIG4sIGspIHtcbiAgdmFyIHggPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGNyeXB0b19vbmV0aW1lYXV0aCh4LDAsbSxtcG9zLG4sayk7XG4gIHJldHVybiBjcnlwdG9fdmVyaWZ5XzE2KGgsaHBvcyx4LDApO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fc2VjcmV0Ym94KGMsbSxkLG4saykge1xuICB2YXIgaTtcbiAgaWYgKGQgPCAzMikgcmV0dXJuIC0xO1xuICBjcnlwdG9fc3RyZWFtX3hvcihjLDAsbSwwLGQsbixrKTtcbiAgY3J5cHRvX29uZXRpbWVhdXRoKGMsIDE2LCBjLCAzMiwgZCAtIDMyLCBjKTtcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIGNbaV0gPSAwO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NlY3JldGJveF9vcGVuKG0sYyxkLG4saykge1xuICB2YXIgaTtcbiAgdmFyIHggPSBuZXcgVWludDhBcnJheSgzMik7XG4gIGlmIChkIDwgMzIpIHJldHVybiAtMTtcbiAgY3J5cHRvX3N0cmVhbSh4LDAsMzIsbixrKTtcbiAgaWYgKGNyeXB0b19vbmV0aW1lYXV0aF92ZXJpZnkoYywgMTYsYywgMzIsZCAtIDMyLHgpICE9PSAwKSByZXR1cm4gLTE7XG4gIGNyeXB0b19zdHJlYW1feG9yKG0sMCxjLDAsZCxuLGspO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgbVtpXSA9IDA7XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBzZXQyNTUxOShyLCBhKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgcltpXSA9IGFbaV18MDtcbn1cblxuZnVuY3Rpb24gY2FyMjU1MTkobykge1xuICB2YXIgaSwgdiwgYyA9IDE7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgdiA9IG9baV0gKyBjICsgNjU1MzU7XG4gICAgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTtcbiAgICBvW2ldID0gdiAtIGMgKiA2NTUzNjtcbiAgfVxuICBvWzBdICs9IGMtMSArIDM3ICogKGMtMSk7XG59XG5cbmZ1bmN0aW9uIHNlbDI1NTE5KHAsIHEsIGIpIHtcbiAgdmFyIHQsIGMgPSB+KGItMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHQgPSBjICYgKHBbaV0gXiBxW2ldKTtcbiAgICBwW2ldIF49IHQ7XG4gICAgcVtpXSBePSB0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhY2syNTUxOShvLCBuKSB7XG4gIHZhciBpLCBqLCBiO1xuICB2YXIgbSA9IGdmKCksIHQgPSBnZigpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgdFtpXSA9IG5baV07XG4gIGNhcjI1NTE5KHQpO1xuICBjYXIyNTUxOSh0KTtcbiAgY2FyMjU1MTkodCk7XG4gIGZvciAoaiA9IDA7IGogPCAyOyBqKyspIHtcbiAgICBtWzBdID0gdFswXSAtIDB4ZmZlZDtcbiAgICBmb3IgKGkgPSAxOyBpIDwgMTU7IGkrKykge1xuICAgICAgbVtpXSA9IHRbaV0gLSAweGZmZmYgLSAoKG1baS0xXT4+MTYpICYgMSk7XG4gICAgICBtW2ktMV0gJj0gMHhmZmZmO1xuICAgIH1cbiAgICBtWzE1XSA9IHRbMTVdIC0gMHg3ZmZmIC0gKChtWzE0XT4+MTYpICYgMSk7XG4gICAgYiA9IChtWzE1XT4+MTYpICYgMTtcbiAgICBtWzE0XSAmPSAweGZmZmY7XG4gICAgc2VsMjU1MTkodCwgbSwgMS1iKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIG9bMippXSA9IHRbaV0gJiAweGZmO1xuICAgIG9bMippKzFdID0gdFtpXT4+ODtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXEyNTUxOShhLCBiKSB7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBkID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBwYWNrMjU1MTkoYywgYSk7XG4gIHBhY2syNTUxOShkLCBiKTtcbiAgcmV0dXJuIGNyeXB0b192ZXJpZnlfMzIoYywgMCwgZCwgMCk7XG59XG5cbmZ1bmN0aW9uIHBhcjI1NTE5KGEpIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSgzMik7XG4gIHBhY2syNTUxOShkLCBhKTtcbiAgcmV0dXJuIGRbMF0gJiAxO1xufVxuXG5mdW5jdGlvbiB1bnBhY2syNTUxOShvLCBuKSB7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykgb1tpXSA9IG5bMippXSArIChuWzIqaSsxXSA8PCA4KTtcbiAgb1sxNV0gJj0gMHg3ZmZmO1xufVxuXG5mdW5jdGlvbiBBKG8sIGEsIGIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSBvW2ldID0gYVtpXSArIGJbaV07XG59XG5cbmZ1bmN0aW9uIFoobywgYSwgYikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIG9baV0gPSBhW2ldIC0gYltpXTtcbn1cblxuZnVuY3Rpb24gTShvLCBhLCBiKSB7XG4gIHZhciB2LCBjLFxuICAgICB0MCA9IDAsICB0MSA9IDAsICB0MiA9IDAsICB0MyA9IDAsICB0NCA9IDAsICB0NSA9IDAsICB0NiA9IDAsICB0NyA9IDAsXG4gICAgIHQ4ID0gMCwgIHQ5ID0gMCwgdDEwID0gMCwgdDExID0gMCwgdDEyID0gMCwgdDEzID0gMCwgdDE0ID0gMCwgdDE1ID0gMCxcbiAgICB0MTYgPSAwLCB0MTcgPSAwLCB0MTggPSAwLCB0MTkgPSAwLCB0MjAgPSAwLCB0MjEgPSAwLCB0MjIgPSAwLCB0MjMgPSAwLFxuICAgIHQyNCA9IDAsIHQyNSA9IDAsIHQyNiA9IDAsIHQyNyA9IDAsIHQyOCA9IDAsIHQyOSA9IDAsIHQzMCA9IDAsXG4gICAgYjAgPSBiWzBdLFxuICAgIGIxID0gYlsxXSxcbiAgICBiMiA9IGJbMl0sXG4gICAgYjMgPSBiWzNdLFxuICAgIGI0ID0gYls0XSxcbiAgICBiNSA9IGJbNV0sXG4gICAgYjYgPSBiWzZdLFxuICAgIGI3ID0gYls3XSxcbiAgICBiOCA9IGJbOF0sXG4gICAgYjkgPSBiWzldLFxuICAgIGIxMCA9IGJbMTBdLFxuICAgIGIxMSA9IGJbMTFdLFxuICAgIGIxMiA9IGJbMTJdLFxuICAgIGIxMyA9IGJbMTNdLFxuICAgIGIxNCA9IGJbMTRdLFxuICAgIGIxNSA9IGJbMTVdO1xuXG4gIHYgPSBhWzBdO1xuICB0MCArPSB2ICogYjA7XG4gIHQxICs9IHYgKiBiMTtcbiAgdDIgKz0gdiAqIGIyO1xuICB0MyArPSB2ICogYjM7XG4gIHQ0ICs9IHYgKiBiNDtcbiAgdDUgKz0gdiAqIGI1O1xuICB0NiArPSB2ICogYjY7XG4gIHQ3ICs9IHYgKiBiNztcbiAgdDggKz0gdiAqIGI4O1xuICB0OSArPSB2ICogYjk7XG4gIHQxMCArPSB2ICogYjEwO1xuICB0MTEgKz0gdiAqIGIxMTtcbiAgdDEyICs9IHYgKiBiMTI7XG4gIHQxMyArPSB2ICogYjEzO1xuICB0MTQgKz0gdiAqIGIxNDtcbiAgdDE1ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzFdO1xuICB0MSArPSB2ICogYjA7XG4gIHQyICs9IHYgKiBiMTtcbiAgdDMgKz0gdiAqIGIyO1xuICB0NCArPSB2ICogYjM7XG4gIHQ1ICs9IHYgKiBiNDtcbiAgdDYgKz0gdiAqIGI1O1xuICB0NyArPSB2ICogYjY7XG4gIHQ4ICs9IHYgKiBiNztcbiAgdDkgKz0gdiAqIGI4O1xuICB0MTAgKz0gdiAqIGI5O1xuICB0MTEgKz0gdiAqIGIxMDtcbiAgdDEyICs9IHYgKiBiMTE7XG4gIHQxMyArPSB2ICogYjEyO1xuICB0MTQgKz0gdiAqIGIxMztcbiAgdDE1ICs9IHYgKiBiMTQ7XG4gIHQxNiArPSB2ICogYjE1O1xuICB2ID0gYVsyXTtcbiAgdDIgKz0gdiAqIGIwO1xuICB0MyArPSB2ICogYjE7XG4gIHQ0ICs9IHYgKiBiMjtcbiAgdDUgKz0gdiAqIGIzO1xuICB0NiArPSB2ICogYjQ7XG4gIHQ3ICs9IHYgKiBiNTtcbiAgdDggKz0gdiAqIGI2O1xuICB0OSArPSB2ICogYjc7XG4gIHQxMCArPSB2ICogYjg7XG4gIHQxMSArPSB2ICogYjk7XG4gIHQxMiArPSB2ICogYjEwO1xuICB0MTMgKz0gdiAqIGIxMTtcbiAgdDE0ICs9IHYgKiBiMTI7XG4gIHQxNSArPSB2ICogYjEzO1xuICB0MTYgKz0gdiAqIGIxNDtcbiAgdDE3ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzNdO1xuICB0MyArPSB2ICogYjA7XG4gIHQ0ICs9IHYgKiBiMTtcbiAgdDUgKz0gdiAqIGIyO1xuICB0NiArPSB2ICogYjM7XG4gIHQ3ICs9IHYgKiBiNDtcbiAgdDggKz0gdiAqIGI1O1xuICB0OSArPSB2ICogYjY7XG4gIHQxMCArPSB2ICogYjc7XG4gIHQxMSArPSB2ICogYjg7XG4gIHQxMiArPSB2ICogYjk7XG4gIHQxMyArPSB2ICogYjEwO1xuICB0MTQgKz0gdiAqIGIxMTtcbiAgdDE1ICs9IHYgKiBiMTI7XG4gIHQxNiArPSB2ICogYjEzO1xuICB0MTcgKz0gdiAqIGIxNDtcbiAgdDE4ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzRdO1xuICB0NCArPSB2ICogYjA7XG4gIHQ1ICs9IHYgKiBiMTtcbiAgdDYgKz0gdiAqIGIyO1xuICB0NyArPSB2ICogYjM7XG4gIHQ4ICs9IHYgKiBiNDtcbiAgdDkgKz0gdiAqIGI1O1xuICB0MTAgKz0gdiAqIGI2O1xuICB0MTEgKz0gdiAqIGI3O1xuICB0MTIgKz0gdiAqIGI4O1xuICB0MTMgKz0gdiAqIGI5O1xuICB0MTQgKz0gdiAqIGIxMDtcbiAgdDE1ICs9IHYgKiBiMTE7XG4gIHQxNiArPSB2ICogYjEyO1xuICB0MTcgKz0gdiAqIGIxMztcbiAgdDE4ICs9IHYgKiBiMTQ7XG4gIHQxOSArPSB2ICogYjE1O1xuICB2ID0gYVs1XTtcbiAgdDUgKz0gdiAqIGIwO1xuICB0NiArPSB2ICogYjE7XG4gIHQ3ICs9IHYgKiBiMjtcbiAgdDggKz0gdiAqIGIzO1xuICB0OSArPSB2ICogYjQ7XG4gIHQxMCArPSB2ICogYjU7XG4gIHQxMSArPSB2ICogYjY7XG4gIHQxMiArPSB2ICogYjc7XG4gIHQxMyArPSB2ICogYjg7XG4gIHQxNCArPSB2ICogYjk7XG4gIHQxNSArPSB2ICogYjEwO1xuICB0MTYgKz0gdiAqIGIxMTtcbiAgdDE3ICs9IHYgKiBiMTI7XG4gIHQxOCArPSB2ICogYjEzO1xuICB0MTkgKz0gdiAqIGIxNDtcbiAgdDIwICs9IHYgKiBiMTU7XG4gIHYgPSBhWzZdO1xuICB0NiArPSB2ICogYjA7XG4gIHQ3ICs9IHYgKiBiMTtcbiAgdDggKz0gdiAqIGIyO1xuICB0OSArPSB2ICogYjM7XG4gIHQxMCArPSB2ICogYjQ7XG4gIHQxMSArPSB2ICogYjU7XG4gIHQxMiArPSB2ICogYjY7XG4gIHQxMyArPSB2ICogYjc7XG4gIHQxNCArPSB2ICogYjg7XG4gIHQxNSArPSB2ICogYjk7XG4gIHQxNiArPSB2ICogYjEwO1xuICB0MTcgKz0gdiAqIGIxMTtcbiAgdDE4ICs9IHYgKiBiMTI7XG4gIHQxOSArPSB2ICogYjEzO1xuICB0MjAgKz0gdiAqIGIxNDtcbiAgdDIxICs9IHYgKiBiMTU7XG4gIHYgPSBhWzddO1xuICB0NyArPSB2ICogYjA7XG4gIHQ4ICs9IHYgKiBiMTtcbiAgdDkgKz0gdiAqIGIyO1xuICB0MTAgKz0gdiAqIGIzO1xuICB0MTEgKz0gdiAqIGI0O1xuICB0MTIgKz0gdiAqIGI1O1xuICB0MTMgKz0gdiAqIGI2O1xuICB0MTQgKz0gdiAqIGI3O1xuICB0MTUgKz0gdiAqIGI4O1xuICB0MTYgKz0gdiAqIGI5O1xuICB0MTcgKz0gdiAqIGIxMDtcbiAgdDE4ICs9IHYgKiBiMTE7XG4gIHQxOSArPSB2ICogYjEyO1xuICB0MjAgKz0gdiAqIGIxMztcbiAgdDIxICs9IHYgKiBiMTQ7XG4gIHQyMiArPSB2ICogYjE1O1xuICB2ID0gYVs4XTtcbiAgdDggKz0gdiAqIGIwO1xuICB0OSArPSB2ICogYjE7XG4gIHQxMCArPSB2ICogYjI7XG4gIHQxMSArPSB2ICogYjM7XG4gIHQxMiArPSB2ICogYjQ7XG4gIHQxMyArPSB2ICogYjU7XG4gIHQxNCArPSB2ICogYjY7XG4gIHQxNSArPSB2ICogYjc7XG4gIHQxNiArPSB2ICogYjg7XG4gIHQxNyArPSB2ICogYjk7XG4gIHQxOCArPSB2ICogYjEwO1xuICB0MTkgKz0gdiAqIGIxMTtcbiAgdDIwICs9IHYgKiBiMTI7XG4gIHQyMSArPSB2ICogYjEzO1xuICB0MjIgKz0gdiAqIGIxNDtcbiAgdDIzICs9IHYgKiBiMTU7XG4gIHYgPSBhWzldO1xuICB0OSArPSB2ICogYjA7XG4gIHQxMCArPSB2ICogYjE7XG4gIHQxMSArPSB2ICogYjI7XG4gIHQxMiArPSB2ICogYjM7XG4gIHQxMyArPSB2ICogYjQ7XG4gIHQxNCArPSB2ICogYjU7XG4gIHQxNSArPSB2ICogYjY7XG4gIHQxNiArPSB2ICogYjc7XG4gIHQxNyArPSB2ICogYjg7XG4gIHQxOCArPSB2ICogYjk7XG4gIHQxOSArPSB2ICogYjEwO1xuICB0MjAgKz0gdiAqIGIxMTtcbiAgdDIxICs9IHYgKiBiMTI7XG4gIHQyMiArPSB2ICogYjEzO1xuICB0MjMgKz0gdiAqIGIxNDtcbiAgdDI0ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEwXTtcbiAgdDEwICs9IHYgKiBiMDtcbiAgdDExICs9IHYgKiBiMTtcbiAgdDEyICs9IHYgKiBiMjtcbiAgdDEzICs9IHYgKiBiMztcbiAgdDE0ICs9IHYgKiBiNDtcbiAgdDE1ICs9IHYgKiBiNTtcbiAgdDE2ICs9IHYgKiBiNjtcbiAgdDE3ICs9IHYgKiBiNztcbiAgdDE4ICs9IHYgKiBiODtcbiAgdDE5ICs9IHYgKiBiOTtcbiAgdDIwICs9IHYgKiBiMTA7XG4gIHQyMSArPSB2ICogYjExO1xuICB0MjIgKz0gdiAqIGIxMjtcbiAgdDIzICs9IHYgKiBiMTM7XG4gIHQyNCArPSB2ICogYjE0O1xuICB0MjUgKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTFdO1xuICB0MTEgKz0gdiAqIGIwO1xuICB0MTIgKz0gdiAqIGIxO1xuICB0MTMgKz0gdiAqIGIyO1xuICB0MTQgKz0gdiAqIGIzO1xuICB0MTUgKz0gdiAqIGI0O1xuICB0MTYgKz0gdiAqIGI1O1xuICB0MTcgKz0gdiAqIGI2O1xuICB0MTggKz0gdiAqIGI3O1xuICB0MTkgKz0gdiAqIGI4O1xuICB0MjAgKz0gdiAqIGI5O1xuICB0MjEgKz0gdiAqIGIxMDtcbiAgdDIyICs9IHYgKiBiMTE7XG4gIHQyMyArPSB2ICogYjEyO1xuICB0MjQgKz0gdiAqIGIxMztcbiAgdDI1ICs9IHYgKiBiMTQ7XG4gIHQyNiArPSB2ICogYjE1O1xuICB2ID0gYVsxMl07XG4gIHQxMiArPSB2ICogYjA7XG4gIHQxMyArPSB2ICogYjE7XG4gIHQxNCArPSB2ICogYjI7XG4gIHQxNSArPSB2ICogYjM7XG4gIHQxNiArPSB2ICogYjQ7XG4gIHQxNyArPSB2ICogYjU7XG4gIHQxOCArPSB2ICogYjY7XG4gIHQxOSArPSB2ICogYjc7XG4gIHQyMCArPSB2ICogYjg7XG4gIHQyMSArPSB2ICogYjk7XG4gIHQyMiArPSB2ICogYjEwO1xuICB0MjMgKz0gdiAqIGIxMTtcbiAgdDI0ICs9IHYgKiBiMTI7XG4gIHQyNSArPSB2ICogYjEzO1xuICB0MjYgKz0gdiAqIGIxNDtcbiAgdDI3ICs9IHYgKiBiMTU7XG4gIHYgPSBhWzEzXTtcbiAgdDEzICs9IHYgKiBiMDtcbiAgdDE0ICs9IHYgKiBiMTtcbiAgdDE1ICs9IHYgKiBiMjtcbiAgdDE2ICs9IHYgKiBiMztcbiAgdDE3ICs9IHYgKiBiNDtcbiAgdDE4ICs9IHYgKiBiNTtcbiAgdDE5ICs9IHYgKiBiNjtcbiAgdDIwICs9IHYgKiBiNztcbiAgdDIxICs9IHYgKiBiODtcbiAgdDIyICs9IHYgKiBiOTtcbiAgdDIzICs9IHYgKiBiMTA7XG4gIHQyNCArPSB2ICogYjExO1xuICB0MjUgKz0gdiAqIGIxMjtcbiAgdDI2ICs9IHYgKiBiMTM7XG4gIHQyNyArPSB2ICogYjE0O1xuICB0MjggKz0gdiAqIGIxNTtcbiAgdiA9IGFbMTRdO1xuICB0MTQgKz0gdiAqIGIwO1xuICB0MTUgKz0gdiAqIGIxO1xuICB0MTYgKz0gdiAqIGIyO1xuICB0MTcgKz0gdiAqIGIzO1xuICB0MTggKz0gdiAqIGI0O1xuICB0MTkgKz0gdiAqIGI1O1xuICB0MjAgKz0gdiAqIGI2O1xuICB0MjEgKz0gdiAqIGI3O1xuICB0MjIgKz0gdiAqIGI4O1xuICB0MjMgKz0gdiAqIGI5O1xuICB0MjQgKz0gdiAqIGIxMDtcbiAgdDI1ICs9IHYgKiBiMTE7XG4gIHQyNiArPSB2ICogYjEyO1xuICB0MjcgKz0gdiAqIGIxMztcbiAgdDI4ICs9IHYgKiBiMTQ7XG4gIHQyOSArPSB2ICogYjE1O1xuICB2ID0gYVsxNV07XG4gIHQxNSArPSB2ICogYjA7XG4gIHQxNiArPSB2ICogYjE7XG4gIHQxNyArPSB2ICogYjI7XG4gIHQxOCArPSB2ICogYjM7XG4gIHQxOSArPSB2ICogYjQ7XG4gIHQyMCArPSB2ICogYjU7XG4gIHQyMSArPSB2ICogYjY7XG4gIHQyMiArPSB2ICogYjc7XG4gIHQyMyArPSB2ICogYjg7XG4gIHQyNCArPSB2ICogYjk7XG4gIHQyNSArPSB2ICogYjEwO1xuICB0MjYgKz0gdiAqIGIxMTtcbiAgdDI3ICs9IHYgKiBiMTI7XG4gIHQyOCArPSB2ICogYjEzO1xuICB0MjkgKz0gdiAqIGIxNDtcbiAgdDMwICs9IHYgKiBiMTU7XG5cbiAgdDAgICs9IDM4ICogdDE2O1xuICB0MSAgKz0gMzggKiB0MTc7XG4gIHQyICArPSAzOCAqIHQxODtcbiAgdDMgICs9IDM4ICogdDE5O1xuICB0NCAgKz0gMzggKiB0MjA7XG4gIHQ1ICArPSAzOCAqIHQyMTtcbiAgdDYgICs9IDM4ICogdDIyO1xuICB0NyAgKz0gMzggKiB0MjM7XG4gIHQ4ICArPSAzOCAqIHQyNDtcbiAgdDkgICs9IDM4ICogdDI1O1xuICB0MTAgKz0gMzggKiB0MjY7XG4gIHQxMSArPSAzOCAqIHQyNztcbiAgdDEyICs9IDM4ICogdDI4O1xuICB0MTMgKz0gMzggKiB0Mjk7XG4gIHQxNCArPSAzOCAqIHQzMDtcbiAgLy8gdDE1IGxlZnQgYXMgaXNcblxuICAvLyBmaXJzdCBjYXJcbiAgYyA9IDE7XG4gIHYgPSAgdDAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0MyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDYgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDcgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0NyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDggKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSAgdDkgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7ICB0OSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTAgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTEgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMSA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTIgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMiA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTMgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxMyA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTQgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNCA9IHYgLSBjICogNjU1MzY7XG4gIHYgPSB0MTUgKyBjICsgNjU1MzU7IGMgPSBNYXRoLmZsb29yKHYgLyA2NTUzNik7IHQxNSA9IHYgLSBjICogNjU1MzY7XG4gIHQwICs9IGMtMSArIDM3ICogKGMtMSk7XG5cbiAgLy8gc2Vjb25kIGNhclxuICBjID0gMTtcbiAgdiA9ICB0MCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQxID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0MyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ2ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0NyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ3ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ4ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9ICB0OSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgIHQ5ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEwID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDExID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMiArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEyID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxMyArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDEzID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNCArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE0ID0gdiAtIGMgKiA2NTUzNjtcbiAgdiA9IHQxNSArIGMgKyA2NTUzNTsgYyA9IE1hdGguZmxvb3IodiAvIDY1NTM2KTsgdDE1ID0gdiAtIGMgKiA2NTUzNjtcbiAgdDAgKz0gYy0xICsgMzcgKiAoYy0xKTtcblxuICBvWyAwXSA9IHQwO1xuICBvWyAxXSA9IHQxO1xuICBvWyAyXSA9IHQyO1xuICBvWyAzXSA9IHQzO1xuICBvWyA0XSA9IHQ0O1xuICBvWyA1XSA9IHQ1O1xuICBvWyA2XSA9IHQ2O1xuICBvWyA3XSA9IHQ3O1xuICBvWyA4XSA9IHQ4O1xuICBvWyA5XSA9IHQ5O1xuICBvWzEwXSA9IHQxMDtcbiAgb1sxMV0gPSB0MTE7XG4gIG9bMTJdID0gdDEyO1xuICBvWzEzXSA9IHQxMztcbiAgb1sxNF0gPSB0MTQ7XG4gIG9bMTVdID0gdDE1O1xufVxuXG5mdW5jdGlvbiBTKG8sIGEpIHtcbiAgTShvLCBhLCBhKTtcbn1cblxuZnVuY3Rpb24gaW52MjU1MTkobywgaSkge1xuICB2YXIgYyA9IGdmKCk7XG4gIHZhciBhO1xuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgY1thXSA9IGlbYV07XG4gIGZvciAoYSA9IDI1MzsgYSA+PSAwOyBhLS0pIHtcbiAgICBTKGMsIGMpO1xuICAgIGlmKGEgIT09IDIgJiYgYSAhPT0gNCkgTShjLCBjLCBpKTtcbiAgfVxuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgb1thXSA9IGNbYV07XG59XG5cbmZ1bmN0aW9uIHBvdzI1MjMobywgaSkge1xuICB2YXIgYyA9IGdmKCk7XG4gIHZhciBhO1xuICBmb3IgKGEgPSAwOyBhIDwgMTY7IGErKykgY1thXSA9IGlbYV07XG4gIGZvciAoYSA9IDI1MDsgYSA+PSAwOyBhLS0pIHtcbiAgICAgIFMoYywgYyk7XG4gICAgICBpZihhICE9PSAxKSBNKGMsIGMsIGkpO1xuICB9XG4gIGZvciAoYSA9IDA7IGEgPCAxNjsgYSsrKSBvW2FdID0gY1thXTtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NjYWxhcm11bHQocSwgbiwgcCkge1xuICB2YXIgeiA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgdmFyIHggPSBuZXcgRmxvYXQ2NEFycmF5KDgwKSwgciwgaTtcbiAgdmFyIGEgPSBnZigpLCBiID0gZ2YoKSwgYyA9IGdmKCksXG4gICAgICBkID0gZ2YoKSwgZSA9IGdmKCksIGYgPSBnZigpO1xuICBmb3IgKGkgPSAwOyBpIDwgMzE7IGkrKykgeltpXSA9IG5baV07XG4gIHpbMzFdPShuWzMxXSYxMjcpfDY0O1xuICB6WzBdJj0yNDg7XG4gIHVucGFjazI1NTE5KHgscCk7XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgYltpXT14W2ldO1xuICAgIGRbaV09YVtpXT1jW2ldPTA7XG4gIH1cbiAgYVswXT1kWzBdPTE7XG4gIGZvciAoaT0yNTQ7IGk+PTA7IC0taSkge1xuICAgIHI9KHpbaT4+PjNdPj4+KGkmNykpJjE7XG4gICAgc2VsMjU1MTkoYSxiLHIpO1xuICAgIHNlbDI1NTE5KGMsZCxyKTtcbiAgICBBKGUsYSxjKTtcbiAgICBaKGEsYSxjKTtcbiAgICBBKGMsYixkKTtcbiAgICBaKGIsYixkKTtcbiAgICBTKGQsZSk7XG4gICAgUyhmLGEpO1xuICAgIE0oYSxjLGEpO1xuICAgIE0oYyxiLGUpO1xuICAgIEEoZSxhLGMpO1xuICAgIFooYSxhLGMpO1xuICAgIFMoYixhKTtcbiAgICBaKGMsZCxmKTtcbiAgICBNKGEsYyxfMTIxNjY1KTtcbiAgICBBKGEsYSxkKTtcbiAgICBNKGMsYyxhKTtcbiAgICBNKGEsZCxmKTtcbiAgICBNKGQsYix4KTtcbiAgICBTKGIsZSk7XG4gICAgc2VsMjU1MTkoYSxiLHIpO1xuICAgIHNlbDI1NTE5KGMsZCxyKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHhbaSsxNl09YVtpXTtcbiAgICB4W2krMzJdPWNbaV07XG4gICAgeFtpKzQ4XT1iW2ldO1xuICAgIHhbaSs2NF09ZFtpXTtcbiAgfVxuICB2YXIgeDMyID0geC5zdWJhcnJheSgzMik7XG4gIHZhciB4MTYgPSB4LnN1YmFycmF5KDE2KTtcbiAgaW52MjU1MTkoeDMyLHgzMik7XG4gIE0oeDE2LHgxNix4MzIpO1xuICBwYWNrMjU1MTkocSx4MTYpO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NjYWxhcm11bHRfYmFzZShxLCBuKSB7XG4gIHJldHVybiBjcnlwdG9fc2NhbGFybXVsdChxLCBuLCBfOSk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfa2V5cGFpcih5LCB4KSB7XG4gIHJhbmRvbWJ5dGVzKHgsIDMyKTtcbiAgcmV0dXJuIGNyeXB0b19zY2FsYXJtdWx0X2Jhc2UoeSwgeCk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgeSwgeCkge1xuICB2YXIgcyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX3NjYWxhcm11bHQocywgeCwgeSk7XG4gIHJldHVybiBjcnlwdG9fY29yZV9oc2Fsc2EyMChrLCBfMCwgcywgc2lnbWEpO1xufVxuXG52YXIgY3J5cHRvX2JveF9hZnRlcm5tID0gY3J5cHRvX3NlY3JldGJveDtcbnZhciBjcnlwdG9fYm94X29wZW5fYWZ0ZXJubSA9IGNyeXB0b19zZWNyZXRib3hfb3BlbjtcblxuZnVuY3Rpb24gY3J5cHRvX2JveChjLCBtLCBkLCBuLCB5LCB4KSB7XG4gIHZhciBrID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBjcnlwdG9fYm94X2JlZm9yZW5tKGssIHksIHgpO1xuICByZXR1cm4gY3J5cHRvX2JveF9hZnRlcm5tKGMsIG0sIGQsIG4sIGspO1xufVxuXG5mdW5jdGlvbiBjcnlwdG9fYm94X29wZW4obSwgYywgZCwgbiwgeSwgeCkge1xuICB2YXIgayA9IG5ldyBVaW50OEFycmF5KDMyKTtcbiAgY3J5cHRvX2JveF9iZWZvcmVubShrLCB5LCB4KTtcbiAgcmV0dXJuIGNyeXB0b19ib3hfb3Blbl9hZnRlcm5tKG0sIGMsIGQsIG4sIGspO1xufVxuXG52YXIgSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxuZnVuY3Rpb24gY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCBtLCBuKSB7XG4gIHZhciB3aCA9IG5ldyBJbnQzMkFycmF5KDE2KSwgd2wgPSBuZXcgSW50MzJBcnJheSgxNiksXG4gICAgICBiaDAsIGJoMSwgYmgyLCBiaDMsIGJoNCwgYmg1LCBiaDYsIGJoNyxcbiAgICAgIGJsMCwgYmwxLCBibDIsIGJsMywgYmw0LCBibDUsIGJsNiwgYmw3LFxuICAgICAgdGgsIHRsLCBpLCBqLCBoLCBsLCBhLCBiLCBjLCBkO1xuXG4gIHZhciBhaDAgPSBoaFswXSxcbiAgICAgIGFoMSA9IGhoWzFdLFxuICAgICAgYWgyID0gaGhbMl0sXG4gICAgICBhaDMgPSBoaFszXSxcbiAgICAgIGFoNCA9IGhoWzRdLFxuICAgICAgYWg1ID0gaGhbNV0sXG4gICAgICBhaDYgPSBoaFs2XSxcbiAgICAgIGFoNyA9IGhoWzddLFxuXG4gICAgICBhbDAgPSBobFswXSxcbiAgICAgIGFsMSA9IGhsWzFdLFxuICAgICAgYWwyID0gaGxbMl0sXG4gICAgICBhbDMgPSBobFszXSxcbiAgICAgIGFsNCA9IGhsWzRdLFxuICAgICAgYWw1ID0gaGxbNV0sXG4gICAgICBhbDYgPSBobFs2XSxcbiAgICAgIGFsNyA9IGhsWzddO1xuXG4gIHZhciBwb3MgPSAwO1xuICB3aGlsZSAobiA+PSAxMjgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgaiA9IDggKiBpICsgcG9zO1xuICAgICAgd2hbaV0gPSAobVtqKzBdIDw8IDI0KSB8IChtW2orMV0gPDwgMTYpIHwgKG1baisyXSA8PCA4KSB8IG1baiszXTtcbiAgICAgIHdsW2ldID0gKG1bais0XSA8PCAyNCkgfCAobVtqKzVdIDw8IDE2KSB8IChtW2orNl0gPDwgOCkgfCBtW2orN107XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICBiaDAgPSBhaDA7XG4gICAgICBiaDEgPSBhaDE7XG4gICAgICBiaDIgPSBhaDI7XG4gICAgICBiaDMgPSBhaDM7XG4gICAgICBiaDQgPSBhaDQ7XG4gICAgICBiaDUgPSBhaDU7XG4gICAgICBiaDYgPSBhaDY7XG4gICAgICBiaDcgPSBhaDc7XG5cbiAgICAgIGJsMCA9IGFsMDtcbiAgICAgIGJsMSA9IGFsMTtcbiAgICAgIGJsMiA9IGFsMjtcbiAgICAgIGJsMyA9IGFsMztcbiAgICAgIGJsNCA9IGFsNDtcbiAgICAgIGJsNSA9IGFsNTtcbiAgICAgIGJsNiA9IGFsNjtcbiAgICAgIGJsNyA9IGFsNztcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gYWg3O1xuICAgICAgbCA9IGFsNztcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIFNpZ21hMVxuICAgICAgaCA9ICgoYWg0ID4+PiAxNCkgfCAoYWw0IDw8ICgzMi0xNCkpKSBeICgoYWg0ID4+PiAxOCkgfCAoYWw0IDw8ICgzMi0xOCkpKSBeICgoYWw0ID4+PiAoNDEtMzIpKSB8IChhaDQgPDwgKDMyLSg0MS0zMikpKSk7XG4gICAgICBsID0gKChhbDQgPj4+IDE0KSB8IChhaDQgPDwgKDMyLTE0KSkpIF4gKChhbDQgPj4+IDE4KSB8IChhaDQgPDwgKDMyLTE4KSkpIF4gKChhaDQgPj4+ICg0MS0zMikpIHwgKGFsNCA8PCAoMzItKDQxLTMyKSkpKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAvLyBDaFxuICAgICAgaCA9IChhaDQgJiBhaDUpIF4gKH5haDQgJiBhaDYpO1xuICAgICAgbCA9IChhbDQgJiBhbDUpIF4gKH5hbDQgJiBhbDYpO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIC8vIEtcbiAgICAgIGggPSBLW2kqMl07XG4gICAgICBsID0gS1tpKjIrMV07XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gd1xuICAgICAgaCA9IHdoW2klMTZdO1xuICAgICAgbCA9IHdsW2klMTZdO1xuXG4gICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICBjICs9IGggJiAweGZmZmY7IGQgKz0gaCA+Pj4gMTY7XG5cbiAgICAgIGIgKz0gYSA+Pj4gMTY7XG4gICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgZCArPSBjID4+PiAxNjtcblxuICAgICAgdGggPSBjICYgMHhmZmZmIHwgZCA8PCAxNjtcbiAgICAgIHRsID0gYSAmIDB4ZmZmZiB8IGIgPDwgMTY7XG5cbiAgICAgIC8vIGFkZFxuICAgICAgaCA9IHRoO1xuICAgICAgbCA9IHRsO1xuXG4gICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgICAgLy8gU2lnbWEwXG4gICAgICBoID0gKChhaDAgPj4+IDI4KSB8IChhbDAgPDwgKDMyLTI4KSkpIF4gKChhbDAgPj4+ICgzNC0zMikpIHwgKGFoMCA8PCAoMzItKDM0LTMyKSkpKSBeICgoYWwwID4+PiAoMzktMzIpKSB8IChhaDAgPDwgKDMyLSgzOS0zMikpKSk7XG4gICAgICBsID0gKChhbDAgPj4+IDI4KSB8IChhaDAgPDwgKDMyLTI4KSkpIF4gKChhaDAgPj4+ICgzNC0zMikpIHwgKGFsMCA8PCAoMzItKDM0LTMyKSkpKSBeICgoYWgwID4+PiAoMzktMzIpKSB8IChhbDAgPDwgKDMyLSgzOS0zMikpKSk7XG5cbiAgICAgIGEgKz0gbCAmIDB4ZmZmZjsgYiArPSBsID4+PiAxNjtcbiAgICAgIGMgKz0gaCAmIDB4ZmZmZjsgZCArPSBoID4+PiAxNjtcblxuICAgICAgLy8gTWFqXG4gICAgICBoID0gKGFoMCAmIGFoMSkgXiAoYWgwICYgYWgyKSBeIChhaDEgJiBhaDIpO1xuICAgICAgbCA9IChhbDAgJiBhbDEpIF4gKGFsMCAmIGFsMikgXiAoYWwxICYgYWwyKTtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIGJoNyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICAgIGJsNyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgICAgLy8gYWRkXG4gICAgICBoID0gYmgzO1xuICAgICAgbCA9IGJsMztcblxuICAgICAgYSA9IGwgJiAweGZmZmY7IGIgPSBsID4+PiAxNjtcbiAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgIGggPSB0aDtcbiAgICAgIGwgPSB0bDtcblxuICAgICAgYSArPSBsICYgMHhmZmZmOyBiICs9IGwgPj4+IDE2O1xuICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICBiICs9IGEgPj4+IDE2O1xuICAgICAgYyArPSBiID4+PiAxNjtcbiAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgIGJoMyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICAgIGJsMyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgICAgYWgxID0gYmgwO1xuICAgICAgYWgyID0gYmgxO1xuICAgICAgYWgzID0gYmgyO1xuICAgICAgYWg0ID0gYmgzO1xuICAgICAgYWg1ID0gYmg0O1xuICAgICAgYWg2ID0gYmg1O1xuICAgICAgYWg3ID0gYmg2O1xuICAgICAgYWgwID0gYmg3O1xuXG4gICAgICBhbDEgPSBibDA7XG4gICAgICBhbDIgPSBibDE7XG4gICAgICBhbDMgPSBibDI7XG4gICAgICBhbDQgPSBibDM7XG4gICAgICBhbDUgPSBibDQ7XG4gICAgICBhbDYgPSBibDU7XG4gICAgICBhbDcgPSBibDY7XG4gICAgICBhbDAgPSBibDc7XG5cbiAgICAgIGlmIChpJTE2ID09PSAxNSkge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgICAgIC8vIGFkZFxuICAgICAgICAgIGggPSB3aFtqXTtcbiAgICAgICAgICBsID0gd2xbal07XG5cbiAgICAgICAgICBhID0gbCAmIDB4ZmZmZjsgYiA9IGwgPj4+IDE2O1xuICAgICAgICAgIGMgPSBoICYgMHhmZmZmOyBkID0gaCA+Pj4gMTY7XG5cbiAgICAgICAgICBoID0gd2hbKGorOSklMTZdO1xuICAgICAgICAgIGwgPSB3bFsoais5KSUxNl07XG5cbiAgICAgICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAgICAgLy8gc2lnbWEwXG4gICAgICAgICAgdGggPSB3aFsoaisxKSUxNl07XG4gICAgICAgICAgdGwgPSB3bFsoaisxKSUxNl07XG4gICAgICAgICAgaCA9ICgodGggPj4+IDEpIHwgKHRsIDw8ICgzMi0xKSkpIF4gKCh0aCA+Pj4gOCkgfCAodGwgPDwgKDMyLTgpKSkgXiAodGggPj4+IDcpO1xuICAgICAgICAgIGwgPSAoKHRsID4+PiAxKSB8ICh0aCA8PCAoMzItMSkpKSBeICgodGwgPj4+IDgpIHwgKHRoIDw8ICgzMi04KSkpIF4gKCh0bCA+Pj4gNykgfCAodGggPDwgKDMyLTcpKSk7XG5cbiAgICAgICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAgICAgLy8gc2lnbWExXG4gICAgICAgICAgdGggPSB3aFsoaisxNCklMTZdO1xuICAgICAgICAgIHRsID0gd2xbKGorMTQpJTE2XTtcbiAgICAgICAgICBoID0gKCh0aCA+Pj4gMTkpIHwgKHRsIDw8ICgzMi0xOSkpKSBeICgodGwgPj4+ICg2MS0zMikpIHwgKHRoIDw8ICgzMi0oNjEtMzIpKSkpIF4gKHRoID4+PiA2KTtcbiAgICAgICAgICBsID0gKCh0bCA+Pj4gMTkpIHwgKHRoIDw8ICgzMi0xOSkpKSBeICgodGggPj4+ICg2MS0zMikpIHwgKHRsIDw8ICgzMi0oNjEtMzIpKSkpIF4gKCh0bCA+Pj4gNikgfCAodGggPDwgKDMyLTYpKSk7XG5cbiAgICAgICAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgICAgICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgICAgICAgYiArPSBhID4+PiAxNjtcbiAgICAgICAgICBjICs9IGIgPj4+IDE2O1xuICAgICAgICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICAgICAgICB3aFtqXSA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICAgICAgICB3bFtqXSA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFkZFxuICAgIGggPSBhaDA7XG4gICAgbCA9IGFsMDtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFswXTtcbiAgICBsID0gaGxbMF07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFswXSA9IGFoMCA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFswXSA9IGFsMCA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDE7XG4gICAgbCA9IGFsMTtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFsxXTtcbiAgICBsID0gaGxbMV07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFsxXSA9IGFoMSA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFsxXSA9IGFsMSA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDI7XG4gICAgbCA9IGFsMjtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFsyXTtcbiAgICBsID0gaGxbMl07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFsyXSA9IGFoMiA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFsyXSA9IGFsMiA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDM7XG4gICAgbCA9IGFsMztcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFszXTtcbiAgICBsID0gaGxbM107XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFszXSA9IGFoMyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFszXSA9IGFsMyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDQ7XG4gICAgbCA9IGFsNDtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs0XTtcbiAgICBsID0gaGxbNF07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs0XSA9IGFoNCA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs0XSA9IGFsNCA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDU7XG4gICAgbCA9IGFsNTtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs1XTtcbiAgICBsID0gaGxbNV07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs1XSA9IGFoNSA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs1XSA9IGFsNSA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDY7XG4gICAgbCA9IGFsNjtcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs2XTtcbiAgICBsID0gaGxbNl07XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs2XSA9IGFoNiA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs2XSA9IGFsNiA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIGggPSBhaDc7XG4gICAgbCA9IGFsNztcblxuICAgIGEgPSBsICYgMHhmZmZmOyBiID0gbCA+Pj4gMTY7XG4gICAgYyA9IGggJiAweGZmZmY7IGQgPSBoID4+PiAxNjtcblxuICAgIGggPSBoaFs3XTtcbiAgICBsID0gaGxbN107XG5cbiAgICBhICs9IGwgJiAweGZmZmY7IGIgKz0gbCA+Pj4gMTY7XG4gICAgYyArPSBoICYgMHhmZmZmOyBkICs9IGggPj4+IDE2O1xuXG4gICAgYiArPSBhID4+PiAxNjtcbiAgICBjICs9IGIgPj4+IDE2O1xuICAgIGQgKz0gYyA+Pj4gMTY7XG5cbiAgICBoaFs3XSA9IGFoNyA9IChjICYgMHhmZmZmKSB8IChkIDw8IDE2KTtcbiAgICBobFs3XSA9IGFsNyA9IChhICYgMHhmZmZmKSB8IChiIDw8IDE2KTtcblxuICAgIHBvcyArPSAxMjg7XG4gICAgbiAtPSAxMjg7XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX2hhc2gob3V0LCBtLCBuKSB7XG4gIHZhciBoaCA9IG5ldyBJbnQzMkFycmF5KDgpLFxuICAgICAgaGwgPSBuZXcgSW50MzJBcnJheSg4KSxcbiAgICAgIHggPSBuZXcgVWludDhBcnJheSgyNTYpLFxuICAgICAgaSwgYiA9IG47XG5cbiAgaGhbMF0gPSAweDZhMDllNjY3O1xuICBoaFsxXSA9IDB4YmI2N2FlODU7XG4gIGhoWzJdID0gMHgzYzZlZjM3MjtcbiAgaGhbM10gPSAweGE1NGZmNTNhO1xuICBoaFs0XSA9IDB4NTEwZTUyN2Y7XG4gIGhoWzVdID0gMHg5YjA1Njg4YztcbiAgaGhbNl0gPSAweDFmODNkOWFiO1xuICBoaFs3XSA9IDB4NWJlMGNkMTk7XG5cbiAgaGxbMF0gPSAweGYzYmNjOTA4O1xuICBobFsxXSA9IDB4ODRjYWE3M2I7XG4gIGhsWzJdID0gMHhmZTk0ZjgyYjtcbiAgaGxbM10gPSAweDVmMWQzNmYxO1xuICBobFs0XSA9IDB4YWRlNjgyZDE7XG4gIGhsWzVdID0gMHgyYjNlNmMxZjtcbiAgaGxbNl0gPSAweGZiNDFiZDZiO1xuICBobFs3XSA9IDB4MTM3ZTIxNzk7XG5cbiAgY3J5cHRvX2hhc2hibG9ja3NfaGwoaGgsIGhsLCBtLCBuKTtcbiAgbiAlPSAxMjg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgeFtpXSA9IG1bYi1uK2ldO1xuICB4W25dID0gMTI4O1xuXG4gIG4gPSAyNTYtMTI4KihuPDExMj8xOjApO1xuICB4W24tOV0gPSAwO1xuICB0czY0KHgsIG4tOCwgIChiIC8gMHgyMDAwMDAwMCkgfCAwLCBiIDw8IDMpO1xuICBjcnlwdG9faGFzaGJsb2Nrc19obChoaCwgaGwsIHgsIG4pO1xuXG4gIGZvciAoaSA9IDA7IGkgPCA4OyBpKyspIHRzNjQob3V0LCA4KmksIGhoW2ldLCBobFtpXSk7XG5cbiAgcmV0dXJuIDA7XG59XG5cbmZ1bmN0aW9uIGFkZChwLCBxKSB7XG4gIHZhciBhID0gZ2YoKSwgYiA9IGdmKCksIGMgPSBnZigpLFxuICAgICAgZCA9IGdmKCksIGUgPSBnZigpLCBmID0gZ2YoKSxcbiAgICAgIGcgPSBnZigpLCBoID0gZ2YoKSwgdCA9IGdmKCk7XG5cbiAgWihhLCBwWzFdLCBwWzBdKTtcbiAgWih0LCBxWzFdLCBxWzBdKTtcbiAgTShhLCBhLCB0KTtcbiAgQShiLCBwWzBdLCBwWzFdKTtcbiAgQSh0LCBxWzBdLCBxWzFdKTtcbiAgTShiLCBiLCB0KTtcbiAgTShjLCBwWzNdLCBxWzNdKTtcbiAgTShjLCBjLCBEMik7XG4gIE0oZCwgcFsyXSwgcVsyXSk7XG4gIEEoZCwgZCwgZCk7XG4gIFooZSwgYiwgYSk7XG4gIFooZiwgZCwgYyk7XG4gIEEoZywgZCwgYyk7XG4gIEEoaCwgYiwgYSk7XG5cbiAgTShwWzBdLCBlLCBmKTtcbiAgTShwWzFdLCBoLCBnKTtcbiAgTShwWzJdLCBnLCBmKTtcbiAgTShwWzNdLCBlLCBoKTtcbn1cblxuZnVuY3Rpb24gY3N3YXAocCwgcSwgYikge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHNlbDI1NTE5KHBbaV0sIHFbaV0sIGIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhY2sociwgcCkge1xuICB2YXIgdHggPSBnZigpLCB0eSA9IGdmKCksIHppID0gZ2YoKTtcbiAgaW52MjU1MTkoemksIHBbMl0pO1xuICBNKHR4LCBwWzBdLCB6aSk7XG4gIE0odHksIHBbMV0sIHppKTtcbiAgcGFjazI1NTE5KHIsIHR5KTtcbiAgclszMV0gXj0gcGFyMjU1MTkodHgpIDw8IDc7XG59XG5cbmZ1bmN0aW9uIHNjYWxhcm11bHQocCwgcSwgcykge1xuICB2YXIgYiwgaTtcbiAgc2V0MjU1MTkocFswXSwgZ2YwKTtcbiAgc2V0MjU1MTkocFsxXSwgZ2YxKTtcbiAgc2V0MjU1MTkocFsyXSwgZ2YxKTtcbiAgc2V0MjU1MTkocFszXSwgZ2YwKTtcbiAgZm9yIChpID0gMjU1OyBpID49IDA7IC0taSkge1xuICAgIGIgPSAoc1soaS84KXwwXSA+PiAoaSY3KSkgJiAxO1xuICAgIGNzd2FwKHAsIHEsIGIpO1xuICAgIGFkZChxLCBwKTtcbiAgICBhZGQocCwgcCk7XG4gICAgY3N3YXAocCwgcSwgYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NhbGFyYmFzZShwLCBzKSB7XG4gIHZhciBxID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuICBzZXQyNTUxOShxWzBdLCBYKTtcbiAgc2V0MjU1MTkocVsxXSwgWSk7XG4gIHNldDI1NTE5KHFbMl0sIGdmMSk7XG4gIE0ocVszXSwgWCwgWSk7XG4gIHNjYWxhcm11bHQocCwgcSwgcyk7XG59XG5cbmZ1bmN0aW9uIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrLCBzZWVkZWQpIHtcbiAgdmFyIGQgPSBuZXcgVWludDhBcnJheSg2NCk7XG4gIHZhciBwID0gW2dmKCksIGdmKCksIGdmKCksIGdmKCldO1xuICB2YXIgaTtcblxuICBpZiAoIXNlZWRlZCkgcmFuZG9tYnl0ZXMoc2ssIDMyKTtcbiAgY3J5cHRvX2hhc2goZCwgc2ssIDMyKTtcbiAgZFswXSAmPSAyNDg7XG4gIGRbMzFdICY9IDEyNztcbiAgZFszMV0gfD0gNjQ7XG5cbiAgc2NhbGFyYmFzZShwLCBkKTtcbiAgcGFjayhwaywgcCk7XG5cbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHNrW2krMzJdID0gcGtbaV07XG4gIHJldHVybiAwO1xufVxuXG52YXIgTCA9IG5ldyBGbG9hdDY0QXJyYXkoWzB4ZWQsIDB4ZDMsIDB4ZjUsIDB4NWMsIDB4MWEsIDB4NjMsIDB4MTIsIDB4NTgsIDB4ZDYsIDB4OWMsIDB4ZjcsIDB4YTIsIDB4ZGUsIDB4ZjksIDB4ZGUsIDB4MTQsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MTBdKTtcblxuZnVuY3Rpb24gbW9kTChyLCB4KSB7XG4gIHZhciBjYXJyeSwgaSwgaiwgaztcbiAgZm9yIChpID0gNjM7IGkgPj0gMzI7IC0taSkge1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGogPSBpIC0gMzIsIGsgPSBpIC0gMTI7IGogPCBrOyArK2opIHtcbiAgICAgIHhbal0gKz0gY2FycnkgLSAxNiAqIHhbaV0gKiBMW2ogLSAoaSAtIDMyKV07XG4gICAgICBjYXJyeSA9IE1hdGguZmxvb3IoKHhbal0gKyAxMjgpIC8gMjU2KTtcbiAgICAgIHhbal0gLT0gY2FycnkgKiAyNTY7XG4gICAgfVxuICAgIHhbal0gKz0gY2Fycnk7XG4gICAgeFtpXSA9IDA7XG4gIH1cbiAgY2FycnkgPSAwO1xuICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgIHhbal0gKz0gY2FycnkgLSAoeFszMV0gPj4gNCkgKiBMW2pdO1xuICAgIGNhcnJ5ID0geFtqXSA+PiA4O1xuICAgIHhbal0gJj0gMjU1O1xuICB9XG4gIGZvciAoaiA9IDA7IGogPCAzMjsgaisrKSB4W2pdIC09IGNhcnJ5ICogTFtqXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICB4W2krMV0gKz0geFtpXSA+PiA4O1xuICAgIHJbaV0gPSB4W2ldICYgMjU1O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZHVjZShyKSB7XG4gIHZhciB4ID0gbmV3IEZsb2F0NjRBcnJheSg2NCksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB4W2ldID0gcltpXTtcbiAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIHJbaV0gPSAwO1xuICBtb2RMKHIsIHgpO1xufVxuXG4vLyBOb3RlOiBkaWZmZXJlbmNlIGZyb20gQyAtIHNtbGVuIHJldHVybmVkLCBub3QgcGFzc2VkIGFzIGFyZ3VtZW50LlxuZnVuY3Rpb24gY3J5cHRvX3NpZ24oc20sIG0sIG4sIHNrKSB7XG4gIHZhciBkID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCBoID0gbmV3IFVpbnQ4QXJyYXkoNjQpLCByID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgaSwgaiwgeCA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXTtcblxuICBjcnlwdG9faGFzaChkLCBzaywgMzIpO1xuICBkWzBdICY9IDI0ODtcbiAgZFszMV0gJj0gMTI3O1xuICBkWzMxXSB8PSA2NDtcblxuICB2YXIgc21sZW4gPSBuICsgNjQ7XG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHNtWzY0ICsgaV0gPSBtW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgc21bMzIgKyBpXSA9IGRbMzIgKyBpXTtcblxuICBjcnlwdG9faGFzaChyLCBzbS5zdWJhcnJheSgzMiksIG4rMzIpO1xuICByZWR1Y2Uocik7XG4gIHNjYWxhcmJhc2UocCwgcik7XG4gIHBhY2soc20sIHApO1xuXG4gIGZvciAoaSA9IDMyOyBpIDwgNjQ7IGkrKykgc21baV0gPSBza1tpXTtcbiAgY3J5cHRvX2hhc2goaCwgc20sIG4gKyA2NCk7XG4gIHJlZHVjZShoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgeFtpXSA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB4W2ldID0gcltpXTtcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgMzI7IGorKykge1xuICAgICAgeFtpK2pdICs9IGhbaV0gKiBkW2pdO1xuICAgIH1cbiAgfVxuXG4gIG1vZEwoc20uc3ViYXJyYXkoMzIpLCB4KTtcbiAgcmV0dXJuIHNtbGVuO1xufVxuXG5mdW5jdGlvbiB1bnBhY2tuZWcociwgcCkge1xuICB2YXIgdCA9IGdmKCksIGNoayA9IGdmKCksIG51bSA9IGdmKCksXG4gICAgICBkZW4gPSBnZigpLCBkZW4yID0gZ2YoKSwgZGVuNCA9IGdmKCksXG4gICAgICBkZW42ID0gZ2YoKTtcblxuICBzZXQyNTUxOShyWzJdLCBnZjEpO1xuICB1bnBhY2syNTUxOShyWzFdLCBwKTtcbiAgUyhudW0sIHJbMV0pO1xuICBNKGRlbiwgbnVtLCBEKTtcbiAgWihudW0sIG51bSwgclsyXSk7XG4gIEEoZGVuLCByWzJdLCBkZW4pO1xuXG4gIFMoZGVuMiwgZGVuKTtcbiAgUyhkZW40LCBkZW4yKTtcbiAgTShkZW42LCBkZW40LCBkZW4yKTtcbiAgTSh0LCBkZW42LCBudW0pO1xuICBNKHQsIHQsIGRlbik7XG5cbiAgcG93MjUyMyh0LCB0KTtcbiAgTSh0LCB0LCBudW0pO1xuICBNKHQsIHQsIGRlbik7XG4gIE0odCwgdCwgZGVuKTtcbiAgTShyWzBdLCB0LCBkZW4pO1xuXG4gIFMoY2hrLCByWzBdKTtcbiAgTShjaGssIGNoaywgZGVuKTtcbiAgaWYgKG5lcTI1NTE5KGNoaywgbnVtKSkgTShyWzBdLCByWzBdLCBJKTtcblxuICBTKGNoaywgclswXSk7XG4gIE0oY2hrLCBjaGssIGRlbik7XG4gIGlmIChuZXEyNTUxOShjaGssIG51bSkpIHJldHVybiAtMTtcblxuICBpZiAocGFyMjU1MTkoclswXSkgPT09IChwWzMxXT4+NykpIFooclswXSwgZ2YwLCByWzBdKTtcblxuICBNKHJbM10sIHJbMF0sIHJbMV0pO1xuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgbiwgcGspIHtcbiAgdmFyIGk7XG4gIHZhciB0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLCBoID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICB2YXIgcCA9IFtnZigpLCBnZigpLCBnZigpLCBnZigpXSxcbiAgICAgIHEgPSBbZ2YoKSwgZ2YoKSwgZ2YoKSwgZ2YoKV07XG5cbiAgaWYgKG4gPCA2NCkgcmV0dXJuIC0xO1xuXG4gIGlmICh1bnBhY2tuZWcocSwgcGspKSByZXR1cm4gLTE7XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykgbVtpXSA9IHNtW2ldO1xuICBmb3IgKGkgPSAwOyBpIDwgMzI7IGkrKykgbVtpKzMyXSA9IHBrW2ldO1xuICBjcnlwdG9faGFzaChoLCBtLCBuKTtcbiAgcmVkdWNlKGgpO1xuICBzY2FsYXJtdWx0KHAsIHEsIGgpO1xuXG4gIHNjYWxhcmJhc2UocSwgc20uc3ViYXJyYXkoMzIpKTtcbiAgYWRkKHAsIHEpO1xuICBwYWNrKHQsIHApO1xuXG4gIG4gLT0gNjQ7XG4gIGlmIChjcnlwdG9fdmVyaWZ5XzMyKHNtLCAwLCB0LCAwKSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1baV0gPSAwO1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIG1baV0gPSBzbVtpICsgNjRdO1xuICByZXR1cm4gbjtcbn1cblxudmFyIGNyeXB0b19zZWNyZXRib3hfS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMgPSAyNCxcbiAgICBjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyA9IDMyLFxuICAgIGNyeXB0b19zZWNyZXRib3hfQk9YWkVST0JZVEVTID0gMTYsXG4gICAgY3J5cHRvX3NjYWxhcm11bHRfQllURVMgPSAzMixcbiAgICBjcnlwdG9fc2NhbGFybXVsdF9TQ0FMQVJCWVRFUyA9IDMyLFxuICAgIGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMgPSAzMixcbiAgICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9CRUZPUkVOTUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX2JveF9OT05DRUJZVEVTID0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTLFxuICAgIGNyeXB0b19ib3hfWkVST0JZVEVTID0gY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMsXG4gICAgY3J5cHRvX2JveF9CT1haRVJPQllURVMgPSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyxcbiAgICBjcnlwdG9fc2lnbl9CWVRFUyA9IDY0LFxuICAgIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTID0gMzIsXG4gICAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMgPSA2NCxcbiAgICBjcnlwdG9fc2lnbl9TRUVEQllURVMgPSAzMixcbiAgICBjcnlwdG9faGFzaF9CWVRFUyA9IDY0O1xuXG5uYWNsLmxvd2xldmVsID0ge1xuICBjcnlwdG9fY29yZV9oc2Fsc2EyMDogY3J5cHRvX2NvcmVfaHNhbHNhMjAsXG4gIGNyeXB0b19zdHJlYW1feG9yOiBjcnlwdG9fc3RyZWFtX3hvcixcbiAgY3J5cHRvX3N0cmVhbTogY3J5cHRvX3N0cmVhbSxcbiAgY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcjogY3J5cHRvX3N0cmVhbV9zYWxzYTIwX3hvcixcbiAgY3J5cHRvX3N0cmVhbV9zYWxzYTIwOiBjcnlwdG9fc3RyZWFtX3NhbHNhMjAsXG4gIGNyeXB0b19vbmV0aW1lYXV0aDogY3J5cHRvX29uZXRpbWVhdXRoLFxuICBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5OiBjcnlwdG9fb25ldGltZWF1dGhfdmVyaWZ5LFxuICBjcnlwdG9fdmVyaWZ5XzE2OiBjcnlwdG9fdmVyaWZ5XzE2LFxuICBjcnlwdG9fdmVyaWZ5XzMyOiBjcnlwdG9fdmVyaWZ5XzMyLFxuICBjcnlwdG9fc2VjcmV0Ym94OiBjcnlwdG9fc2VjcmV0Ym94LFxuICBjcnlwdG9fc2VjcmV0Ym94X29wZW46IGNyeXB0b19zZWNyZXRib3hfb3BlbixcbiAgY3J5cHRvX3NjYWxhcm11bHQ6IGNyeXB0b19zY2FsYXJtdWx0LFxuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlOiBjcnlwdG9fc2NhbGFybXVsdF9iYXNlLFxuICBjcnlwdG9fYm94X2JlZm9yZW5tOiBjcnlwdG9fYm94X2JlZm9yZW5tLFxuICBjcnlwdG9fYm94X2FmdGVybm06IGNyeXB0b19ib3hfYWZ0ZXJubSxcbiAgY3J5cHRvX2JveDogY3J5cHRvX2JveCxcbiAgY3J5cHRvX2JveF9vcGVuOiBjcnlwdG9fYm94X29wZW4sXG4gIGNyeXB0b19ib3hfa2V5cGFpcjogY3J5cHRvX2JveF9rZXlwYWlyLFxuICBjcnlwdG9faGFzaDogY3J5cHRvX2hhc2gsXG4gIGNyeXB0b19zaWduOiBjcnlwdG9fc2lnbixcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcjogY3J5cHRvX3NpZ25fa2V5cGFpcixcbiAgY3J5cHRvX3NpZ25fb3BlbjogY3J5cHRvX3NpZ25fb3BlbixcblxuICBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTOiBjcnlwdG9fc2VjcmV0Ym94X0tFWUJZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVM6IGNyeXB0b19zZWNyZXRib3hfTk9OQ0VCWVRFUyxcbiAgY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVM6IGNyeXB0b19zZWNyZXRib3hfWkVST0JZVEVTLFxuICBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUzogY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMsXG4gIGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTOiBjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyxcbiAgY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVM6IGNyeXB0b19zY2FsYXJtdWx0X1NDQUxBUkJZVEVTLFxuICBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTLFxuICBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTOiBjcnlwdG9fYm94X1NFQ1JFVEtFWUJZVEVTLFxuICBjcnlwdG9fYm94X0JFRk9SRU5NQllURVM6IGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyxcbiAgY3J5cHRvX2JveF9OT05DRUJZVEVTOiBjcnlwdG9fYm94X05PTkNFQllURVMsXG4gIGNyeXB0b19ib3hfWkVST0JZVEVTOiBjcnlwdG9fYm94X1pFUk9CWVRFUyxcbiAgY3J5cHRvX2JveF9CT1haRVJPQllURVM6IGNyeXB0b19ib3hfQk9YWkVST0JZVEVTLFxuICBjcnlwdG9fc2lnbl9CWVRFUzogY3J5cHRvX3NpZ25fQllURVMsXG4gIGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTOiBjcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUyxcbiAgY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVM6IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTLFxuICBjcnlwdG9fc2lnbl9TRUVEQllURVM6IGNyeXB0b19zaWduX1NFRURCWVRFUyxcbiAgY3J5cHRvX2hhc2hfQllURVM6IGNyeXB0b19oYXNoX0JZVEVTLFxuXG4gIGdmOiBnZixcbiAgRDogRCxcbiAgTDogTCxcbiAgcGFjazI1NTE5OiBwYWNrMjU1MTksXG4gIHVucGFjazI1NTE5OiB1bnBhY2syNTUxOSxcbiAgTTogTSxcbiAgQTogQSxcbiAgUzogUyxcbiAgWjogWixcbiAgcG93MjUyMzogcG93MjUyMyxcbiAgYWRkOiBhZGQsXG4gIHNldDI1NTE5OiBzZXQyNTUxOSxcbiAgbW9kTDogbW9kTCxcbiAgc2NhbGFybXVsdDogc2NhbGFybXVsdCxcbiAgc2NhbGFyYmFzZTogc2NhbGFyYmFzZSxcbn07XG5cbi8qIEhpZ2gtbGV2ZWwgQVBJICovXG5cbmZ1bmN0aW9uIGNoZWNrTGVuZ3RocyhrLCBuKSB7XG4gIGlmIChrLmxlbmd0aCAhPT0gY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQga2V5IHNpemUnKTtcbiAgaWYgKG4ubGVuZ3RoICE9PSBjcnlwdG9fc2VjcmV0Ym94X05PTkNFQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG5vbmNlIHNpemUnKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tCb3hMZW5ndGhzKHBrLCBzaykge1xuICBpZiAocGsubGVuZ3RoICE9PSBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwdWJsaWMga2V5IHNpemUnKTtcbiAgaWYgKHNrLmxlbmd0aCAhPT0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUykgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQXJyYXlUeXBlcygpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIShhcmd1bWVudHNbaV0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuZXhwZWN0ZWQgdHlwZSwgdXNlIFVpbnQ4QXJyYXknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhbnVwKGFycikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyW2ldID0gMDtcbn1cblxubmFjbC5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKG4pIHtcbiAgdmFyIGIgPSBuZXcgVWludDhBcnJheShuKTtcbiAgcmFuZG9tYnl0ZXMoYiwgbik7XG4gIHJldHVybiBiO1xufTtcblxubmFjbC5zZWNyZXRib3ggPSBmdW5jdGlvbihtc2csIG5vbmNlLCBrZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZywgbm9uY2UsIGtleSk7XG4gIGNoZWNrTGVuZ3RocyhrZXksIG5vbmNlKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFUyArIG1zZy5sZW5ndGgpO1xuICB2YXIgYyA9IG5ldyBVaW50OEFycmF5KG0ubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIG1baStjcnlwdG9fc2VjcmV0Ym94X1pFUk9CWVRFU10gPSBtc2dbaV07XG4gIGNyeXB0b19zZWNyZXRib3goYywgbSwgbS5sZW5ndGgsIG5vbmNlLCBrZXkpO1xuICByZXR1cm4gYy5zdWJhcnJheShjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUyk7XG59O1xuXG5uYWNsLnNlY3JldGJveC5vcGVuID0gZnVuY3Rpb24oYm94LCBub25jZSwga2V5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhib3gsIG5vbmNlLCBrZXkpO1xuICBjaGVja0xlbmd0aHMoa2V5LCBub25jZSk7XG4gIHZhciBjID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVMgKyBib3gubGVuZ3RoKTtcbiAgdmFyIG0gPSBuZXcgVWludDhBcnJheShjLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm94Lmxlbmd0aDsgaSsrKSBjW2krY3J5cHRvX3NlY3JldGJveF9CT1haRVJPQllURVNdID0gYm94W2ldO1xuICBpZiAoYy5sZW5ndGggPCAzMikgcmV0dXJuIG51bGw7XG4gIGlmIChjcnlwdG9fc2VjcmV0Ym94X29wZW4obSwgYywgYy5sZW5ndGgsIG5vbmNlLCBrZXkpICE9PSAwKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIG0uc3ViYXJyYXkoY3J5cHRvX3NlY3JldGJveF9aRVJPQllURVMpO1xufTtcblxubmFjbC5zZWNyZXRib3gua2V5TGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9LRVlCWVRFUztcbm5hY2wuc2VjcmV0Ym94Lm5vbmNlTGVuZ3RoID0gY3J5cHRvX3NlY3JldGJveF9OT05DRUJZVEVTO1xubmFjbC5zZWNyZXRib3gub3ZlcmhlYWRMZW5ndGggPSBjcnlwdG9fc2VjcmV0Ym94X0JPWFpFUk9CWVRFUztcblxubmFjbC5zY2FsYXJNdWx0ID0gZnVuY3Rpb24obiwgcCkge1xuICBjaGVja0FycmF5VHlwZXMobiwgcCk7XG4gIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG4gc2l6ZScpO1xuICBpZiAocC5sZW5ndGggIT09IGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKSB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwIHNpemUnKTtcbiAgdmFyIHEgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2NhbGFybXVsdF9CWVRFUyk7XG4gIGNyeXB0b19zY2FsYXJtdWx0KHEsIG4sIHApO1xuICByZXR1cm4gcTtcbn07XG5cbm5hY2wuc2NhbGFyTXVsdC5iYXNlID0gZnVuY3Rpb24obikge1xuICBjaGVja0FycmF5VHlwZXMobik7XG4gIGlmIChuLmxlbmd0aCAhPT0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVMpIHRocm93IG5ldyBFcnJvcignYmFkIG4gc2l6ZScpO1xuICB2YXIgcSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zY2FsYXJtdWx0X0JZVEVTKTtcbiAgY3J5cHRvX3NjYWxhcm11bHRfYmFzZShxLCBuKTtcbiAgcmV0dXJuIHE7XG59O1xuXG5uYWNsLnNjYWxhck11bHQuc2NhbGFyTGVuZ3RoID0gY3J5cHRvX3NjYWxhcm11bHRfU0NBTEFSQllURVM7XG5uYWNsLnNjYWxhck11bHQuZ3JvdXBFbGVtZW50TGVuZ3RoID0gY3J5cHRvX3NjYWxhcm11bHRfQllURVM7XG5cbm5hY2wuYm94ID0gZnVuY3Rpb24obXNnLCBub25jZSwgcHVibGljS2V5LCBzZWNyZXRLZXkpIHtcbiAgdmFyIGsgPSBuYWNsLmJveC5iZWZvcmUocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICByZXR1cm4gbmFjbC5zZWNyZXRib3gobXNnLCBub25jZSwgayk7XG59O1xuXG5uYWNsLmJveC5iZWZvcmUgPSBmdW5jdGlvbihwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICBjaGVja0JveExlbmd0aHMocHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICB2YXIgayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUyk7XG4gIGNyeXB0b19ib3hfYmVmb3Jlbm0oaywgcHVibGljS2V5LCBzZWNyZXRLZXkpO1xuICByZXR1cm4gaztcbn07XG5cbm5hY2wuYm94LmFmdGVyID0gbmFjbC5zZWNyZXRib3g7XG5cbm5hY2wuYm94Lm9wZW4gPSBmdW5jdGlvbihtc2csIG5vbmNlLCBwdWJsaWNLZXksIHNlY3JldEtleSkge1xuICB2YXIgayA9IG5hY2wuYm94LmJlZm9yZShwdWJsaWNLZXksIHNlY3JldEtleSk7XG4gIHJldHVybiBuYWNsLnNlY3JldGJveC5vcGVuKG1zZywgbm9uY2UsIGspO1xufTtcblxubmFjbC5ib3gub3Blbi5hZnRlciA9IG5hY2wuc2VjcmV0Ym94Lm9wZW47XG5cbm5hY2wuYm94LmtleVBhaXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX2JveF9QVUJMSUNLRVlCWVRFUyk7XG4gIHZhciBzayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpO1xuICBjcnlwdG9fYm94X2tleXBhaXIocGssIHNrKTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IHNrfTtcbn07XG5cbm5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleSA9IGZ1bmN0aW9uKHNlY3JldEtleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19ib3hfU0VDUkVUS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19ib3hfUFVCTElDS0VZQllURVMpO1xuICBjcnlwdG9fc2NhbGFybXVsdF9iYXNlKHBrLCBzZWNyZXRLZXkpO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogbmV3IFVpbnQ4QXJyYXkoc2VjcmV0S2V5KX07XG59O1xuXG5uYWNsLmJveC5wdWJsaWNLZXlMZW5ndGggPSBjcnlwdG9fYm94X1BVQkxJQ0tFWUJZVEVTO1xubmFjbC5ib3guc2VjcmV0S2V5TGVuZ3RoID0gY3J5cHRvX2JveF9TRUNSRVRLRVlCWVRFUztcbm5hY2wuYm94LnNoYXJlZEtleUxlbmd0aCA9IGNyeXB0b19ib3hfQkVGT1JFTk1CWVRFUztcbm5hY2wuYm94Lm5vbmNlTGVuZ3RoID0gY3J5cHRvX2JveF9OT05DRUJZVEVTO1xubmFjbC5ib3gub3ZlcmhlYWRMZW5ndGggPSBuYWNsLnNlY3JldGJveC5vdmVyaGVhZExlbmd0aDtcblxubmFjbC5zaWduID0gZnVuY3Rpb24obXNnLCBzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKG1zZywgc2VjcmV0S2V5KTtcbiAgaWYgKHNlY3JldEtleS5sZW5ndGggIT09IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTKVxuICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICB2YXIgc2lnbmVkTXNnID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMrbXNnLmxlbmd0aCk7XG4gIGNyeXB0b19zaWduKHNpZ25lZE1zZywgbXNnLCBtc2cubGVuZ3RoLCBzZWNyZXRLZXkpO1xuICByZXR1cm4gc2lnbmVkTXNnO1xufTtcblxubmFjbC5zaWduLm9wZW4gPSBmdW5jdGlvbihzaWduZWRNc2csIHB1YmxpY0tleSkge1xuICBjaGVja0FycmF5VHlwZXMoc2lnbmVkTXNnLCBwdWJsaWNLZXkpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gIHZhciB0bXAgPSBuZXcgVWludDhBcnJheShzaWduZWRNc2cubGVuZ3RoKTtcbiAgdmFyIG1sZW4gPSBjcnlwdG9fc2lnbl9vcGVuKHRtcCwgc2lnbmVkTXNnLCBzaWduZWRNc2cubGVuZ3RoLCBwdWJsaWNLZXkpO1xuICBpZiAobWxlbiA8IDApIHJldHVybiBudWxsO1xuICB2YXIgbSA9IG5ldyBVaW50OEFycmF5KG1sZW4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIG1baV0gPSB0bXBbaV07XG4gIHJldHVybiBtO1xufTtcblxubmFjbC5zaWduLmRldGFjaGVkID0gZnVuY3Rpb24obXNnLCBzZWNyZXRLZXkpIHtcbiAgdmFyIHNpZ25lZE1zZyA9IG5hY2wuc2lnbihtc2csIHNlY3JldEtleSk7XG4gIHZhciBzaWcgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9CWVRFUyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnLmxlbmd0aDsgaSsrKSBzaWdbaV0gPSBzaWduZWRNc2dbaV07XG4gIHJldHVybiBzaWc7XG59O1xuXG5uYWNsLnNpZ24uZGV0YWNoZWQudmVyaWZ5ID0gZnVuY3Rpb24obXNnLCBzaWcsIHB1YmxpY0tleSkge1xuICBjaGVja0FycmF5VHlwZXMobXNnLCBzaWcsIHB1YmxpY0tleSk7XG4gIGlmIChzaWcubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9CWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzaWduYXR1cmUgc2l6ZScpO1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcHVibGljIGtleSBzaXplJyk7XG4gIHZhciBzbSA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX0JZVEVTICsgbXNnLmxlbmd0aCk7XG4gIHZhciBtID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fQllURVMgKyBtc2cubGVuZ3RoKTtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBjcnlwdG9fc2lnbl9CWVRFUzsgaSsrKSBzbVtpXSA9IHNpZ1tpXTtcbiAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykgc21baStjcnlwdG9fc2lnbl9CWVRFU10gPSBtc2dbaV07XG4gIHJldHVybiAoY3J5cHRvX3NpZ25fb3BlbihtLCBzbSwgc20ubGVuZ3RoLCBwdWJsaWNLZXkpID49IDApO1xufTtcblxubmFjbC5zaWduLmtleVBhaXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICB2YXIgc2sgPSBuZXcgVWludDhBcnJheShjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUyk7XG4gIGNyeXB0b19zaWduX2tleXBhaXIocGssIHNrKTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IHNrfTtcbn07XG5cbm5hY2wuc2lnbi5rZXlQYWlyLmZyb21TZWNyZXRLZXkgPSBmdW5jdGlvbihzZWNyZXRLZXkpIHtcbiAgY2hlY2tBcnJheVR5cGVzKHNlY3JldEtleSk7XG4gIGlmIChzZWNyZXRLZXkubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUNSRVRLRVlCWVRFUylcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgdmFyIHBrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fUFVCTElDS0VZQllURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBrLmxlbmd0aDsgaSsrKSBwa1tpXSA9IHNlY3JldEtleVszMitpXTtcbiAgcmV0dXJuIHtwdWJsaWNLZXk6IHBrLCBzZWNyZXRLZXk6IG5ldyBVaW50OEFycmF5KHNlY3JldEtleSl9O1xufTtcblxubmFjbC5zaWduLmtleVBhaXIuZnJvbVNlZWQgPSBmdW5jdGlvbihzZWVkKSB7XG4gIGNoZWNrQXJyYXlUeXBlcyhzZWVkKTtcbiAgaWYgKHNlZWQubGVuZ3RoICE9PSBjcnlwdG9fc2lnbl9TRUVEQllURVMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VlZCBzaXplJyk7XG4gIHZhciBwayA9IG5ldyBVaW50OEFycmF5KGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTKTtcbiAgdmFyIHNrID0gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvX3NpZ25fU0VDUkVUS0VZQllURVMpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHNrW2ldID0gc2VlZFtpXTtcbiAgY3J5cHRvX3NpZ25fa2V5cGFpcihwaywgc2ssIHRydWUpO1xuICByZXR1cm4ge3B1YmxpY0tleTogcGssIHNlY3JldEtleTogc2t9O1xufTtcblxubmFjbC5zaWduLnB1YmxpY0tleUxlbmd0aCA9IGNyeXB0b19zaWduX1BVQkxJQ0tFWUJZVEVTO1xubmFjbC5zaWduLnNlY3JldEtleUxlbmd0aCA9IGNyeXB0b19zaWduX1NFQ1JFVEtFWUJZVEVTO1xubmFjbC5zaWduLnNlZWRMZW5ndGggPSBjcnlwdG9fc2lnbl9TRUVEQllURVM7XG5uYWNsLnNpZ24uc2lnbmF0dXJlTGVuZ3RoID0gY3J5cHRvX3NpZ25fQllURVM7XG5cbm5hY2wuaGFzaCA9IGZ1bmN0aW9uKG1zZykge1xuICBjaGVja0FycmF5VHlwZXMobXNnKTtcbiAgdmFyIGggPSBuZXcgVWludDhBcnJheShjcnlwdG9faGFzaF9CWVRFUyk7XG4gIGNyeXB0b19oYXNoKGgsIG1zZywgbXNnLmxlbmd0aCk7XG4gIHJldHVybiBoO1xufTtcblxubmFjbC5oYXNoLmhhc2hMZW5ndGggPSBjcnlwdG9faGFzaF9CWVRFUztcblxubmFjbC52ZXJpZnkgPSBmdW5jdGlvbih4LCB5KSB7XG4gIGNoZWNrQXJyYXlUeXBlcyh4LCB5KTtcbiAgLy8gWmVybyBsZW5ndGggYXJndW1lbnRzIGFyZSBjb25zaWRlcmVkIG5vdCBlcXVhbC5cbiAgaWYgKHgubGVuZ3RoID09PSAwIHx8IHkubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICh4Lmxlbmd0aCAhPT0geS5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICh2bih4LCAwLCB5LCAwLCB4Lmxlbmd0aCkgPT09IDApID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxubmFjbC5zZXRQUk5HID0gZnVuY3Rpb24oZm4pIHtcbiAgcmFuZG9tYnl0ZXMgPSBmbjtcbn07XG5cbihmdW5jdGlvbigpIHtcbiAgLy8gSW5pdGlhbGl6ZSBQUk5HIGlmIGVudmlyb25tZW50IHByb3ZpZGVzIENTUFJORy5cbiAgLy8gSWYgbm90LCBtZXRob2RzIGNhbGxpbmcgcmFuZG9tYnl0ZXMgd2lsbCB0aHJvdy5cbiAgdmFyIGNyeXB0byA9IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IChzZWxmLmNyeXB0byB8fCBzZWxmLm1zQ3J5cHRvKSA6IG51bGw7XG4gIGlmIChjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIEJyb3dzZXJzLlxuICAgIHZhciBRVU9UQSA9IDY1NTM2O1xuICAgIG5hY2wuc2V0UFJORyhmdW5jdGlvbih4LCBuKSB7XG4gICAgICB2YXIgaSwgdiA9IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkgKz0gUVVPVEEpIHtcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyh2LnN1YmFycmF5KGksIGkgKyBNYXRoLm1pbihuIC0gaSwgUVVPVEEpKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB4W2ldID0gdltpXTtcbiAgICAgIGNsZWFudXAodik7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm9kZS5qcy5cbiAgICBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbiAgICBpZiAoY3J5cHRvICYmIGNyeXB0by5yYW5kb21CeXRlcykge1xuICAgICAgbmFjbC5zZXRQUk5HKGZ1bmN0aW9uKHgsIG4pIHtcbiAgICAgICAgdmFyIGksIHYgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHhbaV0gPSB2W2ldO1xuICAgICAgICBjbGVhbnVwKHYpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59KSgpO1xuXG59KSh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzIDogKHNlbGYubmFjbCA9IHNlbGYubmFjbCB8fCB7fSkpO1xuIiwidmFyIG5hdGl2ZSA9IHJlcXVpcmUoJy4vbmF0aXZlJylcblxuZnVuY3Rpb24gZ2V0VHlwZU5hbWUgKGZuKSB7XG4gIHJldHVybiBmbi5uYW1lIHx8IGZuLnRvU3RyaW5nKCkubWF0Y2goL2Z1bmN0aW9uICguKj8pXFxzKlxcKC8pWzFdXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlVHlwZU5hbWUgKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmUuTmlsKHZhbHVlKSA/ICcnIDogZ2V0VHlwZU5hbWUodmFsdWUuY29uc3RydWN0b3IpXG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlICh2YWx1ZSkge1xuICBpZiAobmF0aXZlLkZ1bmN0aW9uKHZhbHVlKSkgcmV0dXJuICcnXG4gIGlmIChuYXRpdmUuU3RyaW5nKHZhbHVlKSkgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICBpZiAodmFsdWUgJiYgbmF0aXZlLk9iamVjdCh2YWx1ZSkpIHJldHVybiAnJ1xuICByZXR1cm4gdmFsdWVcbn1cblxuZnVuY3Rpb24gY2FwdHVyZVN0YWNrVHJhY2UgKGUsIHQpIHtcbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZSwgdClcbiAgfVxufVxuXG5mdW5jdGlvbiB0ZkpTT04gKHR5cGUpIHtcbiAgaWYgKG5hdGl2ZS5GdW5jdGlvbih0eXBlKSkgcmV0dXJuIHR5cGUudG9KU09OID8gdHlwZS50b0pTT04oKSA6IGdldFR5cGVOYW1lKHR5cGUpXG4gIGlmIChuYXRpdmUuQXJyYXkodHlwZSkpIHJldHVybiAnQXJyYXknXG4gIGlmICh0eXBlICYmIG5hdGl2ZS5PYmplY3QodHlwZSkpIHJldHVybiAnT2JqZWN0J1xuXG4gIHJldHVybiB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogJydcbn1cblxuZnVuY3Rpb24gdGZFcnJvclN0cmluZyAodHlwZSwgdmFsdWUsIHZhbHVlVHlwZU5hbWUpIHtcbiAgdmFyIHZhbHVlSnNvbiA9IGdldFZhbHVlKHZhbHVlKVxuXG4gIHJldHVybiAnRXhwZWN0ZWQgJyArIHRmSlNPTih0eXBlKSArICcsIGdvdCcgK1xuICAgICh2YWx1ZVR5cGVOYW1lICE9PSAnJyA/ICcgJyArIHZhbHVlVHlwZU5hbWUgOiAnJykgK1xuICAgICh2YWx1ZUpzb24gIT09ICcnID8gJyAnICsgdmFsdWVKc29uIDogJycpXG59XG5cbmZ1bmN0aW9uIFRmVHlwZUVycm9yICh0eXBlLCB2YWx1ZSwgdmFsdWVUeXBlTmFtZSkge1xuICB2YWx1ZVR5cGVOYW1lID0gdmFsdWVUeXBlTmFtZSB8fCBnZXRWYWx1ZVR5cGVOYW1lKHZhbHVlKVxuICB0aGlzLm1lc3NhZ2UgPSB0ZkVycm9yU3RyaW5nKHR5cGUsIHZhbHVlLCB2YWx1ZVR5cGVOYW1lKVxuXG4gIGNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFRmVHlwZUVycm9yKVxuICB0aGlzLl9fdHlwZSA9IHR5cGVcbiAgdGhpcy5fX3ZhbHVlID0gdmFsdWVcbiAgdGhpcy5fX3ZhbHVlVHlwZU5hbWUgPSB2YWx1ZVR5cGVOYW1lXG59XG5cblRmVHlwZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuVGZUeXBlRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGZUeXBlRXJyb3JcblxuZnVuY3Rpb24gdGZQcm9wZXJ0eUVycm9yU3RyaW5nICh0eXBlLCBsYWJlbCwgbmFtZSwgdmFsdWUsIHZhbHVlVHlwZU5hbWUpIHtcbiAgdmFyIGRlc2NyaXB0aW9uID0gJ1wiIG9mIHR5cGUgJ1xuICBpZiAobGFiZWwgPT09ICdrZXknKSBkZXNjcmlwdGlvbiA9ICdcIiB3aXRoIGtleSB0eXBlICdcblxuICByZXR1cm4gdGZFcnJvclN0cmluZygncHJvcGVydHkgXCInICsgdGZKU09OKG5hbWUpICsgZGVzY3JpcHRpb24gKyB0ZkpTT04odHlwZSksIHZhbHVlLCB2YWx1ZVR5cGVOYW1lKVxufVxuXG5mdW5jdGlvbiBUZlByb3BlcnR5VHlwZUVycm9yICh0eXBlLCBwcm9wZXJ0eSwgbGFiZWwsIHZhbHVlLCB2YWx1ZVR5cGVOYW1lKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgdmFsdWVUeXBlTmFtZSA9IHZhbHVlVHlwZU5hbWUgfHwgZ2V0VmFsdWVUeXBlTmFtZSh2YWx1ZSlcbiAgICB0aGlzLm1lc3NhZ2UgPSB0ZlByb3BlcnR5RXJyb3JTdHJpbmcodHlwZSwgbGFiZWwsIHByb3BlcnR5LCB2YWx1ZSwgdmFsdWVUeXBlTmFtZSlcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnVW5leHBlY3RlZCBwcm9wZXJ0eSBcIicgKyBwcm9wZXJ0eSArICdcIidcbiAgfVxuXG4gIGNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFRmVHlwZUVycm9yKVxuICB0aGlzLl9fbGFiZWwgPSBsYWJlbFxuICB0aGlzLl9fcHJvcGVydHkgPSBwcm9wZXJ0eVxuICB0aGlzLl9fdHlwZSA9IHR5cGVcbiAgdGhpcy5fX3ZhbHVlID0gdmFsdWVcbiAgdGhpcy5fX3ZhbHVlVHlwZU5hbWUgPSB2YWx1ZVR5cGVOYW1lXG59XG5cblRmUHJvcGVydHlUeXBlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG5UZlByb3BlcnR5VHlwZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRmVHlwZUVycm9yXG5cbmZ1bmN0aW9uIHRmQ3VzdG9tRXJyb3IgKGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgcmV0dXJuIG5ldyBUZlR5cGVFcnJvcihleHBlY3RlZCwge30sIGFjdHVhbClcbn1cblxuZnVuY3Rpb24gdGZTdWJFcnJvciAoZSwgcHJvcGVydHksIGxhYmVsKSB7XG4gIC8vIHN1YiBjaGlsZD9cbiAgaWYgKGUgaW5zdGFuY2VvZiBUZlByb3BlcnR5VHlwZUVycm9yKSB7XG4gICAgcHJvcGVydHkgPSBwcm9wZXJ0eSArICcuJyArIGUuX19wcm9wZXJ0eVxuXG4gICAgZSA9IG5ldyBUZlByb3BlcnR5VHlwZUVycm9yKFxuICAgICAgZS5fX3R5cGUsIHByb3BlcnR5LCBlLl9fbGFiZWwsIGUuX192YWx1ZSwgZS5fX3ZhbHVlVHlwZU5hbWVcbiAgICApXG5cbiAgLy8gY2hpbGQ/XG4gIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIFRmVHlwZUVycm9yKSB7XG4gICAgZSA9IG5ldyBUZlByb3BlcnR5VHlwZUVycm9yKFxuICAgICAgZS5fX3R5cGUsIHByb3BlcnR5LCBsYWJlbCwgZS5fX3ZhbHVlLCBlLl9fdmFsdWVUeXBlTmFtZVxuICAgIClcbiAgfVxuXG4gIGNhcHR1cmVTdGFja1RyYWNlKGUpXG4gIHJldHVybiBlXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUZlR5cGVFcnJvcjogVGZUeXBlRXJyb3IsXG4gIFRmUHJvcGVydHlUeXBlRXJyb3I6IFRmUHJvcGVydHlUeXBlRXJyb3IsXG4gIHRmQ3VzdG9tRXJyb3I6IHRmQ3VzdG9tRXJyb3IsXG4gIHRmU3ViRXJyb3I6IHRmU3ViRXJyb3IsXG4gIHRmSlNPTjogdGZKU09OLFxuICBnZXRWYWx1ZVR5cGVOYW1lOiBnZXRWYWx1ZVR5cGVOYW1lXG59XG4iLCJ2YXIgTkFUSVZFID0gcmVxdWlyZSgnLi9uYXRpdmUnKVxudmFyIEVSUk9SUyA9IHJlcXVpcmUoJy4vZXJyb3JzJylcblxuZnVuY3Rpb24gX0J1ZmZlciAodmFsdWUpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSlcbn1cblxuZnVuY3Rpb24gSGV4ICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAvXihbMC05YS1mXXsyfSkrJC9pLnRlc3QodmFsdWUpXG59XG5cbmZ1bmN0aW9uIF9MZW5ndGhOICh0eXBlLCBsZW5ndGgpIHtcbiAgdmFyIG5hbWUgPSB0eXBlLnRvSlNPTigpXG5cbiAgZnVuY3Rpb24gTGVuZ3RoICh2YWx1ZSkge1xuICAgIGlmICghdHlwZSh2YWx1ZSkpIHJldHVybiBmYWxzZVxuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IGxlbmd0aCkgcmV0dXJuIHRydWVcblxuICAgIHRocm93IEVSUk9SUy50ZkN1c3RvbUVycm9yKG5hbWUgKyAnKExlbmd0aDogJyArIGxlbmd0aCArICcpJywgbmFtZSArICcoTGVuZ3RoOiAnICsgdmFsdWUubGVuZ3RoICsgJyknKVxuICB9XG4gIExlbmd0aC50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuYW1lIH1cblxuICByZXR1cm4gTGVuZ3RoXG59XG5cbnZhciBfQXJyYXlOID0gX0xlbmd0aE4uYmluZChudWxsLCBOQVRJVkUuQXJyYXkpXG52YXIgX0J1ZmZlck4gPSBfTGVuZ3RoTi5iaW5kKG51bGwsIF9CdWZmZXIpXG52YXIgX0hleE4gPSBfTGVuZ3RoTi5iaW5kKG51bGwsIEhleClcbnZhciBfU3RyaW5nTiA9IF9MZW5ndGhOLmJpbmQobnVsbCwgTkFUSVZFLlN0cmluZylcblxuZnVuY3Rpb24gUmFuZ2UgKGEsIGIsIGYpIHtcbiAgZiA9IGYgfHwgTkFUSVZFLk51bWJlclxuICBmdW5jdGlvbiBfcmFuZ2UgKHZhbHVlLCBzdHJpY3QpIHtcbiAgICByZXR1cm4gZih2YWx1ZSwgc3RyaWN0KSAmJiAodmFsdWUgPiBhKSAmJiAodmFsdWUgPCBiKVxuICB9XG4gIF9yYW5nZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGAke2YudG9KU09OKCl9IGJldHdlZW4gWyR7YX0sICR7Yn1dYFxuICB9XG4gIHJldHVybiBfcmFuZ2Vcbn1cblxudmFyIElOVDUzX01BWCA9IE1hdGgucG93KDIsIDUzKSAtIDFcblxuZnVuY3Rpb24gRmluaXRlICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSlcbn1cbmZ1bmN0aW9uIEludDggKHZhbHVlKSB7IHJldHVybiAoKHZhbHVlIDw8IDI0KSA+PiAyNCkgPT09IHZhbHVlIH1cbmZ1bmN0aW9uIEludDE2ICh2YWx1ZSkgeyByZXR1cm4gKCh2YWx1ZSA8PCAxNikgPj4gMTYpID09PSB2YWx1ZSB9XG5mdW5jdGlvbiBJbnQzMiAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSB8IDApID09PSB2YWx1ZSB9XG5mdW5jdGlvbiBJbnQ1MyAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+PSAtSU5UNTNfTUFYICYmXG4gICAgdmFsdWUgPD0gSU5UNTNfTUFYICYmXG4gICAgTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlXG59XG5mdW5jdGlvbiBVSW50OCAodmFsdWUpIHsgcmV0dXJuICh2YWx1ZSAmIDB4ZmYpID09PSB2YWx1ZSB9XG5mdW5jdGlvbiBVSW50MTYgKHZhbHVlKSB7IHJldHVybiAodmFsdWUgJiAweGZmZmYpID09PSB2YWx1ZSB9XG5mdW5jdGlvbiBVSW50MzIgKHZhbHVlKSB7IHJldHVybiAodmFsdWUgPj4+IDApID09PSB2YWx1ZSB9XG5mdW5jdGlvbiBVSW50NTMgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPj0gMCAmJlxuICAgIHZhbHVlIDw9IElOVDUzX01BWCAmJlxuICAgIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZVxufVxuXG52YXIgdHlwZXMgPSB7XG4gIEFycmF5TjogX0FycmF5TixcbiAgQnVmZmVyOiBfQnVmZmVyLFxuICBCdWZmZXJOOiBfQnVmZmVyTixcbiAgRmluaXRlOiBGaW5pdGUsXG4gIEhleDogSGV4LFxuICBIZXhOOiBfSGV4TixcbiAgSW50ODogSW50OCxcbiAgSW50MTY6IEludDE2LFxuICBJbnQzMjogSW50MzIsXG4gIEludDUzOiBJbnQ1MyxcbiAgUmFuZ2U6IFJhbmdlLFxuICBTdHJpbmdOOiBfU3RyaW5nTixcbiAgVUludDg6IFVJbnQ4LFxuICBVSW50MTY6IFVJbnQxNixcbiAgVUludDMyOiBVSW50MzIsXG4gIFVJbnQ1MzogVUludDUzXG59XG5cbmZvciAodmFyIHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gIHR5cGVzW3R5cGVOYW1lXS50b0pTT04gPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0XG4gIH0uYmluZChudWxsLCB0eXBlTmFtZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlc1xuIiwidmFyIEVSUk9SUyA9IHJlcXVpcmUoJy4vZXJyb3JzJylcbnZhciBOQVRJVkUgPSByZXF1aXJlKCcuL25hdGl2ZScpXG5cbi8vIHNob3J0LWhhbmRcbnZhciB0ZkpTT04gPSBFUlJPUlMudGZKU09OXG52YXIgVGZUeXBlRXJyb3IgPSBFUlJPUlMuVGZUeXBlRXJyb3JcbnZhciBUZlByb3BlcnR5VHlwZUVycm9yID0gRVJST1JTLlRmUHJvcGVydHlUeXBlRXJyb3JcbnZhciB0ZlN1YkVycm9yID0gRVJST1JTLnRmU3ViRXJyb3JcbnZhciBnZXRWYWx1ZVR5cGVOYW1lID0gRVJST1JTLmdldFZhbHVlVHlwZU5hbWVcblxudmFyIFRZUEVTID0ge1xuICBhcnJheU9mOiBmdW5jdGlvbiBhcnJheU9mICh0eXBlLCBvcHRpb25zKSB7XG4gICAgdHlwZSA9IGNvbXBpbGUodHlwZSlcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gICAgZnVuY3Rpb24gX2FycmF5T2YgKGFycmF5LCBzdHJpY3QpIHtcbiAgICAgIGlmICghTkFUSVZFLkFycmF5KGFycmF5KSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoTkFUSVZFLk5pbChhcnJheSkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKG9wdGlvbnMubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJyYXkubGVuZ3RoIDwgb3B0aW9ucy5taW5MZW5ndGgpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKG9wdGlvbnMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJyYXkubGVuZ3RoID4gb3B0aW9ucy5tYXhMZW5ndGgpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgYXJyYXkubGVuZ3RoICE9PSBvcHRpb25zLmxlbmd0aCkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHJldHVybiBhcnJheS5ldmVyeShmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdHlwZWZvcmNlKHR5cGUsIHZhbHVlLCBzdHJpY3QpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyB0ZlN1YkVycm9yKGUsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF9hcnJheU9mLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdHIgPSAnWycgKyB0ZkpTT04odHlwZSkgKyAnXSdcbiAgICAgIGlmIChvcHRpb25zLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0ciArPSAneycgKyBvcHRpb25zLmxlbmd0aCArICd9J1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMubWF4TGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3RyICs9ICd7JyArXG4gICAgICAgICAgKG9wdGlvbnMubWluTGVuZ3RoID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5taW5MZW5ndGgpICsgJywnICtcbiAgICAgICAgICAob3B0aW9ucy5tYXhMZW5ndGggPT09IHVuZGVmaW5lZCA/IEluZmluaXR5IDogb3B0aW9ucy5tYXhMZW5ndGgpICsgJ30nXG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyXG4gICAgfVxuXG4gICAgcmV0dXJuIF9hcnJheU9mXG4gIH0sXG5cbiAgbWF5YmU6IGZ1bmN0aW9uIG1heWJlICh0eXBlKSB7XG4gICAgdHlwZSA9IGNvbXBpbGUodHlwZSlcblxuICAgIGZ1bmN0aW9uIF9tYXliZSAodmFsdWUsIHN0cmljdCkge1xuICAgICAgcmV0dXJuIE5BVElWRS5OaWwodmFsdWUpIHx8IHR5cGUodmFsdWUsIHN0cmljdCwgbWF5YmUpXG4gICAgfVxuICAgIF9tYXliZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPycgKyB0ZkpTT04odHlwZSkgfVxuXG4gICAgcmV0dXJuIF9tYXliZVxuICB9LFxuXG4gIG1hcDogZnVuY3Rpb24gbWFwIChwcm9wZXJ0eVR5cGUsIHByb3BlcnR5S2V5VHlwZSkge1xuICAgIHByb3BlcnR5VHlwZSA9IGNvbXBpbGUocHJvcGVydHlUeXBlKVxuICAgIGlmIChwcm9wZXJ0eUtleVR5cGUpIHByb3BlcnR5S2V5VHlwZSA9IGNvbXBpbGUocHJvcGVydHlLZXlUeXBlKVxuXG4gICAgZnVuY3Rpb24gX21hcCAodmFsdWUsIHN0cmljdCkge1xuICAgICAgaWYgKCFOQVRJVkUuT2JqZWN0KHZhbHVlKSkgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoTkFUSVZFLk5pbCh2YWx1ZSkpIHJldHVybiBmYWxzZVxuXG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eU5hbWUgaW4gdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAocHJvcGVydHlLZXlUeXBlKSB7XG4gICAgICAgICAgICB0eXBlZm9yY2UocHJvcGVydHlLZXlUeXBlLCBwcm9wZXJ0eU5hbWUsIHN0cmljdClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyB0ZlN1YkVycm9yKGUsIHByb3BlcnR5TmFtZSwgJ2tleScpXG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gdmFsdWVbcHJvcGVydHlOYW1lXVxuICAgICAgICAgIHR5cGVmb3JjZShwcm9wZXJ0eVR5cGUsIHByb3BlcnR5VmFsdWUsIHN0cmljdClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IHRmU3ViRXJyb3IoZSwgcHJvcGVydHlOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHByb3BlcnR5S2V5VHlwZSkge1xuICAgICAgX21hcC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAneycgKyB0ZkpTT04ocHJvcGVydHlLZXlUeXBlKSArICc6ICcgKyB0ZkpTT04ocHJvcGVydHlUeXBlKSArICd9J1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfbWFwLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICd7JyArIHRmSlNPTihwcm9wZXJ0eVR5cGUpICsgJ30nIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX21hcFxuICB9LFxuXG4gIG9iamVjdDogZnVuY3Rpb24gb2JqZWN0ICh1bmNvbXBpbGVkKSB7XG4gICAgdmFyIHR5cGUgPSB7fVxuXG4gICAgZm9yICh2YXIgdHlwZVByb3BlcnR5TmFtZSBpbiB1bmNvbXBpbGVkKSB7XG4gICAgICB0eXBlW3R5cGVQcm9wZXJ0eU5hbWVdID0gY29tcGlsZSh1bmNvbXBpbGVkW3R5cGVQcm9wZXJ0eU5hbWVdKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9vYmplY3QgKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgIGlmICghTkFUSVZFLk9iamVjdCh2YWx1ZSkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKE5BVElWRS5OaWwodmFsdWUpKSByZXR1cm4gZmFsc2VcblxuICAgICAgdmFyIHByb3BlcnR5TmFtZVxuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHByb3BlcnR5TmFtZSBpbiB0eXBlKSB7XG4gICAgICAgICAgdmFyIHByb3BlcnR5VHlwZSA9IHR5cGVbcHJvcGVydHlOYW1lXVxuICAgICAgICAgIHZhciBwcm9wZXJ0eVZhbHVlID0gdmFsdWVbcHJvcGVydHlOYW1lXVxuXG4gICAgICAgICAgdHlwZWZvcmNlKHByb3BlcnR5VHlwZSwgcHJvcGVydHlWYWx1ZSwgc3RyaWN0KVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93IHRmU3ViRXJyb3IoZSwgcHJvcGVydHlOYW1lKVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgIGZvciAocHJvcGVydHlOYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVbcHJvcGVydHlOYW1lXSkgY29udGludWVcblxuICAgICAgICAgIHRocm93IG5ldyBUZlByb3BlcnR5VHlwZUVycm9yKHVuZGVmaW5lZCwgcHJvcGVydHlOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIF9vYmplY3QudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGZKU09OKHR5cGUpIH1cblxuICAgIHJldHVybiBfb2JqZWN0XG4gIH0sXG5cbiAgYW55T2Y6IGZ1bmN0aW9uIGFueU9mICgpIHtcbiAgICB2YXIgdHlwZXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykubWFwKGNvbXBpbGUpXG5cbiAgICBmdW5jdGlvbiBfYW55T2YgKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgIHJldHVybiB0eXBlcy5zb21lKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVmb3JjZSh0eXBlLCB2YWx1ZSwgc3RyaWN0KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF9hbnlPZi50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlcy5tYXAodGZKU09OKS5qb2luKCd8JykgfVxuXG4gICAgcmV0dXJuIF9hbnlPZlxuICB9LFxuXG4gIGFsbE9mOiBmdW5jdGlvbiBhbGxPZiAoKSB7XG4gICAgdmFyIHR5cGVzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLm1hcChjb21waWxlKVxuXG4gICAgZnVuY3Rpb24gX2FsbE9mICh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICByZXR1cm4gdHlwZXMuZXZlcnkoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdHlwZWZvcmNlKHR5cGUsIHZhbHVlLCBzdHJpY3QpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgX2FsbE9mLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzLm1hcCh0ZkpTT04pLmpvaW4oJyAmICcpIH1cblxuICAgIHJldHVybiBfYWxsT2ZcbiAgfSxcblxuICBxdWFja3NMaWtlOiBmdW5jdGlvbiBxdWFja3NMaWtlICh0eXBlKSB7XG4gICAgZnVuY3Rpb24gX3F1YWNrc0xpa2UgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gZ2V0VmFsdWVUeXBlTmFtZSh2YWx1ZSlcbiAgICB9XG4gICAgX3F1YWNrc0xpa2UudG9KU09OID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZSB9XG5cbiAgICByZXR1cm4gX3F1YWNrc0xpa2VcbiAgfSxcblxuICB0dXBsZTogZnVuY3Rpb24gdHVwbGUgKCkge1xuICAgIHZhciB0eXBlcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5tYXAoY29tcGlsZSlcblxuICAgIGZ1bmN0aW9uIF90dXBsZSAodmFsdWVzLCBzdHJpY3QpIHtcbiAgICAgIGlmIChOQVRJVkUuTmlsKHZhbHVlcykpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKE5BVElWRS5OaWwodmFsdWVzLmxlbmd0aCkpIHJldHVybiBmYWxzZVxuICAgICAgaWYgKHN0cmljdCAmJiAodmFsdWVzLmxlbmd0aCAhPT0gdHlwZXMubGVuZ3RoKSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgIHJldHVybiB0eXBlcy5ldmVyeShmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB0eXBlZm9yY2UodHlwZSwgdmFsdWVzW2ldLCBzdHJpY3QpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aHJvdyB0ZlN1YkVycm9yKGUsIGkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIF90dXBsZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnKCcgKyB0eXBlcy5tYXAodGZKU09OKS5qb2luKCcsICcpICsgJyknIH1cblxuICAgIHJldHVybiBfdHVwbGVcbiAgfSxcblxuICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUgKGV4cGVjdGVkKSB7XG4gICAgZnVuY3Rpb24gX3ZhbHVlIChhY3R1YWwpIHtcbiAgICAgIHJldHVybiBhY3R1YWwgPT09IGV4cGVjdGVkXG4gICAgfVxuICAgIF92YWx1ZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleHBlY3RlZCB9XG5cbiAgICByZXR1cm4gX3ZhbHVlXG4gIH1cbn1cblxuLy8gVE9ETzogZGVwcmVjYXRlXG5UWVBFUy5vbmVPZiA9IFRZUEVTLmFueU9mXG5cbmZ1bmN0aW9uIGNvbXBpbGUgKHR5cGUpIHtcbiAgaWYgKE5BVElWRS5TdHJpbmcodHlwZSkpIHtcbiAgICBpZiAodHlwZVswXSA9PT0gJz8nKSByZXR1cm4gVFlQRVMubWF5YmUodHlwZS5zbGljZSgxKSlcblxuICAgIHJldHVybiBOQVRJVkVbdHlwZV0gfHwgVFlQRVMucXVhY2tzTGlrZSh0eXBlKVxuICB9IGVsc2UgaWYgKHR5cGUgJiYgTkFUSVZFLk9iamVjdCh0eXBlKSkge1xuICAgIGlmIChOQVRJVkUuQXJyYXkodHlwZSkpIHtcbiAgICAgIGlmICh0eXBlLmxlbmd0aCAhPT0gMSkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgY29tcGlsZSgpIHBhcmFtZXRlciBvZiB0eXBlIEFycmF5IG9mIGxlbmd0aCAxJylcbiAgICAgIHJldHVybiBUWVBFUy5hcnJheU9mKHR5cGVbMF0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFRZUEVTLm9iamVjdCh0eXBlKVxuICB9IGVsc2UgaWYgKE5BVElWRS5GdW5jdGlvbih0eXBlKSkge1xuICAgIHJldHVybiB0eXBlXG4gIH1cblxuICByZXR1cm4gVFlQRVMudmFsdWUodHlwZSlcbn1cblxuZnVuY3Rpb24gdHlwZWZvcmNlICh0eXBlLCB2YWx1ZSwgc3RyaWN0LCBzdXJyb2dhdGUpIHtcbiAgaWYgKE5BVElWRS5GdW5jdGlvbih0eXBlKSkge1xuICAgIGlmICh0eXBlKHZhbHVlLCBzdHJpY3QpKSByZXR1cm4gdHJ1ZVxuXG4gICAgdGhyb3cgbmV3IFRmVHlwZUVycm9yKHN1cnJvZ2F0ZSB8fCB0eXBlLCB2YWx1ZSlcbiAgfVxuXG4gIC8vIEpJVFxuICByZXR1cm4gdHlwZWZvcmNlKGNvbXBpbGUodHlwZSksIHZhbHVlLCBzdHJpY3QpXG59XG5cbi8vIGFzc2lnbiB0eXBlcyB0byB0eXBlZm9yY2UgZnVuY3Rpb25cbmZvciAodmFyIHR5cGVOYW1lIGluIE5BVElWRSkge1xuICB0eXBlZm9yY2VbdHlwZU5hbWVdID0gTkFUSVZFW3R5cGVOYW1lXVxufVxuXG5mb3IgKHR5cGVOYW1lIGluIFRZUEVTKSB7XG4gIHR5cGVmb3JjZVt0eXBlTmFtZV0gPSBUWVBFU1t0eXBlTmFtZV1cbn1cblxudmFyIEVYVFJBID0gcmVxdWlyZSgnLi9leHRyYScpXG5mb3IgKHR5cGVOYW1lIGluIEVYVFJBKSB7XG4gIHR5cGVmb3JjZVt0eXBlTmFtZV0gPSBFWFRSQVt0eXBlTmFtZV1cbn1cblxudHlwZWZvcmNlLmNvbXBpbGUgPSBjb21waWxlXG50eXBlZm9yY2UuVGZUeXBlRXJyb3IgPSBUZlR5cGVFcnJvclxudHlwZWZvcmNlLlRmUHJvcGVydHlUeXBlRXJyb3IgPSBUZlByb3BlcnR5VHlwZUVycm9yXG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZWZvcmNlXG4iLCJ2YXIgdHlwZXMgPSB7XG4gIEFycmF5OiBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IEFycmF5IH0sXG4gIEJvb2xlYW46IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfSxcbiAgRnVuY3Rpb246IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIH0sXG4gIE5pbDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsIH0sXG4gIE51bWJlcjogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIH0sXG4gIE9iamVjdDogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIH0sXG4gIFN0cmluZzogZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIH0sXG4gICcnOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH1cbn1cblxuLy8gVE9ETzogZGVwcmVjYXRlXG50eXBlcy5OdWxsID0gdHlwZXMuTmlsXG5cbmZvciAodmFyIHR5cGVOYW1lIGluIHR5cGVzKSB7XG4gIHR5cGVzW3R5cGVOYW1lXS50b0pTT04gPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0XG4gIH0uYmluZChudWxsLCB0eXBlTmFtZSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlc1xuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBVaW50OEFycmF5IGNyZWF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFzc2VkIEFycmF5TGlrZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5TGlrZTxudW1iZXI+Pn0gYXJyYXlzXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF1cbiAqL1xuZnVuY3Rpb24gY29uY2F0IChhcnJheXMsIGxlbmd0aCkge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5sZW5ndGgsIDApXG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmNhdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gcGFzc2VkIFVpbnQ4QXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudFxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBiXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyAoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGVuY29kaW5nOiBnZXRDb2RlYyB9ID0gcmVxdWlyZSgnbXVsdGliYXNlJylcbmNvbnN0IHV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcblxuLyoqXG4gKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnbXVsdGliYXNlL3NyYy90eXBlcycpLkJhc2VOYW1lIHwgJ3V0ZjgnIHwgJ3V0Zi04JyB8ICdhc2NpaScgfCB1bmRlZmluZWR9IFN1cHBvcnRlZEVuY29kaW5nc1xuICovXG5cbi8qKlxuICogSW50ZXJwcmV0cyBlYWNoIGNoYXJhY3RlciBpbiBhIHN0cmluZyBhcyBhIGJ5dGUgYW5kXG4gKiByZXR1cm5zIGEgVWludDhBcnJheSBvZiB0aG9zZSBieXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIHN0cmluZyB0byB0dXJuIGludG8gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gYXNjaWlTdHJpbmdUb1VpbnQ4QXJyYXkgKHN0cmluZykge1xuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KHN0cmluZy5sZW5ndGgpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG4gIH1cblxuICByZXR1cm4gYXJyYXlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgVWludDhBcnJheWAgZnJvbSB0aGUgcGFzc2VkIHN0cmluZ1xuICpcbiAqIFN1cHBvcnRzIGB1dGY4YCwgYHV0Zi04YCBhbmQgYW55IGVuY29kaW5nIHN1cHBvcnRlZCBieSB0aGUgbXVsdGliYXNlIG1vZHVsZS5cbiAqXG4gKiBBbHNvIGBhc2NpaWAgd2hpY2ggaXMgc2ltaWxhciB0byBub2RlJ3MgJ2JpbmFyeScgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtTdXBwb3J0ZWRFbmNvZGluZ3N9IFtlbmNvZGluZz11dGY4XSAtIHV0ZjgsIGJhc2UxNiwgYmFzZTY0LCBiYXNlNjR1cmxwYWQsIGV0Y1xuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICByZXR1cm4gdXRmOEVuY29kZXIuZW5jb2RlKHN0cmluZylcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgIHJldHVybiBhc2NpaVN0cmluZ1RvVWludDhBcnJheShzdHJpbmcpXG4gIH1cblxuICByZXR1cm4gZ2V0Q29kZWMoZW5jb2RpbmcpLmRlY29kZShzdHJpbmcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnJvbVN0cmluZ1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZW5jb2Rpbmc6IGdldENvZGVjIH0gPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCdtdWx0aWJhc2Uvc3JjL3R5cGVzJykuQmFzZU5hbWUgfCAndXRmOCcgfCAndXRmLTgnIHwgJ2FzY2lpJyB8IHVuZGVmaW5lZH0gU3VwcG9ydGVkRW5jb2RpbmdzXG4gKi9cblxuLyoqXG4gKiBUdXJucyBhIFVpbnQ4QXJyYXkgb2YgYnl0ZXMgaW50byBhIHN0cmluZyB3aXRoIGVhY2hcbiAqIGNoYXJhY3RlciBiZWluZyB0aGUgY2hhciBjb2RlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGJ5dGVcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHR1cm4gaW50byBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiB1aW50OEFycmF5VG9Bc2NpaVN0cmluZyAoYXJyYXkpIHtcbiAgbGV0IHN0cmluZyA9ICcnXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKVxuICB9XG4gIHJldHVybiBzdHJpbmdcbn1cblxuLyoqXG4gKiBUdXJucyBhIGBVaW50OEFycmF5YCBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIFN1cHBvcnRzIGB1dGY4YCwgYHV0Zi04YCBhbmQgYW55IGVuY29kaW5nIHN1cHBvcnRlZCBieSB0aGUgbXVsdGliYXNlIG1vZHVsZS5cbiAqXG4gKiBBbHNvIGBhc2NpaWAgd2hpY2ggaXMgc2ltaWxhciB0byBub2RlJ3MgJ2JpbmFyeScgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byB0dXJuIGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3VwcG9ydGVkRW5jb2RpbmdzfSBbZW5jb2Rpbmc9dXRmOF0gLSBUaGUgZW5jb2RpbmcgdG8gdXNlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAoYXJyYXksIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZShhcnJheSlcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgIHJldHVybiB1aW50OEFycmF5VG9Bc2NpaVN0cmluZyhhcnJheSlcbiAgfVxuXG4gIHJldHVybiBnZXRDb2RlYyhlbmNvZGluZykuZW5jb2RlKGFycmF5KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nXG4iLCIndXNlIHN0cmljdCdcblxudmFyIHNjb3BlZFBhY2thZ2VQYXR0ZXJuID0gbmV3IFJlZ0V4cCgnXig/OkAoW14vXSs/KVsvXSk/KFteL10rPykkJylcbnZhciBidWlsdGlucyA9IHJlcXVpcmUoJ2J1aWx0aW5zJylcbnZhciBibGFja2xpc3QgPSBbXG4gICdub2RlX21vZHVsZXMnLFxuICAnZmF2aWNvbi5pY28nLFxuXVxuXG5mdW5jdGlvbiB2YWxpZGF0ZSAobmFtZSkge1xuICB2YXIgd2FybmluZ3MgPSBbXVxuICB2YXIgZXJyb3JzID0gW11cblxuICBpZiAobmFtZSA9PT0gbnVsbCkge1xuICAgIGVycm9ycy5wdXNoKCduYW1lIGNhbm5vdCBiZSBudWxsJylcbiAgICByZXR1cm4gZG9uZSh3YXJuaW5ncywgZXJyb3JzKVxuICB9XG5cbiAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGVycm9ycy5wdXNoKCduYW1lIGNhbm5vdCBiZSB1bmRlZmluZWQnKVxuICAgIHJldHVybiBkb25lKHdhcm5pbmdzLCBlcnJvcnMpXG4gIH1cblxuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgZXJyb3JzLnB1c2goJ25hbWUgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgcmV0dXJuIGRvbmUod2FybmluZ3MsIGVycm9ycylcbiAgfVxuXG4gIGlmICghbmFtZS5sZW5ndGgpIHtcbiAgICBlcnJvcnMucHVzaCgnbmFtZSBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybycpXG4gIH1cblxuICBpZiAobmFtZS5tYXRjaCgvXlxcLi8pKSB7XG4gICAgZXJyb3JzLnB1c2goJ25hbWUgY2Fubm90IHN0YXJ0IHdpdGggYSBwZXJpb2QnKVxuICB9XG5cbiAgaWYgKG5hbWUubWF0Y2goL15fLykpIHtcbiAgICBlcnJvcnMucHVzaCgnbmFtZSBjYW5ub3Qgc3RhcnQgd2l0aCBhbiB1bmRlcnNjb3JlJylcbiAgfVxuXG4gIGlmIChuYW1lLnRyaW0oKSAhPT0gbmFtZSkge1xuICAgIGVycm9ycy5wdXNoKCduYW1lIGNhbm5vdCBjb250YWluIGxlYWRpbmcgb3IgdHJhaWxpbmcgc3BhY2VzJylcbiAgfVxuXG4gIC8vIE5vIGZ1bm55IGJ1c2luZXNzXG4gIGJsYWNrbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChibGFja2xpc3RlZE5hbWUpIHtcbiAgICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpID09PSBibGFja2xpc3RlZE5hbWUpIHtcbiAgICAgIGVycm9ycy5wdXNoKGJsYWNrbGlzdGVkTmFtZSArICcgaXMgYSBibGFja2xpc3RlZCBuYW1lJylcbiAgICB9XG4gIH0pXG5cbiAgLy8gR2VuZXJhdGUgd2FybmluZ3MgZm9yIHN0dWZmIHRoYXQgdXNlZCB0byBiZSBhbGxvd2VkXG5cbiAgLy8gY29yZSBtb2R1bGUgbmFtZXMgbGlrZSBodHRwLCBldmVudHMsIHV0aWwsIGV0Y1xuICBidWlsdGlucyh7IHZlcnNpb246ICcqJyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChidWlsdGluKSB7XG4gICAgaWYgKG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gYnVpbHRpbikge1xuICAgICAgd2FybmluZ3MucHVzaChidWlsdGluICsgJyBpcyBhIGNvcmUgbW9kdWxlIG5hbWUnKVxuICAgIH1cbiAgfSlcblxuICBpZiAobmFtZS5sZW5ndGggPiAyMTQpIHtcbiAgICB3YXJuaW5ncy5wdXNoKCduYW1lIGNhbiBubyBsb25nZXIgY29udGFpbiBtb3JlIHRoYW4gMjE0IGNoYXJhY3RlcnMnKVxuICB9XG5cbiAgLy8gbUl4ZUQgQ2FTZSBuQU1Fc1xuICBpZiAobmFtZS50b0xvd2VyQ2FzZSgpICE9PSBuYW1lKSB7XG4gICAgd2FybmluZ3MucHVzaCgnbmFtZSBjYW4gbm8gbG9uZ2VyIGNvbnRhaW4gY2FwaXRhbCBsZXR0ZXJzJylcbiAgfVxuXG4gIGlmICgvW34nISgpKl0vLnRlc3QobmFtZS5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSkpIHtcbiAgICB3YXJuaW5ncy5wdXNoKCduYW1lIGNhbiBubyBsb25nZXIgY29udGFpbiBzcGVjaWFsIGNoYXJhY3RlcnMgKFwiflxcJyEoKSpcIiknKVxuICB9XG5cbiAgaWYgKGVuY29kZVVSSUNvbXBvbmVudChuYW1lKSAhPT0gbmFtZSkge1xuICAgIC8vIE1heWJlIGl0J3MgYSBzY29wZWQgcGFja2FnZSBuYW1lLCBsaWtlIEB1c2VyL3BhY2thZ2VcbiAgICB2YXIgbmFtZU1hdGNoID0gbmFtZS5tYXRjaChzY29wZWRQYWNrYWdlUGF0dGVybilcbiAgICBpZiAobmFtZU1hdGNoKSB7XG4gICAgICB2YXIgdXNlciA9IG5hbWVNYXRjaFsxXVxuICAgICAgdmFyIHBrZyA9IG5hbWVNYXRjaFsyXVxuICAgICAgaWYgKGVuY29kZVVSSUNvbXBvbmVudCh1c2VyKSA9PT0gdXNlciAmJiBlbmNvZGVVUklDb21wb25lbnQocGtnKSA9PT0gcGtnKSB7XG4gICAgICAgIHJldHVybiBkb25lKHdhcm5pbmdzLCBlcnJvcnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZXJyb3JzLnB1c2goJ25hbWUgY2FuIG9ubHkgY29udGFpbiBVUkwtZnJpZW5kbHkgY2hhcmFjdGVycycpXG4gIH1cblxuICByZXR1cm4gZG9uZSh3YXJuaW5ncywgZXJyb3JzKVxufVxuXG52YXIgZG9uZSA9IGZ1bmN0aW9uICh3YXJuaW5ncywgZXJyb3JzKSB7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgdmFsaWRGb3JOZXdQYWNrYWdlczogZXJyb3JzLmxlbmd0aCA9PT0gMCAmJiB3YXJuaW5ncy5sZW5ndGggPT09IDAsXG4gICAgdmFsaWRGb3JPbGRQYWNrYWdlczogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICB3YXJuaW5nczogd2FybmluZ3MsXG4gICAgZXJyb3JzOiBlcnJvcnMsXG4gIH1cbiAgaWYgKCFyZXN1bHQud2FybmluZ3MubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHJlc3VsdC53YXJuaW5nc1xuICB9XG4gIGlmICghcmVzdWx0LmVycm9ycy5sZW5ndGgpIHtcbiAgICBkZWxldGUgcmVzdWx0LmVycm9yc1xuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcblxuLy8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MVxuXG5mdW5jdGlvbiBjaGVja1VJbnQ1MyAobikge1xuICBpZiAobiA8IDAgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgbiAlIDEgIT09IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiBlbmNvZGUgKG51bWJlciwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgY2hlY2tVSW50NTMobnVtYmVyKVxuXG4gIGlmICghYnVmZmVyKSBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoZW5jb2RpbmdMZW5ndGgobnVtYmVyKSlcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmZmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAoIW9mZnNldCkgb2Zmc2V0ID0gMFxuXG4gIC8vIDggYml0XG4gIGlmIChudW1iZXIgPCAweGZkKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgobnVtYmVyLCBvZmZzZXQpXG4gICAgZW5jb2RlLmJ5dGVzID0gMVxuXG4gIC8vIDE2IGJpdFxuICB9IGVsc2UgaWYgKG51bWJlciA8PSAweGZmZmYpIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZkLCBvZmZzZXQpXG4gICAgYnVmZmVyLndyaXRlVUludDE2TEUobnVtYmVyLCBvZmZzZXQgKyAxKVxuICAgIGVuY29kZS5ieXRlcyA9IDNcblxuICAvLyAzMiBiaXRcbiAgfSBlbHNlIGlmIChudW1iZXIgPD0gMHhmZmZmZmZmZikge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmUsIG9mZnNldClcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShudW1iZXIsIG9mZnNldCArIDEpXG4gICAgZW5jb2RlLmJ5dGVzID0gNVxuXG4gIC8vIDY0IGJpdFxuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYsIG9mZnNldClcbiAgICBidWZmZXIud3JpdGVVSW50MzJMRShudW1iZXIgPj4+IDAsIG9mZnNldCArIDEpXG4gICAgYnVmZmVyLndyaXRlVUludDMyTEUoKG51bWJlciAvIDB4MTAwMDAwMDAwKSB8IDAsIG9mZnNldCArIDUpXG4gICAgZW5jb2RlLmJ5dGVzID0gOVxuICB9XG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBkZWNvZGUgKGJ1ZmZlciwgb2Zmc2V0KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J1ZmZlciBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKCFvZmZzZXQpIG9mZnNldCA9IDBcblxuICB2YXIgZmlyc3QgPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldClcblxuICAvLyA4IGJpdFxuICBpZiAoZmlyc3QgPCAweGZkKSB7XG4gICAgZGVjb2RlLmJ5dGVzID0gMVxuICAgIHJldHVybiBmaXJzdFxuXG4gIC8vIDE2IGJpdFxuICB9IGVsc2UgaWYgKGZpcnN0ID09PSAweGZkKSB7XG4gICAgZGVjb2RlLmJ5dGVzID0gM1xuICAgIHJldHVybiBidWZmZXIucmVhZFVJbnQxNkxFKG9mZnNldCArIDEpXG5cbiAgLy8gMzIgYml0XG4gIH0gZWxzZSBpZiAoZmlyc3QgPT09IDB4ZmUpIHtcbiAgICBkZWNvZGUuYnl0ZXMgPSA1XG4gICAgcmV0dXJuIGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgMSlcblxuICAvLyA2NCBiaXRcbiAgfSBlbHNlIHtcbiAgICBkZWNvZGUuYnl0ZXMgPSA5XG4gICAgdmFyIGxvID0gYnVmZmVyLnJlYWRVSW50MzJMRShvZmZzZXQgKyAxKVxuICAgIHZhciBoaSA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNSlcbiAgICB2YXIgbnVtYmVyID0gaGkgKiAweDAxMDAwMDAwMDAgKyBsb1xuICAgIGNoZWNrVUludDUzKG51bWJlcilcblxuICAgIHJldHVybiBudW1iZXJcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmNvZGluZ0xlbmd0aCAobnVtYmVyKSB7XG4gIGNoZWNrVUludDUzKG51bWJlcilcblxuICByZXR1cm4gKFxuICAgIG51bWJlciA8IDB4ZmQgPyAxXG4gICAgICA6IG51bWJlciA8PSAweGZmZmYgPyAzXG4gICAgICAgIDogbnVtYmVyIDw9IDB4ZmZmZmZmZmYgPyA1XG4gICAgICAgICAgOiA5XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGVuY29kZTogZW5jb2RlLCBkZWNvZGU6IGRlY29kZSwgZW5jb2RpbmdMZW5ndGg6IGVuY29kaW5nTGVuZ3RoIH1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmV4cG9ydHMuVGV4dEVuY29kZXIgPVxuICB0eXBlb2YgVGV4dEVuY29kZXIgIT09IFwidW5kZWZpbmVkXCIgPyBUZXh0RW5jb2RlciA6IHJlcXVpcmUoXCJ1dGlsXCIpLlRleHRFbmNvZGVyXG5cbmV4cG9ydHMuVGV4dERlY29kZXIgPVxuICB0eXBlb2YgVGV4dERlY29kZXIgIT09IFwidW5kZWZpbmVkXCIgPyBUZXh0RGVjb2RlciA6IHJlcXVpcmUoXCJ1dGlsXCIpLlRleHREZWNvZGVyXG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwuV0hBVFdHRmV0Y2ggPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZ2xvYmFsID1cbiAgICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMpIHx8XG4gICAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmKSB8fFxuICAgICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpO1xuXG4gIHZhciBzdXBwb3J0ID0ge1xuICAgIHNlYXJjaFBhcmFtczogJ1VSTFNlYXJjaFBhcmFtcycgaW4gZ2xvYmFsLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnbG9iYWwgJiYgJ2l0ZXJhdG9yJyBpbiBTeW1ib2wsXG4gICAgYmxvYjpcbiAgICAgICdGaWxlUmVhZGVyJyBpbiBnbG9iYWwgJiZcbiAgICAgICdCbG9iJyBpbiBnbG9iYWwgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBnbG9iYWwsXG4gICAgYXJyYXlCdWZmZXI6ICdBcnJheUJ1ZmZlcicgaW4gZ2xvYmFsXG4gIH07XG5cbiAgZnVuY3Rpb24gaXNEYXRhVmlldyhvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIERhdGFWaWV3LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKG9iailcbiAgfVxuXG4gIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyKSB7XG4gICAgdmFyIHZpZXdDbGFzc2VzID0gW1xuICAgICAgJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nXG4gICAgXTtcblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9XG4gICAgICBBcnJheUJ1ZmZlci5pc1ZpZXcgfHxcbiAgICAgIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHZpZXdDbGFzc2VzLmluZGV4T2YoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikpID4gLTFcbiAgICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5eX2B8fiFdL2kudGVzdChuYW1lKSB8fCBuYW1lID09PSAnJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgaW4gaGVhZGVyIGZpZWxkIG5hbWU6IFwiJyArIG5hbWUgKyAnXCInKVxuICAgIH1cbiAgICByZXR1cm4gbmFtZS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLy8gQnVpbGQgYSBkZXN0cnVjdGl2ZSBpdGVyYXRvciBmb3IgdGhlIHZhbHVlIGxpc3RcbiAgZnVuY3Rpb24gaXRlcmF0b3JGb3IoaXRlbXMpIHtcbiAgICB2YXIgaXRlcmF0b3IgPSB7XG4gICAgICBuZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXRlbXMuc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIHtkb25lOiB2YWx1ZSA9PT0gdW5kZWZpbmVkLCB2YWx1ZTogdmFsdWV9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgICBpdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvclxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXRlcmF0b3JcbiAgfVxuXG4gIGZ1bmN0aW9uIEhlYWRlcnMoaGVhZGVycykge1xuICAgIHRoaXMubWFwID0ge307XG5cbiAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaGVhZGVyWzBdLCBoZWFkZXJbMV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChoZWFkZXJzKSB7XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhoZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgaGVhZGVyc1tuYW1lXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gIH1cblxuICBIZWFkZXJzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHZhbHVlID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICAgIHZhciBvbGRWYWx1ZSA9IHRoaXMubWFwW25hbWVdO1xuICAgIHRoaXMubWFwW25hbWVdID0gb2xkVmFsdWUgPyBvbGRWYWx1ZSArICcsICcgKyB2YWx1ZSA6IHZhbHVlO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlWydkZWxldGUnXSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV07XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIG5hbWUgPSBub3JtYWxpemVOYW1lKG5hbWUpO1xuICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMubWFwW25hbWVdIDogbnVsbFxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuaGFzT3duUHJvcGVydHkobm9ybWFsaXplTmFtZShuYW1lKSlcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldID0gbm9ybWFsaXplVmFsdWUodmFsdWUpO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbihjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5tYXApIHtcbiAgICAgIGlmICh0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHRoaXMubWFwW25hbWVdLCBuYW1lLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChuYW1lKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgaXRlbXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaXRlcmF0b3JGb3IoaXRlbXMpXG4gIH07XG5cbiAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN1bWVkKGJvZHkpIHtcbiAgICBpZiAoYm9keS5ib2R5VXNlZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpKVxuICAgIH1cbiAgICBib2R5LmJvZHlVc2VkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICByZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgcmVhZGVyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KHJlYWRlci5lcnJvcik7XG4gICAgICB9O1xuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzQXJyYXlCdWZmZXIoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQmxvYkFzVGV4dChibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzVGV4dChibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpO1xuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIC8qXG4gICAgICAgIGZldGNoLW1vY2sgd3JhcHMgdGhlIFJlc3BvbnNlIG9iamVjdCBpbiBhbiBFUzYgUHJveHkgdG9cbiAgICAgICAgcHJvdmlkZSB1c2VmdWwgdGVzdCBoYXJuZXNzIGZlYXR1cmVzIHN1Y2ggYXMgZmx1c2guIEhvd2V2ZXIsIG9uXG4gICAgICAgIEVTNSBicm93c2VycyB3aXRob3V0IGZldGNoIG9yIFByb3h5IHN1cHBvcnQgcG9sbHlmaWxscyBtdXN0IGJlIHVzZWQ7XG4gICAgICAgIHRoZSBwcm94eS1wb2xseWZpbGwgaXMgdW5hYmxlIHRvIHByb3h5IGFuIGF0dHJpYnV0ZSB1bmxlc3MgaXQgZXhpc3RzXG4gICAgICAgIG9uIHRoZSBvYmplY3QgYmVmb3JlIHRoZSBQcm94eSBpcyBjcmVhdGVkLiBUaGlzIGNoYW5nZSBlbnN1cmVzXG4gICAgICAgIFJlc3BvbnNlLmJvZHlVc2VkIGV4aXN0cyBvbiB0aGUgaW5zdGFuY2UsIHdoaWxlIG1haW50YWluaW5nIHRoZVxuICAgICAgICBzZW1hbnRpYyBvZiBzZXR0aW5nIFJlcXVlc3QuYm9keVVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgICBfaW5pdEJvZHkgaXMgY2FsbGVkLlxuICAgICAgKi9cbiAgICAgIHRoaXMuYm9keVVzZWQgPSB0aGlzLmJvZHlVc2VkO1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpO1xuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGJvZHkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUJsb2IgJiYgdGhpcy5fYm9keUJsb2IudHlwZSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsIHRoaXMuX2JvZHlCbG9iLnR5cGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmJsb2IpIHtcbiAgICAgIHRoaXMuYmxvYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlCbG9iKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyBibG9iJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5VGV4dF0pKVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFycmF5QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICB2YXIgaXNDb25zdW1lZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICAgIGlmIChpc0NvbnN1bWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNDb25zdW1lZFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQgKyB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZUxlbmd0aFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUFycmF5QnVmZmVyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5ibG9iKCkudGhlbihyZWFkQmxvYkFzQXJyYXlCdWZmZXIpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy50ZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVqZWN0ZWQgPSBjb25zdW1lZCh0aGlzKTtcbiAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgIHJldHVybiByZWFkQmxvYkFzVGV4dCh0aGlzLl9ib2R5QmxvYilcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVhZEFycmF5QnVmZmVyQXNUZXh0KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlGb3JtRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgdGV4dCcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2JvZHlUZXh0KVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5mb3JtRGF0YSkge1xuICAgICAgdGhpcy5mb3JtRGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihkZWNvZGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMuanNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oSlNPTi5wYXJzZSlcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEhUVFAgbWV0aG9kcyB3aG9zZSBjYXBpdGFsaXphdGlvbiBzaG91bGQgYmUgbm9ybWFsaXplZFxuICB2YXIgbWV0aG9kcyA9IFsnREVMRVRFJywgJ0dFVCcsICdIRUFEJywgJ09QVElPTlMnLCAnUE9TVCcsICdQVVQnXTtcblxuICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2QobWV0aG9kKSB7XG4gICAgdmFyIHVwY2FzZWQgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICByZXR1cm4gbWV0aG9kcy5pbmRleE9mKHVwY2FzZWQpID4gLTEgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlcXVlc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQbGVhc2UgdXNlIHRoZSBcIm5ld1wiIG9wZXJhdG9yLCB0aGlzIERPTSBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHk7XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsO1xuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzO1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycyk7XG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZDtcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGU7XG4gICAgICB0aGlzLnNpZ25hbCA9IGlucHV0LnNpZ25hbDtcbiAgICAgIGlmICghYm9keSAmJiBpbnB1dC5fYm9keUluaXQgIT0gbnVsbCkge1xuICAgICAgICBib2R5ID0gaW5wdXQuX2JvZHlJbml0O1xuICAgICAgICBpbnB1dC5ib2R5VXNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXJsID0gU3RyaW5nKGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gb3B0aW9ucy5jcmVkZW50aWFscyB8fCB0aGlzLmNyZWRlbnRpYWxzIHx8ICdzYW1lLW9yaWdpbic7XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJyk7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsO1xuICAgIHRoaXMuc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgfHwgdGhpcy5zaWduYWw7XG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGw7XG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpO1xuXG4gICAgaWYgKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICBpZiAob3B0aW9ucy5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBvcHRpb25zLmNhY2hlID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYSAnXycgcGFyYW1ldGVyIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgICAgdmFyIHJlUGFyYW1TZWFyY2ggPSAvKFs/Jl0pXz1bXiZdKi87XG4gICAgICAgIGlmIChyZVBhcmFtU2VhcmNoLnRlc3QodGhpcy51cmwpKSB7XG4gICAgICAgICAgLy8gSWYgaXQgYWxyZWFkeSBleGlzdHMgdGhlbiBzZXQgdGhlIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwucmVwbGFjZShyZVBhcmFtU2VhcmNoLCAnJDFfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBhIG5ldyAnXycgcGFyYW1ldGVyIHRvIHRoZSBlbmQgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgICAgdmFyIHJlUXVlcnlTdHJpbmcgPSAvXFw/LztcbiAgICAgICAgICB0aGlzLnVybCArPSAocmVRdWVyeVN0cmluZy50ZXN0KHRoaXMudXJsKSA/ICcmJyA6ICc/JykgKyAnXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICAvLyBBdm9pZGluZyBzcGxpdCB2aWEgcmVnZXggdG8gd29yayBhcm91bmQgYSBjb21tb24gSUUxMSBidWcgd2l0aCB0aGUgY29yZS1qcyAzLjYuMCByZWdleCBwb2x5ZmlsbFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzc0OFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy83NTFcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzXG4gICAgICAuc3BsaXQoJ1xccicpXG4gICAgICAubWFwKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICByZXR1cm4gaGVhZGVyLmluZGV4T2YoJ1xcbicpID09PSAwID8gaGVhZGVyLnN1YnN0cigxLCBoZWFkZXIubGVuZ3RoKSA6IGhlYWRlclxuICAgICAgfSlcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpO1xuICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0ID09PSB1bmRlZmluZWQgPyAnJyA6ICcnICsgb3B0aW9ucy5zdGF0dXNUZXh0O1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDAsIHN0YXR1c1RleHQ6ICcnfSk7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBnbG9iYWwuRE9NRXhjZXB0aW9uO1xuICB0cnkge1xuICAgIG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSk7XG4gICAgICB0aGlzLnN0YWNrID0gZXJyb3Iuc3RhY2s7XG4gICAgfTtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZXhwb3J0cy5ET01FeGNlcHRpb247XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaChpbnB1dCwgaW5pdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gbmV3IFJlcXVlc3QoaW5wdXQsIGluaXQpO1xuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwgJiYgcmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpXG4gICAgICB9XG5cbiAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgZnVuY3Rpb24gYWJvcnRYaHIoKSB7XG4gICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgfVxuXG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgIHN0YXR1czogeGhyLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnVybCA9ICdyZXNwb25zZVVSTCcgaW4geGhyID8geGhyLnJlc3BvbnNlVVJMIDogb3B0aW9ucy5oZWFkZXJzLmdldCgnWC1SZXF1ZXN0LVVSTCcpO1xuICAgICAgICB2YXIgYm9keSA9ICdyZXNwb25zZScgaW4geGhyID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZWplY3QobmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gZml4VXJsKHVybCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB1cmwgPT09ICcnICYmIGdsb2JhbC5sb2NhdGlvbi5ocmVmID8gZ2xvYmFsLmxvY2F0aW9uLmhyZWYgOiB1cmxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB1cmxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgZml4VXJsKHJlcXVlc3QudXJsKSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgc3VwcG9ydC5hcnJheUJ1ZmZlciAmJlxuICAgICAgICAgIHJlcXVlc3QuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICYmXG4gICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykuaW5kZXhPZignYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykgIT09IC0xXG4gICAgICAgICkge1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbml0ICYmIHR5cGVvZiBpbml0LmhlYWRlcnMgPT09ICdvYmplY3QnICYmICEoaW5pdC5oZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykpIHtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdC5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBub3JtYWxpemVWYWx1ZShpbml0LmhlYWRlcnNbbmFtZV0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCkge1xuICAgICAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKTtcblxuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gRE9ORSAoc3VjY2VzcyBvciBmYWlsdXJlKVxuICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgcmVxdWVzdC5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB4aHIuc2VuZCh0eXBlb2YgcmVxdWVzdC5fYm9keUluaXQgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHJlcXVlc3QuX2JvZHlJbml0KTtcbiAgICB9KVxuICB9XG5cbiAgZmV0Y2gucG9seWZpbGwgPSB0cnVlO1xuXG4gIGlmICghZ2xvYmFsLmZldGNoKSB7XG4gICAgZ2xvYmFsLmZldGNoID0gZmV0Y2g7XG4gICAgZ2xvYmFsLkhlYWRlcnMgPSBIZWFkZXJzO1xuICAgIGdsb2JhbC5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgICBnbG9iYWwuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCJ2YXIgYnM1OGNoZWNrID0gcmVxdWlyZSgnYnM1OGNoZWNrJylcblxuZnVuY3Rpb24gZGVjb2RlUmF3IChidWZmZXIsIHZlcnNpb24pIHtcbiAgLy8gY2hlY2sgdmVyc2lvbiBvbmx5IGlmIGRlZmluZWRcbiAgaWYgKHZlcnNpb24gIT09IHVuZGVmaW5lZCAmJiBidWZmZXJbMF0gIT09IHZlcnNpb24pIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBuZXR3b3JrIHZlcnNpb24nKVxuXG4gIC8vIHVuY29tcHJlc3NlZFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMzMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmVyc2lvbjogYnVmZmVyWzBdLFxuICAgICAgcHJpdmF0ZUtleTogYnVmZmVyLnNsaWNlKDEsIDMzKSxcbiAgICAgIGNvbXByZXNzZWQ6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gaW52YWxpZCBsZW5ndGhcbiAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IDM0KSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgV0lGIGxlbmd0aCcpXG5cbiAgLy8gaW52YWxpZCBjb21wcmVzc2lvbiBmbGFnXG4gIGlmIChidWZmZXJbMzNdICE9PSAweDAxKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gZmxhZycpXG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiBidWZmZXJbMF0sXG4gICAgcHJpdmF0ZUtleTogYnVmZmVyLnNsaWNlKDEsIDMzKSxcbiAgICBjb21wcmVzc2VkOiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlUmF3ICh2ZXJzaW9uLCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQnVmZmVyKGNvbXByZXNzZWQgPyAzNCA6IDMzKVxuXG4gIHJlc3VsdC53cml0ZVVJbnQ4KHZlcnNpb24sIDApXG4gIHByaXZhdGVLZXkuY29weShyZXN1bHQsIDEpXG5cbiAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICByZXN1bHRbMzNdID0gMHgwMVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkZWNvZGUgKHN0cmluZywgdmVyc2lvbikge1xuICByZXR1cm4gZGVjb2RlUmF3KGJzNThjaGVjay5kZWNvZGUoc3RyaW5nKSwgdmVyc2lvbilcbn1cblxuZnVuY3Rpb24gZW5jb2RlICh2ZXJzaW9uLCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpIHJldHVybiBiczU4Y2hlY2suZW5jb2RlKGVuY29kZVJhdyh2ZXJzaW9uLCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSlcblxuICByZXR1cm4gYnM1OGNoZWNrLmVuY29kZShcbiAgICBlbmNvZGVSYXcoXG4gICAgICB2ZXJzaW9uLnZlcnNpb24sXG4gICAgICB2ZXJzaW9uLnByaXZhdGVLZXksXG4gICAgICB2ZXJzaW9uLmNvbXByZXNzZWRcbiAgICApXG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlY29kZTogZGVjb2RlLFxuICBkZWNvZGVSYXc6IGRlY29kZVJhdyxcbiAgZW5jb2RlOiBlbmNvZGUsXG4gIGVuY29kZVJhdzogZW5jb2RlUmF3XG59XG4iLCJleHBvcnQgY29uc3QgQVVUT19MT0NLX1RJTUVPVVRfQUxBUk0gPSAnQVVUT19MT0NLX1RJTUVPVVRfQUxBUk0nO1xyXG5leHBvcnQgY29uc3QgTUVUQU1FVFJJQ1NfRklOQUxJWkVfRVZFTlRfRlJBR01FTlRfQUxBUk0gPVxyXG4gICdNRVRBTUVUUklDU19GSU5BTElaRV9FVkVOVF9GUkFHTUVOVF9BTEFSTSc7XHJcbiIsImltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4vdGltZSc7XHJcblxyXG5leHBvcnQgY29uc3QgRkFMTEJBQ0tfU01BUlRfVFJBTlNBQ1RJT05TX1JFRlJFU0hfVElNRSA9IFNFQ09ORCAqIDEwO1xyXG5leHBvcnQgY29uc3QgRkFMTEJBQ0tfU01BUlRfVFJBTlNBQ1RJT05TX0RFQURMSU5FID0gMTgwO1xyXG5leHBvcnQgY29uc3QgRkFMTEJBQ0tfU01BUlRfVFJBTlNBQ1RJT05TX01BWF9GRUVfTVVMVElQTElFUiA9IDI7XHJcbiIsImV4cG9ydCBjb25zdCBBQ1RJT05fUVVFVUVfTUVUUklDU19FMkVfVEVTVCA9ICdhY3Rpb25fcXVldWVfbWV0cmljc19lMmVfdGVzdCc7XHJcbiIsIi8qKlxyXG4gKiBAZmlsZSBUaGUgZW50cnkgcG9pbnQgZm9yIHRoZSB3ZWIgZXh0ZW5zaW9uIHNpbmdsZXRvbiBwcm9jZXNzLlxyXG4gKi9cclxuXHJcbmltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRzJztcclxuaW1wb3J0IGVuZE9mU3RyZWFtIGZyb20gJ2VuZC1vZi1zdHJlYW0nO1xyXG5pbXBvcnQgcHVtcCBmcm9tICdwdW1wJztcclxuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2RlYm91bmNlLXN0cmVhbSc7XHJcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xyXG5pbXBvcnQgYnJvd3NlciBmcm9tICd3ZWJleHRlbnNpb24tcG9seWZpbGwnO1xyXG5pbXBvcnQgeyBzdG9yZUFzU3RyZWFtIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XHJcblxuaW1wb3J0IFBvcnRTdHJlYW0gZnJvbSAnZXh0ZW5zaW9uLXBvcnQtc3RyZWFtJztcclxuXHJcbmltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcclxuaW1wb3J0IHtcclxuICBFTlZJUk9OTUVOVF9UWVBFX1BPUFVQLFxyXG4gIEVOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OLFxyXG4gIEVOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTixcclxuICBFWFRFTlNJT05fTUVTU0FHRVMsXHJcbiAgUExBVEZPUk1fRklSRUZPWCxcclxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XHJcbmltcG9ydCB7XHJcbiAgUkVKRUNUX05PVElGSUNBVElPTl9DTE9TRSxcclxuICBSRUpFQ1RfTk9USUZJQ0FUSU9OX0NMT1NFX1NJRyxcclxuICBNZXRhTWV0cmljc0V2ZW50Q2F0ZWdvcnksXHJcbiAgTWV0YU1ldHJpY3NFdmVudE5hbWUsXHJcbiAgTWV0YU1ldHJpY3NVc2VyVHJhaXQsXHJcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9tZXRhbWV0cmljcyc7XHJcbmltcG9ydCB7IGNoZWNrRm9yTGFzdEVycm9yQW5kTG9nIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZHVsZXMvYnJvd3Nlci1ydW50aW1lLnV0aWxzJztcclxuaW1wb3J0IHsgaXNNYW5pZmVzdFYzIH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZHVsZXMvbXYzLnV0aWxzJztcclxuaW1wb3J0IHsgbWFza09iamVjdCB9IGZyb20gJy4uLy4uL3NoYXJlZC9tb2R1bGVzL29iamVjdC51dGlscyc7XHJcbmltcG9ydCBtaWdyYXRpb25zIGZyb20gJy4vbWlncmF0aW9ucyc7XHJcbmltcG9ydCBNaWdyYXRvciBmcm9tICcuL2xpYi9taWdyYXRvcic7XHJcbmltcG9ydCBFeHRlbnNpb25QbGF0Zm9ybSBmcm9tICcuL3BsYXRmb3Jtcy9leHRlbnNpb24nO1xyXG5pbXBvcnQgTG9jYWxTdG9yZSBmcm9tICcuL2xpYi9sb2NhbC1zdG9yZSc7XHJcbmltcG9ydCBSZWFkT25seU5ldHdvcmtTdG9yZSBmcm9tICcuL2xpYi9uZXR3b3JrLXN0b3JlJztcclxuaW1wb3J0IHsgU0VOVFJZX1NUQVRFIH0gZnJvbSAnLi9saWIvc2V0dXBTZW50cnknO1xyXG5cclxuaW1wb3J0IGNyZWF0ZVN0cmVhbVNpbmsgZnJvbSAnLi9saWIvY3JlYXRlU3RyZWFtU2luayc7XHJcbmltcG9ydCBOb3RpZmljYXRpb25NYW5hZ2VyLCB7XHJcbiAgTk9USUZJQ0FUSU9OX01BTkFHRVJfRVZFTlRTLFxyXG59IGZyb20gJy4vbGliL25vdGlmaWNhdGlvbi1tYW5hZ2VyJztcclxuaW1wb3J0IE1ldGFtYXNrQ29udHJvbGxlciwge1xyXG4gIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLFxyXG59IGZyb20gJy4vbWV0YW1hc2stY29udHJvbGxlcic7XHJcbmltcG9ydCByYXdGaXJzdFRpbWVTdGF0ZSBmcm9tICcuL2ZpcnN0LXRpbWUtc3RhdGUnO1xyXG5pbXBvcnQgZ2V0Rmlyc3RQcmVmZXJyZWRMYW5nQ29kZSBmcm9tICcuL2xpYi9nZXQtZmlyc3QtcHJlZmVycmVkLWxhbmctY29kZSc7XHJcbmltcG9ydCBnZXRPYmpTdHJ1Y3R1cmUgZnJvbSAnLi9saWIvZ2V0T2JqU3RydWN0dXJlJztcclxuaW1wb3J0IHNldHVwRW5zSXBmc1Jlc29sdmVyIGZyb20gJy4vbGliL2Vucy1pcGZzL3NldHVwJztcclxuaW1wb3J0IHsgZGVmZXJyZWRQcm9taXNlLCBnZXRQbGF0Zm9ybSB9IGZyb20gJy4vbGliL3V0aWwnO1xyXG5cclxuLyogZXNsaW50LWVuYWJsZSBpbXBvcnQvZmlyc3QgKi9cclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9vcmRlciAqL1xyXG5cbi8qIGVzbGludC1lbmFibGUgaW1wb3J0L29yZGVyICovXHJcblxyXG5jb25zdCB7IHNlbnRyeSB9ID0gZ2xvYmFsO1xyXG5jb25zdCBmaXJzdFRpbWVTdGF0ZSA9IHsgLi4ucmF3Rmlyc3RUaW1lU3RhdGUgfTtcclxuXHJcbmNvbnN0IG1ldGFtYXNrSW50ZXJuYWxQcm9jZXNzSGFzaCA9IHtcclxuICBbRU5WSVJPTk1FTlRfVFlQRV9QT1BVUF06IHRydWUsXHJcbiAgW0VOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OXTogdHJ1ZSxcclxuICBbRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOXTogdHJ1ZSxcclxufTtcclxuXHJcbmNvbnN0IG1ldGFtYXNrQmxvY2tlZFBvcnRzID0gWyd0cmV6b3ItY29ubmVjdCddO1xyXG5cclxubG9nLnNldERlZmF1bHRMZXZlbChwcm9jZXNzLmVudi5NRVRBTUFTS19ERUJVRyA/ICdkZWJ1ZycgOiAnaW5mbycpO1xyXG5cclxuY29uc3QgcGxhdGZvcm0gPSBuZXcgRXh0ZW5zaW9uUGxhdGZvcm0oKTtcclxuY29uc3Qgbm90aWZpY2F0aW9uTWFuYWdlciA9IG5ldyBOb3RpZmljYXRpb25NYW5hZ2VyKCk7XHJcblxyXG5sZXQgcG9wdXBJc09wZW4gPSBmYWxzZTtcclxubGV0IG5vdGlmaWNhdGlvbklzT3BlbiA9IGZhbHNlO1xyXG5sZXQgdWlJc1RyaWdnZXJpbmcgPSBmYWxzZTtcclxuY29uc3Qgb3Blbk1ldGFtYXNrVGFic0lEcyA9IHt9O1xyXG5jb25zdCByZXF1ZXN0QWNjb3VudFRhYklkcyA9IHt9O1xyXG5sZXQgY29udHJvbGxlcjtcclxuXHJcbi8vIHN0YXRlIHBlcnNpc3RlbmNlXHJcbmNvbnN0IGluVGVzdCA9IHByb2Nlc3MuZW52LklOX1RFU1Q7XHJcbmNvbnN0IGxvY2FsU3RvcmUgPSBpblRlc3QgPyBuZXcgUmVhZE9ubHlOZXR3b3JrU3RvcmUoKSA6IG5ldyBMb2NhbFN0b3JlKCk7XHJcbmxldCB2ZXJzaW9uZWREYXRhO1xyXG5cclxuaWYgKGluVGVzdCB8fCBwcm9jZXNzLmVudi5NRVRBTUFTS19ERUJVRykge1xyXG4gIGdsb2JhbC5zdGF0ZUhvb2tzLm1ldGFtYXNrR2V0U3RhdGUgPSBsb2NhbFN0b3JlLmdldC5iaW5kKGxvY2FsU3RvcmUpO1xyXG59XHJcblxyXG5jb25zdCBwaGlzaGluZ1BhZ2VVcmwgPSBuZXcgVVJMKHByb2Nlc3MuZW52LlBISVNISU5HX1dBUk5JTkdfUEFHRV9VUkwpO1xyXG5cclxuY29uc3QgT05FX1NFQ09ORF9JTl9NSUxMSVNFQ09ORFMgPSAxXzAwMDtcclxuLy8gVGltZW91dCBmb3IgaW5pdGlhbGl6aW5nIHBoaXNoaW5nIHdhcm5pbmcgcGFnZS5cclxuY29uc3QgUEhJU0hJTkdfV0FSTklOR19QQUdFX1RJTUVPVVQgPSBPTkVfU0VDT05EX0lOX01JTExJU0VDT05EUztcclxuXHJcbmNvbnN0IEFDS19LRUVQX0FMSVZFX01FU1NBR0UgPSAnQUNLX0tFRVBfQUxJVkVfTUVTU0FHRSc7XHJcbmNvbnN0IFdPUktFUl9LRUVQX0FMSVZFX01FU1NBR0UgPSAnV09SS0VSX0tFRVBfQUxJVkVfTUVTU0FHRSc7XHJcblxyXG5cblxyXG4vLyBFdmVudCBlbWl0dGVyIGZvciBzdGF0ZSBwZXJzaXN0ZW5jZVxyXG5leHBvcnQgY29uc3Qgc3RhdGVQZXJzaXN0ZW5jZUV2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGRlZmVycmVkIFByb21pc2UgaXMgdXNlZCB0byB0cmFjayB3aGV0aGVyIGluaXRpYWxpemF0aW9uIGhhcyBmaW5pc2hlZC5cclxuICpcclxuICogSXQgaXMgdmVyeSBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgYHJlc29sdmVJbml0aWFsaXphdGlvbmAgaXMgKmFsd2F5cypcclxuICogY2FsbGVkIG9uY2UgaW5pdGlhbGl6YXRpb24gaGFzIGNvbXBsZXRlZCwgYW5kIHRoYXQgYHJlamVjdEluaXRpYWxpemF0aW9uYCBpc1xyXG4gKiBjYWxsZWQgaWYgaW5pdGlhbGl6YXRpb24gZmFpbHMgaW4gYW4gdW5yZWNvdmVyYWJsZSB3YXkuXHJcbiAqL1xyXG5jb25zdCB7XHJcbiAgcHJvbWlzZTogaXNJbml0aWFsaXplZCxcclxuICByZXNvbHZlOiByZXNvbHZlSW5pdGlhbGl6YXRpb24sXHJcbiAgcmVqZWN0OiByZWplY3RJbml0aWFsaXphdGlvbixcclxufSA9IGRlZmVycmVkUHJvbWlzZSgpO1xyXG5cclxuLyoqXHJcbiAqIFNlbmRzIGEgbWVzc2FnZSB0byB0aGUgZGFwcChzKSBjb250ZW50IHNjcmlwdCB0byBzaWduYWwgaXQgY2FuIGNvbm5lY3QgdG8gTWV0YU1hc2sgYmFja2dyb3VuZCBhc1xyXG4gKiB0aGUgYmFja2VuZCBpcyBub3QgYWN0aXZlLiBJdCBpcyByZXF1aXJlZCB0byByZS1jb25uZWN0IGRhcHBzIGFmdGVyIHNlcnZpY2Ugd29ya2VyIHJlLWFjdGl2YXRlcy5cclxuICogRm9yIG5vbi1kYXBwIHBhZ2VzLCB0aGUgbWVzc2FnZSB3aWxsIGJlIHNlbnQgYW5kIGlnbm9yZWQuXHJcbiAqL1xyXG5jb25zdCBzZW5kUmVhZHlNZXNzYWdlVG9UYWJzID0gYXN5bmMgKCkgPT4ge1xyXG4gIGNvbnN0IHRhYnMgPSBhd2FpdCBicm93c2VyLnRhYnNcclxuICAgIC5xdWVyeSh7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBPbmx5IHF1ZXJ5IHRhYnMgdGhhdCBvdXIgZXh0ZW5zaW9uIGNhbiBydW4gaW4uIFRvIGRvIHRoaXMsIHdlIHF1ZXJ5IGZvciBhbGwgVVJMcyB0aGF0IG91clxyXG4gICAgICAgKiBleHRlbnNpb24gY2FuIGluamVjdCBzY3JpcHRzIGluLCB3aGljaCBpcyBieSB1c2luZyB0aGUgXCI8YWxsX3VybHM+XCIgdmFsdWUgYW5kIF9fd2l0aG91dF9fXHJcbiAgICAgICAqIHRoZSBcInRhYnNcIiBtYW5pZmVzdCBwZXJtaXNzaW9uLiBJZiB3ZSBpbmNsdWRlZCB0aGUgXCJ0YWJzXCIgcGVybWlzc2lvbiwgdGhpcyB3b3VsZCBhbHNvIGZldGNoXHJcbiAgICAgICAqIFVSTHMgdGhhdCB3ZSdkIG5vdCBiZSBhYmxlIHRvIGluamVjdCBpbiwgZS5nLiBjaHJvbWU6Ly9wYWdlcywgY2hyb21lOi8vZXh0ZW5zaW9uLCB3aGljaFxyXG4gICAgICAgKiBpcyBub3Qgd2hhdCB3ZSdkIHdhbnQuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIFlvdSBtaWdodCBiZSB3b25kZXJpbmcsIGhvdyBkb2VzIHRoZSBcInVybFwiIHBhcmFtIHdvcmsgd2l0aG91dCB0aGUgXCJ0YWJzXCIgcGVybWlzc2lvbj9cclxuICAgICAgICpcclxuICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjYxMzExI2MxfVxyXG4gICAgICAgKiAgXCJJZiB0aGUgZXh0ZW5zaW9uIGhhcyBhY2Nlc3MgdG8gaW5qZWN0IHNjcmlwdHMgaW50byBUYWIsIHRoZW4gd2UgY2FuIHJldHVybiB0aGUgdXJsXHJcbiAgICAgICAqICAgb2YgVGFiIChiZWNhdXNlIHRoZSBleHRlbnNpb24gY291bGQganVzdCBpbmplY3QgYSBzY3JpcHQgdG8gbWVzc2FnZSB0aGUgbG9jYXRpb24uaHJlZikuXCJcclxuICAgICAgICovXHJcbiAgICAgIHVybDogJzxhbGxfdXJscz4nLFxyXG4gICAgICB3aW5kb3dUeXBlOiAnbm9ybWFsJyxcclxuICAgIH0pXHJcbiAgICAudGhlbigocmVzdWx0KSA9PiB7XHJcbiAgICAgIGNoZWNrRm9yTGFzdEVycm9yQW5kTG9nKCk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9KVxyXG4gICAgLmNhdGNoKCgpID0+IHtcclxuICAgICAgY2hlY2tGb3JMYXN0RXJyb3JBbmRMb2coKTtcclxuICAgIH0pO1xyXG5cclxuICAvKiogQHRvZG8gd2Ugc2hvdWxkIG9ubHkgc2VuZE1lc3NhZ2UgdG8gZGFwcCB0YWJzLCBub3QgYWxsIHRhYnMuICovXHJcbiAgZm9yIChjb25zdCB0YWIgb2YgdGFicykge1xyXG4gICAgYnJvd3Nlci50YWJzXHJcbiAgICAgIC5zZW5kTWVzc2FnZSh0YWIuaWQsIHtcclxuICAgICAgICBuYW1lOiBFWFRFTlNJT05fTUVTU0FHRVMuUkVBRFksXHJcbiAgICAgIH0pXHJcbiAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICBjaGVja0Zvckxhc3RFcnJvckFuZExvZygpO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgIC8vIEFuIGVycm9yIG1heSBoYXBwZW4gaWYgdGhlIGNvbnRlbnRzY3JpcHQgaXMgYmxvY2tlZCBmcm9tIGxvYWRpbmcsXHJcbiAgICAgICAgLy8gYW5kIHRodXMgdGhlcmUgaXMgbm8gcnVudGltZS5vbk1lc3NhZ2UgaGFuZGxlciB0byBsaXN0ZW4gdG8gdGhlIG1lc3NhZ2UuXHJcbiAgICAgICAgY2hlY2tGb3JMYXN0RXJyb3JBbmRMb2coKTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLy8gVGhlc2UgYXJlIHNldCBhZnRlciBpbml0aWFsaXphdGlvblxyXG5sZXQgY29ubmVjdFJlbW90ZTtcclxubGV0IGNvbm5lY3RFeHRlcm5hbDtcclxuXHJcbmJyb3dzZXIucnVudGltZS5vbkNvbm5lY3QuYWRkTGlzdGVuZXIoYXN5bmMgKC4uLmFyZ3MpID0+IHtcclxuICAvLyBRdWV1ZSB1cCBjb25uZWN0aW9uIGF0dGVtcHRzIGhlcmUsIHdhaXRpbmcgdW50aWwgYWZ0ZXIgaW5pdGlhbGl6YXRpb25cclxuICBhd2FpdCBpc0luaXRpYWxpemVkO1xyXG5cclxuICAvLyBUaGlzIGlzIHNldCBpbiBgc2V0dXBDb250cm9sbGVyYCwgd2hpY2ggaXMgY2FsbGVkIGFzIHBhcnQgb2YgaW5pdGlhbGl6YXRpb25cclxuICBjb25uZWN0UmVtb3RlKC4uLmFyZ3MpO1xyXG59KTtcclxuYnJvd3Nlci5ydW50aW1lLm9uQ29ubmVjdEV4dGVybmFsLmFkZExpc3RlbmVyKGFzeW5jICguLi5hcmdzKSA9PiB7XHJcbiAgLy8gUXVldWUgdXAgY29ubmVjdGlvbiBhdHRlbXB0cyBoZXJlLCB3YWl0aW5nIHVudGlsIGFmdGVyIGluaXRpYWxpemF0aW9uXHJcbiAgYXdhaXQgaXNJbml0aWFsaXplZDtcclxuXHJcbiAgLy8gVGhpcyBpcyBzZXQgaW4gYHNldHVwQ29udHJvbGxlcmAsIHdoaWNoIGlzIGNhbGxlZCBhcyBwYXJ0IG9mIGluaXRpYWxpemF0aW9uXHJcbiAgY29ubmVjdEV4dGVybmFsKC4uLmFyZ3MpO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJykuVHJhbnNhY3Rpb25NZXRhfSBUcmFuc2FjdGlvbk1ldGFcclxuICovXHJcblxyXG4vKipcclxuICogVGhlIGRhdGEgZW1pdHRlZCBmcm9tIHRoZSBNZXRhTWFza0NvbnRyb2xsZXIuc3RvcmUgRXZlbnRFbWl0dGVyLCBhbHNvIHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGUgTWV0YU1hc2tDb250cm9sbGVyLiBBdmFpbGFibGUgaW4gVUkgb24gUmVhY3Qgc3RhdGUgYXMgc3RhdGUubWV0YW1hc2suXHJcbiAqXHJcbiAqIEB0eXBlZGVmIE1ldGFNYXNrU3RhdGVcclxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0luaXRpYWxpemVkIC0gV2hldGhlciB0aGUgZmlyc3QgdmF1bHQgaGFzIGJlZW4gY3JlYXRlZC5cclxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1VubG9ja2VkIC0gV2hldGhlciB0aGUgdmF1bHQgaXMgY3VycmVudGx5IGRlY3J5cHRlZCBhbmQgYWNjb3VudHMgYXJlIGF2YWlsYWJsZSBmb3Igc2VsZWN0aW9uLlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzQWNjb3VudE1lbnVPcGVuIC0gUmVwcmVzZW50cyB3aGV0aGVyIHRoZSBtYWluIGFjY291bnQgc2VsZWN0aW9uIFVJIGlzIGN1cnJlbnRseSBkaXNwbGF5ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNOZXR3b3JrTWVudU9wZW4gLSBSZXByZXNlbnRzIHdoZXRoZXIgdGhlIG1haW4gbmV0d29yayBzZWxlY3Rpb24gVUkgaXMgY3VycmVudGx5IGRpc3BsYXllZC5cclxuICogQHByb3BlcnR5IHtvYmplY3R9IGlkZW50aXRpZXMgLSBBbiBvYmplY3QgbWF0Y2hpbmcgbG93ZXItY2FzZSBoZXggYWRkcmVzc2VzIHRvIElkZW50aXR5IG9iamVjdHMgd2l0aCBcImFkZHJlc3NcIiBhbmQgXCJuYW1lXCIgKG5pY2tuYW1lKSBrZXlzLlxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gdW5hcHByb3ZlZFR4cyAtIEFuIG9iamVjdCBtYXBwaW5nIHRyYW5zYWN0aW9uIGhhc2hlcyB0byB1bmFwcHJvdmVkIHRyYW5zYWN0aW9ucy5cclxuICogQHByb3BlcnR5IHtvYmplY3R9IG5ldHdvcmtDb25maWd1cmF0aW9ucyAtIEEgbGlzdCBvZiBuZXR3b3JrIGNvbmZpZ3VyYXRpb25zLCBjb250YWluaW5nIFJQQyBwcm92aWRlciBkZXRhaWxzIChlZyBjaGFpbklkLCBycGNVcmwsIHJwY1ByZWZlcmVuY2VzKS5cclxuICogQHByb3BlcnR5IHtBcnJheX0gYWRkcmVzc0Jvb2sgLSBBIGxpc3Qgb2YgcHJldmlvdXNseSBzZW50IHRvIGFkZHJlc3Nlcy5cclxuICogQHByb3BlcnR5IHtvYmplY3R9IGNvbnRyYWN0RXhjaGFuZ2VSYXRlcyAtIEluZm8gYWJvdXQgY3VycmVudCB0b2tlbiBwcmljZXMuXHJcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IHRva2VucyAtIFRva2VucyBoZWxkIGJ5IHRoZSBjdXJyZW50IHVzZXIsIGluY2x1ZGluZyB0aGVpciBiYWxhbmNlcy5cclxuICogQHByb3BlcnR5IHtvYmplY3R9IHNlbmQgLSBUT0RPOiBEb2N1bWVudFxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHVzZUJsb2NraWUgLSBJbmRpY2F0ZXMgcHJlZmVycmVkIHVzZXIgaWRlbnRpY29uIGZvcm1hdC4gVHJ1ZSBmb3IgYmxvY2tpZSwgZmFsc2UgZm9yIEphenppY29uLlxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gZmVhdHVyZUZsYWdzIC0gQW4gb2JqZWN0IGZvciBvcHRpb25hbCBmZWF0dXJlIGZsYWdzLlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlbGNvbWVTY3JlZW4gLSBUcnVlIGlmIHdlbGNvbWUgc2NyZWVuIHNob3VsZCBiZSBzaG93bi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGN1cnJlbnRMb2NhbGUgLSBBIGxvY2FsZSBzdHJpbmcgbWF0Y2hpbmcgdGhlIHVzZXIncyBwcmVmZXJyZWQgZGlzcGxheSBsYW5ndWFnZS5cclxuICogQHByb3BlcnR5IHtvYmplY3R9IHByb3ZpZGVyQ29uZmlnIC0gVGhlIGN1cnJlbnQgc2VsZWN0ZWQgbmV0d29yayBwcm92aWRlci5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3ZpZGVyQ29uZmlnLnJwY1VybCAtIFRoZSBhZGRyZXNzIGZvciB0aGUgUlBDIEFQSSwgaWYgdXNpbmcgYW4gUlBDIEFQSS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3ZpZGVyQ29uZmlnLnR5cGUgLSBBbiBpZGVudGlmaWVyIGZvciB0aGUgdHlwZSBvZiBuZXR3b3JrIHNlbGVjdGVkLCBhbGxvd3MgTWV0YU1hc2sgdG8gdXNlIGN1c3RvbSBwcm92aWRlciBzdHJhdGVnaWVzIGZvciBrbm93biBuZXR3b3Jrcy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5ldHdvcmtJZCAtIFRoZSBzdHJpbmdpZmllZCBudW1iZXIgb2YgdGhlIGN1cnJlbnQgbmV0d29yayBJRC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5ldHdvcmtTdGF0dXMgLSBFaXRoZXIgXCJ1bmtub3duXCIsIFwiYXZhaWxhYmxlXCIsIFwidW5hdmFpbGFibGVcIiwgb3IgXCJibG9ja2VkXCIsIGRlcGVuZGluZyBvbiB0aGUgc3RhdHVzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbmV0d29yay5cclxuICogQHByb3BlcnR5IHtvYmplY3R9IGFjY291bnRzIC0gQW4gb2JqZWN0IG1hcHBpbmcgbG93ZXItY2FzZSBoZXggYWRkcmVzc2VzIHRvIG9iamVjdHMgd2l0aCBcImJhbGFuY2VcIiBhbmQgXCJhZGRyZXNzXCIga2V5cywgYm90aCBzdG9yaW5nIGhleCBzdHJpbmcgdmFsdWVzLlxyXG4gKiBAcHJvcGVydHkge2hleH0gY3VycmVudEJsb2NrR2FzTGltaXQgLSBUaGUgbW9zdCByZWNlbnRseSBzZWVuIGJsb2NrIGdhcyBsaW1pdCwgaW4gYSBsb3dlciBjYXNlIGhleCBwcmVmaXhlZCBzdHJpbmcuXHJcbiAqIEBwcm9wZXJ0eSB7VHJhbnNhY3Rpb25NZXRhW119IGN1cnJlbnROZXR3b3JrVHhMaXN0IC0gQW4gYXJyYXkgb2YgdHJhbnNhY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5ldHdvcmsuXHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB1bmFwcHJvdmVkTXNncyAtIEFuIG9iamVjdCBvZiBtZXNzYWdlcyBwZW5kaW5nIGFwcHJvdmFsLCBtYXBwaW5nIGEgdW5pcXVlIElEIHRvIHRoZSBvcHRpb25zLlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZE1zZ0NvdW50IC0gVGhlIG51bWJlciBvZiBtZXNzYWdlcyBpbiB1bmFwcHJvdmVkTXNncy5cclxuICogQHByb3BlcnR5IHtvYmplY3R9IHVuYXBwcm92ZWRQZXJzb25hbE1zZ3MgLSBBbiBvYmplY3Qgb2YgbWVzc2FnZXMgcGVuZGluZyBhcHByb3ZhbCwgbWFwcGluZyBhIHVuaXF1ZSBJRCB0byB0aGUgb3B0aW9ucy5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVuYXBwcm92ZWRQZXJzb25hbE1zZ0NvdW50IC0gVGhlIG51bWJlciBvZiBtZXNzYWdlcyBpbiB1bmFwcHJvdmVkUGVyc29uYWxNc2dzLlxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gdW5hcHByb3ZlZEVuY3J5cHRpb25QdWJsaWNLZXlNc2dzIC0gQW4gb2JqZWN0IG9mIG1lc3NhZ2VzIHBlbmRpbmcgYXBwcm92YWwsIG1hcHBpbmcgYSB1bmlxdWUgSUQgdG8gdGhlIG9wdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1bmFwcHJvdmVkRW5jcnlwdGlvblB1YmxpY0tleU1zZ0NvdW50IC0gVGhlIG51bWJlciBvZiBtZXNzYWdlcyBpbiBFbmNyeXB0aW9uUHVibGljS2V5TXNncy5cclxuICogQHByb3BlcnR5IHtvYmplY3R9IHVuYXBwcm92ZWREZWNyeXB0TXNncyAtIEFuIG9iamVjdCBvZiBtZXNzYWdlcyBwZW5kaW5nIGFwcHJvdmFsLCBtYXBwaW5nIGEgdW5pcXVlIElEIHRvIHRoZSBvcHRpb25zLlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZERlY3J5cHRNc2dDb3VudCAtIFRoZSBudW1iZXIgb2YgbWVzc2FnZXMgaW4gdW5hcHByb3ZlZERlY3J5cHRNc2dzLlxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gdW5hcHByb3ZlZFR5cGVkTXNncyAtIEFuIG9iamVjdCBvZiBtZXNzYWdlcyBwZW5kaW5nIGFwcHJvdmFsLCBtYXBwaW5nIGEgdW5pcXVlIElEIHRvIHRoZSBvcHRpb25zLlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZFR5cGVkTXNnQ291bnQgLSBUaGUgbnVtYmVyIG9mIG1lc3NhZ2VzIGluIHVuYXBwcm92ZWRUeXBlZE1zZ3MuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwZW5kaW5nQXBwcm92YWxDb3VudCAtIFRoZSBudW1iZXIgb2YgcGVuZGluZyByZXF1ZXN0IGluIHRoZSBhcHByb3ZhbCBjb250cm9sbGVyLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBrZXlyaW5nVHlwZXMgLSBBbiBhcnJheSBvZiB1bmlxdWUga2V5cmluZyBpZGVudGlmeWluZyBzdHJpbmdzLCByZXByZXNlbnRpbmcgYXZhaWxhYmxlIHN0cmF0ZWdpZXMgZm9yIGNyZWF0aW5nIGFjY291bnRzLlxyXG4gKiBAcHJvcGVydHkge0tleXJpbmdbXX0ga2V5cmluZ3MgLSBBbiBhcnJheSBvZiBrZXlyaW5nIGRlc2NyaXB0aW9ucywgc3VtbWFyaXppbmcgdGhlIGFjY291bnRzIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdXNlLCBhbmQgd2hhdCBrZXlyaW5ncyB0aGV5IGJlbG9uZyB0by5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdGVkQWRkcmVzcyAtIEEgbG93ZXIgY2FzZSBoZXggc3RyaW5nIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgYWRkcmVzcy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGN1cnJlbnRDdXJyZW5jeSAtIEEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSB1c2VyJ3MgcHJlZmVycmVkIGRpc3BsYXkgY3VycmVuY3ksIGZvciB1c2UgaW4gc2hvd2luZyBjb252ZXJzaW9uIHJhdGVzLlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29udmVyc2lvblJhdGUgLSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgZXhjaGFuZ2UgcmF0ZSBmcm9tIHRoZSB1c2VyJ3MgcHJlZmVycmVkIGN1cnJlbmN5IHRvIEV0aGVyLlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29udmVyc2lvbkRhdGUgLSBBIHVuaXggZXBvY2ggZGF0ZSAobXMpIGZvciB0aGUgdGltZSB0aGUgY3VycmVudCBjb252ZXJzaW9uIHJhdGUgd2FzIGxhc3QgcmV0cmlldmVkLlxyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZvcmdvdHRlblBhc3N3b3JkIC0gUmV0dXJucyB0cnVlIGlmIHRoZSB1c2VyIGhhcyBpbml0aWF0ZWQgdGhlIHBhc3N3b3JkIHJlY292ZXJ5IHNjcmVlbiwgaXMgcmVjb3ZlcmluZyBmcm9tIHNlZWQgcGhyYXNlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiBWZXJzaW9uZWREYXRhXHJcbiAqIEBwcm9wZXJ0eSB7TWV0YU1hc2tTdGF0ZX0gZGF0YSAtIFRoZSBkYXRhIGVtaXR0ZWQgZnJvbSBNZXRhTWFzayBjb250cm9sbGVyLCBvciB1c2VkIHRvIGluaXRpYWxpemUgaXQuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB2ZXJzaW9uIC0gVGhlIGxhdGVzdCBtaWdyYXRpb24gdmVyc2lvbiB0aGF0IGhhcyBiZWVuIHJ1bi5cclxuICovXHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZXMgdGhlIE1ldGFNYXNrIGNvbnRyb2xsZXIsIGFuZCBzZXRzIHVwIGFsbCBwbGF0Zm9ybSBjb25maWd1cmF0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gU2V0dXAgY29tcGxldGUuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBpbml0U3RhdGUgPSBhd2FpdCBsb2FkU3RhdGVGcm9tUGVyc2lzdGVuY2UoKTtcclxuICAgIGNvbnN0IGluaXRMYW5nQ29kZSA9IGF3YWl0IGdldEZpcnN0UHJlZmVycmVkTGFuZ0NvZGUoKTtcclxuXHJcblxuXHJcbiAgICBsZXQgaXNGaXJzdE1ldGFNYXNrQ29udHJvbGxlclNldHVwO1xyXG4gICAgaWYgKGlzTWFuaWZlc3RWMykge1xyXG4gICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IGF3YWl0IGJyb3dzZXIuc3RvcmFnZS5zZXNzaW9uLmdldChbXHJcbiAgICAgICAgJ2lzRmlyc3RNZXRhTWFza0NvbnRyb2xsZXJTZXR1cCcsXHJcbiAgICAgIF0pO1xyXG5cclxuICAgICAgaXNGaXJzdE1ldGFNYXNrQ29udHJvbGxlclNldHVwID1cclxuICAgICAgICBzZXNzaW9uRGF0YT8uaXNGaXJzdE1ldGFNYXNrQ29udHJvbGxlclNldHVwID09PSB1bmRlZmluZWQ7XHJcbiAgICAgIGF3YWl0IGJyb3dzZXIuc3RvcmFnZS5zZXNzaW9uLnNldCh7IGlzRmlyc3RNZXRhTWFza0NvbnRyb2xsZXJTZXR1cCB9KTtcclxuICAgIH1cclxuXHJcbiAgICBzZXR1cENvbnRyb2xsZXIoXHJcbiAgICAgIGluaXRTdGF0ZSxcclxuICAgICAgaW5pdExhbmdDb2RlLFxyXG4gICAgICB7fSxcclxuICAgICAgaXNGaXJzdE1ldGFNYXNrQ29udHJvbGxlclNldHVwLFxyXG4gICAgKTtcclxuICAgIGlmICghaXNNYW5pZmVzdFYzKSB7XHJcbiAgICAgIGF3YWl0IGxvYWRQaGlzaGluZ1dhcm5pbmdQYWdlKCk7XHJcbiAgICB9XHJcbiAgICBhd2FpdCBzZW5kUmVhZHlNZXNzYWdlVG9UYWJzKCk7XHJcbiAgICBsb2cuaW5mbygnTWV0YU1hc2sgaW5pdGlhbGl6YXRpb24gY29tcGxldGUuJyk7XHJcbiAgICByZXNvbHZlSW5pdGlhbGl6YXRpb24oKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgcmVqZWN0SW5pdGlhbGl6YXRpb24oZXJyb3IpO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGVycm9yIHRocm93biBpZiB0aGUgcGhpc2hpbmcgd2FybmluZyBwYWdlIHRha2VzIHRvbyBsb25nIHRvIGxvYWQuXHJcbiAqL1xyXG5jbGFzcyBQaGlzaGluZ1dhcm5pbmdQYWdlVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoJ1RpbWVvdXQgZmFpbGVkJyk7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogTG9hZCB0aGUgcGhpc2hpbmcgd2FybmluZyBwYWdlIHRlbXBvcmFyaWx5IHRvIGVuc3VyZSB0aGUgc2VydmljZVxyXG4gKiB3b3JrZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZCwgc28gdGhhdCB0aGUgd2FybmluZyBwYWdlIHdvcmtzIG9mZmxpbmUuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBsb2FkUGhpc2hpbmdXYXJuaW5nUGFnZSgpIHtcclxuICBsZXQgaWZyYW1lO1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBleHRlbnNpb25TdGFydHVwUGhpc2hpbmdQYWdlVXJsID0gbmV3IFVSTChcclxuICAgICAgcHJvY2Vzcy5lbnYuUEhJU0hJTkdfV0FSTklOR19QQUdFX1VSTCxcclxuICAgICk7XHJcbiAgICAvLyBUaGUgYGV4dGVuc2lvblN0YXJ0dXBgIGhhc2ggc2lnbmFscyB0byB0aGUgcGhpc2hpbmcgd2FybmluZyBwYWdlIHRoYXQgaXQgc2hvdWxkIG5vdCBib3RoZXJcclxuICAgIC8vIHNldHRpbmcgdXAgc3RyZWFtcyBmb3IgdXNlciBpbnRlcmFjdGlvbi4gT3RoZXJ3aXNlIHRoaXMgcGFnZSBsb2FkIHdvdWxkIGNhdXNlIGEgY29uc29sZVxyXG4gICAgLy8gZXJyb3IuXHJcbiAgICBleHRlbnNpb25TdGFydHVwUGhpc2hpbmdQYWdlVXJsLmhhc2ggPSAnI2V4dGVuc2lvblN0YXJ0dXAnO1xyXG5cclxuICAgIGlmcmFtZSA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIGV4dGVuc2lvblN0YXJ0dXBQaGlzaGluZ1BhZ2VVcmwuaHJlZik7XHJcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzYW5kYm94JywgJ2FsbG93LXNjcmlwdHMgYWxsb3ctc2FtZS1vcmlnaW4nKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgXCJkZWZlcnJlZCBQcm9taXNlXCIgdG8gYWxsb3cgcGFzc2luZyByZXNvbHZlL3JlamVjdCB0byBldmVudCBoYW5kbGVyc1xyXG4gICAgbGV0IGRlZmVycmVkUmVzb2x2ZTtcclxuICAgIGxldCBkZWZlcnJlZFJlamVjdDtcclxuICAgIGNvbnN0IGxvYWRDb21wbGV0ZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZGVmZXJyZWRSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgZGVmZXJyZWRSZWplY3QgPSByZWplY3Q7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBUaGUgbG9hZCBldmVudCBpcyBlbWl0dGVkIG9uY2UgbG9hZGluZyBoYXMgY29tcGxldGVkLCBldmVuIGlmIHRoZSBsb2FkaW5nIGZhaWxlZC5cclxuICAgIC8vIElmIGxvYWRpbmcgZmFpbGVkIHdlIGNhbid0IGRvIGFueXRoaW5nIGFib3V0IGl0LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGNoZWNrLlxyXG4gICAgaWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBkZWZlcnJlZFJlc29sdmUpO1xyXG5cclxuICAgIC8vIFRoaXMgc3RlcCBpbml0aWF0ZXMgdGhlIHBhZ2UgbG9hZGluZy5cclxuICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XHJcblxyXG4gICAgLy8gVGhpcyB0aW1lb3V0IGVuc3VyZXMgdGhhdCB0aGlzIGlmcmFtZSBnZXRzIGNsZWFuZWQgdXAgaW4gYSByZWFzb25hYmxlXHJcbiAgICAvLyB0aW1lZnJhbWUsIGFuZCBlbnN1cmVzIHRoYXQgdGhlIFwiaW5pdGlhbGl6YXRpb24gY29tcGxldGVcIiBtZXNzYWdlXHJcbiAgICAvLyBkb2Vzbid0IGdldCBkZWxheWVkIHRvbyBsb25nLlxyXG4gICAgc2V0VGltZW91dChcclxuICAgICAgKCkgPT4gZGVmZXJyZWRSZWplY3QobmV3IFBoaXNoaW5nV2FybmluZ1BhZ2VUaW1lb3V0RXJyb3IoKSksXHJcbiAgICAgIFBISVNISU5HX1dBUk5JTkdfUEFHRV9USU1FT1VULFxyXG4gICAgKTtcclxuICAgIGF3YWl0IGxvYWRDb21wbGV0ZTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgUGhpc2hpbmdXYXJuaW5nUGFnZVRpbWVvdXRFcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgJ1BoaXNoaW5nIHdhcm5pbmcgcGFnZSB0aW1lb3V0OyBwYWdlIG5vdCBndWFyYW5ldGVlZCB0byB3b3JrIG9mZmxpbmUuJyxcclxuICAgICAgKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIHBoaXNoaW5nIHdhcm5pbmcgcGFnZScsIGVycm9yKTtcclxuICAgIH1cclxuICB9IGZpbmFsbHkge1xyXG4gICAgaWYgKGlmcmFtZSkge1xyXG4gICAgICBpZnJhbWUucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vL1xyXG4vLyBTdGF0ZSBhbmQgUGVyc2lzdGVuY2VcclxuLy9cclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBhbnkgc3RvcmVkIGRhdGEsIHByaW9yaXRpemluZyB0aGUgbGF0ZXN0IHN0b3JhZ2Ugc3RyYXRlZ3kuXHJcbiAqIE1pZ3JhdGVzIHRoYXQgZGF0YSBzY2hlbWEgaW4gY2FzZSBpdCB3YXMgbGFzdCBsb2FkZWQgb24gYW4gb2xkZXIgdmVyc2lvbi5cclxuICpcclxuICogQHJldHVybnMge1Byb21pc2U8TWV0YU1hc2tTdGF0ZT59IExhc3QgZGF0YSBlbWl0dGVkIGZyb20gcHJldmlvdXMgaW5zdGFuY2Ugb2YgTWV0YU1hc2suXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFN0YXRlRnJvbVBlcnNpc3RlbmNlKCkge1xyXG4gIC8vIG1pZ3JhdGlvbnNcclxuICBjb25zdCBtaWdyYXRvciA9IG5ldyBNaWdyYXRvcih7IG1pZ3JhdGlvbnMgfSk7XHJcbiAgbWlncmF0b3Iub24oJ2Vycm9yJywgY29uc29sZS53YXJuKTtcclxuXHJcbiAgLy8gcmVhZCBmcm9tIGRpc2tcclxuICAvLyBmaXJzdCBmcm9tIHByZWZlcnJlZCwgYXN5bmMgQVBJOlxyXG4gIHZlcnNpb25lZERhdGEgPVxyXG4gICAgKGF3YWl0IGxvY2FsU3RvcmUuZ2V0KCkpIHx8IG1pZ3JhdG9yLmdlbmVyYXRlSW5pdGlhbFN0YXRlKGZpcnN0VGltZVN0YXRlKTtcclxuXHJcbiAgLy8gY2hlY2sgaWYgc29tZWhvdyBzdGF0ZSBpcyBlbXB0eVxyXG4gIC8vIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBidXQgbmV3IGVycm9yIHJlcG9ydGluZyBzdWdnZXN0cyB0aGF0IGl0IGhhc1xyXG4gIC8vIGZvciBhIHNtYWxsIG51bWJlciBvZiB1c2Vyc1xyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tZXRhbWFzay9tZXRhbWFzay1leHRlbnNpb24vaXNzdWVzLzM5MTlcclxuICBpZiAodmVyc2lvbmVkRGF0YSAmJiAhdmVyc2lvbmVkRGF0YS5kYXRhKSB7XHJcbiAgICAvLyB1bmFibGUgdG8gcmVjb3ZlciwgY2xlYXIgc3RhdGVcclxuICAgIHZlcnNpb25lZERhdGEgPSBtaWdyYXRvci5nZW5lcmF0ZUluaXRpYWxTdGF0ZShmaXJzdFRpbWVTdGF0ZSk7XHJcbiAgICBzZW50cnkuY2FwdHVyZU1lc3NhZ2UoJ01ldGFNYXNrIC0gRW1wdHkgdmF1bHQgZm91bmQgLSB1bmFibGUgdG8gcmVjb3ZlcicpO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVwb3J0IG1pZ3JhdGlvbiBlcnJvcnMgdG8gc2VudHJ5XHJcbiAgbWlncmF0b3Iub24oJ2Vycm9yJywgKGVycikgPT4ge1xyXG4gICAgLy8gZ2V0IHZhdWx0IHN0cnVjdHVyZSB3aXRob3V0IHNlY3JldHNcclxuICAgIGNvbnN0IHZhdWx0U3RydWN0dXJlID0gZ2V0T2JqU3RydWN0dXJlKHZlcnNpb25lZERhdGEpO1xyXG4gICAgc2VudHJ5LmNhcHR1cmVFeGNlcHRpb24oZXJyLCB7XHJcbiAgICAgIC8vIFwiZXh0cmFcIiBrZXkgaXMgcmVxdWlyZWQgYnkgU2VudHJ5XHJcbiAgICAgIGV4dHJhOiB7IHZhdWx0U3RydWN0dXJlIH0sXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgLy8gbWlncmF0ZSBkYXRhXHJcbiAgdmVyc2lvbmVkRGF0YSA9IGF3YWl0IG1pZ3JhdG9yLm1pZ3JhdGVEYXRhKHZlcnNpb25lZERhdGEpO1xyXG4gIGlmICghdmVyc2lvbmVkRGF0YSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayAtIG1pZ3JhdG9yIHJldHVybmVkIHVuZGVmaW5lZCcpO1xyXG4gIH1cclxuICAvLyB0aGlzIGluaXRpYWxpemVzIHRoZSBtZXRhL3ZlcnNpb24gZGF0YSBhcyBhIGNsYXNzIHZhcmlhYmxlIHRvIGJlIHVzZWQgZm9yIGZ1dHVyZSB3cml0ZXNcclxuICBsb2NhbFN0b3JlLnNldE1ldGFkYXRhKHZlcnNpb25lZERhdGEubWV0YSk7XHJcblxyXG4gIC8vIHdyaXRlIHRvIGRpc2tcclxuICBsb2NhbFN0b3JlLnNldCh2ZXJzaW9uZWREYXRhLmRhdGEpO1xyXG5cclxuICAvLyByZXR1cm4ganVzdCB0aGUgZGF0YVxyXG4gIHJldHVybiB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplcyB0aGUgTWV0YU1hc2sgQ29udHJvbGxlciB3aXRoIGFueSBpbml0aWFsIHN0YXRlIGFuZCBkZWZhdWx0IGxhbmd1YWdlLlxyXG4gKiBDb25maWd1cmVzIHBsYXRmb3JtLXNwZWNpZmljIGVycm9yIHJlcG9ydGluZyBzdHJhdGVneS5cclxuICogU3RyZWFtcyBlbWl0dGVkIHN0YXRlIHVwZGF0ZXMgdG8gcGxhdGZvcm0tc3BlY2lmaWMgc3RvcmFnZSBzdHJhdGVneS5cclxuICogQ3JlYXRlcyBwbGF0Zm9ybSBsaXN0ZW5lcnMgZm9yIG5ldyBEYXBwcy9Db250ZXh0cywgYW5kIHNldHMgdXAgdGhlaXIgZGF0YSBjb25uZWN0aW9ucyB0byB0aGUgY29udHJvbGxlci5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IGluaXRTdGF0ZSAtIFRoZSBpbml0aWFsIHN0YXRlIHRvIHN0YXJ0IHRoZSBjb250cm9sbGVyIHdpdGgsIG1hdGNoZXMgdGhlIHN0YXRlIHRoYXQgaXMgZW1pdHRlZCBmcm9tIHRoZSBjb250cm9sbGVyLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5pdExhbmdDb2RlIC0gVGhlIHJlZ2lvbiBjb2RlIGZvciB0aGUgbGFuZ3VhZ2UgcHJlZmVycmVkIGJ5IHRoZSBjdXJyZW50IHVzZXIuXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvdmVycmlkZXMgLSBvYmplY3Qgd2l0aCBjYWxsYmFja3MgdGhhdCBhcmUgYWxsb3dlZCB0byBvdmVycmlkZSB0aGUgc2V0dXAgY29udHJvbGxlciBsb2dpYyAodXNlZnVsbCBmb3IgZGVza3RvcCBhcHApXHJcbiAqIEBwYXJhbSBpc0ZpcnN0TWV0YU1hc2tDb250cm9sbGVyU2V0dXBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXR1cENvbnRyb2xsZXIoXHJcbiAgaW5pdFN0YXRlLFxyXG4gIGluaXRMYW5nQ29kZSxcclxuICBvdmVycmlkZXMsXHJcbiAgaXNGaXJzdE1ldGFNYXNrQ29udHJvbGxlclNldHVwLFxyXG4pIHtcclxuICAvL1xyXG4gIC8vIE1ldGFNYXNrIENvbnRyb2xsZXJcclxuICAvL1xyXG5cclxuICBjb250cm9sbGVyID0gbmV3IE1ldGFtYXNrQ29udHJvbGxlcih7XHJcbiAgICBpbmZ1cmFQcm9qZWN0SWQ6IHByb2Nlc3MuZW52LklORlVSQV9QUk9KRUNUX0lELFxyXG4gICAgLy8gVXNlciBjb25maXJtYXRpb24gY2FsbGJhY2tzOlxyXG4gICAgc2hvd1VzZXJDb25maXJtYXRpb246IHRyaWdnZXJVaSxcclxuICAgIC8vIGluaXRpYWwgc3RhdGVcclxuICAgIGluaXRTdGF0ZSxcclxuICAgIC8vIGluaXRpYWwgbG9jYWxlIGNvZGVcclxuICAgIGluaXRMYW5nQ29kZSxcclxuICAgIC8vIHBsYXRmb3JtIHNwZWNpZmljIGFwaVxyXG4gICAgcGxhdGZvcm0sXHJcbiAgICBub3RpZmljYXRpb25NYW5hZ2VyLFxyXG4gICAgYnJvd3NlcixcclxuICAgIGdldFJlcXVlc3RBY2NvdW50VGFiSWRzOiAoKSA9PiB7XHJcbiAgICAgIHJldHVybiByZXF1ZXN0QWNjb3VudFRhYklkcztcclxuICAgIH0sXHJcbiAgICBnZXRPcGVuTWV0YW1hc2tUYWJzSWRzOiAoKSA9PiB7XHJcbiAgICAgIHJldHVybiBvcGVuTWV0YW1hc2tUYWJzSURzO1xyXG4gICAgfSxcclxuICAgIGxvY2FsU3RvcmUsXHJcbiAgICBvdmVycmlkZXMsXHJcbiAgICBpc0ZpcnN0TWV0YU1hc2tDb250cm9sbGVyU2V0dXAsXHJcbiAgfSk7XHJcblxyXG4gIHNldHVwRW5zSXBmc1Jlc29sdmVyKHtcclxuICAgIGdldEN1cnJlbnRDaGFpbklkOiAoKSA9PlxyXG4gICAgICBjb250cm9sbGVyLm5ldHdvcmtDb250cm9sbGVyLnN0YXRlLnByb3ZpZGVyQ29uZmlnLmNoYWluSWQsXHJcbiAgICBnZXRJcGZzR2F0ZXdheTogY29udHJvbGxlci5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0SXBmc0dhdGV3YXkuYmluZChcclxuICAgICAgY29udHJvbGxlci5wcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICApLFxyXG4gICAgcHJvdmlkZXI6IGNvbnRyb2xsZXIucHJvdmlkZXIsXHJcbiAgfSk7XHJcblxyXG4gIC8vIHNldHVwIHN0YXRlIHBlcnNpc3RlbmNlXHJcbiAgcHVtcChcclxuICAgIHN0b3JlQXNTdHJlYW0oY29udHJvbGxlci5zdG9yZSksXHJcbiAgICBkZWJvdW5jZSgxMDAwKSxcclxuICAgIGNyZWF0ZVN0cmVhbVNpbmsoYXN5bmMgKHN0YXRlKSA9PiB7XHJcbiAgICAgIGF3YWl0IGxvY2FsU3RvcmUuc2V0KHN0YXRlKTtcclxuICAgICAgc3RhdGVQZXJzaXN0ZW5jZUV2ZW50cy5lbWl0KCdzdGF0ZS1wZXJzaXN0ZWQnLCBzdGF0ZSk7XHJcbiAgICB9KSxcclxuICAgIChlcnJvcikgPT4ge1xyXG4gICAgICBsb2cuZXJyb3IoJ01ldGFNYXNrIC0gUGVyc2lzdGVuY2UgcGlwZWxpbmUgZmFpbGVkJywgZXJyb3IpO1xyXG4gICAgfSxcclxuICApO1xyXG5cclxuICBzZXR1cFNlbnRyeUdldFN0YXRlR2xvYmFsKGNvbnRyb2xsZXIpO1xyXG5cclxuICBjb25zdCBpc0NsaWVudE9wZW5TdGF0dXMgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBwb3B1cElzT3BlbiB8fFxyXG4gICAgICBCb29sZWFuKE9iamVjdC5rZXlzKG9wZW5NZXRhbWFza1RhYnNJRHMpLmxlbmd0aCkgfHxcclxuICAgICAgbm90aWZpY2F0aW9uSXNPcGVuXHJcbiAgICApO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IG9uQ2xvc2VFbnZpcm9ubWVudEluc3RhbmNlcyA9IChpc0NsaWVudE9wZW4sIGVudmlyb25tZW50VHlwZSkgPT4ge1xyXG4gICAgLy8gaWYgYWxsIGluc3RhbmNlcyBvZiBtZXRhbWFzayBhcmUgY2xvc2VkIHdlIGNhbGwgYSBtZXRob2Qgb24gdGhlIGNvbnRyb2xsZXIgdG8gc3RvcCBnYXNGZWVDb250cm9sbGVyIHBvbGxpbmdcclxuICAgIGlmIChpc0NsaWVudE9wZW4gPT09IGZhbHNlKSB7XHJcbiAgICAgIGNvbnRyb2xsZXIub25DbGllbnRDbG9zZWQoKTtcclxuICAgICAgLy8gb3RoZXJ3aXNlIHdlIHdhbnQgdG8gb25seSByZW1vdmUgdGhlIHBvbGxpbmcgdG9rZW5zIGZvciB0aGUgZW52aXJvbm1lbnQgdHlwZSB0aGF0IGhhcyBjbG9zZWRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGZ1bGxzY3JlZW4gZW52aXJvbm1lbnQgYSB1c2VyIG1pZ2h0IGhhdmUgbXVsdGlwbGUgdGFicyBvcGVuIHNvIHdlIGRvbid0IHdhbnQgdG8gZGlzY29ubmVjdCBhbGwgb2ZcclxuICAgICAgLy8gaXRzIGNvcnJlc3BvbmRpbmcgcG9sbGluZyB0b2tlbnMgdW5sZXNzIGFsbCB0YWJzIGFyZSBjbG9zZWQuXHJcbiAgICAgIGlmIChcclxuICAgICAgICBlbnZpcm9ubWVudFR5cGUgPT09IEVOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTiAmJlxyXG4gICAgICAgIEJvb2xlYW4oT2JqZWN0LmtleXMob3Blbk1ldGFtYXNrVGFic0lEcykubGVuZ3RoKVxyXG4gICAgICApIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29udHJvbGxlci5vbkVudmlyb25tZW50VHlwZUNsb3NlZChlbnZpcm9ubWVudFR5cGUpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgcnVudGltZS5Qb3J0IG9iamVjdCwgYXMgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXI6XHJcbiAgICpcclxuICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvcnVudGltZS9Qb3J0XHJcbiAgICogQHR5cGVkZWYgUG9ydFxyXG4gICAqIEB0eXBlIE9iamVjdFxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBDb25uZWN0cyBhIFBvcnQgdG8gdGhlIE1ldGFNYXNrIGNvbnRyb2xsZXIgdmlhIGEgbXVsdGlwbGV4ZWQgZHVwbGV4IHN0cmVhbS5cclxuICAgKiBUaGlzIG1ldGhvZCBpZGVudGlmaWVzIHRydXN0ZWQgKE1ldGFNYXNrKSBpbnRlcmZhY2VzLCBhbmQgY29ubmVjdHMgdGhlbSBkaWZmZXJlbnRseSBmcm9tIHVudHJ1c3RlZCAod2ViIHBhZ2VzKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UG9ydH0gcmVtb3RlUG9ydCAtIFRoZSBwb3J0IHByb3ZpZGVkIGJ5IGEgbmV3IGNvbnRleHQuXHJcbiAgICovXHJcbiAgY29ubmVjdFJlbW90ZSA9IGFzeW5jIChyZW1vdGVQb3J0KSA9PiB7XHJcblxuXHJcbiAgICBjb25zdCBwcm9jZXNzTmFtZSA9IHJlbW90ZVBvcnQubmFtZTtcclxuXHJcbiAgICBpZiAobWV0YW1hc2tCbG9ja2VkUG9ydHMuaW5jbHVkZXMocmVtb3RlUG9ydC5uYW1lKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGlzTWV0YU1hc2tJbnRlcm5hbFByb2Nlc3MgPSBmYWxzZTtcclxuICAgIGNvbnN0IHNvdXJjZVBsYXRmb3JtID0gZ2V0UGxhdGZvcm0oKTtcclxuICAgIGNvbnN0IHNlbmRlclVybCA9IHJlbW90ZVBvcnQuc2VuZGVyPy51cmxcclxuICAgICAgPyBuZXcgVVJMKHJlbW90ZVBvcnQuc2VuZGVyLnVybClcclxuICAgICAgOiBudWxsO1xyXG5cclxuICAgIGlmIChzb3VyY2VQbGF0Zm9ybSA9PT0gUExBVEZPUk1fRklSRUZPWCkge1xyXG4gICAgICBpc01ldGFNYXNrSW50ZXJuYWxQcm9jZXNzID0gbWV0YW1hc2tJbnRlcm5hbFByb2Nlc3NIYXNoW3Byb2Nlc3NOYW1lXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlzTWV0YU1hc2tJbnRlcm5hbFByb2Nlc3MgPVxyXG4gICAgICAgIHNlbmRlclVybD8ub3JpZ2luID09PSBgY2hyb21lLWV4dGVuc2lvbjovLyR7YnJvd3Nlci5ydW50aW1lLmlkfWA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTWV0YU1hc2tJbnRlcm5hbFByb2Nlc3MpIHtcclxuICAgICAgY29uc3QgcG9ydFN0cmVhbSA9XHJcbiAgICAgICAgb3ZlcnJpZGVzPy5nZXRQb3J0U3RyZWFtPy4ocmVtb3RlUG9ydCkgfHwgbmV3IFBvcnRTdHJlYW0ocmVtb3RlUG9ydCk7XHJcbiAgICAgIC8vIGNvbW11bmljYXRpb24gd2l0aCBwb3B1cFxyXG4gICAgICBjb250cm9sbGVyLmlzQ2xpZW50T3BlbiA9IHRydWU7XHJcbiAgICAgIGNvbnRyb2xsZXIuc2V0dXBUcnVzdGVkQ29tbXVuaWNhdGlvbihwb3J0U3RyZWFtLCByZW1vdGVQb3J0LnNlbmRlcik7XHJcblxyXG4gICAgICBpZiAoaXNNYW5pZmVzdFYzKSB7XHJcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGEgV09SS0VSX0tFRVBfQUxJVkUgbWVzc2FnZSwgd2UgcmVzcG9uZCB3aXRoIGFuIEFDS1xyXG4gICAgICAgIHJlbW90ZVBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKChtZXNzYWdlKSA9PiB7XHJcbiAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lID09PSBXT1JLRVJfS0VFUF9BTElWRV9NRVNTQUdFKSB7XHJcbiAgICAgICAgICAgIC8vIFRvIHRlc3QgdW4tY29tbWVudCB0aGlzIGxpbmUgYW5kIHdhaXQgZm9yIDEgbWludXRlLiBBbiBlcnJvciBzaG91bGQgYmUgc2hvd24gb24gTWV0YU1hc2sgVUkuXHJcbiAgICAgICAgICAgIHJlbW90ZVBvcnQucG9zdE1lc3NhZ2UoeyBuYW1lOiBBQ0tfS0VFUF9BTElWRV9NRVNTQUdFIH0pO1xyXG5cclxuICAgICAgICAgICAgY29udHJvbGxlci5hcHBTdGF0ZUNvbnRyb2xsZXIuc2V0U2VydmljZVdvcmtlckxhc3RBY3RpdmVUaW1lKFxyXG4gICAgICAgICAgICAgIERhdGUubm93KCksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChwcm9jZXNzTmFtZSA9PT0gRU5WSVJPTk1FTlRfVFlQRV9QT1BVUCkge1xyXG4gICAgICAgIHBvcHVwSXNPcGVuID0gdHJ1ZTtcclxuICAgICAgICBlbmRPZlN0cmVhbShwb3J0U3RyZWFtLCAoKSA9PiB7XHJcbiAgICAgICAgICBwb3B1cElzT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgY29uc3QgaXNDbGllbnRPcGVuID0gaXNDbGllbnRPcGVuU3RhdHVzKCk7XHJcbiAgICAgICAgICBjb250cm9sbGVyLmlzQ2xpZW50T3BlbiA9IGlzQ2xpZW50T3BlbjtcclxuICAgICAgICAgIG9uQ2xvc2VFbnZpcm9ubWVudEluc3RhbmNlcyhpc0NsaWVudE9wZW4sIEVOVklST05NRU5UX1RZUEVfUE9QVVApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAocHJvY2Vzc05hbWUgPT09IEVOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OKSB7XHJcbiAgICAgICAgbm90aWZpY2F0aW9uSXNPcGVuID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZW5kT2ZTdHJlYW0ocG9ydFN0cmVhbSwgKCkgPT4ge1xyXG4gICAgICAgICAgbm90aWZpY2F0aW9uSXNPcGVuID0gZmFsc2U7XHJcbiAgICAgICAgICBjb25zdCBpc0NsaWVudE9wZW4gPSBpc0NsaWVudE9wZW5TdGF0dXMoKTtcclxuICAgICAgICAgIGNvbnRyb2xsZXIuaXNDbGllbnRPcGVuID0gaXNDbGllbnRPcGVuO1xyXG4gICAgICAgICAgb25DbG9zZUVudmlyb25tZW50SW5zdGFuY2VzKFxyXG4gICAgICAgICAgICBpc0NsaWVudE9wZW4sXHJcbiAgICAgICAgICAgIEVOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHByb2Nlc3NOYW1lID09PSBFTlZJUk9OTUVOVF9UWVBFX0ZVTExTQ1JFRU4pIHtcclxuICAgICAgICBjb25zdCB0YWJJZCA9IHJlbW90ZVBvcnQuc2VuZGVyLnRhYi5pZDtcclxuICAgICAgICBvcGVuTWV0YW1hc2tUYWJzSURzW3RhYklkXSA9IHRydWU7XHJcblxyXG4gICAgICAgIGVuZE9mU3RyZWFtKHBvcnRTdHJlYW0sICgpID0+IHtcclxuICAgICAgICAgIGRlbGV0ZSBvcGVuTWV0YW1hc2tUYWJzSURzW3RhYklkXTtcclxuICAgICAgICAgIGNvbnN0IGlzQ2xpZW50T3BlbiA9IGlzQ2xpZW50T3BlblN0YXR1cygpO1xyXG4gICAgICAgICAgY29udHJvbGxlci5pc0NsaWVudE9wZW4gPSBpc0NsaWVudE9wZW47XHJcbiAgICAgICAgICBvbkNsb3NlRW52aXJvbm1lbnRJbnN0YW5jZXMoXHJcbiAgICAgICAgICAgIGlzQ2xpZW50T3BlbixcclxuICAgICAgICAgICAgRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgc2VuZGVyVXJsICYmXHJcbiAgICAgIHNlbmRlclVybC5vcmlnaW4gPT09IHBoaXNoaW5nUGFnZVVybC5vcmlnaW4gJiZcclxuICAgICAgc2VuZGVyVXJsLnBhdGhuYW1lID09PSBwaGlzaGluZ1BhZ2VVcmwucGF0aG5hbWVcclxuICAgICkge1xyXG4gICAgICBjb25zdCBwb3J0U3RyZWFtID1cclxuICAgICAgICBvdmVycmlkZXM/LmdldFBvcnRTdHJlYW0/LihyZW1vdGVQb3J0KSB8fCBuZXcgUG9ydFN0cmVhbShyZW1vdGVQb3J0KTtcclxuICAgICAgY29udHJvbGxlci5zZXR1cFBoaXNoaW5nQ29tbXVuaWNhdGlvbih7XHJcbiAgICAgICAgY29ubmVjdGlvblN0cmVhbTogcG9ydFN0cmVhbSxcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAocmVtb3RlUG9ydC5zZW5kZXIgJiYgcmVtb3RlUG9ydC5zZW5kZXIudGFiICYmIHJlbW90ZVBvcnQuc2VuZGVyLnVybCkge1xyXG4gICAgICAgIGNvbnN0IHRhYklkID0gcmVtb3RlUG9ydC5zZW5kZXIudGFiLmlkO1xyXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVtb3RlUG9ydC5zZW5kZXIudXJsKTtcclxuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gdXJsO1xyXG5cclxuICAgICAgICByZW1vdGVQb3J0Lm9uTWVzc2FnZS5hZGRMaXN0ZW5lcigobXNnKSA9PiB7XHJcbiAgICAgICAgICBpZiAobXNnLmRhdGEgJiYgbXNnLmRhdGEubWV0aG9kID09PSAnZXRoX3JlcXVlc3RBY2NvdW50cycpIHtcclxuICAgICAgICAgICAgcmVxdWVzdEFjY291bnRUYWJJZHNbb3JpZ2luXSA9IHRhYklkO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbm5lY3RFeHRlcm5hbChyZW1vdGVQb3J0KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBjb21tdW5pY2F0aW9uIHdpdGggcGFnZSBvciBvdGhlciBleHRlbnNpb25cclxuICBjb25uZWN0RXh0ZXJuYWwgPSAocmVtb3RlUG9ydCkgPT4ge1xyXG5cblxyXG4gICAgY29uc3QgcG9ydFN0cmVhbSA9XHJcbiAgICAgIG92ZXJyaWRlcz8uZ2V0UG9ydFN0cmVhbT8uKHJlbW90ZVBvcnQpIHx8IG5ldyBQb3J0U3RyZWFtKHJlbW90ZVBvcnQpO1xyXG4gICAgY29udHJvbGxlci5zZXR1cFVudHJ1c3RlZENvbW11bmljYXRpb24oe1xyXG4gICAgICBjb25uZWN0aW9uU3RyZWFtOiBwb3J0U3RyZWFtLFxyXG4gICAgICBzZW5kZXI6IHJlbW90ZVBvcnQuc2VuZGVyLFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgaWYgKG92ZXJyaWRlcz8ucmVnaXN0ZXJDb25uZWN0TGlzdGVuZXJzKSB7XHJcbiAgICBvdmVycmlkZXMucmVnaXN0ZXJDb25uZWN0TGlzdGVuZXJzKGNvbm5lY3RSZW1vdGUsIGNvbm5lY3RFeHRlcm5hbCk7XHJcbiAgfVxyXG5cclxuICAvL1xyXG4gIC8vIFVzZXIgSW50ZXJmYWNlIHNldHVwXHJcbiAgLy9cclxuICB1cGRhdGVCYWRnZSgpO1xyXG5cclxuICBjb250cm9sbGVyLnR4Q29udHJvbGxlci5vbihcclxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcclxuICAgIHVwZGF0ZUJhZGdlLFxyXG4gICk7XHJcbiAgY29udHJvbGxlci5kZWNyeXB0TWVzc2FnZUNvbnRyb2xsZXIuaHViLm9uKFxyXG4gICAgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuVVBEQVRFX0JBREdFLFxyXG4gICAgdXBkYXRlQmFkZ2UsXHJcbiAgKTtcclxuICBjb250cm9sbGVyLmVuY3J5cHRpb25QdWJsaWNLZXlDb250cm9sbGVyLmh1Yi5vbihcclxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcclxuICAgIHVwZGF0ZUJhZGdlLFxyXG4gICk7XHJcbiAgY29udHJvbGxlci5zaWduYXR1cmVDb250cm9sbGVyLmh1Yi5vbihcclxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcclxuICAgIHVwZGF0ZUJhZGdlLFxyXG4gICk7XHJcbiAgY29udHJvbGxlci5hcHBTdGF0ZUNvbnRyb2xsZXIub24oXHJcbiAgICBNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUy5VUERBVEVfQkFER0UsXHJcbiAgICB1cGRhdGVCYWRnZSxcclxuICApO1xyXG5cclxuICBjb250cm9sbGVyLmNvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKFxyXG4gICAgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuQVBQUk9WQUxfU1RBVEVfQ0hBTkdFLFxyXG4gICAgdXBkYXRlQmFkZ2UsXHJcbiAgKTtcclxuXHJcbiAgY29udHJvbGxlci50eENvbnRyb2xsZXIuaW5pdEFwcHJvdmFscygpO1xyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBXZWIgRXh0ZW5zaW9uJ3MgXCJiYWRnZVwiIG51bWJlciwgb24gdGhlIGxpdHRsZSBmb3ggaW4gdGhlIHRvb2xiYXIuXHJcbiAgICogVGhlIG51bWJlciByZWZsZWN0cyB0aGUgY3VycmVudCBudW1iZXIgb2YgcGVuZGluZyB0cmFuc2FjdGlvbnMgb3IgbWVzc2FnZSBzaWduYXR1cmVzIG5lZWRpbmcgdXNlciBhcHByb3ZhbC5cclxuICAgKi9cclxuICBmdW5jdGlvbiB1cGRhdGVCYWRnZSgpIHtcclxuICAgIGxldCBsYWJlbCA9ICcnO1xyXG4gICAgY29uc3QgY291bnQgPSBnZXRVbmFwcHJvdmVkVHJhbnNhY3Rpb25Db3VudCgpO1xyXG4gICAgaWYgKGNvdW50KSB7XHJcbiAgICAgIGxhYmVsID0gU3RyaW5nKGNvdW50KTtcclxuICAgIH1cclxuICAgIC8vIGJyb3dzZXJBY3Rpb24gaGFzIGJlZW4gcmVwbGFjZWQgYnkgYWN0aW9uIGluIE1WM1xyXG4gICAgaWYgKGlzTWFuaWZlc3RWMykge1xyXG4gICAgICBicm93c2VyLmFjdGlvbi5zZXRCYWRnZVRleHQoeyB0ZXh0OiBsYWJlbCB9KTtcclxuICAgICAgYnJvd3Nlci5hY3Rpb24uc2V0QmFkZ2VCYWNrZ3JvdW5kQ29sb3IoeyBjb2xvcjogJyMwMzdERDYnIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnJvd3Nlci5icm93c2VyQWN0aW9uLnNldEJhZGdlVGV4dCh7IHRleHQ6IGxhYmVsIH0pO1xyXG4gICAgICBicm93c2VyLmJyb3dzZXJBY3Rpb24uc2V0QmFkZ2VCYWNrZ3JvdW5kQ29sb3IoeyBjb2xvcjogJyMwMzdERDYnIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0VW5hcHByb3ZlZFRyYW5zYWN0aW9uQ291bnQoKSB7XHJcbiAgICBjb25zdCBwZW5kaW5nQXBwcm92YWxDb3VudCA9XHJcbiAgICAgIGNvbnRyb2xsZXIuYXBwcm92YWxDb250cm9sbGVyLmdldFRvdGFsQXBwcm92YWxDb3VudCgpO1xyXG4gICAgY29uc3Qgd2FpdGluZ0ZvclVubG9ja0NvdW50ID1cclxuICAgICAgY29udHJvbGxlci5hcHBTdGF0ZUNvbnRyb2xsZXIud2FpdGluZ0ZvclVubG9jay5sZW5ndGg7XHJcbiAgICByZXR1cm4gcGVuZGluZ0FwcHJvdmFsQ291bnQgKyB3YWl0aW5nRm9yVW5sb2NrQ291bnQ7XHJcbiAgfVxyXG5cclxuICBub3RpZmljYXRpb25NYW5hZ2VyLm9uKFxyXG4gICAgTk9USUZJQ0FUSU9OX01BTkFHRVJfRVZFTlRTLlBPUFVQX0NMT1NFRCxcclxuICAgICh7IGF1dG9tYXRpY2FsbHlDbG9zZWQgfSkgPT4ge1xyXG4gICAgICBpZiAoIWF1dG9tYXRpY2FsbHlDbG9zZWQpIHtcclxuICAgICAgICByZWplY3RVbmFwcHJvdmVkTm90aWZpY2F0aW9ucygpO1xyXG4gICAgICB9IGVsc2UgaWYgKGdldFVuYXBwcm92ZWRUcmFuc2FjdGlvbkNvdW50KCkgPiAwKSB7XHJcbiAgICAgICAgdHJpZ2dlclVpKCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgKTtcclxuXHJcbiAgZnVuY3Rpb24gcmVqZWN0VW5hcHByb3ZlZE5vdGlmaWNhdGlvbnMoKSB7XHJcbiAgICBPYmplY3Qua2V5cyhcclxuICAgICAgY29udHJvbGxlci50eENvbnRyb2xsZXIudHhTdGF0ZU1hbmFnZXIuZ2V0VW5hcHByb3ZlZFR4TGlzdCgpLFxyXG4gICAgKS5mb3JFYWNoKCh0eElkKSA9PlxyXG4gICAgICBjb250cm9sbGVyLnR4Q29udHJvbGxlci50eFN0YXRlTWFuYWdlci5zZXRUeFN0YXR1c1JlamVjdGVkKHR4SWQpLFxyXG4gICAgKTtcclxuICAgIGNvbnRyb2xsZXIuc2lnbmF0dXJlQ29udHJvbGxlci5yZWplY3RVbmFwcHJvdmVkKFxyXG4gICAgICBSRUpFQ1RfTk9USUZJQ0FUSU9OX0NMT1NFX1NJRyxcclxuICAgICk7XHJcbiAgICBjb250cm9sbGVyLmRlY3J5cHRNZXNzYWdlQ29udHJvbGxlci5yZWplY3RVbmFwcHJvdmVkKFxyXG4gICAgICBSRUpFQ1RfTk9USUZJQ0FUSU9OX0NMT1NFLFxyXG4gICAgKTtcclxuICAgIGNvbnRyb2xsZXIuZW5jcnlwdGlvblB1YmxpY0tleUNvbnRyb2xsZXIucmVqZWN0VW5hcHByb3ZlZChcclxuICAgICAgUkVKRUNUX05PVElGSUNBVElPTl9DTE9TRSxcclxuICAgICk7XHJcblxyXG4gICAgLy8gRmluYWxseSwgcmVzb2x2ZSBzbmFwIGRpYWxvZyBhcHByb3ZhbHMgb24gRmxhc2sgYW5kIHJlamVjdCBhbGwgdGhlIG90aGVycyBtYW5hZ2VkIGJ5IHRoZSBBcHByb3ZhbENvbnRyb2xsZXIuXHJcbiAgICBPYmplY3QudmFsdWVzKGNvbnRyb2xsZXIuYXBwcm92YWxDb250cm9sbGVyLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHMpLmZvckVhY2goXHJcbiAgICAgICh7IGlkLCB0eXBlIH0pID0+IHtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29udHJvbGxlci5hcHByb3ZhbENvbnRyb2xsZXIucmVqZWN0KFxyXG4gICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgIGV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICk7XHJcblxyXG4gICAgdXBkYXRlQmFkZ2UoKTtcclxuICB9XHJcblxyXG5cbn1cclxuXHJcbi8vXHJcbi8vIEV0Yy4uLlxyXG4vL1xyXG5cclxuLyoqXHJcbiAqIE9wZW5zIHRoZSBicm93c2VyIHBvcHVwIGZvciB1c2VyIGNvbmZpcm1hdGlvblxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gdHJpZ2dlclVpKCkge1xyXG4gIGNvbnN0IHRhYnMgPSBhd2FpdCBwbGF0Zm9ybS5nZXRBY3RpdmVUYWJzKCk7XHJcbiAgY29uc3QgY3VycmVudGx5QWN0aXZlTWV0YW1hc2tUYWIgPSBCb29sZWFuKFxyXG4gICAgdGFicy5maW5kKCh0YWIpID0+IG9wZW5NZXRhbWFza1RhYnNJRHNbdGFiLmlkXSksXHJcbiAgKTtcclxuICAvLyBWaXZhbGRpIGlzIG5vdCBjbG9zaW5nIHBvcnQgY29ubmVjdGlvbiBvbiBwb3B1cCBjbG9zZSwgc28gcG9wdXBJc09wZW4gZG9lcyBub3Qgd29yayBjb3JyZWN0bHlcclxuICAvLyBUbyBiZSByZXZpZXdlZCBpbiB0aGUgZnV0dXJlIGlmIHRoaXMgYmVoYXZpb3VyIGlzIGZpeGVkIC0gYWxzbyB0aGUgd2F5IHdlIGRldGVybWluZSBpc1ZpdmFsZGkgdmFyaWFibGUgbWlnaHQgY2hhbmdlIGF0IHNvbWUgcG9pbnRcclxuICBjb25zdCBpc1ZpdmFsZGkgPVxyXG4gICAgdGFicy5sZW5ndGggPiAwICYmXHJcbiAgICB0YWJzWzBdLmV4dERhdGEgJiZcclxuICAgIHRhYnNbMF0uZXh0RGF0YS5pbmRleE9mKCd2aXZhbGRpX3RhYicpID4gLTE7XHJcbiAgaWYgKFxyXG4gICAgIXVpSXNUcmlnZ2VyaW5nICYmXHJcbiAgICAoaXNWaXZhbGRpIHx8ICFwb3B1cElzT3BlbikgJiZcclxuICAgICFjdXJyZW50bHlBY3RpdmVNZXRhbWFza1RhYlxyXG4gICkge1xyXG4gICAgdWlJc1RyaWdnZXJpbmcgPSB0cnVlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY3VycmVudFBvcHVwSWQgPSBjb250cm9sbGVyLmFwcFN0YXRlQ29udHJvbGxlci5nZXRDdXJyZW50UG9wdXBJZCgpO1xyXG4gICAgICBhd2FpdCBub3RpZmljYXRpb25NYW5hZ2VyLnNob3dQb3B1cChcclxuICAgICAgICAobmV3UG9wdXBJZCkgPT5cclxuICAgICAgICAgIGNvbnRyb2xsZXIuYXBwU3RhdGVDb250cm9sbGVyLnNldEN1cnJlbnRQb3B1cElkKG5ld1BvcHVwSWQpLFxyXG4gICAgICAgIGN1cnJlbnRQb3B1cElkLFxyXG4gICAgICApO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgdWlJc1RyaWdnZXJpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEl0IGFkZHMgdGhlIFwiQXBwIEluc3RhbGxlZFwiIGV2ZW50IGludG8gYSBxdWV1ZSBvZiBldmVudHMsIHdoaWNoIHdpbGwgYmUgdHJhY2tlZCBvbmx5IGFmdGVyIGEgdXNlciBvcHRzIGludG8gbWV0cmljcy5cclxuY29uc3QgYWRkQXBwSW5zdGFsbGVkRXZlbnQgPSAoKSA9PiB7XHJcbiAgaWYgKGNvbnRyb2xsZXIpIHtcclxuICAgIGNvbnRyb2xsZXIubWV0YU1ldHJpY3NDb250cm9sbGVyLnVwZGF0ZVRyYWl0cyh7XHJcbiAgICAgIFtNZXRhTWV0cmljc1VzZXJUcmFpdC5JbnN0YWxsRGF0ZUV4dF06IG5ldyBEYXRlKClcclxuICAgICAgICAudG9JU09TdHJpbmcoKVxyXG4gICAgICAgIC5zcGxpdCgnVCcpWzBdLCAvLyB5eXl5LW1tLWRkXHJcbiAgICB9KTtcclxuICAgIGNvbnRyb2xsZXIubWV0YU1ldHJpY3NDb250cm9sbGVyLmFkZEV2ZW50QmVmb3JlTWV0cmljc09wdEluKHtcclxuICAgICAgY2F0ZWdvcnk6IE1ldGFNZXRyaWNzRXZlbnRDYXRlZ29yeS5BcHAsXHJcbiAgICAgIGV2ZW50OiBNZXRhTWV0cmljc0V2ZW50TmFtZS5BcHBJbnN0YWxsZWQsXHJcbiAgICAgIHByb3BlcnRpZXM6IHt9LFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG4gIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgLy8gSWYgdGhlIGNvbnRyb2xsZXIgaXMgbm90IHNldCB5ZXQsIHdlIHdhaXQgYW5kIHRyeSB0byBhZGQgdGhlIFwiQXBwIEluc3RhbGxlZFwiIGV2ZW50IGFnYWluLlxyXG4gICAgYWRkQXBwSW5zdGFsbGVkRXZlbnQoKTtcclxuICB9LCAxMDAwKTtcclxufTtcclxuXHJcbi8vIE9uIGZpcnN0IGluc3RhbGwsIG9wZW4gYSBuZXcgdGFiIHdpdGggTWV0YU1hc2tcclxuYnJvd3Nlci5ydW50aW1lLm9uSW5zdGFsbGVkLmFkZExpc3RlbmVyKCh7IHJlYXNvbiB9KSA9PiB7XHJcbiAgaWYgKFxyXG4gICAgcmVhc29uID09PSAnaW5zdGFsbCcgJiZcclxuICAgICEocHJvY2Vzcy5lbnYuTUVUQU1BU0tfREVCVUcgfHwgcHJvY2Vzcy5lbnYuSU5fVEVTVClcclxuICApIHtcclxuICAgIGFkZEFwcEluc3RhbGxlZEV2ZW50KCk7XHJcbiAgICBwbGF0Zm9ybS5vcGVuRXh0ZW5zaW9uSW5Ccm93c2VyKCk7XHJcbiAgfVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHNldHVwU2VudHJ5R2V0U3RhdGVHbG9iYWwoc3RvcmUpIHtcclxuICBnbG9iYWwuc3RhdGVIb29rcy5nZXRTZW50cnlTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0IGZ1bGxTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XHJcbiAgICBjb25zdCBkZWJ1Z1N0YXRlID0gbWFza09iamVjdCh7IG1ldGFtYXNrOiBmdWxsU3RhdGUgfSwgU0VOVFJZX1NUQVRFKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGJyb3dzZXI6IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LFxyXG4gICAgICBzdG9yZTogZGVidWdTdGF0ZSxcclxuICAgICAgdmVyc2lvbjogcGxhdGZvcm0uZ2V0VmVyc2lvbigpLFxyXG4gICAgfTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpbml0QmFja2dyb3VuZCgpIHtcclxuICBpbml0aWFsaXplKCkuY2F0Y2gobG9nLmVycm9yKTtcclxufVxyXG5cclxuaWYgKCFwcm9jZXNzLmVudi5TS0lQX0JBQ0tHUk9VTkRfSU5JVElBTElaQVRJT04pIHtcclxuICBpbml0QmFja2dyb3VuZCgpO1xyXG59XHJcbiJdLCJwcmVFeGlzdGluZ0NvbW1lbnQiOiIvLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAifQ==
