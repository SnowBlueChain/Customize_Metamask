LavaPack.loadBundle([
["F:\\metamask-extension\\app\\scripts\\migrations\\004.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C004.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 4;
var _default = {
  version,
  migrate(versionedData) {
    const safeVersionedData = (0, _lodash.cloneDeep)(versionedData);
    safeVersionedData.meta.version = version;
    try {
      if (safeVersionedData.data.config.provider.type !== 'rpc') {
        return Promise.resolve(safeVersionedData);
      }
      switch (safeVersionedData.data.config.provider.rpcTarget) {
        case 'https://testrpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'testnet'
          };
          break;
        case 'https://rpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'mainnet'
          };
          break;
        // No default
      }
    } catch (_) {
      // empty
    }
    return Promise.resolve(safeVersionedData);
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\004.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\005.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C005.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration moves state from the flat state trie into KeyringController substate

*/

const version = 5;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = selectSubstateForKeyringController(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #5${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function selectSubstateForKeyringController(state) {
  const {
    config
  } = state;
  const newState = {
    ...state,
    KeyringController: {
      vault: state.vault,
      selectedAccount: config.selectedAccount,
      walletNicknames: state.walletNicknames
    }
  };
  delete newState.vault;
  delete newState.walletNicknames;
  delete newState.config.selectedAccount;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\005.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\006.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C006.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration moves KeyringController.selectedAddress to PreferencesController.selectedAddress

*/

const version = 6;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = migrateState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function migrateState(state) {
  const keyringSubstate = state.KeyringController;

  // add new state
  const newState = {
    ...state,
    PreferencesController: {
      selectedAddress: keyringSubstate.selectedAccount
    }
  };

  // rm old state
  delete newState.KeyringController.selectedAccount;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\006.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\007.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C007.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the TransactionManager substate

*/

const version = 7;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = {
    ...state,
    TransactionManager: {
      transactions: state.transactions || [],
      gasMultiplier: state.gasMultiplier || 1
    }
  };
  delete newState.transactions;
  delete newState.gasMultiplier;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\007.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\008.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C008.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the NoticeController substate

*/

const version = 8;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = {
    ...state,
    NoticeController: {
      noticesList: state.noticesList || []
    }
  };
  delete newState.noticesList;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\008.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\009.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C009.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the CurrencyController substate

*/

const version = 9;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    CurrencyController: {
      currentCurrency: state.currentFiat || state.fiatCurrency || 'USD',
      conversionRate: state.conversionRate,
      conversionDate: state.conversionDate
    }
  });
  delete newState.currentFiat;
  delete newState.fiatCurrency;
  delete newState.conversionRate;
  delete newState.conversionDate;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\009.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\010.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C010.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration breaks out the ShapeShiftController substate

*/

const version = 10;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    ShapeShiftController: {
      shapeShiftTxList: state.shapeShiftTxList || []
    }
  });
  delete newState.shapeShiftTxList;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\010.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\011.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C011.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration removes the discaimer state from our app, which was integrated into our notices.

*/

const version = 11;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  delete newState.TOSHash;
  delete newState.isDisclaimerConfirmed;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\011.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\012.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C012.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration modifies our notices to delete their body after being read.

*/

const version = 12;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  newState.NoticeController.noticesList.forEach(notice => {
    if (notice.read) {
      notice.body = '';
    }
  });
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\012.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\013.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C013.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration modifies the network config from ambiguous 'testnet' to explicit 'ropsten'

*/

const version = 13;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    config
  } = newState;
  if (config && config.provider) {
    if (config.provider.type === 'testnet') {
      newState.config.provider.type = 'ropsten';
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\013.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\014.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C014.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration removes provider from config and moves it too NetworkController.

*/

const version = 14;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  newState.NetworkController = {};
  newState.NetworkController.provider = newState.config.provider;
  delete newState.config.provider;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\014.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\015.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C015.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/

const version = 15;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      } else if (txMeta.err.message === 'Gave up submitting tx.') {
        txMeta.status = _transaction.TransactionStatus.failed;
      }
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\015.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\016.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C016.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/

const version = 16;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      }
      if (txMeta.err === 'transaction with the same hash was already imported.') {
        txMeta.status = _transaction.TransactionStatus.submitted;
        delete txMeta.err;
      }
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\016.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\017.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C017.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions who were retried and marked as failed to submitted

*/

const version = 17;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.status === _transaction.TransactionStatus.failed) {
        return txMeta;
      }
      if (txMeta.retryCount > 0 && txMeta.retryCount < 2) {
        txMeta.status = _transaction.TransactionStatus.submitted;
        delete txMeta.err;
      }
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\017.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\018.js", {"../controllers/transactions/lib/tx-state-history-helpers":"F:\\metamask-extension\\app\\scripts\\controllers\\transactions\\lib\\tx-state-history-helpers.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C018.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _txStateHistoryHelpers = require("../controllers/transactions/lib/tx-state-history-helpers");
/*

This migration updates "transaction state history" to diffs style

*/

const version = 18;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      // no history: initialize
      if (!txMeta.history || txMeta.history.length === 0) {
        const snapshot = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta);
        txMeta.history = [snapshot];
        return txMeta;
      }
      // has history: migrate
      const newHistory = (0, _txStateHistoryHelpers.migrateFromSnapshotsToDiffs)(txMeta.history)
      // remove empty diffs
      .filter(entry => {
        return !Array.isArray(entry) || entry.length > 0;
      });
      txMeta.history = newHistory;
      return txMeta;
    });
  }
  return newState;
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\018.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\019.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C019.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration sets transactions as failed
whos nonce is too high

*/

const version = 19;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map((txMeta, _, txList) => {
      if (txMeta.status !== _transaction.TransactionStatus.submitted) {
        return txMeta;
      }
      const confirmedTxs = txList.filter(tx => tx.status === _transaction.TransactionStatus.confirmed).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestConfirmedNonce = getHighestNonce(confirmedTxs);
      const pendingTxs = txList.filter(tx => tx.status === _transaction.TransactionStatus.submitted).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestContinuousNonce = getHighestContinuousFrom(pendingTxs, highestConfirmedNonce);
      const maxNonce = Math.max(highestContinuousNonce, highestConfirmedNonce);
      if (parseInt(txMeta.txParams.nonce, 16) > maxNonce + 1) {
        txMeta.status = _transaction.TransactionStatus.failed;
        txMeta.err = {
          message: 'nonce too high',
          note: 'migration 019 custom error'
        };
      }
      return txMeta;
    });
  }
  return newState;
}
function getHighestContinuousFrom(txList, startPoint) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce, 16);
  });
  let highest = startPoint;
  while (nonces.includes(highest)) {
    highest += 1;
  }
  return highest;
}
function getHighestNonce(txList) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce || '0x0', 16);
  });
  const highestNonce = Math.max.apply(null, nonces);
  return highestNonce;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\019.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\020.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C020.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration ensures previous installations
get a `firstTimeInfo` key on the metamask state,
so that we can version notices in the future.

*/

const version = 20;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if ('metamask' in newState && !('firstTimeInfo' in newState.metamask)) {
    newState.metamask.firstTimeInfo = {
      version: '3.12.0',
      date: Date.now()
    };
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\020.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\021.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C021.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration removes the BlackListController from disk state

*/

const version = 21;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  delete newState.BlacklistController;
  delete newState.RecentBlocks;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\021.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\022.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C022.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration adds submittedTime to the txMeta if it is not their

*/

const version = 22;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (txMeta.status !== _transaction.TransactionStatus.submitted || txMeta.submittedTime) {
        return txMeta;
      }
      txMeta.submittedTime = new Date().getTime();
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\022.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\023.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C023.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration removes transactions that are no longer usefull down to 40 total

*/

const version = 23;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    if (transactions.length <= 40) {
      return newState;
    }
    const reverseTxList = transactions.reverse();
    let stripping = true;
    while (reverseTxList.length > 40 && stripping) {
      const txIndex = reverseTxList.findIndex(txMeta => {
        return txMeta.status === _transaction.TransactionStatus.failed || txMeta.status === _transaction.TransactionStatus.rejected || txMeta.status === _transaction.TransactionStatus.confirmed || txMeta.status === _transaction.TransactionStatus.dropped;
      });
      if (txIndex < 0) {
        stripping = false;
      } else {
        reverseTxList.splice(txIndex, 1);
      }
    }
    newState.TransactionController.transactions = reverseTxList.reverse();
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\023.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\024.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C024.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
/*

This migration ensures that the from address in txParams is to lower case for
all unapproved transactions

*/

const version = 24;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (!newState.TransactionController) {
    return newState;
  }
  const {
    transactions
  } = newState.TransactionController;
  newState.TransactionController.transactions = transactions.map((txMeta, _) => {
    if (txMeta.status === _transaction.TransactionStatus.unapproved && txMeta.txParams && txMeta.txParams.from) {
      txMeta.txParams.from = txMeta.txParams.from.toLowerCase();
    }
    return txMeta;
  });
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\024.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\025.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","../lib/util":"F:\\metamask-extension\\app\\scripts\\lib\\util.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C025.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _util = require("../lib/util");
var _transaction = require("../../../shared/constants/transaction");
// next version number
/*

normalizes txParams on unconfirmed txs

*/

const version = 25;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.map(txMeta => {
        if (txMeta.status !== _transaction.TransactionStatus.unapproved) {
          return txMeta;
        }
        txMeta.txParams = normalizeTxParams(txMeta.txParams);
        return txMeta;
      });
    }
  }
  return newState;
}
function normalizeTxParams(txParams) {
  // functions that handle normalizing of that key in txParams
  const whiteList = {
    from: from => (0, _util.addHexPrefix)(from).toLowerCase(),
    to: () => (0, _util.addHexPrefix)(txParams.to).toLowerCase(),
    nonce: nonce => (0, _util.addHexPrefix)(nonce),
    value: value => (0, _util.addHexPrefix)(value),
    data: data => (0, _util.addHexPrefix)(data),
    gas: gas => (0, _util.addHexPrefix)(gas),
    gasPrice: gasPrice => (0, _util.addHexPrefix)(gasPrice)
  };

  // apply only keys in the whiteList
  const normalizedTxParams = {};
  Object.keys(whiteList).forEach(key => {
    if (txParams[key]) {
      normalizedTxParams[key] = whiteList[key](txParams[key]);
    }
  });
  return normalizedTxParams;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\025.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\026.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C026.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
/*

This migration moves the identities stored in the KeyringController
 into the PreferencesController

*/

const version = 26;
var _default = {
  version,
  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      versionedData.data = transformState(state);
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
      return Promise.reject(err);
    }
    return Promise.resolve(versionedData);
  }
};
exports.default = _default;
function transformState(state) {
  if (!state.KeyringController || !state.PreferencesController) {
    return state;
  }
  if (!state.KeyringController.walletNicknames) {
    return state;
  }
  state.PreferencesController.identities = Object.keys(state.KeyringController.walletNicknames).reduce((identities, address) => {
    identities[address] = {
      name: state.KeyringController.walletNicknames[address],
      address
    };
    return identities;
  }, {});
  delete state.KeyringController.walletNicknames;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\026.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\027.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C027.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
// next version number
/*

normalizes txParams on unconfirmed txs

*/

const version = 27;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.filter(txMeta => txMeta.status !== _transaction.TransactionStatus.rejected);
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\027.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\028.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C028.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

normalizes txParams on unconfirmed txs

*/

const version = 28;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (newState.PreferencesController) {
    if (newState.PreferencesController.tokens && newState.PreferencesController.identities) {
      const {
        identities,
        tokens
      } = newState.PreferencesController;
      newState.PreferencesController.accountTokens = {};
      Object.keys(identities).forEach(identity => {
        newState.PreferencesController.accountTokens[identity] = {
          mainnet: tokens
        };
      });
      newState.PreferencesController.tokens = [];
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\028.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\029.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","./fail-tx":"F:\\metamask-extension\\app\\scripts\\migrations\\fail-tx.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C029.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _transaction = require("../../../shared/constants/transaction");
var _failTx = _interopRequireDefault(require("./fail-tx"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// next version number

const version = 29;

// time
const seconds = 1000;
const minutes = 60 * seconds;
const hours = 60 * minutes;
const unacceptableDelay = 12 * hours;

/*

normalizes txParams on unconfirmed txs

*/
var _default = {
  version,
  migrate: (0, _failTx.default)(version, 'Stuck in approved state for too long.', txMeta => {
    const isApproved = txMeta.status === _transaction.TransactionStatus.approved;
    const createdTime = txMeta.submittedTime;
    const now = Date.now();
    return isApproved && now - createdTime > unacceptableDelay;
  })
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\029.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\030.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C030.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

removes invalid chaids from preferences and networkController for custom rpcs

*/

const version = 30;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (state.PreferencesController) {
    const {
      frequentRpcListDetail
    } = newState.PreferencesController;
    if (frequentRpcListDetail) {
      frequentRpcListDetail.forEach((rpc, index) => {
        // eslint-disable-next-line radix
        if (Boolean(rpc.chainId) && Number.isNaN(parseInt(rpc.chainId))) {
          delete frequentRpcListDetail[index].chainId;
        }
      });
      newState.PreferencesController.frequentRpcListDetail = frequentRpcListDetail;
    }
  }
  if (state.NetworkController) {
    if (newState.NetworkController.network &&
    // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.network))) {
      delete newState.NetworkController.network;
    }
    if (newState.NetworkController.provider && newState.NetworkController.provider.chainId &&
    // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.provider.chainId))) {
      delete newState.NetworkController.provider.chainId;
    }
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\030.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\031.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C031.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number

const version = 31;

/*
 * The purpose of this migration is to properly set the completedOnboarding flag based on the state
 * of the KeyringController.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    KeyringController,
    PreferencesController
  } = state;
  if (KeyringController && PreferencesController) {
    const {
      vault
    } = KeyringController;
    PreferencesController.completedOnboarding = Boolean(vault);
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\031.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\032.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C032.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 32;

/**
 * The purpose of this migration is to set the {@code completedUiMigration} flag based on the user's UI preferences
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const {
      betaUI
    } = PreferencesController.featureFlags || {};
    // Users who have been using the "beta" UI are considered to have completed the migration
    // as they'll see no difference in this version
    PreferencesController.completedUiMigration = betaUI;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\032.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\033.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C033.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

Cleans up notices and assocated notice controller code

*/

const version = 33;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  // transform state here
  if (state.NoticeController) {
    delete newState.NoticeController;
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\033.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\034.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C034.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 34;

/**
 * The purpose of this migration is to enable the {@code privacyMode} feature flag and set the user as being migrated
 * if it was {@code false}.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};
    if (!featureFlags.privacyMode && typeof PreferencesController.migratedPrivacyMode === 'undefined') {
      // Mark the state has being migrated and enable Privacy Mode
      PreferencesController.migratedPrivacyMode = true;
      featureFlags.privacyMode = true;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\034.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\035.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C035.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
// next version number
/*

Removes the deprecated 'seedWords' state

*/

const version = 35;
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    versionedData.data = transformState(versionedData.data);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.seedWords !== undefined) {
    delete state.PreferencesController.seedWords;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\035.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\036.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C036.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 36;

/**
 * The purpose of this migration is to remove the {@code privacyMode} feature flag.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};
    if (typeof featureFlags.privacyMode !== 'undefined') {
      delete featureFlags.privacyMode;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\036.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\037.js", {"@metamask/controller-utils":"F:\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C037.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _controllerUtils = require("@metamask/controller-utils");
const version = 37;

/**
 * The purpose of this migration is to update the address book state
 * to the new schema with chainId as a key.
 * and to add the isEns flag to all entries
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.AddressBookController) {
    const ab = state.AddressBookController.addressBook;
    const chainIds = new Set();
    const newAddressBook = {};

    // add all of the chainIds to a set
    Object.values(ab).forEach(v => {
      chainIds.add(v.chainId);
    });

    // fill the chainId object with the entries with the matching chainId
    for (const id of chainIds.values()) {
      // make an empty object entry for each chainId
      newAddressBook[id] = {};
      for (const address in ab) {
        if (ab[address].chainId === id) {
          ab[address].isEns = false;
          if ((0, _controllerUtils.normalizeEnsName)(ab[address].name)) {
            ab[address].isEns = true;
          }
          newAddressBook[id][address] = ab[address];
        }
      }
    }
    state.AddressBookController.addressBook = newAddressBook;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\037.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\038.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C038.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 38;

/**
 * The purpose of this migration is to assign all users to a test group for the fullScreenVsPopup a/b test
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    ABTestController: ABTestControllerState = {}
  } = state;
  const {
    abTests = {}
  } = ABTestControllerState;
  if (abTests.fullScreenVsPopup) {
    return state;
  }
  return {
    ...state,
    ABTestController: {
      ...ABTestControllerState,
      abTests: {
        ...abTests,
        fullScreenVsPopup: 'control'
      }
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\038.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\039.js", {"../../../shared/modules/hexstring-utils":"F:\\metamask-extension\\shared\\modules\\hexstring-utils.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C039.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _hexstringUtils = require("../../../shared/modules/hexstring-utils");
const version = 39;
const DAI_V1_CONTRACT_ADDRESS = '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359';
const DAI_V1_TOKEN_SYMBOL = 'DAI';
const SAI_TOKEN_SYMBOL = 'SAI';
function isOldDai(token = {}) {
  return token && typeof token === 'object' && token.symbol === DAI_V1_TOKEN_SYMBOL && (0, _hexstringUtils.toChecksumHexAddress)(token.address) === DAI_V1_CONTRACT_ADDRESS;
}

/**
 * This migration renames the Dai token to Sai.
 *
 * As of 2019-11-18 Dai is now called Sai (refs https://git.io/JeooP) to facilitate
 * Maker's upgrade to Multi-Collateral Dai and this migration renames the token
 * at the old address.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PreferencesController
  } = state;
  if (PreferencesController) {
    const tokens = PreferencesController.tokens || [];
    if (Array.isArray(tokens)) {
      for (const token of tokens) {
        if (isOldDai(token)) {
          token.symbol = SAI_TOKEN_SYMBOL;
        }
      }
    }
    const accountTokens = PreferencesController.accountTokens || {};
    if (accountTokens && typeof accountTokens === 'object') {
      for (const address of Object.keys(accountTokens)) {
        const networkTokens = accountTokens[address];
        if (networkTokens && typeof networkTokens === 'object') {
          for (const network of Object.keys(networkTokens)) {
            const tokensOnNetwork = networkTokens[network];
            if (Array.isArray(tokensOnNetwork)) {
              for (const token of tokensOnNetwork) {
                if (isOldDai(token)) {
                  token.symbol = SAI_TOKEN_SYMBOL;
                }
              }
            }
          }
        }
      }
    }
  }
  return state;
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\039.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\040.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C040.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 40;

/**
 * Site connections are now managed by the PermissionsController, and the
 * ProviderApprovalController is removed. This migration deletes all
 * ProviderApprovalController state.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  delete state.ProviderApprovalController;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\040.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\041.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C041.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 41;

/**
 * PreferencesController.autoLogoutTimeLimit -> autoLockTimeLimit
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.preferences) {
    state.PreferencesController.preferences.autoLockTimeLimit = state.PreferencesController.preferences.autoLogoutTimeLimit;
    delete state.PreferencesController.preferences.autoLogoutTimeLimit;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\041.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\042.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C042.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 42;

/**
 * Initialize `connectedStatusPopoverHasBeenShown` to `false` if it hasn't yet been set,
 * so that existing users are introduced to the new connected status indicator
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.AppStateController) {
    state.AppStateController.connectedStatusPopoverHasBeenShown = false;
  } else {
    state.AppStateController = {
      connectedStatusPopoverHasBeenShown: false
    };
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\042.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\043.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C043.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 43;

/**
 * Remove unused 'currentAccountTab' state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon;
  if (state !== null && state !== void 0 && (_state$PreferencesCon = state.PreferencesController) !== null && _state$PreferencesCon !== void 0 && _state$PreferencesCon.currentAccountTab) {
    delete state.PreferencesController.currentAccountTab;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\043.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\044.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C044.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 44;

/**
 * Remove unused 'mkrMigrationReminderTimestamp' state from the `AppStateController`
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$AppStateContro;
  if (typeof (state === null || state === void 0 ? void 0 : (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? void 0 : _state$AppStateContro.mkrMigrationReminderTimestamp) !== 'undefined') {
    delete state.AppStateController.mkrMigrationReminderTimestamp;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\044.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\045.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C045.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 45;

/**
 * Replaces {@code PreferencesController.ipfsGateway} with 'dweb.link' if set
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
const outdatedGateways = ['ipfs.io', 'ipfs.dweb.link'];
function transformState(state) {
  var _state$PreferencesCon;
  if (outdatedGateways.includes(state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.ipfsGateway)) {
    state.PreferencesController.ipfsGateway = 'dweb.link';
  }
  return state;
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\045.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\046.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C046.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 46;

/**
 * Delete {@code ABTestController} state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (typeof (state === null || state === void 0 ? void 0 : state.ABTestController) !== 'undefined') {
    delete state.ABTestController;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\046.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\047.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C047.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 47;

/**
 * Stringify the `metamaskNetworkId` property of all transactions
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (typeof transaction.metamaskNetworkId === 'number') {
        transaction.metamaskNetworkId = transaction.metamaskNetworkId.toString();
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\047.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\048.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C048.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 48;

/**
 * 1.  Delete NetworkController.settings
 * 2a. Migrate NetworkController.provider to Rinkeby if set to type 'rpc' or
 *     'localhost'.
 * 2b. Re-key provider.rpcTarget to provider.rpcUrl
 * 3.  Add localhost network to frequentRpcListDetail.
 * 4.  Delete CachedBalancesController.cachedBalances
 * 5.  Convert transactions metamaskNetworkId to decimal if they are hex
 * 6.  Convert address book keys from decimal to hex
 * 7.  Delete localhost key in IncomingTransactionsController
 * 8.  Merge 'localhost' tokens into 'rpc' tokens
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
const hexRegEx = /^0x[0-9a-f]+$/iu;
const chainIdRegEx = /^0x[1-9a-f]+[0-9a-f]*$/iu;
function transformState(state = {}) {
  var _state$NetworkControl, _state$NetworkControl2, _state$NetworkControl3, _state$CachedBalances, _state$TransactionCon, _state$AddressBookCon, _state$IncomingTransa, _state$IncomingTransa2, _state$PreferencesCon;
  // 1. Delete NetworkController.settings
  (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? true : delete _state$NetworkControl.settings;

  // 2. Migrate NetworkController.provider to Rinkeby or rename rpcTarget key
  const provider = ((_state$NetworkControl2 = state.NetworkController) === null || _state$NetworkControl2 === void 0 ? void 0 : _state$NetworkControl2.provider) || {};
  const isCustomRpcWithInvalidChainId = provider.type === 'rpc' && (typeof provider.chainId !== 'string' || !chainIdRegEx.test(provider.chainId));
  if (isCustomRpcWithInvalidChainId || provider.type === 'localhost') {
    state.NetworkController.provider = {
      type: 'rinkeby',
      rpcUrl: '',
      chainId: '0x4',
      nickname: '',
      rpcPrefs: {},
      ticker: 'ETH'
    };
  } else if ((_state$NetworkControl3 = state.NetworkController) !== null && _state$NetworkControl3 !== void 0 && _state$NetworkControl3.provider) {
    var _state$NetworkControl4, _state$NetworkControl5;
    if ('rpcTarget' in state.NetworkController.provider) {
      const rpcUrl = state.NetworkController.provider.rpcTarget;
      state.NetworkController.provider.rpcUrl = rpcUrl;
    }
    (_state$NetworkControl4 = state.NetworkController) === null || _state$NetworkControl4 === void 0 ? true : (_state$NetworkControl5 = _state$NetworkControl4.provider) === null || _state$NetworkControl5 === void 0 ? true : delete _state$NetworkControl5.rpcTarget;
  }

  // 3.  Add localhost network to frequentRpcListDetail.
  if (!state.PreferencesController) {
    state.PreferencesController = {};
  }
  if (!state.PreferencesController.frequentRpcListDetail) {
    state.PreferencesController.frequentRpcListDetail = [];
  }
  state.PreferencesController.frequentRpcListDetail.unshift({
    rpcUrl: 'http://localhost:8545',
    chainId: '0x539',
    ticker: 'ETH',
    nickname: 'Localhost 8545',
    rpcPrefs: {}
  });

  // 4.  Delete CachedBalancesController.cachedBalances
  (_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? true : delete _state$CachedBalances.cachedBalances;

  // 5.  Convert transactions metamaskNetworkId to decimal if they are hex
  const transactions = (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      const metamaskNetworkId = transaction === null || transaction === void 0 ? void 0 : transaction.metamaskNetworkId;
      if (typeof metamaskNetworkId === 'string' && hexRegEx.test(metamaskNetworkId)) {
        transaction.metamaskNetworkId = parseInt(metamaskNetworkId, 16).toString(10);
      }
    });
  }

  // 6.  Convert address book keys from decimal to hex
  const addressBook = ((_state$AddressBookCon = state.AddressBookController) === null || _state$AddressBookCon === void 0 ? void 0 : _state$AddressBookCon.addressBook) || {};
  Object.keys(addressBook).forEach(networkKey => {
    if (/^\d+$/iu.test(networkKey)) {
      const chainId = `0x${parseInt(networkKey, 10).toString(16)}`;
      updateChainIds(addressBook[networkKey], chainId);
      if (addressBook[chainId]) {
        mergeAddressBookKeys(addressBook, networkKey, chainId);
      } else {
        addressBook[chainId] = addressBook[networkKey];
      }
      delete addressBook[networkKey];
    }
  });

  // 7.  Delete localhost key in IncomingTransactionsController
  (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? true : (_state$IncomingTransa2 = _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) === null || _state$IncomingTransa2 === void 0 ? true : delete _state$IncomingTransa2.localhost;

  // 8.  Merge 'localhost' tokens into 'rpc' tokens
  const accountTokens = (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;
  if (accountTokens) {
    Object.keys(accountTokens).forEach(account => {
      var _accountTokens$accoun, _accountTokens$accoun2;
      const localhostTokens = ((_accountTokens$accoun = accountTokens[account]) === null || _accountTokens$accoun === void 0 ? void 0 : _accountTokens$accoun.localhost) || [];
      if (localhostTokens.length > 0) {
        const rpcTokens = accountTokens[account].rpc || [];
        if (rpcTokens.length > 0) {
          accountTokens[account].rpc = mergeTokenArrays(localhostTokens, rpcTokens);
        } else {
          accountTokens[account].rpc = localhostTokens;
        }
      }
      (_accountTokens$accoun2 = accountTokens[account]) === null || _accountTokens$accoun2 === void 0 ? true : delete _accountTokens$accoun2.localhost;
    });
  }
  return state;
}

/**
 * Merges the two given keys for the given address book in place.
 *
 * @param addressBook
 * @param networkKey
 * @param chainIdKey
 */
function mergeAddressBookKeys(addressBook, networkKey, chainIdKey) {
  const networkKeyEntries = addressBook[networkKey] || {};
  // For the new entries, start by copying the existing entries for the chainId
  const newEntries = {
    ...addressBook[chainIdKey]
  };

  // For each address of the old/networkId key entries
  Object.keys(networkKeyEntries).forEach(address => {
    if (newEntries[address] && typeof newEntries[address] === 'object') {
      const mergedEntry = {};

      // Collect all keys from both entries and merge the corresponding chainId
      // entry with the networkId entry
      new Set([...Object.keys(newEntries[address]), ...Object.keys(networkKeyEntries[address] || {})]).forEach(key => {
        var _networkKeyEntries$ad;
        // Use non-empty value for the current key, if any
        mergedEntry[key] = newEntries[address][key] || ((_networkKeyEntries$ad = networkKeyEntries[address]) === null || _networkKeyEntries$ad === void 0 ? void 0 : _networkKeyEntries$ad[key]) || '';
      });
      newEntries[address] = mergedEntry;
    } else if (networkKeyEntries[address] && typeof networkKeyEntries[address] === 'object') {
      // If there is no corresponding chainId entry, just use the networkId entry
      // directly
      newEntries[address] = networkKeyEntries[address];
    }
  });
  addressBook[chainIdKey] = newEntries;
}

/**
 * Updates the chainId key values to the given chainId in place for all values
 * of the given networkEntries object.
 *
 * @param networkEntries
 * @param chainId
 */
function updateChainIds(networkEntries, chainId) {
  Object.values(networkEntries).forEach(entry => {
    if (entry && typeof entry === 'object') {
      entry.chainId = chainId;
    }
  });
}

/**
 * Merges the two given, non-empty arrays of token objects and returns a new
 * array.
 *
 * @param localhostTokens
 * @param rpcTokens
 * @returns {Array<object>}
 */
function mergeTokenArrays(localhostTokens, rpcTokens) {
  const localhostTokensMap = tokenArrayToMap(localhostTokens);
  const rpcTokensMap = tokenArrayToMap(rpcTokens);
  const mergedTokens = [];
  new Set([...Object.keys(localhostTokensMap), ...Object.keys(rpcTokensMap)]).forEach(tokenAddress => {
    mergedTokens.push({
      ...localhostTokensMap[tokenAddress],
      ...rpcTokensMap[tokenAddress]
    });
  });
  return mergedTokens;
  function tokenArrayToMap(array) {
    return array.reduce((map, token) => {
      if (token !== null && token !== void 0 && token.address && typeof (token === null || token === void 0 ? void 0 : token.address) === 'string') {
        map[token.address] = token;
      }
      return map;
    }, {});
  }
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\048.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\049.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C049.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 49;

/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state = {}) {
  if (state.PreferencesController) {
    const {
      metaMetricsId,
      participateInMetaMetrics,
      metaMetricsSendCount
    } = state.PreferencesController;
    state.MetaMetricsController = state.MetaMetricsController ?? {};
    if (metaMetricsId !== undefined) {
      state.MetaMetricsController.metaMetricsId = metaMetricsId;
      delete state.PreferencesController.metaMetricsId;
    }
    if (participateInMetaMetrics !== undefined) {
      state.MetaMetricsController.participateInMetaMetrics = participateInMetaMetrics;
      delete state.PreferencesController.participateInMetaMetrics;
    }
    if (metaMetricsSendCount !== undefined) {
      state.MetaMetricsController.metaMetricsSendCount = metaMetricsSendCount;
      delete state.PreferencesController.metaMetricsSendCount;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\049.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\050.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C050.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 50;
const LEGACY_LOCAL_STORAGE_KEYS = ['METASWAP_GAS_PRICE_ESTIMATES_LAST_RETRIEVED', 'METASWAP_GAS_PRICE_ESTIMATES', 'cachedFetch', 'BASIC_PRICE_ESTIMATES_LAST_RETRIEVED', 'BASIC_PRICE_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES'];

/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    LEGACY_LOCAL_STORAGE_KEYS.forEach(key => {
      var _window$localStorage;
      return (_window$localStorage = window.localStorage) === null || _window$localStorage === void 0 ? void 0 : _window$localStorage.removeItem(key);
    });
    return versionedData;
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\050.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\051.js", {"../../../shared/constants/network":"F:\\metamask-extension\\shared\\constants\\network.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C051.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _network = require("../../../shared/constants/network");
const version = 51;

/**
 * Set the chainId in the Network Controller provider data for all infura networks
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$NetworkControl, _BUILT_IN_NETWORKS$ty;
  const {
    chainId,
    type
  } = (state === null || state === void 0 ? void 0 : (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const enumChainId = (_BUILT_IN_NETWORKS$ty = _network.BUILT_IN_NETWORKS[type]) === null || _BUILT_IN_NETWORKS$ty === void 0 ? void 0 : _BUILT_IN_NETWORKS$ty.chainId;
  if (enumChainId && chainId !== enumChainId) {
    state.NetworkController.provider.chainId = enumChainId;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\051.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\052.js", {"../../../shared/constants/network":"F:\\metamask-extension\\shared\\constants\\network.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C052.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _network = require("../../../shared/constants/network");
const version = 52;

/**
 * Migrate tokens in Preferences to be keyed by chainId instead of
 * providerType. To prevent breaking user's MetaMask and selected
 * tokens, this migration copies the RPC entry into *every* custom RPC
 * chainId.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state = {}) {
  if (state.PreferencesController) {
    const {
      accountTokens,
      accountHiddenTokens,
      frequentRpcListDetail
    } = state.PreferencesController;
    const newAccountTokens = {};
    const newAccountHiddenTokens = {};
    if (accountTokens && Object.keys(accountTokens).length > 0) {
      for (const address of Object.keys(accountTokens)) {
        newAccountTokens[address] = {};
        if (accountTokens[address][_network.NETWORK_TYPES.RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountTokens[address][detail.chainId] = accountTokens[address][_network.NETWORK_TYPES.RPC];
          });
        }
        for (const providerType of Object.keys(accountTokens[address])) {
          switch (providerType) {
            case _network.NETWORK_TYPES.MAINNET:
              newAccountTokens[address][_network.CHAIN_IDS.MAINNET] = accountTokens[address][_network.NETWORK_TYPES.MAINNET];
              break;
            case 'ropsten':
              newAccountTokens[address]['0x3'] = accountTokens[address].ropsten;
              break;
            case 'rinkeby':
              newAccountTokens[address]['0x4'] = accountTokens[address].rinkeby;
              break;
            case _network.NETWORK_TYPES.GOERLI:
              newAccountTokens[address][_network.CHAIN_IDS.GOERLI] = accountTokens[address][_network.NETWORK_TYPES.GOERLI];
              break;
            case 'kovan':
              newAccountTokens[address]['0x2a'] = accountTokens[address].kovan;
              break;
            default:
              break;
          }
        }
      }
      state.PreferencesController.accountTokens = newAccountTokens;
    }
    if (accountHiddenTokens && Object.keys(accountHiddenTokens).length > 0) {
      for (const address of Object.keys(accountHiddenTokens)) {
        newAccountHiddenTokens[address] = {};
        if (accountHiddenTokens[address][_network.NETWORK_TYPES.RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountHiddenTokens[address][detail.chainId] = accountHiddenTokens[address][_network.NETWORK_TYPES.RPC];
          });
        }
        for (const providerType of Object.keys(accountHiddenTokens[address])) {
          switch (providerType) {
            case _network.NETWORK_TYPES.MAINNET:
              newAccountHiddenTokens[address][_network.CHAIN_IDS.MAINNET] = accountHiddenTokens[address][_network.NETWORK_TYPES.MAINNET];
              break;
            case 'ropsten':
              newAccountHiddenTokens[address]['0x3'] = accountHiddenTokens[address].ropsten;
              break;
            case 'rinkeby':
              newAccountHiddenTokens[address]['0x4'] = accountHiddenTokens[address].rinkeby;
              break;
            case _network.NETWORK_TYPES.GOERLI:
              newAccountHiddenTokens[address][_network.CHAIN_IDS.GOERLI] = accountHiddenTokens[address][_network.NETWORK_TYPES.GOERLI];
              break;
            case 'kovan':
              newAccountHiddenTokens[address]['0x2a'] = accountHiddenTokens[address].kovan;
              break;
            default:
              break;
          }
        }
      }
      state.PreferencesController.accountHiddenTokens = newAccountHiddenTokens;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\052.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\053.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C053.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
const version = 53;

/**
 * Deprecate transactionCategory and consolidate on 'type'
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon, _state$IncomingTransa;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  const incomingTransactions = state === null || state === void 0 ? void 0 : (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? void 0 : _state$IncomingTransa.incomingTransactions;
  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (transaction) {
        if (transaction.type !== _transaction.TransactionType.retry && transaction.type !== _transaction.TransactionType.cancel) {
          transaction.type = transaction.transactionCategory;
        }
        delete transaction.transactionCategory;
      }
    });
  }
  if (incomingTransactions) {
    const incomingTransactionsEntries = Object.entries(incomingTransactions);
    incomingTransactionsEntries.forEach(([key, transaction]) => {
      if (transaction) {
        delete transaction.transactionCategory;
        state.IncomingTransactionsController.incomingTransactions[key] = {
          ...transaction,
          type: _transaction.TransactionType.incoming
        };
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\053.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\054.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C054.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 54;
function isValidDecimals(decimals) {
  return typeof decimals === 'number' || typeof decimals === 'string' && decimals.match(/^(0x)?\d+$/u);
}

/**
 * Migrates preference tokens with decimals typed as string to number.
 * It also removes any tokens with corrupted or inconvertible decimal values.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const newState = state;
  if (!newState.PreferencesController) {
    return newState;
  }
  const tokens = newState.PreferencesController.tokens || [];
  // Filter out any tokens with corrupted decimal values
  const validTokens = tokens.filter(({
    decimals
  }) => isValidDecimals(decimals));
  for (const token of validTokens) {
    // In the case of a decimal value type string, convert to a number.
    if (typeof token.decimals === 'string') {
      // eslint-disable-next-line radix
      token.decimals = parseInt(token.decimals);
    }
  }
  newState.PreferencesController.tokens = validTokens;
  const {
    accountTokens
  } = newState.PreferencesController;
  if (accountTokens && typeof accountTokens === 'object') {
    for (const address of Object.keys(accountTokens)) {
      const networkTokens = accountTokens[address];
      if (networkTokens && typeof networkTokens === 'object') {
        for (const network of Object.keys(networkTokens)) {
          const tokensOnNetwork = networkTokens[network] || [];
          // Filter out any tokens with corrupted decimal values
          const validTokensOnNetwork = tokensOnNetwork.filter(({
            decimals
          }) => isValidDecimals(decimals));
          // In the case of a decimal value type string, convert to a number.
          for (const token of validTokensOnNetwork) {
            if (typeof token.decimals === 'string') {
              // eslint-disable-next-line radix
              token.decimals = parseInt(token.decimals);
            }
          }
          networkTokens[network] = validTokensOnNetwork;
        }
      }
    }
  }
  newState.PreferencesController.accountTokens = accountTokens;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\054.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\055.js", {"../../../shared/constants/network":"F:\\metamask-extension\\shared\\constants\\network.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C055.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _network = require("../../../shared/constants/network");
const version = 55;

/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
const UNKNOWN_CHAIN_ID_KEY = 'UNKNOWN';
_network.BUILT_IN_NETWORKS.rinkeby = {
  networkId: '4',
  chainId: '0x4',
  ticker: 'ETH'
};
_network.BUILT_IN_NETWORKS.ropsten = {
  networkId: '3',
  chainId: '0x3',
  ticker: 'ETH'
};
_network.BUILT_IN_NETWORKS.kovan = {
  networkId: '42',
  chainId: '0x2a',
  ticker: 'ETH'
};
function transformState(state) {
  var _state$IncomingTransa;
  if (state !== null && state !== void 0 && (_state$IncomingTransa = state.IncomingTransactionsController) !== null && _state$IncomingTransa !== void 0 && _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) {
    state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId = (0, _lodash.mapKeys)(state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork,
    // using optional chaining in case user's state has fetched blocks for
    // RPC network types (which don't map to a single chainId). This should
    // not be possible, but it's safer
    (_, key) => {
      var _BUILT_IN_NETWORKS$ke;
      return ((_BUILT_IN_NETWORKS$ke = _network.BUILT_IN_NETWORKS[key]) === null || _BUILT_IN_NETWORKS$ke === void 0 ? void 0 : _BUILT_IN_NETWORKS$ke.chainId) ?? UNKNOWN_CHAIN_ID_KEY;
    });
    // Now that mainnet and test net last fetched blocks are keyed by their
    // respective chainIds, we can safely delete anything we had for custom
    // networks. Any custom network that shares a chainId with one of the
    // aforementioned networks will use the value stored by chainId.
    delete state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId[UNKNOWN_CHAIN_ID_KEY];
    delete state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\055.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\056.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C056.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 56;

/**
 * Remove tokens that don't have an address due to
 * lack of previous addToken validation.  Also removes
 * an unwanted, undefined image property
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const {
      PreferencesController
    } = versionedData.data;
    if (Array.isArray(PreferencesController === null || PreferencesController === void 0 ? void 0 : PreferencesController.tokens)) {
      PreferencesController.tokens = PreferencesController.tokens.filter(({
        address
      }) => address);
    }
    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.accountTokens && typeof PreferencesController.accountTokens === 'object') {
      Object.keys(PreferencesController.accountTokens).forEach(account => {
        const chains = Object.keys(PreferencesController.accountTokens[account]);
        chains.forEach(chain => {
          PreferencesController.accountTokens[account][chain] = PreferencesController.accountTokens[account][chain].filter(({
            address
          }) => address);
        });
      });
    }
    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.assetImages && 'undefined' in PreferencesController.assetImages) {
      delete PreferencesController.assetImages.undefined;
    }
    return versionedData;
  }
};
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\056.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\057.js", {"../../../shared/modules/random-id":"F:\\metamask-extension\\shared\\modules\\random-id.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C057.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const version = 57;

/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  if (state !== null && state !== void 0 && (_state$TransactionCon = state.TransactionController) !== null && _state$TransactionCon !== void 0 && _state$TransactionCon.transactions && Array.isArray(state.TransactionController.transactions) && !state.TransactionController.transactions.some(item => typeof item !== 'object' || typeof item.txParams === 'undefined')) {
    state.TransactionController.transactions = (0, _lodash.keyBy)(state.TransactionController.transactions,
    // In case for some reason any of a user's transactions do not have an id
    // generate a new one for the transaction.
    tx => {
      if (typeof tx.id === 'undefined' || tx.id === null) {
        // This mutates the item in the array, so will result in a change to
        // the state.
        tx.id = (0, _randomId.default)();
      }
      return tx.id;
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\057.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\058.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C058.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 58;

/**
 * Deletes the swapsWelcomeMessageHasBeenShown property from state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$AppStateContro;
  (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? true : delete _state$AppStateContro.swapsWelcomeMessageHasBeenShown;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\058.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\059.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C059.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
const version = 59;

/**
 * Removes orphaned cancel and retry transactions that no longer have the
 * original transaction in state, which results in bugs.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if ((0, _lodash.isPlainObject)(transactions)) {
    const nonceNetworkGroupedObject = (0, _lodash.groupBy)(Object.values(transactions), tx => {
      var _tx$txParams;
      return `${(_tx$txParams = tx.txParams) === null || _tx$txParams === void 0 ? void 0 : _tx$txParams.nonce}-${tx.chainId ?? tx.metamaskNetworkId}`;
    });
    const withoutOrphans = (0, _lodash.pickBy)(nonceNetworkGroupedObject, group => {
      return group.some(tx => tx.type !== _transaction.TransactionType.cancel && tx.type !== _transaction.TransactionType.retry);
    });
    state.TransactionController.transactions = (0, _lodash.keyBy)((0, _lodash.concat)(...Object.values(withoutOrphans)), tx => tx.id);
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\059.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\060.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C060.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 60;
const SUPPORT_NOTIFICATION_KEY = 2;
const SUPPORT_NOTIFICATION_DATE = '2020-08-31';

/**
 * Removes the support survey notification
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$NotificationCo;
  const notifications = state === null || state === void 0 ? void 0 : (_state$NotificationCo = state.NotificationController) === null || _state$NotificationCo === void 0 ? void 0 : _state$NotificationCo.notifications;
  if ((0, _lodash.isPlainObject)(notifications)) {
    var _notifications$SUPPOR;
    if (((_notifications$SUPPOR = notifications[SUPPORT_NOTIFICATION_KEY]) === null || _notifications$SUPPOR === void 0 ? void 0 : _notifications$SUPPOR.date) === SUPPORT_NOTIFICATION_DATE) {
      delete state.NotificationController.notifications[SUPPORT_NOTIFICATION_KEY];
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\060.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\061.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C061.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 61;

/**
 * Initialize attributes related to recovery seed phrase reminder
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const currentTime = new Date().getTime();
  if (state.AppStateController) {
    state.AppStateController.recoveryPhraseReminderHasBeenShown = false;
    state.AppStateController.recoveryPhraseReminderLastShown = currentTime;
  } else {
    state.AppStateController = {
      recoveryPhraseReminderHasBeenShown: false,
      recoveryPhraseReminderLastShown: currentTime
    };
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\061.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\062.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C062.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 62;

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.MetaMetricsController) {
    const {
      metaMetricsSendCount
    } = state.MetaMetricsController;
    if (metaMetricsSendCount !== undefined) {
      delete state.MetaMetricsController.metaMetricsSendCount;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\062.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\063.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C063.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 63;

/**
 * Moves token state from preferences controller to TokensController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon, _state$PreferencesCon2, _state$PreferencesCon3, _state$PreferencesCon4, _state$PreferencesCon5, _state$PreferencesCon6, _state$PreferencesCon7, _state$PreferencesCon8;
  const accountTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;
  const accountHiddenTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon2 = state.PreferencesController) === null || _state$PreferencesCon2 === void 0 ? void 0 : _state$PreferencesCon2.accountHiddenTokens;
  const newAllTokens = {};
  if (accountTokens) {
    Object.keys(accountTokens).forEach(accountAddress => {
      Object.keys(accountTokens[accountAddress]).forEach(chainId => {
        const tokensArray = accountTokens[accountAddress][chainId];
        if (newAllTokens[chainId] === undefined) {
          newAllTokens[chainId] = {
            [accountAddress]: tokensArray
          };
        } else {
          newAllTokens[chainId] = {
            ...newAllTokens[chainId],
            [accountAddress]: tokensArray
          };
        }
      });
    });
  }
  const newAllIgnoredTokens = {};
  if (accountHiddenTokens) {
    Object.keys(accountHiddenTokens).forEach(accountAddress => {
      Object.keys(accountHiddenTokens[accountAddress]).forEach(chainId => {
        const ignoredTokensArray = accountHiddenTokens[accountAddress][chainId];
        if (newAllIgnoredTokens[chainId] === undefined) {
          newAllIgnoredTokens[chainId] = {
            [accountAddress]: ignoredTokensArray
          };
        } else {
          newAllIgnoredTokens[chainId] = {
            ...newAllIgnoredTokens[chainId],
            [accountAddress]: ignoredTokensArray
          };
        }
      });
    });
  }
  if (state.TokensController) {
    state.TokensController.allTokens = newAllTokens;
    state.TokensController.allIgnoredTokens = newAllIgnoredTokens;
  } else {
    state.TokensController = {
      allTokens: newAllTokens,
      allIgnoredTokens: newAllIgnoredTokens
    };
  }
  state === null || state === void 0 ? true : (_state$PreferencesCon3 = state.PreferencesController) === null || _state$PreferencesCon3 === void 0 ? true : delete _state$PreferencesCon3.accountHiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon4 = state.PreferencesController) === null || _state$PreferencesCon4 === void 0 ? true : delete _state$PreferencesCon4.accountTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon5 = state.PreferencesController) === null || _state$PreferencesCon5 === void 0 ? true : delete _state$PreferencesCon5.assetImages;
  state === null || state === void 0 ? true : (_state$PreferencesCon6 = state.PreferencesController) === null || _state$PreferencesCon6 === void 0 ? true : delete _state$PreferencesCon6.hiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon7 = state.PreferencesController) === null || _state$PreferencesCon7 === void 0 ? true : delete _state$PreferencesCon7.tokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon8 = state.PreferencesController) === null || _state$PreferencesCon8 === void 0 ? true : delete _state$PreferencesCon8.suggestedTokens;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\063.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\064.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C064.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
const version = 64;
const SENT_ETHER = 'sentEther'; // the legacy transaction type being replaced in this migration with TransactionType.simpleSend

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon;
  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  if ((0, _lodash.isPlainObject)(transactions)) {
    for (const tx of Object.values(transactions)) {
      if (tx.type === SENT_ETHER) {
        tx.type = _transaction.TransactionType.simpleSend;
      }
      if (tx.history) {
        tx.history.map(txEvent => {
          if (txEvent.type && txEvent.type === SENT_ETHER) {
            txEvent.type = _transaction.TransactionType.simpleSend;
          }
          return txEvent;
        });
      }
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\064.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\065.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C065.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 65;

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.PreferencesController) {
    const {
      completedOnboarding,
      firstTimeFlowType
    } = state.PreferencesController;
    state.OnboardingController = state.OnboardingController ?? {};
    if (completedOnboarding !== undefined) {
      state.OnboardingController.completedOnboarding = completedOnboarding;
      delete state.PreferencesController.completedOnboarding;
    }
    if (firstTimeFlowType !== undefined) {
      state.OnboardingController.firstTimeFlowType = firstTimeFlowType;
      delete state.PreferencesController.firstTimeFlowType;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\065.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\066.js", {"../../../shared/constants/hardware-wallets":"F:\\metamask-extension\\shared\\constants\\hardware-wallets.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C066.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _hardwareWallets = require("../../../shared/constants/hardware-wallets");
const version = 66;

/**
 * Changes the useLedgerLive boolean property to the ledgerTransportType enum
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon;
  const defaultTransportType = window.navigator.hid ? _hardwareWallets.LedgerTransportTypes.webhid : _hardwareWallets.LedgerTransportTypes.u2f;
  const useLedgerLive = Boolean((_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.useLedgerLive);
  const newState = {
    ...state,
    PreferencesController: {
      ...(state === null || state === void 0 ? void 0 : state.PreferencesController),
      ledgerTransportType: useLedgerLive ? _hardwareWallets.LedgerTransportTypes.live : defaultTransportType
    }
  };
  delete newState.PreferencesController.useLedgerLive;
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\066.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\067.js", {"../../../shared/constants/network":"F:\\metamask-extension\\shared\\constants\\network.ts","bignumber.js":"F:\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C067.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _network = require("../../../shared/constants/network");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const hexNumberIsGreaterThanZero = hexNumber => new _bignumber.default(hexNumber || '0x0', 16).gt(0);
const version = 67;

/**
 * Sets the showTestNetworks property to true if it was false or undefined, and there is evidence
 * that the user has used a test net
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon, _state$NetworkControl, _state$CachedBalances;
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  const preferences = PreferencesController.preferences || {};
  if (preferences.showTestNetworks) {
    return state;
  }
  const transactions = (state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions) || {};
  const provider = ((_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const cachedBalances = ((_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? void 0 : _state$CachedBalances.cachedBalances) || {};
  const userIsCurrentlyOnATestNet = _network.TEST_CHAINS.includes(provider === null || provider === void 0 ? void 0 : provider.chainId);
  const userHasMadeATestNetTransaction = Object.values(transactions).some(({
    chainId
  }) => _network.TEST_CHAINS.includes(chainId));
  const userHasACachedBalanceOnATestnet = _network.TEST_CHAINS.some(chainId => {
    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});
    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(hexNumberIsGreaterThanZero);
    return userHasABalanceGreaterThanZeroOnThisChain;
  });
  const userHasUsedATestnet = userIsCurrentlyOnATestNet || userHasMadeATestNetTransaction || userHasACachedBalanceOnATestnet;
  const newState = {
    ...state,
    PreferencesController: {
      ...PreferencesController,
      preferences: {
        ...preferences,
        showTestNetworks: userHasUsedATestnet
      }
    }
  };
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\067.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\068.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C068.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 68;

/**
 * Transforms the PermissionsController and PermissionsMetadata substates
 * to match the new permission system.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const {
    PermissionsController = {},
    PermissionsMetadata = {},
    ...remainingState
  } = state;
  const {
    domainMetadata = {},
    permissionsHistory = {},
    permissionsLog = []
  } = PermissionsMetadata;
  return {
    ...remainingState,
    PermissionController: getPermissionControllerState(PermissionsController),
    PermissionLogController: {
      permissionActivityLog: permissionsLog,
      permissionHistory: permissionsHistory
    },
    SubjectMetadataController: getSubjectMetadataControllerState(domainMetadata)
  };
}
function getPermissionControllerState(PermissionsController) {
  const {
    domains = {}
  } = PermissionsController;

  /**
   * Example existing domain entry. Every existing domain will have a single
   * eth_accounts permission, which simplifies the transform.
   *
   * 'https://metamask.github.io': {
   *   permissions: [
   *     {
   *       '@context': ['https://github.com/MetaMask/rpc-cap'],
   *       'caveats': [
   *         {
   *           name: 'primaryAccountOnly',
   *           type: 'limitResponseLength',
   *           value: 1,
   *         },
   *         {
   *           name: 'exposedAccounts',
   *           type: 'filterResponse',
   *           value: ['0x0c97a5c81e50a02ff8be73cc3f0a0569e61f4ed8'],
   *         },
   *       ],
   *       'date': 1616006369498,
   *       'id': '3d0bdc27-e8e4-4fb0-a24b-340d61f6a3fa',
   *       'invoker': 'https://metamask.github.io',
   *       'parentCapability': 'eth_accounts',
   *     },
   *   ],
   * },
   */

  const ETH_ACCOUNTS = 'eth_accounts';
  const NEW_CAVEAT_TYPE = 'restrictReturnedAccounts';
  const OLD_CAVEAT_NAME = 'exposedAccounts';
  const subjects = Object.entries(domains).reduce((transformed, [origin, domainEntry]) => {
    const {
      permissions: [ethAccountsPermission]
    } = domainEntry;

    // There are two caveats for each eth_accounts permission, but we only
    // need the value of one of them in the new permission system.
    const oldCaveat = ethAccountsPermission.caveats.find(caveat => caveat.name === OLD_CAVEAT_NAME);
    const newPermission = {
      ...ethAccountsPermission,
      caveats: [{
        type: NEW_CAVEAT_TYPE,
        value: oldCaveat.value
      }]
    };

    // We never used this, and just omit it in the new system.
    delete newPermission['@context'];
    transformed[origin] = {
      origin,
      permissions: {
        [ETH_ACCOUNTS]: newPermission
      }
    };
    return transformed;
  }, {});
  return {
    subjects
  };
}
function getSubjectMetadataControllerState(domainMetadata) {
  /**
   * Example existing domainMetadata entry.
   *
   * "https://www.youtube.com": {
   *   "host": "www.youtube.com",
   *   "icon": null,
   *   "lastUpdated": 1637697914908,
   *   "name": "YouTube"
   * }
   */

  const subjectMetadata = Object.entries(domainMetadata).reduce((transformed, [origin, metadata]) => {
    const {
      name = null,
      icon = null,
      extensionId = null,
      ...other
    } = metadata;

    // We're getting rid of these.
    delete other.lastUpdated;
    delete other.host;
    if (origin) {
      transformed[origin] = {
        name,
        iconUrl: icon,
        extensionId,
        ...other,
        origin
      };
    }
    return transformed;
  }, {});
  return {
    subjectMetadata
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\068.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\069.js", {"@metamask/subject-metadata-controller":"F:\\metamask-extension\\node_modules\\@metamask\\subject-metadata-controller\\dist\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C069.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _subjectMetadataController = require("@metamask/subject-metadata-controller");
var _lodash = require("lodash");
const version = 69;

/**
 * Adds the `subjectType` property to all subject metadata.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$SubjectMetadat;
  if (typeof (state === null || state === void 0 ? void 0 : (_state$SubjectMetadat = state.SubjectMetadataController) === null || _state$SubjectMetadat === void 0 ? void 0 : _state$SubjectMetadat.subjectMetadata) === 'object') {
    const {
      SubjectMetadataController: {
        subjectMetadata
      }
    } = state;

    // mutate SubjectMetadataController.subjectMetadata in place
    Object.values(subjectMetadata).forEach(metadata => {
      if (metadata && typeof metadata === 'object' && !Array.isArray(metadata)) {
        metadata.subjectType = metadata.extensionId ? _subjectMetadataController.SubjectType.Extension : _subjectMetadataController.SubjectType.Website;
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\069.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\070.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C070.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 70;

/**
 * Removes the `request` and `response` properties from
 * `PermissionLogController.permissionActivityLog` objects.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PermissionLogC;
  if (Array.isArray(state === null || state === void 0 ? void 0 : (_state$PermissionLogC = state.PermissionLogController) === null || _state$PermissionLogC === void 0 ? void 0 : _state$PermissionLogC.permissionActivityLog)) {
    const {
      PermissionLogController: {
        permissionActivityLog
      }
    } = state;

    // mutate activity log entries in place
    permissionActivityLog.forEach(logEntry => {
      if (logEntry && typeof logEntry === 'object' && !Array.isArray(logEntry)) {
        delete logEntry.request;
        delete logEntry.response;
      }
    });
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\070.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\071.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C071.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 71;

/**
 * Renames NotificationController to AnnouncementController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  if (state.NotificationController) {
    state.AnnouncementController = {
      announcements: state.NotificationController.notifications
    };
    delete state.NotificationController;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\071.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\072.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C072.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 72;

/**
 * Should empty the `knownMethodData` object in PreferencesController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  return {
    ...state,
    PreferencesController: {
      ...PreferencesController,
      knownMethodData: {}
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\072.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\073.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C073.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 73;

/**
 * Should empty the `knownMethodData` object in PreferencesController
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  return {
    ...state,
    PreferencesController: {
      ...PreferencesController,
      knownMethodData: {}
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\073.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\074.js", {"../../../shared/constants/network":"F:\\metamask-extension\\shared\\constants\\network.ts","bignumber.js":"F:\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C074.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
var _bignumber = _interopRequireDefault(require("bignumber.js"));
var _network = require("../../../shared/constants/network");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const version = 74;
const hexNumberIsGreaterThanZero = hexNumber => new _bignumber.default(hexNumber || '0x0', 16).gt(0);
const DEPRECATED_TEST_NET_CHAINIDS = ['0x3', '0x2a', '0x4'];
const DEPRECATED_TEST_NET_DETAILS = {
  '0x3': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'ropsten'
    }),
    nickname: 'Ropsten',
    ticker: 'RopstenETH'
  },
  '0x2a': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'kovan'
    }),
    nickname: 'Kovan',
    ticker: 'KovanETH'
  },
  '0x4': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'rinkeby'
    }),
    nickname: 'Rinkeby',
    ticker: 'RinkebyETH'
  }
};

/**
 * Migrates the user default but deprecated testnet networks to custom networks, and
 * if the current network is one such network, updates the network provider details so that it
 * will work as a custom rpc
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$TransactionCon, _state$CachedBalances;
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  const preferences = PreferencesController.preferences || {};
  const NetworkController = (state === null || state === void 0 ? void 0 : state.NetworkController) || {};
  const provider = (NetworkController === null || NetworkController === void 0 ? void 0 : NetworkController.provider) || {};
  const currentlyOnDeprecatedNetwork = DEPRECATED_TEST_NET_CHAINIDS.filter(chainId => chainId === (provider === null || provider === void 0 ? void 0 : provider.chainId));

  // If the user does not want to see test networks, and if the the user is not on a deprecated test network, then
  // no need to migrate the test network data to a custom network
  if (!preferences.showTestNetworks && currentlyOnDeprecatedNetwork.length === 0) {
    return state;
  }
  const transactions = (state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions) || {};
  const cachedBalances = ((_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? void 0 : _state$CachedBalances.cachedBalances) || {};
  const deprecatedTestnetsOnWhichTheUserHasMadeATransaction = Object.values(transactions).filter(({
    chainId
  }) => DEPRECATED_TEST_NET_CHAINIDS.includes(chainId)).map(({
    chainId
  }) => chainId);
  const deprecatedTestnetsOnWhichTheUserHasCachedBalance = DEPRECATED_TEST_NET_CHAINIDS.filter(chainId => {
    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});
    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(hexNumberIsGreaterThanZero);
    return userHasABalanceGreaterThanZeroOnThisChain;
  });
  const deprecatedTestnetsThatHaveBeenUsed = (0, _lodash.uniq)([...deprecatedTestnetsOnWhichTheUserHasCachedBalance, ...deprecatedTestnetsOnWhichTheUserHasMadeATransaction, ...currentlyOnDeprecatedNetwork]);
  const newFrequentRpcListDetail = PreferencesController.frequentRpcListDetail ?? [];
  deprecatedTestnetsThatHaveBeenUsed.forEach(chainId => {
    if (!newFrequentRpcListDetail.find(rpcDetails => rpcDetails.chainId === chainId)) {
      newFrequentRpcListDetail.unshift({
        rpcUrl: DEPRECATED_TEST_NET_DETAILS[chainId].rpcUrl,
        chainId,
        ticker: DEPRECATED_TEST_NET_DETAILS[chainId].ticker,
        nickname: DEPRECATED_TEST_NET_DETAILS[chainId].nickname,
        rpcPrefs: {}
      });
    }
  });
  if (newFrequentRpcListDetail.length) {
    PreferencesController.frequentRpcListDetail = newFrequentRpcListDetail;
  }
  if (currentlyOnDeprecatedNetwork.length) {
    const selectedNetworkChainId = currentlyOnDeprecatedNetwork[0];
    NetworkController.provider = {
      ...NetworkController.provider,
      type: 'rpc',
      rpcUrl: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].rpcUrl,
      chainId: selectedNetworkChainId,
      nickname: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].nickname,
      ticker: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].ticker
    };
  }
  return {
    ...state,
    PreferencesController: {
      ...PreferencesController
    },
    NetworkController: {
      ...NetworkController
    }
  };
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\074.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\075.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C075.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 75;

/**
 * Delete the ThreeBoxController.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  delete state.ThreeBoxController;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\075.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\076.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C076.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 76;

/**
 * Update to `@metamask/controllers@33.0.0` (rename "Collectible" to "NFT").
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$PreferencesCon;
  if (state.CollectiblesController) {
    const {
      allCollectibleContracts,
      allCollectibles,
      ignoredCollectibles,
      ...remainingState
    } = state.CollectiblesController;
    state.NftController = {
      ...(allCollectibleContracts ? {
        allNftContracts: allCollectibleContracts
      } : {}),
      ...(allCollectibles ? {
        allNfts: allCollectibles
      } : {}),
      ...(ignoredCollectibles ? {
        ignoredNfts: ignoredCollectibles
      } : {}),
      ...remainingState
    };
    delete state.CollectiblesController;
  }
  if ((_state$PreferencesCon = state.PreferencesController) !== null && _state$PreferencesCon !== void 0 && _state$PreferencesCon.useCollectibleDetection) {
    state.PreferencesController.useNftDetection = state.PreferencesController.useCollectibleDetection;
    delete state.PreferencesController.useCollectibleDetection;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\076.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\077.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C077.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 77;

/**
 * Prior to token detection v2 the data property in tokensChainsCache was an array,
 * in v2 we changes that to an object. In this migration we are converting the data as array to object.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  const TokenListController = (state === null || state === void 0 ? void 0 : state.TokenListController) || {};
  const {
    tokensChainsCache
  } = TokenListController;
  let dataCache;
  let dataObject;
  // eslint-disable-next-line
  for (const chainId in tokensChainsCache) {
    dataCache = tokensChainsCache[chainId].data;
    dataObject = {};
    // if the data is array conver that to object
    if (Array.isArray(dataCache)) {
      for (const token of dataCache) {
        dataObject[token.address] = token;
      }
    } else if (Object.keys(dataCache)[0].toLowerCase() !== dataCache[Object.keys(dataCache)[0]].address.toLowerCase()) {
      // for the users who already updated to the recent version
      // and the dataCache is already an object keyed with 0,1,2,3 etc
      // eslint-disable-next-line
      for (const tokenAddress in dataCache) {
        dataObject[dataCache[tokenAddress].address] = dataCache[tokenAddress];
      }
    }
    tokensChainsCache[chainId].data = Object.keys(dataObject).length > 0 ? dataObject : dataCache;
  }
  TokenListController.tokensChainsCache = tokensChainsCache;
  return {
    ...state,
    TokenListController: {
      ...TokenListController
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\077.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\078.ts", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C078.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 78;

/**
 * The`@metamask/phishing-controller` state was updated in v2.0.0.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'PhishingController') || !(0, _utils.isObject)(state.PhishingController)) {
    return state;
  }
  const {
    PhishingController
  } = state;
  delete PhishingController.phishing;
  delete PhishingController.lastFetched;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\078.ts",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\079.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C079.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 79;

/**
 * Remove collectiblesDropdownState and collectiblesDetectionNoticeDismissed:.
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$AppStateContro, _state$metamask;
  if ((state === null || state === void 0 ? void 0 : (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? void 0 : _state$AppStateContro.collectiblesDetectionNoticeDismissed) !== undefined) {
    delete state.AppStateController.collectiblesDetectionNoticeDismissed;
  }
  if ((state === null || state === void 0 ? void 0 : (_state$metamask = state.metamask) === null || _state$metamask === void 0 ? void 0 : _state$metamask.collectiblesDropdownState) !== undefined) {
    delete state.metamask.collectiblesDropdownState;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\079.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\080.js", {"lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C080.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _lodash = require("lodash");
const version = 80;

/**
 * The portfolio tooltip has been moved to a button on the home screen so
 * this property is no longer needed in state
 */
var _default = {
  version,
  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }
};
exports.default = _default;
function transformState(state) {
  var _state$metamask;
  if ((state === null || state === void 0 ? void 0 : (_state$metamask = state.metamask) === null || _state$metamask === void 0 ? void 0 : _state$metamask.showPortfolioTooltip) !== undefined) {
    delete state.metamask.showPortfolioTooltip;
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\080.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\081.ts", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C081.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 81;

/**
 * Prior to this migration, snap <> dapp permissions were wildcards i.e. `wallet_snap_*`.
 * Now the permission has been changed to `wallet_snap` and the current snap permissions
 * that are under wildcards will be added as caveats to a parent `wallet_snap` permission.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  const state = versionedData.data;
  const newState = transformState(state);
  versionedData.data = newState;
  return versionedData;
}

// We return state AS IS if there is any corruption
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'SnapController') || !(0, _utils.hasProperty)(state, 'PermissionController') || !(0, _utils.isObject)(state.PermissionController)) {
    return state;
  }
  const {
    PermissionController
  } = state;
  const {
    subjects
  } = PermissionController;
  if (!(0, _utils.isObject)(subjects)) {
    return state;
  }
  const snapPrefix = 'wallet_snap_';
  for (const [subjectName, subject] of Object.entries(subjects)) {
    if (!(0, _utils.isObject)(subject) || !(0, _utils.isObject)(subject.permissions)) {
      return state;
    }
    // We keep track of the latest permission's date and associated id
    // to assign to the wallet_snap permission after iterating through all permissions
    let date = 1;
    let id;
    const {
      permissions
    } = subject;
    // New permissions object that we use to tack on the `wallet_snap` permission
    const updatedPermissions = {
      ...permissions
    };
    for (const [permissionName, permission] of Object.entries(permissions)) {
      // check if the permission is namespaced
      if (permissionName.startsWith(snapPrefix)) {
        if (!(0, _utils.isObject)(permission) || !(0, _utils.hasProperty)(permission, 'id') || !(0, _utils.hasProperty)(permission, 'date')) {
          return state;
        }
        // We create a wallet_snap key if we already don't have one
        if (!(0, _utils.hasProperty)(updatedPermissions, 'wallet_snap')) {
          updatedPermissions.wallet_snap = {
            caveats: [{
              type: 'snapIds',
              value: {}
            }],
            invoker: subjectName,
            parentCapability: 'wallet_snap'
          };
        }

        // Check if the existing permission is valid
        if (!(0, _utils.isObject)(updatedPermissions.wallet_snap)) {
          return state;
        }
        if (!(0, _lodash.isArray)(updatedPermissions.wallet_snap.caveats)) {
          return state;
        }

        // Adding the snap name to the wallet_snap permission's caveat value
        const snapId = permissionName.slice(snapPrefix.length);
        const caveat = updatedPermissions.wallet_snap.caveats[0];
        if (!(0, _utils.isObject)(caveat)) {
          return state;
        }
        if (!(0, _utils.hasProperty)(caveat, 'type') || caveat.type !== 'snapIds' || !(0, _utils.hasProperty)(caveat, 'value') || !(0, _utils.isObject)(caveat.value)) {
          return state;
        }
        caveat.value[snapId] = {};
        if (typeof permission.date !== 'number' || typeof permission.id !== 'string') {
          return state;
        }

        // updating the date & id as we iterate through all permissions
        if (permission.date > date) {
          date = permission.date;
          id = permission.id;
        }

        // finally deleting the stale permission
        delete updatedPermissions[permissionName];
      }
    }

    // we reassign the date and id here after iterating through all permissions
    // and update the subject with the updated permissions
    if (updatedPermissions.wallet_snap) {
      updatedPermissions.wallet_snap.date = date;
      updatedPermissions.wallet_snap.id = id;
      subject.permissions = updatedPermissions;
    }
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\081.ts",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\082.ts", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js","uuid":"F:\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C082.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
var _uuid = require("uuid");
const version = 82;

/**
 * Migrate the frequentRpcListDetail from the PreferencesController to the NetworkController, convert it from an array to an object
 * keyed by random uuids.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'PreferencesController') || !(0, _utils.isObject)(state.PreferencesController) || !(0, _utils.isObject)(state.NetworkController) || !(0, _utils.hasProperty)(state.PreferencesController, 'frequentRpcListDetail') || !Array.isArray(state.PreferencesController.frequentRpcListDetail) || !state.PreferencesController.frequentRpcListDetail.every(_utils.isObject)) {
    return state;
  }
  const {
    PreferencesController,
    NetworkController
  } = state;
  const {
    frequentRpcListDetail
  } = PreferencesController;
  if (!Array.isArray(frequentRpcListDetail)) {
    return state;
  }
  const networkConfigurations = frequentRpcListDetail.reduce((networkConfigurationsAcc, {
    rpcUrl,
    chainId,
    ticker,
    nickname,
    rpcPrefs
  }) => {
    const networkConfigurationId = (0, _uuid.v4)();
    return {
      ...networkConfigurationsAcc,
      [networkConfigurationId]: {
        rpcUrl,
        chainId,
        ticker,
        rpcPrefs,
        nickname
      }
    };
  }, {});
  delete PreferencesController.frequentRpcListDetail;
  return {
    ...state,
    NetworkController: {
      ...NetworkController,
      networkConfigurations
    },
    PreferencesController: {
      ...PreferencesController
    }
  };
}


      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\082.ts",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\083.ts", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C083.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 83;

/**
 * Ensure that each networkConfigurations object in state.NetworkController.networkConfigurations has an
 * `id` property which matches the key pointing that object
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.isObject)(state.NetworkController)) {
    return state;
  }
  const {
    NetworkController
  } = state;
  if (!(0, _utils.isObject)(NetworkController.networkConfigurations)) {
    return state;
  }
  const {
    networkConfigurations
  } = NetworkController;
  const newNetworkConfigurations = {};
  for (const networkConfigurationId of Object.keys(networkConfigurations)) {
    const networkConfiguration = networkConfigurations[networkConfigurationId];
    if (!(0, _utils.isObject)(networkConfiguration)) {
      return state;
    }
    newNetworkConfigurations[networkConfigurationId] = {
      ...networkConfiguration,
      id: networkConfigurationId
    };
  }
  return {
    ...state,
    NetworkController: {
      ...NetworkController,
      networkConfigurations: newNetworkConfigurations
    }
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\083.ts",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\084.ts", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C084.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 84;

/**
 * The `network` property in state was replaced with `networkId` and `networkStatus`.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.hasProperty)(state, 'NetworkController') || !(0, _utils.isObject)(state.NetworkController) || !(0, _utils.hasProperty)(state.NetworkController, 'network')) {
    return state;
  }
  const NetworkController = {
    ...state.NetworkController
  };
  if (NetworkController.network === 'loading') {
    NetworkController.networkId = null;
    NetworkController.networkStatus = 'unknown';
  } else {
    NetworkController.networkId = NetworkController.network;
    NetworkController.networkStatus = 'available';
  }
  delete NetworkController.network;
  return {
    ...state,
    NetworkController
  };
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\084.ts",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\085.ts", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C085.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _lodash = require("lodash");
var _utils = require("@metamask/utils");
const version = 85;

/**
 * Remove the now-obsolete network controller `previousProviderStore` state.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.isObject)(state.NetworkController)) {
    return state;
  }
  delete state.NetworkController.previousProviderStore;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\085.ts",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\086.ts", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C086.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _utils = require("@metamask/utils");
var _lodash = require("lodash");
const version = 86;

/**
 * Rename network controller `provider` state to `providerConfig`.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if ((0, _utils.hasProperty)(state, 'NetworkController') && (0, _utils.isObject)(state.NetworkController) && (0, _utils.hasProperty)(state.NetworkController, 'provider')) {
    const networkControllerState = state.NetworkController;
    networkControllerState.providerConfig = networkControllerState.provider;
    delete networkControllerState.provider;
    return {
      ...state,
      NetworkController: networkControllerState
    };
  }
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\086.ts",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\087.ts", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C087.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _utils = require("@metamask/utils");
var _lodash = require("lodash");
const version = 87;

/**
 * Remove the now-obsolete tokens controller `suggestedAssets` state.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  versionedData.data = transformState(versionedData.data);
  return versionedData;
}
function transformState(state) {
  if (!(0, _utils.isObject)(state.TokensController)) {
    return state;
  }
  delete state.TokensController.suggestedAssets;
  return state;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\087.ts",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\088.ts", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5C088.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.migrate = migrate;
exports.version = void 0;
var _utils = require("@metamask/utils");
var _ethereumjsUtil = require("ethereumjs-util");
var _lodash = require("lodash");
const version = 88;

/**
 * This migration does a few things:
 *
 * - Rebuilds `allNftContracts` and `allNfts` in NftController state to be keyed
 * by a hex chain ID rather than a decimal chain ID.
 * - Rebuilds `tokensChainsCache` in TokenListController to be keyed by a hex
 * chain ID rather than a decimal chain ID.
 * - Rebuilds `allTokens` and `allIgnoredTokens` in TokensController to be keyed
 * by a hex chain ID rather than a decimal chain ID.
 *
 * @param originalVersionedData - Versioned MetaMask extension state, exactly what we persist to dist.
 * @param originalVersionedData.meta - State metadata.
 * @param originalVersionedData.meta.version - The current state version.
 * @param originalVersionedData.data - The persisted MetaMask state, keyed by controller.
 * @returns Updated versioned MetaMask extension state.
 */
exports.version = version;
async function migrate(originalVersionedData) {
  const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
  versionedData.meta.version = version;
  migrateData(versionedData.data);
  return versionedData;
}
function migrateData(state) {
  if ((0, _utils.hasProperty)(state, 'NftController') && (0, _utils.isObject)(state.NftController)) {
    const nftControllerState = state.NftController;

    // Migrate NftController.allNftContracts
    if ((0, _utils.hasProperty)(nftControllerState, 'allNftContracts') && (0, _utils.isObject)(nftControllerState.allNftContracts)) {
      const {
        allNftContracts
      } = nftControllerState;
      if (Object.keys(allNftContracts).every(address => (0, _utils.isObject)(allNftContracts[address]))) {
        Object.keys(allNftContracts).forEach(address => {
          const nftContractsByChainId = allNftContracts[address];
          if ((0, _utils.isObject)(nftContractsByChainId)) {
            allNftContracts[address] = (0, _lodash.mapKeys)(nftContractsByChainId, (_, chainId) => toHex(chainId));
          }
        });
      }
    }

    // Migrate NftController.allNfts
    if ((0, _utils.hasProperty)(nftControllerState, 'allNfts') && (0, _utils.isObject)(nftControllerState.allNfts)) {
      const {
        allNfts
      } = nftControllerState;
      if (Object.keys(allNfts).every(address => (0, _utils.isObject)(allNfts[address]))) {
        Object.keys(allNfts).forEach(address => {
          const nftsByChainId = allNfts[address];
          if ((0, _utils.isObject)(nftsByChainId)) {
            allNfts[address] = (0, _lodash.mapKeys)(nftsByChainId, (_, chainId) => toHex(chainId));
          }
        });
      }
    }
    state.NftController = nftControllerState;
  }
  if ((0, _utils.hasProperty)(state, 'TokenListController') && (0, _utils.isObject)(state.TokenListController)) {
    const tokenListControllerState = state.TokenListController;

    // Migrate TokenListController.tokensChainsCache
    if ((0, _utils.hasProperty)(tokenListControllerState, 'tokensChainsCache') && (0, _utils.isObject)(tokenListControllerState.tokensChainsCache)) {
      tokenListControllerState.tokensChainsCache = (0, _lodash.mapKeys)(tokenListControllerState.tokensChainsCache, (_, chainId) => toHex(chainId));
    }
  }
  if ((0, _utils.hasProperty)(state, 'TokensController') && (0, _utils.isObject)(state.TokensController)) {
    const tokensControllerState = state.TokensController;

    // Migrate TokensController.allTokens
    if ((0, _utils.hasProperty)(tokensControllerState, 'allTokens') && (0, _utils.isObject)(tokensControllerState.allTokens)) {
      const {
        allTokens
      } = tokensControllerState;
      tokensControllerState.allTokens = (0, _lodash.mapKeys)(allTokens, (_, chainId) => toHex(chainId));
    }

    // Migrate TokensController.allIgnoredTokens
    if ((0, _utils.hasProperty)(tokensControllerState, 'allIgnoredTokens') && (0, _utils.isObject)(tokensControllerState.allIgnoredTokens)) {
      const {
        allIgnoredTokens
      } = tokensControllerState;
      tokensControllerState.allIgnoredTokens = (0, _lodash.mapKeys)(allIgnoredTokens, (_, chainId) => toHex(chainId));
    }

    // Migrate TokensController.allDetectedTokens
    if ((0, _utils.hasProperty)(tokensControllerState, 'allDetectedTokens') && (0, _utils.isObject)(tokensControllerState.allDetectedTokens)) {
      const {
        allDetectedTokens
      } = tokensControllerState;
      tokensControllerState.allDetectedTokens = (0, _lodash.mapKeys)(allDetectedTokens, (_, chainId) => toHex(chainId));
    }
    state.TokensController = tokensControllerState;
  }
}
function toHex(value) {
  if (typeof value === 'string' && (0, _utils.isStrictHexString)(value)) {
    return value;
  }
  const hexString = _ethereumjsUtil.BN.isBN(value) ? value.toString(16) : new _ethereumjsUtil.BN(value.toString(), 10).toString(16);
  return `0x${hexString}`;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\088.ts",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\fail-tx.js", {"../../../shared/constants/transaction":"F:\\metamask-extension\\shared\\constants\\transaction.ts","lodash":"F:\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5Cfail-tx.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = failTxsThat;
var _lodash = require("lodash");
var _transaction = require("../../../shared/constants/transaction");
function failTxsThat(version, reason, condition) {
  return function (originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    try {
      const state = versionedData.data;
      const newState = transformState(state, condition, reason);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }
    return Promise.resolve(versionedData);
  };
}
function transformState(state, condition, reason) {
  const newState = state;
  const {
    TransactionController
  } = newState;
  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!condition(txMeta)) {
        return txMeta;
      }
      txMeta.status = _transaction.TransactionStatus.failed;
      txMeta.err = {
        message: reason,
        note: `Tx automatically failed by migration because ${reason}`
      };
      return txMeta;
    });
  }
  return newState;
}

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\fail-tx.js",}],
["F:\\metamask-extension\\app\\scripts\\migrations\\index.js", {"./002":"F:\\metamask-extension\\app\\scripts\\migrations\\002.js","./003":"F:\\metamask-extension\\app\\scripts\\migrations\\003.js","./004":"F:\\metamask-extension\\app\\scripts\\migrations\\004.js","./005":"F:\\metamask-extension\\app\\scripts\\migrations\\005.js","./006":"F:\\metamask-extension\\app\\scripts\\migrations\\006.js","./007":"F:\\metamask-extension\\app\\scripts\\migrations\\007.js","./008":"F:\\metamask-extension\\app\\scripts\\migrations\\008.js","./009":"F:\\metamask-extension\\app\\scripts\\migrations\\009.js","./010":"F:\\metamask-extension\\app\\scripts\\migrations\\010.js","./011":"F:\\metamask-extension\\app\\scripts\\migrations\\011.js","./012":"F:\\metamask-extension\\app\\scripts\\migrations\\012.js","./013":"F:\\metamask-extension\\app\\scripts\\migrations\\013.js","./014":"F:\\metamask-extension\\app\\scripts\\migrations\\014.js","./015":"F:\\metamask-extension\\app\\scripts\\migrations\\015.js","./016":"F:\\metamask-extension\\app\\scripts\\migrations\\016.js","./017":"F:\\metamask-extension\\app\\scripts\\migrations\\017.js","./018":"F:\\metamask-extension\\app\\scripts\\migrations\\018.js","./019":"F:\\metamask-extension\\app\\scripts\\migrations\\019.js","./020":"F:\\metamask-extension\\app\\scripts\\migrations\\020.js","./021":"F:\\metamask-extension\\app\\scripts\\migrations\\021.js","./022":"F:\\metamask-extension\\app\\scripts\\migrations\\022.js","./023":"F:\\metamask-extension\\app\\scripts\\migrations\\023.js","./024":"F:\\metamask-extension\\app\\scripts\\migrations\\024.js","./025":"F:\\metamask-extension\\app\\scripts\\migrations\\025.js","./026":"F:\\metamask-extension\\app\\scripts\\migrations\\026.js","./027":"F:\\metamask-extension\\app\\scripts\\migrations\\027.js","./028":"F:\\metamask-extension\\app\\scripts\\migrations\\028.js","./029":"F:\\metamask-extension\\app\\scripts\\migrations\\029.js","./030":"F:\\metamask-extension\\app\\scripts\\migrations\\030.js","./031":"F:\\metamask-extension\\app\\scripts\\migrations\\031.js","./032":"F:\\metamask-extension\\app\\scripts\\migrations\\032.js","./033":"F:\\metamask-extension\\app\\scripts\\migrations\\033.js","./034":"F:\\metamask-extension\\app\\scripts\\migrations\\034.js","./035":"F:\\metamask-extension\\app\\scripts\\migrations\\035.js","./036":"F:\\metamask-extension\\app\\scripts\\migrations\\036.js","./037":"F:\\metamask-extension\\app\\scripts\\migrations\\037.js","./038":"F:\\metamask-extension\\app\\scripts\\migrations\\038.js","./039":"F:\\metamask-extension\\app\\scripts\\migrations\\039.js","./040":"F:\\metamask-extension\\app\\scripts\\migrations\\040.js","./041":"F:\\metamask-extension\\app\\scripts\\migrations\\041.js","./042":"F:\\metamask-extension\\app\\scripts\\migrations\\042.js","./043":"F:\\metamask-extension\\app\\scripts\\migrations\\043.js","./044":"F:\\metamask-extension\\app\\scripts\\migrations\\044.js","./045":"F:\\metamask-extension\\app\\scripts\\migrations\\045.js","./046":"F:\\metamask-extension\\app\\scripts\\migrations\\046.js","./047":"F:\\metamask-extension\\app\\scripts\\migrations\\047.js","./048":"F:\\metamask-extension\\app\\scripts\\migrations\\048.js","./049":"F:\\metamask-extension\\app\\scripts\\migrations\\049.js","./050":"F:\\metamask-extension\\app\\scripts\\migrations\\050.js","./051":"F:\\metamask-extension\\app\\scripts\\migrations\\051.js","./052":"F:\\metamask-extension\\app\\scripts\\migrations\\052.js","./053":"F:\\metamask-extension\\app\\scripts\\migrations\\053.js","./054":"F:\\metamask-extension\\app\\scripts\\migrations\\054.js","./055":"F:\\metamask-extension\\app\\scripts\\migrations\\055.js","./056":"F:\\metamask-extension\\app\\scripts\\migrations\\056.js","./057":"F:\\metamask-extension\\app\\scripts\\migrations\\057.js","./058":"F:\\metamask-extension\\app\\scripts\\migrations\\058.js","./059":"F:\\metamask-extension\\app\\scripts\\migrations\\059.js","./060":"F:\\metamask-extension\\app\\scripts\\migrations\\060.js","./061":"F:\\metamask-extension\\app\\scripts\\migrations\\061.js","./062":"F:\\metamask-extension\\app\\scripts\\migrations\\062.js","./063":"F:\\metamask-extension\\app\\scripts\\migrations\\063.js","./064":"F:\\metamask-extension\\app\\scripts\\migrations\\064.js","./065":"F:\\metamask-extension\\app\\scripts\\migrations\\065.js","./066":"F:\\metamask-extension\\app\\scripts\\migrations\\066.js","./067":"F:\\metamask-extension\\app\\scripts\\migrations\\067.js","./068":"F:\\metamask-extension\\app\\scripts\\migrations\\068.js","./069":"F:\\metamask-extension\\app\\scripts\\migrations\\069.js","./070":"F:\\metamask-extension\\app\\scripts\\migrations\\070.js","./071":"F:\\metamask-extension\\app\\scripts\\migrations\\071.js","./072":"F:\\metamask-extension\\app\\scripts\\migrations\\072.js","./073":"F:\\metamask-extension\\app\\scripts\\migrations\\073.js","./074":"F:\\metamask-extension\\app\\scripts\\migrations\\074.js","./075":"F:\\metamask-extension\\app\\scripts\\migrations\\075.js","./076":"F:\\metamask-extension\\app\\scripts\\migrations\\076.js","./077":"F:\\metamask-extension\\app\\scripts\\migrations\\077.js","./078":"F:\\metamask-extension\\app\\scripts\\migrations\\078.ts","./079":"F:\\metamask-extension\\app\\scripts\\migrations\\079.js","./080":"F:\\metamask-extension\\app\\scripts\\migrations\\080.js","./081":"F:\\metamask-extension\\app\\scripts\\migrations\\081.ts","./082":"F:\\metamask-extension\\app\\scripts\\migrations\\082.ts","./083":"F:\\metamask-extension\\app\\scripts\\migrations\\083.ts","./084":"F:\\metamask-extension\\app\\scripts\\migrations\\084.ts","./085":"F:\\metamask-extension\\app\\scripts\\migrations\\085.ts","./086":"F:\\metamask-extension\\app\\scripts\\migrations\\086.ts","./087":"F:\\metamask-extension\\app\\scripts\\migrations\\087.ts","./088":"F:\\metamask-extension\\app\\scripts\\migrations\\088.ts"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Capp%5Cscripts%5Cmigrations%5Cindex.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _ = _interopRequireDefault(require("./002"));
var _2 = _interopRequireDefault(require("./003"));
var _3 = _interopRequireDefault(require("./004"));
var _4 = _interopRequireDefault(require("./005"));
var _5 = _interopRequireDefault(require("./006"));
var _6 = _interopRequireDefault(require("./007"));
var _7 = _interopRequireDefault(require("./008"));
var _8 = _interopRequireDefault(require("./009"));
var _9 = _interopRequireDefault(require("./010"));
var _10 = _interopRequireDefault(require("./011"));
var _11 = _interopRequireDefault(require("./012"));
var _12 = _interopRequireDefault(require("./013"));
var _13 = _interopRequireDefault(require("./014"));
var _14 = _interopRequireDefault(require("./015"));
var _15 = _interopRequireDefault(require("./016"));
var _16 = _interopRequireDefault(require("./017"));
var _17 = _interopRequireDefault(require("./018"));
var _18 = _interopRequireDefault(require("./019"));
var _19 = _interopRequireDefault(require("./020"));
var _20 = _interopRequireDefault(require("./021"));
var _21 = _interopRequireDefault(require("./022"));
var _22 = _interopRequireDefault(require("./023"));
var _23 = _interopRequireDefault(require("./024"));
var _24 = _interopRequireDefault(require("./025"));
var _25 = _interopRequireDefault(require("./026"));
var _26 = _interopRequireDefault(require("./027"));
var _27 = _interopRequireDefault(require("./028"));
var _28 = _interopRequireDefault(require("./029"));
var _29 = _interopRequireDefault(require("./030"));
var _30 = _interopRequireDefault(require("./031"));
var _31 = _interopRequireDefault(require("./032"));
var _32 = _interopRequireDefault(require("./033"));
var _33 = _interopRequireDefault(require("./034"));
var _34 = _interopRequireDefault(require("./035"));
var _35 = _interopRequireDefault(require("./036"));
var _36 = _interopRequireDefault(require("./037"));
var _37 = _interopRequireDefault(require("./038"));
var _38 = _interopRequireDefault(require("./039"));
var _39 = _interopRequireDefault(require("./040"));
var _40 = _interopRequireDefault(require("./041"));
var _41 = _interopRequireDefault(require("./042"));
var _42 = _interopRequireDefault(require("./043"));
var _43 = _interopRequireDefault(require("./044"));
var _44 = _interopRequireDefault(require("./045"));
var _45 = _interopRequireDefault(require("./046"));
var _46 = _interopRequireDefault(require("./047"));
var _47 = _interopRequireDefault(require("./048"));
var _48 = _interopRequireDefault(require("./049"));
var _49 = _interopRequireDefault(require("./050"));
var _50 = _interopRequireDefault(require("./051"));
var _51 = _interopRequireDefault(require("./052"));
var _52 = _interopRequireDefault(require("./053"));
var _53 = _interopRequireDefault(require("./054"));
var _54 = _interopRequireDefault(require("./055"));
var _55 = _interopRequireDefault(require("./056"));
var _56 = _interopRequireDefault(require("./057"));
var _57 = _interopRequireDefault(require("./058"));
var _58 = _interopRequireDefault(require("./059"));
var _59 = _interopRequireDefault(require("./060"));
var _60 = _interopRequireDefault(require("./061"));
var _61 = _interopRequireDefault(require("./062"));
var _62 = _interopRequireDefault(require("./063"));
var _63 = _interopRequireDefault(require("./064"));
var _64 = _interopRequireDefault(require("./065"));
var _65 = _interopRequireDefault(require("./066"));
var _66 = _interopRequireDefault(require("./067"));
var _67 = _interopRequireDefault(require("./068"));
var _68 = _interopRequireDefault(require("./069"));
var _69 = _interopRequireDefault(require("./070"));
var _70 = _interopRequireDefault(require("./071"));
var _71 = _interopRequireDefault(require("./072"));
var _72 = _interopRequireDefault(require("./073"));
var _73 = _interopRequireDefault(require("./074"));
var _74 = _interopRequireDefault(require("./075"));
var _75 = _interopRequireDefault(require("./076"));
var _76 = _interopRequireDefault(require("./077"));
var m078 = _interopRequireWildcard(require("./078"));
var _78 = _interopRequireDefault(require("./079"));
var _79 = _interopRequireDefault(require("./080"));
var m081 = _interopRequireWildcard(require("./081"));
var m082 = _interopRequireWildcard(require("./082"));
var m083 = _interopRequireWildcard(require("./083"));
var m084 = _interopRequireWildcard(require("./084"));
var m085 = _interopRequireWildcard(require("./085"));
var m086 = _interopRequireWildcard(require("./086"));
var m087 = _interopRequireWildcard(require("./087"));
var m088 = _interopRequireWildcard(require("./088"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
// Migrations must start at version 1 or later.
// They are objects with a `version` number
// and a `migrate` function.
//
// The `migrate` function receives the previous
// config data format, and returns the new one.

const migrations = [_.default, _2.default, _3.default, _4.default, _5.default, _6.default, _7.default, _8.default, _9.default, _10.default, _11.default, _12.default, _13.default, _14.default, _15.default, _16.default, _17.default, _18.default, _19.default, _20.default, _21.default, _22.default, _23.default, _24.default, _25.default, _26.default, _27.default, _28.default, _29.default, _30.default, _31.default, _32.default, _33.default, _34.default, _35.default, _36.default, _37.default, _38.default, _39.default, _40.default, _41.default, _42.default, _43.default, _44.default, _45.default, _46.default, _47.default, _48.default, _49.default, _50.default, _51.default, _52.default, _53.default, _54.default, _55.default, _56.default, _57.default, _58.default, _59.default, _60.default, _61.default, _62.default, _63.default, _64.default, _65.default, _66.default, _67.default, _68.default, _69.default, _70.default, _71.default, _72.default, _73.default, _74.default, _75.default, _76.default, m078, _78.default, _79.default, m081, m082, m083, m084, m085, m086, m087, m088];
var _default = migrations;
exports.default = _default;

      };
    };
  }
  }
}, {package:"$root$",file:"app\\scripts\\migrations\\index.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\base.js", {"./util":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Cbase.js
      return function (require, module, exports) {
'use strict'

const { encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__("./types").BaseName} BaseName */
/** @typedef {__import__("./types").BaseCode} BaseCode */

/**
 * Class to encode/decode in the supported Bases
 *
 */
class Base {
  /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */
  constructor (name, code, factory, alphabet) {
    this.name = name
    this.code = code
    this.codeBuf = encodeText(this.code)
    this.alphabet = alphabet
    this.codec = factory(alphabet)
  }

  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode (buf) {
    return this.codec.encode(buf)
  }

  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode (string) {
    for (const char of string) {
      if (this.alphabet && this.alphabet.indexOf(char) < 0) {
        throw new Error(`invalid character '${char}' in '${string}'`)
      }
    }
    return this.codec.decode(string)
  }
}

module.exports = Base

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\base.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js", {"./base.js":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\base.js","./rfc4648":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\rfc4648.js","./util":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js","@multiformats/base-x":"F:\\metamask-extension\\node_modules\\@multiformats\\base-x\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Cconstants.js
      return function (require, module, exports) {
'use strict'

const baseX = require('@multiformats/base-x')
const Base = require('./base.js')
const { rfc4648 } = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

/** @typedef {__import__('./types').CodecFactory} CodecFactory */
/** @typedef {__import__('./types').Codec} Codec */
/** @typedef {__import__('./types').BaseName} BaseName */
/** @typedef {__import__('./types').BaseCode} BaseCode */

/** @type {CodecFactory} */
const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 *
 * name, code, implementation, alphabet
 *
 * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

/** @type {Record<BaseName,Base>} */
const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, /** @type {Record<BaseName,Base>} */({}))

/** @type {Record<BaseCode,Base>} */
const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, /** @type {Record<BaseCode,Base>} */({}))

module.exports = {
  names,
  codes
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\rfc4648.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Crfc4648.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./types').CodecFactory} CodecFactory */

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar) => {
  // Build the character lookup table:
  /** @type {Record<string, number>} */
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[i])
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * RFC4648 Factory
 *
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */
const rfc4648 = (bitsPerChar) => (alphabet) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode (input) {
      return decode(input, alphabet, bitsPerChar)
    }
  }
}

module.exports = { rfc4648 }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\rfc4648.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js", {"web-encoding":"F:\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultibase%5Csrc%5Cutil.js
      return function (require, module, exports) {
'use strict'

// @ts-ignore
const { TextEncoder, TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * Returns a new Uint8Array created by concatenating the passed Arrays
 *
 * @param {Array<ArrayLike<number>>} arrs
 * @param {number} length
 * @returns {Uint8Array}
 */
function concat (arrs, length) {
  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrs) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = { decodeText, encodeText, concat }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\util.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cdecode.js
      return function (require, module, exports) {
module.exports = read

var MSB = 0x80
  , REST = 0x7F

function read(buf, offset) {
  var res    = 0
    , offset = offset || 0
    , shift  = 0
    , counter = offset
    , b
    , l = buf.length

  do {
    if (counter >= l || shift > 49) {
      read.bytes = 0
      throw new RangeError('Could not decode varint')
    }
    b = buf[counter++]
    res += shift < 28
      ? (b & REST) << shift
      : (b & REST) * Math.pow(2, shift)
    shift += 7
  } while (b >= MSB)

  read.bytes = counter - offset

  return res
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cencode.js
      return function (require, module, exports) {
module.exports = encode

var MSB = 0x80
  , REST = 0x7F
  , MSBALL = ~REST
  , INT = Math.pow(2, 31)

function encode(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode.bytes = 0
    throw new RangeError('Could not encode varint')
  }
  out = out || []
  offset = offset || 0
  var oldOffset = offset

  while(num >= INT) {
    out[offset++] = (num & 0xFF) | MSB
    num /= 128
  }
  while(num & MSBALL) {
    out[offset++] = (num & 0xFF) | MSB
    num >>>= 7
  }
  out[offset] = num | 0
  
  encode.bytes = offset - oldOffset + 1
  
  return out
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js", {"./decode.js":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\decode.js","./encode.js":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\encode.js","./length.js":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Cindex.js
      return function (require, module, exports) {
module.exports = {
    encode: require('./encode.js')
  , decode: require('./decode.js')
  , encodingLength: require('./length.js')
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Cnode_modules%5Cvarint%5Clength.js
      return function (require, module, exports) {

var N1 = Math.pow(2,  7)
var N2 = Math.pow(2, 14)
var N3 = Math.pow(2, 21)
var N4 = Math.pow(2, 28)
var N5 = Math.pow(2, 35)
var N6 = Math.pow(2, 42)
var N7 = Math.pow(2, 49)
var N8 = Math.pow(2, 56)
var N9 = Math.pow(2, 63)

module.exports = function (value) {
  return (
    value < N1 ? 1
  : value < N2 ? 2
  : value < N3 ? 3
  : value < N4 ? 4
  : value < N5 ? 5
  : value < N6 ? 6
  : value < N7 ? 7
  : value < N8 ? 8
  : value < N9 ? 9
  :              10
  )
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>varint",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\length.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cbase-table.js
      return function (require, module, exports) {
// DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js
/* eslint quote-props: off */
'use strict'

/**
 * @type {__import__('./generated-types').NameNumberMap}
 */
const baseTable = Object.freeze({
  'identity': 0x00,
  'cidv1': 0x01,
  'cidv2': 0x02,
  'cidv3': 0x03,
  'ip4': 0x04,
  'tcp': 0x06,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'dccp': 0x21,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'ip6': 0x29,
  'ip6zone': 0x2a,
  'path': 0x2f,
  'multicodec': 0x30,
  'multihash': 0x31,
  'multiaddr': 0x32,
  'multibase': 0x33,
  'dns': 0x35,
  'dns4': 0x36,
  'dns6': 0x37,
  'dnsaddr': 0x38,
  'protobuf': 0x50,
  'cbor': 0x51,
  'raw': 0x55,
  'dbl-sha2-256': 0x56,
  'rlp': 0x60,
  'bencode': 0x63,
  'dag-pb': 0x70,
  'dag-cbor': 0x71,
  'libp2p-key': 0x72,
  'git-raw': 0x78,
  'torrent-info': 0x7b,
  'torrent-file': 0x7c,
  'leofcoin-block': 0x81,
  'leofcoin-tx': 0x82,
  'leofcoin-pr': 0x83,
  'sctp': 0x84,
  'dag-jose': 0x85,
  'dag-cose': 0x86,
  'eth-block': 0x90,
  'eth-block-list': 0x91,
  'eth-tx-trie': 0x92,
  'eth-tx': 0x93,
  'eth-tx-receipt-trie': 0x94,
  'eth-tx-receipt': 0x95,
  'eth-state-trie': 0x96,
  'eth-account-snapshot': 0x97,
  'eth-storage-trie': 0x98,
  'bitcoin-block': 0xb0,
  'bitcoin-tx': 0xb1,
  'bitcoin-witness-commitment': 0xb2,
  'zcash-block': 0xc0,
  'zcash-tx': 0xc1,
  'docid': 0xce,
  'stellar-block': 0xd0,
  'stellar-tx': 0xd1,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'decred-block': 0xe0,
  'decred-tx': 0xe1,
  'ipld-ns': 0xe2,
  'ipfs-ns': 0xe3,
  'swarm-ns': 0xe4,
  'ipns-ns': 0xe5,
  'zeronet': 0xe6,
  'secp256k1-pub': 0xe7,
  'bls12_381-g1-pub': 0xea,
  'bls12_381-g2-pub': 0xeb,
  'x25519-pub': 0xec,
  'ed25519-pub': 0xed,
  'bls12_381-g1g2-pub': 0xee,
  'dash-block': 0xf0,
  'dash-tx': 0xf1,
  'swarm-manifest': 0xfa,
  'swarm-feed': 0xfb,
  'udp': 0x0111,
  'p2p-webrtc-star': 0x0113,
  'p2p-webrtc-direct': 0x0114,
  'p2p-stardust': 0x0115,
  'p2p-circuit': 0x0122,
  'dag-json': 0x0129,
  'udt': 0x012d,
  'utp': 0x012e,
  'unix': 0x0190,
  'p2p': 0x01a5,
  'ipfs': 0x01a5,
  'https': 0x01bb,
  'onion': 0x01bc,
  'onion3': 0x01bd,
  'garlic64': 0x01be,
  'garlic32': 0x01bf,
  'tls': 0x01c0,
  'quic': 0x01cc,
  'ws': 0x01dd,
  'wss': 0x01de,
  'p2p-websocket-star': 0x01df,
  'http': 0x01e0,
  'json': 0x0200,
  'messagepack': 0x0201,
  'libp2p-peer-record': 0x0301,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'p256-pub': 0x1200,
  'p384-pub': 0x1201,
  'p521-pub': 0x1202,
  'ed448-pub': 0x1203,
  'x448-pub': 0x1204,
  'ed25519-priv': 0x1300,
  'kangarootwelve': 0x1d01,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402,
  'zeroxcert-imprint-256': 0xce11,
  'fil-commitment-unsealed': 0xf101,
  'fil-commitment-sealed': 0xf102,
  'holochain-adr-v0': 0x807124,
  'holochain-adr-v1': 0x817124,
  'holochain-key-v0': 0x947124,
  'holochain-key-v1': 0x957124,
  'holochain-sig-v0': 0xa27124,
  'holochain-sig-v1': 0xa37124,
  'skynet-ns': 0xb19910
})

module.exports = { baseTable }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js", {"./base-table":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cconstants.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').ConstantNumberMap} ConstantNumberMap */

const { baseTable } = require('./base-table')

const constants = /** @type {ConstantNumberMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  const constant = name.toUpperCase().replace(/-/g, '_')
  constants[constant] = code
}

module.exports = Object.freeze(constants)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js", {"./constants":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\constants.js","./int-table":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js","./print":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js","./util":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js","./varint-table":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js","uint8arrays/concat":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js","varint":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cindex.js
      return function (require, module, exports) {
/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

const varint = require('varint')
const intTable = require('./int-table')
const codecNameToCodeVarint = require('./varint-table')
const util = require('./util')
const uint8ArrayConcat = require('uint8arrays/concat')

/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {CodecName|Uint8Array} multicodecStrOrCode
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function addPrefix (multicodecStrOrCode, data) {
  let prefix

  if (multicodecStrOrCode instanceof Uint8Array) {
    prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)
  } else {
    if (codecNameToCodeVarint[multicodecStrOrCode]) {
      prefix = codecNameToCodeVarint[multicodecStrOrCode]
    } else {
      throw new Error('multicodec not recognized')
    }
  }
  return uint8ArrayConcat([prefix, data], prefix.length + data.length)
}

/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */
function rmPrefix (data) {
  varint.decode(data)
  return data.slice(varint.decode.bytes)
}

/**
 * Get the codec of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */
function getCodec (prefixedData) {
  const code = varint.decode(prefixedData)
  const codecName = intTable.get(code)
  if (codecName === undefined) {
    throw new Error(`Code ${code} not found`)
  }
  return codecName
}

/**
 * Get the name of the codec.
 *
 * @param {CodecNumber} codec
 * @returns {CodecName|undefined}
 */
function getName (codec) {
  return intTable.get(codec)
}

/**
 * Get the code of the codec
 *
 * @param {CodecName} name
 * @returns {CodecNumber}
 */
function getNumber (name) {
  const code = codecNameToCodeVarint[name]
  if (code === undefined) {
    throw new Error('Codec `' + name + '` not found')
  }
  return varint.decode(code)
}

/**
 * Get the code of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecNumber}
 */
function getCode (prefixedData) {
  return varint.decode(prefixedData)
}

/**
 * Get the code as varint of a codec name.
 *
 * @param {CodecName} codecName
 * @returns {Uint8Array}
 */
function getCodeVarint (codecName) {
  const code = codecNameToCodeVarint[codecName]
  if (code === undefined) {
    throw new Error('Codec `' + codecName + '` not found')
  }
  return code
}

/**
 * Get the varint of a code.
 *
 * @param {CodecNumber} code
 * @returns {Array.<number>}
 */
function getVarint (code) {
  return varint.encode(code)
}

// Make the constants top-level constants
const constants = require('./constants')

// Human friendly names for printing, e.g. in error messages
const print = require('./print')

module.exports = {
  addPrefix,
  rmPrefix,
  getCodec,
  getName,
  getNumber,
  getCode,
  getCodeVarint,
  getVarint,
  print,
  ...constants
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js", {"./base-table":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cint-table.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

const { baseTable } = require('./base-table')

/**
 * @type {Map<CodecNumber,CodecName>}
 */
const nameTable = new Map()

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  nameTable.set(code, /** @type {CodecName} */(encodingName))
}

module.exports = Object.freeze(nameTable)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\int-table.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js", {"./base-table":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cprint.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').CodecName} CodecName */
/** @typedef {__import__('./generated-types').NumberNameMap} NumberNameMap */

const { baseTable } = require('./base-table')

const tableByCode = /** @type {NumberNameMap} */({})

for (const [name, code] of Object.entries(baseTable)) {
  if (tableByCode[code] === undefined) {
    tableByCode[code] = /** @type {CodecName} **/(name)
  }
}

module.exports = /** @type {NumberNameMap} */(Object.freeze(tableByCode))

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\print.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js", {"uint8arrays/from-string":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js","uint8arrays/to-string":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js","varint":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\node_modules\\varint\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cutil.js
      return function (require, module, exports) {
'use strict'

const varint = require('varint')
const uint8ArrayToString = require('uint8arrays/to-string')
const uint8ArrayFromString = require('uint8arrays/from-string')

module.exports = {
  numberToUint8Array,
  uint8ArrayToNumber,
  varintUint8ArrayEncode,
  varintEncode
}

function uint8ArrayToNumber (buf) {
  return parseInt(uint8ArrayToString(buf, 'base16'), 16)
}

function numberToUint8Array (num) {
  let hexString = num.toString(16)
  if (hexString.length % 2 === 1) {
    hexString = '0' + hexString
  }
  return uint8ArrayFromString(hexString, 'base16')
}

function varintUint8ArrayEncode (input) {
  return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))
}

function varintEncode (num) {
  return Uint8Array.from(varint.encode(num))
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js", {"./base-table":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\base-table.js","./util":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmulticodec%5Csrc%5Cvarint-table.js
      return function (require, module, exports) {
'use strict'

/** @typedef {__import__('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */

const { baseTable } = require('./base-table')
const varintEncode = require('./util').varintEncode

const varintTable = /** @type {NameUint8ArrayMap} */ ({})

for (const encodingName in baseTable) {
  const code = baseTable[encodingName]
  varintTable[encodingName] = varintEncode(code)
}

module.exports = Object.freeze(varintTable)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\varint-table.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cbase.js
      return function (require, module, exports) {
// @ts-check
'use strict'
const { Buffer } = require('buffer')

/**
 * @typedef {Object} Codec
 * @property {function(Uint8Array):string} encode
 * @property {function(string):Uint8Array} decode
 *
 * @typedef {function(string):Codec} CodecFactory
 */

class Base {
  /**
   * @param {string} name
   * @param {string} code
   * @param {CodecFactory} implementation
   * @param {string} alphabet
   */
  constructor (name, code, implementation, alphabet) {
    this.name = name
    this.code = code
    this.codeBuf = Buffer.from(this.code)
    this.alphabet = alphabet
    this.engine = implementation(alphabet)
  }

  /**
   * @param {Uint8Array} buf
   * @returns {string}
   */
  encode (buf) {
    return this.engine.encode(buf)
  }

  /**
   * @param {string} string
   * @returns {Uint8Array}
   */
  decode (string) {
    for (const char of string) {
      if (this.alphabet && this.alphabet.indexOf(char) < 0) {
        throw new Error(`invalid character '${char}' in '${string}'`)
      }
    }
    return this.engine.decode(string)
  }
}

module.exports = Base

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js", {"./base.js":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js","./rfc4648":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js","./util":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js","base-x":"F:\\metamask-extension\\node_modules\\base-x\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cconstants.js
      return function (require, module, exports) {
// @ts-check
'use strict'

const baseX = require('base-x')
const Base = require('./base.js')
const rfc4648 = require('./rfc4648')
const { decodeText, encodeText } = require('./util')

const identity = () => {
  return {
    encode: decodeText,
    decode: encodeText
  }
}

/**
 * @typedef {__import__('./base').CodecFactory} CodecFactory
 *
 * name, code, implementation, alphabet
 * @type {Array<[string, string, CodecFactory, string]>}
 */
const constants = [
  ['identity', '\x00', identity, ''],
  ['base2', '0', rfc4648(1), '01'],
  ['base8', '7', rfc4648(3), '01234567'],
  ['base10', '9', baseX, '0123456789'],
  ['base16', 'f', rfc4648(4), '0123456789abcdef'],
  ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
  ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
  ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
  ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
  ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
  ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
  ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
  ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
  ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
  ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
  ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
  ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
  ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
  ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
  ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
  ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
  ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
]

const names = constants.reduce((prev, tupple) => {
  prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
  return prev
}, {})

const codes = constants.reduce((prev, tupple) => {
  prev[tupple[1]] = names[tupple[0]]
  return prev
}, {})

module.exports = {
  names,
  codes
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js", {"./constants":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js","./util":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cindex.js
      return function (require, module, exports) {
// @ts-check
/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 * @module Multibase
 */
'use strict'

const { Buffer } = require('buffer')
const constants = require('./constants')
const { decodeText, asBuffer } = require('./util')

/** @typedef {__import__("./base")} Base */

/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 */
function multibase (nameOrCode, buf) {
  if (!buf) {
    throw new Error('requires an encoded buffer')
  }
  const { name, codeBuf } = encoding(nameOrCode)
  validEncode(name, buf)

  const buffer = Buffer.alloc(codeBuf.length + buf.length)
  buffer.set(codeBuf, 0)
  buffer.set(buf, codeBuf.length)

  return buffer
}

/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function encode (nameOrCode, buf) {
  const enc = encoding(nameOrCode)

  return Buffer.concat([enc.codeBuf, Buffer.from(enc.encode(buf))])
}

/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Buffer}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */
function decode (data) {
  if (ArrayBuffer.isView(data)) {
    data = decodeText(data)
  }
  const prefix = data[0]

  // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
  if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
    data = data.toLowerCase()
  }
  const enc = encoding(data[0])
  return asBuffer(enc.decode(data.substring(1)))
}

/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 * @returns {false|string}
 */
function isEncoded (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  // Ensure bufOrString is a string
  if (Object.prototype.toString.call(data) !== '[object String]') {
    return false
  }

  try {
    const enc = encoding(data[0])
    return enc.name
  } catch (err) {
    return false
  }
}

/**
 * Validate encoded data
 *
 * @param {string} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */
function validEncode (name, buf) {
  const enc = encoding(name)
  enc.decode(decodeText(buf))
}

/**
 * Get the encoding by name or code
 *
 * @param {string|number} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encoding (nameOrCode) {
  if (constants.names[nameOrCode]) {
    return constants.names[nameOrCode]
  } else if (constants.codes[nameOrCode]) {
    return constants.codes[nameOrCode]
  } else {
    throw new Error(`Unsupported encoding: ${nameOrCode}`)
  }
}

/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */
function encodingFromData (data) {
  if (data instanceof Uint8Array) {
    data = decodeText(data)
  }

  return encoding(data[0])
}

exports = module.exports = multibase
exports.encode = encode
exports.decode = decode
exports.isEncoded = isEncoded
exports.encoding = encoding
exports.encodingFromData = encodingFromData
exports.names = Object.freeze(constants.names)
exports.codes = Object.freeze(constants.codes)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Crfc4648.js
      return function (require, module, exports) {
// @ts-check
'use strict'

/** @typedef {__import__('./base').CodecFactory} CodecFactory */

/**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */
const decode = (string, alphabet, bitsPerChar) => {
  // Build the character lookup table:
  const codes = {}
  for (let i = 0; i < alphabet.length; ++i) {
    codes[alphabet[i]] = i
  }

  // Count the padding bytes:
  let end = string.length
  while (string[end - 1] === '=') {
    --end
  }

  // Allocate the output:
  const out = new Uint8Array((end * bitsPerChar / 8) | 0)

  // Parse the data:
  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  let written = 0 // Next byte to write
  for (let i = 0; i < end; ++i) {
    // Read one character from the string:
    const value = codes[string[i]]
    if (value === undefined) {
      throw new SyntaxError('Invalid character ' + string[i])
    }

    // Append the bits to the buffer:
    buffer = (buffer << bitsPerChar) | value
    bits += bitsPerChar

    // Write out some bits if the buffer has a byte's worth:
    if (bits >= 8) {
      bits -= 8
      out[written++] = 0xff & (buffer >> bits)
    }
  }

  // Verify that we have received just enough bits:
  if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
    throw new SyntaxError('Unexpected end of data')
  }

  return out
}

/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */
const encode = (data, alphabet, bitsPerChar) => {
  const pad = alphabet[alphabet.length - 1] === '='
  const mask = (1 << bitsPerChar) - 1
  let out = ''

  let bits = 0 // Number of bits currently in the buffer
  let buffer = 0 // Bits waiting to be written out, MSB first
  for (let i = 0; i < data.length; ++i) {
    // Slurp data into the buffer:
    buffer = (buffer << 8) | data[i]
    bits += 8

    // Write out as much as we can:
    while (bits > bitsPerChar) {
      bits -= bitsPerChar
      out += alphabet[mask & (buffer >> bits)]
    }
  }

  // Partial character:
  if (bits) {
    out += alphabet[mask & (buffer << (bitsPerChar - bits))]
  }

  // Add padding characters until we hit a byte boundary:
  if (pad) {
    while ((out.length * bitsPerChar) & 7) {
      out += '='
    }
  }

  return out
}

/**
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */
module.exports = (bitsPerChar) => (alphabet) => {
  return {
    /**
     * @param {Uint8Array} input
     * @returns {string}
     */
    encode (input) {
      return encode(input, alphabet, bitsPerChar)
    },
    /**
     * @param {string} input
     * @returns {Uint8Array}
     */
    decode (input) {
      return decode(input, alphabet, bitsPerChar)
    }
  }
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","web-encoding":"F:\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Cnode_modules%5Cmultibase%5Csrc%5Cutil.js
      return function (require, module, exports) {
// @ts-check
'use strict'

const { Buffer } = require('buffer')
const { TextEncoder, TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */
const decodeText = (bytes) => textDecoder.decode(bytes)

const textEncoder = new TextEncoder()
/**
 * @param {string} text
 * @returns {Uint8Array}
 */
const encodeText = (text) => textEncoder.encode(text)

/**
 * @param {ArrayBufferView} bytes
 * @returns {Buffer}
 */
const asBuffer = ({ buffer, byteLength, byteOffset }) =>
  Buffer.from(buffer, byteOffset, byteLength)

module.exports = { decodeText, encodeText, asBuffer }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes>multibase",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Csrc%5Cconstants.js
      return function (require, module, exports) {
/* eslint quote-props: off */
'use strict'

const names = Object.freeze({
  'identity': 0x00,
  'sha1': 0x11,
  'sha2-256': 0x12,
  'sha2-512': 0x13,
  'sha3-512': 0x14,
  'sha3-384': 0x15,
  'sha3-256': 0x16,
  'sha3-224': 0x17,
  'shake-128': 0x18,
  'shake-256': 0x19,
  'keccak-224': 0x1a,
  'keccak-256': 0x1b,
  'keccak-384': 0x1c,
  'keccak-512': 0x1d,
  'blake3': 0x1e,
  'murmur3-128': 0x22,
  'murmur3-32': 0x23,
  'dbl-sha2-256': 0x56,
  'md4': 0xd4,
  'md5': 0xd5,
  'bmt': 0xd6,
  'sha2-256-trunc254-padded': 0x1012,
  'ripemd-128': 0x1052,
  'ripemd-160': 0x1053,
  'ripemd-256': 0x1054,
  'ripemd-320': 0x1055,
  'x11': 0x1100,
  'sm3-256': 0x534d,
  'blake2b-8': 0xb201,
  'blake2b-16': 0xb202,
  'blake2b-24': 0xb203,
  'blake2b-32': 0xb204,
  'blake2b-40': 0xb205,
  'blake2b-48': 0xb206,
  'blake2b-56': 0xb207,
  'blake2b-64': 0xb208,
  'blake2b-72': 0xb209,
  'blake2b-80': 0xb20a,
  'blake2b-88': 0xb20b,
  'blake2b-96': 0xb20c,
  'blake2b-104': 0xb20d,
  'blake2b-112': 0xb20e,
  'blake2b-120': 0xb20f,
  'blake2b-128': 0xb210,
  'blake2b-136': 0xb211,
  'blake2b-144': 0xb212,
  'blake2b-152': 0xb213,
  'blake2b-160': 0xb214,
  'blake2b-168': 0xb215,
  'blake2b-176': 0xb216,
  'blake2b-184': 0xb217,
  'blake2b-192': 0xb218,
  'blake2b-200': 0xb219,
  'blake2b-208': 0xb21a,
  'blake2b-216': 0xb21b,
  'blake2b-224': 0xb21c,
  'blake2b-232': 0xb21d,
  'blake2b-240': 0xb21e,
  'blake2b-248': 0xb21f,
  'blake2b-256': 0xb220,
  'blake2b-264': 0xb221,
  'blake2b-272': 0xb222,
  'blake2b-280': 0xb223,
  'blake2b-288': 0xb224,
  'blake2b-296': 0xb225,
  'blake2b-304': 0xb226,
  'blake2b-312': 0xb227,
  'blake2b-320': 0xb228,
  'blake2b-328': 0xb229,
  'blake2b-336': 0xb22a,
  'blake2b-344': 0xb22b,
  'blake2b-352': 0xb22c,
  'blake2b-360': 0xb22d,
  'blake2b-368': 0xb22e,
  'blake2b-376': 0xb22f,
  'blake2b-384': 0xb230,
  'blake2b-392': 0xb231,
  'blake2b-400': 0xb232,
  'blake2b-408': 0xb233,
  'blake2b-416': 0xb234,
  'blake2b-424': 0xb235,
  'blake2b-432': 0xb236,
  'blake2b-440': 0xb237,
  'blake2b-448': 0xb238,
  'blake2b-456': 0xb239,
  'blake2b-464': 0xb23a,
  'blake2b-472': 0xb23b,
  'blake2b-480': 0xb23c,
  'blake2b-488': 0xb23d,
  'blake2b-496': 0xb23e,
  'blake2b-504': 0xb23f,
  'blake2b-512': 0xb240,
  'blake2s-8': 0xb241,
  'blake2s-16': 0xb242,
  'blake2s-24': 0xb243,
  'blake2s-32': 0xb244,
  'blake2s-40': 0xb245,
  'blake2s-48': 0xb246,
  'blake2s-56': 0xb247,
  'blake2s-64': 0xb248,
  'blake2s-72': 0xb249,
  'blake2s-80': 0xb24a,
  'blake2s-88': 0xb24b,
  'blake2s-96': 0xb24c,
  'blake2s-104': 0xb24d,
  'blake2s-112': 0xb24e,
  'blake2s-120': 0xb24f,
  'blake2s-128': 0xb250,
  'blake2s-136': 0xb251,
  'blake2s-144': 0xb252,
  'blake2s-152': 0xb253,
  'blake2s-160': 0xb254,
  'blake2s-168': 0xb255,
  'blake2s-176': 0xb256,
  'blake2s-184': 0xb257,
  'blake2s-192': 0xb258,
  'blake2s-200': 0xb259,
  'blake2s-208': 0xb25a,
  'blake2s-216': 0xb25b,
  'blake2s-224': 0xb25c,
  'blake2s-232': 0xb25d,
  'blake2s-240': 0xb25e,
  'blake2s-248': 0xb25f,
  'blake2s-256': 0xb260,
  'skein256-8': 0xb301,
  'skein256-16': 0xb302,
  'skein256-24': 0xb303,
  'skein256-32': 0xb304,
  'skein256-40': 0xb305,
  'skein256-48': 0xb306,
  'skein256-56': 0xb307,
  'skein256-64': 0xb308,
  'skein256-72': 0xb309,
  'skein256-80': 0xb30a,
  'skein256-88': 0xb30b,
  'skein256-96': 0xb30c,
  'skein256-104': 0xb30d,
  'skein256-112': 0xb30e,
  'skein256-120': 0xb30f,
  'skein256-128': 0xb310,
  'skein256-136': 0xb311,
  'skein256-144': 0xb312,
  'skein256-152': 0xb313,
  'skein256-160': 0xb314,
  'skein256-168': 0xb315,
  'skein256-176': 0xb316,
  'skein256-184': 0xb317,
  'skein256-192': 0xb318,
  'skein256-200': 0xb319,
  'skein256-208': 0xb31a,
  'skein256-216': 0xb31b,
  'skein256-224': 0xb31c,
  'skein256-232': 0xb31d,
  'skein256-240': 0xb31e,
  'skein256-248': 0xb31f,
  'skein256-256': 0xb320,
  'skein512-8': 0xb321,
  'skein512-16': 0xb322,
  'skein512-24': 0xb323,
  'skein512-32': 0xb324,
  'skein512-40': 0xb325,
  'skein512-48': 0xb326,
  'skein512-56': 0xb327,
  'skein512-64': 0xb328,
  'skein512-72': 0xb329,
  'skein512-80': 0xb32a,
  'skein512-88': 0xb32b,
  'skein512-96': 0xb32c,
  'skein512-104': 0xb32d,
  'skein512-112': 0xb32e,
  'skein512-120': 0xb32f,
  'skein512-128': 0xb330,
  'skein512-136': 0xb331,
  'skein512-144': 0xb332,
  'skein512-152': 0xb333,
  'skein512-160': 0xb334,
  'skein512-168': 0xb335,
  'skein512-176': 0xb336,
  'skein512-184': 0xb337,
  'skein512-192': 0xb338,
  'skein512-200': 0xb339,
  'skein512-208': 0xb33a,
  'skein512-216': 0xb33b,
  'skein512-224': 0xb33c,
  'skein512-232': 0xb33d,
  'skein512-240': 0xb33e,
  'skein512-248': 0xb33f,
  'skein512-256': 0xb340,
  'skein512-264': 0xb341,
  'skein512-272': 0xb342,
  'skein512-280': 0xb343,
  'skein512-288': 0xb344,
  'skein512-296': 0xb345,
  'skein512-304': 0xb346,
  'skein512-312': 0xb347,
  'skein512-320': 0xb348,
  'skein512-328': 0xb349,
  'skein512-336': 0xb34a,
  'skein512-344': 0xb34b,
  'skein512-352': 0xb34c,
  'skein512-360': 0xb34d,
  'skein512-368': 0xb34e,
  'skein512-376': 0xb34f,
  'skein512-384': 0xb350,
  'skein512-392': 0xb351,
  'skein512-400': 0xb352,
  'skein512-408': 0xb353,
  'skein512-416': 0xb354,
  'skein512-424': 0xb355,
  'skein512-432': 0xb356,
  'skein512-440': 0xb357,
  'skein512-448': 0xb358,
  'skein512-456': 0xb359,
  'skein512-464': 0xb35a,
  'skein512-472': 0xb35b,
  'skein512-480': 0xb35c,
  'skein512-488': 0xb35d,
  'skein512-496': 0xb35e,
  'skein512-504': 0xb35f,
  'skein512-512': 0xb360,
  'skein1024-8': 0xb361,
  'skein1024-16': 0xb362,
  'skein1024-24': 0xb363,
  'skein1024-32': 0xb364,
  'skein1024-40': 0xb365,
  'skein1024-48': 0xb366,
  'skein1024-56': 0xb367,
  'skein1024-64': 0xb368,
  'skein1024-72': 0xb369,
  'skein1024-80': 0xb36a,
  'skein1024-88': 0xb36b,
  'skein1024-96': 0xb36c,
  'skein1024-104': 0xb36d,
  'skein1024-112': 0xb36e,
  'skein1024-120': 0xb36f,
  'skein1024-128': 0xb370,
  'skein1024-136': 0xb371,
  'skein1024-144': 0xb372,
  'skein1024-152': 0xb373,
  'skein1024-160': 0xb374,
  'skein1024-168': 0xb375,
  'skein1024-176': 0xb376,
  'skein1024-184': 0xb377,
  'skein1024-192': 0xb378,
  'skein1024-200': 0xb379,
  'skein1024-208': 0xb37a,
  'skein1024-216': 0xb37b,
  'skein1024-224': 0xb37c,
  'skein1024-232': 0xb37d,
  'skein1024-240': 0xb37e,
  'skein1024-248': 0xb37f,
  'skein1024-256': 0xb380,
  'skein1024-264': 0xb381,
  'skein1024-272': 0xb382,
  'skein1024-280': 0xb383,
  'skein1024-288': 0xb384,
  'skein1024-296': 0xb385,
  'skein1024-304': 0xb386,
  'skein1024-312': 0xb387,
  'skein1024-320': 0xb388,
  'skein1024-328': 0xb389,
  'skein1024-336': 0xb38a,
  'skein1024-344': 0xb38b,
  'skein1024-352': 0xb38c,
  'skein1024-360': 0xb38d,
  'skein1024-368': 0xb38e,
  'skein1024-376': 0xb38f,
  'skein1024-384': 0xb390,
  'skein1024-392': 0xb391,
  'skein1024-400': 0xb392,
  'skein1024-408': 0xb393,
  'skein1024-416': 0xb394,
  'skein1024-424': 0xb395,
  'skein1024-432': 0xb396,
  'skein1024-440': 0xb397,
  'skein1024-448': 0xb398,
  'skein1024-456': 0xb399,
  'skein1024-464': 0xb39a,
  'skein1024-472': 0xb39b,
  'skein1024-480': 0xb39c,
  'skein1024-488': 0xb39d,
  'skein1024-496': 0xb39e,
  'skein1024-504': 0xb39f,
  'skein1024-512': 0xb3a0,
  'skein1024-520': 0xb3a1,
  'skein1024-528': 0xb3a2,
  'skein1024-536': 0xb3a3,
  'skein1024-544': 0xb3a4,
  'skein1024-552': 0xb3a5,
  'skein1024-560': 0xb3a6,
  'skein1024-568': 0xb3a7,
  'skein1024-576': 0xb3a8,
  'skein1024-584': 0xb3a9,
  'skein1024-592': 0xb3aa,
  'skein1024-600': 0xb3ab,
  'skein1024-608': 0xb3ac,
  'skein1024-616': 0xb3ad,
  'skein1024-624': 0xb3ae,
  'skein1024-632': 0xb3af,
  'skein1024-640': 0xb3b0,
  'skein1024-648': 0xb3b1,
  'skein1024-656': 0xb3b2,
  'skein1024-664': 0xb3b3,
  'skein1024-672': 0xb3b4,
  'skein1024-680': 0xb3b5,
  'skein1024-688': 0xb3b6,
  'skein1024-696': 0xb3b7,
  'skein1024-704': 0xb3b8,
  'skein1024-712': 0xb3b9,
  'skein1024-720': 0xb3ba,
  'skein1024-728': 0xb3bb,
  'skein1024-736': 0xb3bc,
  'skein1024-744': 0xb3bd,
  'skein1024-752': 0xb3be,
  'skein1024-760': 0xb3bf,
  'skein1024-768': 0xb3c0,
  'skein1024-776': 0xb3c1,
  'skein1024-784': 0xb3c2,
  'skein1024-792': 0xb3c3,
  'skein1024-800': 0xb3c4,
  'skein1024-808': 0xb3c5,
  'skein1024-816': 0xb3c6,
  'skein1024-824': 0xb3c7,
  'skein1024-832': 0xb3c8,
  'skein1024-840': 0xb3c9,
  'skein1024-848': 0xb3ca,
  'skein1024-856': 0xb3cb,
  'skein1024-864': 0xb3cc,
  'skein1024-872': 0xb3cd,
  'skein1024-880': 0xb3ce,
  'skein1024-888': 0xb3cf,
  'skein1024-896': 0xb3d0,
  'skein1024-904': 0xb3d1,
  'skein1024-912': 0xb3d2,
  'skein1024-920': 0xb3d3,
  'skein1024-928': 0xb3d4,
  'skein1024-936': 0xb3d5,
  'skein1024-944': 0xb3d6,
  'skein1024-952': 0xb3d7,
  'skein1024-960': 0xb3d8,
  'skein1024-968': 0xb3d9,
  'skein1024-976': 0xb3da,
  'skein1024-984': 0xb3db,
  'skein1024-992': 0xb3dc,
  'skein1024-1000': 0xb3dd,
  'skein1024-1008': 0xb3de,
  'skein1024-1016': 0xb3df,
  'skein1024-1024': 0xb3e0,
  'poseidon-bls12_381-a2-fc1': 0xb401,
  'poseidon-bls12_381-a2-fc1-sc': 0xb402
})

module.exports = { names }

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js", {"./constants":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\constants.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","multibase":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js","varint":"F:\\metamask-extension\\node_modules\\varint\\index.js","web-encoding":"F:\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cmultihashes%5Csrc%5Cindex.js
      return function (require, module, exports) {
// @ts-check
/* eslint-disable guard-for-in */
/**
 * Multihash implementation in JavaScript.
 *
 * @module multihash
 */
'use strict'

const { Buffer } = require('buffer')
const multibase = require('multibase')
const varint = require('varint')
const { names } = require('./constants')
const { TextDecoder } = require('web-encoding')

const textDecoder = new TextDecoder()
const codes = {}

for (const key in names) {
  codes[names[key]] = key
}
exports.names = names
exports.codes = Object.freeze(codes)

/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toHexString = function toHexString (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  const buffer = Buffer.isBuffer(hash)
    ? hash
    : Buffer.from(hash.buffer, hash.byteOffset, hash.byteLength)

  return buffer.toString('hex')
}

/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Buffer}
 */
exports.fromHexString = function fromHexString (hash) {
  return Buffer.from(hash, 'hex')
}

/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */
exports.toB58String = function toB58String (hash) {
  if (!(hash instanceof Uint8Array)) {
    throw new Error('must be passed a Uint8Array')
  }

  return textDecoder.decode(multibase.encode('base58btc', hash)).slice(1)
}

/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Uint8Array} hash
 * @returns {Buffer}
 */
exports.fromB58String = function fromB58String (hash) {
  const encoded = hash instanceof Uint8Array
    ? textDecoder.decode(hash)
    : hash

  return multibase.decode('z' + encoded)
}

/**
 * Decode a hash from the given multihash.
 *
 * @param {Uint8Array} bytes
 * @returns {{code: number, name: string, length: number, digest: Buffer}} result
 */
exports.decode = function decode (bytes) {
  if (!(bytes instanceof Uint8Array)) {
    throw new Error('multihash must be a Uint8Array')
  }
  let buf = Buffer.isBuffer(bytes)
    ? bytes
    : Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength)

  if (buf.length < 2) {
    throw new Error('multihash too short. must be > 2 bytes.')
  }

  const code = varint.decode(buf)
  if (!exports.isValidCode(code)) {
    throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
  }
  buf = buf.slice(varint.decode.bytes)

  const len = varint.decode(buf)
  if (len < 0) {
    throw new Error(`multihash invalid length: ${len}`)
  }
  buf = buf.slice(varint.decode.bytes)

  if (buf.length !== len) {
    throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
  }

  return {
    code,
    name: codes[code],
    length: len,
    digest: buf
  }
}

/**
 *  Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Uint8Array} digest
 * @param {string|number} code
 * @param {number} [length]
 * @returns {Buffer}
 */
exports.encode = function encode (digest, code, length) {
  if (!digest || code === undefined) {
    throw new Error('multihash encode requires at least two args: digest, code')
  }

  // ensure it's a hashfunction code.
  const hashfn = exports.coerceCode(code)

  if (!(digest instanceof Uint8Array)) {
    throw new Error('digest should be a Uint8Array')
  }

  if (length == null) {
    length = digest.length
  }

  if (length && digest.length !== length) {
    throw new Error('digest length should be equal to specified length.')
  }

  const hash = varint.encode(hashfn)
  const len = varint.encode(length)
  const buffer = Buffer.alloc(hash.length + len.length + digest.length)
  buffer.set(hash, 0)
  buffer.set(len, hash.length)
  buffer.set(digest, hash.length + len.length)
  return buffer
}

/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 * @param {string|number} name
 * @returns {number}
 */
exports.coerceCode = function coerceCode (name) {
  let code = name

  if (typeof name === 'string') {
    if (names[name] === undefined) {
      throw new Error(`Unrecognized hash function named: ${name}`)
    }
    code = names[name]
  }

  if (typeof code !== 'number') {
    throw new Error(`Hash function code should be a number. Got: ${code}`)
  }

  if (codes[code] === undefined && !exports.isAppCode(code)) {
    throw new Error(`Unrecognized function code: ${code}`)
  }

  return code
}

/**
 * Checks wether a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isAppCode = function appCode (code) {
  return code > 0 && code < 0x10
}

/**
 * Checks whether a multihash code is valid.
 *
 * @param {number} code
 * @returns {boolean}
 */
exports.isValidCode = function validCode (code) {
  if (exports.isAppCode(code)) {
    return true
  }

  if (codes[code]) {
    return true
  }

  return false
}

/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {void}
 * @throws {Error}
 */
function validate (multihash) {
  exports.decode(multihash) // throws if bad.
}
exports.validate = validate

/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {Buffer}
 * @throws {Error}
 */
exports.prefix = function prefix (multihash) {
  validate(multihash)

  return Buffer.from(multihash.buffer, multihash.byteOffset, 2)
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multihashes",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cuint8arrays%5Cconcat.js
      return function (require, module, exports) {
'use strict'

/**
 * Returns a new Uint8Array created by concatenating the passed ArrayLikes
 *
 * @param {Array<ArrayLike<number>>} arrays
 * @param {Number} length
 * @returns {Uint8Array}
 */
function concat (arrays, length) {
  if (!length) {
    length = arrays.reduce((acc, curr) => acc + curr.length, 0)
  }

  const output = new Uint8Array(length)
  let offset = 0

  for (const arr of arrays) {
    output.set(arr, offset)
    offset += arr.length
  }

  return output
}

module.exports = concat

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\concat.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js", {"multibase/src/constants":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js","web-encoding":"F:\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cuint8arrays%5Cfrom-string.js
      return function (require, module, exports) {
'use strict'

const { names } = require('multibase/src/constants')
const { TextEncoder } = require('web-encoding')
const utf8Encoder = new TextEncoder()

/**
 * Interperets each character in a string as a byte and
 * returns a Uint8Array of those bytes.
 *
 * @param {String} string The string to turn into an array
 * @returns {Uint8Array}
 */
function asciiStringToUint8Array (string) {
  const array = new Uint8Array(string.length)

  for (let i = 0; i < string.length; i++) {
    array[i] = string.charCodeAt(i)
  }

  return array
}

/**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {String} string
 * @param {String} [encoding=utf8] utf8, base16, base64, base64urlpad, etc
 * @returns {Uint8Array}
 * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
 */
function fromString (string, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Encoder.encode(string)
  }

  if (encoding === 'ascii') {
    return asciiStringToUint8Array(string)
  }

  const codec = names[encoding]

  if (!codec) {
    throw new Error('Unknown base')
  }

  return codec.decode(string)
}

module.exports = fromString

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\from-string.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js", {"multibase/src/constants":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multibase\\src\\constants.js","web-encoding":"F:\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Cnode_modules%5Cuint8arrays%5Cto-string.js
      return function (require, module, exports) {
'use strict'

const { names } = require('multibase/src/constants')
const { TextDecoder } = require('web-encoding')
const utf8Decoder = new TextDecoder('utf8')

/**
 * Turns a Uint8Array of bytes into a string with each
 * character being the char code of the corresponding byte
 *
 * @param {Uint8Array} array The array to turn into a string
 * @returns {String}
 */
function uint8ArrayToAsciiString (array) {
  let string = ''

  for (let i = 0; i < array.length; i++) {
    string += String.fromCharCode(array[i])
  }
  return string
}

/**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {Uint8Array} array The array to turn into a string
 * @param {String} [encoding=utf8] The encoding to use
 * @returns {String}
 * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
 */
function toString (array, encoding = 'utf8') {
  if (encoding === 'utf8' || encoding === 'utf-8') {
    return utf8Decoder.decode(array)
  }

  if (encoding === 'ascii') {
    return uint8ArrayToAsciiString(array)
  }

  const codec = names[encoding]

  if (!codec) {
    throw new Error('Unknown base')
  }

  return codec.encode(array)
}

module.exports = toString

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash>multicodec>uint8arrays",file:"node_modules\\@ensdomains\\content-hash\\node_modules\\uint8arrays\\to-string.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js", {"cids":"F:\\metamask-extension\\node_modules\\cids\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Csrc%5Chelpers.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');

// Label's max length in DNS (https://tools.ietf.org/html/rfc1034#page-7)
const dnsLabelMaxLength = 63;

/**
 * Take any ipfsHash and convert it to DNS-compatible CID
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidForWeb = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
  let dnsLabel = cid.toString('base32');
  if (dnsLabel.length > dnsLabelMaxLength) {
    const b36 = cid.toString('base36');
    if (b36.length <= dnsLabelMaxLength) {
      return b36;
    }
    throw new TypeError ('CID is longer than DNS limit of 63 characters and is not compatible with public gateways');
  }
	return dnsLabel;
}

exports.cidForWeb = cidForWeb;


/**
 * Take any ipfsHash and convert it to a CID v1 encoded in base32.
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1 (v1 will remain unchanged)
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidV0ToV1Base32 = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
	return cid.toString('base32');
}

exports.cidV0ToV1Base32 = cidV0ToV1Base32;

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash",file:"node_modules\\@ensdomains\\content-hash\\src\\helpers.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\index.js", {"./helpers":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js","./profiles":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js","multicodec":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multicodec\\src\\index.js","multihashes":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Csrc%5Cindex.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const multiC = require('multicodec');
const multiH = require('multihashes');

const { hexStringToBuffer, profiles } = require('./profiles');
const { cidForWeb, cidV0ToV1Base32 } = require('./helpers');

module.exports = {

	//export some helpers functions
	helpers: {
		cidForWeb,
		cidV0ToV1Base32,
	},

	/**
	* Decode a Content Hash.
	* @param {string} hash an hex string containing a content hash
	* @return {string} the decoded content
	*/
	decode: function (contentHash) {
		const buffer = hexStringToBuffer(contentHash);
		const codec = multiC.getCodec(buffer);
		const value = multiC.rmPrefix(buffer);
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		return profile.decode(value);
	},

	/**
	* Encode an IPFS address into a content hash
	* @param {string} ipfsHash string containing an IPFS address
	* @return {string} the resulting content hash
	*/
	fromIpfs: function (ipfsHash) {
		return this.encode('ipfs-ns', ipfsHash);
	},

	/**
	* Encode a Skylink into a content hash
	* @param {string} skylink string containing a Skylink
	* @return {string} the resulting content hash
	*/
	fromSkylink: function (skylink) {
		return this.encode('skynet-ns', skylink);
	},

	/**
	* Encode a Swarm address into a content hash
	* @param {string} swarmHash string containing a Swarm address
	* @return {string} the resulting content hash
	*/
	fromSwarm: function (swarmHash) {
		return this.encode('swarm-ns', swarmHash);
	},

	/**
	* General purpose encoding function
  * @param {string} codec 
  * @param {string} value 
  */
	encode: function (codec, value) {
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		const encodedValue = profile.encode(value);
		return multiH.toHexString(multiC.addPrefix(codec, encodedValue))
	},

	/**
	* Extract the codec of a content hash
	* @param {string} hash hex string containing a content hash
	* @return {string} the extracted codec
	*/
	getCodec: function (hash) {
		let buffer = hexStringToBuffer(hash);
		return multiC.getCodec(buffer);
	},
}

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash",file:"node_modules\\@ensdomains\\content-hash\\src\\index.js",}],
["F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","cids":"F:\\metamask-extension\\node_modules\\cids\\src\\index.js","js-base64":"F:\\metamask-extension\\node_modules\\js-base64\\base64.js","multihashes":"F:\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@ensdomains%5Ccontent-hash%5Csrc%5Cprofiles.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');
const multiH = require('multihashes');
const base64 = require('js-base64')

/**
 * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'
 * @param {string} hex an hexadecimal value
 * @return {Buffer} the resulting Buffer
 */
const hexStringToBuffer = (hex) => {
	let prefix = hex.slice(0, 2);
	let value = hex.slice(2);
	let res = '';
	if (prefix === '0x') res = value;
	else res = hex;
	return multiH.fromHexString(res);
}

/**
 * Validates IPNS identifier  to safeguard against insecure names.
 * @param {CID} name ised in ipns-ns
 * @return {bool}
 */
const isCryptographicIPNS =  (cid) => {
  try {
    const { multihash } = cid
    // Additional check for identifiers shorter
    // than what inlined ED25519 pubkey would be
    // https://github.com/ensdomains/ens-app/issues/849#issuecomment-777088950
    if (multihash.length < 38) {
      const mh = multiH.decode(multihash)
      // ED25519 pubkeys are inlined using identity hash function
      // and we should not see anything shorter than that
      if (mh.name === 'identity' && mh.length < 36) {
        // One can read inlined string value via:
        // console.log('ipns-ns id:', String(multiH.decode(new CID(value).multihash).digest))
        return false
      }
    }
    // ok, CID looks fine
    return true
  } catch (_) { return false }
  return false
}

/**
* list of known encoding,
* encoding should be a function that takes a `string` input,
* and return a `Buffer` result
*/
const encodes = {
  /**
  * @param {string} value
  * @return {Buffer}
  */
  skynet: (value) => {
    return base64.toUint8Array(value)
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  swarm: (value) => {
    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');
		return new CID(1, 'swarm-manifest', multihash).bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipfs: (value) => {
    return new CID(value).toV1().bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipns: (value) => {
    const cid = new CID(value)
    if (!isCryptographicIPNS(cid)) {
        throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    // Represent IPNS name as a CID with libp2p-key codec
    // https://github.com/libp2p/specs/blob/master/RFC/0001-text-peerid-cid.md
    return new CID(1, 'libp2p-key', cid.multihash).bytes
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  utf8: (value) => {
    return Buffer.from(value, 'utf8');
  },
};

/** 
* list of known decoding,
* decoding should be a function that takes a `Buffer` input,
* and return a `string` result
*/
const decodes = {
  /**
  * @param {Buffer} value 
  */
  hexMultiHash: (value) => {
    const cid = new CID(value);
    return multiH.decode(cid.multihash).digest.toString('hex');
  },
  /**
  * @param {Buffer} value 
  */
  ipfs: (value) => {
    const cid = new CID(value).toV1();
    return cid.toString(cid.codec === 'libp2p-key' ? 'base36' : 'base32')
  },
  /**
  * @param {Buffer} value 
  */
  ipns: (value) => {
    const cid = new CID(value).toV1()
    if (!isCryptographicIPNS(cid)) {
        // Value is not a libp2p-key, return original string
        console.warn('[ensdomains/content-hash] use of non-cryptographic identifiers in ipns-ns is deprecated and will be removed, migrate to ED25519 libp2p-key')
        return String(multiH.decode(new CID(value).multihash).digest)
        // TODO: start throwing an error (after some deprecation period)
        // throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    return cid.toString('base36')
  },
  /**
  * @param {Buffer} value 
  */
  utf8: (value) => {
    return value.toString('utf8');
  },
  base64: (value) => {
    // `true` option makes it URL safe (replaces / and + with - and _ )
    return base64.fromUint8Array(value, true)
  }
};

/**
* list of known encoding/decoding for a given codec,
* `encode` should be chosen among the `encodes` functions
* `decode` should be chosen among the `decodes` functions
*/
const profiles = {
  'skynet-ns': {
    encode: encodes.skynet,
    decode: decodes.base64,
  },
  'swarm-ns': {
    encode: encodes.swarm,
    decode: decodes.hexMultiHash,
  },
  'ipfs-ns': {
    encode: encodes.ipfs,
    decode: decodes.ipfs,
  },
  'ipns-ns': {
    encode: encodes.ipns,
    decode: decodes.ipns,
  },
  'default': {
    encode: encodes.utf8,
    decode: decodes.utf8,
  },
};

exports.hexStringToBuffer = hexStringToBuffer;
exports.profiles = profiles;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@ensdomains/content-hash",file:"node_modules\\@ensdomains\\content-hash\\src\\profiles.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js", {"@ethereumjs/tx":"F:\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"F:\\metamask-extension\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"F:\\metamask-extension\\node_modules\\hdkey\\lib\\hdkey.js","rlp":"F:\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js","uuid":"F:\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cdist%5Cbase-eth-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var HDKey = _interopDefault(require('hdkey'));
var util = require('@ethereumjs/util');
var rlp = _interopDefault(require('rlp'));
var tx = require('@ethereumjs/tx');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');

const keyringType = "QR Hardware Wallet Device";
const pathBase = "m";
const MAX_INDEX = 1000;
const DEFAULT_CHILDREN_PATH = "0/*";
var KEYRING_MODE;

(function (KEYRING_MODE) {
  KEYRING_MODE["hd"] = "hd";
  KEYRING_MODE["pubkey"] = "pubkey";
})(KEYRING_MODE || (KEYRING_MODE = {}));

var KEYRING_ACCOUNT;

(function (KEYRING_ACCOUNT) {
  KEYRING_ACCOUNT["standard"] = "account.standard";
  KEYRING_ACCOUNT["ledger_live"] = "account.ledger_live";
  KEYRING_ACCOUNT["ledger_legacy"] = "account.ledger_legacy";
})(KEYRING_ACCOUNT || (KEYRING_ACCOUNT = {}));

class BaseKeyring {
  constructor(opts) {
    // @ts-ignore
    this.version = 1;

    this.getInteraction = () => {
      throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.");
    };

    this.type = keyringType;

    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {
      const ethSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
      const requestIdBuffer = ethSignature.getRequestId();
      const signature = ethSignature.getSignature();

      if (requestIdBuffer) {
        const requestId = uuid.stringify(requestIdBuffer);

        if (requestId !== _requestId) {
          throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");
        }
      }

      const r = signature.slice(0, 32);
      const s = signature.slice(32, 64);
      const v = signature.slice(64);
      return {
        r,
        s,
        v
      };
    };

    this.__readCryptoHDKey = cryptoHDKey => {
      var _cryptoHDKey$getOrigi, _cryptoHDKey$getChild;

      const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;
      const xfp = (_cryptoHDKey$getOrigi = cryptoHDKey.getOrigin().getSourceFingerprint()) == null ? void 0 : _cryptoHDKey$getOrigi.toString("hex");
      const childrenPath = ((_cryptoHDKey$getChild = cryptoHDKey.getChildren()) == null ? void 0 : _cryptoHDKey$getChild.getPath()) || DEFAULT_CHILDREN_PATH;
      const name = cryptoHDKey.getName();

      if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.standard) {
        this.keyringAccount = KEYRING_ACCOUNT.standard;
      } else if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_legacy) {
        this.keyringAccount = KEYRING_ACCOUNT.ledger_legacy;
      }

      if (!xfp) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");
      }

      const xpub = cryptoHDKey.getBip32Key();
      this.xfp = xfp;
      this.xpub = xpub;
      this.hdPath = hdPath;
      this.childrenPath = childrenPath;

      if (name !== undefined && name !== "") {
        this.name = name;
      }

      this.initialized = true;
    };

    this.__readCryptoAccount = cryptoAccount => {
      var _cryptoAccount$getMas, _cryptoAccount$getOut;

      const xfp = (_cryptoAccount$getMas = cryptoAccount.getMasterFingerprint()) == null ? void 0 : _cryptoAccount$getMas.toString("hex");

      if (!xfp) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");
      }

      this.xfp = xfp;
      this.initialized = true;
      let changed = false;
      const outputs = cryptoAccount.getOutputDescriptors();

      if (!outputs || outputs.length === 0) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");
      }

      if (outputs.length % 5 !== 0) {
        throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");
      }

      (_cryptoAccount$getOut = cryptoAccount.getOutputDescriptors()) == null ? void 0 : _cryptoAccount$getOut.forEach(od => {
        try {
          const cryptoHDKey = od.getHDKey();

          if (cryptoHDKey) {
            const key = cryptoHDKey.getKey();
            const path = `M/${cryptoHDKey.getOrigin().getPath()}`;
            const address = "0x" + util.publicToAddress(key, true).toString("hex");
            this.name = cryptoHDKey.getName();

            if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_live) {
              this.keyringAccount = KEYRING_ACCOUNT.ledger_live;
            }

            if (this.paths[util.toChecksumAddress(address)] === undefined) {
              changed = true;
            }

            this.paths[util.toChecksumAddress(address)] = path;
          }
        } catch (e) {
          throw new Error(`KeystoneError#invalid_data: ${e}`);
        }
      });
      return changed;
    }; // private __readLedgerLiveAccounts = async () => {
    //     const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    //     if (result.getRegistryType() === extend.RegistryTypes.CRYPTO_ACCOUNT) {
    //         const changed = this.__readCryptoAccount(result as CryptoAccount);
    //         if (!changed) {
    //             throw new Error(`#KeystoneError#pubkey_account.no_new_account`);
    //         }
    //     } else {
    //         throw new Error(`KeystoneError#pubkey_account.unexpected_urtype`);
    //     }
    // };


    this.getName = () => {
      return this.name;
    };

    this.setAccountToUnlock = index => {
      this.unlockedAccount = parseInt(index, 10);
    };

    this.__getNormalPage = async increment => {
      this.page += increment;

      if (this.page <= 0) {
        this.page = 1;
      }

      const from = (this.page - 1) * this.perPage;
      const to = from + this.perPage;
      const accounts = [];

      for (let i = from; i < to; i++) {
        const address = await this.__addressFromIndex(pathBase, i);
        accounts.push({
          address,
          balance: null,
          index: i
        });
        this.indexes[util.toChecksumAddress(address)] = i;
      }

      return accounts;
    };

    this.__getLedgerLivePage = async increment => {
      const nextPage = this.page + increment;
      const from = (nextPage - 1) * this.perPage;
      const to = from + this.perPage;
      const accounts = [];

      for (let i = from; i < to; i++) {
        const address = await this.__addressFromIndex(pathBase, i);
        accounts.push({
          address,
          balance: null,
          index: i
        });
      }

      this.page += increment;
      return accounts;
    };

    this.__addressFromIndex = async (pb, i) => {
      if (this.keyringMode === KEYRING_MODE.hd) {
        this.checkKeyring();

        if (!this.hdk) {
          // @ts-ignore
          this.hdk = HDKey.fromExtendedKey(this.xpub);
        }

        const childrenPath = this.childrenPath.replace("*", String(i)).replace(/\*/g, "0");
        const dkey = this.hdk.derive(`${pb}/${childrenPath}`);
        const address = "0x" + util.publicToAddress(dkey.publicKey, true).toString("hex");
        return util.toChecksumAddress(address);
      } else {
        const result = Object.keys(this.paths)[i];

        if (result) {
          return util.toChecksumAddress(result);
        } else {
          throw new Error(`KeystoneError#pubkey_account.no_expected_account`);
        }
      }
    }; //common props


    this.page = 0;
    this.perPage = 5;
    this.accounts = [];
    this.currentAccount = 0;
    this.unlockedAccount = 0;
    this.name = "QR Hardware";
    this.keyringMode = KEYRING_MODE.hd;
    this.keyringAccount = KEYRING_ACCOUNT.standard;
    this.initialized = false; //hd props;

    this.xfp = "";
    this.xpub = "";
    this.hdPath = "";
    this.childrenPath = DEFAULT_CHILDREN_PATH;
    this.indexes = {}; //pubkey props;

    this.paths = {};
    this.deserialize(opts);
  } //initial read


  async readKeyring() {
    const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    this.syncKeyring(result);
  }

  syncKeyring(data) {
    if (data.getRegistryType().getType() === bcUrRegistryEth.extend.RegistryTypes.CRYPTO_HDKEY.getType()) {
      this.keyringMode = KEYRING_MODE.hd;

      this.__readCryptoHDKey(data);
    } else {
      this.keyringMode = KEYRING_MODE.pubkey;

      this.__readCryptoAccount(data);
    }
  }

  checkKeyring() {
    if (!this.xfp || !this.xpub || !this.hdPath) {
      throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly");
    }
  }

  serialize() {
    return Promise.resolve({
      //common
      initialized: this.initialized,
      accounts: this.accounts,
      currentAccount: this.currentAccount,
      page: this.page,
      perPage: this.perPage,
      keyringAccount: this.keyringAccount,
      keyringMode: this.keyringMode,
      name: this.name,
      version: this.version,
      xfp: this.xfp,
      //hd
      xpub: this.xpub,
      hdPath: this.hdPath,
      childrenPath: this.childrenPath,
      indexes: this.indexes,
      //pubkey
      paths: this.paths
    });
  }

  deserialize(opts) {
    if (opts) {
      //common props;
      this.accounts = opts.accounts;
      this.currentAccount = opts.currentAccount;
      this.page = opts.page;
      this.perPage = opts.perPage;
      this.name = opts.name;
      this.initialized = opts.initialized;
      this.keyringMode = opts.keyringMode || KEYRING_MODE.hd;
      this.keyringAccount = opts.keyringAccount || KEYRING_ACCOUNT.standard;
      this.xfp = opts.xfp; //hd props;

      this.xpub = opts.xpub;
      this.hdPath = opts.hdPath;
      this.indexes = opts.indexes;
      this.paths = opts.paths;
      this.childrenPath = opts.childrenPath || DEFAULT_CHILDREN_PATH;
    }
  }

  setCurrentAccount(index) {
    this.currentAccount = index;
  }

  getCurrentAccount() {
    return this.currentAccount;
  }

  getCurrentAddress() {
    return this.accounts[this.currentAccount];
  }

  async addAccounts(n = 1) {
    const from = this.unlockedAccount;
    const to = from + n;
    const newAccounts = [];

    for (let i = from; i < to; i++) {
      const address = await this.__addressFromIndex(pathBase, i);
      newAccounts.push(address);
      this.page = 0;
      this.unlockedAccount++;
    }

    this.accounts = this.accounts.concat(newAccounts);
    return this.accounts;
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  async __getPage(increment) {
    if (!this.initialized) {
      await this.readKeyring();
    }

    if (this.keyringMode === KEYRING_MODE.hd) {
      return this.__getNormalPage(increment);
    } else {
      return this.__getLedgerLivePage(increment);
    }
  }

  getAccounts() {
    return Promise.resolve(this.accounts);
  }

  removeAccount(address) {
    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
  }

  async signTransaction(address, tx$1) {
    const dataType = tx$1.type === 0 ? bcUrRegistryEth.DataType.transaction : bcUrRegistryEth.DataType.typedTransaction;
    let messageToSign;

    if (tx$1.type === 0) {
      messageToSign = Buffer.from(rlp.encode(tx$1.getMessageToSign(false)));
    } else {
      messageToSign = tx$1.getMessageToSign(false);
    }

    const hdPath = await this._pathFromAddress(address);
    const chainId = Number(tx$1.common.chainId());
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(messageToSign, dataType, hdPath, this.xfp, requestId, chainId);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    return tx.TransactionFactory.fromTxData({ ...tx$1.toJSON(),
      type: tx$1.type,
      r,
      s,
      v
    }, {
      common: tx$1.common
    });
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  async signPersonalMessage(withAccount, messageHex) {
    const usignedHex = util.stripHexPrefix(messageHex);
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(usignedHex, "hex"), bcUrRegistryEth.DataType.personalMessage, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
    return "0x" + Buffer.concat([r, s, v]).toString("hex");
  }

  async signTypedData(withAccount, typedData) {
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(typedData), "utf-8"), bcUrRegistryEth.DataType.typedData, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');
    return "0x" + Buffer.concat([r, s, v]).toString("hex");
  }

  async _pathFromAddress(address) {
    if (this.keyringMode === KEYRING_MODE.hd) {
      const checksummedAddress = util.toChecksumAddress(address);
      let index = this.indexes[checksummedAddress];

      if (typeof index === "undefined") {
        for (let i = 0; i < MAX_INDEX; i++) {
          if (checksummedAddress === (await this.__addressFromIndex(pathBase, i))) {
            index = i;
            break;
          }
        }
      }

      if (typeof index === "undefined") {
        throw new Error("Unknown address");
      }

      return `${this.hdPath}/${this.childrenPath.replace("*", index.toString()).replace(/\*/g, "0")}`;
    } else {
      const checksummedAddress = util.toChecksumAddress(address);
      const path = this.paths[checksummedAddress];

      if (typeof path === "undefined") {
        throw new Error("Unknown address");
      }

      return path;
    }
  }

}
BaseKeyring.type = keyringType;

exports.BaseKeyring = BaseKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",file:"node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js", {"@ethereumjs/tx":"F:\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"F:\\metamask-extension\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"F:\\metamask-extension\\node_modules\\hdkey\\lib\\hdkey.js","rlp":"F:\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js","uuid":"F:\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cdist%5Cbase-eth-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t,r,i=e(require("hdkey")),s=require("@ethereumjs/util"),n=e(require("rlp")),a=require("@ethereumjs/tx"),o=require("@keystonehq/bc-ur-registry-eth"),h=require("uuid");!function(e){e.hd="hd",e.pubkey="pubkey"}(t||(t={})),function(e){e.standard="account.standard",e.ledger_live="account.ledger_live",e.ledger_legacy="account.ledger_legacy"}(r||(r={}));class c{constructor(e){this.version=1,this.getInteraction=()=>{throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.")},this.type="QR Hardware Wallet Device",this.requestSignature=async(e,t,r,i)=>{const s=await this.getInteraction().requestSignature(t,r,i),n=s.getRequestId(),a=s.getSignature();if(n&&h.stringify(n)!==e)throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");return{r:a.slice(0,32),s:a.slice(32,64),v:a.slice(64)}},this.__readCryptoHDKey=e=>{var t,i;const s="m/"+e.getOrigin().getPath(),n=null==(t=e.getOrigin().getSourceFingerprint())?void 0:t.toString("hex"),a=(null==(i=e.getChildren())?void 0:i.getPath())||"0/*",o=e.getName();if(e.getNote()===r.standard?this.keyringAccount=r.standard:e.getNote()===r.ledger_legacy&&(this.keyringAccount=r.ledger_legacy),!n)throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");const h=e.getBip32Key();this.xfp=n,this.xpub=h,this.hdPath=s,this.childrenPath=a,void 0!==o&&""!==o&&(this.name=o),this.initialized=!0},this.__readCryptoAccount=e=>{var t,i;const n=null==(t=e.getMasterFingerprint())?void 0:t.toString("hex");if(!n)throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");this.xfp=n,this.initialized=!0;let a=!1;const o=e.getOutputDescriptors();if(!o||0===o.length)throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");if(o.length%5!=0)throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");return null==(i=e.getOutputDescriptors())||i.forEach(e=>{try{const t=e.getHDKey();if(t){const e=t.getKey(),i="M/"+t.getOrigin().getPath(),n="0x"+s.publicToAddress(e,!0).toString("hex");this.name=t.getName(),t.getNote()===r.ledger_live&&(this.keyringAccount=r.ledger_live),void 0===this.paths[s.toChecksumAddress(n)]&&(a=!0),this.paths[s.toChecksumAddress(n)]=i}}catch(e){throw new Error("KeystoneError#invalid_data: "+e)}}),a},this.getName=()=>this.name,this.setAccountToUnlock=e=>{this.unlockedAccount=parseInt(e,10)},this.__getNormalPage=async e=>{this.page+=e,this.page<=0&&(this.page=1);const t=(this.page-1)*this.perPage,r=t+this.perPage,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push({address:t,balance:null,index:e}),this.indexes[s.toChecksumAddress(t)]=e}return i},this.__getLedgerLivePage=async e=>{const t=(this.page+e-1)*this.perPage,r=t+this.perPage,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push({address:t,balance:null,index:e})}return this.page+=e,i},this.__addressFromIndex=async(e,r)=>{if(this.keyringMode===t.hd){this.checkKeyring(),this.hdk||(this.hdk=i.fromExtendedKey(this.xpub));const t=this.childrenPath.replace("*",String(r)).replace(/\*/g,"0"),n=this.hdk.derive(`${e}/${t}`),a="0x"+s.publicToAddress(n.publicKey,!0).toString("hex");return s.toChecksumAddress(a)}{const e=Object.keys(this.paths)[r];if(e)return s.toChecksumAddress(e);throw new Error("KeystoneError#pubkey_account.no_expected_account")}},this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.unlockedAccount=0,this.name="QR Hardware",this.keyringMode=t.hd,this.keyringAccount=r.standard,this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.childrenPath="0/*",this.indexes={},this.paths={},this.deserialize(e)}async readKeyring(){const e=await this.getInteraction().readCryptoHDKeyOrCryptoAccount();this.syncKeyring(e)}syncKeyring(e){e.getRegistryType().getType()===o.extend.RegistryTypes.CRYPTO_HDKEY.getType()?(this.keyringMode=t.hd,this.__readCryptoHDKey(e)):(this.keyringMode=t.pubkey,this.__readCryptoAccount(e))}checkKeyring(){if(!this.xfp||!this.xpub||!this.hdPath)throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly")}serialize(){return Promise.resolve({initialized:this.initialized,accounts:this.accounts,currentAccount:this.currentAccount,page:this.page,perPage:this.perPage,keyringAccount:this.keyringAccount,keyringMode:this.keyringMode,name:this.name,version:this.version,xfp:this.xfp,xpub:this.xpub,hdPath:this.hdPath,childrenPath:this.childrenPath,indexes:this.indexes,paths:this.paths})}deserialize(e){e&&(this.accounts=e.accounts,this.currentAccount=e.currentAccount,this.page=e.page,this.perPage=e.perPage,this.name=e.name,this.initialized=e.initialized,this.keyringMode=e.keyringMode||t.hd,this.keyringAccount=e.keyringAccount||r.standard,this.xfp=e.xfp,this.xpub=e.xpub,this.hdPath=e.hdPath,this.indexes=e.indexes,this.paths=e.paths,this.childrenPath=e.childrenPath||"0/*")}setCurrentAccount(e){this.currentAccount=e}getCurrentAccount(){return this.currentAccount}getCurrentAddress(){return this.accounts[this.currentAccount]}async addAccounts(e=1){const t=this.unlockedAccount,r=t+e,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push(t),this.page=0,this.unlockedAccount++}return this.accounts=this.accounts.concat(i),this.accounts}getFirstPage(){return this.page=0,this.__getPage(1)}getNextPage(){return this.__getPage(1)}getPreviousPage(){return this.__getPage(-1)}async __getPage(e){return this.initialized||await this.readKeyring(),this.keyringMode===t.hd?this.__getNormalPage(e):this.__getLedgerLivePage(e)}getAccounts(){return Promise.resolve(this.accounts)}removeAccount(e){if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())}async signTransaction(e,t){const r=0===t.type?o.DataType.transaction:o.DataType.typedTransaction;let i;i=0===t.type?Buffer.from(n.encode(t.getMessageToSign(!1))):t.getMessageToSign(!1);const s=await this._pathFromAddress(e),c=Number(t.common.chainId()),d=h.v4(),u=o.EthSignRequest.constructETHRequest(i,r,s,this.xfp,d,c),{r:g,s:y,v:p}=await this.requestSignature(d,u,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');return a.TransactionFactory.fromTxData({...t.toJSON(),type:t.type,r:g,s:y,v:p},{common:t.common})}signMessage(e,t){return this.signPersonalMessage(e,t)}async signPersonalMessage(e,t){const r=s.stripHexPrefix(t),i=await this._pathFromAddress(e),n=h.v4(),a=o.EthSignRequest.constructETHRequest(Buffer.from(r,"hex"),o.DataType.personalMessage,i,this.xfp,n,void 0,e),{r:c,s:d,v:u}=await this.requestSignature(n,a,"Scan with your Keystone",'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([c,d,u]).toString("hex")}async signTypedData(e,t){const r=await this._pathFromAddress(e),i=h.v4(),s=o.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(t),"utf-8"),o.DataType.typedData,r,this.xfp,i,void 0,e),{r:n,s:a,v:c}=await this.requestSignature(i,s,"Scan with your Keystone",'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([n,a,c]).toString("hex")}async _pathFromAddress(e){if(this.keyringMode===t.hd){const t=s.toChecksumAddress(e);let r=this.indexes[t];if(void 0===r)for(let e=0;e<1e3;e++)if(t===await this.__addressFromIndex("m",e)){r=e;break}if(void 0===r)throw new Error("Unknown address");return`${this.hdPath}/${this.childrenPath.replace("*",r.toString()).replace(/\*/g,"0")}`}{const t=s.toChecksumAddress(e),r=this.paths[t];if(void 0===r)throw new Error("Unknown address");return r}}}c.type="QR Hardware Wallet Device",exports.BaseKeyring=c;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",file:"node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js", {"./base-eth-keyring.cjs.development.js":"F:\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js","./base-eth-keyring.cjs.production.min.js":"F:\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cdist%5Cindex.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./base-eth-keyring.cjs.production.min.js')
} else {
  module.exports = require('./base-eth-keyring.cjs.development.js')
}

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",file:"node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cbase-eth-keyring%5Cnode_modules%5Crlp%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.decode = exports.encode = void 0;
/**
 * RLP Encoding based on https://eth.wiki/en/fundamentals/rlp
 * This function takes in data, converts it to Uint8Array if not,
 * and adds a length for recursion.
 * @param input Will be converted to Uint8Array
 * @returns Uint8Array of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        for (let i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        const buf = concatBytes(...output);
        return concatBytes(encodeLength(buf.length, 192), buf);
    }
    const inputBuf = toBytes(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
    }
    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
exports.encode = encode;
/**
 * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.
 * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.
 * @param input
 * @param start
 * @param end
 */
function safeSlice(input, start, end) {
    if (end > input.length) {
        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');
    }
    return input.slice(start, end);
}
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 */
function decodeLength(v) {
    if (v[0] === 0) {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
    if (!input || input.length === 0) {
        return Uint8Array.from([]);
    }
    const inputBytes = toBytes(input);
    const decoded = _decode(inputBytes);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid RLP: remainder must be zero');
    }
    return decoded.data;
}
exports.decode = decode;
/** Decode an input with RLP */
function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Uint8Array.from([]);
        }
        else {
            data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = safeSlice(input, llength, length + llength);
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between 0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list over 55 bytes long
        llength = firstByte - 0xf6;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
            throw new Error('invalid RLP: encoded list too short');
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid RLP: total length is larger than the data');
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
const cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    // Pre-caching chars with `cachedHexes` speeds this up 6x
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
    }
    return hex;
}
function parseHexByte(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
        throw new Error('Invalid byte sequence');
    return byte;
}
// Caching slows it down 2-3x
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
}
/** Concatenates two Uint8Arrays into one. */
function concatBytes(...arrays) {
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function utf8ToBytes(utf) {
    return new TextEncoder().encode(utf);
}
/** Transform an integer into its hexadecimal value */
function numberToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.length >= 2 && str[0] === '0' && str[1] === 'x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform anything into a Uint8Array */
function toBytes(v) {
    if (v instanceof Uint8Array) {
        return v;
    }
    if (typeof v === 'string') {
        if (isHexPrefixed(v)) {
            return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
    }
    if (typeof v === 'number' || typeof v === 'bigint') {
        if (!v) {
            return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
    }
    if (v === null || v === undefined) {
        return Uint8Array.from([]);
    }
    throw new Error('toBytes: received unsupported type ' + typeof v);
}
exports.utils = {
    bytesToHex,
    concatBytes,
    hexToBytes,
    utf8ToBytes,
};
const RLP = { encode, decode };
exports.default = RLP;
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>rlp",file:"node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js", {"./metamask-airgapped-keyring.cjs.development.js":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js","./metamask-airgapped-keyring.cjs.production.min.js":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cdist%5Cindex.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./metamask-airgapped-keyring.cjs.production.min.js')
} else {
  module.exports = require('./metamask-airgapped-keyring.cjs.development.js')
}

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js", {"@ethereumjs/tx":"F:\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@keystonehq/base-eth-keyring":"F:\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"F:\\metamask-extension\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","@metamask/obs-store":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","rlp":"F:\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","uuid":"F:\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cdist%5Cmetamask-airgapped-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var baseEthKeyring = require('@keystonehq/base-eth-keyring');
var events = require('events');
var obsStore = require('@metamask/obs-store');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');
var tx = require('@ethereumjs/tx');
var rlp = _interopDefault(require('rlp'));

class MetamaskInteractionProvider extends events.EventEmitter {
  constructor() {
    super();

    this.cleanSyncListeners = () => {
      this.removeAllListeners("keystone-sync_success-hdkey");
      this.removeAllListeners("keystone-sync_success-account");
      this.removeAllListeners("keystone-sync_cancel");
    };

    this.cleanSignListeners = requestId => {
      this.removeAllListeners(`${requestId}-signed`);
      this.removeAllListeners(`${requestId}-canceled`);
    };

    this.readCryptoHDKeyOrCryptoAccount = () => {
      return new Promise((resolve, reject) => {
        this.memStore.updateState({
          sync: {
            reading: true
          }
        });
        this.on("keystone-sync_success-hdkey", cbor => {
          const cryptoHDKey = bcUrRegistryEth.CryptoHDKey.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(cryptoHDKey);
        });
        this.on("keystone-sync_success-account", cbor => {
          const cryptoAccount = bcUrRegistryEth.CryptoAccount.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(cryptoAccount);
        });
        this.on("keystone-sync_cancel", () => {
          this.resetState();
          reject(new Error("KeystoneError#sync_cancel. Sync process canceled, please retry"));
        });
      });
    };

    this.submitCryptoHDKey = cbor => {
      this.emit("keystone-sync_success-hdkey", cbor);
    };

    this.submitCryptoAccount = cbor => {
      this.emit("keystone-sync_success-account", cbor);
    };

    this.cancelSync = () => {
      this.emit("keystone-sync_cancel");
    };

    this.requestSignature = (signRequest, requestTitle, requestDescription) => {
      return new Promise((resolve, reject) => {
        const ur = signRequest.toUR();
        const requestIdBuffer = signRequest.getRequestId();
        const requestId = uuid.stringify(requestIdBuffer);
        const signPayload = {
          requestId,
          payload: {
            type: ur.type,
            cbor: ur.cbor.toString("hex")
          },
          title: requestTitle,
          description: requestDescription
        };
        this.memStore.updateState({
          sign: {
            request: signPayload
          }
        });
        this.once(`${requestId}-signed`, cbor => {
          const ethSignature = bcUrRegistryEth.ETHSignature.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(ethSignature);
        });
        this.once(`${requestId}-canceled`, () => {
          this.resetState();
          reject(new Error("KeystoneError#Tx_canceled. Signing canceled, please retry"));
        });
      });
    };

    this.submitSignature = (requestId, cbor) => {
      this.emit(`${requestId}-signed`, cbor);
    };

    this.cancelRequestSignature = () => {
      const signPayload = this.memStore.getState().sign.request;

      if (signPayload) {
        const {
          requestId
        } = signPayload;
        this.memStore.updateState({
          sign: {}
        });
        this.emit(`${requestId}-canceled`);
      }
    };

    this.reset = () => {
      this.cleanSyncListeners();
      const signPayload = this.memStore.getState().sign.request;

      if (signPayload) {
        const {
          requestId
        } = signPayload;
        this.cleanSignListeners(requestId);
      }

      this.resetState();
    };

    this.resetState = () => {
      this.memStore.updateState({
        sync: {
          reading: false
        },
        sign: {}
      });
    };

    if (MetamaskInteractionProvider.instance) {
      return MetamaskInteractionProvider.instance;
    }

    this.memStore = new obsStore.ObservableStore({
      sync: {
        reading: false
      },
      sign: {},
      _version: 1
    });
    MetamaskInteractionProvider.instance = this;
  }

}

class MetaMaskKeyring extends baseEthKeyring.BaseKeyring {
  constructor(opts) {
    super(opts);

    this.getInteraction = () => {
      return new MetamaskInteractionProvider();
    };

    this.resetStore = () => {
      this.getInteraction().reset();
    };

    this.getMemStore = () => {
      return this.getInteraction().memStore;
    };

    this.removeAccount = address => {
      if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
        throw new Error(`Address ${address} not found in this keyring`);
      }

      this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
    };

    this.forgetDevice = () => {
      //common props
      this.page = 0;
      this.perPage = 5;
      this.accounts = [];
      this.currentAccount = 0;
      this.name = "QR Hardware";
      this.initialized = false; //hd props;

      this.xfp = "";
      this.xpub = "";
      this.hdPath = "";
      this.indexes = {};
      this.hdk = undefined; //pubkey props;

      this.paths = {};
    };

    this.submitCryptoHDKey = this.getInteraction().submitCryptoHDKey;
    this.submitCryptoAccount = this.getInteraction().submitCryptoAccount;
    this.submitSignature = this.getInteraction().submitSignature;
    this.cancelSync = this.getInteraction().cancelSync;
    this.cancelSignRequest = this.getInteraction().cancelRequestSignature;

    if (MetaMaskKeyring.instance) {
      MetaMaskKeyring.instance.deserialize(opts);
      return MetaMaskKeyring.instance;
    }

    MetaMaskKeyring.instance = this;
  }

  async signTransaction(address, tx$1) {
    const dataType = tx$1.type === 0 ? bcUrRegistryEth.DataType.transaction : bcUrRegistryEth.DataType.typedTransaction;
    let messageToSign;

    if (tx$1.type === 0) {
      messageToSign = rlp.encode(tx$1.getMessageToSign(false));
    } else {
      messageToSign = tx$1.getMessageToSign(false);
    }

    const hdPath = await this._pathFromAddress(address);
    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(messageToSign, dataType, hdPath, this.xfp, requestId, chainId, address);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    const txJson = tx$1.toJSON();
    txJson.v = v;
    txJson.s = s;
    txJson.r = r;
    txJson.type = tx$1.type;
    const transaction = tx.TransactionFactory.fromTxData(txJson, {
      common: tx$1.common
    });
    return transaction;
  }

}
MetaMaskKeyring.type = baseEthKeyring.BaseKeyring.type;

exports.MetaMaskKeyring = MetaMaskKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js", {"@ethereumjs/tx":"F:\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@keystonehq/base-eth-keyring":"F:\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"F:\\metamask-extension\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","@metamask/obs-store":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","rlp":"F:\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","uuid":"F:\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cdist%5Cmetamask-airgapped-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=require("@keystonehq/base-eth-keyring"),s=require("events"),n=require("@metamask/obs-store"),i=require("@keystonehq/bc-ur-registry-eth"),r=require("uuid"),c=require("@ethereumjs/tx"),o=(e=require("rlp"))&&"object"==typeof e&&"default"in e?e.default:e;class a extends s.EventEmitter{constructor(){if(super(),this.cleanSyncListeners=()=>{this.removeAllListeners("keystone-sync_success-hdkey"),this.removeAllListeners("keystone-sync_success-account"),this.removeAllListeners("keystone-sync_cancel")},this.cleanSignListeners=e=>{this.removeAllListeners(e+"-signed"),this.removeAllListeners(e+"-canceled")},this.readCryptoHDKeyOrCryptoAccount=()=>new Promise((e,t)=>{this.memStore.updateState({sync:{reading:!0}}),this.on("keystone-sync_success-hdkey",t=>{const s=i.CryptoHDKey.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_success-account",t=>{const s=i.CryptoAccount.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_cancel",()=>{this.resetState(),t(new Error("KeystoneError#sync_cancel. Sync process canceled, please retry"))})}),this.submitCryptoHDKey=e=>{this.emit("keystone-sync_success-hdkey",e)},this.submitCryptoAccount=e=>{this.emit("keystone-sync_success-account",e)},this.cancelSync=()=>{this.emit("keystone-sync_cancel")},this.requestSignature=(e,t,s)=>new Promise((n,c)=>{const o=e.toUR(),a=e.getRequestId(),h=r.stringify(a),u={requestId:h,payload:{type:o.type,cbor:o.cbor.toString("hex")},title:t,description:s};this.memStore.updateState({sign:{request:u}}),this.once(h+"-signed",e=>{const t=i.ETHSignature.fromCBOR(Buffer.from(e,"hex"));this.resetState(),n(t)}),this.once(h+"-canceled",()=>{this.resetState(),c(new Error("KeystoneError#Tx_canceled. Signing canceled, please retry"))})}),this.submitSignature=(e,t)=>{this.emit(e+"-signed",t)},this.cancelRequestSignature=()=>{const e=this.memStore.getState().sign.request;if(e){const{requestId:t}=e;this.memStore.updateState({sign:{}}),this.emit(t+"-canceled")}},this.reset=()=>{this.cleanSyncListeners();const e=this.memStore.getState().sign.request;if(e){const{requestId:t}=e;this.cleanSignListeners(t)}this.resetState()},this.resetState=()=>{this.memStore.updateState({sync:{reading:!1},sign:{}})},a.instance)return a.instance;this.memStore=new n.ObservableStore({sync:{reading:!1},sign:{},_version:1}),a.instance=this}}class h extends t.BaseKeyring{constructor(e){if(super(e),this.getInteraction=()=>new a,this.resetStore=()=>{this.getInteraction().reset()},this.getMemStore=()=>this.getInteraction().memStore,this.removeAccount=e=>{if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())},this.forgetDevice=()=>{this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.name="QR Hardware",this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.indexes={},this.hdk=void 0,this.paths={}},this.submitCryptoHDKey=this.getInteraction().submitCryptoHDKey,this.submitCryptoAccount=this.getInteraction().submitCryptoAccount,this.submitSignature=this.getInteraction().submitSignature,this.cancelSync=this.getInteraction().cancelSync,this.cancelSignRequest=this.getInteraction().cancelRequestSignature,h.instance)return h.instance.deserialize(e),h.instance;h.instance=this}async signTransaction(e,t){const s=0===t.type?i.DataType.transaction:i.DataType.typedTransaction;let n;n=0===t.type?o.encode(t.getMessageToSign(!1)):t.getMessageToSign(!1);const a=await this._pathFromAddress(e),h=t.common.chainId(),u=r.v4(),y=i.EthSignRequest.constructETHRequest(n,s,a,this.xfp,u,h,e),{r:m,s:g,v:d}=await this.requestSignature(u,y,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature'),S=t.toJSON();return S.v=d,S.s=g,S.r=m,S.type=t.type,c.TransactionFactory.fromTxData(S,{common:t.common})}}h.type=t.BaseKeyring.type,exports.MetaMaskKeyring=h;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js", {"./ObservableStore":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        // Typecast: Preserve existing behavior
        super({});
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js", {"./ObservableStore":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CMergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        // Typecast: Preserve existing behavior
        super({});
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js", {"@metamask/safe-event-emitter":"F:\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState) {
        super();
        if (initState) {
            this._state = initState;
        }
        else {
            // Typecast/default state: Preserve existing behavior
            this._state = {};
        }
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            this.putState(Object.assign(Object.assign({}, state), partialState));
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js", {"stream":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5CasStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js", {"./ComposedStore":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js","./MergedStore":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js","./ObservableStore":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js","./asStream":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","./transform":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js", {"through2":"F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5C@metamask%5Cobs-store%5Cdist%5Ctransform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js",}],
["F:\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js", {"_process":"F:\\metamask-extension\\node_modules\\process\\browser.js","readable-stream":"F:\\metamask-extension\\node_modules\\readable-stream\\readable-browser.js","util":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"F:\\metamask-extension\\node_modules\\xtend\\immutable.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@keystonehq%5Cmetamask-airgapped-keyring%5Cnode_modules%5Cthrough2%5Cthrough2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store>through2",file:"node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\address-book-controller\\dist\\AddressBookController.js", {"@metamask/base-controller":"F:\\metamask-extension\\node_modules\\@metamask\\base-controller\\dist\\index.js","@metamask/controller-utils":"F:\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Caddress-book-controller%5Cdist%5CAddressBookController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressBookController = exports.AddressType = void 0;
const controller_utils_1 = require("@metamask/controller-utils");
const base_controller_1 = require("@metamask/base-controller");
var AddressType;
(function (AddressType) {
    AddressType["externallyOwnedAccounts"] = "EXTERNALLY_OWNED_ACCOUNTS";
    AddressType["contractAccounts"] = "CONTRACT_ACCOUNTS";
    AddressType["nonAccounts"] = "NON_ACCOUNTS";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
/**
 * Controller that manages a list of recipient addresses associated with nicknames.
 */
class AddressBookController extends base_controller_1.BaseController {
    /**
     * Creates an AddressBookController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AddressBookController';
        this.defaultState = { addressBook: {} };
        this.initialize();
    }
    /**
     * Remove all contract entries.
     */
    clear() {
        this.update({ addressBook: {} });
    }
    /**
     * Remove a contract entry by address.
     *
     * @param chainId - Chain id identifies the current chain.
     * @param address - Recipient address to delete.
     * @returns Whether the entry was deleted.
     */
    delete(chainId, address) {
        address = (0, controller_utils_1.toChecksumHexAddress)(address);
        if (!(0, controller_utils_1.isValidHexAddress)(address) ||
            !this.state.addressBook[chainId] ||
            !this.state.addressBook[chainId][address]) {
            return false;
        }
        const addressBook = Object.assign({}, this.state.addressBook);
        delete addressBook[chainId][address];
        if (Object.keys(addressBook[chainId]).length === 0) {
            delete addressBook[chainId];
        }
        this.update({ addressBook });
        return true;
    }
    /**
     * Add or update a contact entry by address.
     *
     * @param address - Recipient address to add or update.
     * @param name - Nickname to associate with this address.
     * @param chainId - Chain id identifies the current chain.
     * @param memo - User's note about address.
     * @param addressType - Contact's address type.
     * @returns Boolean indicating if the address was successfully set.
     */
    set(address, name, chainId = (0, controller_utils_1.toHex)(1), memo = '', addressType) {
        address = (0, controller_utils_1.toChecksumHexAddress)(address);
        if (!(0, controller_utils_1.isValidHexAddress)(address)) {
            return false;
        }
        const entry = {
            address,
            chainId,
            isEns: false,
            memo,
            name,
            addressType,
        };
        const ensName = (0, controller_utils_1.normalizeEnsName)(name);
        if (ensName) {
            entry.name = ensName;
            entry.isEns = true;
        }
        this.update({
            addressBook: Object.assign(Object.assign({}, this.state.addressBook), { [chainId]: Object.assign(Object.assign({}, this.state.addressBook[chainId]), { [address]: entry }) }),
        });
        return true;
    }
}
exports.AddressBookController = AddressBookController;
exports.default = AddressBookController;
//# sourceMappingURL=AddressBookController.js.map
      };
    };
  }
  }
}, {package:"@metamask/address-book-controller",file:"node_modules\\@metamask\\address-book-controller\\dist\\AddressBookController.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\address-book-controller\\dist\\index.js", {"./AddressBookController":"F:\\metamask-extension\\node_modules\\@metamask\\address-book-controller\\dist\\AddressBookController.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Caddress-book-controller%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AddressBookController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/address-book-controller",file:"node_modules\\@metamask\\address-book-controller\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\announcement-controller\\dist\\AnnouncementController.js", {"@metamask/base-controller":"F:\\metamask-extension\\node_modules\\@metamask\\base-controller\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cannouncement-controller%5Cdist%5CAnnouncementController.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AnnouncementController_instances, _AnnouncementController_addAnnouncements;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnnouncementController = void 0;
const base_controller_1 = require("@metamask/base-controller");
const controllerName = 'AnnouncementController';
const defaultState = {
    announcements: {},
};
const metadata = {
    announcements: {
        persist: true,
        anonymous: true,
    },
};
/**
 * Controller for managing in-app announcements.
 */
class AnnouncementController extends base_controller_1.BaseControllerV2 {
    /**
     * Creates a AnnouncementController instance.
     *
     * @param args - The arguments to this function.
     * @param args.messenger - Messenger used to communicate with BaseV2 controller.
     * @param args.state - Initial state to set on this controller.
     * @param args.allAnnouncements - Announcements to be passed through to #addAnnouncements
     */
    constructor({ messenger, state, allAnnouncements, }) {
        const mergedState = Object.assign(Object.assign({}, defaultState), state);
        super({ messenger, metadata, name: controllerName, state: mergedState });
        _AnnouncementController_instances.add(this);
        __classPrivateFieldGet(this, _AnnouncementController_instances, "m", _AnnouncementController_addAnnouncements).call(this, allAnnouncements);
    }
    /**
     * Updates the status of the status of the specified announcements
     * once it is read by the user.
     *
     * @param viewedIds - The announcement IDs to mark as viewed.
     */
    updateViewed(viewedIds) {
        this.update(({ announcements }) => {
            for (const id of Object.keys(viewedIds).map(Number)) {
                announcements[id].isShown = viewedIds[id];
            }
        });
    }
}
exports.AnnouncementController = AnnouncementController;
_AnnouncementController_instances = new WeakSet(), _AnnouncementController_addAnnouncements = function _AnnouncementController_addAnnouncements(allAnnouncements) {
    this.update((state) => {
        Object.values(allAnnouncements).forEach((announcement) => {
            var _a;
            state.announcements[announcement.id] = (_a = state.announcements[announcement.id]) !== null && _a !== void 0 ? _a : Object.assign(Object.assign({}, announcement), { isShown: false });
        });
    });
};
//# sourceMappingURL=AnnouncementController.js.map
      };
    };
  }
  }
}, {package:"@metamask/announcement-controller",file:"node_modules\\@metamask\\announcement-controller\\dist\\AnnouncementController.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\announcement-controller\\dist\\index.js", {"./AnnouncementController":"F:\\metamask-extension\\node_modules\\@metamask\\announcement-controller\\dist\\AnnouncementController.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cannouncement-controller%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./AnnouncementController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/announcement-controller",file:"node_modules\\@metamask\\announcement-controller\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\ApprovalController.js", {"./errors":"F:\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\errors.js","@metamask/base-controller":"F:\\metamask-extension\\node_modules\\@metamask\\base-controller\\dist\\index.js","eth-rpc-errors":"F:\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","nanoid":"F:\\metamask-extension\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Capproval-controller%5Cdist%5CApprovalController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ApprovalController_instances, _ApprovalController_approvals, _ApprovalController_origins, _ApprovalController_showApprovalRequest, _ApprovalController_typesExcludedFromRateLimiting, _ApprovalController_add, _ApprovalController_validateAddParams, _ApprovalController_addPendingApprovalOrigin, _ApprovalController_addToStore, _ApprovalController_delete, _ApprovalController_deleteApprovalAndGetCallbacks, _ApprovalController_result;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalController = exports.APPROVAL_TYPE_RESULT_SUCCESS = exports.APPROVAL_TYPE_RESULT_ERROR = exports.ORIGIN_METAMASK = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const base_controller_1 = require("@metamask/base-controller");
const errors_1 = require("./errors");
// Constants
// Avoiding dependency on controller-utils
exports.ORIGIN_METAMASK = 'metamask';
exports.APPROVAL_TYPE_RESULT_ERROR = 'result_error';
exports.APPROVAL_TYPE_RESULT_SUCCESS = 'result_success';
const controllerName = 'ApprovalController';
const stateMetadata = {
    pendingApprovals: { persist: false, anonymous: true },
    pendingApprovalCount: { persist: false, anonymous: false },
    approvalFlows: { persist: false, anonymous: false },
};
const getAlreadyPendingMessage = (origin, type) => `Request of type '${type}' already pending for origin ${origin}. Please wait.`;
const getDefaultState = () => {
    return {
        pendingApprovals: {},
        pendingApprovalCount: 0,
        approvalFlows: [],
    };
};
/**
 * Controller for managing requests that require user approval.
 *
 * Enables limiting the number of pending requests by origin and type, counting
 * pending requests, and more.
 *
 * Adding a request returns a promise that resolves or rejects when the request
 * is approved or denied, respectively.
 */
class ApprovalController extends base_controller_1.BaseControllerV2 {
    /**
     * Construct an Approval controller.
     *
     * @param options - The controller options.
     * @param options.showApprovalRequest - Function for opening the UI such that
     * the request can be displayed to the user.
     * @param options.messenger - The restricted controller messenger for the Approval controller.
     * @param options.state - The initial controller state.
     * @param options.typesExcludedFromRateLimiting - Array of aproval types which allow multiple pending approval requests from the same origin.
     */
    constructor({ messenger, showApprovalRequest, state = {}, typesExcludedFromRateLimiting = [], }) {
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        _ApprovalController_instances.add(this);
        _ApprovalController_approvals.set(this, void 0);
        _ApprovalController_origins.set(this, void 0);
        _ApprovalController_showApprovalRequest.set(this, void 0);
        _ApprovalController_typesExcludedFromRateLimiting.set(this, void 0);
        __classPrivateFieldSet(this, _ApprovalController_approvals, new Map(), "f");
        __classPrivateFieldSet(this, _ApprovalController_origins, new Map(), "f");
        __classPrivateFieldSet(this, _ApprovalController_showApprovalRequest, showApprovalRequest, "f");
        __classPrivateFieldSet(this, _ApprovalController_typesExcludedFromRateLimiting, typesExcludedFromRateLimiting, "f");
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering this controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearRequests`, this.clear.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:addRequest`, (opts, shouldShowRequest) => {
            if (shouldShowRequest) {
                return this.addAndShowApprovalRequest(opts);
            }
            return this.add(opts);
        });
        this.messagingSystem.registerActionHandler(`${controllerName}:hasRequest`, this.has.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:acceptRequest`, this.accept.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:rejectRequest`, this.reject.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:updateRequestState`, this.updateRequestState.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:startFlow`, this.startFlow.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:endFlow`, this.endFlow.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:setFlowLoadingText`, this.setFlowLoadingText.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:showSuccess`, this.success.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:showError`, this.error.bind(this));
    }
    addAndShowApprovalRequest(opts) {
        const promise = __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_add).call(this, opts.origin, opts.type, opts.id, opts.requestData, opts.requestState, opts.expectsResult);
        __classPrivateFieldGet(this, _ApprovalController_showApprovalRequest, "f").call(this);
        return promise;
    }
    add(opts) {
        return __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_add).call(this, opts.origin, opts.type, opts.id, opts.requestData, opts.requestState, opts.expectsResult);
    }
    /**
     * Gets the info for the approval request with the given id.
     *
     * @param id - The id of the approval request.
     * @returns The approval request data associated with the id.
     */
    get(id) {
        return this.state.pendingApprovals[id];
    }
    /**
     * Gets the number of pending approvals, by origin and/or type.
     *
     * If only `origin` is specified, all approvals for that origin will be
     * counted, regardless of type.
     * If only `type` is specified, all approvals for that type will be counted,
     * regardless of origin.
     * If both `origin` and `type` are specified, 0 or 1 will be returned.
     *
     * @param opts - The approval count options.
     * @param opts.origin - An approval origin.
     * @param opts.type - The type of the approval request.
     * @returns The current approval request count for the given origin and/or
     * type.
     */
    getApprovalCount(opts = {}) {
        var _a;
        if (!opts.origin && !opts.type) {
            throw new Error('Must specify origin, type, or both.');
        }
        const { origin, type: _type } = opts;
        if (origin && _type) {
            return ((_a = __classPrivateFieldGet(this, _ApprovalController_origins, "f").get(origin)) === null || _a === void 0 ? void 0 : _a.get(_type)) || 0;
        }
        if (origin) {
            return Array.from((__classPrivateFieldGet(this, _ApprovalController_origins, "f").get(origin) || new Map()).values()).reduce((total, value) => total + value, 0);
        }
        // Only "type" was specified
        let count = 0;
        for (const approval of Object.values(this.state.pendingApprovals)) {
            if (approval.type === _type) {
                count += 1;
            }
        }
        return count;
    }
    /**
     * Get the total count of all pending approval requests for all origins.
     *
     * @returns The total pending approval request count.
     */
    getTotalApprovalCount() {
        return this.state.pendingApprovalCount;
    }
    /**
     * Checks if there's a pending approval request per the given parameters.
     * At least one parameter must be specified. An error will be thrown if the
     * parameters are invalid.
     *
     * If `id` is specified, all other parameters will be ignored.
     * If `id` is not specified, the method will check for requests that match
     * all of the specified parameters.
     *
     * @param opts - Options bag.
     * @param opts.id - The ID to check for.
     * @param opts.origin - The origin to check for.
     * @param opts.type - The type to check for.
     * @returns `true` if a matching approval is found, and `false` otherwise.
     */
    has(opts = {}) {
        var _a;
        const { id, origin, type: _type } = opts;
        if (id) {
            if (typeof id !== 'string') {
                throw new Error('May not specify non-string id.');
            }
            return __classPrivateFieldGet(this, _ApprovalController_approvals, "f").has(id);
        }
        if (_type && typeof _type !== 'string') {
            throw new Error('May not specify non-string type.');
        }
        if (origin) {
            if (typeof origin !== 'string') {
                throw new Error('May not specify non-string origin.');
            }
            // Check origin and type pair if type also specified
            if (_type) {
                return Boolean((_a = __classPrivateFieldGet(this, _ApprovalController_origins, "f").get(origin)) === null || _a === void 0 ? void 0 : _a.get(_type));
            }
            return __classPrivateFieldGet(this, _ApprovalController_origins, "f").has(origin);
        }
        if (_type) {
            for (const approval of Object.values(this.state.pendingApprovals)) {
                if (approval.type === _type) {
                    return true;
                }
            }
            return false;
        }
        throw new Error('Must specify a valid combination of id, origin, and type.');
    }
    /**
     * Resolves the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param value - The value to resolve the approval promise with.
     * @param options - Options bag.
     * @returns A promise that either resolves once a result is provided by
     * the creator of the approval request, or immediately if `options.waitForResult`
     * is `false` or `undefined`.
     */
    accept(id, value, options) {
        // Safe to cast as the delete method below will throw if the ID is not found
        const approval = this.get(id);
        const requestPromise = __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_deleteApprovalAndGetCallbacks).call(this, id);
        return new Promise((resolve, reject) => {
            const resultCallbacks = {
                success: (acceptValue) => resolve({ value: acceptValue }),
                error: reject,
            };
            if ((options === null || options === void 0 ? void 0 : options.waitForResult) && !approval.expectsResult) {
                reject(new errors_1.ApprovalRequestNoResultSupportError(id));
                return;
            }
            const resultValue = (options === null || options === void 0 ? void 0 : options.waitForResult) ? resultCallbacks : undefined;
            const resolveValue = approval.expectsResult
                ? { value, resultCallbacks: resultValue }
                : value;
            requestPromise.resolve(resolveValue);
            if (!(options === null || options === void 0 ? void 0 : options.waitForResult)) {
                resolve({ value: undefined });
            }
        });
    }
    /**
     * Rejects the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param error - The error to reject the approval promise with.
     */
    reject(id, error) {
        __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_deleteApprovalAndGetCallbacks).call(this, id).reject(error);
    }
    /**
     * Rejects and deletes all approval requests.
     *
     * @param rejectionError - The EthereumRpcError to reject the approval
     * requests with.
     */
    clear(rejectionError) {
        for (const id of __classPrivateFieldGet(this, _ApprovalController_approvals, "f").keys()) {
            this.reject(id, rejectionError);
        }
        __classPrivateFieldGet(this, _ApprovalController_origins, "f").clear();
        this.update((draftState) => {
            draftState.pendingApprovals = {};
            draftState.pendingApprovalCount = 0;
        });
    }
    /**
     * Updates the request state of the approval with the given id.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request.
     * @param opts.requestState - Additional data associated with the request
     */
    updateRequestState(opts) {
        if (!this.state.pendingApprovals[opts.id]) {
            throw new errors_1.ApprovalRequestNotFoundError(opts.id);
        }
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.pendingApprovals[opts.id].requestState =
                opts.requestState;
        });
    }
    /**
     * Starts a new approval flow.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval flow.
     * @param opts.loadingText - The loading text that will be associated to the approval flow.
     * @returns The object containing the approval flow id.
     */
    startFlow(opts = {}) {
        var _a, _b;
        const id = (_a = opts.id) !== null && _a !== void 0 ? _a : (0, nanoid_1.nanoid)();
        const loadingText = (_b = opts.loadingText) !== null && _b !== void 0 ? _b : null;
        this.update((draftState) => {
            draftState.approvalFlows.push({ id, loadingText });
        });
        __classPrivateFieldGet(this, _ApprovalController_showApprovalRequest, "f").call(this);
        return { id, loadingText };
    }
    /**
     * Ends the current approval flow.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval flow that will be finished.
     */
    endFlow({ id }) {
        if (!this.state.approvalFlows.length) {
            throw new errors_1.NoApprovalFlowsError();
        }
        const currentFlow = this.state.approvalFlows.slice(-1)[0];
        if (id !== currentFlow.id) {
            throw new errors_1.EndInvalidFlowError(id, this.state.approvalFlows.map((flow) => flow.id));
        }
        this.update((draftState) => {
            draftState.approvalFlows.pop();
        });
    }
    /**
     * Sets the loading text for the approval flow.
     *
     * @param opts - Options bag.
     * @param opts.id - The approval flow loading text that will be displayed.
     * @param opts.loadingText - The loading text that will be associated to the approval flow.
     */
    setFlowLoadingText({ id, loadingText }) {
        const flowIndex = this.state.approvalFlows.findIndex((flow) => flow.id === id);
        if (flowIndex === -1) {
            throw new errors_1.MissingApprovalFlowError(id);
        }
        this.update((draftState) => {
            draftState.approvalFlows[flowIndex].loadingText = loadingText;
        });
    }
    /**
     * Show a success page.
     *
     * @param opts - Options bag.
     * @param opts.message - The message text or components to display in the page.
     * @param opts.header - The text or components to display in the header of the page.
     * @param opts.flowToEnd - The ID of the approval flow to end once the success page is approved.
     * @returns Empty object to support future additions.
     */
    success(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_result).call(this, exports.APPROVAL_TYPE_RESULT_SUCCESS, opts, {
                message: opts.message,
                header: opts.header,
            });
            return {};
        });
    }
    /**
     * Show an error page.
     *
     * @param opts - Options bag.
     * @param opts.message - The message text or components to display in the page.
     * @param opts.header - The text or components to display in the header of the page.
     * @param opts.flowToEnd - The ID of the approval flow to end once the error page is approved.
     * @returns Empty object to support future additions.
     */
    error(opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_result).call(this, exports.APPROVAL_TYPE_RESULT_ERROR, opts, {
                error: opts.error,
                header: opts.header,
            });
            return {};
        });
    }
}
exports.ApprovalController = ApprovalController;
_ApprovalController_approvals = new WeakMap(), _ApprovalController_origins = new WeakMap(), _ApprovalController_showApprovalRequest = new WeakMap(), _ApprovalController_typesExcludedFromRateLimiting = new WeakMap(), _ApprovalController_instances = new WeakSet(), _ApprovalController_add = function _ApprovalController_add(origin, type, id = (0, nanoid_1.nanoid)(), requestData, requestState, expectsResult) {
    __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_validateAddParams).call(this, id, origin, type, requestData, requestState);
    if (!__classPrivateFieldGet(this, _ApprovalController_typesExcludedFromRateLimiting, "f").includes(type) &&
        this.has({ origin, type })) {
        throw eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable(getAlreadyPendingMessage(origin, type));
    }
    // add pending approval
    return new Promise((resolve, reject) => {
        __classPrivateFieldGet(this, _ApprovalController_approvals, "f").set(id, { resolve, reject });
        __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_addPendingApprovalOrigin).call(this, origin, type);
        __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_addToStore).call(this, id, origin, type, requestData, requestState, expectsResult);
    });
}, _ApprovalController_validateAddParams = function _ApprovalController_validateAddParams(id, origin, type, requestData, requestState) {
    let errorMessage = null;
    if (!id || typeof id !== 'string') {
        errorMessage = 'Must specify non-empty string id.';
    }
    else if (__classPrivateFieldGet(this, _ApprovalController_approvals, "f").has(id)) {
        errorMessage = `Approval request with id '${id}' already exists.`;
    }
    else if (!origin || typeof origin !== 'string') {
        errorMessage = 'Must specify non-empty string origin.';
    }
    else if (!type || typeof type !== 'string') {
        errorMessage = 'Must specify non-empty string type.';
    }
    else if (requestData &&
        (typeof requestData !== 'object' || Array.isArray(requestData))) {
        errorMessage = 'Request data must be a plain object if specified.';
    }
    else if (requestState &&
        (typeof requestState !== 'object' || Array.isArray(requestState))) {
        errorMessage = 'Request state must be a plain object if specified.';
    }
    if (errorMessage) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal(errorMessage);
    }
}, _ApprovalController_addPendingApprovalOrigin = function _ApprovalController_addPendingApprovalOrigin(origin, type) {
    let originMap = __classPrivateFieldGet(this, _ApprovalController_origins, "f").get(origin);
    if (!originMap) {
        originMap = new Map();
        __classPrivateFieldGet(this, _ApprovalController_origins, "f").set(origin, originMap);
    }
    const currentValue = originMap.get(type) || 0;
    originMap.set(type, currentValue + 1);
}, _ApprovalController_addToStore = function _ApprovalController_addToStore(id, origin, type, requestData, requestState, expectsResult) {
    const approval = {
        id,
        origin,
        type,
        time: Date.now(),
        requestData: requestData || null,
        requestState: requestState || null,
        expectsResult: expectsResult || false,
    };
    this.update((draftState) => {
        // Typecast: ts(2589)
        draftState.pendingApprovals[id] = approval;
        draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
    });
}, _ApprovalController_delete = function _ApprovalController_delete(id) {
    __classPrivateFieldGet(this, _ApprovalController_approvals, "f").delete(id);
    // This method is only called after verifying that the approval with the
    // specified id exists.
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const { origin, type } = this.state.pendingApprovals[id];
    const originMap = __classPrivateFieldGet(this, _ApprovalController_origins, "f").get(origin);
    const originTotalCount = this.getApprovalCount({ origin });
    const originTypeCount = originMap.get(type);
    if (originTotalCount === 1) {
        __classPrivateFieldGet(this, _ApprovalController_origins, "f").delete(origin);
    }
    else {
        originMap.set(type, originTypeCount - 1);
    }
    this.update((draftState) => {
        delete draftState.pendingApprovals[id];
        draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
    });
}, _ApprovalController_deleteApprovalAndGetCallbacks = function _ApprovalController_deleteApprovalAndGetCallbacks(id) {
    const callbacks = __classPrivateFieldGet(this, _ApprovalController_approvals, "f").get(id);
    if (!callbacks) {
        throw new errors_1.ApprovalRequestNotFoundError(id);
    }
    __classPrivateFieldGet(this, _ApprovalController_instances, "m", _ApprovalController_delete).call(this, id);
    return callbacks;
}, _ApprovalController_result = function _ApprovalController_result(type, opts, requestData) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield this.addAndShowApprovalRequest({
                origin: exports.ORIGIN_METAMASK,
                type,
                requestData,
            });
        }
        catch (error) {
            console.info('Failed to display result page', error);
        }
        finally {
            if (opts.flowToEnd) {
                try {
                    this.endFlow({ id: opts.flowToEnd });
                }
                catch (error) {
                    console.info('Failed to end flow', { id: opts.flowToEnd, error });
                }
            }
        }
    });
};
exports.default = ApprovalController;
//# sourceMappingURL=ApprovalController.js.map
      };
    };
  }
  }
}, {package:"@metamask/approval-controller",file:"node_modules\\@metamask\\approval-controller\\dist\\ApprovalController.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\errors.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Capproval-controller%5Cdist%5Cerrors.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MissingApprovalFlowError = exports.EndInvalidFlowError = exports.NoApprovalFlowsError = exports.ApprovalRequestNoResultSupportError = exports.ApprovalRequestNotFoundError = void 0;
class ApprovalRequestNotFoundError extends Error {
    constructor(id) {
        super(`Approval request with id '${id}' not found.`);
    }
}
exports.ApprovalRequestNotFoundError = ApprovalRequestNotFoundError;
class ApprovalRequestNoResultSupportError extends Error {
    constructor(id) {
        super(`Approval acceptance requested result but request with id '${id}' does not support it.`);
    }
}
exports.ApprovalRequestNoResultSupportError = ApprovalRequestNoResultSupportError;
class NoApprovalFlowsError extends Error {
    constructor() {
        super(`No approval flows found.`);
    }
}
exports.NoApprovalFlowsError = NoApprovalFlowsError;
class EndInvalidFlowError extends Error {
    constructor(id, flowIds) {
        super(`Attempted to end flow with id '${id}' which does not match current flow with id '${flowIds.slice(-1)[0]}'. All Flows: ${flowIds.join(', ')}`);
    }
}
exports.EndInvalidFlowError = EndInvalidFlowError;
class MissingApprovalFlowError extends Error {
    constructor(id) {
        super(`No approval flows found with id '${id}'.`);
    }
}
exports.MissingApprovalFlowError = MissingApprovalFlowError;
//# sourceMappingURL=errors.js.map
      };
    };
  }
  }
}, {package:"@metamask/approval-controller",file:"node_modules\\@metamask\\approval-controller\\dist\\errors.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\index.js", {"./ApprovalController":"F:\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\ApprovalController.js","./errors":"F:\\metamask-extension\\node_modules\\@metamask\\approval-controller\\dist\\errors.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Capproval-controller%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./ApprovalController"), exports);
__exportStar(require("./errors"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/approval-controller",file:"node_modules\\@metamask\\approval-controller\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\index.browser.cjs", {"./url-alphabet/index.cjs":"F:\\metamask-extension\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\url-alphabet\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Capproval-controller%5Cnode_modules%5Cnanoid%5Cindex.browser.cjs
      return function (require, module, exports) {
let { urlAlphabet } = require('./url-alphabet/index.cjs')
let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))
let customRandom = (alphabet, defaultSize, getRandom) => {
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)
  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      let j = step
      while (j--) {
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}
let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)
let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63
    if (byte < 36) {
      id += byte.toString(36)
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')
module.exports = { nanoid, customAlphabet, customRandom, urlAlphabet, random }

      };
    };
  }
  }
}, {package:"@metamask/approval-controller>nanoid",file:"node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\index.browser.cjs",}],
["F:\\metamask-extension\\node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\url-alphabet\\index.cjs", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Capproval-controller%5Cnode_modules%5Cnanoid%5Curl-alphabet%5Cindex.cjs
      return function (require, module, exports) {
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'
module.exports = { urlAlphabet }

      };
    };
  }
  }
}, {package:"@metamask/approval-controller>nanoid",file:"node_modules\\@metamask\\approval-controller\\node_modules\\nanoid\\url-alphabet\\index.cjs",}],
["F:\\metamask-extension\\node_modules\\@metamask\\browser-passworder\\dist\\index.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cbrowser-passworder%5Cdist%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSalt = exports.serializeBufferForStorage = exports.serializeBufferFromStorage = exports.keyFromPassword = exports.exportKey = exports.importKey = exports.decryptWithKey = exports.decryptWithDetail = exports.decrypt = exports.encryptWithKey = exports.encryptWithDetail = exports.encrypt = void 0;
const EXPORT_FORMAT = 'jwk';
const DERIVED_KEY_FORMAT = 'AES-GCM';
const STRING_ENCODING = 'utf-8';
/**
 * Encrypts a data object that can be any serializable value using
 * a provided password.
 *
 * @param password - The password to use for encryption.
 * @param dataObj - The data to encrypt.
 * @param key - The CryptoKey to encrypt with.
 * @param salt - The salt to use to encrypt.
 * @returns The encrypted vault.
 */
async function encrypt(password, dataObj, key, salt = generateSalt()) {
    const cryptoKey = key || (await keyFromPassword(password, salt));
    const payload = await encryptWithKey(cryptoKey, dataObj);
    payload.salt = salt;
    return JSON.stringify(payload);
}
exports.encrypt = encrypt;
/**
 * Encrypts a data object that can be any serializable value using
 * a provided password.
 *
 * @param password - A password to use for encryption.
 * @param dataObj - The data to encrypt.
 * @param salt - The salt used to encrypt.
 * @returns The vault and exported key string.
 */
async function encryptWithDetail(password, dataObj, salt = generateSalt()) {
    const key = await keyFromPassword(password, salt, true);
    const exportedKeyString = await exportKey(key);
    const vault = await encrypt(password, dataObj, key, salt);
    return {
        vault,
        exportedKeyString,
    };
}
exports.encryptWithDetail = encryptWithDetail;
/**
 * Encrypts the provided serializable javascript object using the
 * provided CryptoKey and returns an object containing the cypher text and
 * the initialization vector used.
 *
 * @param key - The CryptoKey to encrypt with.
 * @param dataObj - A serializable JavaScript object to encrypt.
 * @returns The encrypted data.
 */
async function encryptWithKey(key, dataObj) {
    const data = JSON.stringify(dataObj);
    const dataBuffer = Buffer.from(data, STRING_ENCODING);
    const vector = global.crypto.getRandomValues(new Uint8Array(16));
    const buf = await global.crypto.subtle.encrypt({
        name: DERIVED_KEY_FORMAT,
        iv: vector,
    }, key, dataBuffer);
    const buffer = new Uint8Array(buf);
    const vectorStr = Buffer.from(vector).toString('base64');
    const vaultStr = Buffer.from(buffer).toString('base64');
    return {
        data: vaultStr,
        iv: vectorStr,
    };
}
exports.encryptWithKey = encryptWithKey;
/**
 * Given a password and a cypher text, decrypts the text and returns
 * the resulting value.
 *
 * @param password - The password to decrypt with.
 * @param text - The cypher text to decrypt.
 * @param key - The key to decrypt with.
 * @returns The decrypted data.
 */
async function decrypt(password, text, key) {
    const payload = JSON.parse(text);
    const { salt } = payload;
    const cryptoKey = key || (await keyFromPassword(password, salt));
    const result = await decryptWithKey(cryptoKey, payload);
    return result;
}
exports.decrypt = decrypt;
/**
 * Given a password and a cypher text, decrypts the text and returns
 * the resulting value, keyString, and salt.
 *
 * @param password - The password to decrypt with.
 * @param text - The encrypted vault to decrypt.
 * @returns The decrypted vault along with the salt and exported key.
 */
async function decryptWithDetail(password, text) {
    const payload = JSON.parse(text);
    const { salt } = payload;
    const key = await keyFromPassword(password, salt, true);
    const exportedKeyString = await exportKey(key);
    const vault = await decrypt(password, text, key);
    return {
        exportedKeyString,
        vault,
        salt,
    };
}
exports.decryptWithDetail = decryptWithDetail;
/**
 * Given a CryptoKey and an EncryptionResult object containing the initialization
 * vector (iv) and data to decrypt, return the resulting decrypted value.
 *
 * @param key - The CryptoKey to decrypt with.
 * @param payload - The payload to decrypt, returned from an encryption method.
 * @returns The decrypted data.
 */
async function decryptWithKey(key, payload) {
    const encryptedData = Buffer.from(payload.data, 'base64');
    const vector = Buffer.from(payload.iv, 'base64');
    let decryptedObj;
    try {
        const result = await crypto.subtle.decrypt({ name: DERIVED_KEY_FORMAT, iv: vector }, key, encryptedData);
        const decryptedData = new Uint8Array(result);
        const decryptedStr = Buffer.from(decryptedData).toString(STRING_ENCODING);
        decryptedObj = JSON.parse(decryptedStr);
    }
    catch (e) {
        throw new Error('Incorrect password');
    }
    return decryptedObj;
}
exports.decryptWithKey = decryptWithKey;
/**
 * Receives an exported CryptoKey string and creates a key.
 *
 * @param keyString - The key string to import.
 * @returns A CryptoKey.
 */
async function importKey(keyString) {
    const key = await window.crypto.subtle.importKey(EXPORT_FORMAT, JSON.parse(keyString), DERIVED_KEY_FORMAT, true, ['encrypt', 'decrypt']);
    return key;
}
exports.importKey = importKey;
/**
 * Receives an exported CryptoKey string, creates a key,
 * and decrypts cipher text with the reconstructed key.
 *
 * @param key - The CryptoKey to export.
 * @returns A key string.
 */
async function exportKey(key) {
    const exportedKey = await window.crypto.subtle.exportKey(EXPORT_FORMAT, key);
    return JSON.stringify(exportedKey);
}
exports.exportKey = exportKey;
/**
 * Generate a CryptoKey from a password and random salt.
 *
 * @param password - The password to use to generate key.
 * @param salt - The salt string to use in key derivation.
 * @param exportable - Should the derived key be exportable.
 * @returns A CryptoKey for encryption and decryption.
 */
async function keyFromPassword(password, salt, exportable = false) {
    const passBuffer = Buffer.from(password, STRING_ENCODING);
    const saltBuffer = Buffer.from(salt, 'base64');
    const key = await global.crypto.subtle.importKey('raw', passBuffer, { name: 'PBKDF2' }, false, ['deriveBits', 'deriveKey']);
    const derivedKey = await global.crypto.subtle.deriveKey({
        name: 'PBKDF2',
        salt: saltBuffer,
        iterations: 10000,
        hash: 'SHA-256',
    }, key, { name: DERIVED_KEY_FORMAT, length: 256 }, exportable, ['encrypt', 'decrypt']);
    return derivedKey;
}
exports.keyFromPassword = keyFromPassword;
/**
 * Converts a hex string into a buffer.
 *
 * @param str - Hex encoded string.
 * @returns The string ecoded as a byte array.
 */
function serializeBufferFromStorage(str) {
    const stripStr = str.slice(0, 2) === '0x' ? str.slice(2) : str;
    const buf = new Uint8Array(stripStr.length / 2);
    for (let i = 0; i < stripStr.length; i += 2) {
        const seg = stripStr.substr(i, 2);
        buf[i / 2] = parseInt(seg, 16);
    }
    return buf;
}
exports.serializeBufferFromStorage = serializeBufferFromStorage;
/**
 * Converts a buffer into a hex string ready for storage.
 *
 * @param buffer - Buffer to serialize.
 * @returns A hex encoded string.
 */
function serializeBufferForStorage(buffer) {
    let result = '0x';
    buffer.forEach((value) => {
        result += unprefixedHex(value);
    });
    return result;
}
exports.serializeBufferForStorage = serializeBufferForStorage;
/**
 * Converts a number into hex value, and ensures proper leading 0
 * for single characters strings.
 *
 * @param num - The number to convert to string.
 * @returns An unprefixed hex string.
 */
function unprefixedHex(num) {
    let hex = num.toString(16);
    while (hex.length < 2) {
        hex = `0${hex}`;
    }
    return hex;
}
/**
 * Generates a random string for use as a salt in CryptoKey generation.
 *
 * @param byteCount - The number of bytes to generate.
 * @returns A randomly generated string.
 */
function generateSalt(byteCount = 32) {
    const view = new Uint8Array(byteCount);
    global.crypto.getRandomValues(view);
    // Uint8Array is a fixed length array and thus does not have methods like pop, etc
    // so TypeScript complains about casting it to an array. Array.from() works here for
    // getting the proper type, but it results in a functional difference. In order to
    // cast, you have to first cast view to unknown then cast the unknown value to number[]
    // TypeScript ftw: double opt in to write potentially type-mismatched code.
    const b64encoded = btoa(String.fromCharCode.apply(null, view));
    return b64encoded;
}
exports.generateSalt = generateSalt;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/browser-passworder",file:"node_modules\\@metamask\\browser-passworder\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\index.js", {"@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@metamask/eth-sig-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","@metamask/scure-bip39":"F:\\metamask-extension\\node_modules\\@metamask\\scure-bip39\\dist\\index.js","@metamask/scure-bip39/dist/wordlists/english":"F:\\metamask-extension\\node_modules\\@metamask\\scure-bip39\\dist\\wordlists\\english.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/hdkey":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\hdkey.js","ethereum-cryptography/keccak":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\keccak.js","ethereum-cryptography/utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { HDKey } = require('ethereum-cryptography/hdkey');
const { keccak256 } = require('ethereum-cryptography/keccak');
const { bytesToHex } = require('ethereum-cryptography/utils');
const {
  stripHexPrefix,
  privateToPublic,
  publicToAddress,
  ecsign,
  arrToBufArr,
  bufferToHex,
} = require('@ethereumjs/util');
const bip39 = require('@metamask/scure-bip39');
const { wordlist } = require('@metamask/scure-bip39/dist/wordlists/english');
const {
  concatSig,
  decrypt,
  getEncryptionPublicKey,
  normalize,
  personalSign,
  signTypedData,
  SignTypedDataVersion,
} = require('@metamask/eth-sig-util');

// Options:
const hdPathString = `m/44'/60'/0'/0`;
const type = 'HD Key Tree';

class HdKeyring {
  /* PUBLIC METHODS */
  constructor(opts = {}) {
    this.type = type;
    this._wallets = [];
    this.deserialize(opts);
  }

  generateRandomMnemonic() {
    this._initFromMnemonic(bip39.generateMnemonic(wordlist));
  }

  _uint8ArrayToString(mnemonic) {
    const recoveredIndices = Array.from(
      new Uint16Array(new Uint8Array(mnemonic).buffer),
    );
    return recoveredIndices.map((i) => wordlist[i]).join(' ');
  }

  _stringToUint8Array(mnemonic) {
    const indices = mnemonic.split(' ').map((word) => wordlist.indexOf(word));
    return new Uint8Array(new Uint16Array(indices).buffer);
  }

  _mnemonicToUint8Array(mnemonic) {
    let mnemonicData = mnemonic;
    // when encrypted/decrypted, buffers get cast into js object with a property type set to buffer
    if (mnemonic && mnemonic.type && mnemonic.type === 'Buffer') {
      mnemonicData = mnemonic.data;
    }

    if (
      // this block is for backwards compatibility with vaults that were previously stored as buffers, number arrays or plain text strings
      typeof mnemonicData === 'string' ||
      Buffer.isBuffer(mnemonicData) ||
      Array.isArray(mnemonicData)
    ) {
      let mnemonicAsString = mnemonicData;
      if (Array.isArray(mnemonicData)) {
        mnemonicAsString = Buffer.from(mnemonicData).toString();
      } else if (Buffer.isBuffer(mnemonicData)) {
        mnemonicAsString = mnemonicData.toString();
      }
      return this._stringToUint8Array(mnemonicAsString);
    } else if (
      mnemonicData instanceof Object &&
      !(mnemonicData instanceof Uint8Array)
    ) {
      // when encrypted/decrypted the Uint8Array becomes a js object we need to cast back to a Uint8Array
      return Uint8Array.from(Object.values(mnemonicData));
    }
    return mnemonicData;
  }

  serialize() {
    const mnemonicAsString = this._uint8ArrayToString(this.mnemonic);
    const uint8ArrayMnemonic = new TextEncoder('utf-8').encode(
      mnemonicAsString,
    );

    return Promise.resolve({
      mnemonic: Array.from(uint8ArrayMnemonic),
      numberOfAccounts: this._wallets.length,
      hdPath: this.hdPath,
    });
  }

  deserialize(opts = {}) {
    if (opts.numberOfAccounts && !opts.mnemonic) {
      throw new Error(
        'Eth-Hd-Keyring: Deserialize method cannot be called with an opts value for numberOfAccounts and no menmonic',
      );
    }

    if (this.root) {
      throw new Error(
        'Eth-Hd-Keyring: Secret recovery phrase already provided',
      );
    }
    this.opts = opts;
    this._wallets = [];
    this.mnemonic = null;
    this.root = null;
    this.hdPath = opts.hdPath || hdPathString;

    if (opts.mnemonic) {
      this._initFromMnemonic(opts.mnemonic);
    }

    if (opts.numberOfAccounts) {
      return this.addAccounts(opts.numberOfAccounts);
    }

    return Promise.resolve([]);
  }

  addAccounts(numberOfAccounts = 1) {
    if (!this.root) {
      throw new Error('Eth-Hd-Keyring: No secret recovery phrase provided');
    }

    const oldLen = this._wallets.length;
    const newWallets = [];
    for (let i = oldLen; i < numberOfAccounts + oldLen; i++) {
      const wallet = this.root.deriveChild(i);
      newWallets.push(wallet);
      this._wallets.push(wallet);
    }
    const hexWallets = newWallets.map((w) => {
      return this._addressfromPublicKey(w.publicKey);
    });
    return Promise.resolve(hexWallets);
  }

  getAccounts() {
    return this._wallets.map((w) => this._addressfromPublicKey(w.publicKey));
  }

  /* BASE KEYRING METHODS */

  // returns an address specific to an app
  async getAppKeyAddress(address, origin) {
    if (!origin || typeof origin !== 'string') {
      throw new Error(`'origin' must be a non-empty string`);
    }
    const wallet = this._getWalletForAccount(address, {
      withAppKeyOrigin: origin,
    });
    const appKeyAddress = normalize(
      publicToAddress(wallet.publicKey).toString('hex'),
    );

    return appKeyAddress;
  }

  // exportAccount should return a hex-encoded private key:
  async exportAccount(address, opts = {}) {
    const wallet = this._getWalletForAccount(address, opts);
    return bytesToHex(wallet.privateKey);
  }

  // tx is an instance of the ethereumjs-transaction class.
  async signTransaction(address, tx, opts = {}) {
    const privKey = this._getPrivateKeyFor(address, opts);
    const signedTx = tx.sign(privKey);
    // Newer versions of Ethereumjs-tx are immutable and return a new tx object
    return signedTx === undefined ? tx : signedTx;
  }

  // For eth_sign, we need to sign arbitrary data:
  async signMessage(address, data, opts = {}) {
    const message = stripHexPrefix(data);
    const privKey = this._getPrivateKeyFor(address, opts);
    const msgSig = ecsign(Buffer.from(message, 'hex'), privKey);
    const rawMsgSig = concatSig(msgSig.v, msgSig.r, msgSig.s);
    return rawMsgSig;
  }

  // For personal_sign, we need to prefix the message:
  async signPersonalMessage(address, msgHex, opts = {}) {
    const privKey = this._getPrivateKeyFor(address, opts);
    const privateKey = Buffer.from(privKey, 'hex');
    const sig = personalSign({ privateKey, data: msgHex });
    return sig;
  }

  // For eth_decryptMessage:
  async decryptMessage(withAccount, encryptedData) {
    const wallet = this._getWalletForAccount(withAccount);
    const { privateKey: privateKeyAsUint8Array } = wallet;
    const privateKeyAsHex = Buffer.from(privateKeyAsUint8Array).toString('hex');
    const sig = decrypt({ privateKey: privateKeyAsHex, encryptedData });
    return sig;
  }

  // personal_signTypedData, signs data along with the schema
  async signTypedData(
    withAccount,
    typedData,
    opts = { version: SignTypedDataVersion.V1 },
  ) {
    // Treat invalid versions as "V1"
    const version = Object.keys(SignTypedDataVersion).includes(opts.version)
      ? opts.version
      : SignTypedDataVersion.V1;

    const privateKey = this._getPrivateKeyFor(withAccount, opts);
    return signTypedData({ privateKey, data: typedData, version });
  }

  removeAccount(account) {
    const address = normalize(account);
    if (
      !this._wallets
        .map(({ publicKey }) => this._addressfromPublicKey(publicKey))
        .includes(address)
    ) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this._wallets = this._wallets.filter(
      ({ publicKey }) => this._addressfromPublicKey(publicKey) !== address,
    );
  }

  // get public key for nacl
  async getEncryptionPublicKey(withAccount, opts = {}) {
    const privKey = this._getPrivateKeyFor(withAccount, opts);
    const publicKey = getEncryptionPublicKey(privKey);
    return publicKey;
  }

  _getPrivateKeyFor(address, opts = {}) {
    if (!address) {
      throw new Error('Must specify address.');
    }
    const wallet = this._getWalletForAccount(address, opts);
    return wallet.privateKey;
  }

  _getWalletForAccount(account, opts = {}) {
    const address = normalize(account);
    let wallet = this._wallets.find(({ publicKey }) => {
      return this._addressfromPublicKey(publicKey) === address;
    });
    if (!wallet) {
      throw new Error('HD Keyring - Unable to find matching address.');
    }

    if (opts.withAppKeyOrigin) {
      const { privateKey } = wallet;
      const appKeyOriginBuffer = Buffer.from(opts.withAppKeyOrigin, 'utf8');
      const appKeyBuffer = Buffer.concat([privateKey, appKeyOriginBuffer]);
      const appKeyPrivateKey = arrToBufArr(keccak256(appKeyBuffer, 256));
      const appKeyPublicKey = privateToPublic(appKeyPrivateKey);
      wallet = { privateKey: appKeyPrivateKey, publicKey: appKeyPublicKey };
    }

    return wallet;
  }

  /* PRIVATE / UTILITY METHODS */

  /**
   * Sets appropriate properties for the keyring based on the given
   * BIP39-compliant mnemonic.
   *
   * @param {string|Array<number>|Buffer} mnemonic - A seed phrase represented
   * as a string, an array of UTF-8 bytes, or a Buffer. Mnemonic input
   * passed as type buffer or array of UTF-8 bytes must be NFKD normalized.
   */
  _initFromMnemonic(mnemonic) {
    if (this.root) {
      throw new Error(
        'Eth-Hd-Keyring: Secret recovery phrase already provided',
      );
    }

    this.mnemonic = this._mnemonicToUint8Array(mnemonic);

    // validate before initializing
    const isValid = bip39.validateMnemonic(this.mnemonic, wordlist);
    if (!isValid) {
      throw new Error(
        'Eth-Hd-Keyring: Invalid secret recovery phrase provided',
      );
    }

    // eslint-disable-next-line node/no-sync
    const seed = bip39.mnemonicToSeedSync(this.mnemonic, wordlist);
    this.hdWallet = HDKey.fromMasterSeed(seed);
    this.root = this.hdWallet.derive(this.hdPath);
  }

  // small helper function to convert publicKey in Uint8Array form to a publicAddress as a hex
  _addressfromPublicKey(publicKey) {
    return bufferToHex(
      publicToAddress(Buffer.from(publicKey), true),
    ).toLowerCase();
  }
}

HdKeyring.type = type;
module.exports = HdKeyring;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring",file:"node_modules\\@metamask\\eth-hd-keyring\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_assert.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@noble%5Chashes%5C_assert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
exports.default = assert;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@scure/bip39>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_assert.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_sha2.js", {"./_assert.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_assert.js","./utils.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@noble%5Chashes%5C_sha2.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA2 = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.output(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE));
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@scure/bip39>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_sha2.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_u64.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@noble%5Chashes%5C_u64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig: exports.toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@scure/bip39>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_u64.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\cryptoBrowser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@noble%5Chashes%5CcryptoBrowser.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = {
    node: undefined,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@scure/bip39>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\cryptoBrowser.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\hmac.js", {"./_assert.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_assert.js","./utils.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@noble%5Chashes%5Chmac.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hmac = void 0;
const _assert_js_1 = require("./_assert.js");
const utils_js_1 = require("./utils.js");
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        _assert_js_1.default.hash(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new TypeError('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        _assert_js_1.default.exists(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        _assert_js_1.default.exists(this);
        _assert_js_1.default.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@scure/bip39>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\hmac.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\ripemd160.js", {"./_sha2.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_sha2.js","./utils.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@noble%5Chashes%5Cripemd160.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ripemd160 = exports.RIPEMD160 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const utils_js_1 = require("./utils.js");
// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
const Kr = new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const BUF = new Uint32Array(16);
class RIPEMD160 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@scure/bip39>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\ripemd160.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\sha256.js", {"./_sha2.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_sha2.js","./utils.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@noble%5Chashes%5Csha256.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha256 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const utils_js_1 = require("./utils.js");
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@scure/bip39>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\sha256.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\sha512.js", {"./_sha2.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_sha2.js","./_u64.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_u64.js","./utils.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@noble%5Chashes%5Csha512.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha384 = exports.sha512_256 = exports.sha512 = exports.SHA512 = void 0;
const _sha2_js_1 = require("./_sha2.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = _u64_js_1.default.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n)));
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = new Uint32Array(80);
const SHA512_W_L = new Uint32Array(80);
class SHA512 extends _sha2_js_1.SHA2 {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@scure/bip39>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\sha512.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\utils.js", {"@noble/hashes/crypto":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\cryptoBrowser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@noble%5Chashes%5Cutils.js
      return function (require, module, exports) {
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// The import here is via the package name. This is to ensure
// that exports mapping/resolution does fall into place.
const crypto_1 = require("@noble/hashes/crypto");
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
 */
function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('deadbeef')
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */
function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new TypeError('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
/**
 * Secure PRNG
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
    }
    else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
    }
    else {
        throw new Error("The environment doesn't have randomBytes function");
    }
}
exports.randomBytes = randomBytes;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@scure/bip39>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\secp256k1\\lib\\index.js", {"crypto":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@noble%5Csecp256k1%5Clib%5Cindex.js
      return function (require, module, exports) {
"use strict";
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.schnorr = exports.verify = exports.signSync = exports.sign = exports.getSharedSecret = exports.recoverPublicKey = exports.getPublicKey = exports.Signature = exports.Point = exports.CURVE = void 0;
const nodeCrypto = require("crypto");
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _3n = BigInt(3);
const _8n = BigInt(8);
const POW_2_256 = _2n ** BigInt(256);
const CURVE = {
    a: _0n,
    b: BigInt(7),
    P: POW_2_256 - _2n ** BigInt(32) - BigInt(977),
    n: POW_2_256 - BigInt('432420386565659656852420866394968145599'),
    h: _1n,
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
};
exports.CURVE = CURVE;
function weistrass(x) {
    const { a, b } = CURVE;
    const x2 = mod(x * x);
    const x3 = mod(x2 * x);
    return mod(x3 + a * x + b);
}
const USE_ENDOMORPHISM = CURVE.a === _0n;
class JacobianPoint {
    constructor(x, y, z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }
    static fromAffine(p) {
        if (!(p instanceof Point)) {
            throw new TypeError('JacobianPoint#fromAffine: expected Point');
        }
        return new JacobianPoint(p.x, p.y, _1n);
    }
    static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p) => p.z));
        return points.map((p, i) => p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
    }
    equals(other) {
        if (!(other instanceof JacobianPoint))
            throw new TypeError('JacobianPoint expected');
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const Z1Z1 = mod(Z1 ** _2n);
        const Z2Z2 = mod(Z2 ** _2n);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
    }
    negate() {
        return new JacobianPoint(this.x, mod(-this.y), this.z);
    }
    double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const A = mod(X1 ** _2n);
        const B = mod(Y1 ** _2n);
        const C = mod(B ** _2n);
        const D = mod(_2n * (mod((X1 + B) ** _2n) - A - C));
        const E = mod(_3n * A);
        const F = mod(E ** _2n);
        const X3 = mod(F - _2n * D);
        const Y3 = mod(E * (D - X3) - _8n * C);
        const Z3 = mod(_2n * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
    }
    add(other) {
        if (!(other instanceof JacobianPoint))
            throw new TypeError('JacobianPoint expected');
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        if (X2 === _0n || Y2 === _0n)
            return this;
        if (X1 === _0n || Y1 === _0n)
            return other;
        const Z1Z1 = mod(Z1 ** _2n);
        const Z2Z2 = mod(Z2 ** _2n);
        const U1 = mod(X1 * Z2Z2);
        const U2 = mod(X2 * Z1Z1);
        const S1 = mod(mod(Y1 * Z2) * Z2Z2);
        const S2 = mod(mod(Y2 * Z1) * Z1Z1);
        const H = mod(U2 - U1);
        const r = mod(S2 - S1);
        if (H === _0n) {
            if (r === _0n) {
                return this.double();
            }
            else {
                return JacobianPoint.ZERO;
            }
        }
        const HH = mod(H ** _2n);
        const HHH = mod(H * HH);
        const V = mod(U1 * HH);
        const X3 = mod(r ** _2n - HHH - _2n * V);
        const Y3 = mod(r * (V - X3) - S1 * HHH);
        const Z3 = mod(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiplyUnsafe(scalar) {
        const P0 = JacobianPoint.ZERO;
        if (typeof scalar === 'bigint' && scalar === _0n)
            return P0;
        let n = normalizeScalar(scalar);
        if (n === _1n)
            return this;
        if (!USE_ENDOMORPHISM) {
            let p = P0;
            let d = this;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        }
        let { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
        let k1p = P0;
        let k2p = P0;
        let d = this;
        while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
                k1p = k1p.add(d);
            if (k2 & _1n)
                k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
        }
        if (k1neg)
            k1p = k1p.negate();
        if (k2neg)
            k2p = k2p.negate();
        k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
    }
    precomputeWindow(W) {
        const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        const points = [];
        let p = this;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            for (let i = 1; i < 2 ** (W - 1); i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE))
            affinePoint = Point.BASE;
        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;
        if (256 % W) {
            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
                precomputes = JacobianPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
            }
        }
        let p = JacobianPoint.ZERO;
        let f = JacobianPoint.ZERO;
        const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for (let window = 0; window < windows; window++) {
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
            }
            if (wbits === 0) {
                let pr = precomputes[offset];
                if (window % 2)
                    pr = pr.negate();
                f = f.add(pr);
            }
            else {
                let cached = precomputes[offset + Math.abs(wbits) - 1];
                if (wbits < 0)
                    cached = cached.negate();
                p = p.add(cached);
            }
        }
        return { p, f };
    }
    multiply(scalar, affinePoint) {
        let n = normalizeScalar(scalar);
        let point;
        let fake;
        if (USE_ENDOMORPHISM) {
            const { k1neg, k1, k2neg, k2 } = splitScalarEndo(n);
            let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
            let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new JacobianPoint(mod(k2p.x * CURVE.beta), k2p.y, k2p.z);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
        }
        else {
            const { p, f } = this.wNAF(n, affinePoint);
            point = p;
            fake = f;
        }
        return JacobianPoint.normalizeZ([point, fake])[0];
    }
    toAffine(invZ = invert(this.z)) {
        const { x, y, z } = this;
        const iz1 = invZ;
        const iz2 = mod(iz1 * iz1);
        const iz3 = mod(iz2 * iz1);
        const ax = mod(x * iz2);
        const ay = mod(y * iz3);
        const zz = mod(z * iz1);
        if (zz !== _1n)
            throw new Error('invZ was invalid');
        return new Point(ax, ay);
    }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);
const pointPrecomputes = new WeakMap();
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
    }
    static fromCompressedHex(bytes) {
        const isShort = bytes.length === 32;
        const x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x))
            throw new Error('Point is not on curve');
        const y2 = weistrass(x);
        let y = sqrtMod(y2);
        const isYOdd = (y & _1n) === _1n;
        if (isShort) {
            if (isYOdd)
                y = mod(-y);
        }
        else {
            const isFirstByteOdd = (bytes[0] & 1) === 1;
            if (isFirstByteOdd !== isYOdd)
                y = mod(-y);
        }
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromUncompressedHex(bytes) {
        const x = bytesToNumber(bytes.subarray(1, 33));
        const y = bytesToNumber(bytes.subarray(33, 65));
        const point = new Point(x, y);
        point.assertValidity();
        return point;
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        const len = bytes.length;
        const header = bytes[0];
        if (len === 32 || (len === 33 && (header === 0x02 || header === 0x03))) {
            return this.fromCompressedHex(bytes);
        }
        if (len === 65 && header === 0x04)
            return this.fromUncompressedHex(bytes);
        throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${len}`);
    }
    static fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normalizePrivateKey(privateKey));
    }
    static fromSignature(msgHash, signature, recovery) {
        msgHash = ensureBytes(msgHash);
        const h = truncateHash(msgHash);
        const { r, s } = normalizeSignature(signature);
        if (recovery !== 0 && recovery !== 1) {
            throw new Error('Cannot recover signature: invalid recovery bit');
        }
        const prefix = recovery & 1 ? '03' : '02';
        const R = Point.fromHex(prefix + numTo32bStr(r));
        const { n } = CURVE;
        const rinv = invert(r, n);
        const u1 = mod(-h * rinv, n);
        const u2 = mod(s * rinv, n);
        const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q)
            throw new Error('Cannot recover signature: point at infinify');
        Q.assertValidity();
        return Q;
    }
    toRawBytes(isCompressed = false) {
        return hexToBytes(this.toHex(isCompressed));
    }
    toHex(isCompressed = false) {
        const x = numTo32bStr(this.x);
        if (isCompressed) {
            const prefix = this.y & _1n ? '03' : '02';
            return `${prefix}${x}`;
        }
        else {
            return `04${x}${numTo32bStr(this.y)}`;
        }
    }
    toHexX() {
        return this.toHex(true).slice(2);
    }
    toRawX() {
        return this.toRawBytes(true).slice(1);
    }
    assertValidity() {
        const msg = 'Point is not on elliptic curve';
        const { x, y } = this;
        if (!isValidFieldElement(x) || !isValidFieldElement(y))
            throw new Error(msg);
        const left = mod(y * y);
        const right = weistrass(x);
        if (mod(left - right) !== _0n)
            throw new Error(msg);
    }
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    negate() {
        return new Point(this.x, mod(-this.y));
    }
    double() {
        return JacobianPoint.fromAffine(this).double().toAffine();
    }
    add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
    multiplyAndAddUnsafe(Q, a, b) {
        const P = JacobianPoint.fromAffine(this);
        const aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        const sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
    }
}
exports.Point = Point;
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _0n);
function sliceDER(s) {
    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
}
function parseDERInt(data) {
    if (data.length < 2 || data[0] !== 0x02) {
        throw new Error(`Invalid signature integer tag: ${bytesToHex(data)}`);
    }
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len) {
        throw new Error(`Invalid signature integer: wrong length`);
    }
    if (res[0] === 0x00 && res[1] <= 0x7f) {
        throw new Error('Invalid signature integer: trailing length');
    }
    return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
    if (data.length < 2 || data[0] != 0x30) {
        throw new Error(`Invalid signature tag: ${bytesToHex(data)}`);
    }
    if (data[1] !== data.length - 2) {
        throw new Error('Invalid signature: incorrect length');
    }
    const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
    const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
    if (rBytesLeft.length) {
        throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(rBytesLeft)}`);
    }
    return { r, s };
}
class Signature {
    constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromCompact(hex) {
        const arr = isUint8a(hex);
        const name = 'Signature.fromCompact';
        if (typeof hex !== 'string' && !arr)
            throw new TypeError(`${name}: Expected string or Uint8Array`);
        const str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128)
            throw new Error(`${name}: Expected 64-byte hex`);
        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
    }
    static fromDER(hex) {
        const arr = isUint8a(hex);
        if (typeof hex !== 'string' && !arr)
            throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
        const { r, s } = parseDERSignature(arr ? hex : hexToBytes(hex));
        return new Signature(r, s);
    }
    static fromHex(hex) {
        return this.fromDER(hex);
    }
    assertValidity() {
        const { r, s } = this;
        if (!isWithinCurveOrder(r))
            throw new Error('Invalid Signature: r must be 0 < r < n');
        if (!isWithinCurveOrder(s))
            throw new Error('Invalid Signature: s must be 0 < s < n');
    }
    hasHighS() {
        const HALF = CURVE.n >> _1n;
        return this.s > HALF;
    }
    normalizeS() {
        return this.hasHighS() ? new Signature(this.r, CURVE.n - this.s) : this;
    }
    toDERRawBytes(isCompressed = false) {
        return hexToBytes(this.toDERHex(isCompressed));
    }
    toDERHex(isCompressed = false) {
        const sHex = sliceDER(numberToHexUnpadded(this.s));
        if (isCompressed)
            return sHex;
        const rHex = sliceDER(numberToHexUnpadded(this.r));
        const rLen = numberToHexUnpadded(rHex.length / 2);
        const sLen = numberToHexUnpadded(sHex.length / 2);
        const length = numberToHexUnpadded(rHex.length / 2 + sHex.length / 2 + 4);
        return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
    }
    toRawBytes() {
        return this.toDERRawBytes();
    }
    toHex() {
        return this.toDERHex();
    }
    toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
}
exports.Signature = Signature;
function concatBytes(...arrays) {
    if (!arrays.every(isUint8a))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function isUint8a(bytes) {
    return bytes instanceof Uint8Array;
}
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
function numTo32bStr(num) {
    if (num > POW_2_256)
        throw new Error('Expected number < 2^256');
    return num.toString(16).padStart(64, '0');
}
function numTo32b(num) {
    return hexToBytes(numTo32bStr(num));
}
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToNumber: expected string, got ' + typeof hex);
    }
    return BigInt(`0x${hex}`);
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
function bytesToNumber(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
function ensureBytes(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
}
function normalizeScalar(num) {
    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0)
        return BigInt(num);
    if (typeof num === 'bigint' && isWithinCurveOrder(num))
        return num;
    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
}
function mod(a, b = CURVE.P) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= P;
    }
    return res;
}
function sqrtMod(x) {
    const { P } = CURVE;
    const _6n = BigInt(6);
    const _11n = BigInt(11);
    const _22n = BigInt(22);
    const _23n = BigInt(23);
    const _44n = BigInt(44);
    const _88n = BigInt(88);
    const b2 = (x * x * x) % P;
    const b3 = (b2 * b2 * x) % P;
    const b6 = (pow2(b3, _3n) * b3) % P;
    const b9 = (pow2(b6, _3n) * b3) % P;
    const b11 = (pow2(b9, _2n) * b2) % P;
    const b22 = (pow2(b11, _11n) * b11) % P;
    const b44 = (pow2(b22, _22n) * b22) % P;
    const b88 = (pow2(b44, _44n) * b44) % P;
    const b176 = (pow2(b88, _88n) * b88) % P;
    const b220 = (pow2(b176, _44n) * b44) % P;
    const b223 = (pow2(b220, _3n) * b3) % P;
    const t1 = (pow2(b223, _23n) * b22) % P;
    const t2 = (pow2(t1, _6n) * b2) % P;
    return pow2(t2, _2n);
}
function invert(number, modulo = CURVE.P) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
    const scratch = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (num === _0n)
            return acc;
        scratch[i] = acc;
        return mod(acc * num, p);
    }, _1n);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i) => {
        if (num === _0n)
            return acc;
        scratch[i] = mod(acc * scratch[i], p);
        return mod(acc * num, p);
    }, inverted);
    return scratch;
}
const divNearest = (a, b) => (a + b / _2n) / b;
const POW_2_128 = _2n ** BigInt(128);
function splitScalarEndo(k) {
    const { n } = CURVE;
    const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
    const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
    const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
    const b2 = a1;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = mod(k - c1 * a1 - c2 * a2, n);
    let k2 = mod(-c1 * b1 - c2 * b2, n);
    const k1neg = k1 > POW_2_128;
    const k2neg = k2 > POW_2_128;
    if (k1neg)
        k1 = n - k1;
    if (k2neg)
        k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
    }
    return { k1neg, k1, k2neg, k2 };
}
function truncateHash(hash) {
    const { n } = CURVE;
    const byteLength = hash.length;
    const delta = byteLength * 8 - 256;
    let h = bytesToNumber(hash);
    if (delta > 0)
        h = h >> BigInt(delta);
    if (h >= n)
        h -= n;
    return h;
}
class HmacDrbg {
    constructor() {
        this.v = new Uint8Array(32).fill(1);
        this.k = new Uint8Array(32).fill(0);
        this.counter = 0;
    }
    hmac(...values) {
        return exports.utils.hmacSha256(this.k, ...values);
    }
    hmacSync(...values) {
        if (typeof exports.utils.hmacSha256Sync !== 'function')
            throw new Error('utils.hmacSha256Sync is undefined, you need to set it');
        const res = exports.utils.hmacSha256Sync(this.k, ...values);
        if (res instanceof Promise)
            throw new Error('To use sync sign(), ensure utils.hmacSha256 is sync');
        return res;
    }
    incr() {
        if (this.counter >= 1000) {
            throw new Error('Tried 1,000 k values for sign(), all were invalid');
        }
        this.counter += 1;
    }
    async reseed(seed = new Uint8Array()) {
        this.k = await this.hmac(this.v, Uint8Array.from([0x00]), seed);
        this.v = await this.hmac(this.v);
        if (seed.length === 0)
            return;
        this.k = await this.hmac(this.v, Uint8Array.from([0x01]), seed);
        this.v = await this.hmac(this.v);
    }
    reseedSync(seed = new Uint8Array()) {
        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0)
            return;
        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);
        this.v = this.hmacSync(this.v);
    }
    async generate() {
        this.incr();
        this.v = await this.hmac(this.v);
        return this.v;
    }
    generateSync() {
        this.incr();
        this.v = this.hmacSync(this.v);
        return this.v;
    }
}
function isWithinCurveOrder(num) {
    return _0n < num && num < CURVE.n;
}
function isValidFieldElement(num) {
    return _0n < num && num < CURVE.P;
}
function kmdToSig(kBytes, m, d) {
    const k = bytesToNumber(kBytes);
    if (!isWithinCurveOrder(k))
        return;
    const { n } = CURVE;
    const q = Point.BASE.multiply(k);
    const r = mod(q.x, n);
    if (r === _0n)
        return;
    const s = mod(invert(k, n) * mod(m + d * r, n), n);
    if (s === _0n)
        return;
    const sig = new Signature(r, s);
    const recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);
    return { sig, recovery };
}
function normalizePrivateKey(key) {
    let num;
    if (typeof key === 'bigint') {
        num = key;
    }
    else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
        num = BigInt(key);
    }
    else if (typeof key === 'string') {
        if (key.length !== 64)
            throw new Error('Expected 32 bytes of private key');
        num = hexToNumber(key);
    }
    else if (isUint8a(key)) {
        if (key.length !== 32)
            throw new Error('Expected 32 bytes of private key');
        num = bytesToNumber(key);
    }
    else {
        throw new TypeError('Expected valid private key');
    }
    if (!isWithinCurveOrder(num))
        throw new Error('Expected private key: 0 < key < n');
    return num;
}
function normalizePublicKey(publicKey) {
    if (publicKey instanceof Point) {
        publicKey.assertValidity();
        return publicKey;
    }
    else {
        return Point.fromHex(publicKey);
    }
}
function normalizeSignature(signature) {
    if (signature instanceof Signature) {
        signature.assertValidity();
        return signature;
    }
    try {
        return Signature.fromDER(signature);
    }
    catch (error) {
        return Signature.fromCompact(signature);
    }
}
function getPublicKey(privateKey, isCompressed = false) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
exports.getPublicKey = getPublicKey;
function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
    return Point.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
}
exports.recoverPublicKey = recoverPublicKey;
function isPub(item) {
    const arr = isUint8a(item);
    const str = typeof item === 'string';
    const len = (arr || str) && item.length;
    if (arr)
        return len === 33 || len === 65;
    if (str)
        return len === 66 || len === 130;
    if (item instanceof Point)
        return true;
    return false;
}
function getSharedSecret(privateA, publicB, isCompressed = false) {
    if (isPub(privateA))
        throw new TypeError('getSharedSecret: first arg must be private key');
    if (!isPub(publicB))
        throw new TypeError('getSharedSecret: second arg must be public key');
    const b = normalizePublicKey(publicB);
    b.assertValidity();
    return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
}
exports.getSharedSecret = getSharedSecret;
function bits2int(bytes) {
    const slice = bytes.length > 32 ? bytes.slice(0, 32) : bytes;
    return bytesToNumber(slice);
}
function bits2octets(bytes) {
    const z1 = bits2int(bytes);
    const z2 = mod(z1, CURVE.n);
    return int2octets(z2 < _0n ? z1 : z2);
}
function int2octets(num) {
    if (typeof num !== 'bigint')
        throw new Error('Expected bigint');
    const hex = numTo32bStr(num);
    return hexToBytes(hex);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
    if (msgHash == null)
        throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
    const h1 = ensureBytes(msgHash);
    const d = normalizePrivateKey(privateKey);
    const seedArgs = [int2octets(d), bits2octets(h1)];
    if (extraEntropy != null) {
        if (extraEntropy === true)
            extraEntropy = exports.utils.randomBytes(32);
        const e = ensureBytes(extraEntropy);
        if (e.length !== 32)
            throw new Error('sign: Expected 32 bytes of extra data');
        seedArgs.push(e);
    }
    const seed = concatBytes(...seedArgs);
    const m = bits2int(h1);
    return { seed, m, d };
}
function finalizeSig(recSig, opts) {
    let { sig, recovery } = recSig;
    const { canonical, der, recovered } = Object.assign({ canonical: true, der: true }, opts);
    if (canonical && sig.hasHighS()) {
        sig = sig.normalizeS();
        recovery ^= 1;
    }
    const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
    return recovered ? [hashed, recovery] : hashed;
}
async function sign(msgHash, privKey, opts = {}) {
    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    let sig;
    const drbg = new HmacDrbg();
    await drbg.reseed(seed);
    while (!(sig = kmdToSig(await drbg.generate(), m, d)))
        await drbg.reseed();
    return finalizeSig(sig, opts);
}
exports.sign = sign;
function signSync(msgHash, privKey, opts = {}) {
    const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
    let sig;
    const drbg = new HmacDrbg();
    drbg.reseedSync(seed);
    while (!(sig = kmdToSig(drbg.generateSync(), m, d)))
        drbg.reseedSync();
    return finalizeSig(sig, opts);
}
exports.signSync = signSync;
const vopts = { strict: true };
function verify(signature, msgHash, publicKey, opts = vopts) {
    let sig;
    try {
        sig = normalizeSignature(signature);
        msgHash = ensureBytes(msgHash);
    }
    catch (error) {
        return false;
    }
    const { r, s } = sig;
    if (opts.strict && sig.hasHighS())
        return false;
    const h = truncateHash(msgHash);
    let P;
    try {
        P = normalizePublicKey(publicKey);
    }
    catch (error) {
        return false;
    }
    const { n } = CURVE;
    const sinv = invert(s, n);
    const u1 = mod(h * sinv, n);
    const u2 = mod(r * sinv, n);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2);
    if (!R)
        return false;
    const v = mod(R.x, n);
    return v === r;
}
exports.verify = verify;
function finalizeSchnorrChallenge(ch) {
    return mod(bytesToNumber(ch), CURVE.n);
}
function hasEvenY(point) {
    return (point.y & _1n) === _0n;
}
class SchnorrSignature {
    constructor(r, s) {
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex);
        if (bytes.length !== 64)
            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
        const r = bytesToNumber(bytes.subarray(0, 32));
        const s = bytesToNumber(bytes.subarray(32, 64));
        return new SchnorrSignature(r, s);
    }
    assertValidity() {
        const { r, s } = this;
        if (!isValidFieldElement(r) || !isWithinCurveOrder(s))
            throw new Error('Invalid signature');
    }
    toHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
    }
    toRawBytes() {
        return hexToBytes(this.toHex());
    }
}
function schnorrGetPublicKey(privateKey) {
    return Point.fromPrivateKey(privateKey).toRawX();
}
function initSchnorrSigArgs(message, privateKey, auxRand) {
    if (message == null)
        throw new TypeError(`sign: Expected valid message, not "${message}"`);
    const m = ensureBytes(message);
    const d0 = normalizePrivateKey(privateKey);
    const rand = ensureBytes(auxRand);
    if (rand.length !== 32)
        throw new TypeError('sign: Expected 32 bytes of aux randomness');
    const P = Point.fromPrivateKey(d0);
    const px = P.toRawX();
    const d = hasEvenY(P) ? d0 : CURVE.n - d0;
    return { m, P, px, d, rand };
}
function initSchnorrNonce(d, t0h) {
    return numTo32b(d ^ bytesToNumber(t0h));
}
function finalizeSchnorrNonce(k0h) {
    const k0 = mod(bytesToNumber(k0h), CURVE.n);
    if (k0 === _0n)
        throw new Error('sign: Creation of signature failed. k is zero');
    const R = Point.fromPrivateKey(k0);
    const rx = R.toRawX();
    const k = hasEvenY(R) ? k0 : CURVE.n - k0;
    return { R, rx, k };
}
function finalizeSchnorrSig(R, k, e, d) {
    return new SchnorrSignature(R.x, mod(k + e * d, CURVE.n)).toRawBytes();
}
async function schnorrSign(message, privateKey, auxRand = exports.utils.randomBytes()) {
    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);
    const t = initSchnorrNonce(d, await exports.utils.taggedHash(TAGS.aux, rand));
    const { R, rx, k } = finalizeSchnorrNonce(await exports.utils.taggedHash(TAGS.nonce, t, px, m));
    const e = finalizeSchnorrChallenge(await exports.utils.taggedHash(TAGS.challenge, rx, px, m));
    const sig = finalizeSchnorrSig(R, k, e, d);
    const isValid = await schnorrVerify(sig, m, px);
    if (!isValid)
        throw new Error('sign: Invalid signature produced');
    return sig;
}
function schnorrSignSync(message, privateKey, auxRand = exports.utils.randomBytes()) {
    const { m, px, d, rand } = initSchnorrSigArgs(message, privateKey, auxRand);
    const t = initSchnorrNonce(d, exports.utils.taggedHashSync(TAGS.aux, rand));
    const { R, rx, k } = finalizeSchnorrNonce(exports.utils.taggedHashSync(TAGS.nonce, t, px, m));
    const e = finalizeSchnorrChallenge(exports.utils.taggedHashSync(TAGS.challenge, rx, px, m));
    const sig = finalizeSchnorrSig(R, k, e, d);
    const isValid = schnorrVerifySync(sig, m, px);
    if (!isValid)
        throw new Error('sign: Invalid signature produced');
    return sig;
}
function initSchnorrVerify(signature, message, publicKey) {
    const raw = signature instanceof SchnorrSignature;
    const sig = raw ? signature : SchnorrSignature.fromHex(signature);
    if (raw)
        sig.assertValidity();
    return {
        ...sig,
        m: ensureBytes(message),
        P: normalizePublicKey(publicKey),
    };
}
function finalizeSchnorrVerify(r, P, s, e) {
    const R = Point.BASE.multiplyAndAddUnsafe(P, normalizePrivateKey(s), mod(-e, CURVE.n));
    if (!R || !hasEvenY(R) || R.x !== r)
        return false;
    return true;
}
async function schnorrVerify(signature, message, publicKey) {
    try {
        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
        const e = finalizeSchnorrChallenge(await exports.utils.taggedHash(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
    }
    catch (error) {
        return false;
    }
}
function schnorrVerifySync(signature, message, publicKey) {
    try {
        const { r, s, m, P } = initSchnorrVerify(signature, message, publicKey);
        const e = finalizeSchnorrChallenge(exports.utils.taggedHashSync(TAGS.challenge, numTo32b(r), P.toRawX(), m));
        return finalizeSchnorrVerify(r, P, s, e);
    }
    catch (error) {
        return false;
    }
}
exports.schnorr = {
    Signature: SchnorrSignature,
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    signSync: schnorrSignSync,
    verifySync: schnorrVerifySync,
};
Point.BASE._setWindowSize(8);
const crypto = {
    node: nodeCrypto,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};
const TAGS = {
    challenge: 'BIP0340/challenge',
    aux: 'BIP0340/aux',
    nonce: 'BIP0340/nonce',
};
const TAGGED_HASH_PREFIXES = {};
exports.utils = {
    isValidPrivateKey(privateKey) {
        try {
            normalizePrivateKey(privateKey);
            return true;
        }
        catch (error) {
            return false;
        }
    },
    privateAdd: (privateKey, tweak) => {
        const p = normalizePrivateKey(privateKey);
        const t = normalizePrivateKey(tweak);
        return numTo32b(mod(p + t, CURVE.n));
    },
    privateNegate: (privateKey) => {
        const p = normalizePrivateKey(privateKey);
        return numTo32b(CURVE.n - p);
    },
    pointAddScalar: (p, tweak, isCompressed) => {
        const P = Point.fromHex(p);
        const t = normalizePrivateKey(tweak);
        const Q = Point.BASE.multiplyAndAddUnsafe(P, t, _1n);
        if (!Q)
            throw new Error('Tweaked point at infinity');
        return Q.toRawBytes(isCompressed);
    },
    pointMultiply: (p, tweak, isCompressed) => {
        const P = Point.fromHex(p);
        const t = bytesToNumber(ensureBytes(tweak));
        return P.multiply(t).toRawBytes(isCompressed);
    },
    hashToPrivateKey: (hash) => {
        hash = ensureBytes(hash);
        if (hash.length < 40 || hash.length > 1024)
            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
        const num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;
        return numTo32b(num);
    },
    randomBytes: (bytesLength = 32) => {
        if (crypto.web) {
            return crypto.web.getRandomValues(new Uint8Array(bytesLength));
        }
        else if (crypto.node) {
            const { randomBytes } = crypto.node;
            return Uint8Array.from(randomBytes(bytesLength));
        }
        else {
            throw new Error("The environment doesn't have randomBytes function");
        }
    },
    randomPrivateKey: () => {
        return exports.utils.hashToPrivateKey(exports.utils.randomBytes(40));
    },
    bytesToHex,
    hexToBytes,
    concatBytes,
    mod,
    invert,
    sha256: async (...messages) => {
        if (crypto.web) {
            const buffer = await crypto.web.subtle.digest('SHA-256', concatBytes(...messages));
            return new Uint8Array(buffer);
        }
        else if (crypto.node) {
            const { createHash } = crypto.node;
            const hash = createHash('sha256');
            messages.forEach((m) => hash.update(m));
            return Uint8Array.from(hash.digest());
        }
        else {
            throw new Error("The environment doesn't have sha256 function");
        }
    },
    hmacSha256: async (key, ...messages) => {
        if (crypto.web) {
            const ckey = await crypto.web.subtle.importKey('raw', key, { name: 'HMAC', hash: { name: 'SHA-256' } }, false, ['sign']);
            const message = concatBytes(...messages);
            const buffer = await crypto.web.subtle.sign('HMAC', ckey, message);
            return new Uint8Array(buffer);
        }
        else if (crypto.node) {
            const { createHmac } = crypto.node;
            const hash = createHmac('sha256', key);
            messages.forEach((m) => hash.update(m));
            return Uint8Array.from(hash.digest());
        }
        else {
            throw new Error("The environment doesn't have hmac-sha256 function");
        }
    },
    sha256Sync: undefined,
    hmacSha256Sync: undefined,
    taggedHash: async (tag, ...messages) => {
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = await exports.utils.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return exports.utils.sha256(tagP, ...messages);
    },
    taggedHashSync: (tag, ...messages) => {
        if (typeof exports.utils.sha256Sync !== 'function')
            throw new Error('utils.sha256Sync is undefined, you need to set it');
        let tagP = TAGGED_HASH_PREFIXES[tag];
        if (tagP === undefined) {
            const tagH = exports.utils.sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
            tagP = concatBytes(tagH, tagH);
            TAGGED_HASH_PREFIXES[tag] = tagP;
        }
        return exports.utils.sha256Sync(tagP, ...messages);
    },
    precompute(windowSize = 8, point = Point.BASE) {
        const cached = point === Point.BASE ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_3n);
        return cached;
    },
};

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@noble/secp256k1",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\secp256k1\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@scure\\bip32\\lib\\index.js", {"@noble/hashes/_assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\_assert.js","@noble/hashes/hmac":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\hmac.js","@noble/hashes/ripemd160":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\ripemd160.js","@noble/hashes/sha256":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\sha256.js","@noble/hashes/sha512":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\sha512.js","@noble/hashes/utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\hashes\\utils.js","@noble/secp256k1":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@noble\\secp256k1\\lib\\index.js","@scure/base":"F:\\metamask-extension\\node_modules\\@scure\\base\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5C@scure%5Cbip32%5Clib%5Cindex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKey = exports.HARDENED_OFFSET = void 0;
const hmac_1 = require("@noble/hashes/hmac");
const ripemd160_1 = require("@noble/hashes/ripemd160");
const sha256_1 = require("@noble/hashes/sha256");
const sha512_1 = require("@noble/hashes/sha512");
const _assert_1 = require("@noble/hashes/_assert");
const utils_1 = require("@noble/hashes/utils");
const secp = require("@noble/secp256k1");
const base_1 = require("@scure/base");
secp.utils.hmacSha256Sync = (key, ...messages) => {
    const h = hmac_1.hmac.create(sha256_1.sha256, key);
    messages.forEach((msg) => h.update(msg));
    return h.digest();
};
const base58c = (0, base_1.base58check)(sha256_1.sha256);
function bytesToNumber(bytes) {
    return BigInt(`0x${(0, utils_1.bytesToHex)(bytes)}`);
}
function numberToBytes(num) {
    return (0, utils_1.hexToBytes)(num.toString(16).padStart(64, '0'));
}
const MASTER_SECRET = (0, utils_1.utf8ToBytes)('Bitcoin seed');
const BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };
exports.HARDENED_OFFSET = 0x80000000;
const hash160 = (data) => (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(data));
const fromU32 = (data) => (0, utils_1.createView)(data).getUint32(0, false);
const toU32 = (n) => {
    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
        throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);
    }
    const buf = new Uint8Array(4);
    (0, utils_1.createView)(buf).setUint32(0, n, false);
    return buf;
};
class HDKey {
    constructor(opt) {
        this.depth = 0;
        this.index = 0;
        this.chainCode = null;
        this.parentFingerprint = 0;
        if (!opt || typeof opt !== 'object') {
            throw new Error('HDKey.constructor must not be called directly');
        }
        this.versions = opt.versions || BITCOIN_VERSIONS;
        this.depth = opt.depth || 0;
        this.chainCode = opt.chainCode;
        this.index = opt.index || 0;
        this.parentFingerprint = opt.parentFingerprint || 0;
        if (!this.depth) {
            if (this.parentFingerprint || this.index) {
                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');
            }
        }
        if (opt.publicKey && opt.privateKey) {
            throw new Error('HDKey: publicKey and privateKey at same time.');
        }
        if (opt.privateKey) {
            if (!secp.utils.isValidPrivateKey(opt.privateKey)) {
                throw new Error('Invalid private key');
            }
            this.privKey =
                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);
            this.privKeyBytes = numberToBytes(this.privKey);
            this.pubKey = secp.getPublicKey(opt.privateKey, true);
        }
        else if (opt.publicKey) {
            this.pubKey = secp.Point.fromHex(opt.publicKey).toRawBytes(true);
        }
        else {
            throw new Error('HDKey: no public or private key provided');
        }
        this.pubHash = hash160(this.pubKey);
    }
    get fingerprint() {
        if (!this.pubHash) {
            throw new Error('No publicKey set!');
        }
        return fromU32(this.pubHash);
    }
    get identifier() {
        return this.pubHash;
    }
    get pubKeyHash() {
        return this.pubHash;
    }
    get privateKey() {
        return this.privKeyBytes || null;
    }
    get publicKey() {
        return this.pubKey || null;
    }
    get privateExtendedKey() {
        const priv = this.privateKey;
        if (!priv) {
            throw new Error('No private key');
        }
        return base58c.encode(this.serialize(this.versions.private, (0, utils_1.concatBytes)(new Uint8Array([0]), priv)));
    }
    get publicExtendedKey() {
        if (!this.pubKey) {
            throw new Error('No public key');
        }
        return base58c.encode(this.serialize(this.versions.public, this.pubKey));
    }
    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
        if (8 * seed.length < 128 || 8 * seed.length > 512) {
            throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
        }
        const I = (0, hmac_1.hmac)(sha512_1.sha512, MASTER_SECRET, seed);
        return new HDKey({
            versions,
            chainCode: I.slice(32),
            privateKey: I.slice(0, 32),
        });
    }
    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
        const keyBuffer = base58c.decode(base58key);
        const keyView = (0, utils_1.createView)(keyBuffer);
        const version = keyView.getUint32(0, false);
        const opt = {
            versions,
            depth: keyBuffer[4],
            parentFingerprint: keyView.getUint32(5, false),
            index: keyView.getUint32(9, false),
            chainCode: keyBuffer.slice(13, 45),
        };
        const key = keyBuffer.slice(45);
        const isPriv = key[0] === 0;
        if (version !== versions[isPriv ? 'private' : 'public']) {
            throw new Error('Version mismatch');
        }
        if (isPriv) {
            return new HDKey({ ...opt, privateKey: key.slice(1) });
        }
        else {
            return new HDKey({ ...opt, publicKey: key });
        }
    }
    static fromJSON(json) {
        return HDKey.fromExtendedKey(json.xpriv);
    }
    derive(path) {
        if (!/^[mM]'?/.test(path)) {
            throw new Error('Path must start with "m" or "M"');
        }
        if (/^[mM]'?$/.test(path)) {
            return this;
        }
        const parts = path.replace(/^[mM]'?\//, '').split('/');
        let child = this;
        for (const c of parts) {
            const m = /^(\d+)('?)$/.exec(c);
            if (!m || m.length !== 3) {
                throw new Error(`Invalid child index: ${c}`);
            }
            let idx = +m[1];
            if (!Number.isSafeInteger(idx) || idx >= exports.HARDENED_OFFSET) {
                throw new Error('Invalid index');
            }
            if (m[2] === "'") {
                idx += exports.HARDENED_OFFSET;
            }
            child = child.deriveChild(idx);
        }
        return child;
    }
    deriveChild(index) {
        if (!this.pubKey || !this.chainCode) {
            throw new Error('No publicKey or chainCode set');
        }
        let data = toU32(index);
        if (index >= exports.HARDENED_OFFSET) {
            const priv = this.privateKey;
            if (!priv) {
                throw new Error('Could not derive hardened child key');
            }
            data = (0, utils_1.concatBytes)(new Uint8Array([0]), priv, data);
        }
        else {
            data = (0, utils_1.concatBytes)(this.pubKey, data);
        }
        const I = (0, hmac_1.hmac)(sha512_1.sha512, this.chainCode, data);
        const childTweak = bytesToNumber(I.slice(0, 32));
        const chainCode = I.slice(32);
        if (!secp.utils.isValidPrivateKey(childTweak)) {
            throw new Error('Tweak bigger than curve order');
        }
        const opt = {
            versions: this.versions,
            chainCode,
            depth: this.depth + 1,
            parentFingerprint: this.fingerprint,
            index,
        };
        try {
            if (this.privateKey) {
                const added = secp.utils.mod(this.privKey + childTweak, secp.CURVE.n);
                if (!secp.utils.isValidPrivateKey(added)) {
                    throw new Error('The tweak was out of range or the resulted private key is invalid');
                }
                opt.privateKey = added;
            }
            else {
                opt.publicKey = secp.Point.fromHex(this.pubKey)
                    .add(secp.Point.fromPrivateKey(childTweak))
                    .toRawBytes(true);
            }
            return new HDKey(opt);
        }
        catch (err) {
            return this.deriveChild(index + 1);
        }
    }
    sign(hash) {
        if (!this.privateKey) {
            throw new Error('No privateKey set!');
        }
        (0, _assert_1.bytes)(hash, 32);
        return secp.signSync(hash, this.privKey, {
            canonical: true,
            der: false,
        });
    }
    verify(hash, signature) {
        (0, _assert_1.bytes)(hash, 32);
        (0, _assert_1.bytes)(signature, 64);
        if (!this.publicKey) {
            throw new Error('No publicKey set!');
        }
        let sig;
        try {
            sig = secp.Signature.fromCompact(signature);
        }
        catch (error) {
            return false;
        }
        return secp.verify(sig, hash, this.publicKey);
    }
    wipePrivateData() {
        this.privKey = undefined;
        if (this.privKeyBytes) {
            this.privKeyBytes.fill(0);
            this.privKeyBytes = undefined;
        }
        return this;
    }
    toJSON() {
        return {
            xpriv: this.privateExtendedKey,
            xpub: this.publicExtendedKey,
        };
    }
    serialize(version, key) {
        if (!this.chainCode) {
            throw new Error('No chainCode set');
        }
        (0, _assert_1.bytes)(key, 33);
        return (0, utils_1.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
    }
}
exports.HDKey = HDKey;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@scure/bip32",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@scure\\bip32\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\hdkey.js", {"@scure/bip32":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\@scure\\bip32\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5Cethereum-cryptography%5Chdkey.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKey = exports.HARDENED_OFFSET = void 0;
var bip32_1 = require("@scure/bip32");
Object.defineProperty(exports, "HARDENED_OFFSET", { enumerable: true, get: function () { return bip32_1.HARDENED_OFFSET; } });
Object.defineProperty(exports, "HDKey", { enumerable: true, get: function () { return bip32_1.HDKey; } });

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\hdkey.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\keccak.js", {"./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\utils.js","@noble/hashes/sha3":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5Cethereum-cryptography%5Ckeccak.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const utils_1 = require("./utils");
exports.keccak224 = (0, utils_1.wrapHash)(sha3_1.keccak_224);
exports.keccak256 = (() => {
    const k = (0, utils_1.wrapHash)(sha3_1.keccak_256);
    k.create = sha3_1.keccak_256.create;
    return k;
})();
exports.keccak384 = (0, utils_1.wrapHash)(sha3_1.keccak_384);
exports.keccak512 = (0, utils_1.wrapHash)(sha3_1.keccak_512);

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\keccak.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5C_assert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
exports.default = assert;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5C_u64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig: exports.toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5CcryptoBrowser.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = {
    node: undefined,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js", {"./_assert.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js","./_u64.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js","./utils.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5Csha3.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = require("./_assert.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        _assert_js_1.default.number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js", {"@noble/hashes/crypto":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5Cutils.js
      return function (require, module, exports) {
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// The import here is via the package name. This is to ensure
// that exports mapping/resolution does fall into place.
const crypto_1 = require("@noble/hashes/crypto");
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
 */
function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('deadbeef')
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */
function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new TypeError('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
/**
 * Secure PRNG
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
    }
    else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
    }
    else {
        throw new Error("The environment doesn't have randomBytes function");
    }
}
exports.randomBytes = randomBytes;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\utils.js", {"@noble/hashes/_assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js","@noble/hashes/utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-hd-keyring%5Cnode_modules%5Cethereum-cryptography%5Cutils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
// buf.toString('hex') -> toHex(buf)
const _assert_1 = __importDefault(require("@noble/hashes/_assert"));
const utils_1 = require("@noble/hashes/utils");
const assertBool = _assert_1.default.bool;
exports.assertBool = assertBool;
const assertBytes = _assert_1.default.bytes;
exports.assertBytes = assertBytes;
var utils_2 = require("@noble/hashes/utils");
Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return utils_2.concatBytes; } });
Object.defineProperty(exports, "createView", { enumerable: true, get: function () { return utils_2.createView; } });
Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function () { return utils_2.utf8ToBytes; } });
// buf.toString('utf8') -> bytesToUtf8(buf)
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
exports.bytesToUtf8 = bytesToUtf8;
function hexToBytes(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return (0, utils_1.hexToBytes)(sliced);
}
exports.hexToBytes = hexToBytes;
// buf.equals(buf2) -> equalsBytes(buf, buf2)
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.equalsBytes = equalsBytes;
// Internal utils
function wrapHash(hash) {
    return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
    };
}
exports.wrapHash = wrapHash;
exports.crypto = (() => {
    const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : undefined;
    const nodeRequire = typeof module !== "undefined" &&
        typeof module.require === "function" &&
        module.require.bind(module);
    return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
        web: webCrypto
    };
})();

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-hd-keyring>ethereum-cryptography",file:"node_modules\\@metamask\\eth-hd-keyring\\node_modules\\ethereum-cryptography\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js", {"./fetch-config-from-req":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js","./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js","eth-rpc-errors":"F:\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","node-fetch":"F:\\metamask-extension\\node_modules\\node-fetch\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Ccreate-infura-middleware.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInfuraMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const node_fetch_1 = __importDefault(require("node-fetch"));
const fetch_config_from_req_1 = require("./fetch-config-from-req");
const logging_utils_1 = require("./logging-utils");
const log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, 'create-infura-middleware');
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    'ECONNRESET',
    // ignore server sent html error pages
    // or truncated json responses
    'SyntaxError',
];
/**
 * Builds [`json-rpc-engine`](https://github.com/MetaMask/json-rpc-engine)-compatible middleware designed
 * for interfacing with Infura's JSON-RPC endpoints.
 *
 * @param opts - The options.
 * @param opts.network - A network that Infura supports; plugs into
 * `https://${network}.infura.io` (default: 'mainnet').
 * @param opts.maxAttempts - The number of times a request to Infura should be
 * retried in the case of failure (default: 5).
 * @param opts.source - A descriptor for the entity making the request; tracked
 * by Infura for analytics purposes.
 * @param opts.projectId - The Infura project id.
 * @param opts.headers - Extra headers that will be used to make the request.
 * @returns The `json-rpc-engine`-compatible middleware.
 */
function createInfuraMiddleware({ network = 'mainnet', maxAttempts = 5, source, projectId, headers = {}, }) {
    // validate options
    if (!projectId || typeof projectId !== 'string') {
        throw new Error(`Invalid value for 'projectId': "${projectId}"`);
    }
    if (!headers || typeof headers !== 'object') {
        throw new Error(`Invalid value for 'headers': "${headers}"`);
    }
    if (!maxAttempts) {
        throw new Error(`Invalid value for 'maxAttempts': "${maxAttempts}" (${typeof maxAttempts})`);
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res) => {
        // retry MAX_ATTEMPTS times, if error matches filter
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                // attempt request
                log('Attempting request to Infura. network = %o, projectId = %s, headers = %o, req = %o', network, projectId, headers, req);
                await performFetch(network, projectId, headers, req, res, source);
                // request was successful
                break;
            }
            catch (err) {
                // an error was caught while performing the request
                // if not retriable, resolve with the encountered error
                if (!isRetriableError(err)) {
                    // abort with error
                    log('Non-retriable request error encountered. req = %o, res = %o, error = %o', req, res, err);
                    throw err;
                }
                // if no more attempts remaining, throw an error
                const remainingAttempts = maxAttempts - attempt;
                if (!remainingAttempts) {
                    log('Retriable request error encountered, but exceeded max attempts. req = %o, res = %o, error = %o', req, res, err);
                    const errMsg = `InfuraProvider - cannot complete request. All retries exhausted.\nOriginal Error:\n${err.toString()}\n\n`;
                    const retriesExhaustedErr = new Error(errMsg);
                    throw retriesExhaustedErr;
                }
                // otherwise, ignore error and retry again after timeout
                log('Retriable request error encountered. req = %o, res = %o, error = %o', req, res, err);
                log('Waiting 1 second to try again...');
                await timeout(1000);
            }
        }
        // request was handled correctly, end
    });
}
exports.createInfuraMiddleware = createInfuraMiddleware;
/**
 * Makes a request to Infura, updating the given response object if the response
 * has a "successful" status code or throwing an error otherwise.
 *
 * @param network - A network that Infura supports; plugs into
 * `https://${network}.infura.io`.
 * @param projectId - The Infura project id.
 * @param extraHeaders - Extra headers that will be used to make the request.
 * @param req - The original request object obtained via the middleware stack.
 * @param res - The original response object obtained via the middleware stack.
 * @param source - A descriptor for the entity making the request;
 * tracked by Infura for analytics purposes.
 * @throws an error with a detailed message if the HTTP status code is anywhere
 * outside 2xx, and especially if it is 405, 429, 503, or 504.
 */
async function performFetch(network, projectId, extraHeaders, req, res, source) {
    const { fetchUrl, fetchParams } = (0, fetch_config_from_req_1.fetchConfigFromReq)({
        network,
        projectId,
        extraHeaders,
        req,
        source,
    });
    const response = await (0, node_fetch_1.default)(fetchUrl, fetchParams);
    const rawData = await response.text();
    // handle errors
    if (!response.ok) {
        switch (response.status) {
            case 405:
                throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
            case 429:
                throw createRatelimitError();
            case 503:
            case 504:
                throw createTimeoutError();
            default:
                throw createInternalError(rawData);
        }
    }
    // special case for now
    if (req.method === 'eth_getBlockByNumber' && rawData === 'Not Found') {
        res.result = null;
        return;
    }
    // parse JSON
    const data = JSON.parse(rawData);
    // finally return result
    res.result = data.result;
    res.error = data.error;
}
/**
 * Builds a JSON-RPC 2.0 internal error object describing a rate-limiting
 * error.
 *
 * @returns The error object.
 */
function createRatelimitError() {
    const msg = `Request is being rate limited.`;
    return createInternalError(msg);
}
/**
 * Builds a JSON-RPC 2.0 internal error object describing a timeout error.
 *
 * @returns The error object.
 */
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return createInternalError(msg);
}
/**
 * Builds a JSON-RPC 2.0 internal error object.
 *
 * @param msg - The message.
 * @returns The error object.
 */
function createInternalError(msg) {
    return eth_rpc_errors_1.ethErrors.rpc.internal(msg);
}
/**
 * Upon making a request, we may get an error that is temporary and
 * intermittent. In these cases we can attempt the request again with the
 * assumption that the error is unlikely to occur again. Here we determine if we
 * have received such an error.
 *
 * @param err - The error object.
 * @returns Whether the request that produced the error can be retried.
 */
function isRetriableError(err) {
    const errMessage = err.toString();
    return RETRIABLE_ERRORS.some((phrase) => errMessage.includes(phrase));
}
/**
 * A utility function that promisifies `setTimeout`.
 *
 * @param length - The number of milliseconds to wait.
 * @returns A promise that resolves after the given time has elapsed.
 */
function timeout(length) {
    return new Promise((resolve) => {
        setTimeout(resolve, length);
    });
}
//# sourceMappingURL=create-infura-middleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js", {"./create-infura-middleware":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js","eth-json-rpc-middleware":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Ccreate-provider.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProvider = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_json_rpc_middleware_1 = require("eth-json-rpc-middleware");
const create_infura_middleware_1 = require("./create-infura-middleware");
/**
 * Creates a provider (as defined in
 * [`eth-json-rpc-middleware`](https://github.com/MetaMask/eth-json-rpc-middleware)
 * which is preloaded with middleware specialized for interfacing with Infura
 * JSON-RPC endpoints.
 *
 * @param opts - Options to {@link createInfuraMiddleware}.
 * @returns The provider as returned by `providerFromEngine` (a part of
 * [`eth-json-rpc-middleware`](https://github.com/MetaMask/eth-json-rpc-middleware)).
 */
function createProvider(opts) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push((0, create_infura_middleware_1.createInfuraMiddleware)(opts));
    return (0, eth_json_rpc_middleware_1.providerFromEngine)(engine);
}
exports.createProvider = createProvider;
//# sourceMappingURL=create-provider.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Cfetch-config-from-req.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchConfigFromReq = void 0;
/**
 * Determines the arguments to feed into `fetch` in order to make a request to
 * Infura.
 *
 * @param options - The options.
 * @param options.network - A network that Infura supports; plugs into
 * `https://${network}.infura.io`.
 * @param options.projectId - The Infura project id.
 * @param options.extraHeaders - Extra headers that will be used to make the
 * request.
 * @param options.req - The original request object obtained via the
 * middleware stack.
 * @param options.source - A descriptor for the entity making the request;
 * tracked by Infura for analytics purposes.
 * @returns An object containing the URL and a bag of options, both of which
 * will be passed to `fetch`.
 */
function fetchConfigFromReq({ network, projectId, extraHeaders = {}, req, source, }) {
    const requestOrigin = req.origin || 'internal';
    const headers = Object.assign({}, extraHeaders, {
        Accept: 'application/json',
        'Content-Type': 'application/json',
    });
    if (source) {
        headers['Infura-Source'] = `${source}/${requestOrigin}`;
    }
    return {
        fetchUrl: `https://${network}.infura.io/v3/${projectId}`,
        fetchParams: {
            method: 'POST',
            headers,
            body: JSON.stringify(normalizeReq(req)),
        },
    };
}
exports.fetchConfigFromReq = fetchConfigFromReq;
/**
 * Strips out extra keys from a request object that could be rejected by strict
 * nodes like parity.
 *
 * @param req - The original request object obtained via the middleware stack.
 * @returns An object that describes a JSON-RPC request.
 */
function normalizeReq(req) {
    return {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
}
//# sourceMappingURL=fetch-config-from-req.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\index.js", {"./create-infura-middleware":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js","./create-provider":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js","./fetch-config-from-req":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./create-infura-middleware"), exports);
__exportStar(require("./fetch-config-from-req"), exports);
__exportStar(require("./create-provider"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cdist%5Clogging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = (0, utils_1.createProjectLogger)('eth-json-rpc-infura');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura",file:"node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js", {"superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cassert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
const superstruct_1 = require("superstruct");
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
/**
 * Check if a value is a constructor, i.e., a function that can be called with
 * the `new` keyword.
 *
 * @param fn - The value to check.
 * @returns `true` if the value is a constructor, or `false` otherwise.
 */
function isConstructable(fn) {
    var _a, _b;
    /* istanbul ignore next */
    return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
}
/**
 * Get the error message from an unknown error object. If the error object has
 * a `message` property, that property is returned. Otherwise, the stringified
 * error object is returned.
 *
 * @param error - The error object to get the message from.
 * @returns The error message.
 */
function getErrorMessage(error) {
    const message = isErrorWithMessage(error) ? error.message : String(error);
    // If the error ends with a period, remove it, as we'll add our own period.
    if (message.endsWith('.')) {
        return message.slice(0, -1);
    }
    return message;
}
/**
 * Initialise an {@link AssertionErrorConstructor} error.
 *
 * @param ErrorWrapper - The error class to use.
 * @param message - The error message.
 * @returns The error object.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getError(ErrorWrapper, message) {
    if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
            message,
        });
    }
    return ErrorWrapper({
        message,
    });
}
/**
 * The default error class that is thrown if an assertion fails.
 */
class AssertionError extends Error {
    constructor(options) {
        super(options.message);
        this.code = 'ERR_ASSERTION';
    }
}
exports.AssertionError = AssertionError;
/**
 * Same as Node.js assert.
 * If the value is falsy, throws an error, does nothing otherwise.
 *
 * @throws {@link AssertionError} If value is falsy.
 * @param value - The test that should be truthy to pass.
 * @param message - Message to be passed to {@link AssertionError} or an
 * {@link Error} instance to throw.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}. If a custom error class is provided for
 * the `message` argument, this argument is ignored.
 */
function assert(value, message = 'Assertion failed.', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    if (!value) {
        if (message instanceof Error) {
            throw message;
        }
        throw getError(ErrorWrapper, message);
    }
}
exports.assert = assert;
/**
 * Assert a value against a Superstruct struct.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param errorPrefix - A prefix to add to the error message. Defaults to
 * "Assertion failed".
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the value is not valid.
 */
function assertStruct(value, struct, errorPrefix = 'Assertion failed', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    try {
        (0, superstruct_1.assert)(value, struct);
    }
    catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
    }
}
exports.assertStruct = assertStruct;
/**
 * Use in the default case of a switch that you want to be fully exhaustive.
 * Using this function forces the compiler to enforce exhaustivity during
 * compile-time.
 *
 * @example
 * ```
 * const number = 1;
 * switch (number) {
 *   case 0:
 *     ...
 *   case 1:
 *     ...
 *   default:
 *     assertExhaustive(snapPrefix);
 * }
 * ```
 * @param _object - The object on which the switch is being operated.
 */
function assertExhaustive(_object) {
    throw new Error('Invalid branch reached. Should be detected during compilation.');
}
exports.assertExhaustive = assertExhaustive;
//# sourceMappingURL=assert.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbase64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64 = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * Ensure that a provided string-based struct is valid base64.
 *
 * @param struct - The string based struct.
 * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.
 * @returns A superstruct validating base64.
 */
const base64 = (struct, options = {}) => {
    var _a, _b;
    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';
    let letters;
    if (characterSet === 'base64') {
        letters = String.raw `[A-Za-z0-9+\/]`;
    }
    else {
        (0, assert_1.assert)(characterSet === 'base64url');
        letters = String.raw `[-_A-Za-z0-9]`;
    }
    let re;
    if (paddingRequired) {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    else {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    return (0, superstruct_1.pattern)(struct, re);
};
exports.base64 = base64;
//# sourceMappingURL=base64.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
// '0'.charCodeAt(0) === 48
const HEX_MINIMUM_NUMBER_CHARACTER = 48;
// '9'.charCodeAt(0) === 57
const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
const HEX_CHARACTER_OFFSET = 87;
/**
 * Memoized function that returns an array to be used as a lookup table for
 * converting bytes to hexadecimal values.
 *
 * The array is created lazily and then cached for future use. The benefit of
 * this approach is that the performance of converting bytes to hex is much
 * better than if we were to call `toString(16)` on each byte.
 *
 * The downside is that the array is created once and then never garbage
 * collected. This is not a problem in practice because the array is only 256
 * elements long.
 *
 * @returns A function that returns the lookup table.
 */
function getPrecomputedHexValuesBuilder() {
    // To avoid issues with tree shaking, we need to use a function to return the
    // array. This is because the array is only used in the `bytesToHex` function
    // and if we were to use a global variable, the array might be removed by the
    // tree shaker.
    const lookupTable = [];
    return () => {
        if (lookupTable.length === 0) {
            for (let i = 0; i < 256; i++) {
                lookupTable.push(i.toString(16).padStart(2, '0'));
            }
        }
        return lookupTable;
    };
}
/**
 * Function implementation of the {@link getPrecomputedHexValuesBuilder}
 * function.
 */
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
/**
 * Check if a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @returns Whether the value is a `Uint8Array`.
 */
function isBytes(value) {
    return value instanceof Uint8Array;
}
exports.isBytes = isBytes;
/**
 * Assert that a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @throws If the value is not a `Uint8Array`.
 */
function assertIsBytes(value) {
    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');
}
exports.assertIsBytes = assertIsBytes;
/**
 * Convert a `Uint8Array` to a hexadecimal string.
 *
 * @param bytes - The bytes to convert to a hexadecimal string.
 * @returns The hexadecimal string.
 */
function bytesToHex(bytes) {
    assertIsBytes(bytes);
    if (bytes.length === 0) {
        return '0x';
    }
    const lookupTable = getPrecomputedHexValues();
    const hexadecimal = new Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        hexadecimal[i] = lookupTable[bytes[i]];
    }
    return (0, hex_1.add0x)(hexadecimal.join(''));
}
exports.bytesToHex = bytesToHex;
/**
 * Convert a `Uint8Array` to a `bigint`.
 *
 * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.
 * To convert a two's complement encoded `Uint8Array` to a `bigint`, use
 * {@link bytesToSignedBigInt}.
 *
 * @param bytes - The bytes to convert to a `bigint`.
 * @returns The `bigint`.
 */
function bytesToBigInt(bytes) {
    assertIsBytes(bytes);
    const hexadecimal = bytesToHex(bytes);
    return BigInt(hexadecimal);
}
exports.bytesToBigInt = bytesToBigInt;
/**
 * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are
 * encoded in two's complement.
 *
 * To convert a `Uint8Array` to an unsigned `bigint` instead, use
 * {@link bytesToBigInt}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param bytes - The bytes to convert to a signed `bigint`.
 * @returns The signed `bigint`.
 */
function bytesToSignedBigInt(bytes) {
    assertIsBytes(bytes);
    let value = BigInt(0);
    for (const byte of bytes) {
        // eslint-disable-next-line no-bitwise
        value = (value << BigInt(8)) + BigInt(byte);
    }
    return BigInt.asIntN(bytes.length * 8, value);
}
exports.bytesToSignedBigInt = bytesToSignedBigInt;
/**
 * Convert a `Uint8Array` to a `number`.
 *
 * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.
 *
 * @param bytes - The bytes to convert to a number.
 * @returns The number.
 * @throws If the resulting number is not a safe integer.
 */
function bytesToNumber(bytes) {
    assertIsBytes(bytes);
    const bigint = bytesToBigInt(bytes);
    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
    return Number(bigint);
}
exports.bytesToNumber = bytesToNumber;
/**
 * Convert a UTF-8 encoded `Uint8Array` to a `string`.
 *
 * @param bytes - The bytes to convert to a string.
 * @returns The string.
 */
function bytesToString(bytes) {
    assertIsBytes(bytes);
    return new TextDecoder().decode(bytes);
}
exports.bytesToString = bytesToString;
/**
 * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be
 * prefixed with `0x`. It accepts even and odd length strings.
 *
 * If the value is "0x", an empty `Uint8Array` is returned.
 *
 * @param value - The hexadecimal string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function hexToBytes(value) {
    var _a;
    // "0x" is often used as empty byte array.
    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
        return new Uint8Array();
    }
    (0, hex_1.assertIsHexString)(value);
    // Remove the `0x` prefix if it exists, and pad the string to have an even
    // number of characters.
    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
    const bytes = new Uint8Array(normalizedValue.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        // While this is not the prettiest way to convert a hexadecimal string to a
        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each
        // character.
        const c1 = normalizedValue.charCodeAt(i * 2);
        const c2 = normalizedValue.charCodeAt(i * 2 + 1);
        const n1 = c1 -
            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        const n2 = c2 -
            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        bytes[i] = n1 * 16 + n2;
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert a `bigint` to a `Uint8Array`.
 *
 * This assumes that the `bigint` is an unsigned integer. To convert a signed
 * `bigint` instead, use {@link signedBigIntToBytes}.
 *
 * @param value - The bigint to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function bigIntToBytes(value) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.bigIntToBytes = bigIntToBytes;
/**
 * Check if a `bigint` fits in a certain number of bytes.
 *
 * @param value - The `bigint` to check.
 * @param bytes - The number of bytes.
 * @returns Whether the `bigint` fits in the number of bytes.
 */
function bigIntFits(value, bytes) {
    (0, assert_1.assert)(bytes > 0);
    /* eslint-disable no-bitwise */
    const mask = value >> BigInt(31);
    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));
    /* eslint-enable no-bitwise */
}
/**
 * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement
 * encoding to represent negative numbers.
 *
 * To convert an unsigned `bigint` to a `Uint8Array` instead, use
 * {@link bigIntToBytes}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param value - The number to convert to bytes.
 * @param byteLength - The length of the resulting `Uint8Array`. If the number
 * is larger than the maximum value that can be represented by the given length,
 * an error is thrown.
 * @returns The bytes as `Uint8Array`.
 */
function signedBigIntToBytes(value, byteLength) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');
    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
    // ESLint doesn't like mutating function parameters, so to avoid having to
    // disable the rule, we create a new variable.
    let numberValue = value;
    const bytes = new Uint8Array(byteLength);
    for (let i = 0; i < bytes.length; i++) {
        bytes[i] = Number(BigInt.asUintN(8, numberValue));
        // eslint-disable-next-line no-bitwise
        numberValue >>= BigInt(8);
    }
    return bytes.reverse();
}
exports.signedBigIntToBytes = signedBigIntToBytes;
/**
 * Convert a `number` to a `Uint8Array`.
 *
 * @param value - The number to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 * @throws If the number is not a safe integer.
 */
function numberToBytes(value) {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.numberToBytes = numberToBytes;
/**
 * Convert a `string` to a UTF-8 encoded `Uint8Array`.
 *
 * @param value - The string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function stringToBytes(value) {
    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');
    return new TextEncoder().encode(value);
}
exports.stringToBytes = stringToBytes;
/**
 * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,
 * a `bigint`, a `number`, or a `string`.
 *
 * This will attempt to guess the type of the value based on its type and
 * contents. For more control over the conversion, use the more specific
 * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.
 *
 * If the value is a `string`, and it is prefixed with `0x`, it will be
 * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a
 * UTF-8 string. To convert a hexadecimal string to bytes without interpreting
 * it as a UTF-8 string, use {@link hexToBytes} instead.
 *
 * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed
 * `bigint` to bytes, use {@link signedBigIntToBytes} instead.
 *
 * If the value is a `Uint8Array`, it will be returned as-is.
 *
 * @param value - The value to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function valueToBytes(value) {
    if (typeof value === 'bigint') {
        return bigIntToBytes(value);
    }
    if (typeof value === 'number') {
        return numberToBytes(value);
    }
    if (typeof value === 'string') {
        if (value.startsWith('0x')) {
            return hexToBytes(value);
        }
        return stringToBytes(value);
    }
    if (isBytes(value)) {
        return value;
    }
    throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
exports.valueToBytes = valueToBytes;
/**
 * Concatenate multiple byte-like values into a single `Uint8Array`. The values
 * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses
 * {@link valueToBytes} under the hood to convert each value to bytes. Refer to
 * the documentation of that function for more information.
 *
 * @param values - The values to concatenate.
 * @returns The concatenated bytes as `Uint8Array`.
 */
function concatBytes(values) {
    const normalizedValues = new Array(values.length);
    let byteLength = 0;
    for (let i = 0; i < values.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const value = valueToBytes(values[i]);
        normalizedValues[i] = value;
        byteLength += value.length;
    }
    const bytes = new Uint8Array(byteLength);
    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
        // While we could simply spread the values into an array and use
        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.
        bytes.set(normalizedValues[i], offset);
        offset += normalizedValues[i].length;
    }
    return bytes;
}
exports.concatBytes = concatBytes;
/**
 * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience
 * function that avoids having to create a {@link DataView} manually, which
 * requires passing the `byteOffset` and `byteLength` parameters every time.
 *
 * Not passing the `byteOffset` and `byteLength` parameters can result in
 * unexpected behavior when the {@link Uint8Array} is a view of a larger
 * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.
 *
 * This function also supports Node.js {@link Buffer}s.
 *
 * @example
 * ```typescript
 * const bytes = new Uint8Array([1, 2, 3]);
 *
 * // This is equivalent to:
 * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
 * const dataView = createDataView(bytes);
 * ```
 * @param bytes - The bytes to create the {@link DataView} from.
 * @returns The {@link DataView}.
 */
function createDataView(bytes) {
    // To maintain compatibility with Node.js, we need to check if the bytes are
    // a Buffer. If so, we need to slice the buffer to get the underlying
    // ArrayBuffer.
    // eslint-disable-next-line no-restricted-globals
    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {
        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        return new DataView(buffer);
    }
    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}
exports.createDataView = createDataView;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\checksum.js", {"./base64":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cchecksum.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChecksumStruct = void 0;
const superstruct_1 = require("superstruct");
const base64_1 = require("./base64");
exports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);
//# sourceMappingURL=checksum.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\checksum.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\coercers.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./bytes":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js","./hex":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccoercers.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const bytes_1 = require("./bytes");
const hex_1 = require("./hex");
const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
const BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
const HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
/**
 * Create a number from a number-like value.
 *
 * - If the value is a number, it is returned as-is.
 * - If the value is a `bigint`, it is converted to a number.
 * - If the value is a string, it is interpreted as a decimal number.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number.
 *
 * This validates that the value is a number-like value, and that the resulting
 * number is not `NaN` or `Infinity`.
 *
 * @example
 * ```typescript
 * const value = createNumber('0x010203');
 * console.log(value); // 66051
 *
 * const otherValue = createNumber(123n);
 * console.log(otherValue); // 123
 * ```
 * @param value - The value to create the number from.
 * @returns The created number.
 * @throws If the value is not a number-like value, or if the resulting number
 * is `NaN` or `Infinity`.
 */
function createNumber(value) {
    try {
        const result = (0, superstruct_1.create)(value, NumberCoercer);
        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${value}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createNumber = createNumber;
/**
 * Create a `bigint` from a number-like value.
 *
 * - If the value is a number, it is converted to a `bigint`.
 * - If the value is a `bigint`, it is returned as-is.
 * - If the value is a string, it is interpreted as a decimal number and
 * converted to a `bigint`.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number and converted to a `bigint`.
 *
 * @example
 * ```typescript
 * const value = createBigInt('0x010203');
 * console.log(value); // 16909060n
 *
 * const otherValue = createBigInt(123);
 * console.log(otherValue); // 123n
 * ```
 * @param value - The value to create the bigint from.
 * @returns The created bigint.
 * @throws If the value is not a number-like value.
 */
function createBigInt(value) {
    try {
        // The `BigInt` constructor throws if the value is not a number-like value.
        // There is no need to validate the value manually.
        return (0, superstruct_1.create)(value, BigIntCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBigInt = createBigInt;
/**
 * Create a byte array from a bytes-like value.
 *
 * - If the value is a byte array, it is returned as-is.
 * - If the value is a hex string (i.e., it starts with "0x"), it is interpreted
 * as a hexadecimal number and converted to a byte array.
 *
 * @example
 * ```typescript
 * const value = createBytes('0x010203');
 * console.log(value); // Uint8Array [ 1, 2, 3 ]
 *
 * const otherValue = createBytes('0x010203');
 * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]
 * ```
 * @param value - The value to create the byte array from.
 * @returns The created byte array.
 * @throws If the value is not a bytes-like value.
 */
function createBytes(value) {
    if (typeof value === 'string' && value.toLowerCase() === '0x') {
        return new Uint8Array();
    }
    try {
        return (0, superstruct_1.create)(value, BytesCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBytes = createBytes;
/**
 * Create a hexadecimal string from a bytes-like value.
 *
 * - If the value is a hex string (i.e., it starts with "0x"), it is returned
 * as-is.
 * - If the value is a `Uint8Array`, it is converted to a hex string.
 *
 * @example
 * ```typescript
 * const value = createHex(new Uint8Array([1, 2, 3]));
 * console.log(value); // '0x010203'
 *
 * const otherValue = createHex('0x010203');
 * console.log(otherValue); // '0x010203'
 * ```
 * @param value - The value to create the hex string from.
 * @returns The created hex string.
 * @throws If the value is not a bytes-like value.
 */
function createHex(value) {
    if ((value instanceof Uint8Array && value.length === 0) ||
        (typeof value === 'string' && value.toLowerCase() === '0x')) {
        return '0x';
    }
    try {
        return (0, superstruct_1.create)(value, HexCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createHex = createHex;
//# sourceMappingURL=coercers.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\coercers.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\collections.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccollections.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrozenSet = exports.FrozenMap = void 0;
/**
 * A {@link ReadonlyMap} that cannot be modified after instantiation.
 * The implementation uses an inner map hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this map.
 */
class FrozenMap {
    constructor(entries) {
        _FrozenMap_map.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
    }
    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner map.
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
    }
    get(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
    }
    has(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
    }
    toString() {
        return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
    }
}
exports.FrozenMap = FrozenMap;
/**
 * A {@link ReadonlySet} that cannot be modified after instantiation.
 * The implementation uses an inner set hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this set.
 */
class FrozenSet {
    constructor(values) {
        _FrozenSet_set.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
    }
    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner set.
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
    }
    has(value) {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
    }
    toString() {
        return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
    }
}
exports.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
//# sourceMappingURL=collections.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\collections.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Chex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
/**
 * Check if a string is a valid hex string.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isHexString(value) {
    return (0, superstruct_1.is)(value, exports.HexStruct);
}
exports.isHexString = isHexString;
/**
 * Strictly check if a string is a valid hex string. A valid hex string must
 * start with the "0x"-prefix.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isStrictHexString(value) {
    return (0, superstruct_1.is)(value, exports.StrictHexStruct);
}
exports.isStrictHexString = isStrictHexString;
/**
 * Assert that a value is a valid hex string.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsHexString(value) {
    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
}
exports.assertIsHexString = assertIsHexString;
/**
 * Assert that a value is a valid hex string. A valid hex string must start with
 * the "0x"-prefix.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsStrictHexString(value) {
    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
}
exports.assertIsStrictHexString = assertIsStrictHexString;
/**
 * Add the `0x`-prefix to a hexadecimal string. If the string already has the
 * prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to add the prefix to.
 * @returns The prefixed hexadecimal string.
 */
function add0x(hexadecimal) {
    if (hexadecimal.startsWith('0x')) {
        return hexadecimal;
    }
    if (hexadecimal.startsWith('0X')) {
        return `0x${hexadecimal.substring(2)}`;
    }
    return `0x${hexadecimal}`;
}
exports.add0x = add0x;
/**
 * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have
 * the prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to remove the prefix from.
 * @returns The un-prefixed hexadecimal string.
 */
function remove0x(hexadecimal) {
    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {
        return hexadecimal.substring(2);
    }
    return hexadecimal;
}
exports.remove0x = remove0x;
//# sourceMappingURL=hex.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./base64":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\base64.js","./bytes":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\bytes.js","./checksum":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\checksum.js","./coercers":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\coercers.js","./collections":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\collections.js","./hex":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js","./json":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\json.js","./logging":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\logging.js","./misc":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js","./number":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\number.js","./opaque":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\opaque.js","./time":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\time.js","./versions":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\versions.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./assert"), exports);
__exportStar(require("./base64"), exports);
__exportStar(require("./bytes"), exports);
__exportStar(require("./checksum"), exports);
__exportStar(require("./coercers"), exports);
__exportStar(require("./collections"), exports);
__exportStar(require("./hex"), exports);
__exportStar(require("./json"), exports);
__exportStar(require("./logging"), exports);
__exportStar(require("./misc"), exports);
__exportStar(require("./number"), exports);
__exportStar(require("./opaque"), exports);
__exportStar(require("./time"), exports);
__exportStar(require("./versions"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\json.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./misc":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cjson.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.isValidJson = exports.JsonStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const misc_1 = require("./misc");
exports.JsonStruct = (0, superstruct_1.define)('Json', (value) => {
    const [isValid] = validateJsonAndGetSize(value, true);
    if (!isValid) {
        return 'Expected a valid JSON-serializable value';
    }
    return true;
});
/**
 * Check if the given value is a valid {@link Json} value, i.e., a value that is
 * serializable to JSON.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid {@link Json} value.
 */
function isValidJson(value) {
    return (0, superstruct_1.is)(value, exports.JsonStruct);
}
exports.isValidJson = isValidJson;
/**
 * The string '2.0'.
 */
exports.jsonrpc2 = '2.0';
exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
    code: (0, superstruct_1.integer)(),
    message: (0, superstruct_1.string)(),
    data: (0, superstruct_1.optional)(exports.JsonStruct),
    stack: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    method: (0, superstruct_1.string)(),
    params: exports.JsonRpcParamsStruct,
});
exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
/**
 * Check if the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcNotification}
 * object.
 */
function isJsonRpcNotification(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
}
exports.isJsonRpcNotification = isJsonRpcNotification;
/**
 * Assert that the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcNotification} object.
 */
function assertIsJsonRpcNotification(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
}
exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
/**
 * Check if the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcRequest} object.
 */
function isJsonRpcRequest(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
}
exports.isJsonRpcRequest = isJsonRpcRequest;
/**
 * Assert that the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The JSON-RPC request or notification to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcRequest} object.
 */
function assertIsJsonRpcRequest(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
}
exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),
});
exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: exports.JsonStruct,
});
exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    error: exports.JsonRpcErrorStruct,
});
exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
    exports.JsonRpcSuccessStruct,
    exports.JsonRpcFailureStruct,
]);
/**
 * Type guard to check whether specified JSON-RPC response is a
 * {@link PendingJsonRpcResponse}.
 *
 * @param response - The JSON-RPC response to check.
 * @returns Whether the specified JSON-RPC response is pending.
 */
function isPendingJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
}
exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.
 *
 * @param response - The JSON-RPC response to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link PendingJsonRpcResponse}
 * object.
 */
function assertIsPendingJsonRpcResponse(response, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
}
exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
/**
 * Type guard to check if a value is a {@link JsonRpcResponse}.
 *
 * @param response - The object to check.
 * @returns Whether the object is a JsonRpcResponse.
 */
function isJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
}
exports.isJsonRpcResponse = isJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link JsonRpcResponse} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcResponse} object.
 */
function assertIsJsonRpcResponse(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
}
exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
/**
 * Check if the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.
 */
function isJsonRpcSuccess(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
}
exports.isJsonRpcSuccess = isJsonRpcSuccess;
/**
 * Assert that the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcSuccess} object.
 */
function assertIsJsonRpcSuccess(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
}
exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
/**
 * Check if the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcFailure} object.
 */
function isJsonRpcFailure(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
}
exports.isJsonRpcFailure = isJsonRpcFailure;
/**
 * Assert that the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcFailure} object.
 */
function assertIsJsonRpcFailure(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
}
exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
/**
 * Check if the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcError} object.
 */
function isJsonRpcError(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
}
exports.isJsonRpcError = isJsonRpcError;
/**
 * Assert that the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcError} object.
 */
function assertIsJsonRpcError(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
}
exports.assertIsJsonRpcError = assertIsJsonRpcError;
/**
 * Gets a function for validating JSON-RPC request / response `id` values.
 *
 * By manipulating the options of this factory, you can control the behavior
 * of the resulting validator for some edge cases. This is useful because e.g.
 * `null` should sometimes but not always be permitted.
 *
 * Note that the empty string (`''`) is always permitted by the JSON-RPC
 * specification, but that kind of sucks and you may want to forbid it in some
 * instances anyway.
 *
 * For more details, see the
 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
 *
 * @param options - An options object.
 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
 * should be treated as a valid ID. Default: `true`
 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
 * should be treated as valid IDs. Default: `false`
 * @param options.permitNull - Whether `null` should be treated as a valid ID.
 * Default: `true`
 * @returns The JSON-RPC ID validator function.
 */
function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    /**
     * Type guard for {@link JsonRpcId}.
     *
     * @param id - The JSON-RPC ID value to check.
     * @returns Whether the given ID is valid per the options given to the
     * factory.
     */
    const isValidJsonRpcId = (id) => {
        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
            (permitNull && id === null));
    };
    return isValidJsonRpcId;
}
exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
/**
 * Checks whether a value is JSON serializable and counts the total number
 * of bytes needed to store the serialized version of the value.
 *
 * @param jsObject - Potential JSON serializable object.
 * @param skipSizingProcess - Skip JSON size calculation (default: false).
 * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
 * the value was serializable and a number of bytes that it will use when serialized to JSON.
 */
function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
    const seenObjects = new Set();
    /**
     * Checks whether a value is JSON serializable and counts the total number
     * of bytes needed to store the serialized version of the value.
     *
     * This function assumes the encoding of the JSON is done in UTF-8.
     *
     * @param value - Potential JSON serializable value.
     * @param skipSizing - Skip JSON size calculation (default: false).
     * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
     * the value was serializable and a number of bytes that it will use when serialized to JSON.
     */
    function getJsonSerializableInfo(value, skipSizing) {
        if (value === undefined) {
            return [false, 0];
        }
        else if (value === null) {
            // Return already specified constant size for null (special object)
            return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
        }
        // Check and calculate sizes for basic (and some special) types
        const typeOfValue = typeof value;
        try {
            if (typeOfValue === 'function') {
                return [false, 0];
            }
            else if (typeOfValue === 'string' || value instanceof String) {
                return [
                    true,
                    skipSizing
                        ? 0
                        : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2,
                ];
            }
            else if (typeOfValue === 'boolean' || value instanceof Boolean) {
                if (skipSizing) {
                    return [true, 0];
                }
                // eslint-disable-next-line eqeqeq
                return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
            }
            else if (typeOfValue === 'number' || value instanceof Number) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [true, (0, misc_1.calculateNumberSize)(value)];
            }
            else if (value instanceof Date) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [
                    true,
                    // Note: Invalid dates will serialize to null
                    isNaN(value.getDate())
                        ? misc_1.JsonSize.Null
                        : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2,
                ];
            }
        }
        catch (_) {
            return [false, 0];
        }
        // If object is not plain and cannot be serialized properly,
        // stop here and return false for serialization
        if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
            return [false, 0];
        }
        // Circular object detection (handling)
        // Check if the same object already exists
        if (seenObjects.has(value)) {
            return [false, 0];
        }
        // Add new object to the seen objects set
        // Only the plain objects should be added (Primitive types are skipped)
        seenObjects.add(value);
        // Continue object decomposition
        try {
            return [
                true,
                Object.entries(value).reduce((sum, [key, nestedValue], idx, arr) => {
                    // Recursively process next nested object or primitive type
                    // eslint-disable-next-line prefer-const
                    let [valid, size] = getJsonSerializableInfo(nestedValue, skipSizing);
                    if (!valid) {
                        throw new Error('JSON validation did not pass. Validation process stopped.');
                    }
                    // Circular object detection
                    // Once a child node is visited and processed remove it from the set.
                    // This will prevent false positives with the same adjacent objects.
                    seenObjects.delete(value);
                    if (skipSizing) {
                        return 0;
                    }
                    // Objects will have be serialized with "key": value,
                    // therefore we include the key in the calculation here
                    const keySize = Array.isArray(value)
                        ? 0
                        : key.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
                    const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;
                    return sum + keySize + size + separator;
                }, 
                // Starts at 2 because the serialized JSON string data (plain text)
                // will minimally contain {}/[]
                skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2),
            ];
        }
        catch (_) {
            return [false, 0];
        }
    }
    return getJsonSerializableInfo(jsObject, skipSizingProcess);
}
exports.validateJsonAndGetSize = validateJsonAndGetSize;
//# sourceMappingURL=json.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\json.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\logging.js", {"debug":"F:\\metamask-extension\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Clogging.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.createProjectLogger = void 0;
const debug_1 = __importDefault(require("debug"));
const globalLogger = (0, debug_1.default)('metamask');
/**
 * Creates a logger via the `debug` library whose log messages will be tagged
 * using the name of your project. By default, such messages will be
 * suppressed, but you can reveal them by setting the `DEBUG` environment
 * variable to `metamask:<projectName>`. You can also set this variable to
 * `metamask:*` if you want to see log messages from all MetaMask projects that
 * are also using this function to create their loggers.
 *
 * @param projectName - The name of your project. This should be the name of
 * your NPM package if you're developing one.
 * @returns An instance of `debug`.
 */
function createProjectLogger(projectName) {
    return globalLogger.extend(projectName);
}
exports.createProjectLogger = createProjectLogger;
/**
 * Creates a logger via the `debug` library which is derived from the logger for
 * the whole project whose log messages will be tagged using the name of your
 * module. By default, such messages will be suppressed, but you can reveal them
 * by setting the `DEBUG` environment variable to
 * `metamask:<projectName>:<moduleName>`. You can also set this variable to
 * `metamask:<projectName>:*` if you want to see log messages from the project,
 * or `metamask:*` if you want to see log messages from all MetaMask projects.
 *
 * @param projectLogger - The logger created via {@link createProjectLogger}.
 * @param moduleName - The name of your module. You could use the name of the
 * file where you're using this logger or some other name.
 * @returns An instance of `debug`.
 */
function createModuleLogger(projectLogger, moduleName) {
    return projectLogger.extend(moduleName);
}
exports.createModuleLogger = createModuleLogger;
//# sourceMappingURL=logging.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\logging.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cmisc.js
      return function (require, module, exports) {
"use strict";
//
// Types
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
//
// Type Guards
//
/**
 * A {@link NonEmptyArray} type guard.
 *
 * @template Element - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * Type guard for "nullishness".
 *
 * @param value - Any value.
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * A type guard for {@link RuntimeObject}.
 *
 * @param value - The value to check.
 * @returns Whether the specified value has a runtime type of `object` and is
 * neither `null` nor an `Array`.
 */
function isObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isObject = isObject;
//
// Other utility functions
//
/**
 * A type guard for ensuring an object has a property.
 *
 * @param objectToCheck - The object to check.
 * @param name - The property name to check for.
 * @returns Whether the specified object has an own property with the specified
 * name, regardless of whether it is enumerable or not.
 */
const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
exports.hasProperty = hasProperty;
/**
 * Predefined sizes (in Bytes) of specific parts of JSON structure.
 */
var JsonSize;
(function (JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    // eslint-disable-next-line @typescript-eslint/no-shadow
    JsonSize[JsonSize["Date"] = 24] = "Date";
})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));
/**
 * Regular expression with pattern matching for (special) escaped characters.
 */
exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
/**
 * Check if the value is plain object.
 *
 * @param value - Value to be checked.
 * @returns True if an object is the plain JavaScript object,
 * false if the object is not plain (e.g. function).
 */
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    try {
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
    catch (_) {
        return false;
    }
}
exports.isPlainObject = isPlainObject;
/**
 * Check if character is ASCII.
 *
 * @param character - Character.
 * @returns True if a character code is ASCII, false if not.
 */
function isASCII(character) {
    return character.charCodeAt(0) <= 127;
}
exports.isASCII = isASCII;
/**
 * Calculate string size.
 *
 * @param value - String value to calculate size.
 * @returns Number of bytes used to store whole string value.
 */
function calculateStringSize(value) {
    var _a;
    const size = value.split('').reduce((total, character) => {
        if (isASCII(character)) {
            return total + 1;
        }
        return total + 2;
    }, 0);
    // Also detect characters that need backslash escape
    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
}
exports.calculateStringSize = calculateStringSize;
/**
 * Calculate size of a number ofter JSON serialization.
 *
 * @param value - Number value to calculate size.
 * @returns Number of bytes used to store whole number in JSON.
 */
function calculateNumberSize(value) {
    return value.toString().length;
}
exports.calculateNumberSize = calculateNumberSize;
//# sourceMappingURL=misc.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\misc.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\number.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\hex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cnumber.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
/**
 * Convert a number to a hexadecimal string. This verifies that the number is a
 * non-negative safe integer.
 *
 * To convert a `bigint` to a hexadecimal string instead, use
 * {@link bigIntToHex}.
 *
 * @example
 * ```typescript
 * numberToHex(0); // '0x0'
 * numberToHex(1); // '0x1'
 * numberToHex(16); // '0x10'
 * ```
 * @param value - The number to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the number is not a non-negative safe integer.
 */
const numberToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.numberToHex = numberToHex;
/**
 * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`
 * is a non-negative integer.
 *
 * To convert a number to a hexadecimal string instead, use {@link numberToHex}.
 *
 * @example
 * ```typescript
 * bigIntToHex(0n); // '0x0'
 * bigIntToHex(1n); // '0x1'
 * bigIntToHex(16n); // '0x10'
 * ```
 * @param value - The `bigint` to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the `bigint` is not a non-negative integer.
 */
const bigIntToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.bigIntToHex = bigIntToHex;
/**
 * Convert a hexadecimal string to a number. This verifies that the string is a
 * valid hex string, and that the resulting number is a safe integer. Both
 * "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a `bigint` instead, use
 * {@link hexToBigInt}.
 *
 * @example
 * ```typescript
 * hexToNumber('0x0'); // 0
 * hexToNumber('0x1'); // 1
 * hexToNumber('0x10'); // 16
 * ```
 * @param value - The hexadecimal string to convert to a number.
 * @returns The number.
 * @throws If the value is not a valid hexadecimal string, or if the resulting
 * number is not a safe integer.
 */
const hexToNumber = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
    // not. Using this is slightly faster than `Number(add0x(value))`.
    const numberValue = parseInt(value, 16);
    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
    return numberValue;
};
exports.hexToNumber = hexToNumber;
/**
 * Convert a hexadecimal string to a `bigint`. This verifies that the string is
 * a valid hex string. Both "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.
 *
 * @example
 * ```typescript
 * hexToBigInt('0x0'); // 0n
 * hexToBigInt('0x1'); // 1n
 * hexToBigInt('0x10'); // 16n
 * ```
 * @param value - The hexadecimal string to convert to a `bigint`.
 * @returns The `bigint`.
 * @throws If the value is not a valid hexadecimal string.
 */
const hexToBigInt = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
    return BigInt((0, hex_1.add0x)(value));
};
exports.hexToBigInt = hexToBigInt;
//# sourceMappingURL=number.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\number.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\opaque.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Copaque.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=opaque.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\opaque.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\time.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ctime.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
/**
 * Common duration constants, in milliseconds.
 */
var Duration;
(function (Duration) {
    /**
     * A millisecond.
     */
    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    /**
     * A second, in milliseconds.
     */
    Duration[Duration["Second"] = 1000] = "Second";
    /**
     * A minute, in milliseconds.
     */
    Duration[Duration["Minute"] = 60000] = "Minute";
    /**
     * An hour, in milliseconds.
     */
    Duration[Duration["Hour"] = 3600000] = "Hour";
    /**
     * A day, in milliseconds.
     */
    Duration[Duration["Day"] = 86400000] = "Day";
    /**
     * A week, in milliseconds.
     */
    Duration[Duration["Week"] = 604800000] = "Week";
    /**
     * A year, in milliseconds.
     */
    Duration[Duration["Year"] = 31536000000] = "Year";
})(Duration = exports.Duration || (exports.Duration = {}));
const isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
const assertIsNonNegativeInteger = (number, name) => {
    if (!isNonNegativeInteger(number)) {
        throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
    }
};
/**
 * Calculates the millisecond value of the specified number of units of time.
 *
 * @param count - The number of units of time.
 * @param duration - The unit of time to count.
 * @returns The count multiplied by the specified duration.
 */
function inMilliseconds(count, duration) {
    assertIsNonNegativeInteger(count, 'count');
    return count * duration;
}
exports.inMilliseconds = inMilliseconds;
/**
 * Gets the milliseconds since a particular Unix epoch timestamp.
 *
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    assertIsNonNegativeInteger(timestamp, 'timestamp');
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;
//# sourceMappingURL=time.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\time.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\versions.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\assert.js","semver":"F:\\metamask-extension\\node_modules\\semver\\index.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cversions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
const semver_1 = require("semver");
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * A struct for validating a version string.
 */
exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {
    if ((0, semver_1.valid)(value) === null) {
        return `Expected SemVer version, got "${value}"`;
    }
    return true;
});
exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {
    if ((0, semver_1.validRange)(value) === null) {
        return `Expected SemVer range, got "${value}"`;
    }
    return true;
});
/**
 * Checks whether a SemVer version is valid.
 *
 * @param version - A potential version.
 * @returns `true` if the version is valid, and `false` otherwise.
 */
function isValidSemVerVersion(version) {
    return (0, superstruct_1.is)(version, exports.VersionStruct);
}
exports.isValidSemVerVersion = isValidSemVerVersion;
/**
 * Checks whether a SemVer version range is valid.
 *
 * @param versionRange - A potential version range.
 * @returns `true` if the version range is valid, and `false` otherwise.
 */
function isValidSemVerRange(versionRange) {
    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
}
exports.isValidSemVerRange = isValidSemVerRange;
/**
 * Asserts that a value is a valid concrete SemVer version.
 *
 * @param version - A potential SemVer concrete version.
 */
function assertIsSemVerVersion(version) {
    (0, assert_1.assertStruct)(version, exports.VersionStruct);
}
exports.assertIsSemVerVersion = assertIsSemVerVersion;
/**
 * Asserts that a value is a valid SemVer range.
 *
 * @param range - A potential SemVer range.
 */
function assertIsSemVerRange(range) {
    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);
}
exports.assertIsSemVerRange = assertIsSemVerRange;
/**
 * Checks whether a SemVer version is greater than another.
 *
 * @param version1 - The left-hand version.
 * @param version2 - The right-hand version.
 * @returns `version1 > version2`.
 */
function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2);
}
exports.gtVersion = gtVersion;
/**
 * Checks whether a SemVer version is greater than all possibilities in a range.
 *
 * @param version - A SemvVer version.
 * @param range - The range to check against.
 * @returns `version > range`.
 */
function gtRange(version, range) {
    return (0, semver_1.gtr)(version, range);
}
exports.gtRange = gtRange;
/**
 * Returns whether a SemVer version satisfies a SemVer range.
 *
 * @param version - The SemVer version to check.
 * @param versionRange - The SemVer version range to check against.
 * @returns Whether the version satisfied the version range.
 */
function satisfiesVersionRange(version, versionRange) {
    return (0, semver_1.satisfies)(version, versionRange, {
        includePrerelease: true,
    });
}
exports.satisfiesVersionRange = satisfiesVersionRange;
//# sourceMappingURL=versions.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\versions.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js", {"./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-cache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockCacheMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-cache');
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e'];
//
// Cache Strategies
//
class BlockCacheStrategy {
    constructor() {
        this.cache = {};
    }
    getBlockCacheForPayload(_payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            const newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    }
    async get(payload, requestedBlockNumber) {
        // lookup block cache
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        // lookup payload in block cache
        const identifier = cache_1.cacheIdentifierForPayload(payload, true);
        return identifier ? blockCache[identifier] : undefined;
    }
    async set(payload, requestedBlockNumber, result) {
        // check if we can cached this result
        const canCacheResult = this.canCacheResult(payload, result);
        if (!canCacheResult) {
            return;
        }
        // set the value in the cache
        const identifier = cache_1.cacheIdentifierForPayload(payload, true);
        if (!identifier) {
            return;
        }
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        blockCache[identifier] = result;
    }
    canCacheRequest(payload) {
        // check request method
        if (!cache_1.canCache(payload)) {
            return false;
        }
        // check blockTag
        const blockTag = cache_1.blockTagForPayload(payload);
        if (blockTag === 'pending') {
            return false;
        }
        // can be cached
        return true;
    }
    canCacheResult(payload, result) {
        // never cache empty values (e.g. undefined)
        if (emptyValues.includes(result)) {
            return false;
        }
        // check if transactions have block reference before caching
        if (payload.method &&
            ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {
            if (!result ||
                !result.blockHash ||
                result.blockHash ===
                    '0x0000000000000000000000000000000000000000000000000000000000000000') {
                return false;
            }
        }
        // otherwise true
        return true;
    }
    // removes all block caches with block number lower than `oldBlockHex`
    clearBefore(oldBlockHex) {
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter((num) => num < oldBlockNumber)
            .forEach((num) => delete this.cache[num]);
    }
}
function createBlockCacheMiddleware({ blockTracker, } = {}) {
    // validate options
    if (!blockTracker) {
        throw new Error('createBlockCacheMiddleware - No PollingBlockTracker specified');
    }
    // create caching strategies
    const blockCache = new BlockCacheStrategy();
    const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache,
    };
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // check type and matching strategy
        const type = cache_1.cacheTypeForPayload(req);
        const strategy = strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCacheRequest(req)) {
            return next();
        }
        // get block reference (number or keyword)
        let blockTag = cache_1.blockTagForPayload(req);
        if (!blockTag) {
            blockTag = 'latest';
        }
        log('blockTag = %o, req = %o', blockTag, req);
        // get exact block number
        let requestedBlockNumber;
        if (blockTag === 'earliest') {
            // this just exists for symmetry with "latest"
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            // fetch latest block number
            log('Fetching latest block number to determine cache key');
            const latestBlockNumber = await blockTracker.getLatestBlock();
            // clear all cache before latest block
            log('Clearing values stored under block numbers before %o', latestBlockNumber);
            blockCache.clearBefore(latestBlockNumber);
            requestedBlockNumber = latestBlockNumber;
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // end on a hit, continue on a miss
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === undefined) {
            // cache miss
            // wait for other middleware to handle request
            log('No cache stored under block number %o, carrying request forward', requestedBlockNumber);
            // eslint-disable-next-line node/callback-return
            await next();
            // add result to cache
            // it's safe to cast res.result as Block, due to runtime type checks
            // performed when strategy.set is called
            log('Populating cache with', res);
            await strategy.set(req, requestedBlockNumber, res.result);
        }
        else {
            // fill in result from cache
            log('Cache hit, reusing cache result stored under block number %o', requestedBlockNumber);
            res.result = cacheResult;
        }
        return undefined;
    });
}
exports.createBlockCacheMiddleware = createBlockCacheMiddleware;
//# sourceMappingURL=block-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js", {"./utils/cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref-rewrite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefRewriteMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createBlockRefRewriteMiddleware({ blockTracker, } = {}) {
    if (!blockTracker) {
        throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, _res, next) => {
        var _a;
        const blockRefIndex = cache_1.blockTagParamIndex(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // rewrite blockRef to block-tracker's block number
        const latestBlockNumber = await blockTracker.getLatestBlock();
        if (req.params) {
            // eslint-disable-next-line require-atomic-updates
            req.params[blockRefIndex] = latestBlockNumber;
        }
        return next();
    });
}
exports.createBlockRefRewriteMiddleware = createBlockRefRewriteMiddleware;
//# sourceMappingURL=block-ref-rewrite.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js", {"./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"F:\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const clone_1 = __importDefault(require("clone"));
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-ref');
function createBlockRefMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a, _b;
        const blockRefIndex = cache_1.blockTagParamIndex(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        const blockRef = (_b = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex]) !== null && _b !== void 0 ? _b : 'latest';
        // skip if not "latest"
        if (blockRef !== 'latest') {
            log('blockRef is not "latest", carrying request forward');
            return next();
        }
        // lookup latest block
        const latestBlockNumber = await blockTracker.getLatestBlock();
        log(`blockRef is "latest", setting param ${blockRefIndex} to latest block ${latestBlockNumber}`);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        if (childRequest.params) {
            childRequest.params[blockRefIndex] = latestBlockNumber;
        }
        // perform child request
        log('Performing another request %o', childRequest);
        const childRes = await pify_1.default(provider.sendAsync).call(provider, childRequest);
        // copy child response onto original response
        res.result = childRes.result;
        res.error = childRes.error;
        return undefined;
    });
}
exports.createBlockRefMiddleware = createBlockRefMiddleware;
//# sourceMappingURL=block-ref.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js", {"./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cblock-tracker-inspector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockTrackerInspectorMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-tracker-inspector');
const futureBlockRefRequests = [
    'eth_getTransactionByHash',
    'eth_getTransactionReceipt',
];
// inspect if response contains a block ref higher than our latest block
function createBlockTrackerInspectorMiddleware({ blockTracker, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a;
        if (!futureBlockRefRequests.includes(req.method)) {
            return next();
        }
        // eslint-disable-next-line node/callback-return
        await next();
        // abort if no result or no block number
        if (!((_a = res.result) === null || _a === void 0 ? void 0 : _a.blockNumber)) {
            return undefined;
        }
        log('res.result.blockNumber exists, proceeding. res = %o', res);
        if (typeof res.result.blockNumber === 'string') {
            // if number is higher, suggest block-tracker check for a new block
            const blockNumber = Number.parseInt(res.result.blockNumber, 16);
            // Typecast: If getCurrentBlock returns null, currentBlockNumber will be NaN, which is fine.
            const currentBlockNumber = Number.parseInt(blockTracker.getCurrentBlock(), 16);
            if (blockNumber > currentBlockNumber) {
                log('blockNumber from response is greater than current block number, refreshing current block number');
                await blockTracker.checkForLatestBlock();
            }
        }
        return undefined;
    });
}
exports.createBlockTrackerInspectorMiddleware = createBlockTrackerInspectorMiddleware;
//# sourceMappingURL=block-tracker-inspector.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js", {"btoa":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js","eth-rpc-errors":"F:\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","node-fetch":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cfetch.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchConfigFromReq = exports.createFetchMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
/* eslint-disable @typescript-eslint/no-require-imports,@typescript-eslint/no-shadow */
const fetch = global.fetch || require('node-fetch');
const btoa = global.btoa || require('btoa');
/* eslint-enable @typescript-eslint/no-require-imports,@typescript-eslint/no-shadow */
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'failed to parse response body',
    // ignore errors where http req failed to establish
    'Failed to fetch',
];
function createFetchMiddleware({ rpcUrl, originHttpHeaderKey, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, _next) => {
        const { fetchUrl, fetchParams } = createFetchConfigFromReq({
            req,
            rpcUrl,
            originHttpHeaderKey,
        });
        // attempt request multiple times
        const maxAttempts = 5;
        const retryInterval = 1000;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            try {
                const fetchRes = await fetch(fetchUrl, fetchParams);
                // check for http errrors
                checkForHttpErrors(fetchRes);
                // parse response body
                const rawBody = await fetchRes.text();
                let fetchBody;
                try {
                    fetchBody = JSON.parse(rawBody);
                }
                catch (_) {
                    throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`);
                }
                const result = parseResponse(fetchRes, fetchBody);
                // set result and exit retry loop
                res.result = result;
                return;
            }
            catch (err) {
                const errMsg = err.toString();
                const isRetriable = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
                // re-throw error if not retriable
                if (!isRetriable) {
                    throw err;
                }
            }
            // delay before retrying
            await timeout(retryInterval);
        }
    });
}
exports.createFetchMiddleware = createFetchMiddleware;
function checkForHttpErrors(fetchRes) {
    // check for errors
    switch (fetchRes.status) {
        case 405:
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
        case 418:
            throw createRatelimitError();
        case 503:
        case 504:
            throw createTimeoutError();
        default:
            break;
    }
}
function parseResponse(fetchRes, body) {
    // check for error code
    if (fetchRes.status !== 200) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            message: `Non-200 status code: '${fetchRes.status}'`,
            data: body,
        });
    }
    // check for rpc error
    if (body.error) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            data: body.error,
        });
    }
    // return successful result
    return body.result;
}
function createFetchConfigFromReq({ req, rpcUrl, originHttpHeaderKey, }) {
    const parsedUrl = new URL(rpcUrl);
    const fetchUrl = normalizeUrlFromParsed(parsedUrl);
    // prepare payload
    // copy only canonical json rpc properties
    const payload = {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
    // extract 'origin' parameter from request
    const originDomain = req.origin;
    // serialize request body
    const serializedPayload = JSON.stringify(payload);
    // configure fetch params
    const fetchParams = {
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        body: serializedPayload,
    };
    // encoded auth details as header (not allowed in fetch url)
    if (parsedUrl.username && parsedUrl.password) {
        const authString = `${parsedUrl.username}:${parsedUrl.password}`;
        const encodedAuth = btoa(authString);
        fetchParams.headers.Authorization = `Basic ${encodedAuth}`;
    }
    // optional: add request origin as header
    if (originHttpHeaderKey && originDomain) {
        fetchParams.headers[originHttpHeaderKey] = originDomain;
    }
    return { fetchUrl, fetchParams };
}
exports.createFetchConfigFromReq = createFetchConfigFromReq;
function normalizeUrlFromParsed(parsedUrl) {
    let result = '';
    result += parsedUrl.protocol;
    result += `//${parsedUrl.hostname}`;
    if (parsedUrl.port) {
        result += `:${parsedUrl.port}`;
    }
    result += `${parsedUrl.pathname}`;
    result += `${parsedUrl.search}`;
    return result;
}
function createRatelimitError() {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: `Request is being rate limited.` });
}
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: msg });
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=fetch.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js", {"./block-cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js","./block-ref":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js","./block-ref-rewrite":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js","./block-tracker-inspector":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js","./fetch":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js","./inflight-cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js","./providerAsMiddleware":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js","./providerFromEngine":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js","./providerFromMiddleware":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js","./retryOnEmpty":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js","./wallet":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./block-cache"), exports);
__exportStar(require("./block-ref-rewrite"), exports);
__exportStar(require("./block-ref"), exports);
__exportStar(require("./block-tracker-inspector"), exports);
__exportStar(require("./fetch"), exports);
__exportStar(require("./inflight-cache"), exports);
__exportStar(require("./providerAsMiddleware"), exports);
__exportStar(require("./providerFromEngine"), exports);
__exportStar(require("./providerFromMiddleware"), exports);
__exportStar(require("./retryOnEmpty"), exports);
__exportStar(require("./wallet"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js", {"./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"F:\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cinflight-cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInflightCacheMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'inflight-cache');
function createInflightCacheMiddleware() {
    const inflightRequests = {};
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // get cacheId, if cacheable
        const cacheId = cache_1.cacheIdentifierForPayload(req);
        // if not cacheable, skip
        if (!cacheId) {
            log('Request is not cacheable, proceeding. req = %o', req);
            return next();
        }
        // check for matching requests
        let activeRequestHandlers = inflightRequests[cacheId];
        // if found, wait for the active request to be handled
        if (activeRequestHandlers) {
            // setup the response listener and wait for it to be called
            // it will handle copying the result and request fields
            log('Running %i handler(s) for request %o', activeRequestHandlers.length, req);
            await createActiveRequestHandler(res, activeRequestHandlers);
            return undefined;
        }
        // setup response handler array for subsequent requests
        activeRequestHandlers = [];
        inflightRequests[cacheId] = activeRequestHandlers;
        // allow request to be handled normally
        log('Carrying original request forward %o', req);
        // eslint-disable-next-line node/callback-return
        await next();
        // clear inflight requests
        delete inflightRequests[cacheId];
        // schedule activeRequestHandlers to be handled
        log('Running %i collected handler(s) for request %o', activeRequestHandlers.length, req);
        handleActiveRequest(res, activeRequestHandlers);
        // complete
        return undefined;
    });
    function createActiveRequestHandler(res, activeRequestHandlers) {
        const { resolve, promise } = deferredPromise();
        activeRequestHandlers.push((handledRes) => {
            // append a copy of the result and error to the response
            res.result = clone_1.default(handledRes.result);
            res.error = clone_1.default(handledRes.error);
            resolve();
        });
        return promise;
    }
    function handleActiveRequest(res, activeRequestHandlers) {
        // use setTimeout so we can resolve our original request first
        setTimeout(() => {
            activeRequestHandlers.forEach((handler) => {
                try {
                    handler(res);
                }
                catch (err) {
                    // catch error so all requests are handled correctly
                    console.error(err);
                }
            });
        });
    }
}
exports.createInflightCacheMiddleware = createInflightCacheMiddleware;
function deferredPromise() {
    let resolve;
    const promise = new Promise((_resolve) => {
        resolve = _resolve;
    });
    return { resolve, promise };
}
//# sourceMappingURL=inflight-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Clogging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = utils_1.createProjectLogger('eth-json-rpc-middleware');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CproviderAsMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethersProviderAsMiddleware = exports.providerAsMiddleware = void 0;
function providerAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.sendAsync(req, (err, providerRes) => {
            // forward any error
            if (err instanceof Error) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.providerAsMiddleware = providerAsMiddleware;
function ethersProviderAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.send(req, (err, providerRes) => {
            // forward any error
            if (err) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.ethersProviderAsMiddleware = ethersProviderAsMiddleware;
//# sourceMappingURL=providerAsMiddleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js", {"@metamask/safe-event-emitter":"F:\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CproviderFromEngine.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromEngine = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
function providerFromEngine(engine) {
    const provider = new safe_event_emitter_1.default();
    // handle both rpc send methods
    provider.sendAsync = (req, cb) => {
        engine.handle(req, cb);
    };
    provider.send = (req, callback) => {
        if (typeof callback !== 'function') {
            throw new Error('Must provide callback to "send" method.');
        }
        engine.handle(req, callback);
    };
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            provider.emit('data', null, message);
        });
    }
    return provider;
}
exports.providerFromEngine = providerFromEngine;
//# sourceMappingURL=providerFromEngine.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js", {"./providerFromEngine":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CproviderFromMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const providerFromEngine_1 = require("./providerFromEngine");
function providerFromMiddleware(middleware) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push(middleware);
    const provider = providerFromEngine_1.providerFromEngine(engine);
    return provider;
}
exports.providerFromMiddleware = providerFromMiddleware;
//# sourceMappingURL=providerFromMiddleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js", {"./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"F:\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5CretryOnEmpty.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRetryOnEmptyMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
//
// RetryOnEmptyMiddleware will retry any request with an empty response that has
// a numbered block reference at or lower than the blockTracker's latest block.
// Its useful for dealing with load-balanced ethereum JSON RPC
// nodes that are not always in sync with each other.
//
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'retry-on-empty');
// empty values used to determine if a request should be retried
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [
    undefined,
    null,
    '\u003cnil\u003e',
];
function createRetryOnEmptyMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a;
        const blockRefIndex = cache_1.blockTagParamIndex(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not exact block references
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        // skip if non-number block reference
        if (['latest', 'pending'].includes(blockRef)) {
            return next();
        }
        // skip if block refernce is not a valid number
        const blockRefNumber = Number.parseInt(blockRef.slice(2), 16);
        if (Number.isNaN(blockRefNumber)) {
            return next();
        }
        // lookup latest block
        const latestBlockNumberHex = await blockTracker.getLatestBlock();
        const latestBlockNumber = Number.parseInt(latestBlockNumberHex.slice(2), 16);
        // skip if request block number is higher than current
        if (blockRefNumber > latestBlockNumber) {
            log('Requested block number %o is higher than latest block number %o, falling through to original request', blockRefNumber, latestBlockNumber);
            return next();
        }
        log('Requested block number %o is not higher than latest block number %o, trying request until non-empty response is received', blockRefNumber, latestBlockNumber);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        // attempt child request until non-empty response is received
        const childResponse = await retry(10, async () => {
            log('Performing request %o', childRequest);
            const attemptResponse = await pify_1.default(provider.sendAsync).call(provider, childRequest);
            log('Response is %o', attemptResponse);
            // verify result
            if (emptyValues.includes(attemptResponse.result)) {
                throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(attemptResponse)}" for request "${JSON.stringify(childRequest)}"`);
            }
            return attemptResponse;
        });
        log('Copying result %o and error %o', childResponse.result, childResponse.error);
        // copy child response onto original response
        res.result = childResponse.result;
        res.error = childResponse.error;
        return undefined;
    });
}
exports.createRetryOnEmptyMiddleware = createRetryOnEmptyMiddleware;
async function retry(maxRetries, asyncFn) {
    for (let index = 0; index < maxRetries; index++) {
        try {
            return await asyncFn();
        }
        catch (err) {
            log('(call %i) Request failed, waiting 1s to retry again...', index + 1);
            await timeout(1000);
        }
    }
    log('Retries exhausted');
    throw new Error('RetryOnEmptyMiddleware - retries exhausted');
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=retryOnEmpty.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js", {"json-stable-stringify":"F:\\metamask-extension\\node_modules\\json-stable-stringify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cutils%5Ccache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheTypeForPayload = exports.blockTagParamIndex = exports.paramsWithoutBlockTag = exports.blockTagForPayload = exports.canCache = exports.cacheIdentifierForPayload = void 0;
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
function cacheIdentifierForPayload(payload, skipBlockRef) {
    var _a;
    const simpleParams = skipBlockRef
        ? paramsWithoutBlockTag(payload)
        : (_a = payload.params) !== null && _a !== void 0 ? _a : [];
    if (canCache(payload)) {
        return `${payload.method}:${json_stable_stringify_1.default(simpleParams)}`;
    }
    return null;
}
exports.cacheIdentifierForPayload = cacheIdentifierForPayload;
function canCache(payload) {
    return cacheTypeForPayload(payload) !== 'never';
}
exports.canCache = canCache;
function blockTagForPayload(payload) {
    if (!payload.params) {
        return undefined;
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return undefined;
    }
    return payload.params[index];
}
exports.blockTagForPayload = blockTagForPayload;
function paramsWithoutBlockTag(payload) {
    if (!payload.params) {
        return [];
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return payload.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (payload.method === 'eth_getBlockByNumber') {
        return payload.params.slice(1);
    }
    return payload.params.slice(0, index);
}
exports.paramsWithoutBlockTag = paramsWithoutBlockTag;
function blockTagParamIndex(payload) {
    switch (payload.method) {
        // blockTag is at index 2
        case 'eth_getStorageAt':
            return 2;
        // blockTag is at index 1
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
            return 1;
        // blockTag is at index 0
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
function cacheTypeForPayload(payload) {
    switch (payload.method) {
        // cache permanently
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
        case 'test_permaCache':
            return 'perma';
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
        case 'test_forkCache':
            return 'fork';
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'test_blockCache':
            return 'block';
        // never cache
        default:
            return 'never';
    }
}
exports.cacheTypeForPayload = cacheTypeForPayload;
//# sourceMappingURL=cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js", {"@metamask/eth-sig-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","eth-rpc-errors":"F:\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Ceth-json-rpc-middleware%5Cdist%5Cwallet.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWalletMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const sigUtil = __importStar(require("@metamask/eth-sig-util"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
function createWalletMiddleware({ getAccounts, processDecryptMessage, processEncryptionPublicKey, processEthSignMessage, processPersonalMessage, processTransaction, processSignTransaction, processTypedMessage, processTypedMessageV3, processTypedMessageV4, }) {
    if (!getAccounts) {
        throw new Error('opts.getAccounts is required');
    }
    return json_rpc_engine_1.createScaffoldMiddleware({
        // account lookups
        eth_accounts: json_rpc_engine_1.createAsyncMiddleware(lookupAccounts),
        eth_coinbase: json_rpc_engine_1.createAsyncMiddleware(lookupDefaultAccount),
        // tx signatures
        eth_sendTransaction: json_rpc_engine_1.createAsyncMiddleware(sendTransaction),
        eth_signTransaction: json_rpc_engine_1.createAsyncMiddleware(signTransaction),
        // message signatures
        eth_sign: json_rpc_engine_1.createAsyncMiddleware(ethSign),
        eth_signTypedData: json_rpc_engine_1.createAsyncMiddleware(signTypedData),
        eth_signTypedData_v3: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV3),
        eth_signTypedData_v4: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV4),
        personal_sign: json_rpc_engine_1.createAsyncMiddleware(personalSign),
        eth_getEncryptionPublicKey: json_rpc_engine_1.createAsyncMiddleware(encryptionPublicKey),
        eth_decrypt: json_rpc_engine_1.createAsyncMiddleware(decryptMessage),
        personal_ecRecover: json_rpc_engine_1.createAsyncMiddleware(personalRecover),
    });
    //
    // account lookups
    //
    async function lookupAccounts(req, res) {
        res.result = await getAccounts(req);
    }
    async function lookupDefaultAccount(req, res) {
        const accounts = await getAccounts(req);
        res.result = accounts[0] || null;
    }
    //
    // transaction signatures
    //
    async function sendTransaction(req, res) {
        if (!processTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        if (!processSignTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processSignTransaction(txParams, req);
    }
    //
    // message signatures
    //
    async function ethSign(req, res) {
        if (!processEthSignMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processEthSignMessage(msgParams, req);
    }
    async function signTypedData(req, res) {
        if (!processTypedMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const message = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const version = 'V1';
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processTypedMessage(msgParams, req, version);
    }
    async function signTypedDataV3(req, res) {
        if (!processTypedMessageV3) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V3';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV3(msgParams, req, version);
    }
    async function signTypedDataV4(req, res) {
        if (!processTypedMessageV4) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V4';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV4(msgParams, req, version);
    }
    async function personalSign(req, res) {
        if (!processPersonalMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        // process normally
        const firstParam = req.params[0];
        const secondParam = req.params[1];
        // non-standard "extraParams" to be appended to our "msgParams" obj
        const extraParams = req.params[2] || {};
        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        let address, message;
        if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
            let warning = `The eth_personalSign method requires params ordered `;
            warning += `[message, address]. This was previously handled incorrectly, `;
            warning += `and has been corrected automatically. `;
            warning += `Please switch this param order for smooth behavior in the future.`;
            res.warning = warning;
            address = firstParam;
            message = secondParam;
        }
        else {
            message = firstParam;
            address = secondParam;
        }
        address = await validateAndNormalizeKeyholder(address, req);
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        // eslint-disable-next-line require-atomic-updates
        res.result = await processPersonalMessage(msgParams, req);
    }
    async function personalRecover(req, res) {
        const message = req.params[0];
        const signature = req.params[1];
        const signerAddress = sigUtil.recoverPersonalSignature({
            data: message,
            signature,
        });
        res.result = signerAddress;
    }
    async function encryptionPublicKey(req, res) {
        if (!processEncryptionPublicKey) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        res.result = await processEncryptionPublicKey(address, req);
    }
    async function decryptMessage(req, res) {
        if (!processDecryptMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const ciphertext = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: ciphertext });
        res.result = await processDecryptMessage(msgParams, req);
    }
    //
    // utility
    //
    /**
     * Validates the keyholder address, and returns a normalized (i.e. lowercase)
     * copy of it.
     *
     * @param {string} address - The address to validate and normalize.
     * @param {Object} req - The request object.
     * @returns {string} - The normalized address, if valid. Otherwise, throws
     * an error
     */
    async function validateAndNormalizeKeyholder(address, req) {
        if (typeof address === 'string' &&
            address.length > 0 &&
            resemblesAddress(address)) {
            // ensure address is included in provided accounts. `suppressUnauthorized: false` is passed to `getAccounts`
            // so that an "unauthorized" error is thrown if the requester does not have the `eth_accounts`
            // permission.
            const accounts = await getAccounts(req, {
                suppressUnauthorized: false,
            });
            const normalizedAccounts = accounts.map((_address) => _address.toLowerCase());
            const normalizedAddress = address.toLowerCase();
            if (normalizedAccounts.includes(normalizedAddress)) {
                return normalizedAddress;
            }
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized();
        }
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Invalid parameters: must provide an Ethereum address.`,
        });
    }
}
exports.createWalletMiddleware = createWalletMiddleware;
function resemblesAddress(str) {
    // hex prefix 2 + 20 bytes
    return str.length === 2 + 20 * 2;
}
//# sourceMappingURL=wallet.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-infura%5Cnode_modules%5Cpify%5Cindex.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-infura>eth-json-rpc-middleware>pify",file:"node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-cache.js", {"./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-cache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockCacheMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-cache');
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e'];
//
// Cache Strategies
//
class BlockCacheStrategy {
    constructor() {
        this.cache = {};
    }
    getBlockCache(blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            const newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    }
    async get(request, requestedBlockNumber) {
        // lookup block cache
        const blockCache = this.getBlockCache(requestedBlockNumber);
        // lookup payload in block cache
        const identifier = cache_1.cacheIdentifierForRequest(request, true);
        return identifier ? blockCache[identifier] : undefined;
    }
    async set(request, requestedBlockNumber, result) {
        // check if we can cached this result
        const canCacheResult = this.canCacheResult(request, result);
        if (!canCacheResult) {
            return;
        }
        // set the value in the cache
        const identifier = cache_1.cacheIdentifierForRequest(request, true);
        if (!identifier) {
            return;
        }
        const blockCache = this.getBlockCache(requestedBlockNumber);
        blockCache[identifier] = result;
    }
    canCacheRequest(request) {
        // check request method
        if (!cache_1.canCache(request.method)) {
            return false;
        }
        // check blockTag
        const blockTag = cache_1.blockTagForRequest(request);
        if (blockTag === 'pending') {
            return false;
        }
        // can be cached
        return true;
    }
    canCacheResult(request, result) {
        // never cache empty values (e.g. undefined)
        if (emptyValues.includes(result)) {
            return false;
        }
        // check if transactions have block reference before caching
        if (request.method &&
            ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(request.method)) {
            if (!result ||
                !result.blockHash ||
                result.blockHash ===
                    '0x0000000000000000000000000000000000000000000000000000000000000000') {
                return false;
            }
        }
        // otherwise true
        return true;
    }
    // removes all block caches with block number lower than `oldBlockHex`
    clearBefore(oldBlockHex) {
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter((num) => num < oldBlockNumber)
            .forEach((num) => delete this.cache[num]);
    }
}
function createBlockCacheMiddleware({ blockTracker, } = {}) {
    // validate options
    if (!blockTracker) {
        throw new Error('createBlockCacheMiddleware - No PollingBlockTracker specified');
    }
    // create caching strategies
    const blockCache = new BlockCacheStrategy();
    const strategies = {
        [cache_1.CacheStrategy.Permanent]: blockCache,
        [cache_1.CacheStrategy.Block]: blockCache,
        [cache_1.CacheStrategy.Fork]: blockCache,
        [cache_1.CacheStrategy.Never]: undefined,
    };
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // check type and matching strategy
        const type = cache_1.cacheTypeForMethod(req.method);
        const strategy = strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCacheRequest(req)) {
            return next();
        }
        // get block reference (number or keyword)
        const requestBlockTag = cache_1.blockTagForRequest(req);
        const blockTag = requestBlockTag && typeof requestBlockTag === 'string'
            ? requestBlockTag
            : 'latest';
        log('blockTag = %o, req = %o', blockTag, req);
        // get exact block number
        let requestedBlockNumber;
        if (blockTag === 'earliest') {
            // this just exists for symmetry with "latest"
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            // fetch latest block number
            log('Fetching latest block number to determine cache key');
            const latestBlockNumber = await blockTracker.getLatestBlock();
            // clear all cache before latest block
            log('Clearing values stored under block numbers before %o', latestBlockNumber);
            blockCache.clearBefore(latestBlockNumber);
            requestedBlockNumber = latestBlockNumber;
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // end on a hit, continue on a miss
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === undefined) {
            // cache miss
            // wait for other middleware to handle request
            log('No cache stored under block number %o, carrying request forward', requestedBlockNumber);
            // eslint-disable-next-line node/callback-return
            await next();
            // add result to cache
            // it's safe to cast res.result as Block, due to runtime type checks
            // performed when strategy.set is called
            log('Populating cache with', res);
            await strategy.set(req, requestedBlockNumber, res.result);
        }
        else {
            // fill in result from cache
            log('Cache hit, reusing cache result stored under block number %o', requestedBlockNumber);
            res.result = cacheResult;
        }
        return undefined;
    });
}
exports.createBlockCacheMiddleware = createBlockCacheMiddleware;
//# sourceMappingURL=block-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-cache.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js", {"./utils/cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref-rewrite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefRewriteMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createBlockRefRewriteMiddleware({ blockTracker, } = {}) {
    if (!blockTracker) {
        throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, _res, next) => {
        const blockRefIndex = cache_1.blockTagParamIndex(req.method);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = Array.isArray(req.params)
            ? req.params[blockRefIndex]
            : undefined;
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // rewrite blockRef to block-tracker's block number
        const latestBlockNumber = await blockTracker.getLatestBlock();
        if (Array.isArray(req.params)) {
            // eslint-disable-next-line require-atomic-updates
            req.params[blockRefIndex] = latestBlockNumber;
        }
        return next();
    });
}
exports.createBlockRefRewriteMiddleware = createBlockRefRewriteMiddleware;
//# sourceMappingURL=block-ref-rewrite.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref.js", {"./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"F:\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-ref.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const clone_1 = __importDefault(require("clone"));
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-ref');
function createBlockRefMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        var _a;
        const blockRefIndex = cache_1.blockTagParamIndex(req.method);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        const blockRef = Array.isArray(req.params)
            ? (_a = req.params[blockRefIndex]) !== null && _a !== void 0 ? _a : 'latest'
            : 'latest';
        // skip if not "latest"
        if (blockRef !== 'latest') {
            log('blockRef is not "latest", carrying request forward');
            return next();
        }
        // lookup latest block
        const latestBlockNumber = await blockTracker.getLatestBlock();
        log(`blockRef is "latest", setting param ${blockRefIndex} to latest block ${latestBlockNumber}`);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        if (Array.isArray(childRequest.params)) {
            childRequest.params[blockRefIndex] = latestBlockNumber;
        }
        // perform child request
        log('Performing another request %o', childRequest);
        const childRes = await pify_1.default(provider.sendAsync).call(provider, childRequest);
        // copy child response onto original response
        res.result = childRes.result;
        res.error = childRes.error;
        return undefined;
    });
}
exports.createBlockRefMiddleware = createBlockRefMiddleware;
//# sourceMappingURL=block-ref.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js", {"./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cblock-tracker-inspector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockTrackerInspectorMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'block-tracker-inspector');
const futureBlockRefRequests = [
    'eth_getTransactionByHash',
    'eth_getTransactionReceipt',
];
/**
 * Determines whether the given object has the given property.
 *
 * @param objectToCheck - The object to check.
 * @param property - The property to look for.
 * @returns - Whether the object has the property.
 */
function hasProperty(objectToCheck, property) {
    return Object.hasOwnProperty.call(objectToCheck, property);
}
function getResultBlockNumber(response) {
    const { result } = response;
    if (!result ||
        typeof result !== 'object' ||
        !hasProperty(result, 'blockNumber')) {
        return undefined;
    }
    if (typeof result.blockNumber === 'string') {
        return result.blockNumber;
    }
    return undefined;
}
// inspect if response contains a block ref higher than our latest block
function createBlockTrackerInspectorMiddleware({ blockTracker, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        if (!futureBlockRefRequests.includes(req.method)) {
            return next();
        }
        // eslint-disable-next-line node/callback-return
        await next();
        // abort if no result or no block number
        const responseBlockNumber = getResultBlockNumber(res);
        if (!responseBlockNumber) {
            return undefined;
        }
        log('res.result.blockNumber exists, proceeding. res = %o', res);
        // if number is higher, suggest block-tracker check for a new block
        const blockNumber = Number.parseInt(responseBlockNumber, 16);
        // Typecast: If getCurrentBlock returns null, currentBlockNumber will be NaN, which is fine.
        const currentBlockNumber = Number.parseInt(blockTracker.getCurrentBlock(), 16);
        if (blockNumber > currentBlockNumber) {
            log('blockNumber from response is greater than current block number, refreshing current block number');
            await blockTracker.checkForLatestBlock();
        }
        return undefined;
    });
}
exports.createBlockTrackerInspectorMiddleware = createBlockTrackerInspectorMiddleware;
//# sourceMappingURL=block-tracker-inspector.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\fetch.js", {"./utils/timeout":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js","eth-rpc-errors":"F:\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cfetch.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchConfigFromReq = exports.createFetchMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const timeout_1 = require("./utils/timeout");
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'failed to parse response body',
    // ignore errors where http req failed to establish
    'Failed to fetch',
];
/**
 * Create middleware for sending a JSON-RPC request to the given RPC URL.
 *
 * @param options - Options
 * @param options.btoa - Generates a base64-encoded string from a binary string.
 * @param options.fetch - The `fetch` function; expected to be equivalent to `window.fetch`.
 * @param options.rpcUrl - The URL to send the request to.
 * @param options.originHttpHeaderKey - If provider, the origin field for each JSON-RPC request
 * will be attached to each outgoing fetch request under this header.
 * @returns The fetch middleware.
 */
function createFetchMiddleware({ 
// eslint-disable-next-line @typescript-eslint/no-shadow
btoa, 
// eslint-disable-next-line @typescript-eslint/no-shadow
fetch, rpcUrl, originHttpHeaderKey, }) {
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, _next) => {
        const { fetchUrl, fetchParams } = createFetchConfigFromReq({
            btoa,
            req,
            rpcUrl,
            originHttpHeaderKey,
        });
        // attempt request multiple times
        const maxAttempts = 5;
        const retryInterval = 1000;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            try {
                const fetchRes = await fetch(fetchUrl, fetchParams);
                // check for http errrors
                checkForHttpErrors(fetchRes);
                // parse response body
                const rawBody = await fetchRes.text();
                let fetchBody;
                try {
                    fetchBody = JSON.parse(rawBody);
                }
                catch (_) {
                    throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`);
                }
                const result = parseResponse(fetchRes, fetchBody);
                // set result and exit retry loop
                res.result = result;
                return;
            }
            catch (err) {
                const errMsg = err.toString();
                const isRetriable = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
                // re-throw error if not retriable
                if (!isRetriable) {
                    throw err;
                }
            }
            // delay before retrying
            await timeout_1.timeout(retryInterval);
        }
    });
}
exports.createFetchMiddleware = createFetchMiddleware;
function checkForHttpErrors(fetchRes) {
    // check for errors
    switch (fetchRes.status) {
        case 405:
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
        case 418:
            throw createRatelimitError();
        case 503:
        case 504:
            throw createTimeoutError();
        default:
            break;
    }
}
function parseResponse(fetchRes, body) {
    // check for error code
    if (fetchRes.status !== 200) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            message: `Non-200 status code: '${fetchRes.status}'`,
            data: body,
        });
    }
    // check for rpc error
    if (body.error) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            data: body.error,
        });
    }
    // return successful result
    return body.result;
}
/**
 * Generate `fetch` configuration for sending the given request to an RPC API.
 *
 * @param options - Options
 * @param options.btoa - Generates a base64-encoded string from a binary string.
 * @param options.rpcUrl - The URL to send the request to.
 * @param options.originHttpHeaderKey - If provider, the origin field for each JSON-RPC request
 * will be attached to each outgoing fetch request under this header.
 * @returns The fetch middleware.
 */
function createFetchConfigFromReq({ 
// eslint-disable-next-line @typescript-eslint/no-shadow
btoa, req, rpcUrl, originHttpHeaderKey, }) {
    const parsedUrl = new URL(rpcUrl);
    const fetchUrl = normalizeUrlFromParsed(parsedUrl);
    // prepare payload
    // copy only canonical json rpc properties
    const payload = {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
    // extract 'origin' parameter from request
    const originDomain = req.origin;
    // serialize request body
    const serializedPayload = JSON.stringify(payload);
    // configure fetch params
    const fetchParams = {
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        body: serializedPayload,
    };
    // encoded auth details as header (not allowed in fetch url)
    if (parsedUrl.username && parsedUrl.password) {
        const authString = `${parsedUrl.username}:${parsedUrl.password}`;
        const encodedAuth = btoa(authString);
        fetchParams.headers.Authorization = `Basic ${encodedAuth}`;
    }
    // optional: add request origin as header
    if (originHttpHeaderKey && originDomain) {
        fetchParams.headers[originHttpHeaderKey] = originDomain;
    }
    return { fetchUrl, fetchParams };
}
exports.createFetchConfigFromReq = createFetchConfigFromReq;
function normalizeUrlFromParsed(parsedUrl) {
    let result = '';
    result += parsedUrl.protocol;
    result += `//${parsedUrl.hostname}`;
    if (parsedUrl.port) {
        result += `:${parsedUrl.port}`;
    }
    result += `${parsedUrl.pathname}`;
    result += `${parsedUrl.search}`;
    return result;
}
function createRatelimitError() {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: `Request is being rate limited.` });
}
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: msg });
}
//# sourceMappingURL=fetch.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\fetch.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\index.js", {"./block-cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-cache.js","./block-ref":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref.js","./block-ref-rewrite":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js","./block-tracker-inspector":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js","./fetch":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\fetch.js","./inflight-cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\inflight-cache.js","./providerAsMiddleware":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js","./retryOnEmpty":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js","./wallet":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\wallet.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./block-cache"), exports);
__exportStar(require("./block-ref-rewrite"), exports);
__exportStar(require("./block-ref"), exports);
__exportStar(require("./block-tracker-inspector"), exports);
__exportStar(require("./fetch"), exports);
__exportStar(require("./inflight-cache"), exports);
__exportStar(require("./providerAsMiddleware"), exports);
__exportStar(require("./retryOnEmpty"), exports);
__exportStar(require("./wallet"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\inflight-cache.js", {"./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"F:\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cinflight-cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInflightCacheMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'inflight-cache');
function createInflightCacheMiddleware() {
    const inflightRequests = {};
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // get cacheId, if cacheable
        const cacheId = cache_1.cacheIdentifierForRequest(req);
        // if not cacheable, skip
        if (!cacheId) {
            log('Request is not cacheable, proceeding. req = %o', req);
            return next();
        }
        // check for matching requests
        let activeRequestHandlers = inflightRequests[cacheId];
        // if found, wait for the active request to be handled
        if (activeRequestHandlers) {
            // setup the response listener and wait for it to be called
            // it will handle copying the result and request fields
            log('Running %i handler(s) for request %o', activeRequestHandlers.length, req);
            await createActiveRequestHandler(res, activeRequestHandlers);
            return undefined;
        }
        // setup response handler array for subsequent requests
        activeRequestHandlers = [];
        inflightRequests[cacheId] = activeRequestHandlers;
        // allow request to be handled normally
        log('Carrying original request forward %o', req);
        // eslint-disable-next-line node/callback-return
        await next();
        // clear inflight requests
        delete inflightRequests[cacheId];
        // schedule activeRequestHandlers to be handled
        log('Running %i collected handler(s) for request %o', activeRequestHandlers.length, req);
        handleActiveRequest(res, activeRequestHandlers);
        // complete
        return undefined;
    });
    function createActiveRequestHandler(res, activeRequestHandlers) {
        const { resolve, promise } = deferredPromise();
        activeRequestHandlers.push((handledRes) => {
            // append a copy of the result and error to the response
            res.result = clone_1.default(handledRes.result);
            res.error = clone_1.default(handledRes.error);
            resolve();
        });
        return promise;
    }
    function handleActiveRequest(res, activeRequestHandlers) {
        // use setTimeout so we can resolve our original request first
        setTimeout(() => {
            activeRequestHandlers.forEach((handler) => {
                try {
                    handler(res);
                }
                catch (err) {
                    // catch error so all requests are handled correctly
                    console.error(err);
                }
            });
        });
    }
}
exports.createInflightCacheMiddleware = createInflightCacheMiddleware;
function deferredPromise() {
    let resolve;
    const promise = new Promise((_resolve) => {
        resolve = _resolve;
    });
    return { resolve, promise };
}
//# sourceMappingURL=inflight-cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\inflight-cache.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Clogging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = utils_1.createProjectLogger('eth-json-rpc-middleware');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5CproviderAsMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethersProviderAsMiddleware = exports.providerAsMiddleware = void 0;
function providerAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.sendAsync(req, (err, providerRes) => {
            // forward any error
            if (err instanceof Error) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.providerAsMiddleware = providerAsMiddleware;
function ethersProviderAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.send(req, (err, providerRes) => {
            // forward any error
            if (err) {
                // TODO: Remove this cast when next major `json-rpc-engine` release is out
                // The next release changes how errors are propogated.
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.ethersProviderAsMiddleware = ethersProviderAsMiddleware;
//# sourceMappingURL=providerAsMiddleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js", {"./logging-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\logging-utils.js","./utils/cache":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js","./utils/timeout":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js","clone":"F:\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5CretryOnEmpty.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRetryOnEmptyMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const pify_1 = __importDefault(require("pify"));
const logging_utils_1 = require("./logging-utils");
const cache_1 = require("./utils/cache");
const timeout_1 = require("./utils/timeout");
//
// RetryOnEmptyMiddleware will retry any request with an empty response that has
// a numbered block reference at or lower than the blockTracker's latest block.
// Its useful for dealing with load-balanced ethereum JSON RPC
// nodes that are not always in sync with each other.
//
const log = logging_utils_1.createModuleLogger(logging_utils_1.projectLogger, 'retry-on-empty');
// empty values used to determine if a request should be retried
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [
    undefined,
    null,
    '\u003cnil\u003e',
];
function createRetryOnEmptyMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
    }
    return json_rpc_engine_1.createAsyncMiddleware(async (req, res, next) => {
        const blockRefIndex = cache_1.blockTagParamIndex(req.method);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not exact block references
        let blockRef = Array.isArray(req.params)
            ? req.params[blockRefIndex]
            : undefined;
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        // skip if non-number block reference
        if (['latest', 'pending'].includes(blockRef)) {
            return next();
        }
        // skip if block refernce is not a valid number
        const blockRefNumber = Number.parseInt(blockRef.slice(2), 16);
        if (Number.isNaN(blockRefNumber)) {
            return next();
        }
        // lookup latest block
        const latestBlockNumberHex = await blockTracker.getLatestBlock();
        const latestBlockNumber = Number.parseInt(latestBlockNumberHex.slice(2), 16);
        // skip if request block number is higher than current
        if (blockRefNumber > latestBlockNumber) {
            log('Requested block number %o is higher than latest block number %o, falling through to original request', blockRefNumber, latestBlockNumber);
            return next();
        }
        log('Requested block number %o is not higher than latest block number %o, trying request until non-empty response is received', blockRefNumber, latestBlockNumber);
        // create child request with specific block-ref
        const childRequest = clone_1.default(req);
        // attempt child request until non-empty response is received
        const childResponse = await retry(10, async () => {
            log('Performing request %o', childRequest);
            const attemptResponse = await pify_1.default(provider.sendAsync).call(provider, childRequest);
            log('Response is %o', attemptResponse);
            // verify result
            if (emptyValues.includes(attemptResponse.result)) {
                throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(attemptResponse)}" for request "${JSON.stringify(childRequest)}"`);
            }
            return attemptResponse;
        });
        log('Copying result %o and error %o', childResponse.result, childResponse.error);
        // copy child response onto original response
        res.result = childResponse.result;
        res.error = childResponse.error;
        return undefined;
    });
}
exports.createRetryOnEmptyMiddleware = createRetryOnEmptyMiddleware;
async function retry(maxRetries, asyncFn) {
    for (let index = 0; index < maxRetries; index++) {
        try {
            return await asyncFn();
        }
        catch (err) {
            log('(call %i) Request failed, waiting 1s to retry again...', index + 1);
            await timeout_1.timeout(1000);
        }
    }
    log('Retries exhausted');
    throw new Error('RetryOnEmptyMiddleware - retries exhausted');
}
//# sourceMappingURL=retryOnEmpty.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js", {"safe-stable-stringify":"F:\\metamask-extension\\node_modules\\safe-stable-stringify\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cutils%5Ccache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheTypeForMethod = exports.blockTagParamIndex = exports.blockTagForRequest = exports.canCache = exports.cacheIdentifierForRequest = exports.CacheStrategy = void 0;
const safe_stable_stringify_1 = require("safe-stable-stringify");
const stringify = safe_stable_stringify_1.configure({ bigint: false, circularValue: Error });
/**
 * The cache strategy to use for a given method.
 */
var CacheStrategy;
(function (CacheStrategy) {
    /**
     * Cache per-block.
     */
    CacheStrategy["Block"] = "block";
    /**
     * Cache until a chain reorganization occurs.
     */
    CacheStrategy["Fork"] = "fork";
    /**
     * Never cache.
     */
    CacheStrategy["Never"] = "never";
    /**
     * Permanently cache.
     */
    CacheStrategy["Permanent"] = "perma";
})(CacheStrategy = exports.CacheStrategy || (exports.CacheStrategy = {}));
/*
 * Return a cache identifier for the given request.
 *
 * This identifier should include any request details that might impact the
 * response, with the exception of the block parameter if the `skipBlockRef`
 * option is set,
 *
 * If the request cannot be cached, this will return `null`.
 *
 * @param request - The JSON-RPC request.
 * @param skipBlockRef - Skip the block parameter when generating the cache
 * identifier.
 * @returns The cache identifier for this request, or `null` if it can't be
 * cached.
 */
function cacheIdentifierForRequest(request, skipBlockRef) {
    var _a;
    const simpleParams = skipBlockRef
        ? paramsWithoutBlockTag(request)
        : (_a = request.params) !== null && _a !== void 0 ? _a : [];
    if (canCache(request.method)) {
        return `${request.method}:${stringify(simpleParams)}`;
    }
    return null;
}
exports.cacheIdentifierForRequest = cacheIdentifierForRequest;
/**
 * Return whether a method can be cached or not.
 *
 * @param method - The method to check.
 * @returns Whether the method can be cached.
 */
function canCache(method) {
    return cacheTypeForMethod(method) !== CacheStrategy.Never;
}
exports.canCache = canCache;
/**
 * Return the block parameter for the given request, if it has one.
 *
 * @param request - The JSON-RPC request.
 * @returns The block parameter in the given request, or `undefined` if none was found.
 */
function blockTagForRequest(request) {
    if (!request.params) {
        return undefined;
    }
    const index = blockTagParamIndex(request.method);
    // Block tag param not passed.
    if (index === undefined ||
        !Array.isArray(request.params) ||
        index >= request.params.length) {
        return undefined;
    }
    return request.params[index];
}
exports.blockTagForRequest = blockTagForRequest;
/**
 * Return the request parameters without the block parameter.
 *
 * @param request - The JSON-RPC request.
 * @returns The request parameters with the block parameter removed, if one was found.
 */
function paramsWithoutBlockTag(request) {
    if (!request.params) {
        return [];
    }
    const index = blockTagParamIndex(request.method);
    // Block tag param not passed.
    if (index === undefined ||
        !Array.isArray(request.params) ||
        index >= request.params.length) {
        return request.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (request.method === 'eth_getBlockByNumber') {
        return request.params.slice(1);
    }
    return request.params.slice(0, index);
}
/**
 * Returns the index of the block parameter for the given method.
 *
 * @param method - A JSON-RPC method.
 * @returns The index of the block parameter for that method, or `undefined` if
 * there is no known block parameter.
 */
function blockTagParamIndex(method) {
    switch (method) {
        // blockTag is at index 2
        case 'eth_getStorageAt':
            return 2;
        // blockTag is at index 1
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
            return 1;
        // blockTag is at index 0
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
/**
 * Return the cache type used for the given method.
 *
 * @param method - A JSON-RPC method.
 * @returns The cache type to use for that method.
 */
function cacheTypeForMethod(method) {
    switch (method) {
        // cache permanently
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
        case 'test_permaCache':
            return CacheStrategy.Permanent;
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
        case 'test_forkCache':
            return CacheStrategy.Fork;
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'test_blockCache':
            return CacheStrategy.Block;
        // never cache
        default:
            return CacheStrategy.Never;
    }
}
exports.cacheTypeForMethod = cacheTypeForMethod;
//# sourceMappingURL=cache.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\cache.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cutils%5Ctimeout.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeout = void 0;
/**
 * Wait the specified number of milliseconds.
 *
 * @param duration - The number of milliseconds to wait.
 * @returns A promise that resolves after the specified amount of time.
 */
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
exports.timeout = timeout;
//# sourceMappingURL=timeout.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\utils\\timeout.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\wallet.js", {"@metamask/eth-sig-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","eth-rpc-errors":"F:\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cdist%5Cwallet.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWalletMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const sigUtil = __importStar(require("@metamask/eth-sig-util"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
function createWalletMiddleware({ getAccounts, processDecryptMessage, processEncryptionPublicKey, processEthSignMessage, processPersonalMessage, processTransaction, processSignTransaction, processTypedMessage, processTypedMessageV3, processTypedMessageV4, }) {
    if (!getAccounts) {
        throw new Error('opts.getAccounts is required');
    }
    return json_rpc_engine_1.createScaffoldMiddleware({
        // account lookups
        eth_accounts: json_rpc_engine_1.createAsyncMiddleware(lookupAccounts),
        eth_coinbase: json_rpc_engine_1.createAsyncMiddleware(lookupDefaultAccount),
        // tx signatures
        eth_sendTransaction: json_rpc_engine_1.createAsyncMiddleware(sendTransaction),
        eth_signTransaction: json_rpc_engine_1.createAsyncMiddleware(signTransaction),
        // message signatures
        eth_sign: json_rpc_engine_1.createAsyncMiddleware(ethSign),
        eth_signTypedData: json_rpc_engine_1.createAsyncMiddleware(signTypedData),
        eth_signTypedData_v3: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV3),
        eth_signTypedData_v4: json_rpc_engine_1.createAsyncMiddleware(signTypedDataV4),
        personal_sign: json_rpc_engine_1.createAsyncMiddleware(personalSign),
        eth_getEncryptionPublicKey: json_rpc_engine_1.createAsyncMiddleware(encryptionPublicKey),
        eth_decrypt: json_rpc_engine_1.createAsyncMiddleware(decryptMessage),
        personal_ecRecover: json_rpc_engine_1.createAsyncMiddleware(personalRecover),
    });
    //
    // account lookups
    //
    async function lookupAccounts(req, res) {
        res.result = await getAccounts(req);
    }
    async function lookupDefaultAccount(req, res) {
        const accounts = await getAccounts(req);
        res.result = accounts[0] || null;
    }
    //
    // transaction signatures
    //
    async function sendTransaction(req, res) {
        if (!processTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        if (!processSignTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processSignTransaction(txParams, req);
    }
    //
    // message signatures
    //
    async function ethSign(req, res) {
        if (!processEthSignMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processEthSignMessage(msgParams, req);
    }
    async function signTypedData(req, res) {
        if (!processTypedMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const message = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const version = 'V1';
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processTypedMessage(msgParams, req, version);
    }
    async function signTypedDataV3(req, res) {
        if (!processTypedMessageV3) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V3';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV3(msgParams, req, version);
    }
    async function signTypedDataV4(req, res) {
        if (!processTypedMessageV4) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V4';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV4(msgParams, req, version);
    }
    async function personalSign(req, res) {
        if (!processPersonalMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        // process normally
        const firstParam = req.params[0];
        const secondParam = req.params[1];
        // non-standard "extraParams" to be appended to our "msgParams" obj
        const extraParams = req.params[2] || {};
        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        let address, message;
        if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
            let warning = `The eth_personalSign method requires params ordered `;
            warning += `[message, address]. This was previously handled incorrectly, `;
            warning += `and has been corrected automatically. `;
            warning += `Please switch this param order for smooth behavior in the future.`;
            res.warning = warning;
            address = firstParam;
            message = secondParam;
        }
        else {
            message = firstParam;
            address = secondParam;
        }
        address = await validateAndNormalizeKeyholder(address, req);
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        // eslint-disable-next-line require-atomic-updates
        res.result = await processPersonalMessage(msgParams, req);
    }
    async function personalRecover(req, res) {
        const message = req.params[0];
        const signature = req.params[1];
        const signerAddress = sigUtil.recoverPersonalSignature({
            data: message,
            signature,
        });
        res.result = signerAddress;
    }
    async function encryptionPublicKey(req, res) {
        if (!processEncryptionPublicKey) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        res.result = await processEncryptionPublicKey(address, req);
    }
    async function decryptMessage(req, res) {
        if (!processDecryptMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const ciphertext = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: ciphertext });
        res.result = await processDecryptMessage(msgParams, req);
    }
    //
    // utility
    //
    /**
     * Validates the keyholder address, and returns a normalized (i.e. lowercase)
     * copy of it.
     *
     * @param {string} address - The address to validate and normalize.
     * @param {Object} req - The request object.
     * @returns {string} - The normalized address, if valid. Otherwise, throws
     * an error
     */
    async function validateAndNormalizeKeyholder(address, req) {
        if (typeof address === 'string' &&
            address.length > 0 &&
            resemblesAddress(address)) {
            // Ensure that an "unauthorized" error is thrown if the requester does not have the `eth_accounts`
            // permission.
            const accounts = await getAccounts(req);
            const normalizedAccounts = accounts.map((_address) => _address.toLowerCase());
            const normalizedAddress = address.toLowerCase();
            if (normalizedAccounts.includes(normalizedAddress)) {
                return normalizedAddress;
            }
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized();
        }
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Invalid parameters: must provide an Ethereum address.`,
        });
    }
}
exports.createWalletMiddleware = createWalletMiddleware;
function resemblesAddress(str) {
    // hex prefix 2 + 20 bytes
    return str.length === 2 + 20 * 2;
}
//# sourceMappingURL=wallet.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\dist\\wallet.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js", {"superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cassert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
const superstruct_1 = require("superstruct");
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
/**
 * Check if a value is a constructor, i.e., a function that can be called with
 * the `new` keyword.
 *
 * @param fn - The value to check.
 * @returns `true` if the value is a constructor, or `false` otherwise.
 */
function isConstructable(fn) {
    var _a, _b;
    /* istanbul ignore next */
    return Boolean(typeof ((_b = (_a = fn === null || fn === void 0 ? void 0 : fn.prototype) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'string');
}
/**
 * Get the error message from an unknown error object. If the error object has
 * a `message` property, that property is returned. Otherwise, the stringified
 * error object is returned.
 *
 * @param error - The error object to get the message from.
 * @returns The error message.
 */
function getErrorMessage(error) {
    const message = isErrorWithMessage(error) ? error.message : String(error);
    // If the error ends with a period, remove it, as we'll add our own period.
    if (message.endsWith('.')) {
        return message.slice(0, -1);
    }
    return message;
}
/**
 * Initialise an {@link AssertionErrorConstructor} error.
 *
 * @param ErrorWrapper - The error class to use.
 * @param message - The error message.
 * @returns The error object.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getError(ErrorWrapper, message) {
    if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
            message,
        });
    }
    return ErrorWrapper({
        message,
    });
}
/**
 * The default error class that is thrown if an assertion fails.
 */
class AssertionError extends Error {
    constructor(options) {
        super(options.message);
        this.code = 'ERR_ASSERTION';
    }
}
exports.AssertionError = AssertionError;
/**
 * Same as Node.js assert.
 * If the value is falsy, throws an error, does nothing otherwise.
 *
 * @throws {@link AssertionError} If value is falsy.
 * @param value - The test that should be truthy to pass.
 * @param message - Message to be passed to {@link AssertionError} or an
 * {@link Error} instance to throw.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}. If a custom error class is provided for
 * the `message` argument, this argument is ignored.
 */
function assert(value, message = 'Assertion failed.', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    if (!value) {
        if (message instanceof Error) {
            throw message;
        }
        throw getError(ErrorWrapper, message);
    }
}
exports.assert = assert;
/**
 * Assert a value against a Superstruct struct.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param errorPrefix - A prefix to add to the error message. Defaults to
 * "Assertion failed".
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the value is not valid.
 */
function assertStruct(value, struct, errorPrefix = 'Assertion failed', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    try {
        (0, superstruct_1.assert)(value, struct);
    }
    catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
    }
}
exports.assertStruct = assertStruct;
/**
 * Use in the default case of a switch that you want to be fully exhaustive.
 * Using this function forces the compiler to enforce exhaustivity during
 * compile-time.
 *
 * @example
 * ```
 * const number = 1;
 * switch (number) {
 *   case 0:
 *     ...
 *   case 1:
 *     ...
 *   default:
 *     assertExhaustive(snapPrefix);
 * }
 * ```
 * @param _object - The object on which the switch is being operated.
 */
function assertExhaustive(_object) {
    throw new Error('Invalid branch reached. Should be detected during compilation.');
}
exports.assertExhaustive = assertExhaustive;
//# sourceMappingURL=assert.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbase64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64 = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * Ensure that a provided string-based struct is valid base64.
 *
 * @param struct - The string based struct.
 * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.
 * @returns A superstruct validating base64.
 */
const base64 = (struct, options = {}) => {
    var _a, _b;
    const paddingRequired = (_a = options.paddingRequired) !== null && _a !== void 0 ? _a : false;
    const characterSet = (_b = options.characterSet) !== null && _b !== void 0 ? _b : 'base64';
    let letters;
    if (characterSet === 'base64') {
        letters = String.raw `[A-Za-z0-9+\/]`;
    }
    else {
        (0, assert_1.assert)(characterSet === 'base64url');
        letters = String.raw `[-_A-Za-z0-9]`;
    }
    let re;
    if (paddingRequired) {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    else {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    return (0, superstruct_1.pattern)(struct, re);
};
exports.base64 = base64;
//# sourceMappingURL=base64.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbytes.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDataView = exports.concatBytes = exports.valueToBytes = exports.stringToBytes = exports.numberToBytes = exports.signedBigIntToBytes = exports.bigIntToBytes = exports.hexToBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToSignedBigInt = exports.bytesToBigInt = exports.bytesToHex = exports.assertIsBytes = exports.isBytes = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
// '0'.charCodeAt(0) === 48
const HEX_MINIMUM_NUMBER_CHARACTER = 48;
// '9'.charCodeAt(0) === 57
const HEX_MAXIMUM_NUMBER_CHARACTER = 58;
const HEX_CHARACTER_OFFSET = 87;
/**
 * Memoized function that returns an array to be used as a lookup table for
 * converting bytes to hexadecimal values.
 *
 * The array is created lazily and then cached for future use. The benefit of
 * this approach is that the performance of converting bytes to hex is much
 * better than if we were to call `toString(16)` on each byte.
 *
 * The downside is that the array is created once and then never garbage
 * collected. This is not a problem in practice because the array is only 256
 * elements long.
 *
 * @returns A function that returns the lookup table.
 */
function getPrecomputedHexValuesBuilder() {
    // To avoid issues with tree shaking, we need to use a function to return the
    // array. This is because the array is only used in the `bytesToHex` function
    // and if we were to use a global variable, the array might be removed by the
    // tree shaker.
    const lookupTable = [];
    return () => {
        if (lookupTable.length === 0) {
            for (let i = 0; i < 256; i++) {
                lookupTable.push(i.toString(16).padStart(2, '0'));
            }
        }
        return lookupTable;
    };
}
/**
 * Function implementation of the {@link getPrecomputedHexValuesBuilder}
 * function.
 */
const getPrecomputedHexValues = getPrecomputedHexValuesBuilder();
/**
 * Check if a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @returns Whether the value is a `Uint8Array`.
 */
function isBytes(value) {
    return value instanceof Uint8Array;
}
exports.isBytes = isBytes;
/**
 * Assert that a value is a `Uint8Array`.
 *
 * @param value - The value to check.
 * @throws If the value is not a `Uint8Array`.
 */
function assertIsBytes(value) {
    (0, assert_1.assert)(isBytes(value), 'Value must be a Uint8Array.');
}
exports.assertIsBytes = assertIsBytes;
/**
 * Convert a `Uint8Array` to a hexadecimal string.
 *
 * @param bytes - The bytes to convert to a hexadecimal string.
 * @returns The hexadecimal string.
 */
function bytesToHex(bytes) {
    assertIsBytes(bytes);
    if (bytes.length === 0) {
        return '0x';
    }
    const lookupTable = getPrecomputedHexValues();
    const hexadecimal = new Array(bytes.length);
    for (let i = 0; i < bytes.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        hexadecimal[i] = lookupTable[bytes[i]];
    }
    return (0, hex_1.add0x)(hexadecimal.join(''));
}
exports.bytesToHex = bytesToHex;
/**
 * Convert a `Uint8Array` to a `bigint`.
 *
 * To convert a `Uint8Array` to a `number` instead, use {@link bytesToNumber}.
 * To convert a two's complement encoded `Uint8Array` to a `bigint`, use
 * {@link bytesToSignedBigInt}.
 *
 * @param bytes - The bytes to convert to a `bigint`.
 * @returns The `bigint`.
 */
function bytesToBigInt(bytes) {
    assertIsBytes(bytes);
    const hexadecimal = bytesToHex(bytes);
    return BigInt(hexadecimal);
}
exports.bytesToBigInt = bytesToBigInt;
/**
 * Convert a `Uint8Array` to a signed `bigint`. This assumes that the bytes are
 * encoded in two's complement.
 *
 * To convert a `Uint8Array` to an unsigned `bigint` instead, use
 * {@link bytesToBigInt}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param bytes - The bytes to convert to a signed `bigint`.
 * @returns The signed `bigint`.
 */
function bytesToSignedBigInt(bytes) {
    assertIsBytes(bytes);
    let value = BigInt(0);
    for (const byte of bytes) {
        // eslint-disable-next-line no-bitwise
        value = (value << BigInt(8)) + BigInt(byte);
    }
    return BigInt.asIntN(bytes.length * 8, value);
}
exports.bytesToSignedBigInt = bytesToSignedBigInt;
/**
 * Convert a `Uint8Array` to a `number`.
 *
 * To convert a `Uint8Array` to a `bigint` instead, use {@link bytesToBigInt}.
 *
 * @param bytes - The bytes to convert to a number.
 * @returns The number.
 * @throws If the resulting number is not a safe integer.
 */
function bytesToNumber(bytes) {
    assertIsBytes(bytes);
    const bigint = bytesToBigInt(bytes);
    (0, assert_1.assert)(bigint <= BigInt(Number.MAX_SAFE_INTEGER), 'Number is not a safe integer. Use `bytesToBigInt` instead.');
    return Number(bigint);
}
exports.bytesToNumber = bytesToNumber;
/**
 * Convert a UTF-8 encoded `Uint8Array` to a `string`.
 *
 * @param bytes - The bytes to convert to a string.
 * @returns The string.
 */
function bytesToString(bytes) {
    assertIsBytes(bytes);
    return new TextDecoder().decode(bytes);
}
exports.bytesToString = bytesToString;
/**
 * Convert a hexadecimal string to a `Uint8Array`. The string can optionally be
 * prefixed with `0x`. It accepts even and odd length strings.
 *
 * If the value is "0x", an empty `Uint8Array` is returned.
 *
 * @param value - The hexadecimal string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function hexToBytes(value) {
    var _a;
    // "0x" is often used as empty byte array.
    if (((_a = value === null || value === void 0 ? void 0 : value.toLowerCase) === null || _a === void 0 ? void 0 : _a.call(value)) === '0x') {
        return new Uint8Array();
    }
    (0, hex_1.assertIsHexString)(value);
    // Remove the `0x` prefix if it exists, and pad the string to have an even
    // number of characters.
    const strippedValue = (0, hex_1.remove0x)(value).toLowerCase();
    const normalizedValue = strippedValue.length % 2 === 0 ? strippedValue : `0${strippedValue}`;
    const bytes = new Uint8Array(normalizedValue.length / 2);
    for (let i = 0; i < bytes.length; i++) {
        // While this is not the prettiest way to convert a hexadecimal string to a
        // `Uint8Array`, it is a lot faster than using `parseInt` to convert each
        // character.
        const c1 = normalizedValue.charCodeAt(i * 2);
        const c2 = normalizedValue.charCodeAt(i * 2 + 1);
        const n1 = c1 -
            (c1 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        const n2 = c2 -
            (c2 < HEX_MAXIMUM_NUMBER_CHARACTER
                ? HEX_MINIMUM_NUMBER_CHARACTER
                : HEX_CHARACTER_OFFSET);
        bytes[i] = n1 * 16 + n2;
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
/**
 * Convert a `bigint` to a `Uint8Array`.
 *
 * This assumes that the `bigint` is an unsigned integer. To convert a signed
 * `bigint` instead, use {@link signedBigIntToBytes}.
 *
 * @param value - The bigint to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function bigIntToBytes(value) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= BigInt(0), 'Value must be a non-negative bigint.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.bigIntToBytes = bigIntToBytes;
/**
 * Check if a `bigint` fits in a certain number of bytes.
 *
 * @param value - The `bigint` to check.
 * @param bytes - The number of bytes.
 * @returns Whether the `bigint` fits in the number of bytes.
 */
function bigIntFits(value, bytes) {
    (0, assert_1.assert)(bytes > 0);
    /* eslint-disable no-bitwise */
    const mask = value >> BigInt(31);
    return !(((~value & mask) + (value & ~mask)) >> BigInt(bytes * 8 + ~0));
    /* eslint-enable no-bitwise */
}
/**
 * Convert a signed `bigint` to a `Uint8Array`. This uses two's complement
 * encoding to represent negative numbers.
 *
 * To convert an unsigned `bigint` to a `Uint8Array` instead, use
 * {@link bigIntToBytes}.
 *
 * @see https://en.wikipedia.org/wiki/Two%27s_complement
 * @param value - The number to convert to bytes.
 * @param byteLength - The length of the resulting `Uint8Array`. If the number
 * is larger than the maximum value that can be represented by the given length,
 * an error is thrown.
 * @returns The bytes as `Uint8Array`.
 */
function signedBigIntToBytes(value, byteLength) {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(typeof byteLength === 'number', 'Byte length must be a number.');
    (0, assert_1.assert)(byteLength > 0, 'Byte length must be greater than 0.');
    (0, assert_1.assert)(bigIntFits(value, byteLength), 'Byte length is too small to represent the given value.');
    // ESLint doesn't like mutating function parameters, so to avoid having to
    // disable the rule, we create a new variable.
    let numberValue = value;
    const bytes = new Uint8Array(byteLength);
    for (let i = 0; i < bytes.length; i++) {
        bytes[i] = Number(BigInt.asUintN(8, numberValue));
        // eslint-disable-next-line no-bitwise
        numberValue >>= BigInt(8);
    }
    return bytes.reverse();
}
exports.signedBigIntToBytes = signedBigIntToBytes;
/**
 * Convert a `number` to a `Uint8Array`.
 *
 * @param value - The number to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 * @throws If the number is not a safe integer.
 */
function numberToBytes(value) {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToBytes` instead.');
    const hexadecimal = value.toString(16);
    return hexToBytes(hexadecimal);
}
exports.numberToBytes = numberToBytes;
/**
 * Convert a `string` to a UTF-8 encoded `Uint8Array`.
 *
 * @param value - The string to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function stringToBytes(value) {
    (0, assert_1.assert)(typeof value === 'string', 'Value must be a string.');
    return new TextEncoder().encode(value);
}
exports.stringToBytes = stringToBytes;
/**
 * Convert a byte-like value to a `Uint8Array`. The value can be a `Uint8Array`,
 * a `bigint`, a `number`, or a `string`.
 *
 * This will attempt to guess the type of the value based on its type and
 * contents. For more control over the conversion, use the more specific
 * conversion functions, such as {@link hexToBytes} or {@link stringToBytes}.
 *
 * If the value is a `string`, and it is prefixed with `0x`, it will be
 * interpreted as a hexadecimal string. Otherwise, it will be interpreted as a
 * UTF-8 string. To convert a hexadecimal string to bytes without interpreting
 * it as a UTF-8 string, use {@link hexToBytes} instead.
 *
 * If the value is a `bigint`, it is assumed to be unsigned. To convert a signed
 * `bigint` to bytes, use {@link signedBigIntToBytes} instead.
 *
 * If the value is a `Uint8Array`, it will be returned as-is.
 *
 * @param value - The value to convert to bytes.
 * @returns The bytes as `Uint8Array`.
 */
function valueToBytes(value) {
    if (typeof value === 'bigint') {
        return bigIntToBytes(value);
    }
    if (typeof value === 'number') {
        return numberToBytes(value);
    }
    if (typeof value === 'string') {
        if (value.startsWith('0x')) {
            return hexToBytes(value);
        }
        return stringToBytes(value);
    }
    if (isBytes(value)) {
        return value;
    }
    throw new TypeError(`Unsupported value type: "${typeof value}".`);
}
exports.valueToBytes = valueToBytes;
/**
 * Concatenate multiple byte-like values into a single `Uint8Array`. The values
 * can be `Uint8Array`, `bigint`, `number`, or `string`. This uses
 * {@link valueToBytes} under the hood to convert each value to bytes. Refer to
 * the documentation of that function for more information.
 *
 * @param values - The values to concatenate.
 * @returns The concatenated bytes as `Uint8Array`.
 */
function concatBytes(values) {
    const normalizedValues = new Array(values.length);
    let byteLength = 0;
    for (let i = 0; i < values.length; i++) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const value = valueToBytes(values[i]);
        normalizedValues[i] = value;
        byteLength += value.length;
    }
    const bytes = new Uint8Array(byteLength);
    for (let i = 0, offset = 0; i < normalizedValues.length; i++) {
        // While we could simply spread the values into an array and use
        // `Uint8Array.from`, that is a lot slower than using `Uint8Array.set`.
        bytes.set(normalizedValues[i], offset);
        offset += normalizedValues[i].length;
    }
    return bytes;
}
exports.concatBytes = concatBytes;
/**
 * Create a {@link DataView} from a {@link Uint8Array}. This is a convenience
 * function that avoids having to create a {@link DataView} manually, which
 * requires passing the `byteOffset` and `byteLength` parameters every time.
 *
 * Not passing the `byteOffset` and `byteLength` parameters can result in
 * unexpected behavior when the {@link Uint8Array} is a view of a larger
 * {@link ArrayBuffer}, e.g., when using {@link Uint8Array.subarray}.
 *
 * This function also supports Node.js {@link Buffer}s.
 *
 * @example
 * ```typescript
 * const bytes = new Uint8Array([1, 2, 3]);
 *
 * // This is equivalent to:
 * // const dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
 * const dataView = createDataView(bytes);
 * ```
 * @param bytes - The bytes to create the {@link DataView} from.
 * @returns The {@link DataView}.
 */
function createDataView(bytes) {
    // To maintain compatibility with Node.js, we need to check if the bytes are
    // a Buffer. If so, we need to slice the buffer to get the underlying
    // ArrayBuffer.
    // eslint-disable-next-line no-restricted-globals
    if (typeof Buffer !== 'undefined' && bytes instanceof Buffer) {
        const buffer = bytes.buffer.slice(bytes.byteOffset, bytes.byteOffset + bytes.byteLength);
        return new DataView(buffer);
    }
    return new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
}
exports.createDataView = createDataView;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\checksum.js", {"./base64":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cchecksum.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChecksumStruct = void 0;
const superstruct_1 = require("superstruct");
const base64_1 = require("./base64");
exports.ChecksumStruct = (0, superstruct_1.size)((0, base64_1.base64)((0, superstruct_1.string)(), { paddingRequired: true }), 44, 44);
//# sourceMappingURL=checksum.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\checksum.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\coercers.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./bytes":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js","./hex":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccoercers.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHex = exports.createBytes = exports.createBigInt = exports.createNumber = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const bytes_1 = require("./bytes");
const hex_1 = require("./hex");
const NumberLikeStruct = (0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.bigint)(), (0, superstruct_1.string)(), hex_1.StrictHexStruct]);
const NumberCoercer = (0, superstruct_1.coerce)((0, superstruct_1.number)(), NumberLikeStruct, Number);
const BigIntCoercer = (0, superstruct_1.coerce)((0, superstruct_1.bigint)(), NumberLikeStruct, BigInt);
const BytesLikeStruct = (0, superstruct_1.union)([hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array)]);
const BytesCoercer = (0, superstruct_1.coerce)((0, superstruct_1.instance)(Uint8Array), (0, superstruct_1.union)([hex_1.StrictHexStruct]), bytes_1.hexToBytes);
const HexCoercer = (0, superstruct_1.coerce)(hex_1.StrictHexStruct, (0, superstruct_1.instance)(Uint8Array), bytes_1.bytesToHex);
/**
 * Create a number from a number-like value.
 *
 * - If the value is a number, it is returned as-is.
 * - If the value is a `bigint`, it is converted to a number.
 * - If the value is a string, it is interpreted as a decimal number.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number.
 *
 * This validates that the value is a number-like value, and that the resulting
 * number is not `NaN` or `Infinity`.
 *
 * @example
 * ```typescript
 * const value = createNumber('0x010203');
 * console.log(value); // 66051
 *
 * const otherValue = createNumber(123n);
 * console.log(otherValue); // 123
 * ```
 * @param value - The value to create the number from.
 * @returns The created number.
 * @throws If the value is not a number-like value, or if the resulting number
 * is `NaN` or `Infinity`.
 */
function createNumber(value) {
    try {
        const result = (0, superstruct_1.create)(value, NumberCoercer);
        (0, assert_1.assert)(Number.isFinite(result), `Expected a number-like value, got "${value}".`);
        return result;
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${value}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createNumber = createNumber;
/**
 * Create a `bigint` from a number-like value.
 *
 * - If the value is a number, it is converted to a `bigint`.
 * - If the value is a `bigint`, it is returned as-is.
 * - If the value is a string, it is interpreted as a decimal number and
 * converted to a `bigint`.
 * - If the value is a hex string (i.e., it starts with "0x"), it is
 * interpreted as a hexadecimal number and converted to a `bigint`.
 *
 * @example
 * ```typescript
 * const value = createBigInt('0x010203');
 * console.log(value); // 16909060n
 *
 * const otherValue = createBigInt(123);
 * console.log(otherValue); // 123n
 * ```
 * @param value - The value to create the bigint from.
 * @returns The created bigint.
 * @throws If the value is not a number-like value.
 */
function createBigInt(value) {
    try {
        // The `BigInt` constructor throws if the value is not a number-like value.
        // There is no need to validate the value manually.
        return (0, superstruct_1.create)(value, BigIntCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a number-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBigInt = createBigInt;
/**
 * Create a byte array from a bytes-like value.
 *
 * - If the value is a byte array, it is returned as-is.
 * - If the value is a hex string (i.e., it starts with "0x"), it is interpreted
 * as a hexadecimal number and converted to a byte array.
 *
 * @example
 * ```typescript
 * const value = createBytes('0x010203');
 * console.log(value); // Uint8Array [ 1, 2, 3 ]
 *
 * const otherValue = createBytes('0x010203');
 * console.log(otherValue); // Uint8Array [ 1, 2, 3 ]
 * ```
 * @param value - The value to create the byte array from.
 * @returns The created byte array.
 * @throws If the value is not a bytes-like value.
 */
function createBytes(value) {
    if (typeof value === 'string' && value.toLowerCase() === '0x') {
        return new Uint8Array();
    }
    try {
        return (0, superstruct_1.create)(value, BytesCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createBytes = createBytes;
/**
 * Create a hexadecimal string from a bytes-like value.
 *
 * - If the value is a hex string (i.e., it starts with "0x"), it is returned
 * as-is.
 * - If the value is a `Uint8Array`, it is converted to a hex string.
 *
 * @example
 * ```typescript
 * const value = createHex(new Uint8Array([1, 2, 3]));
 * console.log(value); // '0x010203'
 *
 * const otherValue = createHex('0x010203');
 * console.log(otherValue); // '0x010203'
 * ```
 * @param value - The value to create the hex string from.
 * @returns The created hex string.
 * @throws If the value is not a bytes-like value.
 */
function createHex(value) {
    if ((value instanceof Uint8Array && value.length === 0) ||
        (typeof value === 'string' && value.toLowerCase() === '0x')) {
        return '0x';
    }
    try {
        return (0, superstruct_1.create)(value, HexCoercer);
    }
    catch (error) {
        if (error instanceof superstruct_1.StructError) {
            throw new Error(`Expected a bytes-like value, got "${String(error.value)}".`);
        }
        /* istanbul ignore next */
        throw error;
    }
}
exports.createHex = createHex;
//# sourceMappingURL=coercers.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\coercers.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\collections.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ccollections.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FrozenMap_map, _FrozenSet_set;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FrozenSet = exports.FrozenMap = void 0;
/**
 * A {@link ReadonlyMap} that cannot be modified after instantiation.
 * The implementation uses an inner map hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this map.
 */
class FrozenMap {
    constructor(entries) {
        _FrozenMap_map.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenMap_map, new Map(entries), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").size;
    }
    [(_FrozenMap_map = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner map.
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").forEach((value, key, _map) => callbackfn.call(thisArg, value, key, this));
    }
    get(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").get(key);
    }
    has(key) {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").has(key);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenMap_map, "f").values();
    }
    toString() {
        return `FrozenMap(${this.size}) {${this.size > 0
            ? ` ${[...this.entries()]
                .map(([key, value]) => `${String(key)} => ${String(value)}`)
                .join(', ')} `
            : ''}}`;
    }
}
exports.FrozenMap = FrozenMap;
/**
 * A {@link ReadonlySet} that cannot be modified after instantiation.
 * The implementation uses an inner set hidden via a private field, and the
 * immutability guarantee relies on it being impossible to get a reference
 * to this set.
 */
class FrozenSet {
    constructor(values) {
        _FrozenSet_set.set(this, void 0);
        __classPrivateFieldSet(this, _FrozenSet_set, new Set(values), "f");
        Object.freeze(this);
    }
    get size() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").size;
    }
    [(_FrozenSet_set = new WeakMap(), Symbol.iterator)]() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f")[Symbol.iterator]();
    }
    entries() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").entries();
    }
    forEach(callbackfn, thisArg) {
        // We have to wrap the specified callback in order to prevent it from
        // receiving a reference to the inner set.
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").forEach((value, value2, _set) => callbackfn.call(thisArg, value, value2, this));
    }
    has(value) {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").has(value);
    }
    keys() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").keys();
    }
    values() {
        return __classPrivateFieldGet(this, _FrozenSet_set, "f").values();
    }
    toString() {
        return `FrozenSet(${this.size}) {${this.size > 0
            ? ` ${[...this.values()].map((member) => String(member)).join(', ')} `
            : ''}}`;
    }
}
exports.FrozenSet = FrozenSet;
Object.freeze(FrozenMap);
Object.freeze(FrozenMap.prototype);
Object.freeze(FrozenSet);
Object.freeze(FrozenSet.prototype);
//# sourceMappingURL=collections.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\collections.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Chex.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remove0x = exports.add0x = exports.assertIsStrictHexString = exports.assertIsHexString = exports.isStrictHexString = exports.isHexString = exports.StrictHexStruct = exports.HexStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
exports.HexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^(?:0x)?[0-9a-f]+$/iu);
exports.StrictHexStruct = (0, superstruct_1.pattern)((0, superstruct_1.string)(), /^0x[0-9a-f]+$/iu);
/**
 * Check if a string is a valid hex string.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isHexString(value) {
    return (0, superstruct_1.is)(value, exports.HexStruct);
}
exports.isHexString = isHexString;
/**
 * Strictly check if a string is a valid hex string. A valid hex string must
 * start with the "0x"-prefix.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid hex string.
 */
function isStrictHexString(value) {
    return (0, superstruct_1.is)(value, exports.StrictHexStruct);
}
exports.isStrictHexString = isStrictHexString;
/**
 * Assert that a value is a valid hex string.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsHexString(value) {
    (0, assert_1.assert)(isHexString(value), 'Value must be a hexadecimal string.');
}
exports.assertIsHexString = assertIsHexString;
/**
 * Assert that a value is a valid hex string. A valid hex string must start with
 * the "0x"-prefix.
 *
 * @param value - The value to check.
 * @throws If the value is not a valid hex string.
 */
function assertIsStrictHexString(value) {
    (0, assert_1.assert)(isStrictHexString(value), 'Value must be a hexadecimal string, starting with "0x".');
}
exports.assertIsStrictHexString = assertIsStrictHexString;
/**
 * Add the `0x`-prefix to a hexadecimal string. If the string already has the
 * prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to add the prefix to.
 * @returns The prefixed hexadecimal string.
 */
function add0x(hexadecimal) {
    if (hexadecimal.startsWith('0x')) {
        return hexadecimal;
    }
    if (hexadecimal.startsWith('0X')) {
        return `0x${hexadecimal.substring(2)}`;
    }
    return `0x${hexadecimal}`;
}
exports.add0x = add0x;
/**
 * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have
 * the prefix, it is returned as-is.
 *
 * @param hexadecimal - The hexadecimal string to remove the prefix from.
 * @returns The un-prefixed hexadecimal string.
 */
function remove0x(hexadecimal) {
    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {
        return hexadecimal.substring(2);
    }
    return hexadecimal;
}
exports.remove0x = remove0x;
//# sourceMappingURL=hex.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\index.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./base64":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\base64.js","./bytes":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\bytes.js","./checksum":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\checksum.js","./coercers":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\coercers.js","./collections":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\collections.js","./hex":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js","./json":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\json.js","./logging":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\logging.js","./misc":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js","./number":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\number.js","./opaque":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\opaque.js","./time":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\time.js","./versions":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\versions.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./assert"), exports);
__exportStar(require("./base64"), exports);
__exportStar(require("./bytes"), exports);
__exportStar(require("./checksum"), exports);
__exportStar(require("./coercers"), exports);
__exportStar(require("./collections"), exports);
__exportStar(require("./hex"), exports);
__exportStar(require("./json"), exports);
__exportStar(require("./logging"), exports);
__exportStar(require("./misc"), exports);
__exportStar(require("./number"), exports);
__exportStar(require("./opaque"), exports);
__exportStar(require("./time"), exports);
__exportStar(require("./versions"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\json.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./misc":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cjson.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateJsonAndGetSize = exports.getJsonRpcIdValidator = exports.assertIsJsonRpcError = exports.isJsonRpcError = exports.assertIsJsonRpcFailure = exports.isJsonRpcFailure = exports.assertIsJsonRpcSuccess = exports.isJsonRpcSuccess = exports.assertIsJsonRpcResponse = exports.isJsonRpcResponse = exports.assertIsPendingJsonRpcResponse = exports.isPendingJsonRpcResponse = exports.JsonRpcResponseStruct = exports.JsonRpcFailureStruct = exports.JsonRpcSuccessStruct = exports.PendingJsonRpcResponseStruct = exports.assertIsJsonRpcRequest = exports.isJsonRpcRequest = exports.assertIsJsonRpcNotification = exports.isJsonRpcNotification = exports.JsonRpcNotificationStruct = exports.JsonRpcRequestStruct = exports.JsonRpcParamsStruct = exports.JsonRpcErrorStruct = exports.JsonRpcIdStruct = exports.JsonRpcVersionStruct = exports.jsonrpc2 = exports.isValidJson = exports.JsonStruct = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
const misc_1 = require("./misc");
exports.JsonStruct = (0, superstruct_1.define)('Json', (value) => {
    const [isValid] = validateJsonAndGetSize(value, true);
    if (!isValid) {
        return 'Expected a valid JSON-serializable value';
    }
    return true;
});
/**
 * Check if the given value is a valid {@link Json} value, i.e., a value that is
 * serializable to JSON.
 *
 * @param value - The value to check.
 * @returns Whether the value is a valid {@link Json} value.
 */
function isValidJson(value) {
    return (0, superstruct_1.is)(value, exports.JsonStruct);
}
exports.isValidJson = isValidJson;
/**
 * The string '2.0'.
 */
exports.jsonrpc2 = '2.0';
exports.JsonRpcVersionStruct = (0, superstruct_1.literal)(exports.jsonrpc2);
exports.JsonRpcIdStruct = (0, superstruct_1.nullable)((0, superstruct_1.union)([(0, superstruct_1.number)(), (0, superstruct_1.string)()]));
exports.JsonRpcErrorStruct = (0, superstruct_1.object)({
    code: (0, superstruct_1.integer)(),
    message: (0, superstruct_1.string)(),
    data: (0, superstruct_1.optional)(exports.JsonStruct),
    stack: (0, superstruct_1.optional)((0, superstruct_1.string)()),
});
exports.JsonRpcParamsStruct = (0, superstruct_1.optional)((0, superstruct_1.union)([(0, superstruct_1.record)((0, superstruct_1.string)(), exports.JsonStruct), (0, superstruct_1.array)(exports.JsonStruct)]));
exports.JsonRpcRequestStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    method: (0, superstruct_1.string)(),
    params: exports.JsonRpcParamsStruct,
});
exports.JsonRpcNotificationStruct = (0, superstruct_1.omit)(exports.JsonRpcRequestStruct, ['id']);
/**
 * Check if the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcNotification}
 * object.
 */
function isJsonRpcNotification(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcNotificationStruct);
}
exports.isJsonRpcNotification = isJsonRpcNotification;
/**
 * Assert that the given value is a valid {@link JsonRpcNotification} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcNotification} object.
 */
function assertIsJsonRpcNotification(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);
}
exports.assertIsJsonRpcNotification = assertIsJsonRpcNotification;
/**
 * Check if the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcRequest} object.
 */
function isJsonRpcRequest(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcRequestStruct);
}
exports.isJsonRpcRequest = isJsonRpcRequest;
/**
 * Assert that the given value is a valid {@link JsonRpcRequest} object.
 *
 * @param value - The JSON-RPC request or notification to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcRequest} object.
 */
function assertIsJsonRpcRequest(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);
}
exports.assertIsJsonRpcRequest = assertIsJsonRpcRequest;
exports.PendingJsonRpcResponseStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: (0, superstruct_1.optional)((0, superstruct_1.unknown)()),
    error: (0, superstruct_1.optional)(exports.JsonRpcErrorStruct),
});
exports.JsonRpcSuccessStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    result: exports.JsonStruct,
});
exports.JsonRpcFailureStruct = (0, superstruct_1.object)({
    id: exports.JsonRpcIdStruct,
    jsonrpc: exports.JsonRpcVersionStruct,
    error: exports.JsonRpcErrorStruct,
});
exports.JsonRpcResponseStruct = (0, superstruct_1.union)([
    exports.JsonRpcSuccessStruct,
    exports.JsonRpcFailureStruct,
]);
/**
 * Type guard to check whether specified JSON-RPC response is a
 * {@link PendingJsonRpcResponse}.
 *
 * @param response - The JSON-RPC response to check.
 * @returns Whether the specified JSON-RPC response is pending.
 */
function isPendingJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.PendingJsonRpcResponseStruct);
}
exports.isPendingJsonRpcResponse = isPendingJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.
 *
 * @param response - The JSON-RPC response to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link PendingJsonRpcResponse}
 * object.
 */
function assertIsPendingJsonRpcResponse(response, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(response, exports.PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);
}
exports.assertIsPendingJsonRpcResponse = assertIsPendingJsonRpcResponse;
/**
 * Type guard to check if a value is a {@link JsonRpcResponse}.
 *
 * @param response - The object to check.
 * @returns Whether the object is a JsonRpcResponse.
 */
function isJsonRpcResponse(response) {
    return (0, superstruct_1.is)(response, exports.JsonRpcResponseStruct);
}
exports.isJsonRpcResponse = isJsonRpcResponse;
/**
 * Assert that the given value is a valid {@link JsonRpcResponse} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcResponse} object.
 */
function assertIsJsonRpcResponse(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);
}
exports.assertIsJsonRpcResponse = assertIsJsonRpcResponse;
/**
 * Check if the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.
 */
function isJsonRpcSuccess(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcSuccessStruct);
}
exports.isJsonRpcSuccess = isJsonRpcSuccess;
/**
 * Assert that the given value is a valid {@link JsonRpcSuccess} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcSuccess} object.
 */
function assertIsJsonRpcSuccess(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);
}
exports.assertIsJsonRpcSuccess = assertIsJsonRpcSuccess;
/**
 * Check if the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcFailure} object.
 */
function isJsonRpcFailure(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcFailureStruct);
}
exports.isJsonRpcFailure = isJsonRpcFailure;
/**
 * Assert that the given value is a valid {@link JsonRpcFailure} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcFailure} object.
 */
function assertIsJsonRpcFailure(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);
}
exports.assertIsJsonRpcFailure = assertIsJsonRpcFailure;
/**
 * Check if the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @returns Whether the given value is a valid {@link JsonRpcError} object.
 */
function isJsonRpcError(value) {
    return (0, superstruct_1.is)(value, exports.JsonRpcErrorStruct);
}
exports.isJsonRpcError = isJsonRpcError;
/**
 * Assert that the given value is a valid {@link JsonRpcError} object.
 *
 * @param value - The value to check.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the given value is not a valid {@link JsonRpcError} object.
 */
function assertIsJsonRpcError(value, 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper) {
    (0, assert_1.assertStruct)(value, exports.JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);
}
exports.assertIsJsonRpcError = assertIsJsonRpcError;
/**
 * Gets a function for validating JSON-RPC request / response `id` values.
 *
 * By manipulating the options of this factory, you can control the behavior
 * of the resulting validator for some edge cases. This is useful because e.g.
 * `null` should sometimes but not always be permitted.
 *
 * Note that the empty string (`''`) is always permitted by the JSON-RPC
 * specification, but that kind of sucks and you may want to forbid it in some
 * instances anyway.
 *
 * For more details, see the
 * [JSON-RPC Specification](https://www.jsonrpc.org/specification).
 *
 * @param options - An options object.
 * @param options.permitEmptyString - Whether the empty string (i.e. `''`)
 * should be treated as a valid ID. Default: `true`
 * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)
 * should be treated as valid IDs. Default: `false`
 * @param options.permitNull - Whether `null` should be treated as a valid ID.
 * Default: `true`
 * @returns The JSON-RPC ID validator function.
 */
function getJsonRpcIdValidator(options) {
    const { permitEmptyString, permitFractions, permitNull } = Object.assign({ permitEmptyString: true, permitFractions: false, permitNull: true }, options);
    /**
     * Type guard for {@link JsonRpcId}.
     *
     * @param id - The JSON-RPC ID value to check.
     * @returns Whether the given ID is valid per the options given to the
     * factory.
     */
    const isValidJsonRpcId = (id) => {
        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||
            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||
            (permitNull && id === null));
    };
    return isValidJsonRpcId;
}
exports.getJsonRpcIdValidator = getJsonRpcIdValidator;
/**
 * Checks whether a value is JSON serializable and counts the total number
 * of bytes needed to store the serialized version of the value.
 *
 * @param jsObject - Potential JSON serializable object.
 * @param skipSizingProcess - Skip JSON size calculation (default: false).
 * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
 * the value was serializable and a number of bytes that it will use when serialized to JSON.
 */
function validateJsonAndGetSize(jsObject, skipSizingProcess = false) {
    const seenObjects = new Set();
    /**
     * Checks whether a value is JSON serializable and counts the total number
     * of bytes needed to store the serialized version of the value.
     *
     * This function assumes the encoding of the JSON is done in UTF-8.
     *
     * @param value - Potential JSON serializable value.
     * @param skipSizing - Skip JSON size calculation (default: false).
     * @returns Tuple [isValid, plainTextSizeInBytes] containing a boolean that signals whether
     * the value was serializable and a number of bytes that it will use when serialized to JSON.
     */
    function getJsonSerializableInfo(value, skipSizing) {
        if (value === undefined) {
            return [false, 0];
        }
        else if (value === null) {
            // Return already specified constant size for null (special object)
            return [true, skipSizing ? 0 : misc_1.JsonSize.Null];
        }
        // Check and calculate sizes for basic (and some special) types
        const typeOfValue = typeof value;
        try {
            if (typeOfValue === 'function') {
                return [false, 0];
            }
            else if (typeOfValue === 'string' || value instanceof String) {
                return [
                    true,
                    skipSizing
                        ? 0
                        : (0, misc_1.calculateStringSize)(value) + misc_1.JsonSize.Quote * 2,
                ];
            }
            else if (typeOfValue === 'boolean' || value instanceof Boolean) {
                if (skipSizing) {
                    return [true, 0];
                }
                // eslint-disable-next-line eqeqeq
                return [true, value == true ? misc_1.JsonSize.True : misc_1.JsonSize.False];
            }
            else if (typeOfValue === 'number' || value instanceof Number) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [true, (0, misc_1.calculateNumberSize)(value)];
            }
            else if (value instanceof Date) {
                if (skipSizing) {
                    return [true, 0];
                }
                return [
                    true,
                    // Note: Invalid dates will serialize to null
                    isNaN(value.getDate())
                        ? misc_1.JsonSize.Null
                        : misc_1.JsonSize.Date + misc_1.JsonSize.Quote * 2,
                ];
            }
        }
        catch (_) {
            return [false, 0];
        }
        // If object is not plain and cannot be serialized properly,
        // stop here and return false for serialization
        if (!(0, misc_1.isPlainObject)(value) && !Array.isArray(value)) {
            return [false, 0];
        }
        // Circular object detection (handling)
        // Check if the same object already exists
        if (seenObjects.has(value)) {
            return [false, 0];
        }
        // Add new object to the seen objects set
        // Only the plain objects should be added (Primitive types are skipped)
        seenObjects.add(value);
        // Continue object decomposition
        try {
            return [
                true,
                Object.entries(value).reduce((sum, [key, nestedValue], idx, arr) => {
                    // Recursively process next nested object or primitive type
                    // eslint-disable-next-line prefer-const
                    let [valid, size] = getJsonSerializableInfo(nestedValue, skipSizing);
                    if (!valid) {
                        throw new Error('JSON validation did not pass. Validation process stopped.');
                    }
                    // Circular object detection
                    // Once a child node is visited and processed remove it from the set.
                    // This will prevent false positives with the same adjacent objects.
                    seenObjects.delete(value);
                    if (skipSizing) {
                        return 0;
                    }
                    // Objects will have be serialized with "key": value,
                    // therefore we include the key in the calculation here
                    const keySize = Array.isArray(value)
                        ? 0
                        : key.length + misc_1.JsonSize.Comma + misc_1.JsonSize.Colon * 2;
                    const separator = idx < arr.length - 1 ? misc_1.JsonSize.Comma : 0;
                    return sum + keySize + size + separator;
                }, 
                // Starts at 2 because the serialized JSON string data (plain text)
                // will minimally contain {}/[]
                skipSizing ? 0 : misc_1.JsonSize.Wrapper * 2),
            ];
        }
        catch (_) {
            return [false, 0];
        }
    }
    return getJsonSerializableInfo(jsObject, skipSizingProcess);
}
exports.validateJsonAndGetSize = validateJsonAndGetSize;
//# sourceMappingURL=json.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\json.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\logging.js", {"debug":"F:\\metamask-extension\\node_modules\\debug\\src\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Clogging.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.createProjectLogger = void 0;
const debug_1 = __importDefault(require("debug"));
const globalLogger = (0, debug_1.default)('metamask');
/**
 * Creates a logger via the `debug` library whose log messages will be tagged
 * using the name of your project. By default, such messages will be
 * suppressed, but you can reveal them by setting the `DEBUG` environment
 * variable to `metamask:<projectName>`. You can also set this variable to
 * `metamask:*` if you want to see log messages from all MetaMask projects that
 * are also using this function to create their loggers.
 *
 * @param projectName - The name of your project. This should be the name of
 * your NPM package if you're developing one.
 * @returns An instance of `debug`.
 */
function createProjectLogger(projectName) {
    return globalLogger.extend(projectName);
}
exports.createProjectLogger = createProjectLogger;
/**
 * Creates a logger via the `debug` library which is derived from the logger for
 * the whole project whose log messages will be tagged using the name of your
 * module. By default, such messages will be suppressed, but you can reveal them
 * by setting the `DEBUG` environment variable to
 * `metamask:<projectName>:<moduleName>`. You can also set this variable to
 * `metamask:<projectName>:*` if you want to see log messages from the project,
 * or `metamask:*` if you want to see log messages from all MetaMask projects.
 *
 * @param projectLogger - The logger created via {@link createProjectLogger}.
 * @param moduleName - The name of your module. You could use the name of the
 * file where you're using this logger or some other name.
 * @returns An instance of `debug`.
 */
function createModuleLogger(projectLogger, moduleName) {
    return projectLogger.extend(moduleName);
}
exports.createModuleLogger = createModuleLogger;
//# sourceMappingURL=logging.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\logging.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cmisc.js
      return function (require, module, exports) {
"use strict";
//
// Types
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateNumberSize = exports.calculateStringSize = exports.isASCII = exports.isPlainObject = exports.ESCAPE_CHARACTERS_REGEXP = exports.JsonSize = exports.hasProperty = exports.isObject = exports.isNullOrUndefined = exports.isNonEmptyArray = void 0;
//
// Type Guards
//
/**
 * A {@link NonEmptyArray} type guard.
 *
 * @template Element - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * Type guard for "nullishness".
 *
 * @param value - Any value.
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */
function isNullOrUndefined(value) {
    return value === null || value === undefined;
}
exports.isNullOrUndefined = isNullOrUndefined;
/**
 * A type guard for {@link RuntimeObject}.
 *
 * @param value - The value to check.
 * @returns Whether the specified value has a runtime type of `object` and is
 * neither `null` nor an `Array`.
 */
function isObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isObject = isObject;
//
// Other utility functions
//
/**
 * A type guard for ensuring an object has a property.
 *
 * @param objectToCheck - The object to check.
 * @param name - The property name to check for.
 * @returns Whether the specified object has an own property with the specified
 * name, regardless of whether it is enumerable or not.
 */
const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);
exports.hasProperty = hasProperty;
/**
 * Predefined sizes (in Bytes) of specific parts of JSON structure.
 */
var JsonSize;
(function (JsonSize) {
    JsonSize[JsonSize["Null"] = 4] = "Null";
    JsonSize[JsonSize["Comma"] = 1] = "Comma";
    JsonSize[JsonSize["Wrapper"] = 1] = "Wrapper";
    JsonSize[JsonSize["True"] = 4] = "True";
    JsonSize[JsonSize["False"] = 5] = "False";
    JsonSize[JsonSize["Quote"] = 1] = "Quote";
    JsonSize[JsonSize["Colon"] = 1] = "Colon";
    // eslint-disable-next-line @typescript-eslint/no-shadow
    JsonSize[JsonSize["Date"] = 24] = "Date";
})(JsonSize = exports.JsonSize || (exports.JsonSize = {}));
/**
 * Regular expression with pattern matching for (special) escaped characters.
 */
exports.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
/**
 * Check if the value is plain object.
 *
 * @param value - Value to be checked.
 * @returns True if an object is the plain JavaScript object,
 * false if the object is not plain (e.g. function).
 */
function isPlainObject(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    try {
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
    catch (_) {
        return false;
    }
}
exports.isPlainObject = isPlainObject;
/**
 * Check if character is ASCII.
 *
 * @param character - Character.
 * @returns True if a character code is ASCII, false if not.
 */
function isASCII(character) {
    return character.charCodeAt(0) <= 127;
}
exports.isASCII = isASCII;
/**
 * Calculate string size.
 *
 * @param value - String value to calculate size.
 * @returns Number of bytes used to store whole string value.
 */
function calculateStringSize(value) {
    var _a;
    const size = value.split('').reduce((total, character) => {
        if (isASCII(character)) {
            return total + 1;
        }
        return total + 2;
    }, 0);
    // Also detect characters that need backslash escape
    return size + ((_a = value.match(exports.ESCAPE_CHARACTERS_REGEXP)) !== null && _a !== void 0 ? _a : []).length;
}
exports.calculateStringSize = calculateStringSize;
/**
 * Calculate size of a number ofter JSON serialization.
 *
 * @param value - Number value to calculate size.
 * @returns Number of bytes used to store whole number in JSON.
 */
function calculateNumberSize(value) {
    return value.toString().length;
}
exports.calculateNumberSize = calculateNumberSize;
//# sourceMappingURL=misc.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\misc.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\number.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","./hex":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\hex.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cnumber.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hexToBigInt = exports.hexToNumber = exports.bigIntToHex = exports.numberToHex = void 0;
const assert_1 = require("./assert");
const hex_1 = require("./hex");
/**
 * Convert a number to a hexadecimal string. This verifies that the number is a
 * non-negative safe integer.
 *
 * To convert a `bigint` to a hexadecimal string instead, use
 * {@link bigIntToHex}.
 *
 * @example
 * ```typescript
 * numberToHex(0); // '0x0'
 * numberToHex(1); // '0x1'
 * numberToHex(16); // '0x10'
 * ```
 * @param value - The number to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the number is not a non-negative safe integer.
 */
const numberToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'number', 'Value must be a number.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative number.');
    (0, assert_1.assert)(Number.isSafeInteger(value), 'Value is not a safe integer. Use `bigIntToHex` instead.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.numberToHex = numberToHex;
/**
 * Convert a `bigint` to a hexadecimal string. This verifies that the `bigint`
 * is a non-negative integer.
 *
 * To convert a number to a hexadecimal string instead, use {@link numberToHex}.
 *
 * @example
 * ```typescript
 * bigIntToHex(0n); // '0x0'
 * bigIntToHex(1n); // '0x1'
 * bigIntToHex(16n); // '0x10'
 * ```
 * @param value - The `bigint` to convert to a hexadecimal string.
 * @returns The hexadecimal string, with the "0x"-prefix.
 * @throws If the `bigint` is not a non-negative integer.
 */
const bigIntToHex = (value) => {
    (0, assert_1.assert)(typeof value === 'bigint', 'Value must be a bigint.');
    (0, assert_1.assert)(value >= 0, 'Value must be a non-negative bigint.');
    return (0, hex_1.add0x)(value.toString(16));
};
exports.bigIntToHex = bigIntToHex;
/**
 * Convert a hexadecimal string to a number. This verifies that the string is a
 * valid hex string, and that the resulting number is a safe integer. Both
 * "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a `bigint` instead, use
 * {@link hexToBigInt}.
 *
 * @example
 * ```typescript
 * hexToNumber('0x0'); // 0
 * hexToNumber('0x1'); // 1
 * hexToNumber('0x10'); // 16
 * ```
 * @param value - The hexadecimal string to convert to a number.
 * @returns The number.
 * @throws If the value is not a valid hexadecimal string, or if the resulting
 * number is not a safe integer.
 */
const hexToNumber = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // `parseInt` accepts values without the "0x"-prefix, whereas `Number` does
    // not. Using this is slightly faster than `Number(add0x(value))`.
    const numberValue = parseInt(value, 16);
    (0, assert_1.assert)(Number.isSafeInteger(numberValue), 'Value is not a safe integer. Use `hexToBigInt` instead.');
    return numberValue;
};
exports.hexToNumber = hexToNumber;
/**
 * Convert a hexadecimal string to a `bigint`. This verifies that the string is
 * a valid hex string. Both "0x"-prefixed and unprefixed strings are supported.
 *
 * To convert a hexadecimal string to a number instead, use {@link hexToNumber}.
 *
 * @example
 * ```typescript
 * hexToBigInt('0x0'); // 0n
 * hexToBigInt('0x1'); // 1n
 * hexToBigInt('0x10'); // 16n
 * ```
 * @param value - The hexadecimal string to convert to a `bigint`.
 * @returns The `bigint`.
 * @throws If the value is not a valid hexadecimal string.
 */
const hexToBigInt = (value) => {
    (0, hex_1.assertIsHexString)(value);
    // The `BigInt` constructor requires the "0x"-prefix to parse a hex string.
    return BigInt((0, hex_1.add0x)(value));
};
exports.hexToBigInt = hexToBigInt;
//# sourceMappingURL=number.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\number.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\opaque.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Copaque.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=opaque.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\opaque.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\time.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Ctime.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeSince = exports.inMilliseconds = exports.Duration = void 0;
/**
 * Common duration constants, in milliseconds.
 */
var Duration;
(function (Duration) {
    /**
     * A millisecond.
     */
    Duration[Duration["Millisecond"] = 1] = "Millisecond";
    /**
     * A second, in milliseconds.
     */
    Duration[Duration["Second"] = 1000] = "Second";
    /**
     * A minute, in milliseconds.
     */
    Duration[Duration["Minute"] = 60000] = "Minute";
    /**
     * An hour, in milliseconds.
     */
    Duration[Duration["Hour"] = 3600000] = "Hour";
    /**
     * A day, in milliseconds.
     */
    Duration[Duration["Day"] = 86400000] = "Day";
    /**
     * A week, in milliseconds.
     */
    Duration[Duration["Week"] = 604800000] = "Week";
    /**
     * A year, in milliseconds.
     */
    Duration[Duration["Year"] = 31536000000] = "Year";
})(Duration = exports.Duration || (exports.Duration = {}));
const isNonNegativeInteger = (number) => Number.isInteger(number) && number >= 0;
const assertIsNonNegativeInteger = (number, name) => {
    if (!isNonNegativeInteger(number)) {
        throw new Error(`"${name}" must be a non-negative integer. Received: "${number}".`);
    }
};
/**
 * Calculates the millisecond value of the specified number of units of time.
 *
 * @param count - The number of units of time.
 * @param duration - The unit of time to count.
 * @returns The count multiplied by the specified duration.
 */
function inMilliseconds(count, duration) {
    assertIsNonNegativeInteger(count, 'count');
    return count * duration;
}
exports.inMilliseconds = inMilliseconds;
/**
 * Gets the milliseconds since a particular Unix epoch timestamp.
 *
 * @param timestamp - A Unix millisecond timestamp.
 * @returns The number of milliseconds elapsed since the specified timestamp.
 */
function timeSince(timestamp) {
    assertIsNonNegativeInteger(timestamp, 'timestamp');
    return Date.now() - timestamp;
}
exports.timeSince = timeSince;
//# sourceMappingURL=time.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\time.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\versions.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\assert.js","semver":"F:\\metamask-extension\\node_modules\\semver\\index.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cversions.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.satisfiesVersionRange = exports.gtRange = exports.gtVersion = exports.assertIsSemVerRange = exports.assertIsSemVerVersion = exports.isValidSemVerRange = exports.isValidSemVerVersion = exports.VersionRangeStruct = exports.VersionStruct = void 0;
const semver_1 = require("semver");
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * A struct for validating a version string.
 */
exports.VersionStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version', (value) => {
    if ((0, semver_1.valid)(value) === null) {
        return `Expected SemVer version, got "${value}"`;
    }
    return true;
});
exports.VersionRangeStruct = (0, superstruct_1.refine)((0, superstruct_1.string)(), 'Version range', (value) => {
    if ((0, semver_1.validRange)(value) === null) {
        return `Expected SemVer range, got "${value}"`;
    }
    return true;
});
/**
 * Checks whether a SemVer version is valid.
 *
 * @param version - A potential version.
 * @returns `true` if the version is valid, and `false` otherwise.
 */
function isValidSemVerVersion(version) {
    return (0, superstruct_1.is)(version, exports.VersionStruct);
}
exports.isValidSemVerVersion = isValidSemVerVersion;
/**
 * Checks whether a SemVer version range is valid.
 *
 * @param versionRange - A potential version range.
 * @returns `true` if the version range is valid, and `false` otherwise.
 */
function isValidSemVerRange(versionRange) {
    return (0, superstruct_1.is)(versionRange, exports.VersionRangeStruct);
}
exports.isValidSemVerRange = isValidSemVerRange;
/**
 * Asserts that a value is a valid concrete SemVer version.
 *
 * @param version - A potential SemVer concrete version.
 */
function assertIsSemVerVersion(version) {
    (0, assert_1.assertStruct)(version, exports.VersionStruct);
}
exports.assertIsSemVerVersion = assertIsSemVerVersion;
/**
 * Asserts that a value is a valid SemVer range.
 *
 * @param range - A potential SemVer range.
 */
function assertIsSemVerRange(range) {
    (0, assert_1.assertStruct)(range, exports.VersionRangeStruct);
}
exports.assertIsSemVerRange = assertIsSemVerRange;
/**
 * Checks whether a SemVer version is greater than another.
 *
 * @param version1 - The left-hand version.
 * @param version2 - The right-hand version.
 * @returns `version1 > version2`.
 */
function gtVersion(version1, version2) {
    return (0, semver_1.gt)(version1, version2);
}
exports.gtVersion = gtVersion;
/**
 * Checks whether a SemVer version is greater than all possibilities in a range.
 *
 * @param version - A SemvVer version.
 * @param range - The range to check against.
 * @returns `version > range`.
 */
function gtRange(version, range) {
    return (0, semver_1.gtr)(version, range);
}
exports.gtRange = gtRange;
/**
 * Returns whether a SemVer version satisfies a SemVer range.
 *
 * @param version - The SemVer version to check.
 * @param versionRange - The SemVer version range to check against.
 * @returns Whether the version satisfied the version range.
 */
function satisfiesVersionRange(version, versionRange) {
    return (0, semver_1.satisfies)(version, versionRange, {
        includePrerelease: true,
    });
}
exports.satisfiesVersionRange = satisfiesVersionRange;
//# sourceMappingURL=versions.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>@metamask/utils",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\@metamask\\utils\\dist\\versions.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-middleware%5Cnode_modules%5Cpify%5Cindex.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
  }
}, {package:"@metamask/eth-json-rpc-middleware>pify",file:"node_modules\\@metamask\\eth-json-rpc-middleware\\node_modules\\pify\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\index.js", {"./provider-from-engine":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js","./provider-from-middleware":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-middleware.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./provider-from-engine"), exports);
__exportStar(require("./provider-from-middleware"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js", {"./safe-event-emitter-provider":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\safe-event-emitter-provider.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Cprovider-from-engine.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromEngine = void 0;
const safe_event_emitter_provider_1 = require("./safe-event-emitter-provider");
/**
 * Construct an Ethereum provider from the given JSON-RPC engine.
 *
 * @param engine - The JSON-RPC engine to construct a provider from.
 * @returns An Ethereum provider.
 */
function providerFromEngine(engine) {
    return new safe_event_emitter_provider_1.SafeEventEmitterProvider({ engine });
}
exports.providerFromEngine = providerFromEngine;
//# sourceMappingURL=provider-from-engine.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-middleware.js", {"./provider-from-engine":"F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-engine.js","json-rpc-engine":"F:\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Cprovider-from-middleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const provider_from_engine_1 = require("./provider-from-engine");
/**
 * Construct an Ethereum provider from the given middleware.
 *
 * @param middleware - The middleware to construct a provider from.
 * @returns An Ethereum provider.
 */
function providerFromMiddleware(middleware) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push(middleware);
    const provider = (0, provider_from_engine_1.providerFromEngine)(engine);
    return provider;
}
exports.providerFromMiddleware = providerFromMiddleware;
//# sourceMappingURL=provider-from-middleware.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\provider-from-middleware.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-provider\\dist\\safe-event-emitter-provider.js", {"@metamask/safe-event-emitter":"F:\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-json-rpc-provider%5Cdist%5Csafe-event-emitter-provider.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _SafeEventEmitterProvider_engine;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeEventEmitterProvider = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
/**
 * An Ethereum provider.
 *
 * This provider loosely follows conventions that pre-date EIP-1193.
 * It is not compliant with any Ethereum provider standard.
 */
class SafeEventEmitterProvider extends safe_event_emitter_1.default {
    /**
     * Construct a SafeEventEmitterProvider from a JSON-RPC engine.
     *
     * @param options - Options.
     * @param options.engine - The JSON-RPC engine used to process requests.
     */
    constructor({ engine }) {
        super();
        _SafeEventEmitterProvider_engine.set(this, void 0);
        /**
         * Send a provider request asynchronously.
         *
         * @param req - The request to send.
         * @param callback - A function that is called upon the success or failure of the request.
         */
        this.sendAsync = (req, callback) => {
            __classPrivateFieldGet(this, _SafeEventEmitterProvider_engine, "f").handle(req, callback);
        };
        /**
         * Send a provider request asynchronously.
         *
         * This method serves the same purpose as `sendAsync`. It only exists for
         * legacy reasons.
         *
         * @deprecated Use `sendAsync` instead.
         * @param req - The request to send.
         * @param callback - A function that is called upon the success or failure of the request.
         */
        this.send = (req, callback) => {
            if (typeof callback !== 'function') {
                throw new Error('Must provide callback to "send" method.');
            }
            __classPrivateFieldGet(this, _SafeEventEmitterProvider_engine, "f").handle(req, callback);
        };
        __classPrivateFieldSet(this, _SafeEventEmitterProvider_engine, engine, "f");
        if (engine.on) {
            engine.on('notification', (message) => {
                this.emit('data', null, message);
            });
        }
    }
}
exports.SafeEventEmitterProvider = SafeEventEmitterProvider;
_SafeEventEmitterProvider_engine = new WeakMap();
//# sourceMappingURL=safe-event-emitter-provider.js.map
      };
    };
  }
  }
}, {package:"@metamask/network-controller>@metamask/eth-json-rpc-provider",file:"node_modules\\@metamask\\eth-json-rpc-provider\\dist\\safe-event-emitter-provider.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\index.js", {"@metamask/browser-passworder":"F:\\metamask-extension\\node_modules\\@metamask\\browser-passworder\\dist\\index.js","@metamask/eth-hd-keyring":"F:\\metamask-extension\\node_modules\\@metamask\\eth-hd-keyring\\index.js","@metamask/eth-sig-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","@metamask/eth-simple-keyring":"F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\index.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","obs-store":"F:\\metamask-extension\\node_modules\\obs-store\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cindex.js
      return function (require, module, exports) {
const encryptor = require('@metamask/browser-passworder');
const HdKeyring = require('@metamask/eth-hd-keyring');
const { normalize: normalizeAddress } = require('@metamask/eth-sig-util');
const SimpleKeyring = require('@metamask/eth-simple-keyring');
// TODO: Stop using `events`, and remove the notice about this from the README
// eslint-disable-next-line import/no-nodejs-modules
const { EventEmitter } = require('events');
const ObservableStore = require('obs-store');

const defaultKeyringBuilders = [
  keyringBuilderFactory(SimpleKeyring),
  keyringBuilderFactory(HdKeyring),
];

const KEYRINGS_TYPE_MAP = {
  HD_KEYRING: 'HD Key Tree',
  SIMPLE_KEYRING: 'Simple Key Pair',
};

/**
 * Strip the hex prefix from an address, if present.
 *
 * @param {string} address - The address that might be hex prefixed.
 * @returns {string} The address without a hex prefix.
 */
function stripHexPrefix(address) {
  if (address.startsWith('0x')) {
    return address.slice(2);
  }
  return address;
}

class KeyringController extends EventEmitter {
  //
  // PUBLIC METHODS
  //

  constructor(opts) {
    super();
    const initState = opts.initState || {};
    this.keyringBuilders = opts.keyringBuilders
      ? defaultKeyringBuilders.concat(opts.keyringBuilders)
      : defaultKeyringBuilders;
    this.store = new ObservableStore(initState);
    this.memStore = new ObservableStore({
      isUnlocked: false,
      keyringTypes: this.keyringBuilders.map(
        (keyringBuilder) => keyringBuilder.type,
      ),
      keyrings: [],
      encryptionKey: null,
    });

    this.encryptor = opts.encryptor || encryptor;
    this.keyrings = [];
    this._unsupportedKeyrings = [];

    // This option allows the controller to cache an exported key
    // for use in decrypting and encrypting data without password
    this.cacheEncryptionKey = Boolean(opts.cacheEncryptionKey);
  }

  /**
   * Full Update
   *
   * Emits the `update` event and @returns a Promise that resolves to
   * the current state.
   *
   * Frequently used to end asynchronous chains in this class,
   * indicating consumers can often either listen for updates,
   * or accept a state-resolving promise to consume their results.
   *
   * @returns {object} The controller state.
   */
  fullUpdate() {
    this.emit('update', this.memStore.getState());
    return this.memStore.getState();
  }

  /**
   * Create New Vault And Keychain
   *
   * Destroys any old encrypted storage,
   * creates a new encrypted store with the given password,
   * randomly creates a new HD wallet with 1 account,
   * faucets that account on the testnet.
   *
   * @fires KeyringController#unlock
   * @param {string} password - The password to encrypt the vault with.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async createNewVaultAndKeychain(password) {
    this.password = password;

    await this.createFirstKeyTree();
    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * CreateNewVaultAndRestore
   *
   * Destroys any old encrypted storage,
   * creates a new encrypted store with the given password,
   * creates a new HD wallet from the given seed with 1 account.
   *
   * @fires KeyringController#unlock
   * @param {string} password - The password to encrypt the vault with.
   * @param {Uint8Array | string} seedPhrase - The BIP39-compliant seed phrase,
   * either as a string or Uint8Array.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async createNewVaultAndRestore(password, seedPhrase) {
    if (typeof password !== 'string') {
      throw new Error('Password must be text.');
    }
    this.password = password;

    await this.clearKeyrings();
    const keyring = await this.addNewKeyring(KEYRINGS_TYPE_MAP.HD_KEYRING, {
      mnemonic: seedPhrase,
      numberOfAccounts: 1,
    });
    const [firstAccount] = await keyring.getAccounts();

    if (!firstAccount) {
      throw new Error('KeyringController - First Account not found.');
    }
    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * Set Locked
   * This method deallocates all secrets, and effectively locks MetaMask.
   *
   * @fires KeyringController#lock
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async setLocked() {
    delete this.password;

    // set locked
    this.memStore.updateState({
      isUnlocked: false,
      encryptionKey: null,
      encryptionSalt: null,
    });

    // remove keyrings
    this.keyrings = [];
    await this._updateMemStoreKeyrings();
    this.emit('lock');
    return this.fullUpdate();
  }

  /**
   * Submit password.
   *
   * Attempts to decrypt the current vault and load its keyrings
   * into memory.
   *
   * Temporarily also migrates any old-style vaults first, as well
   * (Pre MetaMask 3.0.0).
   *
   * @fires KeyringController#unlock
   * @param {string} password - The keyring controller password.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async submitPassword(password) {
    this.keyrings = await this.unlockKeyrings(password);

    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * Submit Encryption Key.
   *
   * Attempts to decrypt the current vault and load its keyrings
   * into memory based on the vault and CryptoKey information.
   *
   * @fires KeyringController#unlock
   * @param {string} encryptionKey - The encrypted key information used to decrypt the vault.
   * @param {string} encryptionSalt - The salt used to generate the last key.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async submitEncryptionKey(encryptionKey, encryptionSalt) {
    this.keyrings = await this.unlockKeyrings(
      undefined,
      encryptionKey,
      encryptionSalt,
    );
    this.setUnlocked();
    return this.fullUpdate();
  }

  /**
   * Verify Password
   *
   * Attempts to decrypt the current vault with a given password
   * to verify its validity.
   *
   * @param {string} password - The vault password.
   */
  async verifyPassword(password) {
    const encryptedVault = this.store.getState().vault;
    if (!encryptedVault) {
      throw new Error('Cannot unlock without a previous vault.');
    }
    await this.encryptor.decrypt(password, encryptedVault);
  }

  /**
   * Add New Keyring
   *
   * Adds a new Keyring of the given `type` to the vault
   * and the current decrypted Keyrings array.
   *
   * All Keyring classes implement a unique `type` string,
   * and this is used to retrieve them from the keyringBuilders array.
   *
   * @param {string} type - The type of keyring to add.
   * @param {object} opts - The constructor options for the keyring.
   * @returns {Promise<Keyring>} The new keyring.
   */
  async addNewKeyring(type, opts) {
    const keyring = await this._newKeyring(type, opts);

    if ((!opts || !opts.mnemonic) && type === KEYRINGS_TYPE_MAP.HD_KEYRING) {
      keyring.generateRandomMnemonic();
      await keyring.addAccounts();
    }

    const accounts = await keyring.getAccounts();
    await this.checkForDuplicate(type, accounts);

    this.keyrings.push(keyring);
    await this.persistAllKeyrings();

    this.fullUpdate();

    return keyring;
  }

  /**
   * Remove Empty Keyrings.
   *
   * Loops through the keyrings and removes the ones with empty accounts
   * (usually after removing the last / only account) from a keyring.
   */
  async removeEmptyKeyrings() {
    const validKeyrings = [];

    // Since getAccounts returns a Promise
    // We need to wait to hear back form each keyring
    // in order to decide which ones are now valid (accounts.length > 0)

    await Promise.all(
      this.keyrings.map(async (keyring) => {
        const accounts = await keyring.getAccounts();
        if (accounts.length > 0) {
          validKeyrings.push(keyring);
        }
      }),
    );
    this.keyrings = validKeyrings;
  }

  /**
   * Checks for duplicate keypairs, using the the first account in the given
   * array. Rejects if a duplicate is found.
   *
   * Only supports 'Simple Key Pair'.
   *
   * @param {string} type - The key pair type to check for.
   * @param {Array<string>} newAccountArray - Array of new accounts.
   * @returns {Promise<Array<string>>} The account, if no duplicate is found.
   */
  async checkForDuplicate(type, newAccountArray) {
    const accounts = await this.getAccounts();

    switch (type) {
      case KEYRINGS_TYPE_MAP.SIMPLE_KEYRING: {
        const isIncluded = Boolean(
          accounts.find(
            (key) =>
              key === newAccountArray[0] ||
              key === stripHexPrefix(newAccountArray[0]),
          ),
        );

        if (isIncluded) {
          throw new Error(
            'The account you are trying to import is a duplicate',
          );
        }
        return newAccountArray;
      }

      default: {
        return newAccountArray;
      }
    }
  }

  /**
   * Add New Account.
   *
   * Calls the `addAccounts` method on the given keyring,
   * and then saves those changes.
   *
   * @param {Keyring} selectedKeyring - The currently selected keyring.
   * @returns {Promise<object>} A Promise that resolves to the state.
   */
  async addNewAccount(selectedKeyring) {
    const accounts = await selectedKeyring.addAccounts(1);
    accounts.forEach((hexAccount) => {
      this.emit('newAccount', hexAccount);
    });

    await this.persistAllKeyrings();
    return this.fullUpdate();
  }

  /**
   * Export Account
   *
   * Requests the private key from the keyring controlling
   * the specified address.
   *
   * Returns a Promise that may resolve with the private key string.
   *
   * @param {string} address - The address of the account to export.
   * @returns {Promise<string>} The private key of the account.
   */
  async exportAccount(address) {
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.exportAccount(normalizeAddress(address));
  }

  /**
   * Remove Account.
   *
   * Removes a specific account from a keyring
   * If the account is the last/only one then it also removes the keyring.
   *
   * @param {string} address - The address of the account to remove.
   * @returns {Promise<void>} A Promise that resolves if the operation was successful.
   */
  async removeAccount(address) {
    const keyring = await this.getKeyringForAccount(address);

    // Not all the keyrings support this, so we have to check
    if (typeof keyring.removeAccount === 'function') {
      keyring.removeAccount(address);
      this.emit('removedAccount', address);
    } else {
      throw new Error(
        `Keyring ${keyring.type} doesn't support account removal operations`,
      );
    }

    const accounts = await keyring.getAccounts();
    // Check if this was the last/only account
    if (accounts.length === 0) {
      await this.removeEmptyKeyrings();
    }

    await this.persistAllKeyrings();
    return this.fullUpdate();
  }

  //
  // SIGNING METHODS
  //

  /**
   * Sign Ethereum Transaction
   *
   * Signs an Ethereum transaction object.
   *
   * @param {object} ethTx - The transaction to sign.
   * @param {string} _fromAddress - The transaction 'from' address.
   * @param {object} opts - Signing options.
   * @returns {Promise<object>} The signed transaction object.
   */
  async signTransaction(ethTx, _fromAddress, opts = {}) {
    const fromAddress = normalizeAddress(_fromAddress);
    const keyring = await this.getKeyringForAccount(fromAddress);
    return await keyring.signTransaction(fromAddress, ethTx, opts);
  }

  /**
   * Sign Message
   *
   * Attempts to sign the provided message parameters.
   *
   * @param {object} msgParams - The message parameters to sign.
   * @param {object} opts - Additional signing options.
   * @returns {Promise<Buffer>} The raw signature.
   */
  async signMessage(msgParams, opts = {}) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.signMessage(address, msgParams.data, opts);
  }

  /**
   * Sign Personal Message
   *
   * Attempts to sign the provided message parameters.
   * Prefixes the hash before signing per the personal sign expectation.
   *
   * @param {object} msgParams - The message parameters to sign.
   * @param {object} opts - Additional signing options.
   * @returns {Promise<Buffer>} The raw signature.
   */
  async signPersonalMessage(msgParams, opts = {}) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.signPersonalMessage(address, msgParams.data, opts);
  }

  /**
   * Get encryption public key
   *
   * Get encryption public key for using in encrypt/decrypt process.
   *
   * @param {object} address - The address to get the encryption public key for.
   * @param {object} opts - Additional encryption options.
   * @returns {Promise<Buffer>} The public key.
   */
  async getEncryptionPublicKey(address, opts = {}) {
    const normalizedAddress = normalizeAddress(address);
    const keyring = await this.getKeyringForAccount(address);
    return await keyring.getEncryptionPublicKey(normalizedAddress, opts);
  }

  /**
   * Decrypt Message
   *
   * Attempts to decrypt the provided message parameters.
   *
   * @param {object} msgParams - The decryption message parameters.
   * @param {object} opts - Additional decryption options.
   * @returns {Promise<Buffer>} The raw decryption result.
   */
  async decryptMessage(msgParams, opts = {}) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return keyring.decryptMessage(address, msgParams.data, opts);
  }

  /**
   * Sign Typed Data.
   *
   * @see {@link https://github.com/ethereum/EIPs/pull/712#issuecomment-329988454|EIP712}.
   * @param {object} msgParams - The message parameters to sign.
   * @param {object} opts - Additional signing options.
   * @returns {Promise<Buffer>} The raw signature.
   */
  async signTypedMessage(msgParams, opts = { version: 'V1' }) {
    const address = normalizeAddress(msgParams.from);
    const keyring = await this.getKeyringForAccount(address);
    return keyring.signTypedData(address, msgParams.data, opts);
  }

  /**
   * Gets the app key address for the given Ethereum address and origin.
   *
   * @param {string} _address - The Ethereum address for the app key.
   * @param {string} origin - The origin for the app key.
   * @returns {string} The app key address.
   */
  async getAppKeyAddress(_address, origin) {
    const address = normalizeAddress(_address);
    const keyring = await this.getKeyringForAccount(address);
    return keyring.getAppKeyAddress(address, origin);
  }

  /**
   * Exports an app key private key for the given Ethereum address and origin.
   *
   * @param {string} _address - The Ethereum address for the app key.
   * @param {string} origin - The origin for the app key.
   * @returns {string} The app key private key.
   */
  async exportAppKeyForAddress(_address, origin) {
    const address = normalizeAddress(_address);
    const keyring = await this.getKeyringForAccount(address);
    // The "in" operator is typically restricted because it also checks inherited properties,
    // which can be unexpected for plain objects. We're allowing it here because `keyring` is not
    // a plain object, and we explicitly want to include inherited methods in this check.
    // eslint-disable-next-line no-restricted-syntax
    if (!('exportAccount' in keyring)) {
      throw new Error(
        `The keyring for address ${_address} does not support exporting.`,
      );
    }
    return keyring.exportAccount(address, { withAppKeyOrigin: origin });
  }

  //
  // PRIVATE METHODS
  //

  /**
   * Create First Key Tree.
   *
   * - Clears the existing vault.
   * - Creates a new vault.
   * - Creates a random new HD Keyring with 1 account.
   * - Makes that account the selected account.
   * - Faucets that account on testnet.
   * - Puts the current seed words into the state tree.
   *
   * @returns {Promise<void>} A promise that resolves if the operation was successful.
   */
  async createFirstKeyTree() {
    this.clearKeyrings();

    const keyring = await this.addNewKeyring(KEYRINGS_TYPE_MAP.HD_KEYRING);
    const [firstAccount] = await keyring.getAccounts();
    if (!firstAccount) {
      throw new Error('KeyringController - No account found on keychain.');
    }

    const hexAccount = normalizeAddress(firstAccount);
    this.emit('newVault', hexAccount);
    return null;
  }

  /**
   * Persist All Keyrings
   *
   * Iterates the current `keyrings` array,
   * serializes each one into a serialized array,
   * encrypts that array with the provided `password`,
   * and persists that encrypted string to storage.
   *
   * @returns {Promise<boolean>} Resolves to true once keyrings are persisted.
   */
  async persistAllKeyrings() {
    const { encryptionKey, encryptionSalt } = this.memStore.getState();

    if (!this.password && !encryptionKey) {
      throw new Error(
        'Cannot persist vault without password and encryption key',
      );
    }

    const serializedKeyrings = await Promise.all(
      this.keyrings.map(async (keyring) => {
        const [type, data] = await Promise.all([
          keyring.type,
          keyring.serialize(),
        ]);
        return { type, data };
      }),
    );

    serializedKeyrings.push(...this._unsupportedKeyrings);

    let vault;
    let newEncryptionKey;

    if (this.cacheEncryptionKey) {
      if (this.password) {
        const { vault: newVault, exportedKeyString } =
          await this.encryptor.encryptWithDetail(
            this.password,
            serializedKeyrings,
          );

        vault = newVault;
        newEncryptionKey = exportedKeyString;
      } else if (encryptionKey) {
        const key = await this.encryptor.importKey(encryptionKey);
        const vaultJSON = await this.encryptor.encryptWithKey(
          key,
          serializedKeyrings,
        );
        vaultJSON.salt = encryptionSalt;
        vault = JSON.stringify(vaultJSON);
      }
    } else {
      vault = await this.encryptor.encrypt(this.password, serializedKeyrings);
    }

    if (!vault) {
      throw new Error('Cannot persist vault without vault information');
    }

    this.store.updateState({ vault });

    // The keyring updates need to be announced before updating the encryptionKey
    // so that the updated keyring gets propagated to the extension first.
    // Not calling _updateMemStoreKeyrings results in the wrong account being selected
    // in the extension.
    await this._updateMemStoreKeyrings();

    if (newEncryptionKey) {
      this.memStore.updateState({
        encryptionKey: newEncryptionKey,
        encryptionSalt: JSON.parse(vault).salt,
      });
    }

    return true;
  }

  /**
   * Unlock Keyrings.
   *
   * Attempts to unlock the persisted encrypted storage,
   * initializing the persisted keyrings to RAM.
   *
   * @param {string} password - The keyring controller password.
   * @param {string} encryptionKey - An exported key string to unlock keyrings with.
   * @param {string} encryptionSalt - The salt used to encrypt the vault.
   * @returns {Promise<Array<Keyring>>} The keyrings.
   */
  async unlockKeyrings(password, encryptionKey, encryptionSalt) {
    const encryptedVault = this.store.getState().vault;
    if (!encryptedVault) {
      throw new Error('Cannot unlock without a previous vault.');
    }

    await this.clearKeyrings();

    let vault;

    if (this.cacheEncryptionKey) {
      if (password) {
        const result = await this.encryptor.decryptWithDetail(
          password,
          encryptedVault,
        );
        vault = result.vault;
        this.password = password;

        this.memStore.updateState({
          encryptionKey: result.exportedKeyString,
          encryptionSalt: result.salt,
        });
      } else {
        const parsedEncryptedVault = JSON.parse(encryptedVault);

        if (encryptionSalt !== parsedEncryptedVault.salt) {
          throw new Error('Encryption key and salt provided are expired');
        }

        const key = await this.encryptor.importKey(encryptionKey);
        vault = await this.encryptor.decryptWithKey(key, parsedEncryptedVault);

        // This call is required on the first call because encryptionKey
        // is not yet inside the memStore
        this.memStore.updateState({
          encryptionKey,
          encryptionSalt,
        });
      }
    } else {
      vault = await this.encryptor.decrypt(password, encryptedVault);
      this.password = password;
    }

    await Promise.all(vault.map(this._restoreKeyring.bind(this)));
    await this._updateMemStoreKeyrings();
    return this.keyrings;
  }

  /**
   * Restore Keyring
   *
   * Attempts to initialize a new keyring from the provided serialized payload.
   * On success, updates the memStore keyrings and returns the resulting
   * keyring instance.
   *
   * @param {object} serialized - The serialized keyring.
   * @returns {Promise<Keyring>} The deserialized keyring.
   */
  async restoreKeyring(serialized) {
    const keyring = await this._restoreKeyring(serialized);
    if (keyring) {
      await this._updateMemStoreKeyrings();
    }
    return keyring;
  }

  /**
   * Restore Keyring Helper
   *
   * Attempts to initialize a new keyring from the provided serialized payload.
   * On success, returns the resulting keyring instance.
   *
   * @param {object} serialized - The serialized keyring.
   * @returns {Promise<Keyring|undefined>} The deserialized keyring or undefined if the keyring type is unsupported.
   */
  async _restoreKeyring(serialized) {
    const { type, data } = serialized;

    const keyring = await this._newKeyring(type, data);
    if (!keyring) {
      this._unsupportedKeyrings.push(serialized);
      return undefined;
    }

    // getAccounts also validates the accounts for some keyrings
    await keyring.getAccounts();
    this.keyrings.push(keyring);
    return keyring;
  }

  /**
   * Get Keyring Class For Type
   *
   * Searches the current `keyringBuilders` array
   * for a Keyring builder whose unique `type` property
   * matches the provided `type`,
   * returning it if it exists.
   *
   * @param {string} type - The type whose class to get.
   * @returns {Keyring|undefined} The class, if it exists.
   */
  getKeyringBuilderForType(type) {
    return this.keyringBuilders.find(
      (keyringBuilder) => keyringBuilder.type === type,
    );
  }

  /**
   * Get Keyrings by Type
   *
   * Gets all keyrings of the given type.
   *
   * @param {string} type - The keyring types to retrieve.
   * @returns {Array<Keyring>} The keyrings.
   */
  getKeyringsByType(type) {
    return this.keyrings.filter((keyring) => keyring.type === type);
  }

  /**
   * Get Accounts
   *
   * Returns the public addresses of all current accounts
   * managed by all currently unlocked keyrings.
   *
   * @returns {Promise<Array<string>>} The array of accounts.
   */
  async getAccounts() {
    const keyrings = this.keyrings || [];

    const keyringArrays = await Promise.all(
      keyrings.map((keyring) => keyring.getAccounts()),
    );
    const addresses = keyringArrays.reduce((res, arr) => {
      return res.concat(arr);
    }, []);

    return addresses.map(normalizeAddress);
  }

  /**
   * Get Keyring For Account
   *
   * Returns the currently initialized keyring that manages
   * the specified `address` if one exists.
   *
   * @param {string} address - An account address.
   * @returns {Promise<Keyring>} The keyring of the account, if it exists.
   */
  async getKeyringForAccount(address) {
    const hexed = normalizeAddress(address);

    const candidates = await Promise.all(
      this.keyrings.map((keyring) => {
        return Promise.all([keyring, keyring.getAccounts()]);
      }),
    );

    const winners = candidates.filter((candidate) => {
      const accounts = candidate[1].map(normalizeAddress);
      return accounts.includes(hexed);
    });
    if (winners && winners.length > 0) {
      return winners[0][0];
    }

    // Adding more info to the error
    let errorInfo = '';
    if (!address) {
      errorInfo = 'The address passed in is invalid/empty';
    } else if (!candidates || !candidates.length) {
      errorInfo = 'There are no keyrings';
    } else if (!winners || !winners.length) {
      errorInfo = 'There are keyrings, but none match the address';
    }
    throw new Error(
      `No keyring found for the requested account. Error info: ${errorInfo}`,
    );
  }

  /**
   * Display For Keyring
   *
   * Is used for adding the current keyrings to the state object.
   *
   * @param {Keyring} keyring - The keyring to display.
   * @returns {Promise<object>} A keyring display object, with type and accounts properties.
   */
  async displayForKeyring(keyring) {
    const accounts = await keyring.getAccounts();

    return {
      type: keyring.type,
      accounts: accounts.map(normalizeAddress),
    };
  }

  /**
   * Clear Keyrings
   *
   * Deallocates all currently managed keyrings and accounts.
   * Used before initializing a new vault.
   */

  /* eslint-disable require-await */
  async clearKeyrings() {
    // clear keyrings from memory
    this.keyrings = [];
    this.memStore.updateState({
      keyrings: [],
    });
  }

  /**
   * Update memStore Keyrings
   *
   * Updates the in-memory keyrings, without persisting.
   */
  async _updateMemStoreKeyrings() {
    const keyrings = await Promise.all(
      this.keyrings.map(this.displayForKeyring),
    );
    return this.memStore.updateState({ keyrings });
  }

  /**
   * Unlock Keyrings
   *
   * Unlocks the keyrings.
   *
   * @fires KeyringController#unlock
   */
  setUnlocked() {
    this.memStore.updateState({ isUnlocked: true });
    this.emit('unlock');
  }

  /**
   * Forget hardware keyring.
   *
   * Forget hardware and update memorized state.
   *
   * @param {Keyring} keyring - The keyring to forget.
   */
  forgetKeyring(keyring) {
    if (keyring.forgetDevice) {
      keyring.forgetDevice();
      this.persistAllKeyrings();
    } else {
      throw new Error(
        `KeyringController - keyring does not have method "forgetDevice", keyring type: ${keyring.type}`,
      );
    }
  }

  /**
   * Instantiate, initialize and return a new keyring
   *
   * The keyring instantiated is of the given `type`.
   *
   * @param {string} type - The type of keyring to add.
   * @param {object} data - The data to restore a previously serialized keyring.
   * @returns {Promise<Keyring>} The new keyring.
   */
  async _newKeyring(type, data) {
    const keyringBuilder = this.getKeyringBuilderForType(type);

    if (!keyringBuilder) {
      return undefined;
    }

    const keyring = keyringBuilder();

    await keyring.deserialize(data);

    if (keyring.init) {
      await keyring.init();
    }

    return keyring;
  }
}

/**
 * Get builder function for `Keyring`
 *
 * Returns a builder function for `Keyring` with a `type` property.
 *
 * @param {Keyring} Keyring - The Keyring class for the builder.
 * @returns {Function} A builder function for the given Keyring.
 */
function keyringBuilderFactory(Keyring) {
  const builder = () => new Keyring();

  builder.type = Keyring.type;

  return builder;
}

module.exports = {
  KeyringController,
  keyringBuilderFactory,
};

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller",file:"node_modules\\@metamask\\eth-keyring-controller\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\encryption.js", {"./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","tweetnacl":"F:\\metamask-extension\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"F:\\metamask-extension\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Cencryption.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;
const nacl = __importStar(require("tweetnacl"));
const naclUtil = __importStar(require("tweetnacl-util"));
const utils_1 = require("./utils");
/**
 * Encrypt a message.
 *
 * @param options - The encryption options.
 * @param options.publicKey - The public key of the message recipient.
 * @param options.data - The message data.
 * @param options.version - The type of encryption to use.
 * @returns The encrypted data.
 */
function encrypt({ publicKey, data, version, }) {
    if ((0, utils_1.isNullish)(publicKey)) {
        throw new Error('Missing publicKey parameter');
    }
    else if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(version)) {
        throw new Error('Missing version parameter');
    }
    switch (version) {
        case 'x25519-xsalsa20-poly1305': {
            if (typeof data !== 'string') {
                throw new Error('Message data must be given as a string');
            }
            // generate ephemeral keypair
            const ephemeralKeyPair = nacl.box.keyPair();
            // assemble encryption parameters - from string to UInt8
            let pubKeyUInt8Array;
            try {
                pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);
            }
            catch (err) {
                throw new Error('Bad public key');
            }
            const msgParamsUInt8Array = naclUtil.decodeUTF8(data);
            const nonce = nacl.randomBytes(nacl.box.nonceLength);
            // encrypt
            const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);
            // handle encrypted data
            const output = {
                version: 'x25519-xsalsa20-poly1305',
                nonce: naclUtil.encodeBase64(nonce),
                ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),
                ciphertext: naclUtil.encodeBase64(encryptedMessage),
            };
            // return encrypted msg data
            return output;
        }
        default:
            throw new Error('Encryption type/version not supported');
    }
}
exports.encrypt = encrypt;
/**
 * Encrypt a message in a way that obscures the message length.
 *
 * The message is padded to a multiple of 2048 before being encrypted so that the length of the
 * resulting encrypted message can't be used to guess the exact length of the original message.
 *
 * @param options - The encryption options.
 * @param options.publicKey - The public key of the message recipient.
 * @param options.data - The message data.
 * @param options.version - The type of encryption to use.
 * @returns The encrypted data.
 */
function encryptSafely({ publicKey, data, version, }) {
    if ((0, utils_1.isNullish)(publicKey)) {
        throw new Error('Missing publicKey parameter');
    }
    else if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(version)) {
        throw new Error('Missing version parameter');
    }
    const DEFAULT_PADDING_LENGTH = 2 ** 11;
    const NACL_EXTRA_BYTES = 16;
    if (typeof data === 'object' && 'toJSON' in data) {
        // remove toJSON attack vector
        // TODO, check all possible children
        throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');
    }
    // add padding
    const dataWithPadding = {
        data,
        padding: '',
    };
    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');
    const modVal = dataLength % DEFAULT_PADDING_LENGTH;
    let padLength = 0;
    // Only pad if necessary
    if (modVal > 0) {
        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength);
    const paddedMessage = JSON.stringify(dataWithPadding);
    return encrypt({ publicKey, data: paddedMessage, version });
}
exports.encryptSafely = encryptSafely;
/**
 * Decrypt a message.
 *
 * @param options - The decryption options.
 * @param options.encryptedData - The encrypted data.
 * @param options.privateKey - The private key to decrypt with.
 * @returns The decrypted message.
 */
function decrypt({ encryptedData, privateKey, }) {
    if ((0, utils_1.isNullish)(encryptedData)) {
        throw new Error('Missing encryptedData parameter');
    }
    else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error('Missing privateKey parameter');
    }
    switch (encryptedData.version) {
        case 'x25519-xsalsa20-poly1305': {
            // string to buffer to UInt8Array
            const recieverPrivateKeyUint8Array = nacl_decodeHex(privateKey);
            const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey;
            // assemble decryption parameters
            const nonce = naclUtil.decodeBase64(encryptedData.nonce);
            const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);
            const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);
            // decrypt
            const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey);
            // return decrypted msg data
            let output;
            try {
                output = naclUtil.encodeUTF8(decryptedMessage);
            }
            catch (err) {
                throw new Error('Decryption failed.');
            }
            if (output) {
                return output;
            }
            throw new Error('Decryption failed.');
        }
        default:
            throw new Error('Encryption type/version not supported.');
    }
}
exports.decrypt = decrypt;
/**
 * Decrypt a message that has been encrypted using `encryptSafely`.
 *
 * @param options - The decryption options.
 * @param options.encryptedData - The encrypted data.
 * @param options.privateKey - The private key to decrypt with.
 * @returns The decrypted message.
 */
function decryptSafely({ encryptedData, privateKey, }) {
    if ((0, utils_1.isNullish)(encryptedData)) {
        throw new Error('Missing encryptedData parameter');
    }
    else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error('Missing privateKey parameter');
    }
    const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));
    return dataWithPadding.data;
}
exports.decryptSafely = decryptSafely;
/**
 * Get the encryption public key for the given key.
 *
 * @param privateKey - The private key to generate the encryption public key with.
 * @returns The encryption public key.
 */
function getEncryptionPublicKey(privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey);
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;
    return naclUtil.encodeBase64(encryptionPublicKey);
}
exports.getEncryptionPublicKey = getEncryptionPublicKey;
/**
 * Convert a hex string to the UInt8Array format used by nacl.
 *
 * @param msgHex - The string to convert.
 * @returns The converted string.
 */
function nacl_decodeHex(msgHex) {
    const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');
    return naclUtil.decodeBase64(msgBase64);
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\encryption.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\ethereumjs-abi-utils.js", {"./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","bn.js":"F:\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Cethereumjs-abi-utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
/* eslint jsdoc/require-description: 0 */
/* eslint jsdoc/require-returns: 0 */
/* eslint jsdoc/match-description: 0 */
/* eslint jsdoc/require-param-description: 0 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rawEncode = exports.parseNumber = exports.solidityPack = void 0;
const util_1 = require("@ethereumjs/util");
const ethjs_util_1 = require("ethjs-util");
const bn_js_1 = __importDefault(require("bn.js"));
const utils_1 = require("./utils");
//
// Methods borrowed and somewhat adapted from ethereumjs-abi@0.6.8:
// https://npmfs.com/package/ethereumjs-abi/0.6.8/lib/index.js
//
/**
 * Packs non-standard encoded values packed according to their respective type in types in a buffer.
 *
 * @param types - Array of types of each value to encode.
 * @param values - Array of values to encode.
 * @returns A buffer containing the packed values.
 */
function solidityPack(types, values) {
    if (types.length !== values.length) {
        throw new Error('Number of types are not matching the values');
    }
    const ret = [];
    for (let i = 0; i < types.length; i++) {
        const type = elementaryName(types[i]);
        const value = values[i];
        ret.push(solidityHexValue(type, value, null));
    }
    return Buffer.concat(ret);
}
exports.solidityPack = solidityPack;
/**
 * Checks if a value is an array (represented as a string).
 *
 * @param type - The value to check whether it is an array.
 * @returns A boolean indicating whether the passed value is an array.
 */
function isArray(type) {
    return type.lastIndexOf(']') === type.length - 1;
}
/**
 * Parse array type for packing solidity values.
 *
 * @param type - A string that may be an array to parse.
 * @returns A parsed value from the array.
 */
function parseTypeArray(type) {
    const tmp = type.match(/(.*)\[(.*?)\]$/u);
    if (tmp) {
        return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);
    }
    return null;
}
/**
 * Parse N from type<N>.
 *
 * @param type - Value to parse.
 * @returns Parsed value.
 */
function parseTypeN(type) {
    return parseInt(/^\D+(\d+)$/u.exec(type)[1], 10);
}
/**
 * Parse a number for determining a solidity hexvalue.
 *
 * @param arg - Number to parse.
 * @returns Parsed value.
 */
function parseNumber(arg) {
    const type = typeof arg;
    if (type === 'string') {
        if ((0, util_1.isHexPrefixed)(arg)) {
            return new bn_js_1.default((0, ethjs_util_1.stripHexPrefix)(arg), 16);
        }
        return new bn_js_1.default(arg, 10);
    }
    else if (type === 'number') {
        return new bn_js_1.default(arg);
    }
    else if (arg.toArray) {
        // assume this is a BN for the moment, replace with BN.isBN soon
        return arg;
    }
    throw new Error('Argument is not a number');
}
exports.parseNumber = parseNumber;
/**
 * Get solidity hex value from type, value and bitsize inputs for packing these values in a buffer.
 *
 * @param type - The type of the value to encode.
 * @param value - The value to encode.
 * @param bitsize - The bitsize of the value to encode.
 * @returns The encoded soldity hex value.
 */
function solidityHexValue(type, value, bitsize) {
    // pass in bitsize = null if use default bitsize
    let size, num;
    if (isArray(type)) {
        const subType = type.replace(/\[.*?\]/u, '');
        if (!isArray(subType)) {
            const arraySize = parseTypeArray(type);
            if (arraySize !== 'dynamic' &&
                arraySize !== 0 &&
                value.length > arraySize) {
                throw new Error(`Elements exceed array size: ${arraySize}`);
            }
        }
        const arrayValues = value.map(function (v) {
            return solidityHexValue(subType, v, 256);
        });
        return Buffer.concat(arrayValues);
    }
    else if (type === 'bytes') {
        return value;
    }
    else if (type === 'string') {
        return Buffer.from(value, 'utf8');
    }
    else if (type === 'bool') {
        bitsize = bitsize || 8;
        const padding = Array(bitsize / 4).join('0');
        return Buffer.from(value ? `${padding}1` : `${padding}0`, 'hex');
    }
    else if (type === 'address') {
        let bytesize = 20;
        if (bitsize) {
            bytesize = bitsize / 8;
        }
        return (0, util_1.setLengthLeft)((0, util_1.toBuffer)(value), bytesize);
    }
    else if (type.startsWith('bytes')) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
            throw new Error(`Invalid bytes<N> width: ${size}`);
        }
        if (typeof value === 'number') {
            value = (0, utils_1.normalize)(value);
        }
        return (0, util_1.setLengthRight)((0, util_1.toBuffer)(value), size);
    }
    else if (type.startsWith('uint')) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
            throw new Error(`Invalid uint<N> width: ${size}`);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
            throw new Error(`Supplied uint exceeds width: ${size} vs ${num.bitLength()}`);
        }
        bitsize = bitsize || size;
        return num.toArrayLike(Buffer, 'be', bitsize / 8);
    }
    else if (type.startsWith('int')) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
            throw new Error(`Invalid int<N> width: ${size}`);
        }
        num = parseNumber(value);
        if (num.bitLength() > size) {
            throw new Error(`Supplied int exceeds width: ${size} vs ${num.bitLength()}`);
        }
        bitsize = bitsize || size;
        return num.toTwos(size).toArrayLike(Buffer, 'be', bitsize / 8);
    }
    // FIXME: support all other types
    throw new Error(`Unsupported or invalid type: ${type}`);
}
/**
 * Gets the correct solidity type name.
 *
 * @param name - The type name for which we want the corresponding solidity type name.
 * @returns The solidity type name for the input value.
 */
function elementaryName(name) {
    if (name.startsWith('int[')) {
        return `int256${name.slice(3)}`;
    }
    else if (name === 'int') {
        return 'int256';
    }
    else if (name.startsWith('uint[')) {
        return `uint256${name.slice(4)}`;
    }
    else if (name === 'uint') {
        return 'uint256';
    }
    else if (name.startsWith('fixed[')) {
        return `fixed128x128${name.slice(5)}`;
    }
    else if (name === 'fixed') {
        return 'fixed128x128';
    }
    else if (name.startsWith('ufixed[')) {
        return `ufixed128x128${name.slice(6)}`;
    }
    else if (name === 'ufixed') {
        return 'ufixed128x128';
    }
    return name;
}
/**
 * @param types
 * @param values
 */
function rawEncode(types, values) {
    const output = [];
    const data = [];
    let headLength = 0;
    types.forEach(function (type) {
        if (isArray(type)) {
            const size = parseTypeArray(type);
            // eslint-disable-next-line no-negated-condition
            if (size !== 'dynamic') {
                headLength += 32 * size;
            }
            else {
                headLength += 32;
            }
        }
        else {
            headLength += 32;
        }
    });
    for (let i = 0; i < types.length; i++) {
        const type = elementaryName(types[i]);
        const value = values[i];
        const cur = encodeSingle(type, value);
        // Use the head/tail method for storing dynamic data
        if (isDynamic(type)) {
            output.push(encodeSingle('uint256', headLength));
            data.push(cur);
            headLength += cur.length;
        }
        else {
            output.push(cur);
        }
    }
    return Buffer.concat(output.concat(data));
}
exports.rawEncode = rawEncode;
// Encodes a single item (can be dynamic array)
// @returns: Buffer
/**
 * @param type
 * @param arg
 */
function encodeSingle(type, arg) {
    let size, num, ret, i;
    if (type === 'address') {
        return encodeSingle('uint160', parseNumber(arg));
    }
    else if (type === 'bool') {
        return encodeSingle('uint8', arg ? 1 : 0);
    }
    else if (type === 'string') {
        return encodeSingle('bytes', Buffer.from(arg, 'utf8'));
    }
    else if (isArray(type)) {
        // this part handles fixed-length ([2]) and variable length ([]) arrays
        // NOTE: we catch here all calls to arrays, that simplifies the rest
        if (typeof arg.length === 'undefined') {
            throw new Error('Not an array?');
        }
        size = parseTypeArray(type);
        if (size !== 'dynamic' && size !== 0 && arg.length > size) {
            throw new Error(`Elements exceed array size: ${size}`);
        }
        ret = [];
        type = type.slice(0, type.lastIndexOf('['));
        if (typeof arg === 'string') {
            arg = JSON.parse(arg);
        }
        for (i in arg) {
            if (Object.prototype.hasOwnProperty.call(arg, i)) {
                ret.push(encodeSingle(type, arg[i]));
            }
        }
        if (size === 'dynamic') {
            const length = encodeSingle('uint256', arg.length);
            ret.unshift(length);
        }
        return Buffer.concat(ret);
    }
    else if (type === 'bytes') {
        arg = Buffer.from(arg);
        ret = Buffer.concat([encodeSingle('uint256', arg.length), arg]);
        if (arg.length % 32 !== 0) {
            ret = Buffer.concat([ret, (0, util_1.zeros)(32 - (arg.length % 32))]);
        }
        return ret;
    }
    else if (type.startsWith('bytes')) {
        size = parseTypeN(type);
        if (size < 1 || size > 32) {
            throw new Error(`Invalid bytes<N> width: ${size}`);
        }
        if (typeof arg === 'number') {
            arg = (0, utils_1.normalize)(arg);
        }
        return (0, util_1.setLengthRight)((0, util_1.toBuffer)(arg), 32);
    }
    else if (type.startsWith('uint')) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
            throw new Error(`Invalid uint<N> width: ${size}`);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
            throw new Error(`Supplied uint exceeds width: ${size} vs ${num.bitLength()}`);
        }
        if (num < 0) {
            throw new Error('Supplied uint is negative');
        }
        return num.toArrayLike(Buffer, 'be', 32);
    }
    else if (type.startsWith('int')) {
        size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
            throw new Error(`Invalid int<N> width: ${size}`);
        }
        num = parseNumber(arg);
        if (num.bitLength() > size) {
            throw new Error(`Supplied int exceeds width: ${size} vs ${num.bitLength()}`);
        }
        return num.toTwos(256).toArrayLike(Buffer, 'be', 32);
    }
    else if (type.startsWith('ufixed')) {
        size = parseTypeNxM(type);
        num = parseNumber(arg);
        if (num < 0) {
            throw new Error('Supplied ufixed is negative');
        }
        return encodeSingle('uint256', num.mul(new bn_js_1.default(2).pow(new bn_js_1.default(size[1]))));
    }
    else if (type.startsWith('fixed')) {
        size = parseTypeNxM(type);
        return encodeSingle('int256', parseNumber(arg).mul(new bn_js_1.default(2).pow(new bn_js_1.default(size[1]))));
    }
    throw new Error(`Unsupported or invalid type: ${type}`);
}
// Is a type dynamic?
/**
 * @param type
 */
function isDynamic(type) {
    // FIXME: handle all types? I don't think anything is missing now
    return (type === 'string' || type === 'bytes' || parseTypeArray(type) === 'dynamic');
}
// Parse N,M from type<N>x<M>
/**
 * @param type
 */
function parseTypeNxM(type) {
    const tmp = /^\D+(\d+)x(\d+)$/u.exec(type);
    return [parseInt(tmp[1], 10), parseInt(tmp[2], 10)];
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\ethereumjs-abi-utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js", {"./encryption":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\encryption.js","./personal-sign":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\personal-sign.js","./sign-typed-data":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\sign-typed-data.js","./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalize = exports.concatSig = void 0;
__exportStar(require("./personal-sign"), exports);
__exportStar(require("./sign-typed-data"), exports);
__exportStar(require("./encryption"), exports);
var utils_1 = require("./utils");
Object.defineProperty(exports, "concatSig", { enumerable: true, get: function () { return utils_1.concatSig; } });
Object.defineProperty(exports, "normalize", { enumerable: true, get: function () { return utils_1.normalize; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\personal-sign.js", {"./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Cpersonal-sign.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;
const util_1 = require("@ethereumjs/util");
const utils_1 = require("./utils");
/**
 * Create an Ethereum-specific signature for a message.
 *
 * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,
 * as well as the MetaMask's `personal_sign` method.
 *
 * @param options - The personal sign options.
 * @param options.privateKey - The key to sign with.
 * @param options.data - The hex data to sign.
 * @returns The '0x'-prefixed hex encoded signature.
 */
function personalSign({ privateKey, data, }) {
    if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error('Missing privateKey parameter');
    }
    const message = (0, utils_1.legacyToBuffer)(data);
    const msgHash = (0, util_1.hashPersonalMessage)(message);
    const sig = (0, util_1.ecsign)(msgHash, privateKey);
    const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);
    return serialized;
}
exports.personalSign = personalSign;
/**
 * Recover the address of the account used to create the given Ethereum signature. The message
 * must have been signed using the `personalSign` function, or an equivalent function.
 *
 * @param options - The signature recovery options.
 * @param options.data - The hex data that was signed.
 * @param options.signature - The '0x'-prefixed hex encoded message signature.
 * @returns The '0x'-prefixed hex encoded address of the message signer.
 */
function recoverPersonalSignature({ data, signature, }) {
    if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(signature)) {
        throw new Error('Missing signature parameter');
    }
    const publicKey = getPublicKeyFor(data, signature);
    const sender = (0, util_1.publicToAddress)(publicKey);
    const senderHex = (0, util_1.bufferToHex)(sender);
    return senderHex;
}
exports.recoverPersonalSignature = recoverPersonalSignature;
/**
 * Recover the public key of the account used to create the given Ethereum signature. The message
 * must have been signed using the `personalSign` function, or an equivalent function.
 *
 * @param options - The public key recovery options.
 * @param options.data - The hex data that was signed.
 * @param options.signature - The '0x'-prefixed hex encoded message signature.
 * @returns The '0x'-prefixed hex encoded public key of the message signer.
 */
function extractPublicKey({ data, signature, }) {
    if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(signature)) {
        throw new Error('Missing signature parameter');
    }
    const publicKey = getPublicKeyFor(data, signature);
    return `0x${publicKey.toString('hex')}`;
}
exports.extractPublicKey = extractPublicKey;
/**
 * Get the public key for the given signature and message.
 *
 * @param message - The message that was signed.
 * @param signature - The '0x'-prefixed hex encoded message signature.
 * @returns The public key of the signer.
 */
function getPublicKeyFor(message, signature) {
    const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));
    return (0, utils_1.recoverPublicKey)(messageHash, signature);
}
//# sourceMappingURL=personal-sign.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\personal-sign.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\sign-typed-data.js", {"./ethereumjs-abi-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\ethereumjs-abi-utils.js","./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/keccak":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Csign-typed-data.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;
const ethjs_util_1 = require("ethjs-util");
const util_1 = require("@ethereumjs/util");
const keccak_1 = require("ethereum-cryptography/keccak");
const ethereumjs_abi_utils_1 = require("./ethereumjs-abi-utils");
const utils_1 = require("./utils");
/**
 * Represents the version of `signTypedData` being used.
 *
 * V1 is based upon [an early version of EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)
 * that lacked some later security improvements, and should generally be neglected in favor of
 * later versions.
 *
 * V3 is based on EIP-712, except that arrays and recursive data structures are not supported.
 *
 * V4 is based on EIP-712, and includes full support of arrays and recursive data structures.
 */
var SignTypedDataVersion;
(function (SignTypedDataVersion) {
    SignTypedDataVersion["V1"] = "V1";
    SignTypedDataVersion["V3"] = "V3";
    SignTypedDataVersion["V4"] = "V4";
})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
exports.TYPED_MESSAGE_SCHEMA = {
    type: 'object',
    properties: {
        types: {
            type: 'object',
            additionalProperties: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        name: { type: 'string' },
                        type: { type: 'string' },
                    },
                    required: ['name', 'type'],
                },
            },
        },
        primaryType: { type: 'string' },
        domain: { type: 'object' },
        message: { type: 'object' },
    },
    required: ['types', 'primaryType', 'domain', 'message'],
};
/**
 * Validate that the given value is a valid version string.
 *
 * @param version - The version value to validate.
 * @param allowedVersions - A list of allowed versions. If omitted, all versions are assumed to be
 * allowed.
 */
function validateVersion(version, allowedVersions) {
    if (!Object.keys(SignTypedDataVersion).includes(version)) {
        throw new Error(`Invalid version: '${version}'`);
    }
    else if (allowedVersions && !allowedVersions.includes(version)) {
        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(', ')}`);
    }
}
/**
 * Encode a single field.
 *
 * @param types - All type definitions.
 * @param name - The name of the field to encode.
 * @param type - The type of the field being encoded.
 * @param value - The value to encode.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns Encoded representation of the field.
 */
function encodeField(types, name, type, value, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    if (types[type] !== undefined) {
        return [
            'bytes32',
            version === SignTypedDataVersion.V4 && value == null // eslint-disable-line no-eq-null
                ? '0x0000000000000000000000000000000000000000000000000000000000000000'
                : (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(type, value, types, version))),
        ];
    }
    if (value === undefined) {
        throw new Error(`missing value for field ${name} of type ${type}`);
    }
    if (type === 'bytes') {
        if (typeof value === 'number') {
            value = (0, utils_1.numberToBuffer)(value);
        }
        else if ((0, ethjs_util_1.isHexString)(value)) {
            const prepend = value.length % 2 ? '0' : '';
            value = Buffer.from(prepend + value.slice(2), 'hex');
        }
        else {
            value = Buffer.from(value, 'utf8');
        }
        return ['bytes32', (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];
    }
    if (type === 'string') {
        if (typeof value === 'number') {
            value = (0, utils_1.numberToBuffer)(value);
        }
        else {
            value = Buffer.from(value !== null && value !== void 0 ? value : '', 'utf8');
        }
        return ['bytes32', (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];
    }
    if (type.lastIndexOf(']') === type.length - 1) {
        if (version === SignTypedDataVersion.V3) {
            throw new Error('Arrays are unimplemented in encodeData; use V4 extension');
        }
        const parsedType = type.slice(0, type.lastIndexOf('['));
        const typeValuePairs = value.map((item) => encodeField(types, name, parsedType, item, version));
        return [
            'bytes32',
            (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.rawEncode)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))),
        ];
    }
    return [type, value];
}
/**
 * Encodes an object by encoding and concatenating each of its members.
 *
 * @param primaryType - The root type.
 * @param data - The object to encode.
 * @param types - Type definitions for all types included in the message.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns An encoded representation of an object.
 */
function encodeData(primaryType, data, types, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    const encodedTypes = ['bytes32'];
    const encodedValues = [hashType(primaryType, types)];
    for (const field of types[primaryType]) {
        if (version === SignTypedDataVersion.V3 && data[field.name] === undefined) {
            continue;
        }
        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);
        encodedTypes.push(type);
        encodedValues.push(value);
    }
    return (0, ethereumjs_abi_utils_1.rawEncode)(encodedTypes, encodedValues);
}
/**
 * Encodes the type of an object by encoding a comma delimited list of its members.
 *
 * @param primaryType - The root type to encode.
 * @param types - Type definitions for all types included in the message.
 * @returns An encoded representation of the primary type.
 */
function encodeType(primaryType, types) {
    let result = '';
    const unsortedDeps = findTypeDependencies(primaryType, types);
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
        const children = types[type];
        if (!children) {
            throw new Error(`No type definition specified: ${type}`);
        }
        result += `${type}(${types[type]
            .map(({ name, type: t }) => `${t} ${name}`)
            .join(',')})`;
    }
    return result;
}
/**
 * Finds all types within a type definition object.
 *
 * @param primaryType - The root type.
 * @param types - Type definitions for all types included in the message.
 * @param results - The current set of accumulated types.
 * @returns The set of all types found in the type definition.
 */
function findTypeDependencies(primaryType, types, results = new Set()) {
    [primaryType] = primaryType.match(/^\w*/u);
    if (results.has(primaryType) || types[primaryType] === undefined) {
        return results;
    }
    results.add(primaryType);
    for (const field of types[primaryType]) {
        findTypeDependencies(field.type, types, results);
    }
    return results;
}
/**
 * Hashes an object.
 *
 * @param primaryType - The root type.
 * @param data - The object to hash.
 * @param types - Type definitions for all types included in the message.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns The hash of the object.
 */
function hashStruct(primaryType, data, types, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(primaryType, data, types, version)));
}
/**
 * Hashes the type of an object.
 *
 * @param primaryType - The root type to hash.
 * @param types - Type definitions for all types included in the message.
 * @returns The hash of the object type.
 */
function hashType(primaryType, types) {
    const encodedHashType = Buffer.from(encodeType(primaryType, types), 'utf-8');
    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodedHashType));
}
/**
 * Removes properties from a message object that are not defined per EIP-712.
 *
 * @param data - The typed message object.
 * @returns The typed message object with only allowed fields.
 */
function sanitizeData(data) {
    const sanitizedData = {};
    for (const key in exports.TYPED_MESSAGE_SCHEMA.properties) {
        if (data[key]) {
            sanitizedData[key] = data[key];
        }
    }
    if ('types' in sanitizedData) {
        sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
    }
    return sanitizedData;
}
/**
 * Hash a typed message according to EIP-712. The returned message starts with the EIP-712 prefix,
 * which is "1901", followed by the hash of the domain separator, then the data (if any).
 * The result is hashed again and returned.
 *
 * This function does not sign the message. The resulting hash must still be signed to create an
 * EIP-712 signature.
 *
 * @param typedData - The typed message to hash.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns The hash of the typed message.
 */
function eip712Hash(typedData, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    const sanitizedData = sanitizeData(typedData);
    const parts = [Buffer.from('1901', 'hex')];
    parts.push(hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, version));
    if (sanitizedData.primaryType !== 'EIP712Domain') {
        parts.push(hashStruct(
        // TODO: Validate that this is a string, so this type cast can be removed.
        sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, version));
    }
    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(Buffer.concat(parts)));
}
/**
 * A collection of utility functions used for signing typed data.
 */
exports.TypedDataUtils = {
    encodeData,
    encodeType,
    findTypeDependencies,
    hashStruct,
    hashType,
    sanitizeData,
    eip712Hash,
};
/**
 * Generate the "V1" hash for the provided typed message.
 *
 * The hash will be generated in accordance with an earlier version of the EIP-712
 * specification. This hash is used in `signTypedData_v1`.
 *
 * @param typedData - The typed message.
 * @returns The '0x'-prefixed hex encoded hash representing the type of the provided message.
 */
function typedSignatureHash(typedData) {
    const hashBuffer = _typedSignatureHash(typedData);
    return (0, util_1.bufferToHex)(hashBuffer);
}
exports.typedSignatureHash = typedSignatureHash;
/**
 * Generate the "V1" hash for the provided typed message.
 *
 * The hash will be generated in accordance with an earlier version of the EIP-712
 * specification. This hash is used in `signTypedData_v1`.
 *
 * @param typedData - The typed message.
 * @returns The hash representing the type of the provided message.
 */
function _typedSignatureHash(typedData) {
    const error = new Error('Expect argument to be non-empty array');
    if (typeof typedData !== 'object' ||
        !('length' in typedData) ||
        !typedData.length) {
        throw error;
    }
    const data = typedData.map(function (e) {
        if (e.type !== 'bytes') {
            return e.value;
        }
        return (0, utils_1.legacyToBuffer)(e.value);
    });
    const types = typedData.map(function (e) {
        return e.type;
    });
    const schema = typedData.map(function (e) {
        if (!e.name) {
            throw error;
        }
        return `${e.type} ${e.name}`;
    });
    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(['bytes32', 'bytes32'], [
        (0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(new Array(typedData.length).fill('string'), schema)),
        (0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(types, data)),
    ])));
}
/**
 * Sign typed data according to EIP-712. The signing differs based upon the `version`.
 *
 * V1 is based upon [an early version of EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)
 * that lacked some later security improvements, and should generally be neglected in favor of
 * later versions.
 *
 * V3 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), except that arrays and
 * recursive data structures are not supported.
 *
 * V4 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), and includes full support of
 * arrays and recursive data structures.
 *
 * @param options - The signing options.
 * @param options.privateKey - The private key to sign with.
 * @param options.data - The typed data to sign.
 * @param options.version - The signing version to use.
 * @returns The '0x'-prefixed hex encoded signature.
 */
function signTypedData({ privateKey, data, version, }) {
    validateVersion(version);
    if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error('Missing private key parameter');
    }
    const messageHash = version === SignTypedDataVersion.V1
        ? _typedSignatureHash(data)
        : exports.TypedDataUtils.eip712Hash(data, version);
    const sig = (0, util_1.ecsign)(messageHash, privateKey);
    return (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);
}
exports.signTypedData = signTypedData;
/**
 * Recover the address of the account that created the given EIP-712
 * signature. The version provided must match the version used to
 * create the signature.
 *
 * @param options - The signature recovery options.
 * @param options.data - The typed data that was signed.
 * @param options.signature - The '0x-prefixed hex encoded message signature.
 * @param options.version - The signing version to use.
 * @returns The '0x'-prefixed hex address of the signer.
 */
function recoverTypedSignature({ data, signature, version, }) {
    validateVersion(version);
    if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(signature)) {
        throw new Error('Missing signature parameter');
    }
    const messageHash = version === SignTypedDataVersion.V1
        ? _typedSignatureHash(data)
        : exports.TypedDataUtils.eip712Hash(data, version);
    const publicKey = (0, utils_1.recoverPublicKey)(messageHash, signature);
    const sender = (0, util_1.publicToAddress)(publicKey);
    return (0, util_1.bufferToHex)(sender);
}
exports.recoverTypedSignature = recoverTypedSignature;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\sign-typed-data.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js", {"@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Cutils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.numberToBuffer = exports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;
const util_1 = require("@ethereumjs/util");
const ethjs_util_1 = require("ethjs-util");
/**
 * Pads the front of the given hex string with zeroes until it reaches the
 * target length. If the input string is already longer than or equal to the
 * target length, it is returned unmodified.
 *
 * If the input string is "0x"-prefixed or not a hex string, an error will be
 * thrown.
 *
 * @param hexString - The hexadecimal string to pad with zeroes.
 * @param targetLength - The target length of the hexadecimal string.
 * @returns The input string front-padded with zeroes, or the original string
 * if it was already greater than or equal to to the target length.
 */
function padWithZeroes(hexString, targetLength) {
    if (hexString !== '' && !/^[a-f0-9]+$/iu.test(hexString)) {
        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
    }
    if (targetLength < 0) {
        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
    }
    return String.prototype.padStart.call(hexString, targetLength, '0');
}
exports.padWithZeroes = padWithZeroes;
/**
 * Returns `true` if the given value is nullish.
 *
 * @param value - The value being checked.
 * @returns Whether the value is nullish.
 */
function isNullish(value) {
    return value === null || value === undefined;
}
exports.isNullish = isNullish;
/**
 * Convert a value to a Buffer. This function should be equivalent to the `toBuffer` function in
 * `ethereumjs-util@5.2.1`.
 *
 * @param value - The value to convert to a Buffer.
 * @returns The given value as a Buffer.
 */
function legacyToBuffer(value) {
    return typeof value === 'string' && !(0, ethjs_util_1.isHexString)(value)
        ? Buffer.from(value)
        : (0, util_1.toBuffer)(value);
}
exports.legacyToBuffer = legacyToBuffer;
/**
 * Concatenate an extended ECDSA signature into a single '0x'-prefixed hex string.
 *
 * @param v - The 'v' portion of the signature.
 * @param r - The 'r' portion of the signature.
 * @param s - The 's' portion of the signature.
 * @returns The concatenated ECDSA signature as a '0x'-prefixed string.
 */
function concatSig(v, r, s) {
    const rSig = (0, util_1.fromSigned)(r);
    const sSig = (0, util_1.fromSigned)(s);
    const vSig = (0, util_1.bufferToInt)(v);
    const rStr = padWithZeroes((0, util_1.toUnsigned)(rSig).toString('hex'), 64);
    const sStr = padWithZeroes((0, util_1.toUnsigned)(sSig).toString('hex'), 64);
    const vStr = (0, ethjs_util_1.stripHexPrefix)((0, ethjs_util_1.intToHex)(vSig));
    return (0, util_1.addHexPrefix)(rStr.concat(sStr, vStr));
}
exports.concatSig = concatSig;
/**
 * Recover the public key from the given signature and message hash.
 *
 * @param messageHash - The hash of the signed message.
 * @param signature - The signature.
 * @returns The public key of the signer.
 */
function recoverPublicKey(messageHash, signature) {
    const sigParams = (0, util_1.fromRpcSig)(signature);
    return (0, util_1.ecrecover)(messageHash, sigParams.v, sigParams.r, sigParams.s);
}
exports.recoverPublicKey = recoverPublicKey;
/**
 * Normalize the input to a lower-cased '0x'-prefixed hex string.
 *
 * @param input - The value to normalize.
 * @returns The normalized value.
 */
function normalize(input) {
    if (!input) {
        return undefined;
    }
    if (typeof input === 'number') {
        if (input < 0) {
            return '0x';
        }
        const buffer = (0, util_1.toBuffer)(input);
        input = (0, util_1.bufferToHex)(buffer);
    }
    if (typeof input !== 'string') {
        let msg = 'eth-sig-util.normalize() requires hex string or integer input.';
        msg += ` received ${typeof input}: ${input}`;
        throw new Error(msg);
    }
    return (0, util_1.addHexPrefix)(input.toLowerCase());
}
exports.normalize = normalize;
/**
 * Node's Buffer.from() method does not seem to buffer numbers correctly out of the box.
 * This helper method formats the number correct for Buffer.from to return correct buffer.
 *
 * @param num - The number to convert to buffer.
 * @returns The number in buffer form.
 */
function numberToBuffer(num) {
    const hexVal = num.toString(16);
    const prepend = hexVal.length % 2 ? '0' : '';
    return Buffer.from(prepend + hexVal, 'hex');
}
exports.numberToBuffer = numberToBuffer;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\keccak.js", {"./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\utils.js","@noble/hashes/sha3":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5Cethereum-cryptography%5Ckeccak.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const utils_1 = require("./utils");
exports.keccak224 = (0, utils_1.wrapHash)(sha3_1.keccak_224);
exports.keccak256 = (() => {
    const k = (0, utils_1.wrapHash)(sha3_1.keccak_256);
    k.create = sha3_1.keccak_256.create;
    return k;
})();
exports.keccak384 = (0, utils_1.wrapHash)(sha3_1.keccak_384);
exports.keccak512 = (0, utils_1.wrapHash)(sha3_1.keccak_512);

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util>ethereum-cryptography",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\keccak.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5C_assert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
exports.default = assert;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5C_u64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig: exports.toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5CcryptoBrowser.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = {
    node: undefined,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js", {"./_assert.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js","./_u64.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js","./utils.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5Csha3.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = require("./_assert.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        _assert_js_1.default.number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js", {"@noble/hashes/crypto":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5Cutils.js
      return function (require, module, exports) {
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// The import here is via the package name. This is to ensure
// that exports mapping/resolution does fall into place.
const crypto_1 = require("@noble/hashes/crypto");
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
 */
function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('deadbeef')
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */
function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new TypeError('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
/**
 * Secure PRNG
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
    }
    else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
    }
    else {
        throw new Error("The environment doesn't have randomBytes function");
    }
}
exports.randomBytes = randomBytes;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\utils.js", {"@noble/hashes/_assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js","@noble/hashes/utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5Cethereum-cryptography%5Cutils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
// buf.toString('hex') -> toHex(buf)
const _assert_1 = __importDefault(require("@noble/hashes/_assert"));
const utils_1 = require("@noble/hashes/utils");
const assertBool = _assert_1.default.bool;
exports.assertBool = assertBool;
const assertBytes = _assert_1.default.bytes;
exports.assertBytes = assertBytes;
var utils_2 = require("@noble/hashes/utils");
Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return utils_2.concatBytes; } });
Object.defineProperty(exports, "createView", { enumerable: true, get: function () { return utils_2.createView; } });
Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function () { return utils_2.utf8ToBytes; } });
// buf.toString('utf8') -> bytesToUtf8(buf)
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
exports.bytesToUtf8 = bytesToUtf8;
function hexToBytes(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return (0, utils_1.hexToBytes)(sliced);
}
exports.hexToBytes = hexToBytes;
// buf.equals(buf2) -> equalsBytes(buf, buf2)
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.equalsBytes = equalsBytes;
// Internal utils
function wrapHash(hash) {
    return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
    };
}
exports.wrapHash = wrapHash;
exports.crypto = (() => {
    const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : undefined;
    const nodeRequire = typeof module !== "undefined" &&
        typeof module.require === "function" &&
        module.require.bind(module);
    return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
        web: webCrypto
    };
})();

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util>ethereum-cryptography",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethereum-cryptography\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"F:\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"F:\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-keyring-controller%5Cnode_modules%5Cethjs-util%5Clib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-sig-util>ethjs-util",file:"node_modules\\@metamask\\eth-keyring-controller\\node_modules\\ethjs-util\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js", {"@ethereumjs/tx":"F:\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-sig-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","hdkey":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\hdkey\\lib\\hdkey.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events')
const HDKey = require('hdkey')
const ethUtil = require('ethereumjs-util')
const sigUtil = require('eth-sig-util')
const { TransactionFactory } = require('@ethereumjs/tx')

const pathBase = 'm'
const hdPathString = `${pathBase}/44'/60'/0'`
const type = 'Ledger Hardware'

const BRIDGE_URL = 'https://metamask.github.io/eth-ledger-bridge-keyring'

const MAX_INDEX = 1000
const NETWORK_API_URLS = {
  ropsten: 'http://api-ropsten.etherscan.io',
  kovan: 'http://api-kovan.etherscan.io',
  rinkeby: 'https://api-rinkeby.etherscan.io',
  mainnet: 'https://api.etherscan.io',
}

const CONNECTION_EVENT = 'ledger-connection-change'

class LedgerBridgeKeyring extends EventEmitter {
  constructor (opts = {}) {
    super()
    this.accountDetails = {}
    this.bridgeUrl = null
    this.type = type
    this.page = 0
    this.perPage = 5
    this.unlockedAccount = 0
    this.hdk = new HDKey()
    this.paths = {}
    this.iframe = null
    this.network = 'mainnet'
    this.implementFullBIP44 = false
    this.deserialize(opts)

    this.iframeLoaded = false
    this._setupIframe()

    this.currentMessageId = 0
    this.messageCallbacks = {}
    this._setupListener()
  }

  serialize () {
    return Promise.resolve({
      hdPath: this.hdPath,
      accounts: this.accounts,
      accountDetails: this.accountDetails,
      bridgeUrl: this.bridgeUrl,
      implementFullBIP44: false,
    })
  }

  deserialize (opts = {}) {
    this.hdPath = opts.hdPath || hdPathString
    this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL
    this.accounts = opts.accounts || []
    this.accountDetails = opts.accountDetails || {}
    if (!opts.accountDetails) {
      this._migrateAccountDetails(opts)
    }

    this.implementFullBIP44 = opts.implementFullBIP44 || false

    // Remove accounts that don't have corresponding account details
    this.accounts = this.accounts
      .filter((account) => Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))

    return Promise.resolve()
  }

  _migrateAccountDetails (opts) {
    if (this._isLedgerLiveHdPath() && opts.accountIndexes) {
      for (const account of Object.keys(opts.accountIndexes)) {
        this.accountDetails[account] = {
          bip44: true,
          hdPath: this._getPathForIndex(opts.accountIndexes[account]),
        }
      }
    }

    // try to migrate non-LedgerLive accounts too
    if (!this._isLedgerLiveHdPath()) {
      this.accounts
        .filter((account) => !Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))
        .forEach((account) => {
          try {
            this.accountDetails[ethUtil.toChecksumAddress(account)] = {
              bip44: false,
              hdPath: this._pathFromAddress(account),
            }
          } catch (e) {
            console.log(`failed to migrate account ${account}`)
          }
        })
    }
  }

  isUnlocked () {
    return Boolean(this.hdk && this.hdk.publicKey)
  }

  isConnected () {
    return this.isDeviceConnected
  }

  setAccountToUnlock (index) {
    this.unlockedAccount = parseInt(index, 10)
  }

  setHdPath (hdPath) {
    // Reset HDKey if the path changes
    if (this.hdPath !== hdPath) {
      this.hdk = new HDKey()
    }
    this.hdPath = hdPath
  }

  unlock (hdPath, updateHdk = true) {
    if (this.isUnlocked() && !hdPath) {
      return Promise.resolve('already unlocked')
    }
    const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-unlock',
        params: {
          hdPath: path,
        },
      },
      ({ success, payload }) => {
        if (success) {
          if (updateHdk) {
            this.hdk.publicKey = Buffer.from(payload.publicKey, 'hex')
            this.hdk.chainCode = Buffer.from(payload.chainCode, 'hex')
          }
          resolve(payload.address)
        } else {
          reject(payload.error || new Error('Unknown error'))
        }
      })
    })
  }

  addAccounts (n = 1) {

    return new Promise((resolve, reject) => {
      this.unlock()
        .then(async (_) => {
          const from = this.unlockedAccount
          const to = from + n
          for (let i = from; i < to; i++) {
            const path = this._getPathForIndex(i)
            let address
            if (this._isLedgerLiveHdPath()) {
              address = await this.unlock(path)
            } else {
              address = this._addressFromIndex(pathBase, i)
            }
            this.accountDetails[ethUtil.toChecksumAddress(address)] = {
              // TODO: consider renaming this property, as the current name is misleading
              // It's currently used to represent whether an account uses the Ledger Live path.
              bip44: this._isLedgerLiveHdPath(),
              hdPath: path,
            }

            if (!this.accounts.includes(address)) {
              this.accounts.push(address)
            }
            this.page = 0
          }
          resolve(this.accounts)
        })
        .catch(reject)
    })
  }

  getFirstPage () {
    this.page = 0
    return this.__getPage(1)
  }

  getNextPage () {
    return this.__getPage(1)
  }

  getPreviousPage () {
    return this.__getPage(-1)
  }

  getAccounts () {
    return Promise.resolve(this.accounts.slice())
  }

  removeAccount (address) {
    if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`)
    }
    this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase())
    delete this.accountDetails[ethUtil.toChecksumAddress(address)]
  }

  attemptMakeApp () {
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-make-app',
      }, ({ success, error }) => {
        if (success) {
          resolve(true)
        } else {
          reject(error)
        }
      })
    })
  }

  updateTransportMethod (transportType) {
    return new Promise((resolve, reject) => {
      // If the iframe isn't loaded yet, let's store the desired transportType value and
      // optimistically return a successful promise
      if (!this.iframeLoaded) {
        this.delayedPromise = {
          resolve,
          reject,
          transportType,
        }
        return
      }

      this._sendMessage({
        action: 'ledger-update-transport',
        params: { transportType },
      }, ({ success }) => {
        if (success) {
          resolve(true)
        } else {
          reject(new Error('Ledger transport could not be updated'))
        }
      })
    })
  }

  // tx is an instance of the ethereumjs-transaction class.
  signTransaction (address, tx) {
    let rawTxHex
    // transactions built with older versions of ethereumjs-tx have a
    // getChainId method that newer versions do not. Older versions are mutable
    // while newer versions default to being immutable. Expected shape and type
    // of data for v, r and s differ (Buffer (old) vs BN (new))
    if (typeof tx.getChainId === 'function') {
      // In this version of ethereumjs-tx we must add the chainId in hex format
      // to the initial v value. The chainId must be included in the serialized
      // transaction which is only communicated to ethereumjs-tx in this
      // value. In newer versions the chainId is communicated via the 'Common'
      // object.
      tx.v = ethUtil.bufferToHex(tx.getChainId())
      tx.r = '0x00'
      tx.s = '0x00'

      rawTxHex = tx.serialize().toString('hex')

      return this._signTransaction(address, rawTxHex, (payload) => {
        tx.v = Buffer.from(payload.v, 'hex')
        tx.r = Buffer.from(payload.r, 'hex')
        tx.s = Buffer.from(payload.s, 'hex')
        return tx
      })
    }

    // The below `encode` call is only necessary for legacy transactions, as `getMessageToSign`
    // calls `rlp.encode` internally for non-legacy transactions. As per the "Transaction Execution"
    // section of the ethereum yellow paper, transactions need to be "well-formed RLP, with no additional
    // trailing bytes".

    // Note also that `getMessageToSign` will return valid RLP for all transaction types, whereas the
    // `serialize` method will not for any transaction type except legacy. This is because `serialize` includes
    // empty r, s and v values in the encoded rlp. This is why we use `getMessageToSign` here instead of `serialize`.
    const messageToSign = tx.getMessageToSign(false)

    rawTxHex = Buffer.isBuffer(messageToSign)
      ? messageToSign.toString('hex')
      : ethUtil.rlp.encode(messageToSign).toString('hex')

    return this._signTransaction(address, rawTxHex, (payload) => {
      // Because tx will be immutable, first get a plain javascript object that
      // represents the transaction. Using txData here as it aligns with the
      // nomenclature of ethereumjs/tx.
      const txData = tx.toJSON()
      // The fromTxData utility expects a type to support transactions with a type other than 0
      txData.type = tx.type
      // The fromTxData utility expects v,r and s to be hex prefixed
      txData.v = ethUtil.addHexPrefix(payload.v)
      txData.r = ethUtil.addHexPrefix(payload.r)
      txData.s = ethUtil.addHexPrefix(payload.s)
      // Adopt the 'common' option from the original transaction and set the
      // returned object to be frozen if the original is frozen.
      return TransactionFactory.fromTxData(txData, { common: tx.common, freeze: Object.isFrozen(tx) })
    })
  }

  _signTransaction (address, rawTxHex, handleSigning) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(address)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-transaction',
            params: {
              tx: rawTxHex,
              hdPath,
            },
          },
          ({ success, payload }) => {
            if (success) {

              const newOrMutatedTx = handleSigning(payload)
              const valid = newOrMutatedTx.verifySignature()
              if (valid) {
                resolve(newOrMutatedTx)
              } else {
                reject(new Error('Ledger: The transaction signature is not valid'))
              }
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing transaction'))
            }
          })
        })
        .catch(reject)
    })
  }

  signMessage (withAccount, data) {
    return this.signPersonalMessage(withAccount, data)
  }

  // For personal_sign, we need to prefix the message:
  signPersonalMessage (withAccount, message) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(withAccount)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-personal-message',
            params: {
              hdPath,
              message: ethUtil.stripHexPrefix(message),
            },
          },
          ({ success, payload }) => {
            if (success) {
              let v = parseInt(payload.v, 10)
              v = v.toString(16)
              if (v.length < 2) {
                v = `0${v}`
              }
              const signature = `0x${payload.r}${payload.s}${v}`
              const addressSignedWith = sigUtil.recoverPersonalSignature({ data: message, sig: signature })
              if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
                reject(new Error('Ledger: The signature doesnt match the right address'))
              }
              resolve(signature)
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing message'))
            }
          })
        })
        .catch(reject)
    })
  }

  async unlockAccountByAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    if (!Object.keys(this.accountDetails).includes(checksummedAddress)) {
      throw new Error(`Ledger: Account for address '${checksummedAddress}' not found`)
    }
    const { hdPath } = this.accountDetails[checksummedAddress]
    const unlockedAddress = await this.unlock(hdPath, false)

    // unlock resolves to the address for the given hdPath as reported by the ledger device
    // if that address is not the requested address, then this account belongs to a different device or seed
    if (unlockedAddress.toLowerCase() !== address.toLowerCase()) {
      throw new Error(`Ledger: Account ${address} does not belong to the connected device`)
    }
    return hdPath
  }

  async signTypedData (withAccount, data, options = {}) {
    const isV4 = options.version === 'V4'
    if (!isV4) {
      throw new Error('Ledger: Only version 4 of typed data signing is supported')
    }

    const {
      domain,
      types,
      primaryType,
      message,
    } = sigUtil.TypedDataUtils.sanitizeData(data)
    const domainSeparatorHex = sigUtil.TypedDataUtils.hashStruct('EIP712Domain', domain, types, isV4).toString('hex')
    const hashStructMessageHex = sigUtil.TypedDataUtils.hashStruct(primaryType, message, types, isV4).toString('hex')

    const hdPath = await this.unlockAccountByAddress(withAccount)
    const { success, payload } = await new Promise((resolve) => {
      this._sendMessage({
        action: 'ledger-sign-typed-data',
        params: {
          hdPath,
          domainSeparatorHex,
          hashStructMessageHex,
        },
      },
      (result) => resolve(result))
    })

    if (success) {
      let v = parseInt(payload.v, 10)
      v = v.toString(16)
      if (v.length < 2) {
        v = `0${v}`
      }
      const signature = `0x${payload.r}${payload.s}${v}`
      const addressSignedWith = sigUtil.recoverTypedSignature_v4({
        data,
        sig: signature,
      })
      if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
        throw new Error('Ledger: The signature doesnt match the right address')
      }
      return signature
    }
    throw payload.error || new Error('Ledger: Unknown error while signing message')
  }

  exportAccount () {
    throw new Error('Not supported on this device')
  }

  forgetDevice () {
    this.accounts = []
    this.page = 0
    this.unlockedAccount = 0
    this.paths = {}
    this.accountDetails = {}
    this.hdk = new HDKey()
  }

  /* PRIVATE METHODS */

  _setupIframe () {
    this.iframe = document.createElement('iframe')
    this.iframe.src = this.bridgeUrl
    this.iframe.allow = `hid 'src'`
    this.iframe.onload = async () => {
      // If the ledger live preference was set before the iframe is loaded,
      // set it after the iframe has loaded
      this.iframeLoaded = true
      if (this.delayedPromise) {
        try {
          const result = await this.updateTransportMethod(
            this.delayedPromise.transportType,
          )
          this.delayedPromise.resolve(result)
        } catch (e) {
          this.delayedPromise.reject(e)
        } finally {
          delete this.delayedPromise
        }
      }
    }
    document.head.appendChild(this.iframe)
  }

  _getOrigin () {
    const tmp = this.bridgeUrl.split('/')
    tmp.splice(-1, 1)
    return tmp.join('/')
  }

  _sendMessage (msg, cb) {
    msg.target = 'LEDGER-IFRAME'

    this.currentMessageId += 1
    msg.messageId = this.currentMessageId

    this.messageCallbacks[this.currentMessageId] = cb
    this.iframe.contentWindow.postMessage(msg, '*')
  }

  _setupListener () {
    this._eventListener = ({ origin, data }) => {
      if (origin !== this._getOrigin()) {
        return false
      }

      if (data) {
        if (this.messageCallbacks[data.messageId]) {
          this.messageCallbacks[data.messageId](data)
        } else if (data.action === CONNECTION_EVENT) {
          this.isDeviceConnected = data.payload.connected
        }
      }

      return undefined
    }
    window.addEventListener('message', this._eventListener)
  }

  destroy () {
    window.removeEventListener('message', this._eventListener)
  }

  async __getPage (increment) {

    this.page += increment

    if (this.page <= 0) {
      this.page = 1
    }
    const from = (this.page - 1) * this.perPage
    const to = from + this.perPage

    await this.unlock()
    let accounts
    if (this._isLedgerLiveHdPath()) {
      accounts = await this._getAccountsBIP44(from, to)
    } else {
      accounts = this._getAccountsLegacy(from, to)
    }
    return accounts
  }

  async _getAccountsBIP44 (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const path = this._getPathForIndex(i)
      const address = await this.unlock(path)
      const valid = this.implementFullBIP44 ? await this._hasPreviousTransactions(address) : true
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      // PER BIP44
      // "Software should prevent a creation of an account if
      // a previous account does not have a transaction history
      // (meaning none of its addresses have been used before)."
      if (!valid) {
        break
      }
    }
    return accounts
  }

  _getAccountsLegacy (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const address = this._addressFromIndex(pathBase, i)
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      this.paths[ethUtil.toChecksumAddress(address)] = i
    }
    return accounts
  }

  _padLeftEven (hex) {
    return hex.length % 2 === 0 ? hex : `0${hex}`
  }

  _normalize (buf) {
    return this._padLeftEven(ethUtil.bufferToHex(buf).toLowerCase())
  }

  // eslint-disable-next-line no-shadow
  _addressFromIndex (pathBase, i) {
    const dkey = this.hdk.derive(`${pathBase}/${i}`)
    const address = ethUtil
      .publicToAddress(dkey.publicKey, true)
      .toString('hex')
    return ethUtil.toChecksumAddress(`0x${address}`)
  }

  _pathFromAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    let index = this.paths[checksummedAddress]
    if (typeof index === 'undefined') {
      for (let i = 0; i < MAX_INDEX; i++) {
        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
          index = i
          break
        }
      }
    }

    if (typeof index === 'undefined') {
      throw new Error('Unknown address')
    }
    return this._getPathForIndex(index)
  }

  _toAscii (hex) {
    let str = ''
    let i = 0
    const l = hex.length
    if (hex.substring(0, 2) === '0x') {
      i = 2
    }
    for (; i < l; i += 2) {
      const code = parseInt(hex.substr(i, 2), 16)
      str += String.fromCharCode(code)
    }

    return str
  }

  _getPathForIndex (index) {
    // Check if the path is BIP 44 (Ledger Live)
    return this._isLedgerLiveHdPath() ? `m/44'/60'/${index}'/0/0` : `${this.hdPath}/${index}`
  }

  _isLedgerLiveHdPath () {
    return this.hdPath === `m/44'/60'/0'/0/0`
  }

  _toLedgerPath (path) {
    return path.toString().replace('m/', '')
  }

  async _hasPreviousTransactions (address) {
    const apiUrl = this._getApiUrl()
    const response = await window.fetch(`${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1&offset=1`)
    const parsedResponse = await response.json()
    if (parsedResponse.status !== '0' && parsedResponse.result.length > 0) {
      return true
    }
    return false
  }

  _getApiUrl () {
    return NETWORK_API_URLS[this.network] || NETWORK_API_URLS.mainnet
  }

}

LedgerBridgeKeyring.type = type
module.exports = LedgerBridgeKeyring

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-abi":"F:\\metamask-extension\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js","tweetnacl":"F:\\metamask-extension\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"F:\\metamask-extension\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cindex.js
      return function (require, module, exports) {
const { Buffer } = require('buffer')
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')
const nacl = require('tweetnacl')
nacl.util = require('tweetnacl-util')

const TYPED_MESSAGE_SCHEMA = {
  type: 'object',
  properties: {
    types: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            type: { type: 'string' },
          },
          required: ['name', 'type'],
        },
      },
    },
    primaryType: { type: 'string' },
    domain: { type: 'object' },
    message: { type: 'object' },
  },
  required: ['types', 'primaryType', 'domain', 'message'],
}

/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {

  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData (primaryType, data, types, useV4 = true) {
    const encodedTypes = ['bytes32']
    const encodedValues = [this.hashType(primaryType, types)]

    if (useV4) {
      const encodeField = (name, type, value) => {
        if (types[type] !== undefined) {
          return ['bytes32', value === null || value === undefined ?
            '0x0000000000000000000000000000000000000000000000000000000000000000' :
            ethUtil.keccak(this.encodeData(type, value, types, useV4))]
        }

        if (value === undefined) {
          throw new Error(`missing value for field ${name} of type ${type}`)
        }

        if (type === 'bytes') {
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type === 'string') {
          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
          if (typeof value === 'string') {
            value = Buffer.from(value, 'utf8')
          }
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type.lastIndexOf(']') === type.length - 1) {
          const parsedType = type.slice(0, type.lastIndexOf('['))
          const typeValuePairs = value.map((item) => encodeField(name, parsedType, item))
          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(
            typeValuePairs.map(([_type]) => _type),
            typeValuePairs.map(([, _value]) => _value),
          ))]
        }

        return [type, value]
      }

      for (const field of types[primaryType]) {
        const [type, value] = encodeField(field.name, field.type, data[field.name])
        encodedTypes.push(type)
        encodedValues.push(value)
      }
    } else {
      for (const field of types[primaryType]) {
        let value = data[field.name]
        if (value !== undefined) {
          if (field.type === 'bytes') {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (field.type === 'string') {
            encodedTypes.push('bytes32')
            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
            if (typeof value === 'string') {
              value = Buffer.from(value, 'utf8')
            }
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (types[field.type] !== undefined) {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4))
            encodedValues.push(value)
          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
            throw new Error('Arrays currently unimplemented in encodeData')
          } else {
            encodedTypes.push(field.type)
            encodedValues.push(value)
          }
        }
      }
    }

    return ethAbi.rawEncode(encodedTypes, encodedValues)
  },

  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType (primaryType, types) {
    let result = ''
    let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType)
    deps = [primaryType].concat(deps.sort())
    for (const type of deps) {
      const children = types[type]
      if (!children) {
        throw new Error(`No type definition specified: ${type}`)
      }
      result += `${type}(${types[type].map(({ name, type: _type }) => `${_type} ${name}`).join(',')})`
    }
    return result
  },

  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies (primaryType, types, results = []) {
    const [firstWord] = primaryType.match(/^\w*/u)
    primaryType = firstWord
    if (results.includes(primaryType) || types[primaryType] === undefined) {
      return results
    }
    results.push(primaryType)
    for (const field of types[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types, results)) {
        !results.includes(dep) && results.push(dep)
      }
    }
    return results
  },

  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashStruct (primaryType, data, types, useV4 = true) {
    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4))
  },

  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType (primaryType, types) {
    return ethUtil.keccak(this.encodeType(primaryType, types))
  },

  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData (data) {
    const sanitizedData = {}
    for (const key of Object.keys(TYPED_MESSAGE_SCHEMA.properties)) {
      data[key] && (sanitizedData[key] = data[key])
    }
    if (sanitizedData.types) {
      sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types }
    }
    return sanitizedData
  },

  /**
   * Signs a typed message as per EIP-712 and returns its keccak hash
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - keccak hash of the resulting signed message
   */
  sign (typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData)
    const parts = [Buffer.from('1901', 'hex')]
    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))
    if (sanitizedData.primaryType !== 'EIP712Domain') {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))
    }
    return ethUtil.keccak(Buffer.concat(parts))
  },
}

module.exports = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,

  concatSig (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize (input) {
    if (!input) {
      return undefined
    }

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      let msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ` received ${typeof input}: ${input}`
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign (privateKey, msgParams) {
    const message = ethUtil.toBuffer(msgParams.data)
    const msgHash = ethUtil.hashPersonalMessage(message)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    const serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return `0x${publicKey.toString('hex')}`
  },

  typedSignatureHash (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedDataLegacy (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignatureLegacy (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  encrypt (receiverPublicKey, msgParams, version) {

    switch (version) {
      case 'x25519-xsalsa20-poly1305': {
        if (typeof msgParams.data === 'undefined') {
          throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ')
        }
        // generate ephemeral keypair
        const ephemeralKeyPair = nacl.box.keyPair()

        // assemble encryption parameters - from string to UInt8
        let pubKeyUInt8Array
        try {
          pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey)
        } catch (err) {
          throw new Error('Bad public key')
        }

        const msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data)
        const nonce = nacl.randomBytes(nacl.box.nonceLength)

        // encrypt
        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey)

        // handle encrypted data
        const output = {
          version: 'x25519-xsalsa20-poly1305',
          nonce: nacl.util.encodeBase64(nonce),
          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),
          ciphertext: nacl.util.encodeBase64(encryptedMessage),
        }
        // return encrypted msg data
        return output
      }
      default:
        throw new Error('Encryption type/version not supported')

    }
  },

  encryptSafely (receiverPublicKey, msgParams, version) {

    const DEFAULT_PADDING_LENGTH = (2 ** 11)
    const NACL_EXTRA_BYTES = 16

    const { data } = msgParams
    if (!data) {
      throw new Error('Cannot encrypt empty msg.data')
    }

    if (typeof data === 'object' && data.toJSON) {
      // remove toJSON attack vector
      // TODO, check all possible children
      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property')
    }

    // add padding
    const dataWithPadding = {
      data,
      padding: '',
    }

    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8')
    const modVal = (dataLength % DEFAULT_PADDING_LENGTH)
    let padLength = 0
    // Only pad if necessary
    if (modVal > 0) {
      padLength = (DEFAULT_PADDING_LENGTH - modVal) - NACL_EXTRA_BYTES // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength)

    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) }
    return this.encrypt(receiverPublicKey, paddedMsgParams, version)
  },

  decrypt (encryptedData, receiverPrivateKey) {

    switch (encryptedData.version) {
      case 'x25519-xsalsa20-poly1305': {
        // string to buffer to UInt8Array
        const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey)
        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey

        // assemble decryption parameters
        const nonce = nacl.util.decodeBase64(encryptedData.nonce)
        const ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext)
        const ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey)

        // decrypt
        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey)

        // return decrypted msg data
        let output
        try {
          output = nacl.util.encodeUTF8(decryptedMessage)
        } catch (err) {
          throw new Error('Decryption failed.')
        }

        if (output) {
          return output
        }
        throw new Error('Decryption failed.')
      }

      default:
        throw new Error('Encryption type/version not supported.')
    }
  },

  decryptSafely (encryptedData, receiverPrivateKey) {
    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey))
    return dataWithPadding.data
  },


  getEncryptionPublicKey (privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey)
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey
    return nacl.util.encodeBase64(encryptionPublicKey)
  },


  /**
   * A generic entry point for all typed data methods to be passed, includes a version parameter.
   */
  signTypedMessage (privateKey, msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.signTypedDataLegacy(privateKey, msgParams)
      case 'V3':
        return this.signTypedData(privateKey, msgParams)
      case 'V4':
      default:
        return this.signTypedData_v4(privateKey, msgParams)
    }
  },

  recoverTypedMessage (msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.recoverTypedSignatureLegacy(msgParams)
      case 'V3':
        return this.recoverTypedSignature(msgParams)
      case 'V4':
      default:
        return this.recoverTypedSignature_v4(msgParams)
    }
  },

  signTypedData (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  signTypedData_v4 (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  recoverTypedSignature_v4 (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash (typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) {
    throw error
  }

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) {
    return e.type
  })
  const schema = typedData.map(function (e) {
    if (!e.name) {
      throw error
    }
    return `${e.type} ${e.name}`
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data),
    ],
  )
}

function recoverPublicKey (hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  let myString = `${number}`
  while (myString.length < length) {
    myString = `0${myString}`
  }
  return myString
}

// converts hex strings to the Uint8Array format used by nacl
function nacl_decodeHex (msgHex) {
  const msgBase64 = (Buffer.from(msgHex, 'hex')).toString('base64')
  return nacl.util.decodeBase64(msgBase64)
}



      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js", {"./secp256k1-adapter":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js","assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","bn.js":"F:\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","create-hash":"F:\\metamask-extension\\node_modules\\create-hash\\browser.js","ethereum-cryptography/keccak":"F:\\metamask-extension\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethjs-util\\lib\\index.js","rlp":"F:\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Cindex.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('ethereum-cryptography/keccak'),
    keccak224 = _require.keccak224,
    keccak384 = _require.keccak384,
    k256 = _require.keccak256,
    keccak512 = _require.keccak512;

var secp256k1 = require('./secp256k1-adapter');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  switch (bits) {
    case 224:
      {
        return keccak224(a);
      }
    case 256:
      {
        return k256(a);
      }
    case 384:
      {
        return keccak384(a);
      }
    case 512:
      {
        return keccak512(a);
      }
    default:
      {
        throw new Error('Invald algorithm: keccak' + bits);
      }
  }
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js", {"./secp256k1-lib/der":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js","./secp256k1-lib/index":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"F:\\metamask-extension\\node_modules\\ethereum-cryptography\\secp256k1.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var secp256k1 = require('ethereum-cryptography/secp256k1');

function getSecp256k1 () { return require('./secp256k1-lib/index'); }
var der = require('./secp256k1-lib/der');

/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
var privateKeyVerify = function privateKeyVerify(privateKey) {
  // secp256k1 v4 version throws when privateKey length is not 32
  if (privateKey.length !== 32) {
    return false;
  }

  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};

/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
var privateKeyExport = function privateKeyExport(privateKey, compressed) {
  var secp256k1v3 = getSecp256k1();
  // privateKeyExport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);

  return der.privateKeyExport(privateKey, publicKey, compressed);
};

/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */

var privateKeyImport = function privateKeyImport(privateKey) {
  // privateKeyImport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  privateKey = der.privateKeyImport(privateKey);
  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
    return privateKey;
  }

  throw new Error("couldn't import from DER format");
};

/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyNegate = function privateKeyNegate(privateKey) {
  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};

/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyModInverse = function privateKeyModInverse(privateKey) {
  if (privateKey.length !== 32) {
    throw new Error('private key length is invalid');
  }
  var secp256k1v3 = getSecp256k1();
  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};

/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};

/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};

/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {
  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};

/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {
  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};

/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var publicKeyVerify = function publicKeyVerify(publicKey) {
  // secp256k1 v4 version throws when publicKey length is not 33 or 65
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    return false;
  }

  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};

/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {
  var keys = [];
  publicKeys.forEach(function (publicKey) {
    keys.push(Uint8Array.from(publicKey));
  });

  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};

/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureNormalize = function signatureNormalize(signature) {
  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};

/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureExport = function signatureExport(signature) {
  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImport = function signatureImport(signature) {
  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImportLax = function signatureImportLax(signature) {
  // signatureImportLax method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure that signature is greater than 0
  if (signature.length === 0) {
    throw new RangeError('signature length is invalid');
  }
  var secp256k1v3 = getSecp256k1();

  var sigObj = der.signatureImportLax(signature);
  if (sigObj === null) {
    throw new Error("couldn't parse DER signature");
  }

  return secp256k1v3.signatureImport(sigObj);
};

/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
var sign = function sign(message, privateKey, options) {
  if (options === null) {
    throw new TypeError('options should be an Object');
  }

  var signOptions = void 0;

  if (options) {
    signOptions = {};

    if (options.data === null) {
      throw new TypeError('options.data should be a Buffer');
    }

    if (options.data) {
      // validate option.data length
      if (options.data.length !== 32) {
        throw new RangeError('options.data length is invalid');
      }

      signOptions.data = new Uint8Array(options.data);
    }

    if (options.noncefn === null) {
      throw new TypeError('options.noncefn should be a Function');
    }

    if (options.noncefn) {
      //  convert option.noncefn function signature
      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
        var bufferAlgo = algo != null ? Buffer.from(algo) : null;
        var bufferData = data != null ? Buffer.from(data) : null;

        var buffer = Buffer.from('');

        if (options.noncefn) {
          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
        }

        return Uint8Array.from(buffer);
      };
    }
  }

  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);

  return {
    signature: Buffer.from(sig.signature),
    recovery: sig.recid
  };
};

/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var verify = function verify(message, signature, publicKey) {
  // note: secp256k1 v4 verify method has a different argument order
  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};

/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
var recover = function recover(message, signature, recid, compressed) {
  // note: secp256k1 v4 recover method has a different argument order
  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};

/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var ecdh = function ecdh(publicKey, privateKey) {
  // note: secp256k1 v3 doesn't allow optional parameter
  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};

/**
 * Compute an EC Diffie-Hellman secret and return public key as result
 * @method ecdhUnsafe
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {
  // ecdhUnsafe method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure valid publicKey length
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    throw new RangeError('public key length is invalid');
  }

  // ensure valid privateKey length
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }
  var secp256k1v3 = getSecp256k1();

  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

module.exports = {
  privateKeyVerify: privateKeyVerify,
  privateKeyExport: privateKeyExport,
  privateKeyImport: privateKeyImport,
  privateKeyNegate: privateKeyNegate,
  privateKeyModInverse: privateKeyModInverse,
  privateKeyTweakAdd: privateKeyTweakAdd,
  privateKeyTweakMul: privateKeyTweakMul,

  publicKeyCreate: publicKeyCreate,
  publicKeyConvert: publicKeyConvert,
  publicKeyVerify: publicKeyVerify,
  publicKeyTweakAdd: publicKeyTweakAdd,
  publicKeyTweakMul: publicKeyTweakMul,
  publicKeyCombine: publicKeyCombine,

  signatureNormalize: signatureNormalize,
  signatureExport: signatureExport,
  signatureImport: signatureImport,
  signatureImportLax: signatureImportLax,

  sign: sign,
  verify: verify,
  recover: recover,

  ecdh: ecdh,
  ecdhUnsafe: ecdhUnsafe
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1-lib%5Cder.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
// begin
0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
// begin
0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length;

  // sequence header
  var index = 0;
  if (length < index + 1 || privateKey[index] !== 0x30) return null;
  index += 1;

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return null;

  var lenb = privateKey[index] & 0x7f;
  index += 1;
  if (lenb < 1 || lenb > 2) return null;
  if (length < index + lenb) return null;

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
  index += lenb;
  if (length < index + len) return null;

  // sequence element 0: version number (=1)
  if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
    return null;
  }
  index += 3;

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
    return null;
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};

exports.signatureImportLax = function (signature) {
  var r = Buffer.alloc(32, 0);
  var s = Buffer.alloc(32, 0);

  var length = signature.length;
  var index = 0;

  // sequence tag byte
  if (signature[index++] !== 0x30) {
    return null;
  }

  // sequence length byte
  var lenbyte = signature[index++];
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80;
    if (index > length) {
      return null;
    }
  }

  // sequence tag byte for r
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for r
  var rlen = signature[index++];
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      rlen = (rlen << 8) + signature[index];
    }
  }
  if (rlen > length - index) {
    return null;
  }
  var rindex = index;
  index += rlen;

  // sequence tag byte for s
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for s
  var slen = signature[index++];
  if (slen & 0x80) {
    lenbyte = slen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      slen = (slen << 8) + signature[index];
    }
  }
  if (slen > length - index) {
    return null;
  }
  var sindex = index;
  index += slen;

  // ignore leading zeros in r
  for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1) {}
  // copy r value
  if (rlen > 32) {
    return null;
  }
  var rvalue = signature.slice(rindex, rindex + rlen);
  rvalue.copy(r, 32 - rvalue.length);

  // ignore leading zeros in s
  for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1) {}
  // copy s value
  if (slen > 32) {
    return null;
  }
  var svalue = signature.slice(sindex, sindex + slen);
  svalue.copy(s, 32 - svalue.length);

  return { r: r, s: s };
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js", {"bn.js":"F:\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","elliptic":"F:\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Ceth-sig-util%5Cnode_modules%5Cethereumjs-util%5Cdist%5Csecp256k1-lib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var BN = require('bn.js');
var EC = require('elliptic').ec;

var ec = new EC('secp256k1');
var ecparams = ec.curve;

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey);
  if (d.ucmp(ecparams.n) >= 0) {
    throw new Error('couldn\'t export to DER format');
  }

  var point = ec.g.mul(d);
  return toPublicKey(point.getX(), point.getY(), compressed);
};

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey);
  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
    throw new Error('private key range is invalid');
  }

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r);
  if (r.ucmp(ecparams.n) >= 0) {
    r = new BN(0);
  }

  var s = new BN(sigObj.s);
  if (s.ucmp(ecparams.n) >= 0) {
    s = new BN(0);
  }

  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var point = ec.keyFromPublic(publicKey);

  var scalar = new BN(privateKey);
  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
    throw new Error('scalar was invalid (zero or overflow)');
  }

  var shared = point.pub.mul(scalar);
  return toPublicKey(shared.getX(), shared.getY(), compressed);
};

var toPublicKey = function toPublicKey(x, y, compressed) {
  var publicKey = void 0;

  if (compressed) {
    publicKey = Buffer.alloc(33);
    publicKey[0] = y.isOdd() ? 0x03 : 0x02;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
  } else {
    publicKey = Buffer.alloc(65);
    publicKey[0] = 0x04;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
  }

  return publicKey;
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"F:\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"F:\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Cethjs-util%5Clib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util>ethjs-util",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethjs-util\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\hdkey\\lib\\hdkey.js", {"assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","coinstring":"F:\\metamask-extension\\node_modules\\coinstring\\lib\\coinstring.js","crypto":"F:\\metamask-extension\\node_modules\\crypto-browserify\\index.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js","secp256k1":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Chdkey%5Clib%5Chdkey.js
      return function (require, module, exports) {
var assert = require('assert')
var Buffer = require('safe-buffer').Buffer
var crypto = require('crypto')
var cs = require('coinstring')
var secp256k1 = require('secp256k1')

var MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')
var HARDENED_OFFSET = 0x80000000
var LEN = 78

// Bitcoin hardcoded by default, can use package `coininfo` for others
var BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}

function HDKey (versions) {
  this.versions = versions || BITCOIN_VERSIONS
  this.depth = 0
  this.index = 0
  this._privateKey = null
  this._publicKey = null
  this.chainCode = null
  this._fingerprint = 0
  this.parentFingerprint = 0
}

Object.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })
Object.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })
Object.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })

Object.defineProperty(HDKey.prototype, 'privateKey', {
  get: function () {
    return this._privateKey
  },
  set: function (value) {
    assert.equal(value.length, 32, 'Private key must be 32 bytes.')
    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')

    this._privateKey = value
    this._publicKey = secp256k1.publicKeyCreate(value, true)
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
  }
})

Object.defineProperty(HDKey.prototype, 'publicKey', {
  get: function () {
    return this._publicKey
  },
  set: function (value) {
    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')
    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')

    this._publicKey = secp256k1.publicKeyConvert(value, true) // force compressed point
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
    this._privateKey = null
  }
})

Object.defineProperty(HDKey.prototype, 'privateExtendedKey', {
  get: function () {
    if (this._privateKey) return cs.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))
    else return null
  }
})

Object.defineProperty(HDKey.prototype, 'publicExtendedKey', {
  get: function () {
    return cs.encode(serialize(this, this.versions.public, this.publicKey))
  }
})

HDKey.prototype.derive = function (path) {
  if (path === 'm' || path === 'M' || path === "m'" || path === "M'") {
    return this
  }

  var entries = path.split('/')
  var hdkey = this
  entries.forEach(function (c, i) {
    if (i === 0) {
      assert(c, 'm', 'Invalid path')
      return
    }

    var hardened = (c.length > 1) && (c[c.length - 1] === "'")
    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)
    assert(childIndex < HARDENED_OFFSET, 'Invalid index')
    if (hardened) childIndex += HARDENED_OFFSET

    hdkey = hdkey.deriveChild(childIndex)
  })

  return hdkey
}

HDKey.prototype.deriveChild = function (index) {
  var isHardened = index >= HARDENED_OFFSET
  var indexBuffer = Buffer.allocUnsafe(4)
  indexBuffer.writeUInt32BE(index, 0)

  var data

  if (isHardened) { // Hardened child
    assert(this.privateKey, 'Could not derive hardened child key')

    var pk = this.privateKey
    var zb = Buffer.alloc(1, 0)
    pk = Buffer.concat([zb, pk])

    // data = 0x00 || ser256(kpar) || ser32(index)
    data = Buffer.concat([pk, indexBuffer])
  } else { // Normal child
    // data = serP(point(kpar)) || ser32(index)
    //      = serP(Kpar) || ser32(index)
    data = Buffer.concat([this.publicKey, indexBuffer])
  }

  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hd = new HDKey(this.versions)

  // Private parent key -> private child key
  if (this.privateKey) {
    // ki = parse256(IL) + kpar (mod n)
    try {
      hd.privateKey = secp256k1.privateKeyTweakAdd(this.privateKey, IL)
      // throw if IL >= n || (privateKey + IL) === 0
    } catch (err) {
      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i
      return this.derive(index + 1)
    }
  // Public parent key -> public child key
  } else {
    // Ki = point(parse256(IL)) + Kpar
    //    = G*IL + Kpar
    try {
      hd.publicKey = secp256k1.publicKeyTweakAdd(this.publicKey, IL, true)
      // throw if IL >= n || (g**IL + publicKey) is infinity
    } catch (err) {
      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i
      return this.derive(index + 1, isHardened)
    }
  }

  hd.chainCode = IR
  hd.depth = this.depth + 1
  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)
  hd.index = index

  return hd
}

HDKey.prototype.sign = function (hash) {
  return secp256k1.sign(hash, this.privateKey).signature
}

HDKey.prototype.verify = function (hash, signature) {
  return secp256k1.verify(hash, signature, this.publicKey)
}

HDKey.prototype.toJSON = function () {
  return {
    xpriv: this.privateExtendedKey,
    xpub: this.publicExtendedKey
  }
}

HDKey.fromMasterSeed = function (seedBuffer, versions) {
  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hdkey = new HDKey(versions)
  hdkey.chainCode = IR
  hdkey.privateKey = IL

  return hdkey
}

HDKey.fromExtendedKey = function (base58key, versions) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  versions = versions || BITCOIN_VERSIONS
  var hdkey = new HDKey(versions)

  var keyBuffer = cs.decode(base58key)

  var version = keyBuffer.readUInt32BE(0)
  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')

  hdkey.depth = keyBuffer.readUInt8(4)
  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)
  hdkey.index = keyBuffer.readUInt32BE(9)
  hdkey.chainCode = keyBuffer.slice(13, 45)

  var key = keyBuffer.slice(45)
  if (key.readUInt8(0) === 0) { // private
    assert(version === versions.private, 'Version mismatch: version does not match private')
    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte
  } else {
    assert(version === versions.public, 'Version mismatch: version does not match public')
    hdkey.publicKey = key
  }

  return hdkey
}

HDKey.fromJSON = function (obj) {
  return HDKey.fromExtendedKey(obj.xpriv)
}

function serialize (hdkey, version, key) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  var buffer = Buffer.allocUnsafe(LEN)

  buffer.writeUInt32BE(version, 0)
  buffer.writeUInt8(hdkey.depth, 4)

  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000
  buffer.writeUInt32BE(fingerprint, 5)
  buffer.writeUInt32BE(hdkey.index, 9)

  hdkey.chainCode.copy(buffer, 13)
  key.copy(buffer, 45)

  return buffer
}

function hash160 (buf) {
  var sha = crypto.createHash('sha256').update(buf).digest()
  return crypto.createHash('rmd160').update(sha).digest()
}

HDKey.HARDENED_OFFSET = HARDENED_OFFSET
module.exports = HDKey

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\hdkey\\lib\\hdkey.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\elliptic.js", {"./lib":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\index.js","./lib/elliptic":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Csecp256k1%5Celliptic.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib')(require('./lib/elliptic'))

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\elliptic.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\assert.js", {"../../../../../is-buffer/index.js":"F:\\metamask-extension\\node_modules\\is-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Csecp256k1%5Clib%5Cassert.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'
var toString = Object.prototype.toString

// TypeError
exports.isArray = function (value, message) {
  if (!Array.isArray(value)) throw TypeError(message)
}

exports.isBoolean = function (value, message) {
  if (toString.call(value) !== '[object Boolean]') throw TypeError(message)
}

exports.isBuffer = function (value, message) {
  if (!Buffer.isBuffer(value)) throw TypeError(message)
}

exports.isFunction = function (value, message) {
  if (toString.call(value) !== '[object Function]') throw TypeError(message)
}

exports.isNumber = function (value, message) {
  if (toString.call(value) !== '[object Number]') throw TypeError(message)
}

exports.isObject = function (value, message) {
  if (toString.call(value) !== '[object Object]') throw TypeError(message)
}

// RangeError
exports.isBufferLength = function (buffer, length, message) {
  if (buffer.length !== length) throw RangeError(message)
}

exports.isBufferLength2 = function (buffer, length1, length2, message) {
  if (buffer.length !== length1 && buffer.length !== length2) throw RangeError(message)
}

exports.isLengthGTZero = function (value, message) {
  if (value.length === 0) throw RangeError(message)
}

exports.isNumberInInterval = function (number, x, y, message) {
  if (number <= x || number >= y) throw RangeError(message)
}

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\assert.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\der.js", {"bip66":"F:\\metamask-extension\\node_modules\\bip66\\index.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Csecp256k1%5Clib%5Cder.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var bip66 = require('bip66')

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
  // begin
  0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x21, 0x02, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
  // begin
  0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x41, 0x04, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0E, 0x11,
  0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10,
  0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED)
  privateKey.copy(result, compressed ? 8 : 9)
  publicKey.copy(result, compressed ? 181 : 214)
  return result
}

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length

  // sequence header
  var index = 0
  if (length < index + 1 || privateKey[index] !== 0x30) return
  index += 1

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return

  var lenb = privateKey[index] & 0x7f
  index += 1
  if (lenb < 1 || lenb > 2) return
  if (length < index + lenb) return

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0)
  index += lenb
  if (length < index + len) return

  // sequence element 0: version number (=1)
  if (length < index + 3 ||
      privateKey[index] !== 0x02 ||
      privateKey[index + 1] !== 0x01 ||
      privateKey[index + 2] !== 0x01) {
    return
  }
  index += 3

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 ||
      privateKey[index] !== 0x04 ||
      privateKey[index + 1] > 0x20 ||
      length < index + 2 + privateKey[index + 1]) {
    return
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1])
}

exports.signatureExport = function (sigObj) {
  var r = Buffer.concat([Buffer.from([0]), sigObj.r])
  for (var lenR = 33, posR = 0; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

  var s = Buffer.concat([Buffer.from([0]), sigObj.s])
  for (var lenS = 33, posS = 0; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

  return bip66.encode(r.slice(posR), s.slice(posS))
}

exports.signatureImport = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  try {
    var sigObj = bip66.decode(sig)
    if (sigObj.r.length === 33 && sigObj.r[0] === 0x00) sigObj.r = sigObj.r.slice(1)
    if (sigObj.r.length > 32) throw new Error('R length is too long')
    if (sigObj.s.length === 33 && sigObj.s[0] === 0x00) sigObj.s = sigObj.s.slice(1)
    if (sigObj.s.length > 32) throw new Error('S length is too long')
  } catch (err) {
    return
  }

  sigObj.r.copy(r, 32 - sigObj.r.length)
  sigObj.s.copy(s, 32 - sigObj.s.length)

  return { r: r, s: s }
}

exports.signatureImportLax = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  var length = sig.length
  var index = 0

  // sequence tag byte
  if (sig[index++] !== 0x30) return

  // sequence length byte
  var lenbyte = sig[index++]
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80
    if (index > length) return
  }

  // sequence tag byte for r
  if (sig[index++] !== 0x02) return

  // length for r
  var rlen = sig[index++]
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) rlen = (rlen << 8) + sig[index]
  }
  if (rlen > length - index) return
  var rindex = index
  index += rlen

  // sequence tag byte for s
  if (sig[index++] !== 0x02) return

  // length for s
  var slen = sig[index++]
  if (slen & 0x80) {
    lenbyte = slen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) slen = (slen << 8) + sig[index]
  }
  if (slen > length - index) return
  var sindex = index
  index += slen

  // ignore leading zeros in r
  for (; rlen > 0 && sig[rindex] === 0x00; rlen -= 1, rindex += 1);
  // copy r value
  if (rlen > 32) return
  var rvalue = sig.slice(rindex, rindex + rlen)
  rvalue.copy(r, 32 - rvalue.length)

  // ignore leading zeros in s
  for (; slen > 0 && sig[sindex] === 0x00; slen -= 1, sindex += 1);
  // copy s value
  if (slen > 32) return
  var svalue = sig.slice(sindex, sindex + slen)
  svalue.copy(s, 32 - svalue.length)

  return { r: r, s: s }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\der.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js", {"../messages.json":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json","bn.js":"F:\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","create-hash":"F:\\metamask-extension\\node_modules\\create-hash\\browser.js","elliptic":"F:\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Csecp256k1%5Clib%5Celliptic%5Cindex.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var createHash = require('create-hash')
var BN = require('bn.js')
var EC = require('elliptic').ec

var messages = require('../messages.json')

var ec = new EC('secp256k1')
var ecparams = ec.curve

function loadCompressedPublicKey (first, xBuffer) {
  var x = new BN(xBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xBuffer, yBuffer) {
  var x = new BN(xBuffer)
  var y = new BN(yBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  var x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (publicKey) {
  var first = publicKey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (publicKey.length !== 33) return null
      return loadCompressedPublicKey(first, publicKey.slice(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (publicKey.length !== 65) return null
      return loadUncompressedPublicKey(first, publicKey.slice(1, 33), publicKey.slice(33, 65))
    default:
      return null
  }
}

exports.privateKeyVerify = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.cmp(ecparams.n) < 0 && !bn.isZero()
}

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.privateKeyNegate = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.isZero() ? Buffer.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID)

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakAdd = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  bn.iadd(new BN(privateKey))
  if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
  if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakMul = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL)

  bn.imul(new BN(privateKey))
  if (bn.cmp(ecparams.n)) bn = bn.umod(ecparams.n)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.publicKeyCreate = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.publicKeyConvert = function (publicKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return Buffer.from(pair.getPublic(compressed, true))
}

exports.publicKeyVerify = function (publicKey) {
  return loadPublicKey(publicKey) !== null
}

exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  var point = ecparams.g.mul(tweak).add(pair.pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL)

  return Buffer.from(pair.pub.mul(tweak).encode(true, compressed))
}

exports.publicKeyCombine = function (publicKeys, compressed) {
  var pairs = new Array(publicKeys.length)
  for (var i = 0; i < publicKeys.length; ++i) {
    pairs[i] = loadPublicKey(publicKeys[i])
    if (pairs[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)
  }

  var point = pairs[0].pub
  for (var j = 1; j < pairs.length; ++j) point = point.add(pairs[j].pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.signatureNormalize = function (signature) {
  var r = new BN(signature.slice(0, 32))
  var s = new BN(signature.slice(32, 64))
  if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  var result = Buffer.from(signature)
  if (s.cmp(ec.nh) === 1) ecparams.n.sub(s).toArrayLike(Buffer, 'be', 32).copy(result, 32)

  return result
}

exports.signatureExport = function (signature) {
  var r = signature.slice(0, 32)
  var s = signature.slice(32, 64)
  if (new BN(r).cmp(ecparams.n) >= 0 || new BN(s).cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  return { r: r, s: s }
}

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r)
  if (r.cmp(ecparams.n) >= 0) r = new BN(0)

  var s = new BN(sigObj.s)
  if (s.cmp(ecparams.n) >= 0) s = new BN(0)

  return Buffer.concat([
    r.toArrayLike(Buffer, 'be', 32),
    s.toArrayLike(Buffer, 'be', 32)
  ])
}

exports.sign = function (message, privateKey, noncefn, data) {
  if (typeof noncefn === 'function') {
    var getNonce = noncefn
    noncefn = function (counter) {
      var nonce = getNonce(message, privateKey, null, data, counter)
      if (!Buffer.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL)

      return new BN(nonce)
    }
  }

  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL)

  var result = ec.sign(message, privateKey, { canonical: true, k: noncefn, pers: data })
  return {
    signature: Buffer.concat([
      result.r.toArrayLike(Buffer, 'be', 32),
      result.s.toArrayLike(Buffer, 'be', 32)
    ]),
    recovery: result.recoveryParam
  }
}

exports.verify = function (message, signature, publicKey) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)
  if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return false

  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return ec.verify(message, sigObj, { x: pair.pub.x, y: pair.pub.y })
}

exports.recover = function (message, signature, recovery, compressed) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  try {
    if (sigr.isZero() || sigs.isZero()) throw new Error()

    var point = ec.recoverPubKey(message, sigObj, recovery)
    return Buffer.from(point.encode(true, compressed))
  } catch (err) {
    throw new Error(messages.ECDSA_RECOVER_FAIL)
  }
}

exports.ecdh = function (publicKey, privateKey) {
  var shared = exports.ecdhUnsafe(publicKey, privateKey, true)
  return createHash('sha256').update(shared).digest()
}

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  var scalar = new BN(privateKey)
  if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) throw new Error(messages.ECDH_FAIL)

  return Buffer.from(pair.pub.mul(scalar).encode(true, compressed))
}

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\index.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\assert.js","./der":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\der.js","./messages.json":"F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Csecp256k1%5Clib%5Cindex.js
      return function (require, module, exports) {
'use strict'
var assert = require('./assert')
var der = require('./der')
var messages = require('./messages.json')

function initCompressedValue (value, defaultValue) {
  if (value === undefined) return defaultValue

  assert.isBoolean(value, messages.COMPRESSED_TYPE_INVALID)
  return value
}

module.exports = function (secp256k1) {
  return {
    privateKeyVerify: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)
    },

    privateKeyExport: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)
      var publicKey = secp256k1.privateKeyExport(privateKey, compressed)

      return der.privateKeyExport(privateKey, publicKey, compressed)
    },

    privateKeyImport: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)

      privateKey = der.privateKeyImport(privateKey)
      if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)) return privateKey

      throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL)
    },

    privateKeyNegate: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyNegate(privateKey)
    },

    privateKeyModInverse: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyModInverse(privateKey)
    },

    privateKeyTweakAdd: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakAdd(privateKey, tweak)
    },

    privateKeyTweakMul: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakMul(privateKey, tweak)
    },

    publicKeyCreate: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCreate(privateKey, compressed)
    },

    publicKeyConvert: function (publicKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyConvert(publicKey, compressed)
    },

    publicKeyVerify: function (publicKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      return secp256k1.publicKeyVerify(publicKey)
    },

    publicKeyTweakAdd: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed)
    },

    publicKeyTweakMul: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed)
    },

    publicKeyCombine: function (publicKeys, compressed) {
      assert.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID)
      assert.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID)
      for (var i = 0; i < publicKeys.length; ++i) {
        assert.isBuffer(publicKeys[i], messages.EC_PUBLIC_KEY_TYPE_INVALID)
        assert.isBufferLength2(publicKeys[i], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)
      }

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCombine(publicKeys, compressed)
    },

    signatureNormalize: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      return secp256k1.signatureNormalize(signature)
    },

    signatureExport: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = secp256k1.signatureExport(signature)
      return der.signatureExport(sigObj)
    },

    signatureImport: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImport(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    signatureImportLax: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImportLax(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    sign: function (message, privateKey, options) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      var data = null
      var noncefn = null
      if (options !== undefined) {
        assert.isObject(options, messages.OPTIONS_TYPE_INVALID)

        if (options.data !== undefined) {
          assert.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID)
          assert.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID)
          data = options.data
        }

        if (options.noncefn !== undefined) {
          assert.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID)
          noncefn = options.noncefn
        }
      }

      return secp256k1.sign(message, privateKey, noncefn, data)
    },

    verify: function (message, signature, publicKey) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      return secp256k1.verify(message, signature, publicKey)
    },

    recover: function (message, signature, recovery, compressed) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID)
      assert.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.recover(message, signature, recovery, compressed)
    },

    ecdh: function (publicKey, privateKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.ecdh(publicKey, privateKey)
    },

    ecdhUnsafe: function (publicKey, privateKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed)
    }
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-ledger-bridge-keyring%5Cnode_modules%5Csecp256k1%5Clib%5Cmessages.json
      return function (require, module, exports) {
module.exports={
  "COMPRESSED_TYPE_INVALID": "compressed should be a boolean",
  "EC_PRIVATE_KEY_TYPE_INVALID": "private key should be a Buffer",
  "EC_PRIVATE_KEY_LENGTH_INVALID": "private key length is invalid",
  "EC_PRIVATE_KEY_RANGE_INVALID": "private key range is invalid",
  "EC_PRIVATE_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting private key is invalid",
  "EC_PRIVATE_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PRIVATE_KEY_EXPORT_DER_FAIL": "couldn't export to DER format",
  "EC_PRIVATE_KEY_IMPORT_DER_FAIL": "couldn't import from DER format",
  "EC_PUBLIC_KEYS_TYPE_INVALID": "public keys should be an Array",
  "EC_PUBLIC_KEYS_LENGTH_INVALID": "public keys Array should have at least 1 element",
  "EC_PUBLIC_KEY_TYPE_INVALID": "public key should be a Buffer",
  "EC_PUBLIC_KEY_LENGTH_INVALID": "public key length is invalid",
  "EC_PUBLIC_KEY_PARSE_FAIL": "the public key could not be parsed or is invalid",
  "EC_PUBLIC_KEY_CREATE_FAIL": "private was invalid, try again",
  "EC_PUBLIC_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting public key is invalid",
  "EC_PUBLIC_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PUBLIC_KEY_COMBINE_FAIL": "the sum of the public keys is not valid",
  "ECDH_FAIL": "scalar was invalid (zero or overflow)",
  "ECDSA_SIGNATURE_TYPE_INVALID": "signature should be a Buffer",
  "ECDSA_SIGNATURE_LENGTH_INVALID": "signature length is invalid",
  "ECDSA_SIGNATURE_PARSE_FAIL": "couldn't parse signature",
  "ECDSA_SIGNATURE_PARSE_DER_FAIL": "couldn't parse DER signature",
  "ECDSA_SIGNATURE_SERIALIZE_DER_FAIL": "couldn't serialize signature to DER format",
  "ECDSA_SIGN_FAIL": "nonce generation function failed or private key is invalid",
  "ECDSA_RECOVER_FAIL": "couldn't recover public key from signature",
  "MSG32_TYPE_INVALID": "message should be a Buffer",
  "MSG32_LENGTH_INVALID": "message length is invalid",
  "OPTIONS_TYPE_INVALID": "options should be an Object",
  "OPTIONS_DATA_TYPE_INVALID": "options.data should be a Buffer",
  "OPTIONS_DATA_LENGTH_INVALID": "options.data length is invalid",
  "OPTIONS_NONCEFN_TYPE_INVALID": "options.noncefn should be a Function",
  "RECOVERY_ID_TYPE_INVALID": "recovery should be a Number",
  "RECOVERY_ID_VALUE_INVALID": "recovery should have value between -1 and 4",
  "TWEAK_TYPE_INVALID": "tweak should be a Buffer",
  "TWEAK_LENGTH_INVALID": "tweak length is invalid"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\encryption.js", {"./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","tweetnacl":"F:\\metamask-extension\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"F:\\metamask-extension\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Cencryption.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEncryptionPublicKey = exports.decryptSafely = exports.decrypt = exports.encryptSafely = exports.encrypt = void 0;
const nacl = __importStar(require("tweetnacl"));
const naclUtil = __importStar(require("tweetnacl-util"));
const utils_1 = require("./utils");
/**
 * Encrypt a message.
 *
 * @param options - The encryption options.
 * @param options.publicKey - The public key of the message recipient.
 * @param options.data - The message data.
 * @param options.version - The type of encryption to use.
 * @returns The encrypted data.
 */
function encrypt({ publicKey, data, version, }) {
    if ((0, utils_1.isNullish)(publicKey)) {
        throw new Error('Missing publicKey parameter');
    }
    else if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(version)) {
        throw new Error('Missing version parameter');
    }
    switch (version) {
        case 'x25519-xsalsa20-poly1305': {
            if (typeof data !== 'string') {
                throw new Error('Message data must be given as a string');
            }
            // generate ephemeral keypair
            const ephemeralKeyPair = nacl.box.keyPair();
            // assemble encryption parameters - from string to UInt8
            let pubKeyUInt8Array;
            try {
                pubKeyUInt8Array = naclUtil.decodeBase64(publicKey);
            }
            catch (err) {
                throw new Error('Bad public key');
            }
            const msgParamsUInt8Array = naclUtil.decodeUTF8(data);
            const nonce = nacl.randomBytes(nacl.box.nonceLength);
            // encrypt
            const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey);
            // handle encrypted data
            const output = {
                version: 'x25519-xsalsa20-poly1305',
                nonce: naclUtil.encodeBase64(nonce),
                ephemPublicKey: naclUtil.encodeBase64(ephemeralKeyPair.publicKey),
                ciphertext: naclUtil.encodeBase64(encryptedMessage),
            };
            // return encrypted msg data
            return output;
        }
        default:
            throw new Error('Encryption type/version not supported');
    }
}
exports.encrypt = encrypt;
/**
 * Encrypt a message in a way that obscures the message length.
 *
 * The message is padded to a multiple of 2048 before being encrypted so that the length of the
 * resulting encrypted message can't be used to guess the exact length of the original message.
 *
 * @param options - The encryption options.
 * @param options.publicKey - The public key of the message recipient.
 * @param options.data - The message data.
 * @param options.version - The type of encryption to use.
 * @returns The encrypted data.
 */
function encryptSafely({ publicKey, data, version, }) {
    if ((0, utils_1.isNullish)(publicKey)) {
        throw new Error('Missing publicKey parameter');
    }
    else if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(version)) {
        throw new Error('Missing version parameter');
    }
    const DEFAULT_PADDING_LENGTH = 2 ** 11;
    const NACL_EXTRA_BYTES = 16;
    if (typeof data === 'object' && data && 'toJSON' in data) {
        // remove toJSON attack vector
        // TODO, check all possible children
        throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property');
    }
    // add padding
    const dataWithPadding = {
        data,
        padding: '',
    };
    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8');
    const modVal = dataLength % DEFAULT_PADDING_LENGTH;
    let padLength = 0;
    // Only pad if necessary
    if (modVal > 0) {
        padLength = DEFAULT_PADDING_LENGTH - modVal - NACL_EXTRA_BYTES; // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength);
    const paddedMessage = JSON.stringify(dataWithPadding);
    return encrypt({ publicKey, data: paddedMessage, version });
}
exports.encryptSafely = encryptSafely;
/**
 * Decrypt a message.
 *
 * @param options - The decryption options.
 * @param options.encryptedData - The encrypted data.
 * @param options.privateKey - The private key to decrypt with.
 * @returns The decrypted message.
 */
function decrypt({ encryptedData, privateKey, }) {
    if ((0, utils_1.isNullish)(encryptedData)) {
        throw new Error('Missing encryptedData parameter');
    }
    else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error('Missing privateKey parameter');
    }
    switch (encryptedData.version) {
        case 'x25519-xsalsa20-poly1305': {
            // string to buffer to UInt8Array
            const receiverPrivateKeyUint8Array = naclDecodeHex(privateKey);
            const receiverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(receiverPrivateKeyUint8Array).secretKey;
            // assemble decryption parameters
            const nonce = naclUtil.decodeBase64(encryptedData.nonce);
            const ciphertext = naclUtil.decodeBase64(encryptedData.ciphertext);
            const ephemPublicKey = naclUtil.decodeBase64(encryptedData.ephemPublicKey);
            // decrypt
            const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, receiverEncryptionPrivateKey);
            // return decrypted msg data
            try {
                if (!decryptedMessage) {
                    throw new Error();
                }
                const output = naclUtil.encodeUTF8(decryptedMessage);
                // TODO: This is probably extraneous but was kept to minimize changes during refactor
                if (!output) {
                    throw new Error();
                }
                return output;
            }
            catch (err) {
                if (err && typeof err.message === 'string' && err.message.length) {
                    throw new Error(`Decryption failed: ${err.message}`);
                }
                throw new Error(`Decryption failed.`);
            }
        }
        default:
            throw new Error('Encryption type/version not supported.');
    }
}
exports.decrypt = decrypt;
/**
 * Decrypt a message that has been encrypted using `encryptSafely`.
 *
 * @param options - The decryption options.
 * @param options.encryptedData - The encrypted data.
 * @param options.privateKey - The private key to decrypt with.
 * @returns The decrypted message.
 */
function decryptSafely({ encryptedData, privateKey, }) {
    if ((0, utils_1.isNullish)(encryptedData)) {
        throw new Error('Missing encryptedData parameter');
    }
    else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error('Missing privateKey parameter');
    }
    const dataWithPadding = JSON.parse(decrypt({ encryptedData, privateKey }));
    return dataWithPadding.data;
}
exports.decryptSafely = decryptSafely;
/**
 * Get the encryption public key for the given key.
 *
 * @param privateKey - The private key to generate the encryption public key with.
 * @returns The encryption public key.
 */
function getEncryptionPublicKey(privateKey) {
    const privateKeyUint8Array = naclDecodeHex(privateKey);
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey;
    return naclUtil.encodeBase64(encryptionPublicKey);
}
exports.getEncryptionPublicKey = getEncryptionPublicKey;
/**
 * Convert a hex string to the UInt8Array format used by nacl.
 *
 * @param msgHex - The string to convert.
 * @returns The converted string.
 */
function naclDecodeHex(msgHex) {
    const msgBase64 = Buffer.from(msgHex, 'hex').toString('base64');
    return naclUtil.decodeBase64(msgBase64);
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-sig-util\\dist\\encryption.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\ethereumjs-abi-utils.js", {"./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","bn.js":"F:\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Cethereumjs-abi-utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
/* eslint jsdoc/require-description: 0 */
/* eslint jsdoc/require-returns: 0 */
/* eslint jsdoc/match-description: 0 */
/* eslint jsdoc/require-param-description: 0 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rawEncode = exports.parseNumber = exports.solidityPack = void 0;
const util_1 = require("@ethereumjs/util");
const bn_js_1 = __importDefault(require("bn.js"));
const ethjs_util_1 = require("ethjs-util");
const utils_1 = require("./utils");
//
// Methods borrowed and somewhat adapted from ethereumjs-abi@0.6.8:
// https://npmfs.com/package/ethereumjs-abi/0.6.8/lib/index.js
//
/**
 * Packs non-standard encoded values packed according to their respective type in types in a buffer.
 *
 * @param types - Array of types of each value to encode.
 * @param values - Array of values to encode.
 * @returns A buffer containing the packed values.
 */
function solidityPack(types, values) {
    if (types.length !== values.length) {
        throw new Error('Number of types are not matching the values');
    }
    const ret = [];
    for (let i = 0; i < types.length; i++) {
        const type = elementaryName(types[i]);
        const value = values[i];
        ret.push(solidityHexValue(type, value, null));
    }
    return Buffer.concat(ret);
}
exports.solidityPack = solidityPack;
/**
 * Checks if a value is an array (represented as a string).
 *
 * @param type - The value to check whether it is an array.
 * @returns A boolean indicating whether the passed value is an array.
 */
function isArray(type) {
    return type.endsWith(']');
}
/**
 * Parse array type for packing solidity values.
 *
 * @param type - A string that may be an array to parse.
 * @returns A parsed value from the array.
 */
function parseTypeArray(type) {
    const tmp = type.match(/(.*)\[(.*?)\]$/u);
    if (tmp) {
        return tmp[2] === '' ? 'dynamic' : parseInt(tmp[2], 10);
    }
    return null;
}
/**
 * Parse N from type<N>.
 *
 * @param type - Value to parse.
 * @returns Parsed value.
 */
function parseTypeN(type) {
    const match = /^\D+(\d+)$/u.exec(type);
    if (match === null) {
        throw new Error(`Invalid parseTypeN input "${type}".`);
    }
    return parseInt(match[1], 10);
}
/**
 * Parse a number for determining a solidity hexvalue.
 *
 * @param arg - Number to parse.
 * @returns Parsed value.
 */
function parseNumber(arg) {
    const type = typeof arg;
    if (type === 'string') {
        if ((0, util_1.isHexPrefixed)(arg)) {
            return new bn_js_1.default((0, ethjs_util_1.stripHexPrefix)(arg), 16);
        }
        return new bn_js_1.default(arg, 10);
    }
    else if (type === 'number') {
        return new bn_js_1.default(arg);
    }
    else if ((arg && Object.prototype.hasOwnProperty.call(arg, 'toArray')) ||
        bn_js_1.default.isBN(arg)) {
        return arg;
    }
    throw new Error('Argument is not a number');
}
exports.parseNumber = parseNumber;
/**
 * Get solidity hex value from type, value and bitsize inputs for packing these values in a buffer.
 *
 * @param type - The type of the value to encode.
 * @param value - The value to encode.
 * @param bitsize - The bitsize of the value to encode.
 * @returns The encoded soldity hex value.
 */
function solidityHexValue(type, value, bitsize) {
    // pass in bitsize = null if use default bitsize
    if (isArray(type)) {
        const subType = type.replace(/\[.*?\]/u, '');
        if (!isArray(subType)) {
            const arraySize = parseTypeArray(type);
            if (arraySize !== 'dynamic' &&
                arraySize !== 0 &&
                arraySize !== null &&
                value.length > arraySize) {
                throw new Error(`Elements exceed array size: ${arraySize}`);
            }
        }
        const arrayValues = value.map((v) => solidityHexValue(subType, v, 256));
        return Buffer.concat(arrayValues);
    }
    else if (type === 'bytes') {
        return value;
    }
    else if (type === 'string') {
        return Buffer.from(value, 'utf8');
    }
    else if (type === 'bool') {
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        bitsize = bitsize || 8;
        const padding = Array(bitsize / 4).join('0');
        return Buffer.from(value ? `${padding}1` : `${padding}0`, 'hex');
    }
    else if (type === 'address') {
        let bytesize = 20;
        if (bitsize) {
            bytesize = bitsize / 8;
        }
        return (0, util_1.setLengthLeft)((0, util_1.toBuffer)(value), bytesize);
    }
    else if (type.startsWith('bytes')) {
        const size = parseTypeN(type);
        if (size < 1 || size > 32) {
            throw new Error(`Invalid bytes<N> width: ${size}`);
        }
        if (typeof value === 'number') {
            value = (0, utils_1.normalize)(value);
        }
        return (0, util_1.setLengthRight)((0, util_1.toBuffer)(value), size);
    }
    else if (type.startsWith('uint')) {
        const size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
            throw new Error(`Invalid uint<N> width: ${size}`);
        }
        const num = parseNumber(value);
        if (num.bitLength() > size) {
            throw new Error(`Supplied uint exceeds width: ${size} vs ${num.bitLength()}`);
        }
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        bitsize = bitsize || size;
        return num.toArrayLike(Buffer, 'be', bitsize / 8);
    }
    else if (type.startsWith('int')) {
        const size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
            throw new Error(`Invalid int<N> width: ${size}`);
        }
        const num = parseNumber(value);
        if (num.bitLength() > size) {
            throw new Error(`Supplied int exceeds width: ${size} vs ${num.bitLength()}`);
        }
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        bitsize = bitsize || size;
        return num.toTwos(size).toArrayLike(Buffer, 'be', bitsize / 8);
    }
    // FIXME: support all other types
    throw new Error(`Unsupported or invalid type: ${JSON.stringify(type)}`);
}
/**
 * Gets the correct solidity type name.
 *
 * @param name - The type name for which we want the corresponding solidity type name.
 * @returns The solidity type name for the input value.
 */
function elementaryName(name) {
    if (name.startsWith('int[')) {
        return `int256${name.slice(3)}`;
    }
    else if (name === 'int') {
        return 'int256';
    }
    else if (name.startsWith('uint[')) {
        return `uint256${name.slice(4)}`;
    }
    else if (name === 'uint') {
        return 'uint256';
    }
    else if (name.startsWith('fixed[')) {
        return `fixed128x128${name.slice(5)}`;
    }
    else if (name === 'fixed') {
        return 'fixed128x128';
    }
    else if (name.startsWith('ufixed[')) {
        return `ufixed128x128${name.slice(6)}`;
    }
    else if (name === 'ufixed') {
        return 'ufixed128x128';
    }
    return name;
}
/**
 * @param types
 * @param values
 */
function rawEncode(types, values) {
    const output = [];
    const data = [];
    let headLength = 0;
    types.forEach((type) => {
        if (isArray(type)) {
            const size = parseTypeArray(type);
            // eslint-disable-next-line no-negated-condition
            if (size !== 'dynamic' && size !== null) {
                headLength += 32 * size;
            }
            else {
                headLength += 32;
            }
        }
        else {
            headLength += 32;
        }
    });
    for (let i = 0; i < types.length; i++) {
        const type = elementaryName(types[i]);
        const value = values[i];
        const cur = encodeSingle(type, value);
        // Use the head/tail method for storing dynamic data
        if (isDynamic(type)) {
            output.push(encodeSingle('uint256', headLength));
            data.push(cur);
            headLength += cur.length;
        }
        else {
            output.push(cur);
        }
    }
    return Buffer.concat(output.concat(data));
}
exports.rawEncode = rawEncode;
// Encodes a single item (can be dynamic array)
// @returns: Buffer
/**
 * @param type
 * @param arg
 */
function encodeSingle(type, arg) {
    if (type === 'address') {
        return encodeSingle('uint160', parseNumber(arg));
    }
    else if (type === 'bool') {
        return encodeSingle('uint8', arg ? 1 : 0);
    }
    else if (type === 'string') {
        return encodeSingle('bytes', Buffer.from(arg, 'utf8'));
    }
    else if (isArray(type)) {
        // this part handles fixed-length ([2]) and variable length ([]) arrays
        // NOTE: we catch here all calls to arrays, that simplifies the rest
        if (typeof arg.length === 'undefined') {
            throw new Error('Not an array?');
        }
        const size = parseTypeArray(type);
        if (size !== 'dynamic' &&
            size !== 0 &&
            size !== null &&
            arg.length > size) {
            throw new Error(`Elements exceed array size: ${size}`);
        }
        const ret = [];
        type = type.slice(0, type.lastIndexOf('['));
        if (typeof arg === 'string') {
            arg = JSON.parse(arg);
        }
        // TODO: if this is array, should do for-of
        for (const i in arg) {
            if (Object.prototype.hasOwnProperty.call(arg, i)) {
                ret.push(encodeSingle(type, arg[i]));
            }
        }
        if (size === 'dynamic') {
            const length = encodeSingle('uint256', arg.length);
            ret.unshift(length);
        }
        return Buffer.concat(ret);
    }
    else if (type === 'bytes') {
        arg = Buffer.from(arg);
        let ret = Buffer.concat([encodeSingle('uint256', arg.length), arg]);
        if (arg.length % 32 !== 0) {
            ret = Buffer.concat([ret, (0, util_1.zeros)(32 - (arg.length % 32))]);
        }
        return ret;
    }
    else if (type.startsWith('bytes')) {
        const size = parseTypeN(type);
        if (size < 1 || size > 32) {
            throw new Error(`Invalid bytes<N> width: ${size}`);
        }
        // TODO: fix types here
        const nArg = typeof arg === 'number' ? (0, utils_1.normalize)(arg) : arg;
        return (0, util_1.setLengthRight)((0, util_1.toBuffer)(nArg), 32);
    }
    else if (type.startsWith('uint')) {
        const size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
            throw new Error(`Invalid uint<N> width: ${size}`);
        }
        const num = parseNumber(arg);
        if (num.bitLength() > size) {
            throw new Error(`Supplied uint exceeds width: ${size} vs ${num.bitLength()}`);
        }
        if (num.isNeg()) {
            throw new Error('Supplied uint is negative');
        }
        return num.toArrayLike(Buffer, 'be', 32);
    }
    else if (type.startsWith('int')) {
        const size = parseTypeN(type);
        if (size % 8 || size < 8 || size > 256) {
            throw new Error(`Invalid int<N> width: ${size}`);
        }
        const num = parseNumber(arg);
        if (num.bitLength() > size) {
            throw new Error(`Supplied int exceeds width: ${size} vs ${num.bitLength()}`);
        }
        return num.toTwos(256).toArrayLike(Buffer, 'be', 32);
    }
    else if (type.startsWith('ufixed')) {
        const size = parseTypeNxM(type);
        const num = parseNumber(arg);
        if (num.isNeg()) {
            throw new Error('Supplied ufixed is negative');
        }
        return encodeSingle('uint256', num.mul(new bn_js_1.default(2).pow(new bn_js_1.default(size[1]))));
    }
    else if (type.startsWith('fixed')) {
        const size = parseTypeNxM(type);
        return encodeSingle('int256', parseNumber(arg).mul(new bn_js_1.default(2).pow(new bn_js_1.default(size[1]))));
    }
    throw new Error(`Unsupported or invalid type: ${JSON.stringify(type)}`);
}
// Is a type dynamic?
/**
 * @param type
 */
function isDynamic(type) {
    // FIXME: handle all types? I don't think anything is missing now
    return (type === 'string' || type === 'bytes' || parseTypeArray(type) === 'dynamic');
}
// Parse N,M from type<N>x<M>
/**
 * @param type
 */
function parseTypeNxM(type) {
    const match = /^\D+(\d+)x(\d+)$/u.exec(type);
    if (match === null || match.length < 1) {
        throw new Error(`Invalid parseTypeNxM input "${type}".`);
    }
    return [parseInt(match[1], 10), parseInt(match[2], 10)];
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-sig-util\\dist\\ethereumjs-abi-utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js", {"./encryption":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\encryption.js","./personal-sign":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\personal-sign.js","./sign-typed-data":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\sign-typed-data.js","./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalize = exports.concatSig = void 0;
__exportStar(require("./personal-sign"), exports);
__exportStar(require("./sign-typed-data"), exports);
__exportStar(require("./encryption"), exports);
var utils_1 = require("./utils");
Object.defineProperty(exports, "concatSig", { enumerable: true, get: function () { return utils_1.concatSig; } });
Object.defineProperty(exports, "normalize", { enumerable: true, get: function () { return utils_1.normalize; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-sig-util\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\personal-sign.js", {"./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Cpersonal-sign.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractPublicKey = exports.recoverPersonalSignature = exports.personalSign = void 0;
const util_1 = require("@ethereumjs/util");
const utils_1 = require("./utils");
/**
 * Create an Ethereum-specific signature for a message.
 *
 * This function is equivalent to the `eth_sign` Ethereum JSON-RPC method as specified in EIP-1417,
 * as well as the MetaMask's `personal_sign` method.
 *
 * @param options - The personal sign options.
 * @param options.privateKey - The key to sign with.
 * @param options.data - The hex data to sign.
 * @returns The '0x'-prefixed hex encoded signature.
 */
function personalSign({ privateKey, data, }) {
    if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error('Missing privateKey parameter');
    }
    const message = (0, utils_1.legacyToBuffer)(data);
    const msgHash = (0, util_1.hashPersonalMessage)(message);
    const sig = (0, util_1.ecsign)(msgHash, privateKey);
    const serialized = (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);
    return serialized;
}
exports.personalSign = personalSign;
/**
 * Recover the address of the account used to create the given Ethereum signature. The message
 * must have been signed using the `personalSign` function, or an equivalent function.
 *
 * @param options - The signature recovery options.
 * @param options.data - The hex data that was signed.
 * @param options.signature - The '0x'-prefixed hex encoded message signature.
 * @returns The '0x'-prefixed hex encoded address of the message signer.
 */
function recoverPersonalSignature({ data, signature, }) {
    if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(signature)) {
        throw new Error('Missing signature parameter');
    }
    const publicKey = getPublicKeyFor(data, signature);
    const sender = (0, util_1.publicToAddress)(publicKey);
    const senderHex = (0, util_1.bufferToHex)(sender);
    return senderHex;
}
exports.recoverPersonalSignature = recoverPersonalSignature;
/**
 * Recover the public key of the account used to create the given Ethereum signature. The message
 * must have been signed using the `personalSign` function, or an equivalent function.
 *
 * @param options - The public key recovery options.
 * @param options.data - The hex data that was signed.
 * @param options.signature - The '0x'-prefixed hex encoded message signature.
 * @returns The '0x'-prefixed hex encoded public key of the message signer.
 */
function extractPublicKey({ data, signature, }) {
    if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(signature)) {
        throw new Error('Missing signature parameter');
    }
    const publicKey = getPublicKeyFor(data, signature);
    return `0x${publicKey.toString('hex')}`;
}
exports.extractPublicKey = extractPublicKey;
/**
 * Get the public key for the given signature and message.
 *
 * @param message - The message that was signed.
 * @param signature - The '0x'-prefixed hex encoded message signature.
 * @returns The public key of the signer.
 */
function getPublicKeyFor(message, signature) {
    const messageHash = (0, util_1.hashPersonalMessage)((0, utils_1.legacyToBuffer)(message));
    return (0, utils_1.recoverPublicKey)(messageHash, signature);
}
//# sourceMappingURL=personal-sign.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-sig-util\\dist\\personal-sign.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\sign-typed-data.js", {"./ethereumjs-abi-utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\ethereumjs-abi-utils.js","./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/keccak":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Csign-typed-data.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recoverTypedSignature = exports.signTypedData = exports.typedSignatureHash = exports.TypedDataUtils = exports.TYPED_MESSAGE_SCHEMA = exports.SignTypedDataVersion = void 0;
const util_1 = require("@ethereumjs/util");
const keccak_1 = require("ethereum-cryptography/keccak");
const ethjs_util_1 = require("ethjs-util");
const ethereumjs_abi_utils_1 = require("./ethereumjs-abi-utils");
const utils_1 = require("./utils");
/**
 * Represents the version of `signTypedData` being used.
 *
 * V1 is based upon [an early version of EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)
 * that lacked some later security improvements, and should generally be neglected in favor of
 * later versions.
 *
 * V3 is based on EIP-712, except that arrays and recursive data structures are not supported.
 *
 * V4 is based on EIP-712, and includes full support of arrays and recursive data structures.
 */
var SignTypedDataVersion;
(function (SignTypedDataVersion) {
    SignTypedDataVersion["V1"] = "V1";
    SignTypedDataVersion["V3"] = "V3";
    SignTypedDataVersion["V4"] = "V4";
})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
exports.TYPED_MESSAGE_SCHEMA = {
    type: 'object',
    properties: {
        types: {
            type: 'object',
            additionalProperties: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        name: { type: 'string' },
                        type: { type: 'string' },
                    },
                    required: ['name', 'type'],
                },
            },
        },
        primaryType: { type: 'string' },
        domain: { type: 'object' },
        message: { type: 'object' },
    },
    required: ['types', 'primaryType', 'domain', 'message'],
};
/**
 * Validate that the given value is a valid version string.
 *
 * @param version - The version value to validate.
 * @param allowedVersions - A list of allowed versions. If omitted, all versions are assumed to be
 * allowed.
 */
function validateVersion(version, allowedVersions) {
    if (!Object.keys(SignTypedDataVersion).includes(version)) {
        throw new Error(`Invalid version: '${version}'`);
    }
    else if (allowedVersions && !allowedVersions.includes(version)) {
        throw new Error(`SignTypedDataVersion not allowed: '${version}'. Allowed versions are: ${allowedVersions.join(', ')}`);
    }
}
/**
 * Encode a single field.
 *
 * @param types - All type definitions.
 * @param name - The name of the field to encode.
 * @param type - The type of the field being encoded.
 * @param value - The value to encode.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns Encoded representation of the field.
 */
function encodeField(types, name, type, 
// TODO: constrain type on `value`
value, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    if (types[type] !== undefined) {
        return [
            'bytes32',
            // TODO: return Buffer, remove string from return type
            version === SignTypedDataVersion.V4 && value == null // eslint-disable-line no-eq-null
                ? '0x0000000000000000000000000000000000000000000000000000000000000000'
                : (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodeData(type, value, types, version))),
        ];
    }
    if (value === undefined) {
        throw new Error(`missing value for field ${name} of type ${type}`);
    }
    if (type === 'bytes') {
        if (typeof value === 'number') {
            value = (0, utils_1.numberToBuffer)(value);
        }
        else if ((0, ethjs_util_1.isHexString)(value)) {
            const prepend = value.length % 2 ? '0' : '';
            value = Buffer.from(prepend + value.slice(2), 'hex');
        }
        else {
            value = Buffer.from(value, 'utf8');
        }
        return ['bytes32', (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];
    }
    if (type === 'string') {
        if (typeof value === 'number') {
            value = (0, utils_1.numberToBuffer)(value);
        }
        else {
            value = Buffer.from(value !== null && value !== void 0 ? value : '', 'utf8');
        }
        return ['bytes32', (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(value))];
    }
    if (type.endsWith(']')) {
        if (version === SignTypedDataVersion.V3) {
            throw new Error('Arrays are unimplemented in encodeData; use V4 extension');
        }
        const parsedType = type.slice(0, type.lastIndexOf('['));
        const typeValuePairs = value.map((item) => encodeField(types, name, parsedType, item, version));
        return [
            'bytes32',
            (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.rawEncode)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v)))),
        ];
    }
    return [type, value];
}
/**
 * Encodes an object by encoding and concatenating each of its members.
 *
 * @param primaryType - The root type.
 * @param data - The object to encode.
 * @param types - Type definitions for all types included in the message.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns An encoded representation of an object.
 */
function encodeData(primaryType, data, types, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    const encodedTypes = ['bytes32'];
    const encodedValues = [hashType(primaryType, types)];
    for (const field of types[primaryType]) {
        if (version === SignTypedDataVersion.V3 && data[field.name] === undefined) {
            continue;
        }
        const [type, value] = encodeField(types, field.name, field.type, data[field.name], version);
        encodedTypes.push(type);
        encodedValues.push(value);
    }
    return (0, ethereumjs_abi_utils_1.rawEncode)(encodedTypes, encodedValues);
}
/**
 * Encodes the type of an object by encoding a comma delimited list of its members.
 *
 * @param primaryType - The root type to encode.
 * @param types - Type definitions for all types included in the message.
 * @returns An encoded representation of the primary type.
 */
function encodeType(primaryType, types) {
    let result = '';
    const unsortedDeps = findTypeDependencies(primaryType, types);
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
        const children = types[type];
        if (!children) {
            throw new Error(`No type definition specified: ${type}`);
        }
        result += `${type}(${types[type]
            .map(({ name, type: t }) => `${t} ${name}`)
            .join(',')})`;
    }
    return result;
}
/**
 * Finds all types within a type definition object.
 *
 * @param primaryType - The root type.
 * @param types - Type definitions for all types included in the message.
 * @param results - The current set of accumulated types.
 * @returns The set of all types found in the type definition.
 */
function findTypeDependencies(primaryType, types, results = new Set()) {
    if (typeof primaryType !== 'string') {
        throw new Error(`Invalid findTypeDependencies input ${JSON.stringify(primaryType)}`);
    }
    const match = primaryType.match(/^\w*/u);
    [primaryType] = match;
    if (results.has(primaryType) || types[primaryType] === undefined) {
        return results;
    }
    results.add(primaryType);
    for (const field of types[primaryType]) {
        findTypeDependencies(field.type, types, results);
    }
    return results;
}
/**
 * Hashes an object.
 *
 * @param primaryType - The root type.
 * @param data - The object to hash.
 * @param types - Type definitions for all types included in the message.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns The hash of the object.
 */
function hashStruct(primaryType, data, types, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    const encoded = encodeData(primaryType, data, types, version);
    const hashed = (0, keccak_1.keccak256)(encoded);
    const buf = (0, util_1.arrToBufArr)(hashed);
    return buf;
}
/**
 * Hashes the type of an object.
 *
 * @param primaryType - The root type to hash.
 * @param types - Type definitions for all types included in the message.
 * @returns The hash of the object type.
 */
function hashType(primaryType, types) {
    const encodedHashType = Buffer.from(encodeType(primaryType, types), 'utf-8');
    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(encodedHashType));
}
/**
 * Removes properties from a message object that are not defined per EIP-712.
 *
 * @param data - The typed message object.
 * @returns The typed message object with only allowed fields.
 */
function sanitizeData(data) {
    const sanitizedData = {};
    for (const key in exports.TYPED_MESSAGE_SCHEMA.properties) {
        if (data[key]) {
            sanitizedData[key] = data[key];
        }
    }
    if ('types' in sanitizedData) {
        // TODO: Fix types
        sanitizedData.types = Object.assign({ EIP712Domain: [] }, sanitizedData.types);
    }
    return sanitizedData;
}
/**
 * Create a EIP-712 Domain Hash.
 * This hash is used at the top of the EIP-712 encoding.
 *
 * @param typedData - The typed message to hash.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns The hash of the domain object.
 */
function eip712DomainHash(typedData, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    const sanitizedData = sanitizeData(typedData);
    const { domain } = sanitizedData;
    const domainType = { EIP712Domain: sanitizedData.types.EIP712Domain };
    return hashStruct('EIP712Domain', domain, domainType, version);
}
/**
 * Hash a typed message according to EIP-712. The returned message starts with the EIP-712 prefix,
 * which is "1901", followed by the hash of the domain separator, then the data (if any).
 * The result is hashed again and returned.
 *
 * This function does not sign the message. The resulting hash must still be signed to create an
 * EIP-712 signature.
 *
 * @param typedData - The typed message to hash.
 * @param version - The EIP-712 version the encoding should comply with.
 * @returns The hash of the typed message.
 */
function eip712Hash(typedData, version) {
    validateVersion(version, [SignTypedDataVersion.V3, SignTypedDataVersion.V4]);
    const sanitizedData = sanitizeData(typedData);
    const parts = [Buffer.from('1901', 'hex')];
    parts.push(eip712DomainHash(typedData, version));
    if (sanitizedData.primaryType !== 'EIP712Domain') {
        parts.push(hashStruct(
        // TODO: Validate that this is a string, so this type cast can be removed.
        sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, version));
    }
    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)(Buffer.concat(parts)));
}
/**
 * A collection of utility functions used for signing typed data.
 */
exports.TypedDataUtils = {
    encodeData,
    encodeType,
    findTypeDependencies,
    hashStruct,
    hashType,
    sanitizeData,
    eip712Hash,
    eip712DomainHash,
};
/**
 * Generate the "V1" hash for the provided typed message.
 *
 * The hash will be generated in accordance with an earlier version of the EIP-712
 * specification. This hash is used in `signTypedData_v1`.
 *
 * @param typedData - The typed message.
 * @returns The '0x'-prefixed hex encoded hash representing the type of the provided message.
 */
function typedSignatureHash(typedData) {
    const hashBuffer = _typedSignatureHash(typedData);
    return (0, util_1.bufferToHex)(hashBuffer);
}
exports.typedSignatureHash = typedSignatureHash;
/**
 * Generate the "V1" hash for the provided typed message.
 *
 * The hash will be generated in accordance with an earlier version of the EIP-712
 * specification. This hash is used in `signTypedData_v1`.
 *
 * @param typedData - The typed message.
 * @returns The hash representing the type of the provided message.
 */
function _typedSignatureHash(typedData) {
    const error = new Error('Expect argument to be non-empty array');
    if (typeof typedData !== 'object' ||
        !('length' in typedData) ||
        !typedData.length) {
        throw error;
    }
    const data = typedData.map(function (e) {
        if (e.type !== 'bytes') {
            return e.value;
        }
        return (0, utils_1.legacyToBuffer)(e.value);
    });
    const types = typedData.map(function (e) {
        return e.type;
    });
    const schema = typedData.map(function (e) {
        if (!e.name) {
            throw error;
        }
        return `${e.type} ${e.name}`;
    });
    return (0, util_1.arrToBufArr)((0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(['bytes32', 'bytes32'], [
        (0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(new Array(typedData.length).fill('string'), schema)),
        (0, keccak_1.keccak256)((0, ethereumjs_abi_utils_1.solidityPack)(types, data)),
    ])));
}
/**
 * Sign typed data according to EIP-712. The signing differs based upon the `version`.
 *
 * V1 is based upon [an early version of EIP-712](https://github.com/ethereum/EIPs/pull/712/commits/21abe254fe0452d8583d5b132b1d7be87c0439ca)
 * that lacked some later security improvements, and should generally be neglected in favor of
 * later versions.
 *
 * V3 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), except that arrays and
 * recursive data structures are not supported.
 *
 * V4 is based on [EIP-712](https://eips.ethereum.org/EIPS/eip-712), and includes full support of
 * arrays and recursive data structures.
 *
 * @param options - The signing options.
 * @param options.privateKey - The private key to sign with.
 * @param options.data - The typed data to sign.
 * @param options.version - The signing version to use.
 * @returns The '0x'-prefixed hex encoded signature.
 */
function signTypedData({ privateKey, data, version, }) {
    validateVersion(version);
    if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(privateKey)) {
        throw new Error('Missing private key parameter');
    }
    const messageHash = version === SignTypedDataVersion.V1
        ? _typedSignatureHash(data)
        : exports.TypedDataUtils.eip712Hash(data, version);
    const sig = (0, util_1.ecsign)(messageHash, privateKey);
    return (0, utils_1.concatSig)((0, util_1.toBuffer)(sig.v), sig.r, sig.s);
}
exports.signTypedData = signTypedData;
/**
 * Recover the address of the account that created the given EIP-712
 * signature. The version provided must match the version used to
 * create the signature.
 *
 * @param options - The signature recovery options.
 * @param options.data - The typed data that was signed.
 * @param options.signature - The '0x-prefixed hex encoded message signature.
 * @param options.version - The signing version to use.
 * @returns The '0x'-prefixed hex address of the signer.
 */
function recoverTypedSignature({ data, signature, version, }) {
    validateVersion(version);
    if ((0, utils_1.isNullish)(data)) {
        throw new Error('Missing data parameter');
    }
    else if ((0, utils_1.isNullish)(signature)) {
        throw new Error('Missing signature parameter');
    }
    const messageHash = version === SignTypedDataVersion.V1
        ? _typedSignatureHash(data)
        : exports.TypedDataUtils.eip712Hash(data, version);
    const publicKey = (0, utils_1.recoverPublicKey)(messageHash, signature);
    const sender = (0, util_1.publicToAddress)(publicKey);
    return (0, util_1.bufferToHex)(sender);
}
exports.recoverTypedSignature = recoverTypedSignature;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-sig-util\\dist\\sign-typed-data.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\utils.js", {"@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethjs-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cdist%5Cutils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.numberToBuffer = exports.normalize = exports.recoverPublicKey = exports.concatSig = exports.legacyToBuffer = exports.isNullish = exports.padWithZeroes = void 0;
const util_1 = require("@ethereumjs/util");
const ethjs_util_1 = require("ethjs-util");
/**
 * Pads the front of the given hex string with zeroes until it reaches the
 * target length. If the input string is already longer than or equal to the
 * target length, it is returned unmodified.
 *
 * If the input string is "0x"-prefixed or not a hex string, an error will be
 * thrown.
 *
 * @param hexString - The hexadecimal string to pad with zeroes.
 * @param targetLength - The target length of the hexadecimal string.
 * @returns The input string front-padded with zeroes, or the original string
 * if it was already greater than or equal to to the target length.
 */
function padWithZeroes(hexString, targetLength) {
    if (hexString !== '' && !/^[a-f0-9]+$/iu.test(hexString)) {
        throw new Error(`Expected an unprefixed hex string. Received: ${hexString}`);
    }
    if (targetLength < 0) {
        throw new Error(`Expected a non-negative integer target length. Received: ${targetLength}`);
    }
    return String.prototype.padStart.call(hexString, targetLength, '0');
}
exports.padWithZeroes = padWithZeroes;
/**
 * Returns `true` if the given value is nullish.
 *
 * @param value - The value being checked.
 * @returns Whether the value is nullish.
 */
function isNullish(value) {
    return value === null || value === undefined;
}
exports.isNullish = isNullish;
/**
 * Convert a value to a Buffer. This function should be equivalent to the `toBuffer` function in
 * `ethereumjs-util@5.2.1`.
 *
 * @param value - The value to convert to a Buffer.
 * @returns The given value as a Buffer.
 */
function legacyToBuffer(value) {
    return typeof value === 'string' && !(0, ethjs_util_1.isHexString)(value)
        ? Buffer.from(value)
        : (0, util_1.toBuffer)(value);
}
exports.legacyToBuffer = legacyToBuffer;
/**
 * Concatenate an extended ECDSA signature into a single '0x'-prefixed hex string.
 *
 * @param v - The 'v' portion of the signature.
 * @param r - The 'r' portion of the signature.
 * @param s - The 's' portion of the signature.
 * @returns The concatenated ECDSA signature as a '0x'-prefixed string.
 */
function concatSig(v, r, s) {
    const rSig = (0, util_1.fromSigned)(r);
    const sSig = (0, util_1.fromSigned)(s);
    const vSig = (0, util_1.bufferToInt)(v);
    const rStr = padWithZeroes((0, util_1.toUnsigned)(rSig).toString('hex'), 64);
    const sStr = padWithZeroes((0, util_1.toUnsigned)(sSig).toString('hex'), 64);
    const vStr = (0, ethjs_util_1.stripHexPrefix)((0, ethjs_util_1.intToHex)(vSig));
    return (0, util_1.addHexPrefix)(rStr.concat(sStr, vStr));
}
exports.concatSig = concatSig;
/**
 * Recover the public key from the given signature and message hash.
 *
 * @param messageHash - The hash of the signed message.
 * @param signature - The signature.
 * @returns The public key of the signer.
 */
function recoverPublicKey(messageHash, signature) {
    const sigParams = (0, util_1.fromRpcSig)(signature);
    return (0, util_1.ecrecover)(messageHash, sigParams.v, sigParams.r, sigParams.s);
}
exports.recoverPublicKey = recoverPublicKey;
/**
 * Normalize the input to a lower-cased '0x'-prefixed hex string.
 *
 * @param input - The value to normalize.
 * @returns The normalized value.
 */
function normalize(input) {
    if (!input) {
        return undefined;
    }
    if (typeof input === 'number') {
        if (input < 0) {
            return '0x';
        }
        const buffer = (0, util_1.toBuffer)(input);
        input = (0, util_1.bufferToHex)(buffer);
    }
    if (typeof input !== 'string') {
        let msg = 'eth-sig-util.normalize() requires hex string or integer input.';
        msg += ` received ${typeof input}: ${input}`;
        throw new Error(msg);
    }
    return (0, util_1.addHexPrefix)(input.toLowerCase());
}
exports.normalize = normalize;
/**
 * Node's Buffer.from() method does not seem to buffer numbers correctly out of the box.
 * This helper method formats the number correct for Buffer.from to return correct buffer.
 *
 * @param num - The number to convert to buffer.
 * @returns The number in buffer form.
 */
function numberToBuffer(num) {
    const hexVal = num.toString(16);
    const prepend = hexVal.length % 2 ? '0' : '';
    return Buffer.from(prepend + hexVal, 'hex');
}
exports.numberToBuffer = numberToBuffer;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util",file:"node_modules\\@metamask\\eth-sig-util\\dist\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\_assert.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cnode_modules%5C@noble%5Chashes%5C_assert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
exports.default = assert;
//# sourceMappingURL=_assert.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\_assert.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\_u64.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cnode_modules%5C@noble%5Chashes%5C_u64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig: exports.toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;
//# sourceMappingURL=_u64.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\_u64.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\crypto.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cnode_modules%5C@noble%5Chashes%5Ccrypto.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\crypto.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\sha3.js", {"./_assert.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\_assert.js","./_u64.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\_u64.js","./utils.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cnode_modules%5C@noble%5Chashes%5Csha3.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = require("./_assert.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        _assert_js_1.default.number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);
//# sourceMappingURL=sha3.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\sha3.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\utils.js", {"@noble/hashes/crypto":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\crypto.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cnode_modules%5C@noble%5Chashes%5Cutils.js
      return function (require, module, exports) {
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use `globalThis.crypto`, but node.js versions earlier than v19 don't
// declare it in global scope. For node.js, package.json#exports field mapping
// rewrites import from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
const crypto_1 = require("@noble/hashes/crypto");
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef])) // 'deadbeef'
 */
function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('deadbeef') // Uint8Array.from([0xde, 0xad, 0xbe, 0xef])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */
function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new TypeError('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
/**
 * Secure PRNG. Uses `globalThis.crypto` or node.js crypto module.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereum-cryptography\\keccak.js", {"./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereum-cryptography\\utils.js","@noble/hashes/sha3":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\sha3.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cnode_modules%5Cethereum-cryptography%5Ckeccak.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const utils_1 = require("./utils");
exports.keccak224 = (0, utils_1.wrapHash)(sha3_1.keccak_224);
exports.keccak256 = (() => {
    const k = (0, utils_1.wrapHash)(sha3_1.keccak_256);
    k.create = sha3_1.keccak_256.create;
    return k;
})();
exports.keccak384 = (0, utils_1.wrapHash)(sha3_1.keccak_384);
exports.keccak512 = (0, utils_1.wrapHash)(sha3_1.keccak_512);

      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util>ethereum-cryptography",file:"node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereum-cryptography\\keccak.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereum-cryptography\\utils.js", {"@noble/hashes/_assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\_assert.js","@noble/hashes/utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cnode_modules%5Cethereum-cryptography%5Cutils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
// buf.toString('hex') -> toHex(buf)
const _assert_1 = __importDefault(require("@noble/hashes/_assert"));
const utils_1 = require("@noble/hashes/utils");
const assertBool = _assert_1.default.bool;
exports.assertBool = assertBool;
const assertBytes = _assert_1.default.bytes;
exports.assertBytes = assertBytes;
var utils_2 = require("@noble/hashes/utils");
Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return utils_2.concatBytes; } });
Object.defineProperty(exports, "createView", { enumerable: true, get: function () { return utils_2.createView; } });
Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function () { return utils_2.utf8ToBytes; } });
// buf.toString('utf8') -> bytesToUtf8(buf)
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
exports.bytesToUtf8 = bytesToUtf8;
function hexToBytes(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return (0, utils_1.hexToBytes)(sliced);
}
exports.hexToBytes = hexToBytes;
// buf.equals(buf2) -> equalsBytes(buf, buf2)
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.equalsBytes = equalsBytes;
// Internal utils
function wrapHash(hash) {
    return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
    };
}
exports.wrapHash = wrapHash;
exports.crypto = (() => {
    const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : undefined;
    const nodeRequire = typeof module !== "undefined" &&
        typeof module.require === "function" &&
        module.require.bind(module);
    return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
        web: webCrypto
    };
})();

      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util>ethereum-cryptography",file:"node_modules\\@metamask\\eth-sig-util\\node_modules\\ethereum-cryptography\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"F:\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"F:\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-sig-util%5Cnode_modules%5Cethjs-util%5Clib%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-snap-keyring>@metamask/eth-sig-util>ethjs-util",file:"node_modules\\@metamask\\eth-sig-util\\node_modules\\ethjs-util\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\index.js", {"@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@metamask/eth-sig-util":"F:\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/keccak":"F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\keccak.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","randombytes":"F:\\metamask-extension\\node_modules\\randombytes\\browser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-simple-keyring%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events');
const {
  isValidPrivate,
  stripHexPrefix,
  privateToPublic,
  bufferToHex,
  publicToAddress,
  ecsign,
  arrToBufArr,
} = require('@ethereumjs/util');
const randomBytes = require('randombytes');
const { keccak256 } = require('ethereum-cryptography/keccak');

const type = 'Simple Key Pair';
const {
  concatSig,
  decrypt,
  getEncryptionPublicKey,
  normalize,
  personalSign,
  signTypedData,
  SignTypedDataVersion,
} = require('@metamask/eth-sig-util');

function generateKey() {
  const privateKey = randomBytes(32);
  // I don't think this is possible, but this validation was here previously,
  // so it has been preserved just in case.
  // istanbul ignore next
  if (!isValidPrivate(privateKey)) {
    throw new Error(
      'Private key does not satisfy the curve requirements (ie. it is invalid)',
    );
  }
  return privateKey;
}

class SimpleKeyring extends EventEmitter {
  constructor(opts) {
    super();
    this.type = type;
    this._wallets = [];
    this.deserialize(opts);
  }

  async serialize() {
    return this._wallets.map(({ privateKey }) => privateKey.toString('hex'));
  }

  async deserialize(privateKeys = []) {
    this._wallets = privateKeys.map((hexPrivateKey) => {
      const strippedHexPrivateKey = stripHexPrefix(hexPrivateKey);
      const privateKey = Buffer.from(strippedHexPrivateKey, 'hex');
      const publicKey = privateToPublic(privateKey);
      return { privateKey, publicKey };
    });
  }

  async addAccounts(n = 1) {
    const newWallets = [];
    for (let i = 0; i < n; i++) {
      const privateKey = generateKey();
      const publicKey = privateToPublic(privateKey);
      newWallets.push({ privateKey, publicKey });
    }
    this._wallets = this._wallets.concat(newWallets);
    const hexWallets = newWallets.map(({ publicKey }) =>
      bufferToHex(publicToAddress(publicKey)),
    );
    return hexWallets;
  }

  async getAccounts() {
    return this._wallets.map(({ publicKey }) =>
      bufferToHex(publicToAddress(publicKey)),
    );
  }

  // tx is an instance of the ethereumjs-transaction class.
  async signTransaction(address, tx, opts = {}) {
    const privKey = this._getPrivateKeyFor(address, opts);
    const signedTx = tx.sign(privKey);
    // Newer versions of Ethereumjs-tx are immutable and return a new tx object
    return signedTx === undefined ? tx : signedTx;
  }

  // For eth_sign, we need to sign arbitrary data:
  async signMessage(address, data, opts = {}) {
    const message = stripHexPrefix(data);
    const privKey = this._getPrivateKeyFor(address, opts);
    const msgSig = ecsign(Buffer.from(message, 'hex'), privKey);
    const rawMsgSig = concatSig(msgSig.v, msgSig.r, msgSig.s);
    return rawMsgSig;
  }

  // For personal_sign, we need to prefix the message:
  async signPersonalMessage(address, msgHex, opts = {}) {
    const privKey = this._getPrivateKeyFor(address, opts);
    const privateKey = Buffer.from(privKey, 'hex');
    const sig = personalSign({ privateKey, data: msgHex });
    return sig;
  }

  // For eth_decryptMessage:
  async decryptMessage(withAccount, encryptedData) {
    const wallet = this._getWalletForAccount(withAccount);
    const { privateKey } = wallet;
    const sig = decrypt({ privateKey, encryptedData });
    return sig;
  }

  // personal_signTypedData, signs data along with the schema
  async signTypedData(
    withAccount,
    typedData,
    opts = { version: SignTypedDataVersion.V1 },
  ) {
    // Treat invalid versions as "V1"
    const version = Object.keys(SignTypedDataVersion).includes(opts.version)
      ? opts.version
      : SignTypedDataVersion.V1;

    const privateKey = this._getPrivateKeyFor(withAccount, opts);
    return signTypedData({ privateKey, data: typedData, version });
  }

  // get public key for nacl
  async getEncryptionPublicKey(withAccount, opts = {}) {
    const privKey = this._getPrivateKeyFor(withAccount, opts);
    const publicKey = getEncryptionPublicKey(privKey);
    return publicKey;
  }

  _getPrivateKeyFor(address, opts = {}) {
    if (!address) {
      throw new Error('Must specify address.');
    }
    const wallet = this._getWalletForAccount(address, opts);
    return wallet.privateKey;
  }

  // returns an address specific to an app
  async getAppKeyAddress(address, origin) {
    if (!origin || typeof origin !== 'string') {
      throw new Error(`'origin' must be a non-empty string`);
    }
    const wallet = this._getWalletForAccount(address, {
      withAppKeyOrigin: origin,
    });
    const appKeyAddress = normalize(
      publicToAddress(wallet.publicKey).toString('hex'),
    );
    return appKeyAddress;
  }

  // exportAccount should return a hex-encoded private key:
  async exportAccount(address, opts = {}) {
    const wallet = this._getWalletForAccount(address, opts);
    return wallet.privateKey.toString('hex');
  }

  removeAccount(address) {
    if (
      !this._wallets
        .map(({ publicKey }) =>
          bufferToHex(publicToAddress(publicKey)).toLowerCase(),
        )
        .includes(address.toLowerCase())
    ) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this._wallets = this._wallets.filter(
      ({ publicKey }) =>
        bufferToHex(publicToAddress(publicKey)).toLowerCase() !==
        address.toLowerCase(),
    );
  }

  /**
   * @private
   */
  _getWalletForAccount(account, opts = {}) {
    const address = normalize(account);
    let wallet = this._wallets.find(
      ({ publicKey }) => bufferToHex(publicToAddress(publicKey)) === address,
    );
    if (!wallet) {
      throw new Error('Simple Keyring - Unable to find matching address.');
    }

    if (opts.withAppKeyOrigin) {
      const { privateKey } = wallet;
      const appKeyOriginBuffer = Buffer.from(opts.withAppKeyOrigin, 'utf8');
      const appKeyBuffer = Buffer.concat([privateKey, appKeyOriginBuffer]);
      const appKeyPrivateKey = arrToBufArr(keccak256(appKeyBuffer, 256));
      const appKeyPublicKey = privateToPublic(appKeyPrivateKey);
      wallet = { privateKey: appKeyPrivateKey, publicKey: appKeyPublicKey };
    }

    return wallet;
  }
}

SimpleKeyring.type = type;
module.exports = SimpleKeyring;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-simple-keyring",file:"node_modules\\@metamask\\eth-simple-keyring\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\keccak.js", {"./utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\utils.js","@noble/hashes/sha3":"F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-simple-keyring%5Cnode_modules%5Cethereum-cryptography%5Ckeccak.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.keccak512 = exports.keccak384 = exports.keccak256 = exports.keccak224 = void 0;
const sha3_1 = require("@noble/hashes/sha3");
const utils_1 = require("./utils");
exports.keccak224 = (0, utils_1.wrapHash)(sha3_1.keccak_224);
exports.keccak256 = (() => {
    const k = (0, utils_1.wrapHash)(sha3_1.keccak_256);
    k.create = sha3_1.keccak_256.create;
    return k;
})();
exports.keccak384 = (0, utils_1.wrapHash)(sha3_1.keccak_384);
exports.keccak512 = (0, utils_1.wrapHash)(sha3_1.keccak_512);

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-simple-keyring>ethereum-cryptography",file:"node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\keccak.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-simple-keyring%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5C_assert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new TypeError('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output,
};
exports.default = assert;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-simple-keyring>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-simple-keyring%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5C_u64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = BigInt(2 ** 32 - 1);
const _32n = BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, l, s) => h >>> s;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (h, l) => l;
const rotr32L = (h, l) => h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
// Removing "export" has 5% perf penalty -_-
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
// prettier-ignore
const u64 = {
    fromBig, split, toBig: exports.toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-simple-keyring>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-simple-keyring%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5CcryptoBrowser.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = {
    node: undefined,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,
};

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-simple-keyring>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js", {"./_assert.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js","./_u64.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_u64.js","./utils.js":"F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-simple-keyring%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5Csha3.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = require("./_assert.js");
const _u64_js_1 = require("./_u64.js");
const utils_js_1 = require("./utils.js");
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
const rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        _assert_js_1.default.number(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        _assert_js_1.default.exists(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        _assert_js_1.default.exists(this, false);
        _assert_js_1.default.bytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        _assert_js_1.default.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        _assert_js_1.default.output(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-simple-keyring>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\sha3.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js", {"@noble/hashes/crypto":"F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\cryptoBrowser.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-simple-keyring%5Cnode_modules%5Cethereum-cryptography%5Cnode_modules%5C@noble%5Chashes%5Cutils.js
      return function (require, module, exports) {
"use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// The import here is via the package name. This is to ensure
// that exports mapping/resolution does fall into place.
const crypto_1 = require("@noble/hashes/crypto");
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
// There is almost no big endian hardware, but js typed arrays uses platform specific endianness.
// So, just to be sure not to corrupt anything.
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xde, 0xad, 0xbe, 0xef]))
 */
function bytesToHex(uint8a) {
    // pre-caching improves the speed 6x
    if (!(uint8a instanceof Uint8Array))
        throw new Error('Uint8Array expected');
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += hexes[uint8a[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('deadbeef')
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow. However, call to async function will return Promise
// which will be fullfiled only on next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
function utf8ToBytes(str) {
    if (typeof str !== 'string') {
        throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
}
exports.utf8ToBytes = utf8ToBytes;
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
        throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Concats Uint8Array-s into one; like `Buffer.concat([buf1, buf2])`
 * @example concatBytes(buf1, buf2)
 */
function concatBytes(...arrays) {
    if (!arrays.every((a) => a instanceof Uint8Array))
        throw new Error('Uint8Array list expected');
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
// Check if object doens't have custom constructor (like Uint8Array/Array)
const isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;
function checkOpts(defaults, opts) {
    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))
        throw new TypeError('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
/**
 * Secure PRNG
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto.web) {
        return crypto_1.crypto.web.getRandomValues(new Uint8Array(bytesLength));
    }
    else if (crypto_1.crypto.node) {
        return new Uint8Array(crypto_1.crypto.node.randomBytes(bytesLength).buffer);
    }
    else {
        throw new Error("The environment doesn't have randomBytes function");
    }
}
exports.randomBytes = randomBytes;

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-simple-keyring>ethereum-cryptography>@noble/hashes",file:"node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\utils.js", {"@noble/hashes/_assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\_assert.js","@noble/hashes/utils":"F:\\metamask-extension\\node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\node_modules\\@noble\\hashes\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-simple-keyring%5Cnode_modules%5Cethereum-cryptography%5Cutils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = exports.wrapHash = exports.equalsBytes = exports.hexToBytes = exports.bytesToUtf8 = exports.utf8ToBytes = exports.createView = exports.concatBytes = exports.toHex = exports.bytesToHex = exports.assertBytes = exports.assertBool = void 0;
// buf.toString('hex') -> toHex(buf)
const _assert_1 = __importDefault(require("@noble/hashes/_assert"));
const utils_1 = require("@noble/hashes/utils");
const assertBool = _assert_1.default.bool;
exports.assertBool = assertBool;
const assertBytes = _assert_1.default.bytes;
exports.assertBytes = assertBytes;
var utils_2 = require("@noble/hashes/utils");
Object.defineProperty(exports, "bytesToHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
Object.defineProperty(exports, "toHex", { enumerable: true, get: function () { return utils_2.bytesToHex; } });
Object.defineProperty(exports, "concatBytes", { enumerable: true, get: function () { return utils_2.concatBytes; } });
Object.defineProperty(exports, "createView", { enumerable: true, get: function () { return utils_2.createView; } });
Object.defineProperty(exports, "utf8ToBytes", { enumerable: true, get: function () { return utils_2.utf8ToBytes; } });
// buf.toString('utf8') -> bytesToUtf8(buf)
function bytesToUtf8(data) {
    if (!(data instanceof Uint8Array)) {
        throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
    }
    return new TextDecoder().decode(data);
}
exports.bytesToUtf8 = bytesToUtf8;
function hexToBytes(data) {
    const sliced = data.startsWith("0x") ? data.substring(2) : data;
    return (0, utils_1.hexToBytes)(sliced);
}
exports.hexToBytes = hexToBytes;
// buf.equals(buf2) -> equalsBytes(buf, buf2)
function equalsBytes(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.equalsBytes = equalsBytes;
// Internal utils
function wrapHash(hash) {
    return (msg) => {
        _assert_1.default.bytes(msg);
        return hash(msg);
    };
}
exports.wrapHash = wrapHash;
exports.crypto = (() => {
    const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : undefined;
    const nodeRequire = typeof module !== "undefined" &&
        typeof module.require === "function" &&
        module.require.bind(module);
    return {
        node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
        web: webCrypto
    };
})();

      };
    };
  }
  }
}, {package:"@metamask/eth-keyring-controller>@metamask/eth-simple-keyring>ethereum-cryptography",file:"node_modules\\@metamask\\eth-simple-keyring\\node_modules\\ethereum-cryptography\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\index.js", {"@ethereumjs/tx":"F:\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist\\index.js","@ethereumjs/util":"F:\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@trezor/connect-plugin-ethereum":"F:\\metamask-extension\\node_modules\\@trezor\\connect-plugin-ethereum\\lib\\index.js","@trezor/connect-web":"F:\\metamask-extension\\node_modules\\@trezor\\connect-web\\lib\\index.js","buffer":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","hdkey":"F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\hdkey\\lib\\hdkey.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-trezor-keyring%5Cindex.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events');
const ethUtil = require('@ethereumjs/util');
const HDKey = require('hdkey');
const TrezorConnect = require('@trezor/connect-web').default;
const { TransactionFactory } = require('@ethereumjs/tx');
const { transformTypedData } = require('@trezor/connect-plugin-ethereum');

const hdPathString = `m/44'/60'/0'/0`;
const SLIP0044TestnetPath = `m/44'/1'/0'/0`;

const ALLOWED_HD_PATHS = {
  [hdPathString]: true,
  [SLIP0044TestnetPath]: true,
};

const keyringType = 'Trezor Hardware';
const pathBase = 'm';
const MAX_INDEX = 1000;
const DELAY_BETWEEN_POPUPS = 1000;
const TREZOR_CONNECT_MANIFEST = {
  email: 'support@metamask.io',
  appUrl: 'https://metamask.io',
};

function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * @typedef {__import__('@ethereumjs/tx').TypedTransaction} TypedTransaction
 * @typedef {InstanceType<__import__("ethereumjs-tx")>} OldEthJsTransaction
 */

/**
 * Check if the given transaction is made with ethereumjs-tx or @ethereumjs/tx
 *
 * Transactions built with older versions of ethereumjs-tx have a
 * getChainId method that newer versions do not.
 * Older versions are mutable
 * while newer versions default to being immutable.
 * Expected shape and type
 * of data for v, r and s differ (Buffer (old) vs BN (new)).
 *
 * @param {TypedTransaction | OldEthJsTransaction} tx
 * @returns {tx is OldEthJsTransaction} Returns `true` if tx is an old-style ethereumjs-tx transaction.
 */
function isOldStyleEthereumjsTx(tx) {
  return typeof tx.getChainId === 'function';
}

class TrezorKeyring extends EventEmitter {
  constructor(opts = {}) {
    super();
    this.type = keyringType;
    this.accounts = [];
    this.hdk = new HDKey();
    this.page = 0;
    this.perPage = 5;
    this.unlockedAccount = 0;
    this.paths = {};
    this.deserialize(opts);
    this.trezorConnectInitiated = false;

    TrezorConnect.on('DEVICE_EVENT', (event) => {
      if (event && event.payload && event.payload.features) {
        this.model = event.payload.features.model;
      }
    });

    if (!this.trezorConnectInitiated) {
      TrezorConnect.init({ manifest: TREZOR_CONNECT_MANIFEST, lazyLoad: true });
      this.trezorConnectInitiated = true;
    }
  }

  /**
   * Gets the model, if known.
   * This may be `undefined` if the model hasn't been loaded yet.
   *
   * @returns {"T" | "1" | undefined}
   */
  getModel() {
    return this.model;
  }

  dispose() {
    // This removes the Trezor Connect iframe from the DOM
    // This method is not well documented, but the code it calls can be seen
    // here: https://github.com/trezor/connect/blob/dec4a56af8a65a6059fb5f63fa3c6690d2c37e00/src/js/iframe/builder.js#L181
    TrezorConnect.dispose();
  }

  serialize() {
    return Promise.resolve({
      hdPath: this.hdPath,
      accounts: this.accounts,
      page: this.page,
      paths: this.paths,
      perPage: this.perPage,
      unlockedAccount: this.unlockedAccount,
    });
  }

  deserialize(opts = {}) {
    this.hdPath = opts.hdPath || hdPathString;
    this.accounts = opts.accounts || [];
    this.page = opts.page || 0;
    this.perPage = opts.perPage || 5;
    return Promise.resolve();
  }

  isUnlocked() {
    return Boolean(this.hdk && this.hdk.publicKey);
  }

  unlock() {
    if (this.isUnlocked()) {
      return Promise.resolve('already unlocked');
    }
    return new Promise((resolve, reject) => {
      TrezorConnect.getPublicKey({
        path: this.hdPath,
        coin: 'ETH',
      })
        .then((response) => {
          if (response.success) {
            this.hdk.publicKey = Buffer.from(response.payload.publicKey, 'hex');
            this.hdk.chainCode = Buffer.from(response.payload.chainCode, 'hex');
            resolve('just unlocked');
          } else {
            reject(
              new Error(
                (response.payload && response.payload.error) || 'Unknown error',
              ),
            );
          }
        })
        .catch((e) => {
          reject(new Error((e && e.toString()) || 'Unknown error'));
        });
    });
  }

  setAccountToUnlock(index) {
    this.unlockedAccount = parseInt(index, 10);
  }

  addAccounts(n = 1) {
    return new Promise((resolve, reject) => {
      this.unlock()
        .then((_) => {
          const from = this.unlockedAccount;
          const to = from + n;

          for (let i = from; i < to; i++) {
            const address = this._addressFromIndex(pathBase, i);
            if (!this.accounts.includes(address)) {
              this.accounts.push(address);
            }
            this.page = 0;
          }
          resolve(this.accounts);
        })
        .catch((e) => {
          reject(e);
        });
    });
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  __getPage(increment) {
    this.page += increment;

    if (this.page <= 0) {
      this.page = 1;
    }

    return new Promise((resolve, reject) => {
      this.unlock()
        .then((_) => {
          const from = (this.page - 1) * this.perPage;
          const to = from + this.perPage;

          const accounts = [];

          for (let i = from; i < to; i++) {
            const address = this._addressFromIndex(pathBase, i);
            accounts.push({
              address,
              balance: null,
              index: i,
            });
            this.paths[ethUtil.toChecksumAddress(address)] = i;
          }
          resolve(accounts);
        })
        .catch((e) => {
          reject(e);
        });
    });
  }

  getAccounts() {
    return Promise.resolve(this.accounts.slice());
  }

  removeAccount(address) {
    if (
      !this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())
    ) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(
      (a) => a.toLowerCase() !== address.toLowerCase(),
    );
  }

  /**
   * Signs a transaction using Trezor.
   *
   * Accepts either an ethereumjs-tx or @ethereumjs/tx transaction, and returns
   * the same type.
   *
   * @template {TypedTransaction | OldEthJsTransaction} Transaction
   * @param {string} address - Hex string address.
   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.
   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style
   * ethereumjs transaction.
   */
  signTransaction(address, tx) {
    if (isOldStyleEthereumjsTx(tx)) {
      // In this version of ethereumjs-tx we must add the chainId in hex format
      // to the initial v value. The chainId must be included in the serialized
      // transaction which is only communicated to ethereumjs-tx in this
      // value. In newer versions the chainId is communicated via the 'Common'
      // object.
      return this._signTransaction(address, tx.getChainId(), tx, (payload) => {
        tx.v = Buffer.from(payload.v, 'hex');
        tx.r = Buffer.from(payload.r, 'hex');
        tx.s = Buffer.from(payload.s, 'hex');
        return tx;
      });
    }
    return this._signTransaction(
      address,
      Number(tx.common.chainId()),
      tx,
      (payload) => {
        // Because tx will be immutable, first get a plain javascript object that
        // represents the transaction. Using txData here as it aligns with the
        // nomenclature of ethereumjs/tx.
        const txData = tx.toJSON();
        // The fromTxData utility expects a type to support transactions with a type other than 0
        txData.type = tx.type;
        // The fromTxData utility expects v,r and s to be hex prefixed
        txData.v = ethUtil.addHexPrefix(payload.v);
        txData.r = ethUtil.addHexPrefix(payload.r);
        txData.s = ethUtil.addHexPrefix(payload.s);
        // Adopt the 'common' option from the original transaction and set the
        // returned object to be frozen if the original is frozen.
        return TransactionFactory.fromTxData(txData, {
          common: tx.common,
          freeze: Object.isFrozen(tx),
        });
      },
    );
  }

  /**
   *
   * @template {TypedTransaction | OldEthJsTransaction} Transaction
   * @param {string} address - Hex string address.
   * @param {number} chainId - Chain ID
   * @param {Transaction} tx - Instance of either new-style or old-style ethereumjs transaction.
   * @param {(__import__('trezor-connect').EthereumSignedTx) => Transaction} handleSigning - Converts signed transaction
   * to the same new-style or old-style ethereumjs-tx.
   * @returns {Promise<Transaction>} The signed transaction, an instance of either new-style or old-style
   * ethereumjs transaction.
   */
  async _signTransaction(address, chainId, tx, handleSigning) {
    let transaction;
    if (isOldStyleEthereumjsTx(tx)) {
      // legacy transaction from ethereumjs-tx package has no .toJSON() function,
      // so we need to convert to hex-strings manually manually
      transaction = {
        to: this._normalize(tx.to),
        value: this._normalize(tx.value),
        data: this._normalize(tx.data),
        chainId,
        nonce: this._normalize(tx.nonce),
        gasLimit: this._normalize(tx.gasLimit),
        gasPrice: this._normalize(tx.gasPrice),
      };
    } else {
      // new-style transaction from @ethereumjs/tx package
      // we can just copy tx.toJSON() for everything except chainId, which must be a number
      transaction = {
        ...tx.toJSON(),
        chainId,
        to: this._normalize(tx.to),
      };
    }

    try {
      const status = await this.unlock();
      await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);
      const response = await TrezorConnect.ethereumSignTransaction({
        path: this._pathFromAddress(address),
        transaction,
      });
      if (response.success) {
        const newOrMutatedTx = handleSigning(response.payload);

        const addressSignedWith = ethUtil.toChecksumAddress(
          ethUtil.addHexPrefix(
            newOrMutatedTx.getSenderAddress().toString('hex'),
          ),
        );
        const correctAddress = ethUtil.toChecksumAddress(address);
        if (addressSignedWith !== correctAddress) {
          throw new Error("signature doesn't match the right address");
        }

        return newOrMutatedTx;
      }
      throw new Error(
        (response.payload && response.payload.error) || 'Unknown error',
      );
    } catch (e) {
      throw new Error((e && e.toString()) || 'Unknown error');
    }
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  // For personal_sign, we need to prefix the message:
  signPersonalMessage(withAccount, message) {
    return new Promise((resolve, reject) => {
      this.unlock()
        .then((status) => {
          setTimeout(
            (_) => {
              TrezorConnect.ethereumSignMessage({
                path: this._pathFromAddress(withAccount),
                message: ethUtil.stripHexPrefix(message),
                hex: true,
              })
                .then((response) => {
                  if (response.success) {
                    if (
                      response.payload.address !==
                      ethUtil.toChecksumAddress(withAccount)
                    ) {
                      reject(
                        new Error('signature doesnt match the right address'),
                      );
                    }
                    const signature = `0x${response.payload.signature}`;
                    resolve(signature);
                  } else {
                    reject(
                      new Error(
                        (response.payload && response.payload.error) ||
                          'Unknown error',
                      ),
                    );
                  }
                })
                .catch((e) => {
                  reject(new Error((e && e.toString()) || 'Unknown error'));
                });
              // This is necessary to avoid popup collision
              // between the unlock & sign trezor popups
            },
            status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0,
          );
        })
        .catch((e) => {
          reject(new Error((e && e.toString()) || 'Unknown error'));
        });
    });
  }

  /**
   * EIP-712 Sign Typed Data
   */
  async signTypedData(address, data, { version }) {
    const dataWithHashes = transformTypedData(data, version === 'V4');

    // set default values for signTypedData
    // Trezor is stricter than @metamask/eth-sig-util in what it accepts
    const {
      types: { EIP712Domain = [], ...otherTypes } = {},
      message = {},
      domain = {},
      primaryType,
      // snake_case since Trezor uses Protobuf naming conventions here
      domain_separator_hash, // eslint-disable-line camelcase
      message_hash, // eslint-disable-line camelcase
    } = dataWithHashes;

    // This is necessary to avoid popup collision
    // between the unlock & sign trezor popups
    const status = await this.unlock();
    await wait(status === 'just unlocked' ? DELAY_BETWEEN_POPUPS : 0);

    const response = await TrezorConnect.ethereumSignTypedData({
      path: this._pathFromAddress(address),
      data: {
        types: { EIP712Domain, ...otherTypes },
        message,
        domain,
        primaryType,
      },
      metamask_v4_compat: true,
      // Trezor 1 only supports blindly signing hashes
      domain_separator_hash,
      message_hash,
    });

    if (response.success) {
      if (ethUtil.toChecksumAddress(address) !== response.payload.address) {
        throw new Error('signature doesnt match the right address');
      }
      return response.payload.signature;
    }

    throw new Error(
      (response.payload && response.payload.error) || 'Unknown error',
    );
  }

  exportAccount() {
    return Promise.reject(new Error('Not supported on this device'));
  }

  forgetDevice() {
    this.accounts = [];
    this.hdk = new HDKey();
    this.page = 0;
    this.unlockedAccount = 0;
    this.paths = {};
  }

  /**
   * Set the HD path to be used by the keyring. Only known supported HD paths are allowed.
   *
   * If the given HD path is already the current HD path, nothing happens. Otherwise the new HD
   * path is set, and the wallet state is completely reset.
   *
   * @throws {Error] Throws if the HD path is not supported.
   *
   * @param {string} hdPath - The HD path to set.
   */
  setHdPath(hdPath) {
    if (!ALLOWED_HD_PATHS[hdPath]) {
      throw new Error(
        `The setHdPath method does not support setting HD Path to ${hdPath}`,
      );
    }

    // Reset HDKey if the path changes
    if (this.hdPath !== hdPath) {
      this.hdk = new HDKey();
      this.accounts = [];
      this.page = 0;
      this.perPage = 5;
      this.unlockedAccount = 0;
      this.paths = {};
    }
    this.hdPath = hdPath;
  }

  /* PRIVATE METHODS */

  _normalize(buf) {
    return ethUtil.bufferToHex(buf).toString();
  }

  // eslint-disable-next-line no-shadow
  _addressFromIndex(pathBase, i) {
    const dkey = this.hdk.derive(`${pathBase}/${i}`);
    const address = ethUtil
      .publicToAddress(dkey.publicKey, true)
      .toString('hex');
    return ethUtil.toChecksumAddress(`0x${address}`);
  }

  _pathFromAddress(address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address);
    let index = this.paths[checksummedAddress];
    if (typeof index === 'undefined') {
      for (let i = 0; i < MAX_INDEX; i++) {
        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
          index = i;
          break;
        }
      }
    }

    if (typeof index === 'undefined') {
      throw new Error('Unknown address');
    }
    return `${this.hdPath}/${index}`;
  }
}

TrezorKeyring.type = keyringType;
module.exports = TrezorKeyring;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring",file:"node_modules\\@metamask\\eth-trezor-keyring\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\hdkey\\lib\\hdkey.js", {"assert":"F:\\metamask-extension\\node_modules\\browserify\\node_modules\\assert\\assert.js","coinstring":"F:\\metamask-extension\\node_modules\\coinstring\\lib\\coinstring.js","crypto":"F:\\metamask-extension\\node_modules\\crypto-browserify\\index.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js","secp256k1":"F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-trezor-keyring%5Cnode_modules%5Chdkey%5Clib%5Chdkey.js
      return function (require, module, exports) {
var assert = require('assert')
var Buffer = require('safe-buffer').Buffer
var crypto = require('crypto')
var cs = require('coinstring')
var secp256k1 = require('secp256k1')

var MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')
var HARDENED_OFFSET = 0x80000000
var LEN = 78

// Bitcoin hardcoded by default, can use package `coininfo` for others
var BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}

function HDKey (versions) {
  this.versions = versions || BITCOIN_VERSIONS
  this.depth = 0
  this.index = 0
  this._privateKey = null
  this._publicKey = null
  this.chainCode = null
  this._fingerprint = 0
  this.parentFingerprint = 0
}

Object.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })
Object.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })
Object.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })

Object.defineProperty(HDKey.prototype, 'privateKey', {
  get: function () {
    return this._privateKey
  },
  set: function (value) {
    assert.equal(value.length, 32, 'Private key must be 32 bytes.')
    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')

    this._privateKey = value
    this._publicKey = secp256k1.publicKeyCreate(value, true)
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
  }
})

Object.defineProperty(HDKey.prototype, 'publicKey', {
  get: function () {
    return this._publicKey
  },
  set: function (value) {
    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')
    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')

    this._publicKey = secp256k1.publicKeyConvert(value, true) // force compressed point
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
    this._privateKey = null
  }
})

Object.defineProperty(HDKey.prototype, 'privateExtendedKey', {
  get: function () {
    if (this._privateKey) return cs.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))
    else return null
  }
})

Object.defineProperty(HDKey.prototype, 'publicExtendedKey', {
  get: function () {
    return cs.encode(serialize(this, this.versions.public, this.publicKey))
  }
})

HDKey.prototype.derive = function (path) {
  if (path === 'm' || path === 'M' || path === "m'" || path === "M'") {
    return this
  }

  var entries = path.split('/')
  var hdkey = this
  entries.forEach(function (c, i) {
    if (i === 0) {
      assert(c, 'm', 'Invalid path')
      return
    }

    var hardened = (c.length > 1) && (c[c.length - 1] === "'")
    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)
    assert(childIndex < HARDENED_OFFSET, 'Invalid index')
    if (hardened) childIndex += HARDENED_OFFSET

    hdkey = hdkey.deriveChild(childIndex)
  })

  return hdkey
}

HDKey.prototype.deriveChild = function (index) {
  var isHardened = index >= HARDENED_OFFSET
  var indexBuffer = Buffer.allocUnsafe(4)
  indexBuffer.writeUInt32BE(index, 0)

  var data

  if (isHardened) { // Hardened child
    assert(this.privateKey, 'Could not derive hardened child key')

    var pk = this.privateKey
    var zb = Buffer.alloc(1, 0)
    pk = Buffer.concat([zb, pk])

    // data = 0x00 || ser256(kpar) || ser32(index)
    data = Buffer.concat([pk, indexBuffer])
  } else { // Normal child
    // data = serP(point(kpar)) || ser32(index)
    //      = serP(Kpar) || ser32(index)
    data = Buffer.concat([this.publicKey, indexBuffer])
  }

  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hd = new HDKey(this.versions)

  // Private parent key -> private child key
  if (this.privateKey) {
    // ki = parse256(IL) + kpar (mod n)
    try {
      hd.privateKey = secp256k1.privateKeyTweakAdd(this.privateKey, IL)
      // throw if IL >= n || (privateKey + IL) === 0
    } catch (err) {
      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i
      return this.derive(index + 1)
    }
  // Public parent key -> public child key
  } else {
    // Ki = point(parse256(IL)) + Kpar
    //    = G*IL + Kpar
    try {
      hd.publicKey = secp256k1.publicKeyTweakAdd(this.publicKey, IL, true)
      // throw if IL >= n || (g**IL + publicKey) is infinity
    } catch (err) {
      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i
      return this.derive(index + 1, isHardened)
    }
  }

  hd.chainCode = IR
  hd.depth = this.depth + 1
  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)
  hd.index = index

  return hd
}

HDKey.prototype.sign = function (hash) {
  return secp256k1.sign(hash, this.privateKey).signature
}

HDKey.prototype.verify = function (hash, signature) {
  return secp256k1.verify(hash, signature, this.publicKey)
}

HDKey.prototype.toJSON = function () {
  return {
    xpriv: this.privateExtendedKey,
    xpub: this.publicExtendedKey
  }
}

HDKey.fromMasterSeed = function (seedBuffer, versions) {
  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hdkey = new HDKey(versions)
  hdkey.chainCode = IR
  hdkey.privateKey = IL

  return hdkey
}

HDKey.fromExtendedKey = function (base58key, versions) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  versions = versions || BITCOIN_VERSIONS
  var hdkey = new HDKey(versions)

  var keyBuffer = cs.decode(base58key)

  var version = keyBuffer.readUInt32BE(0)
  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')

  hdkey.depth = keyBuffer.readUInt8(4)
  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)
  hdkey.index = keyBuffer.readUInt32BE(9)
  hdkey.chainCode = keyBuffer.slice(13, 45)

  var key = keyBuffer.slice(45)
  if (key.readUInt8(0) === 0) { // private
    assert(version === versions.private, 'Version mismatch: version does not match private')
    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte
  } else {
    assert(version === versions.public, 'Version mismatch: version does not match public')
    hdkey.publicKey = key
  }

  return hdkey
}

HDKey.fromJSON = function (obj) {
  return HDKey.fromExtendedKey(obj.xpriv)
}

function serialize (hdkey, version, key) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  var buffer = Buffer.allocUnsafe(LEN)

  buffer.writeUInt32BE(version, 0)
  buffer.writeUInt8(hdkey.depth, 4)

  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000
  buffer.writeUInt32BE(fingerprint, 5)
  buffer.writeUInt32BE(hdkey.index, 9)

  hdkey.chainCode.copy(buffer, 13)
  key.copy(buffer, 45)

  return buffer
}

function hash160 (buf) {
  var sha = crypto.createHash('sha256').update(buf).digest()
  return crypto.createHash('rmd160').update(sha).digest()
}

HDKey.HARDENED_OFFSET = HARDENED_OFFSET
module.exports = HDKey

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>hdkey",file:"node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\hdkey\\lib\\hdkey.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\elliptic.js", {"./lib":"F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\index.js","./lib/elliptic":"F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-trezor-keyring%5Cnode_modules%5Csecp256k1%5Celliptic.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib')(require('./lib/elliptic'))

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\elliptic.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\assert.js", {"../../../../../is-buffer/index.js":"F:\\metamask-extension\\node_modules\\is-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-trezor-keyring%5Cnode_modules%5Csecp256k1%5Clib%5Cassert.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'
var toString = Object.prototype.toString

// TypeError
exports.isArray = function (value, message) {
  if (!Array.isArray(value)) throw TypeError(message)
}

exports.isBoolean = function (value, message) {
  if (toString.call(value) !== '[object Boolean]') throw TypeError(message)
}

exports.isBuffer = function (value, message) {
  if (!Buffer.isBuffer(value)) throw TypeError(message)
}

exports.isFunction = function (value, message) {
  if (toString.call(value) !== '[object Function]') throw TypeError(message)
}

exports.isNumber = function (value, message) {
  if (toString.call(value) !== '[object Number]') throw TypeError(message)
}

exports.isObject = function (value, message) {
  if (toString.call(value) !== '[object Object]') throw TypeError(message)
}

// RangeError
exports.isBufferLength = function (buffer, length, message) {
  if (buffer.length !== length) throw RangeError(message)
}

exports.isBufferLength2 = function (buffer, length1, length2, message) {
  if (buffer.length !== length1 && buffer.length !== length2) throw RangeError(message)
}

exports.isLengthGTZero = function (value, message) {
  if (value.length === 0) throw RangeError(message)
}

exports.isNumberInInterval = function (number, x, y, message) {
  if (number <= x || number >= y) throw RangeError(message)
}

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\assert.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\der.js", {"bip66":"F:\\metamask-extension\\node_modules\\bip66\\index.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-trezor-keyring%5Cnode_modules%5Csecp256k1%5Clib%5Cder.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var bip66 = require('bip66')

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
  // begin
  0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x21, 0x02, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
  // begin
  0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x41, 0x04, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0E, 0x11,
  0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10,
  0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED)
  privateKey.copy(result, compressed ? 8 : 9)
  publicKey.copy(result, compressed ? 181 : 214)
  return result
}

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length

  // sequence header
  var index = 0
  if (length < index + 1 || privateKey[index] !== 0x30) return
  index += 1

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return

  var lenb = privateKey[index] & 0x7f
  index += 1
  if (lenb < 1 || lenb > 2) return
  if (length < index + lenb) return

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0)
  index += lenb
  if (length < index + len) return

  // sequence element 0: version number (=1)
  if (length < index + 3 ||
      privateKey[index] !== 0x02 ||
      privateKey[index + 1] !== 0x01 ||
      privateKey[index + 2] !== 0x01) {
    return
  }
  index += 3

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 ||
      privateKey[index] !== 0x04 ||
      privateKey[index + 1] > 0x20 ||
      length < index + 2 + privateKey[index + 1]) {
    return
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1])
}

exports.signatureExport = function (sigObj) {
  var r = Buffer.concat([Buffer.from([0]), sigObj.r])
  for (var lenR = 33, posR = 0; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

  var s = Buffer.concat([Buffer.from([0]), sigObj.s])
  for (var lenS = 33, posS = 0; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

  return bip66.encode(r.slice(posR), s.slice(posS))
}

exports.signatureImport = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  try {
    var sigObj = bip66.decode(sig)
    if (sigObj.r.length === 33 && sigObj.r[0] === 0x00) sigObj.r = sigObj.r.slice(1)
    if (sigObj.r.length > 32) throw new Error('R length is too long')
    if (sigObj.s.length === 33 && sigObj.s[0] === 0x00) sigObj.s = sigObj.s.slice(1)
    if (sigObj.s.length > 32) throw new Error('S length is too long')
  } catch (err) {
    return
  }

  sigObj.r.copy(r, 32 - sigObj.r.length)
  sigObj.s.copy(s, 32 - sigObj.s.length)

  return { r: r, s: s }
}

exports.signatureImportLax = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  var length = sig.length
  var index = 0

  // sequence tag byte
  if (sig[index++] !== 0x30) return

  // sequence length byte
  var lenbyte = sig[index++]
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80
    if (index > length) return
  }

  // sequence tag byte for r
  if (sig[index++] !== 0x02) return

  // length for r
  var rlen = sig[index++]
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) rlen = (rlen << 8) + sig[index]
  }
  if (rlen > length - index) return
  var rindex = index
  index += rlen

  // sequence tag byte for s
  if (sig[index++] !== 0x02) return

  // length for s
  var slen = sig[index++]
  if (slen & 0x80) {
    lenbyte = slen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) slen = (slen << 8) + sig[index]
  }
  if (slen > length - index) return
  var sindex = index
  index += slen

  // ignore leading zeros in r
  for (; rlen > 0 && sig[rindex] === 0x00; rlen -= 1, rindex += 1);
  // copy r value
  if (rlen > 32) return
  var rvalue = sig.slice(rindex, rindex + rlen)
  rvalue.copy(r, 32 - rvalue.length)

  // ignore leading zeros in s
  for (; slen > 0 && sig[sindex] === 0x00; slen -= 1, sindex += 1);
  // copy s value
  if (slen > 32) return
  var svalue = sig.slice(sindex, sindex + slen)
  svalue.copy(s, 32 - svalue.length)

  return { r: r, s: s }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\der.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js", {"../messages.json":"F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\messages.json","bn.js":"F:\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","create-hash":"F:\\metamask-extension\\node_modules\\create-hash\\browser.js","elliptic":"F:\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js","safe-buffer":"F:\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-trezor-keyring%5Cnode_modules%5Csecp256k1%5Clib%5Celliptic%5Cindex.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var createHash = require('create-hash')
var BN = require('bn.js')
var EC = require('elliptic').ec

var messages = require('../messages.json')

var ec = new EC('secp256k1')
var ecparams = ec.curve

function loadCompressedPublicKey (first, xBuffer) {
  var x = new BN(xBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xBuffer, yBuffer) {
  var x = new BN(xBuffer)
  var y = new BN(yBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  var x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (publicKey) {
  var first = publicKey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (publicKey.length !== 33) return null
      return loadCompressedPublicKey(first, publicKey.slice(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (publicKey.length !== 65) return null
      return loadUncompressedPublicKey(first, publicKey.slice(1, 33), publicKey.slice(33, 65))
    default:
      return null
  }
}

exports.privateKeyVerify = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.cmp(ecparams.n) < 0 && !bn.isZero()
}

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.privateKeyNegate = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.isZero() ? Buffer.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID)

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakAdd = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  bn.iadd(new BN(privateKey))
  if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
  if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakMul = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL)

  bn.imul(new BN(privateKey))
  if (bn.cmp(ecparams.n)) bn = bn.umod(ecparams.n)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.publicKeyCreate = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.publicKeyConvert = function (publicKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return Buffer.from(pair.getPublic(compressed, true))
}

exports.publicKeyVerify = function (publicKey) {
  return loadPublicKey(publicKey) !== null
}

exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  var point = ecparams.g.mul(tweak).add(pair.pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL)

  return Buffer.from(pair.pub.mul(tweak).encode(true, compressed))
}

exports.publicKeyCombine = function (publicKeys, compressed) {
  var pairs = new Array(publicKeys.length)
  for (var i = 0; i < publicKeys.length; ++i) {
    pairs[i] = loadPublicKey(publicKeys[i])
    if (pairs[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)
  }

  var point = pairs[0].pub
  for (var j = 1; j < pairs.length; ++j) point = point.add(pairs[j].pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.signatureNormalize = function (signature) {
  var r = new BN(signature.slice(0, 32))
  var s = new BN(signature.slice(32, 64))
  if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  var result = Buffer.from(signature)
  if (s.cmp(ec.nh) === 1) ecparams.n.sub(s).toArrayLike(Buffer, 'be', 32).copy(result, 32)

  return result
}

exports.signatureExport = function (signature) {
  var r = signature.slice(0, 32)
  var s = signature.slice(32, 64)
  if (new BN(r).cmp(ecparams.n) >= 0 || new BN(s).cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  return { r: r, s: s }
}

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r)
  if (r.cmp(ecparams.n) >= 0) r = new BN(0)

  var s = new BN(sigObj.s)
  if (s.cmp(ecparams.n) >= 0) s = new BN(0)

  return Buffer.concat([
    r.toArrayLike(Buffer, 'be', 32),
    s.toArrayLike(Buffer, 'be', 32)
  ])
}

exports.sign = function (message, privateKey, noncefn, data) {
  if (typeof noncefn === 'function') {
    var getNonce = noncefn
    noncefn = function (counter) {
      var nonce = getNonce(message, privateKey, null, data, counter)
      if (!Buffer.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL)

      return new BN(nonce)
    }
  }

  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL)

  var result = ec.sign(message, privateKey, { canonical: true, k: noncefn, pers: data })
  return {
    signature: Buffer.concat([
      result.r.toArrayLike(Buffer, 'be', 32),
      result.s.toArrayLike(Buffer, 'be', 32)
    ]),
    recovery: result.recoveryParam
  }
}

exports.verify = function (message, signature, publicKey) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)
  if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return false

  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return ec.verify(message, sigObj, { x: pair.pub.x, y: pair.pub.y })
}

exports.recover = function (message, signature, recovery, compressed) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  try {
    if (sigr.isZero() || sigs.isZero()) throw new Error()

    var point = ec.recoverPubKey(message, sigObj, recovery)
    return Buffer.from(point.encode(true, compressed))
  } catch (err) {
    throw new Error(messages.ECDSA_RECOVER_FAIL)
  }
}

exports.ecdh = function (publicKey, privateKey) {
  var shared = exports.ecdhUnsafe(publicKey, privateKey, true)
  return createHash('sha256').update(shared).digest()
}

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  var scalar = new BN(privateKey)
  if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) throw new Error(messages.ECDH_FAIL)

  return Buffer.from(pair.pub.mul(scalar).encode(true, compressed))
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\index.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\assert.js","./der":"F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\der.js","./messages.json":"F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\messages.json"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-trezor-keyring%5Cnode_modules%5Csecp256k1%5Clib%5Cindex.js
      return function (require, module, exports) {
'use strict'
var assert = require('./assert')
var der = require('./der')
var messages = require('./messages.json')

function initCompressedValue (value, defaultValue) {
  if (value === undefined) return defaultValue

  assert.isBoolean(value, messages.COMPRESSED_TYPE_INVALID)
  return value
}

module.exports = function (secp256k1) {
  return {
    privateKeyVerify: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)
    },

    privateKeyExport: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)
      var publicKey = secp256k1.privateKeyExport(privateKey, compressed)

      return der.privateKeyExport(privateKey, publicKey, compressed)
    },

    privateKeyImport: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)

      privateKey = der.privateKeyImport(privateKey)
      if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)) return privateKey

      throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL)
    },

    privateKeyNegate: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyNegate(privateKey)
    },

    privateKeyModInverse: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyModInverse(privateKey)
    },

    privateKeyTweakAdd: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakAdd(privateKey, tweak)
    },

    privateKeyTweakMul: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakMul(privateKey, tweak)
    },

    publicKeyCreate: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCreate(privateKey, compressed)
    },

    publicKeyConvert: function (publicKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyConvert(publicKey, compressed)
    },

    publicKeyVerify: function (publicKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      return secp256k1.publicKeyVerify(publicKey)
    },

    publicKeyTweakAdd: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed)
    },

    publicKeyTweakMul: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed)
    },

    publicKeyCombine: function (publicKeys, compressed) {
      assert.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID)
      assert.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID)
      for (var i = 0; i < publicKeys.length; ++i) {
        assert.isBuffer(publicKeys[i], messages.EC_PUBLIC_KEY_TYPE_INVALID)
        assert.isBufferLength2(publicKeys[i], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)
      }

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCombine(publicKeys, compressed)
    },

    signatureNormalize: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      return secp256k1.signatureNormalize(signature)
    },

    signatureExport: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = secp256k1.signatureExport(signature)
      return der.signatureExport(sigObj)
    },

    signatureImport: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImport(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    signatureImportLax: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImportLax(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    sign: function (message, privateKey, options) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      var data = null
      var noncefn = null
      if (options !== undefined) {
        assert.isObject(options, messages.OPTIONS_TYPE_INVALID)

        if (options.data !== undefined) {
          assert.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID)
          assert.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID)
          data = options.data
        }

        if (options.noncefn !== undefined) {
          assert.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID)
          noncefn = options.noncefn
        }
      }

      return secp256k1.sign(message, privateKey, noncefn, data)
    },

    verify: function (message, signature, publicKey) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      return secp256k1.verify(message, signature, publicKey)
    },

    recover: function (message, signature, recovery, compressed) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID)
      assert.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.recover(message, signature, recovery, compressed)
    },

    ecdh: function (publicKey, privateKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.ecdh(publicKey, privateKey)
    },

    ecdhUnsafe: function (publicKey, privateKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed)
    }
  }
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\messages.json", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ceth-trezor-keyring%5Cnode_modules%5Csecp256k1%5Clib%5Cmessages.json
      return function (require, module, exports) {
module.exports={
  "COMPRESSED_TYPE_INVALID": "compressed should be a boolean",
  "EC_PRIVATE_KEY_TYPE_INVALID": "private key should be a Buffer",
  "EC_PRIVATE_KEY_LENGTH_INVALID": "private key length is invalid",
  "EC_PRIVATE_KEY_RANGE_INVALID": "private key range is invalid",
  "EC_PRIVATE_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting private key is invalid",
  "EC_PRIVATE_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PRIVATE_KEY_EXPORT_DER_FAIL": "couldn't export to DER format",
  "EC_PRIVATE_KEY_IMPORT_DER_FAIL": "couldn't import from DER format",
  "EC_PUBLIC_KEYS_TYPE_INVALID": "public keys should be an Array",
  "EC_PUBLIC_KEYS_LENGTH_INVALID": "public keys Array should have at least 1 element",
  "EC_PUBLIC_KEY_TYPE_INVALID": "public key should be a Buffer",
  "EC_PUBLIC_KEY_LENGTH_INVALID": "public key length is invalid",
  "EC_PUBLIC_KEY_PARSE_FAIL": "the public key could not be parsed or is invalid",
  "EC_PUBLIC_KEY_CREATE_FAIL": "private was invalid, try again",
  "EC_PUBLIC_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting public key is invalid",
  "EC_PUBLIC_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PUBLIC_KEY_COMBINE_FAIL": "the sum of the public keys is not valid",
  "ECDH_FAIL": "scalar was invalid (zero or overflow)",
  "ECDSA_SIGNATURE_TYPE_INVALID": "signature should be a Buffer",
  "ECDSA_SIGNATURE_LENGTH_INVALID": "signature length is invalid",
  "ECDSA_SIGNATURE_PARSE_FAIL": "couldn't parse signature",
  "ECDSA_SIGNATURE_PARSE_DER_FAIL": "couldn't parse DER signature",
  "ECDSA_SIGNATURE_SERIALIZE_DER_FAIL": "couldn't serialize signature to DER format",
  "ECDSA_SIGN_FAIL": "nonce generation function failed or private key is invalid",
  "ECDSA_RECOVER_FAIL": "couldn't recover public key from signature",
  "MSG32_TYPE_INVALID": "message should be a Buffer",
  "MSG32_LENGTH_INVALID": "message length is invalid",
  "OPTIONS_TYPE_INVALID": "options should be an Object",
  "OPTIONS_DATA_TYPE_INVALID": "options.data should be a Buffer",
  "OPTIONS_DATA_LENGTH_INVALID": "options.data length is invalid",
  "OPTIONS_NONCEFN_TYPE_INVALID": "options.noncefn should be a Function",
  "RECOVERY_ID_TYPE_INVALID": "recovery should be a Number",
  "RECOVERY_ID_VALUE_INVALID": "recovery should have value between -1 and 4",
  "TWEAK_TYPE_INVALID": "tweak should be a Buffer",
  "TWEAK_LENGTH_INVALID": "tweak length is invalid"
}

      };
    };
  }
  }
}, {package:"@metamask/eth-trezor-keyring>hdkey>secp256k1",file:"node_modules\\@metamask\\eth-trezor-keyring\\node_modules\\secp256k1\\lib\\messages.json",}],
["F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\GasFeeController.js", {"./determineGasFeeCalculations":"F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\determineGasFeeCalculations.js","./fetchGasEstimatesViaEthFeeHistory":"F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory.js","./gas-util":"F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\gas-util.js","@metamask/base-controller":"F:\\metamask-extension\\node_modules\\@metamask\\base-controller\\dist\\index.js","@metamask/controller-utils":"F:\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js","eth-query":"F:\\metamask-extension\\node_modules\\eth-query\\index.js","uuid":"F:\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cgas-fee-controller%5Cdist%5CGasFeeController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _GasFeeController_instances, _GasFeeController_getProvider, _GasFeeController_onNetworkControllerStateChange;
Object.defineProperty(exports, "__esModule", { value: true });
exports.GasFeeController = exports.GAS_ESTIMATE_TYPES = exports.LEGACY_GAS_PRICES_API_URL = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const uuid_1 = require("uuid");
const base_controller_1 = require("@metamask/base-controller");
const controller_utils_1 = require("@metamask/controller-utils");
const gas_util_1 = require("./gas-util");
const determineGasFeeCalculations_1 = __importDefault(require("./determineGasFeeCalculations"));
const fetchGasEstimatesViaEthFeeHistory_1 = __importDefault(require("./fetchGasEstimatesViaEthFeeHistory"));
exports.LEGACY_GAS_PRICES_API_URL = `https://api.metaswap.codefi.network/gasPrices`;
/**
 * Indicates which type of gasEstimate the controller is currently returning.
 * This is useful as a way of asserting that the shape of gasEstimates matches
 * expectations. NONE is a special case indicating that no previous gasEstimate
 * has been fetched.
 */
exports.GAS_ESTIMATE_TYPES = {
    FEE_MARKET: 'fee-market',
    LEGACY: 'legacy',
    ETH_GASPRICE: 'eth_gasPrice',
    NONE: 'none',
};
const metadata = {
    gasFeeEstimates: { persist: true, anonymous: false },
    estimatedGasFeeTimeBounds: { persist: true, anonymous: false },
    gasEstimateType: { persist: true, anonymous: false },
};
const name = 'GasFeeController';
const defaultState = {
    gasFeeEstimates: {},
    estimatedGasFeeTimeBounds: {},
    gasEstimateType: exports.GAS_ESTIMATE_TYPES.NONE,
};
/**
 * Controller that retrieves gas fee estimate data and polls for updated data on a set interval
 */
class GasFeeController extends base_controller_1.BaseControllerV2 {
    /**
     * Creates a GasFeeController instance.
     *
     * @param options - The controller options.
     * @param options.interval - The time in milliseconds to wait between polls.
     * @param options.messenger - The controller messenger.
     * @param options.state - The initial state.
     * @param options.getCurrentNetworkEIP1559Compatibility - Determines whether or not the current
     * network is EIP-1559 compatible.
     * @param options.getCurrentNetworkLegacyGasAPICompatibility - Determines whether or not the
     * current network is compatible with the legacy gas price API.
     * @param options.getCurrentAccountEIP1559Compatibility - Determines whether or not the current
     * account is EIP-1559 compatible.
     * @param options.getChainId - Returns the current chain ID.
     * @param options.getProvider - Returns a network provider for the current network.
     * @param options.onNetworkStateChange - A function for registering an event handler for the
     * network state change event.
     * @param options.legacyAPIEndpoint - The legacy gas price API URL. This option is primarily for
     * testing purposes.
     * @param options.EIP1559APIEndpoint - The EIP-1559 gas price API URL.
     * @param options.clientId - The client ID used to identify to the gas estimation API who is
     * asking for estimates.
     */
    constructor({ interval = 15000, messenger, state, getCurrentNetworkEIP1559Compatibility, getCurrentAccountEIP1559Compatibility, getChainId, getCurrentNetworkLegacyGasAPICompatibility, getProvider, onNetworkStateChange, legacyAPIEndpoint = exports.LEGACY_GAS_PRICES_API_URL, EIP1559APIEndpoint, clientId, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        _GasFeeController_instances.add(this);
        _GasFeeController_getProvider.set(this, void 0);
        this.intervalDelay = interval;
        this.pollTokens = new Set();
        this.getCurrentNetworkEIP1559Compatibility =
            getCurrentNetworkEIP1559Compatibility;
        this.getCurrentNetworkLegacyGasAPICompatibility =
            getCurrentNetworkLegacyGasAPICompatibility;
        this.getCurrentAccountEIP1559Compatibility =
            getCurrentAccountEIP1559Compatibility;
        __classPrivateFieldSet(this, _GasFeeController_getProvider, getProvider, "f");
        this.EIP1559APIEndpoint = EIP1559APIEndpoint;
        this.legacyAPIEndpoint = legacyAPIEndpoint;
        this.clientId = clientId;
        this.ethQuery = new eth_query_1.default(__classPrivateFieldGet(this, _GasFeeController_getProvider, "f").call(this));
        if (onNetworkStateChange && getChainId) {
            this.currentChainId = getChainId();
            onNetworkStateChange((networkControllerState) => __awaiter(this, void 0, void 0, function* () {
                yield __classPrivateFieldGet(this, _GasFeeController_instances, "m", _GasFeeController_onNetworkControllerStateChange).call(this, networkControllerState);
            }));
        }
        else {
            this.currentChainId = this.messagingSystem.call('NetworkController:getState').providerConfig.chainId;
            this.messagingSystem.subscribe('NetworkController:stateChange', (networkControllerState) => __awaiter(this, void 0, void 0, function* () {
                yield __classPrivateFieldGet(this, _GasFeeController_instances, "m", _GasFeeController_onNetworkControllerStateChange).call(this, networkControllerState);
            }));
        }
    }
    resetPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pollTokens.size !== 0) {
                const tokens = Array.from(this.pollTokens);
                this.stopPolling();
                yield this.getGasFeeEstimatesAndStartPolling(tokens[0]);
                tokens.slice(1).forEach((token) => {
                    this.pollTokens.add(token);
                });
            }
        });
    }
    fetchGasFeeEstimates(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._fetchGasFeeEstimateData(options);
        });
    }
    getGasFeeEstimatesAndStartPolling(pollToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pollToken = pollToken || (0, uuid_1.v1)();
            this.pollTokens.add(_pollToken);
            if (this.pollTokens.size === 1) {
                yield this._fetchGasFeeEstimateData();
                this._poll();
            }
            return _pollToken;
        });
    }
    /**
     * Gets and sets gasFeeEstimates in state.
     *
     * @param options - The gas fee estimate options.
     * @param options.shouldUpdateState - Determines whether the state should be updated with the
     * updated gas estimates.
     * @returns The gas fee estimates.
     */
    _fetchGasFeeEstimateData(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { shouldUpdateState = true } = options;
            let isEIP1559Compatible;
            const isLegacyGasAPICompatible = this.getCurrentNetworkLegacyGasAPICompatibility();
            const decimalChainId = (0, controller_utils_1.convertHexToDecimal)(this.currentChainId);
            try {
                isEIP1559Compatible = yield this.getEIP1559Compatibility();
            }
            catch (e) {
                console.error(e);
                isEIP1559Compatible = false;
            }
            const gasFeeCalculations = yield (0, determineGasFeeCalculations_1.default)({
                isEIP1559Compatible,
                isLegacyGasAPICompatible,
                fetchGasEstimates: gas_util_1.fetchGasEstimates,
                fetchGasEstimatesUrl: this.EIP1559APIEndpoint.replace('<chain_id>', `${decimalChainId}`),
                fetchGasEstimatesViaEthFeeHistory: fetchGasEstimatesViaEthFeeHistory_1.default,
                fetchLegacyGasPriceEstimates: gas_util_1.fetchLegacyGasPriceEstimates,
                fetchLegacyGasPriceEstimatesUrl: this.legacyAPIEndpoint.replace('<chain_id>', `${decimalChainId}`),
                fetchEthGasPriceEstimate: gas_util_1.fetchEthGasPriceEstimate,
                calculateTimeEstimate: gas_util_1.calculateTimeEstimate,
                clientId: this.clientId,
                ethQuery: this.ethQuery,
            });
            if (shouldUpdateState) {
                this.update((state) => {
                    state.gasFeeEstimates = gasFeeCalculations.gasFeeEstimates;
                    state.estimatedGasFeeTimeBounds =
                        gasFeeCalculations.estimatedGasFeeTimeBounds;
                    state.gasEstimateType = gasFeeCalculations.gasEstimateType;
                });
            }
            return gasFeeCalculations;
        });
    }
    /**
     * Remove the poll token, and stop polling if the set of poll tokens is empty.
     *
     * @param pollToken - The poll token to disconnect.
     */
    disconnectPoller(pollToken) {
        this.pollTokens.delete(pollToken);
        if (this.pollTokens.size === 0) {
            this.stopPolling();
        }
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
        this.pollTokens.clear();
        this.resetState();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    _poll() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
        this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield (0, controller_utils_1.safelyExecute)(() => this._fetchGasFeeEstimateData());
        }), this.intervalDelay);
    }
    resetState() {
        this.update(() => {
            return defaultState;
        });
    }
    getEIP1559Compatibility() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const currentNetworkIsEIP1559Compatible = yield this.getCurrentNetworkEIP1559Compatibility();
            const currentAccountIsEIP1559Compatible = (_b = (_a = this.getCurrentAccountEIP1559Compatibility) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : true;
            return (currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible);
        });
    }
    getTimeEstimate(maxPriorityFeePerGas, maxFeePerGas) {
        if (!this.state.gasFeeEstimates ||
            this.state.gasEstimateType !== exports.GAS_ESTIMATE_TYPES.FEE_MARKET) {
            return {};
        }
        return (0, gas_util_1.calculateTimeEstimate)(maxPriorityFeePerGas, maxFeePerGas, this.state.gasFeeEstimates);
    }
}
exports.GasFeeController = GasFeeController;
_GasFeeController_getProvider = new WeakMap(), _GasFeeController_instances = new WeakSet(), _GasFeeController_onNetworkControllerStateChange = function _GasFeeController_onNetworkControllerStateChange(networkControllerState) {
    return __awaiter(this, void 0, void 0, function* () {
        const newChainId = networkControllerState.providerConfig.chainId;
        if (newChainId !== this.currentChainId) {
            this.ethQuery = new eth_query_1.default(__classPrivateFieldGet(this, _GasFeeController_getProvider, "f").call(this));
            yield this.resetPolling();
            this.currentChainId = newChainId;
        }
    });
};
exports.default = GasFeeController;
//# sourceMappingURL=GasFeeController.js.map
      };
    };
  }
  }
}, {package:"@metamask/gas-fee-controller",file:"node_modules\\@metamask\\gas-fee-controller\\dist\\GasFeeController.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\determineGasFeeCalculations.js", {"./GasFeeController":"F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\GasFeeController.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cgas-fee-controller%5Cdist%5CdetermineGasFeeCalculations.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const GasFeeController_1 = require("./GasFeeController");
/**
 * Obtains a set of max base and priority fee estimates along with time estimates so that we
 * can present them to users when they are sending transactions or making swaps.
 *
 * @param args - The arguments.
 * @param args.isEIP1559Compatible - Governs whether or not we can use an EIP-1559-only method to
 * produce estimates.
 * @param args.isLegacyGasAPICompatible - Governs whether or not we can use a non-EIP-1559 method to
 * produce estimates (for instance, testnets do not support estimates altogether).
 * @param args.fetchGasEstimates - A function that fetches gas estimates using an EIP-1559-specific
 * API.
 * @param args.fetchGasEstimatesUrl - The URL for the API we can use to obtain EIP-1559-specific
 * estimates.
 * @param args.fetchGasEstimatesViaEthFeeHistory - A function that fetches gas estimates using
 * `eth_feeHistory` (an EIP-1559 feature).
 * @param args.fetchLegacyGasPriceEstimates - A function that fetches gas estimates using an
 * non-EIP-1559-specific API.
 * @param args.fetchLegacyGasPriceEstimatesUrl - The URL for the API we can use to obtain
 * non-EIP-1559-specific estimates.
 * @param args.fetchEthGasPriceEstimate - A function that fetches gas estimates using
 * `eth_gasPrice`.
 * @param args.calculateTimeEstimate - A function that determine time estimate bounds.
 * @param args.clientId - An identifier that an API can use to know who is asking for estimates.
 * @param args.ethQuery - An EthQuery instance we can use to talk to Ethereum directly.
 * @returns The gas fee calculations.
 */
function determineGasFeeCalculations({ isEIP1559Compatible, isLegacyGasAPICompatible, fetchGasEstimates, fetchGasEstimatesUrl, fetchGasEstimatesViaEthFeeHistory, fetchLegacyGasPriceEstimates, fetchLegacyGasPriceEstimatesUrl, fetchEthGasPriceEstimate, calculateTimeEstimate, clientId, ethQuery, }) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (isEIP1559Compatible) {
                let estimates;
                try {
                    estimates = yield fetchGasEstimates(fetchGasEstimatesUrl, clientId);
                }
                catch (_a) {
                    estimates = yield fetchGasEstimatesViaEthFeeHistory(ethQuery);
                }
                const { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = estimates.medium;
                const estimatedGasFeeTimeBounds = calculateTimeEstimate(suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas, estimates);
                return {
                    gasFeeEstimates: estimates,
                    estimatedGasFeeTimeBounds,
                    gasEstimateType: GasFeeController_1.GAS_ESTIMATE_TYPES.FEE_MARKET,
                };
            }
            else if (isLegacyGasAPICompatible) {
                const estimates = yield fetchLegacyGasPriceEstimates(fetchLegacyGasPriceEstimatesUrl, clientId);
                return {
                    gasFeeEstimates: estimates,
                    estimatedGasFeeTimeBounds: {},
                    gasEstimateType: GasFeeController_1.GAS_ESTIMATE_TYPES.LEGACY,
                };
            }
            throw new Error('Main gas fee/price estimation failed. Use fallback');
        }
        catch (_b) {
            try {
                const estimates = yield fetchEthGasPriceEstimate(ethQuery);
                return {
                    gasFeeEstimates: estimates,
                    estimatedGasFeeTimeBounds: {},
                    gasEstimateType: GasFeeController_1.GAS_ESTIMATE_TYPES.ETH_GASPRICE,
                };
            }
            catch (error) {
                if (error instanceof Error) {
                    throw new Error(`Gas fee/price estimation failed. Message: ${error.message}`);
                }
                throw error;
            }
        }
    });
}
exports.default = determineGasFeeCalculations;
//# sourceMappingURL=determineGasFeeCalculations.js.map
      };
    };
  }
  }
}, {package:"@metamask/gas-fee-controller",file:"node_modules\\@metamask\\gas-fee-controller\\dist\\determineGasFeeCalculations.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\fetchBlockFeeHistory.js", {"@metamask/controller-utils":"F:\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cgas-fee-controller%5Cdist%5CfetchBlockFeeHistory.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_util_1 = require("ethereumjs-util");
const controller_utils_1 = require("@metamask/controller-utils");
const MAX_NUMBER_OF_BLOCKS_PER_ETH_FEE_HISTORY_CALL = 1024;
/**
 * Uses `eth_feeHistory` (an EIP-1559 feature) to obtain information about gas fees from a range of
 * blocks that have occurred recently on a network.
 *
 * To learn more, see these resources:
 *
 * - <https://infura.io/docs/ethereum#operation/eth_feeHistory>
 * - <https://github.com/zsfelfoldi/feehistory/blob/main/docs/feeHistory.md>
 * - <https://github.com/ethereum/go-ethereum/blob/57a3fab8a75eeb9c2f4fab770b73b51b9fe672c5/eth/gasprice/feehistory.go#L180>
 * - <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md>
 * - <https://gas-api.metaswap.codefi.network/testFeeHistory>
 *
 * @param args - The arguments to this function.
 * @param args.ethQuery - An EthQuery instance that wraps a provider for the network in question.
 * @param args.endBlock - The desired end of the requested block range. Can be "latest" if you want
 * to start from the latest successful block or the number of a known past block.
 * @param args.numberOfBlocks - How many total blocks to fetch. Note that if this is more than 1024,
 * multiple calls to `eth_feeHistory` will be made.
 * @param args.percentiles - A set of numbers between 1 and 100 which will dictate how
 * `priorityFeesByPercentile` in each returned block will be formed. When Ethereum runs the
 * `eth_feeHistory` method, for each block it is considering, it will first sort all transactions by
 * the priority fee. It will then go through each transaction and add the total amount of gas paid
 * for that transaction to a bucket which maxes out at the total gas used for the whole block. As
 * the bucket fills, it will cross percentages which correspond to the percentiles specified here,
 * and the priority fees of the first transactions which cause it to reach those percentages will be
 * recorded. Hence, `priorityFeesByPercentile` represents the priority fees of transactions at key
 * gas used contribution levels, where earlier levels have smaller contributions and later levels
 * have higher contributions.
 * @param args.includeNextBlock - Whether to include an extra block that represents the next
 * block after the latest one. Only the `baseFeePerGas` will be filled in for this block (which is
 * estimated).
 * @returns The list of blocks and their fee data, sorted from oldest to newest.
 */
function fetchBlockFeeHistory({ ethQuery, numberOfBlocks: totalNumberOfBlocks, endBlock: givenEndBlock = 'latest', percentiles: givenPercentiles = [], includeNextBlock = false, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const percentiles = givenPercentiles.length > 0
            ? Array.from(new Set(givenPercentiles)).sort((a, b) => a - b)
            : [];
        const finalEndBlockNumber = givenEndBlock === 'latest'
            ? (0, controller_utils_1.fromHex)(yield (0, controller_utils_1.query)(ethQuery, 'blockNumber'))
            : givenEndBlock;
        const requestChunkSpecifiers = determineRequestChunkSpecifiers(finalEndBlockNumber, totalNumberOfBlocks);
        const blockChunks = yield Promise.all(requestChunkSpecifiers.map(({ numberOfBlocks, endBlockNumber }, i) => {
            return i === requestChunkSpecifiers.length - 1
                ? makeRequestForChunk({
                    ethQuery,
                    numberOfBlocks,
                    endBlockNumber,
                    percentiles,
                    includeNextBlock,
                })
                : makeRequestForChunk({
                    ethQuery,
                    numberOfBlocks,
                    endBlockNumber,
                    percentiles,
                    includeNextBlock: false,
                });
        }));
        return blockChunks.reduce((array, blocks) => [...array, ...blocks], []);
    });
}
exports.default = fetchBlockFeeHistory;
/**
 * Builds an ExistingFeeHistoryBlock.
 *
 * @param args - The args to this function.
 * @param args.number - The number of the block.
 * @param args.baseFeePerGas - The base fee per gas of the block.
 * @param args.blockIndex - The index of the block in the source chunk.
 * @param args.gasUsedRatios - The gas used ratios for the block.
 * @param args.priorityFeePercentileGroups - The priority fee percentile groups for the block.
 * @param args.percentiles - The percentiles used to fetch the source chunk.
 * @returns The ExistingFeeHistoryBlock.
 */
function buildExistingFeeHistoryBlock({ baseFeePerGas, number, blockIndex, gasUsedRatios, priorityFeePercentileGroups, percentiles, }) {
    const gasUsedRatio = gasUsedRatios[blockIndex];
    const priorityFeesForEachPercentile = priorityFeePercentileGroups[blockIndex];
    const priorityFeesByPercentile = percentiles.reduce((obj, percentile, percentileIndex) => {
        const priorityFee = priorityFeesForEachPercentile[percentileIndex];
        return Object.assign(Object.assign({}, obj), { [percentile]: (0, controller_utils_1.fromHex)(priorityFee) });
    }, {});
    return {
        number,
        baseFeePerGas,
        gasUsedRatio,
        priorityFeesByPercentile,
    };
}
/**
 * Builds a NextFeeHistoryBlock.
 *
 * @param args - The args to this function.
 * @param args.baseFeePerGas - The base fee per gas of the block.
 * @param args.number - The number of the block.
 * @returns The NextFeeHistoryBlock.
 */
function buildNextFeeHistoryBlock({ baseFeePerGas, number, }) {
    return {
        number,
        baseFeePerGas,
        gasUsedRatio: null,
        priorityFeesByPercentile: null,
    };
}
/**
 * Uses eth_feeHistory to request historical data about a group of blocks (max size 1024).
 *
 * @param args - The arguments
 * @param args.ethQuery - An EthQuery instance.
 * @param args.numberOfBlocks - The number of blocks in the chunk. Must be at most 1024, as this is
 * the maximum that `eth_feeHistory` can return in one call.
 * @param args.endBlockNumber - The end of the requested block range.
 * @param args.percentiles - A set of numbers between 1 and 100 that will be used to pull priority
 * fees for each block.
 * @param args.includeNextBlock - Whether to include an extra block that represents the next
 * block after the latest one. Only the `baseFeePerGas` will be filled in for this block (which is
 * estimated).
 * @returns A list of block data.
 */
function makeRequestForChunk({ ethQuery, numberOfBlocks, endBlockNumber, percentiles, includeNextBlock, }) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, controller_utils_1.query)(ethQuery, 'eth_feeHistory', [(0, controller_utils_1.toHex)(numberOfBlocks), (0, controller_utils_1.toHex)(endBlockNumber), percentiles]);
        const startBlockNumber = (0, controller_utils_1.fromHex)(response.oldestBlock);
        if (response.baseFeePerGas !== undefined &&
            response.baseFeePerGas.length > 0 &&
            response.gasUsedRatio.length > 0 &&
            (response.reward === undefined || response.reward.length > 0)) {
            // Per
            // <https://github.com/ethereum/go-ethereum/blob/57a3fab8a75eeb9c2f4fab770b73b51b9fe672c5/eth/gasprice/feehistory.go#L191-L192>,
            // baseFeePerGas will always include an extra item which is the calculated base fee for the
            // next (future) block. We may or may not care about this; if we don't, chop it off.
            const baseFeesPerGasAsHex = includeNextBlock
                ? response.baseFeePerGas
                : response.baseFeePerGas.slice(0, numberOfBlocks);
            const gasUsedRatios = response.gasUsedRatio;
            const priorityFeePercentileGroups = (_a = response.reward) !== null && _a !== void 0 ? _a : [];
            // Chain is allowed to return fewer number of block results
            const numberOfExistingResults = gasUsedRatios.length;
            return baseFeesPerGasAsHex.map((baseFeePerGasAsHex, blockIndex) => {
                const baseFeePerGas = (0, controller_utils_1.fromHex)(baseFeePerGasAsHex);
                const number = startBlockNumber.addn(blockIndex);
                return blockIndex >= numberOfExistingResults
                    ? buildNextFeeHistoryBlock({ baseFeePerGas, number })
                    : buildExistingFeeHistoryBlock({
                        baseFeePerGas,
                        number,
                        blockIndex,
                        gasUsedRatios,
                        priorityFeePercentileGroups,
                        percentiles,
                    });
            });
        }
        return [];
    });
}
/**
 * Divides a block range (specified by a range size and the end of the range) into chunks based on
 * the maximum number of blocks that `eth_feeHistory` can return in a single call.
 *
 * If the requested totalNumberOfBlocks exceed endBlockNumber, totalNumberOfBlocks is
 * truncated to avoid requesting chunks with negative endBlockNumber.
 *
 * @param endBlockNumber - The final block in the complete desired block range after all
 * `eth_feeHistory` requests have been made.
 * @param totalNumberOfBlocks - The total number of desired blocks after all `eth_feeHistory`
 * requests have been made.
 * @returns A set of arguments that can be used to make requests to `eth_feeHistory` in order to
 * retrieve all of the requested blocks, sorted from oldest block to newest block.
 */
function determineRequestChunkSpecifiers(endBlockNumber, totalNumberOfBlocks) {
    if (endBlockNumber.lt(new ethereumjs_util_1.BN(totalNumberOfBlocks))) {
        totalNumberOfBlocks = endBlockNumber.toNumber();
    }
    const specifiers = [];
    for (let chunkStartBlockNumber = endBlockNumber.subn(totalNumberOfBlocks); chunkStartBlockNumber.lt(endBlockNumber); chunkStartBlockNumber = chunkStartBlockNumber.addn(MAX_NUMBER_OF_BLOCKS_PER_ETH_FEE_HISTORY_CALL)) {
        const distanceToEnd = endBlockNumber.sub(chunkStartBlockNumber).toNumber();
        const numberOfBlocks = distanceToEnd < MAX_NUMBER_OF_BLOCKS_PER_ETH_FEE_HISTORY_CALL
            ? distanceToEnd
            : MAX_NUMBER_OF_BLOCKS_PER_ETH_FEE_HISTORY_CALL;
        const chunkEndBlockNumber = chunkStartBlockNumber.addn(numberOfBlocks);
        specifiers.push({ numberOfBlocks, endBlockNumber: chunkEndBlockNumber });
    }
    return specifiers;
}
//# sourceMappingURL=fetchBlockFeeHistory.js.map
      };
    };
  }
  }
}, {package:"@metamask/gas-fee-controller",file:"node_modules\\@metamask\\gas-fee-controller\\dist\\fetchBlockFeeHistory.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory.js", {"./fetchBlockFeeHistory":"F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\fetchBlockFeeHistory.js","./fetchGasEstimatesViaEthFeeHistory/calculateGasFeeEstimatesForPriorityLevels":"F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory\\calculateGasFeeEstimatesForPriorityLevels.js","./fetchGasEstimatesViaEthFeeHistory/fetchLatestBlock":"F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory\\fetchLatestBlock.js","@metamask/controller-utils":"F:\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js","ethjs-unit":"F:\\metamask-extension\\node_modules\\ethjs-unit\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cgas-fee-controller%5Cdist%5CfetchGasEstimatesViaEthFeeHistory.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethjs_unit_1 = require("ethjs-unit");
const controller_utils_1 = require("@metamask/controller-utils");
const fetchBlockFeeHistory_1 = __importDefault(require("./fetchBlockFeeHistory"));
const fetchLatestBlock_1 = __importDefault(require("./fetchGasEstimatesViaEthFeeHistory/fetchLatestBlock"));
const calculateGasFeeEstimatesForPriorityLevels_1 = __importDefault(require("./fetchGasEstimatesViaEthFeeHistory/calculateGasFeeEstimatesForPriorityLevels"));
/**
 * Generates gas fee estimates based on gas fees that have been used in the recent past so that
 * those estimates can be displayed to users.
 *
 * To produce the estimates, the last 5 blocks are read from the network, and for each block, the
 * priority fees for transactions at the 10th, 20th, and 30th percentiles are also read (here
 * "percentile" signifies the level at which those transactions contribute to the overall gas used
 * for the block, where higher percentiles correspond to higher fees). This information is used to
 * calculate reasonable max priority and max fees for three different priority levels (higher
 * priority = higher fee).
 *
 * Note that properties are returned for other data that are normally obtained via the API; however,
 * to prevent extra requests to Infura, these properties are empty.
 *
 * @param ethQuery - An EthQuery instance.
 * @returns Base and priority fee estimates, categorized by priority level, as well as an estimate
 * for the next block's base fee.
 */
function fetchGasEstimatesViaEthFeeHistory(ethQuery) {
    return __awaiter(this, void 0, void 0, function* () {
        const latestBlock = yield (0, fetchLatestBlock_1.default)(ethQuery);
        const blocks = yield (0, fetchBlockFeeHistory_1.default)({
            ethQuery,
            endBlock: latestBlock.number,
            numberOfBlocks: 5,
            percentiles: [10, 20, 30],
        });
        const estimatedBaseFee = (0, ethjs_unit_1.fromWei)(latestBlock.baseFeePerGas, controller_utils_1.GWEI);
        const levelSpecificEstimates = (0, calculateGasFeeEstimatesForPriorityLevels_1.default)(blocks);
        return Object.assign(Object.assign({}, levelSpecificEstimates), { estimatedBaseFee, historicalBaseFeeRange: null, baseFeeTrend: null, latestPriorityFeeRange: null, historicalPriorityFeeRange: null, priorityFeeTrend: null, networkCongestion: null });
    });
}
exports.default = fetchGasEstimatesViaEthFeeHistory;
//# sourceMappingURL=fetchGasEstimatesViaEthFeeHistory.js.map
      };
    };
  }
  }
}, {package:"@metamask/gas-fee-controller",file:"node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory\\calculateGasFeeEstimatesForPriorityLevels.js", {"./medianOf":"F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory\\medianOf.js","@metamask/controller-utils":"F:\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethjs-unit":"F:\\metamask-extension\\node_modules\\ethjs-unit\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cgas-fee-controller%5Cdist%5CfetchGasEstimatesViaEthFeeHistory%5CcalculateGasFeeEstimatesForPriorityLevels.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_util_1 = require("ethereumjs-util");
const ethjs_unit_1 = require("ethjs-unit");
const controller_utils_1 = require("@metamask/controller-utils");
const medianOf_1 = __importDefault(require("./medianOf"));
const PRIORITY_LEVELS = ['low', 'medium', 'high'];
const PRIORITY_LEVEL_PERCENTILES = [10, 20, 30];
const SETTINGS_BY_PRIORITY_LEVEL = {
    low: {
        percentile: 10,
        baseFeePercentageMultiplier: new ethereumjs_util_1.BN(110),
        priorityFeePercentageMultiplier: new ethereumjs_util_1.BN(94),
        minSuggestedMaxPriorityFeePerGas: new ethereumjs_util_1.BN(1000000000),
        estimatedWaitTimes: {
            minWaitTimeEstimate: 15000,
            maxWaitTimeEstimate: 30000,
        },
    },
    medium: {
        percentile: 20,
        baseFeePercentageMultiplier: new ethereumjs_util_1.BN(120),
        priorityFeePercentageMultiplier: new ethereumjs_util_1.BN(97),
        minSuggestedMaxPriorityFeePerGas: new ethereumjs_util_1.BN(1500000000),
        estimatedWaitTimes: {
            minWaitTimeEstimate: 15000,
            maxWaitTimeEstimate: 45000,
        },
    },
    high: {
        percentile: 30,
        baseFeePercentageMultiplier: new ethereumjs_util_1.BN(125),
        priorityFeePercentageMultiplier: new ethereumjs_util_1.BN(98),
        minSuggestedMaxPriorityFeePerGas: new ethereumjs_util_1.BN(2000000000),
        estimatedWaitTimes: {
            minWaitTimeEstimate: 15000,
            maxWaitTimeEstimate: 60000,
        },
    },
};
/**
 * Calculates a set of estimates assigned to a particular priority level based on the data returned
 * by `eth_feeHistory`.
 *
 * @param priorityLevel - The level of fees that dictates how soon a transaction may go through
 * ("low", "medium", or "high").
 * @param blocks - A set of blocks as obtained from {@link fetchBlockFeeHistory}.
 * @returns The estimates.
 */
function calculateEstimatesForPriorityLevel(priorityLevel, blocks) {
    const settings = SETTINGS_BY_PRIORITY_LEVEL[priorityLevel];
    const latestBaseFeePerGas = blocks[blocks.length - 1].baseFeePerGas;
    const adjustedBaseFee = latestBaseFeePerGas
        .mul(settings.baseFeePercentageMultiplier)
        .divn(100);
    const priorityFees = blocks
        .map((block) => {
        return 'priorityFeesByPercentile' in block
            ? block.priorityFeesByPercentile[settings.percentile]
            : null;
    })
        .filter(ethereumjs_util_1.BN.isBN);
    const medianPriorityFee = (0, medianOf_1.default)(priorityFees);
    const adjustedPriorityFee = medianPriorityFee
        .mul(settings.priorityFeePercentageMultiplier)
        .divn(100);
    const suggestedMaxPriorityFeePerGas = ethereumjs_util_1.BN.max(adjustedPriorityFee, settings.minSuggestedMaxPriorityFeePerGas);
    const suggestedMaxFeePerGas = adjustedBaseFee.add(suggestedMaxPriorityFeePerGas);
    return Object.assign(Object.assign({}, settings.estimatedWaitTimes), { suggestedMaxPriorityFeePerGas: (0, ethjs_unit_1.fromWei)(suggestedMaxPriorityFeePerGas, controller_utils_1.GWEI), suggestedMaxFeePerGas: (0, ethjs_unit_1.fromWei)(suggestedMaxFeePerGas, controller_utils_1.GWEI) });
}
/**
 * Calculates a set of estimates suitable for different priority levels based on the data returned
 * by `eth_feeHistory`.
 *
 * @param blocks - A set of blocks populated with data for priority fee percentiles 10, 20, and 30,
 * obtained via {@link BlockFeeHistoryDatasetFetcher}.
 * @returns The estimates.
 */
function calculateGasFeeEstimatesForPriorityLevels(blocks) {
    return PRIORITY_LEVELS.reduce((obj, priorityLevel) => {
        const gasEstimatesForPriorityLevel = calculateEstimatesForPriorityLevel(priorityLevel, blocks);
        return Object.assign(Object.assign({}, obj), { [priorityLevel]: gasEstimatesForPriorityLevel });
    }, {});
}
exports.default = calculateGasFeeEstimatesForPriorityLevels;
//# sourceMappingURL=calculateGasFeeEstimatesForPriorityLevels.js.map
      };
    };
  }
  }
}, {package:"@metamask/gas-fee-controller",file:"node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory\\calculateGasFeeEstimatesForPriorityLevels.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory\\fetchLatestBlock.js", {"@metamask/controller-utils":"F:\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cgas-fee-controller%5Cdist%5CfetchGasEstimatesViaEthFeeHistory%5CfetchLatestBlock.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const controller_utils_1 = require("@metamask/controller-utils");
/**
 * Returns information about the latest completed block.
 *
 * @param ethQuery - An EthQuery instance
 * @param includeFullTransactionData - Whether or not to include all data for transactions as
 * opposed to merely hashes. False by default.
 * @returns The block.
 */
function fetchLatestBlock(ethQuery, includeFullTransactionData = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const blockNumber = yield (0, controller_utils_1.query)(ethQuery, 'blockNumber');
        const block = yield (0, controller_utils_1.query)(ethQuery, 'getBlockByNumber', [
            blockNumber,
            includeFullTransactionData,
        ]);
        return Object.assign(Object.assign({}, block), { number: (0, controller_utils_1.fromHex)(block.number), baseFeePerGas: (0, controller_utils_1.fromHex)(block.baseFeePerGas) });
    });
}
exports.default = fetchLatestBlock;
//# sourceMappingURL=fetchLatestBlock.js.map
      };
    };
  }
  }
}, {package:"@metamask/gas-fee-controller",file:"node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory\\fetchLatestBlock.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory\\medianOf.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cgas-fee-controller%5Cdist%5CfetchGasEstimatesViaEthFeeHistory%5CmedianOf.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Finds the median among a list of numbers. Note that this is different from the implementation
 * in the MetaSwap API, as we want to hold to using BN as much as possible.
 *
 * @param numbers - A list of numbers, as BNs. Will be sorted automatically if unsorted.
 * @returns The median number.
 */
function medianOf(numbers) {
    const sortedNumbers = numbers.slice().sort((a, b) => a.cmp(b));
    const len = sortedNumbers.length;
    const index = Math.floor((len - 1) / 2);
    return sortedNumbers[index];
}
exports.default = medianOf;
//# sourceMappingURL=medianOf.js.map
      };
    };
  }
  }
}, {package:"@metamask/gas-fee-controller",file:"node_modules\\@metamask\\gas-fee-controller\\dist\\fetchGasEstimatesViaEthFeeHistory\\medianOf.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\gas-util.js", {"@metamask/controller-utils":"F:\\metamask-extension\\node_modules\\@metamask\\controller-utils\\dist\\index.js","ethereumjs-util":"F:\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cgas-fee-controller%5Cdist%5Cgas-util.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateTimeEstimate = exports.fetchEthGasPriceEstimate = exports.fetchLegacyGasPriceEstimates = exports.fetchGasEstimates = exports.normalizeGWEIDecimalNumbers = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const controller_utils_1 = require("@metamask/controller-utils");
const makeClientIdHeader = (clientId) => ({ 'X-Client-Id': clientId });
/**
 * Convert a decimal GWEI value to a decimal string rounded to the nearest WEI.
 *
 * @param n - The input GWEI amount, as a decimal string or a number.
 * @returns The decimal string GWEI amount.
 */
function normalizeGWEIDecimalNumbers(n) {
    const numberAsWEIHex = (0, controller_utils_1.gweiDecToWEIBN)(n).toString(16);
    const numberAsGWEI = (0, controller_utils_1.weiHexToGweiDec)(numberAsWEIHex).toString(10);
    return numberAsGWEI;
}
exports.normalizeGWEIDecimalNumbers = normalizeGWEIDecimalNumbers;
/**
 * Fetch gas estimates from the given URL.
 *
 * @param url - The gas estimate URL.
 * @param clientId - The client ID used to identify to the API who is asking for estimates.
 * @returns The gas estimates.
 */
function fetchGasEstimates(url, clientId) {
    return __awaiter(this, void 0, void 0, function* () {
        const estimates = yield (0, controller_utils_1.handleFetch)(url, clientId ? { headers: makeClientIdHeader(clientId) } : undefined);
        return {
            low: Object.assign(Object.assign({}, estimates.low), { suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas), suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas) }),
            medium: Object.assign(Object.assign({}, estimates.medium), { suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas), suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas) }),
            high: Object.assign(Object.assign({}, estimates.high), { suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas), suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas) }),
            estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),
            historicalBaseFeeRange: estimates.historicalBaseFeeRange,
            baseFeeTrend: estimates.baseFeeTrend,
            latestPriorityFeeRange: estimates.latestPriorityFeeRange,
            historicalPriorityFeeRange: estimates.historicalPriorityFeeRange,
            priorityFeeTrend: estimates.priorityFeeTrend,
            networkCongestion: estimates.networkCongestion,
        };
    });
}
exports.fetchGasEstimates = fetchGasEstimates;
/**
 * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium
 * high values from that API.
 *
 * @param url - The URL to fetch gas price estimates from.
 * @param clientId - The client ID used to identify to the API who is asking for estimates.
 * @returns The gas price estimates.
 */
function fetchLegacyGasPriceEstimates(url, clientId) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield (0, controller_utils_1.handleFetch)(url, {
            referrer: url,
            referrerPolicy: 'no-referrer-when-downgrade',
            method: 'GET',
            mode: 'cors',
            headers: Object.assign({ 'Content-Type': 'application/json' }, (clientId && makeClientIdHeader(clientId))),
        });
        return {
            low: result.SafeGasPrice,
            medium: result.ProposeGasPrice,
            high: result.FastGasPrice,
        };
    });
}
exports.fetchLegacyGasPriceEstimates = fetchLegacyGasPriceEstimates;
/**
 * Get a gas price estimate from the network using the `eth_gasPrice` method.
 *
 * @param ethQuery - The EthQuery instance to call the network with.
 * @returns A gas price estimate.
 */
function fetchEthGasPriceEstimate(ethQuery) {
    return __awaiter(this, void 0, void 0, function* () {
        const gasPrice = yield (0, controller_utils_1.query)(ethQuery, 'gasPrice');
        return {
            gasPrice: (0, controller_utils_1.weiHexToGweiDec)(gasPrice).toString(),
        };
    });
}
exports.fetchEthGasPriceEstimate = fetchEthGasPriceEstimate;
/**
 * Estimate the time it will take for a transaction to be confirmed.
 *
 * @param maxPriorityFeePerGas - The max priority fee per gas.
 * @param maxFeePerGas - The max fee per gas.
 * @param gasFeeEstimates - The gas fee estimates.
 * @returns The estimated lower and upper bounds for when this transaction will be confirmed.
 */
function calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, gasFeeEstimates) {
    const { low, medium, high, estimatedBaseFee } = gasFeeEstimates;
    const maxPriorityFeePerGasInWEI = (0, controller_utils_1.gweiDecToWEIBN)(maxPriorityFeePerGas);
    const maxFeePerGasInWEI = (0, controller_utils_1.gweiDecToWEIBN)(maxFeePerGas);
    const estimatedBaseFeeInWEI = (0, controller_utils_1.gweiDecToWEIBN)(estimatedBaseFee);
    const effectiveMaxPriorityFee = ethereumjs_util_1.BN.min(maxPriorityFeePerGasInWEI, maxFeePerGasInWEI.sub(estimatedBaseFeeInWEI));
    const lowMaxPriorityFeeInWEI = (0, controller_utils_1.gweiDecToWEIBN)(low.suggestedMaxPriorityFeePerGas);
    const mediumMaxPriorityFeeInWEI = (0, controller_utils_1.gweiDecToWEIBN)(medium.suggestedMaxPriorityFeePerGas);
    const highMaxPriorityFeeInWEI = (0, controller_utils_1.gweiDecToWEIBN)(high.suggestedMaxPriorityFeePerGas);
    let lowerTimeBound;
    let upperTimeBound;
    if (effectiveMaxPriorityFee.lt(lowMaxPriorityFeeInWEI)) {
        lowerTimeBound = null;
        upperTimeBound = 'unknown';
    }
    else if (effectiveMaxPriorityFee.gte(lowMaxPriorityFeeInWEI) &&
        effectiveMaxPriorityFee.lt(mediumMaxPriorityFeeInWEI)) {
        lowerTimeBound = low.minWaitTimeEstimate;
        upperTimeBound = low.maxWaitTimeEstimate;
    }
    else if (effectiveMaxPriorityFee.gte(mediumMaxPriorityFeeInWEI) &&
        effectiveMaxPriorityFee.lt(highMaxPriorityFeeInWEI)) {
        lowerTimeBound = medium.minWaitTimeEstimate;
        upperTimeBound = medium.maxWaitTimeEstimate;
    }
    else if (effectiveMaxPriorityFee.eq(highMaxPriorityFeeInWEI)) {
        lowerTimeBound = high.minWaitTimeEstimate;
        upperTimeBound = high.maxWaitTimeEstimate;
    }
    else {
        lowerTimeBound = 0;
        upperTimeBound = high.maxWaitTimeEstimate;
    }
    return {
        lowerTimeBound,
        upperTimeBound,
    };
}
exports.calculateTimeEstimate = calculateTimeEstimate;
//# sourceMappingURL=gas-util.js.map
      };
    };
  }
  }
}, {package:"@metamask/gas-fee-controller",file:"node_modules\\@metamask\\gas-fee-controller\\dist\\gas-util.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\index.js", {"./GasFeeController":"F:\\metamask-extension\\node_modules\\@metamask\\gas-fee-controller\\dist\\GasFeeController.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Cgas-fee-controller%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./GasFeeController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/gas-fee-controller",file:"node_modules\\@metamask\\gas-fee-controller\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\BIP44CoinTypeNode.js", {"./BIP44Node":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\BIP44Node.js","./SLIP10Node":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\SLIP10Node.js","./constants":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js","./utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5CBIP44CoinTypeNode.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BIP44CoinTypeNode_node;
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBIP44AddressKeyDeriver = exports.deriveBIP44AddressKey = exports.BIP44CoinTypeNode = exports.BIP_44_COIN_TYPE_DEPTH = void 0;
const BIP44Node_1 = require("./BIP44Node");
const constants_1 = require("./constants");
const SLIP10Node_1 = require("./SLIP10Node");
const utils_1 = require("./utils");
exports.BIP_44_COIN_TYPE_DEPTH = 2;
/**
 * A wrapper object for BIP-44 `coin_type` keys. `coin_type` is the index
 * specifying the protocol for which deeper keys are intended. For the
 * authoritative list of coin types, please see
 * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 */
class BIP44CoinTypeNode {
    // Constructors cannot use hash names.
    // eslint-disable-next-line no-restricted-syntax
    constructor(node, coin_type) {
        _BIP44CoinTypeNode_node.set(this, void 0);
        __classPrivateFieldSet(this, _BIP44CoinTypeNode_node, node, "f");
        this.coin_type = coin_type;
        this.path = (0, utils_1.getBIP44CoinTypePathString)(coin_type);
        Object.freeze(this);
    }
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param json - The {@link JsonBIP44Node} for the key of this node.
     * @param coin_type - The coin_type index of this node. Must be a non-negative
     * integer.
     */
    static async fromJSON(json, coin_type) {
        validateCoinType(coin_type);
        validateCoinTypeNodeDepth(json.depth);
        const node = await BIP44Node_1.BIP44Node.fromExtendedKey({
            depth: json.depth,
            index: json.index,
            parentFingerprint: json.parentFingerprint,
            chainCode: (0, utils_1.hexStringToBytes)(json.chainCode),
            privateKey: (0, utils_1.nullableHexStringToBytes)(json.privateKey),
            publicKey: (0, utils_1.hexStringToBytes)(json.publicKey),
        });
        return new BIP44CoinTypeNode(node, coin_type);
    }
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param derivationPath - The derivation path for the key of this node.
     */
    static async fromDerivationPath(derivationPath) {
        validateCoinTypeNodeDepth(derivationPath.length - 1);
        const node = await BIP44Node_1.BIP44Node.fromDerivationPath({
            derivationPath,
        });
        // Split the bip32 string token and extract the coin_type index
        const coinType = Number.parseInt(derivationPath[exports.BIP_44_COIN_TYPE_DEPTH].split(':')[1].replace(`'`, ''), 10);
        return new BIP44CoinTypeNode(node, coinType);
    }
    /**
     * Constructs a BIP-44 `coin_type` node. `coin_type` is the index
     * specifying the protocol for which deeper keys are intended. For the
     * authoritative list of coin types, please see
     * [SLIP-44](https://github.com/satoshilabs/slips/blob/master/slip-0044.md).
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param node - The {@link BIP44Node} for the key of this node.
     * @param coin_type - The coin_type index of this node. Must be a non-negative
     * integer.
     */
    static async fromNode(node, coin_type) {
        if (!(node instanceof BIP44Node_1.BIP44Node)) {
            throw new Error('Invalid node: Expected an instance of BIP44Node.');
        }
        validateCoinType(coin_type);
        validateCoinTypeNodeDepth(node.depth);
        // TODO: Make this function not async in a future version.
        return Promise.resolve(new BIP44CoinTypeNode(node, coin_type));
    }
    get depth() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").depth;
    }
    get privateKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").privateKeyBytes;
    }
    get publicKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").publicKeyBytes;
    }
    get chainCodeBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").chainCodeBytes;
    }
    get privateKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").privateKey;
    }
    get publicKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").publicKey;
    }
    get compressedPublicKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").compressedPublicKey;
    }
    get compressedPublicKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").compressedPublicKeyBytes;
    }
    get chainCode() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").chainCode;
    }
    get address() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").address;
    }
    get masterFingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").masterFingerprint;
    }
    get parentFingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").parentFingerprint;
    }
    get fingerprint() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").fingerprint;
    }
    get index() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").index;
    }
    get curve() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").curve;
    }
    get extendedKey() {
        return __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").extendedKey;
    }
    /**
     * Derives a BIP-44 `address_index` key corresponding to the path of this
     * node and the specified `account`, `change`, and `address_index` values.
     * `address_index` keys are normally the keys used to generate user account
     * addresses.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param indices - The BIP-44 index values to use in key derivation.
     * @param indices.account - The `account` index. Default: `0`
     * @param indices.change - The `change` index. Default: `0`
     * @param indices.address_index - The `address_index` index.
     * @returns The derived BIP-44 `address_index` node.
     */
    async deriveBIP44AddressKey({ account = 0, change = 0, address_index, }) {
        return await __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").derive((0, utils_1.getBIP44CoinTypeToAddressPathTuple)({ account, change, address_index }));
    }
    toJSON() {
        return Object.assign(Object.assign({}, __classPrivateFieldGet(this, _BIP44CoinTypeNode_node, "f").toJSON()), { coin_type: this.coin_type, path: this.path });
    }
}
exports.BIP44CoinTypeNode = BIP44CoinTypeNode;
_BIP44CoinTypeNode_node = new WeakMap();
/**
 * Validates the depth of a `coin_type` node. Simply, ensures that it is the
 * number `2`. An error is thrown if validation fails.
 *
 * @param depth - The depth to validate.
 */
function validateCoinTypeNodeDepth(depth) {
    if (depth !== exports.BIP_44_COIN_TYPE_DEPTH) {
        throw new Error(`Invalid depth: Coin type nodes must be of depth ${exports.BIP_44_COIN_TYPE_DEPTH}. Received: "${depth}"`);
    }
}
/**
 * Validates that the coin type is a non-negative integer number. An error is
 * thrown if validation fails.
 *
 * @param coin_type - The coin type to validate.
 */
function validateCoinType(coin_type) {
    if (typeof coin_type !== 'number' ||
        !Number.isInteger(coin_type) ||
        coin_type < 0) {
        throw new Error('Invalid coin type: The specified coin type must be a non-negative integer number.');
    }
}
/**
 * Derives a BIP-44 address key corresponding to the specified derivation path,
 * given either by a {@link BIP44CoinTypeNode} or derivation path tuple.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param parentKeyOrNode - The `coin_type` parent key to derive from.
 * @param indices - The BIP-44 index values to use in key derivation.
 * @param indices.account - The `account` index. Default: `0`.
 * @param indices.change - The `change` index. Default: `0`.
 * @param indices.address_index - The `address_index` index.
 * @returns The derived `address_index` key for the specified derivation path.
 */
async function deriveBIP44AddressKey(parentKeyOrNode, { account = 0, change = 0, address_index }) {
    const path = (0, utils_1.getBIP44CoinTypeToAddressPathTuple)({
        account,
        change,
        address_index,
    });
    const node = await getNode(parentKeyOrNode);
    const childNode = await (0, SLIP10Node_1.deriveChildNode)({
        path,
        node,
    });
    return new BIP44Node_1.BIP44Node(childNode);
}
exports.deriveBIP44AddressKey = deriveBIP44AddressKey;
/**
 * Creates a function that derives BIP-44 address keys corresponding to the
 * specified derivation path, given either by a {@link BIP44CoinTypeNode} or
 * derivation path tuple.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param node - The {@link BIP44CoinTypeNode} to derive address keys from.
 * This node contains a BIP-44 key of depth 2, `coin_type`.
 * @param accountAndChangeIndices - The `account` and `change` indices that
 * will be used to derive addresses.
 * @returns The deriver function for the derivation path specified by the
 * `coin_type` node, `account`, and `change` indices.
 */
async function getBIP44AddressKeyDeriver(node, accountAndChangeIndices) {
    const { account = 0, change = 0 } = accountAndChangeIndices !== null && accountAndChangeIndices !== void 0 ? accountAndChangeIndices : {};
    const actualNode = await getNode(node);
    const accountNode = (0, utils_1.getHardenedBIP32NodeToken)(account);
    const changeNode = (0, utils_1.getBIP32NodeToken)(change);
    const bip44AddressKeyDeriver = async (address_index, isHardened = false) => {
        const slip10Node = await (0, SLIP10Node_1.deriveChildNode)({
            path: [
                accountNode,
                changeNode,
                isHardened
                    ? (0, utils_1.getHardenedBIP32NodeToken)(address_index)
                    : (0, utils_1.getUnhardenedBIP32NodeToken)(address_index),
            ],
            node: actualNode,
        });
        return new BIP44Node_1.BIP44Node(slip10Node);
    };
    bip44AddressKeyDeriver.coin_type = actualNode.coin_type;
    bip44AddressKeyDeriver.path = (0, utils_1.getBIP44ChangePathString)(actualNode.path, {
        account,
        change,
    });
    Object.freeze(bip44AddressKeyDeriver);
    return bip44AddressKeyDeriver;
}
exports.getBIP44AddressKeyDeriver = getBIP44AddressKeyDeriver;
/**
 * Get a BIP-44 coin type node from a JSON node or extended key string. If an existing coin type
 * node is provided, the same node is returned.
 *
 * The depth of the node is validated to be a valid coin type node.
 *
 * @param node - A BIP-44 coin type node, JSON node or extended key.
 */
async function getNode(node) {
    if (node instanceof BIP44CoinTypeNode) {
        validateCoinTypeNodeDepth(node.depth);
        return node;
    }
    if (typeof node === 'string') {
        const bip44Node = await BIP44Node_1.BIP44Node.fromExtendedKey(node);
        const coinTypeNode = await BIP44CoinTypeNode.fromNode(bip44Node, bip44Node.index - constants_1.BIP_32_HARDENED_OFFSET);
        validateCoinTypeNodeDepth(coinTypeNode.depth);
        return coinTypeNode;
    }
    return BIP44CoinTypeNode.fromJSON(node, node.coin_type);
}
//# sourceMappingURL=BIP44CoinTypeNode.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\BIP44CoinTypeNode.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\BIP44Node.js", {"./SLIP10Node":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\SLIP10Node.js","./constants":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js","./extended-keys":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\extended-keys.js","./utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5CBIP44Node.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BIP44Node_node;
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBIP44Depth = exports.BIP44Node = void 0;
const utils_1 = require("@metamask/utils");
const constants_1 = require("./constants");
const extended_keys_1 = require("./extended-keys");
const SLIP10Node_1 = require("./SLIP10Node");
const utils_2 = require("./utils");
/**
 * A wrapper for BIP-44 Hierarchical Deterministic (HD) tree nodes, i.e.
 * cryptographic keys used to generate keypairs and addresses for cryptocurrency
 * protocols.
 *
 * This class contains methods and fields that may not serialize well. Use
 * {@link BIP44Node.toJSON} to get a JSON-compatible representation.
 */
class BIP44Node {
    constructor(node) {
        _BIP44Node_node.set(this, void 0);
        __classPrivateFieldSet(this, _BIP44Node_node, node, "f");
        Object.freeze(this);
    }
    /**
     * Wrapper of the {@link fromExtendedKey} function. Refer to that function
     * for documentation.
     *
     * @param json - The JSON representation of a SLIP-10 node.
     */
    static async fromJSON(json) {
        return BIP44Node.fromExtendedKey(json);
    }
    /**
     * Create a new BIP-44 node from a key and chain code. You must specify
     * either a private key or a public key. When specifying a private key,
     * the public key will be derived from the private key.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * @param options - An object containing the extended key, or an extended
     * public (xpub) or private (xprv) key.
     * @param options.depth - The depth of the node.
     * @param options.privateKey - The private key for the node.
     * @param options.publicKey - The public key for the node. If a private key is
     * specified, this parameter is ignored.
     * @param options.chainCode - The chain code for the node.
     */
    static async fromExtendedKey(options) {
        if (typeof options === 'string') {
            const extendedKey = (0, extended_keys_1.decodeExtendedKey)(options);
            const { chainCode, depth, parentFingerprint, index } = extendedKey;
            if (extendedKey.version === extended_keys_1.PRIVATE_KEY_VERSION) {
                const { privateKey } = extendedKey;
                return BIP44Node.fromExtendedKey({
                    depth,
                    parentFingerprint,
                    index,
                    privateKey,
                    chainCode,
                });
            }
            const { publicKey } = extendedKey;
            return BIP44Node.fromExtendedKey({
                depth,
                parentFingerprint,
                index,
                publicKey,
                chainCode,
            });
        }
        const { privateKey, publicKey, chainCode, depth, parentFingerprint, index, } = options;
        validateBIP44Depth(depth);
        const node = await SLIP10Node_1.SLIP10Node.fromExtendedKey({
            privateKey,
            publicKey,
            chainCode,
            depth,
            parentFingerprint,
            index,
            curve: 'secp256k1',
        });
        return new BIP44Node(node);
    }
    /**
     * Create a new BIP-44 node from a derivation path. The derivation path
     * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of
     * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of
     * BIP-39 seed phrase words.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param options - An object containing the derivation path.
     * @param options.derivationPath - The rooted HD tree path that will be used
     * to derive the key of this node.
     */
    static async fromDerivationPath({ derivationPath, }) {
        validateBIP44Depth(derivationPath.length - 1);
        validateBIP44DerivationPath(derivationPath, constants_1.MIN_BIP_44_DEPTH);
        const node = await SLIP10Node_1.SLIP10Node.fromDerivationPath({
            derivationPath,
            curve: 'secp256k1',
        });
        return new BIP44Node(node);
    }
    get depth() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").depth;
    }
    get privateKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").privateKeyBytes;
    }
    get publicKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").publicKeyBytes;
    }
    get chainCodeBytes() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").chainCodeBytes;
    }
    get privateKey() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").privateKey;
    }
    get publicKey() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").publicKey;
    }
    get compressedPublicKey() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").compressedPublicKey;
    }
    get compressedPublicKeyBytes() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").compressedPublicKeyBytes;
    }
    get chainCode() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").chainCode;
    }
    get address() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").address;
    }
    get masterFingerprint() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").masterFingerprint;
    }
    get parentFingerprint() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").parentFingerprint;
    }
    get fingerprint() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").fingerprint;
    }
    get index() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").index;
    }
    get extendedKey() {
        const data = {
            depth: this.depth,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            chainCode: this.chainCodeBytes,
        };
        if (this.privateKeyBytes) {
            return (0, extended_keys_1.encodeExtendedKey)(Object.assign(Object.assign({}, data), { version: extended_keys_1.PRIVATE_KEY_VERSION, privateKey: this.privateKeyBytes }));
        }
        return (0, extended_keys_1.encodeExtendedKey)(Object.assign(Object.assign({}, data), { version: extended_keys_1.PUBLIC_KEY_VERSION, publicKey: this.publicKeyBytes }));
    }
    get curve() {
        return __classPrivateFieldGet(this, _BIP44Node_node, "f").curve;
    }
    /**
     * Get a neutered version of this node, i.e. a node without a private key.
     *
     * @returns A neutered version of this node.
     */
    neuter() {
        const node = __classPrivateFieldGet(this, _BIP44Node_node, "f").neuter();
        return new BIP44Node(node);
    }
    /**
     * Derives a child of the key contains be this node and returns a new
     * {@link BIP44Node} containing the child key.
     *
     * The specified path must be a valid HD path from this node, per BIP-44.
     * At present, this means that the path must consist of no more than 5 BIP-32
     * nodes, depending on the depth of this node.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param path - The partial (non-rooted) BIP-44 HD tree path will be used
     * to derive a child key from the parent key contained within this node.
     * @returns The {@link BIP44Node} corresponding to the derived child key.
     */
    async derive(path) {
        if (this.depth === constants_1.MAX_BIP_44_DEPTH) {
            throw new Error('Illegal operation: This HD tree node is already a leaf node.');
        }
        const newDepth = this.depth + path.length;
        validateBIP44Depth(newDepth);
        validateBIP44DerivationPath(path, (this.depth + 1));
        const node = await __classPrivateFieldGet(this, _BIP44Node_node, "f").derive(path);
        return new BIP44Node(node);
    }
    // This is documented in the interface of this class.
    toJSON() {
        return {
            depth: this.depth,
            masterFingerprint: this.masterFingerprint,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            privateKey: this.privateKey,
            publicKey: this.publicKey,
            chainCode: this.chainCode,
        };
    }
}
exports.BIP44Node = BIP44Node;
_BIP44Node_node = new WeakMap();
/**
 * Validates a BIP-44 path depth. Effectively, asserts that the depth is an
 * integer `number` N such that 0 <= N <= 5. Throws an error if validation
 * fails.
 *
 * @param depth - The depth to validate.
 */
function validateBIP44Depth(depth) {
    (0, SLIP10Node_1.validateBIP32Depth)(depth);
    if (depth < constants_1.MIN_BIP_44_DEPTH || depth > constants_1.MAX_BIP_44_DEPTH) {
        throw new Error(`Invalid HD tree path depth: The depth must be a positive integer N such that 0 <= N <= 5. Received: "${depth}"`);
    }
}
exports.validateBIP44Depth = validateBIP44Depth;
/**
 * Ensures that the given derivation is valid by BIP-44.
 *
 * Recall that a BIP-44 HD tree path consists of the following nodes:
 *
 * `m / 44' / coin_type' / account' / change / address_index`
 *
 * With the following depths:
 *
 * `0 / 1 / 2 / 3 / 4 / 5`
 *
 * @param path - The path to validate.
 * @param startingDepth - The depth of the first node of the derivation path.
 */
function validateBIP44DerivationPath(path, startingDepth) {
    path.forEach((nodeToken, index) => {
        const currentDepth = startingDepth + index;
        if (currentDepth === constants_1.MIN_BIP_44_DEPTH) {
            if (!(nodeToken instanceof Uint8Array) &&
                !constants_1.BIP_39_PATH_REGEX.test(nodeToken)) {
                throw new Error('Invalid derivation path: The "m" / seed node (depth 0) must be a BIP-39 node.');
            }
            return;
        }
        (0, utils_1.assert)(typeof nodeToken === 'string');
        // eslint-disable-next-line default-case
        switch (currentDepth) {
            case 1:
                if (nodeToken !== constants_1.BIP44PurposeNodeToken) {
                    throw new Error(`Invalid derivation path: The "purpose" node (depth 1) must be the string "${constants_1.BIP44PurposeNodeToken}".`);
                }
                break;
            case 2:
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken) || !(0, utils_2.isHardened)(nodeToken)) {
                    throw new Error('Invalid derivation path: The "coin_type" node (depth 2) must be a hardened BIP-32 node.');
                }
                break;
            case 3:
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken) || !(0, utils_2.isHardened)(nodeToken)) {
                    throw new Error('Invalid derivation path: The "account" node (depth 3) must be a hardened BIP-32 node.');
                }
                break;
            case 4:
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken)) {
                    throw new Error('Invalid derivation path: The "change" node (depth 4) must be a BIP-32 node.');
                }
                break;
            case constants_1.MAX_BIP_44_DEPTH: // 5
                if (!constants_1.BIP_32_PATH_REGEX.test(nodeToken)) {
                    throw new Error('Invalid derivation path: The "address_index" node (depth 5) must be a BIP-32 node.');
                }
                break;
        }
    });
}
//# sourceMappingURL=BIP44Node.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\BIP44Node.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\SLIP10Node.js", {"./constants":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js","./curves":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\index.js","./derivation":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivation.js","./derivers/bip32":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\bip32.js","./utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5CSLIP10Node.js
      return function (require, module, exports) {
"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _a, _SLIP10Node_constructorGuard;
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildNode = exports.validateRootIndex = exports.validateMasterParentFingerprint = exports.validateParentFingerprint = exports.validateBIP32Depth = exports.SLIP10Node = void 0;
const utils_1 = require("@metamask/utils");
const constants_1 = require("./constants");
const curves_1 = require("./curves");
const derivation_1 = require("./derivation");
const bip32_1 = require("./derivers/bip32");
const utils_2 = require("./utils");
class SLIP10Node {
    // eslint-disable-next-line no-restricted-syntax
    constructor({ depth, masterFingerprint, parentFingerprint, index, chainCode, privateKey, publicKey, curve, }, constructorGuard) {
        (0, utils_1.assert)(constructorGuard === __classPrivateFieldGet(SLIP10Node, _a, "f", _SLIP10Node_constructorGuard), 'SLIP10Node can only be constructed using `SLIP10Node.fromJSON`, `SLIP10Node.fromExtendedKey`, or `SLIP10Node.fromDerivationPath`.');
        this.depth = depth;
        this.masterFingerprint = masterFingerprint;
        this.parentFingerprint = parentFingerprint;
        this.index = index;
        this.chainCodeBytes = chainCode;
        this.privateKeyBytes = privateKey;
        this.publicKeyBytes = publicKey;
        this.curve = curve;
        Object.freeze(this);
    }
    /**
     * Wrapper of the {@link fromExtendedKey} function. Refer to that function
     * for documentation.
     *
     * @param json - The JSON representation of a SLIP-10 node.
     */
    static async fromJSON(json) {
        return SLIP10Node.fromExtendedKey(json);
    }
    /**
     * Create a new SLIP-10 node from a key and chain code. You must specify
     * either a private key or a public key. When specifying a private key,
     * the public key will be derived from the private key.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * @param options - The options for the new node.
     * @param options.depth - The depth of the node.
     * @param options.masterFingerprint - The fingerprint of the master node, i.e., the
     * node at depth 0. May be undefined if this node was created from an extended
     * key.
     * @param options.parentFingerprint - The fingerprint of the parent key, or 0 if
     * the node is a master node.
     * @param options.index - The index of the node, or 0 if the node is a master node.
     * @param options.privateKey - The private key for the node.
     * @param options.publicKey - The public key for the node. If a private key is
     * specified, this parameter is ignored.
     * @param options.chainCode - The chain code for the node.
     * @param options.curve - The curve used by the node.
     */
    static async fromExtendedKey({ depth, masterFingerprint, parentFingerprint, index, privateKey, publicKey, chainCode, curve, }) {
        const chainCodeBytes = (0, utils_2.getBytes)(chainCode, constants_1.BYTES_KEY_LENGTH);
        (0, utils_2.validateCurve)(curve);
        validateBIP32Depth(depth);
        (0, utils_2.validateBIP32Index)(index);
        validateRootIndex(index, depth);
        validateParentFingerprint(parentFingerprint, depth);
        validateMasterParentFingerprint(masterFingerprint, parentFingerprint, depth);
        const curveObject = (0, curves_1.getCurveByName)(curve);
        if (privateKey) {
            const privateKeyBytes = (0, utils_2.getBytesUnsafe)(privateKey, constants_1.BYTES_KEY_LENGTH);
            (0, utils_1.assert)(curveObject.isValidPrivateKey(privateKeyBytes), `Invalid private key: Value is not a valid ${curve} private key.`);
            return new SLIP10Node({
                depth,
                masterFingerprint,
                parentFingerprint,
                index,
                chainCode: chainCodeBytes,
                privateKey: privateKeyBytes,
                publicKey: await curveObject.getPublicKey(privateKeyBytes),
                curve,
            }, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
        }
        if (publicKey) {
            const publicKeyBytes = (0, utils_2.getBytes)(publicKey, curveObject.publicKeyLength);
            return new SLIP10Node({
                depth,
                masterFingerprint,
                parentFingerprint,
                index,
                chainCode: chainCodeBytes,
                publicKey: publicKeyBytes,
                curve,
            }, __classPrivateFieldGet(this, _a, "f", _SLIP10Node_constructorGuard));
        }
        throw new Error('Invalid options: Must provide either a private key or a public key.');
    }
    /**
     * Create a new SLIP-10 node from a derivation path. The derivation path
     * must be rooted, i.e. it must begin with a BIP-39 node, given as a string of
     * the form `bip39:MNEMONIC`, where `MNEMONIC` is a space-separated list of
     * BIP-39 seed phrase words.
     *
     * All parameters are stringently validated, and an error is thrown if
     * validation fails.
     *
     * Recall that a BIP-44 HD tree path consists of the following nodes:
     *
     * `m / 44' / coin_type' / account' / change / address_index`
     *
     * With the following depths:
     *
     * `0 / 1 / 2 / 3 / 4 / 5`
     *
     * @param options - The options for the new node.
     * @param options.derivationPath - The rooted HD tree path that will be used
     * to derive the key of this node.
     * @param options.curve - The curve used by the node.
     * @returns A new SLIP-10 node.
     */
    static async fromDerivationPath({ derivationPath, curve, }) {
        (0, utils_2.validateCurve)(curve);
        if (!derivationPath) {
            throw new Error('Invalid options: Must provide a derivation path.');
        }
        if (derivationPath.length === 0) {
            throw new Error('Invalid derivation path: May not specify an empty derivation path.');
        }
        return await (0, derivation_1.deriveKeyFromPath)({
            path: derivationPath,
            depth: derivationPath.length - 1,
            curve,
        });
    }
    get chainCode() {
        return (0, utils_1.bytesToHex)(this.chainCodeBytes);
    }
    get privateKey() {
        if (this.privateKeyBytes) {
            return (0, utils_1.bytesToHex)(this.privateKeyBytes);
        }
        return undefined;
    }
    get publicKey() {
        return (0, utils_1.bytesToHex)(this.publicKeyBytes);
    }
    get compressedPublicKeyBytes() {
        return (0, curves_1.getCurveByName)(this.curve).compressPublicKey(this.publicKeyBytes);
    }
    get compressedPublicKey() {
        return (0, utils_1.bytesToHex)(this.compressedPublicKeyBytes);
    }
    get address() {
        if (this.curve !== 'secp256k1') {
            throw new Error('Unable to get address for this node: Only secp256k1 is supported.');
        }
        return (0, utils_1.bytesToHex)((0, bip32_1.publicKeyToEthAddress)(this.publicKeyBytes));
    }
    get fingerprint() {
        return (0, utils_2.getFingerprint)(this.compressedPublicKeyBytes);
    }
    /**
     * Get a neutered version of this node, i.e. a node without a private key.
     *
     * @returns A neutered version of this node.
     */
    neuter() {
        return new SLIP10Node({
            depth: this.depth,
            masterFingerprint: this.masterFingerprint,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            chainCode: this.chainCodeBytes,
            publicKey: this.publicKeyBytes,
            curve: this.curve,
        }, __classPrivateFieldGet(SLIP10Node, _a, "f", _SLIP10Node_constructorGuard));
    }
    /**
     * Derives a child of the key contains be this node and returns a new
     * {@link SLIP10Node} containing the child key.
     *
     * The specified path must be a valid HD path from this node, per SLIP-10.
     *
     * @param path - The partial (non-rooted) SLIP-10 HD tree path will be used
     * to derive a child key from the parent key contained within this node.
     * @returns The {@link SLIP10Node} corresponding to the derived child key.
     */
    async derive(path) {
        return await deriveChildNode({
            path,
            node: this,
        });
    }
    // This is documented in the interface of this class.
    toJSON() {
        return {
            depth: this.depth,
            masterFingerprint: this.masterFingerprint,
            parentFingerprint: this.parentFingerprint,
            index: this.index,
            curve: this.curve,
            privateKey: this.privateKey,
            publicKey: this.publicKey,
            chainCode: this.chainCode,
        };
    }
}
exports.SLIP10Node = SLIP10Node;
_a = SLIP10Node;
_SLIP10Node_constructorGuard = { value: Symbol('SLIP10Node.constructor') };
/**
 * Validates a BIP-32 path depth. Effectively, asserts that the depth is an
 * integer `number`. Throws an error if validation fails.
 *
 * @param depth - The depth to validate.
 */
function validateBIP32Depth(depth) {
    if (!(0, utils_2.isValidInteger)(depth)) {
        throw new Error(`Invalid HD tree path depth: The depth must be a positive integer. Received: "${String(depth)}".`);
    }
}
exports.validateBIP32Depth = validateBIP32Depth;
/**
 * Validates a BIP-32 parent fingerprint. Effectively, asserts that the fingerprint is an
 * integer `number`. Throws an error if validation fails.
 *
 * @param parentFingerprint - The parent fingerprint to validate.
 * @param depth - The depth of the node to validate.
 * @throws If the parent fingerprint is not a positive integer, or invalid for
 * the current depth.
 */
function validateParentFingerprint(parentFingerprint, depth) {
    if (!(0, utils_2.isValidInteger)(parentFingerprint)) {
        throw new Error(`Invalid parent fingerprint: The fingerprint must be a positive integer. Received: "${String(parentFingerprint)}".`);
    }
    if (depth === 0 && parentFingerprint !== 0) {
        throw new Error(`Invalid parent fingerprint: The fingerprint of the root node must be 0. Received: "${String(parentFingerprint)}".`);
    }
    if (depth > 0 && parentFingerprint === 0) {
        throw new Error(`Invalid parent fingerprint: The fingerprint of a child node must not be 0. Received: "${String(parentFingerprint)}".`);
    }
}
exports.validateParentFingerprint = validateParentFingerprint;
/**
 * Validate that a given combination of master fingerprint and parent
 * fingerprint is valid for the given depth.
 *
 * @param masterFingerprint - The master fingerprint to validate.
 * @param parentFingerprint - The parent fingerprint to validate.
 * @param depth - The depth of the node to validate.
 * @throws If the combination of master fingerprint and parent fingerprint is
 * invalid for the given depth.
 */
function validateMasterParentFingerprint(masterFingerprint, parentFingerprint, depth) {
    // The master fingerprint is optional.
    if (!masterFingerprint) {
        return;
    }
    if (depth >= 2 && masterFingerprint === parentFingerprint) {
        throw new Error(`Invalid parent fingerprint: The fingerprint of a child node cannot be equal to the master fingerprint. Received: "${String(parentFingerprint)}".`);
    }
}
exports.validateMasterParentFingerprint = validateMasterParentFingerprint;
/**
 * Validate that the index is zero for the root node.
 *
 * @param index - The index to validate.
 * @param depth - The depth of the node to validate.
 * @throws If the index is not zero for the root node.
 */
function validateRootIndex(index, depth) {
    if (depth === 0 && index !== 0) {
        throw new Error(`Invalid index: The index of the root node must be 0. Received: "${String(index)}".`);
    }
}
exports.validateRootIndex = validateRootIndex;
/**
 * Derives a child key from the given parent key.
 *
 * @param options - The options to use when deriving the child key.
 * @param options.node - The node to derive from.
 * @param options.path - The path to the child node / key.
 * @returns The derived key and depth.
 */
async function deriveChildNode({ path, node, }) {
    if (path.length === 0) {
        throw new Error('Invalid HD tree derivation path: Deriving a path of length 0 is not defined.');
    }
    // Note that we do not subtract 1 from the length of the path to the child,
    // unlike when we calculate the depth of a rooted path.
    const newDepth = node.depth + path.length;
    validateBIP32Depth(newDepth);
    return await (0, derivation_1.deriveKeyFromPath)({
        path,
        node,
        depth: newDepth,
    });
}
exports.deriveChildNode = deriveChildNode;
//# sourceMappingURL=SLIP10Node.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\SLIP10Node.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js", {}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Cconstants.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BIP_32_HARDENED_OFFSET = exports.BIP_39_PATH_REGEX = exports.SLIP_10_PATH_REGEX = exports.BIP_32_PATH_REGEX = exports.UNPREFIXED_BIP_32_PATH_REGEX = exports.UNPREFIXED_PATH_REGEX = exports.BIP44PurposeNodeToken = exports.MAX_BIP_32_INDEX = exports.MAX_UNHARDENED_BIP_32_INDEX = exports.MAX_BIP_44_DEPTH = exports.MIN_BIP_44_DEPTH = exports.BYTES_KEY_LENGTH = void 0;
exports.BYTES_KEY_LENGTH = 32;
exports.MIN_BIP_44_DEPTH = 0;
exports.MAX_BIP_44_DEPTH = 5;
exports.MAX_UNHARDENED_BIP_32_INDEX = 0x7fffffff; // 2^31 - 1
exports.MAX_BIP_32_INDEX = 0xffffffff; // 2^32 - 1
exports.BIP44PurposeNodeToken = `bip32:44'`;
exports.UNPREFIXED_PATH_REGEX = /^\d+$/u;
/**
 * e.g.
 * -  0
 * -  0'
 */
exports.UNPREFIXED_BIP_32_PATH_REGEX = /^(?<index>\d+)'?$/u;
/**
 * e.g.
 * -  bip32:0
 * -  bip32:0'
 */
exports.BIP_32_PATH_REGEX = /^bip32:\d+'?$/u;
/**
 * e.g.
 * -  slip10:0
 * -  slip10:0'
 */
exports.SLIP_10_PATH_REGEX = /^slip10:\d+'?$/u;
/**
 * bip39:<SPACE_DELMITED_SEED_PHRASE>
 *
 * The seed phrase must consist of 12 <= 24 words.
 */
exports.BIP_39_PATH_REGEX = /^bip39:([a-z]+){1}( [a-z]+){11,23}$/u;
exports.BIP_32_HARDENED_OFFSET = 0x80000000;
//# sourceMappingURL=constants.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\constants.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\curve.js", {"./ed25519":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\ed25519.js","./secp256k1":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\secp256k1.js","@noble/secp256k1":"F:\\metamask-extension\\node_modules\\@noble\\secp256k1\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Ccurves%5Ccurve.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mod = exports.getCurveByName = exports.curves = void 0;
const secp256k1_1 = require("@noble/secp256k1");
const ed25519 = __importStar(require("./ed25519"));
const secp256k1 = __importStar(require("./secp256k1"));
exports.curves = {
    secp256k1,
    ed25519,
};
/**
 * Get a curve by name.
 *
 * @param curveName - The name of the curve to get.
 * @returns The curve.
 */
function getCurveByName(curveName) {
    return exports.curves[curveName];
}
exports.getCurveByName = getCurveByName;
// As long as both parameters are specified, this function is the same for all curves.
exports.mod = secp256k1_1.utils.mod;
//# sourceMappingURL=curve.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\curves\\curve.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\ed25519.js", {"@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js","@noble/ed25519":"F:\\metamask-extension\\node_modules\\@noble\\ed25519\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Ccurves%5Ced25519.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decompressPublicKey = exports.compressPublicKey = exports.publicAdd = exports.getPublicKey = exports.publicKeyLength = exports.deriveUnhardenedKeys = exports.isValidPrivateKey = exports.secret = exports.name = exports.curve = void 0;
const utils_1 = require("@metamask/utils");
const ed25519_1 = require("@noble/ed25519");
var ed25519_2 = require("@noble/ed25519");
Object.defineProperty(exports, "curve", { enumerable: true, get: function () { return ed25519_2.CURVE; } });
exports.name = 'ed25519';
// Secret is defined in SLIP-10:
// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation
exports.secret = (0, utils_1.stringToBytes)('ed25519 seed');
// All private keys are valid for ed25519:
// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation
const isValidPrivateKey = (_privateKey) => true;
exports.isValidPrivateKey = isValidPrivateKey;
exports.deriveUnhardenedKeys = false;
exports.publicKeyLength = 33;
const getPublicKey = async (privateKey, _compressed) => {
    const publicKey = await (0, ed25519_1.getPublicKey)(privateKey);
    return (0, utils_1.concatBytes)([new Uint8Array([0]), publicKey]);
};
exports.getPublicKey = getPublicKey;
const publicAdd = (_publicKey, _tweak) => {
    throw new Error('Ed25519 does not support public key derivation.');
};
exports.publicAdd = publicAdd;
const compressPublicKey = (publicKey) => {
    // Ed25519 public keys don't have a compressed form.
    return publicKey;
};
exports.compressPublicKey = compressPublicKey;
const decompressPublicKey = (publicKey) => {
    // Ed25519 public keys don't have a compressed form.
    return publicKey;
};
exports.decompressPublicKey = decompressPublicKey;
//# sourceMappingURL=ed25519.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\curves\\ed25519.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\index.js", {"./curve":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\curve.js","./ed25519":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\ed25519.js","./secp256k1":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\secp256k1.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Ccurves%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ed25519 = exports.secp256k1 = void 0;
__exportStar(require("./curve"), exports);
exports.secp256k1 = __importStar(require("./secp256k1"));
exports.ed25519 = __importStar(require("./ed25519"));
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\curves\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\secp256k1.js", {"../utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js","@noble/secp256k1":"F:\\metamask-extension\\node_modules\\@noble\\secp256k1\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Ccurves%5Csecp256k1.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decompressPublicKey = exports.compressPublicKey = exports.publicAdd = exports.getPublicKey = exports.isValidPrivateKey = exports.publicKeyLength = exports.deriveUnhardenedKeys = exports.secret = exports.name = exports.curve = void 0;
const utils_1 = require("@metamask/utils");
const secp256k1_1 = require("@noble/secp256k1");
const utils_2 = require("../utils");
var secp256k1_2 = require("@noble/secp256k1");
Object.defineProperty(exports, "curve", { enumerable: true, get: function () { return secp256k1_2.CURVE; } });
exports.name = 'secp256k1';
// Secret is defined in BIP-32 and SLIP-10:
// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#master-key-generation
// https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#master-key-generation
exports.secret = (0, utils_1.stringToBytes)('Bitcoin seed');
exports.deriveUnhardenedKeys = true;
exports.publicKeyLength = 65;
const isValidPrivateKey = (privateKey) => {
    return secp256k1_1.utils.isValidPrivateKey(privateKey);
};
exports.isValidPrivateKey = isValidPrivateKey;
const getPublicKey = (privateKey, compressed) => (0, secp256k1_1.getPublicKey)(privateKey, compressed);
exports.getPublicKey = getPublicKey;
const publicAdd = (publicKey, tweak) => {
    (0, utils_1.assert)((0, utils_2.isValidBytesKey)(tweak, 32), 'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.');
    const point = secp256k1_1.Point.fromHex(publicKey);
    // The returned child key Ki is point(parse256(IL)) + Kpar.
    // This multiplies the tweak with the base point of the curve (Gx, Gy).
    // https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#public-parent-key--public-child-key
    const newPoint = point.add(secp256k1_1.Point.fromPrivateKey(tweak));
    newPoint.assertValidity();
    return newPoint.toRawBytes(false);
};
exports.publicAdd = publicAdd;
const compressPublicKey = (publicKey) => {
    const point = secp256k1_1.Point.fromHex(publicKey);
    return point.toRawBytes(true);
};
exports.compressPublicKey = compressPublicKey;
const decompressPublicKey = (publicKey) => {
    // This calculates a point on the elliptic curve from a compressed public key. We can then use
    // this to get the uncompressed version of the public key.
    const point = secp256k1_1.Point.fromHex(publicKey);
    return point.toRawBytes(false);
};
exports.decompressPublicKey = decompressPublicKey;
//# sourceMappingURL=secp256k1.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\curves\\secp256k1.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivation.js", {"./BIP44CoinTypeNode":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\BIP44CoinTypeNode.js","./BIP44Node":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\BIP44Node.js","./SLIP10Node":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\SLIP10Node.js","./constants":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js","./curves":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\index.js","./derivers":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\index.js","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Cderivation.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validatePathSegment = exports.deriveKeyFromPath = void 0;
const utils_1 = require("@metamask/utils");
const BIP44CoinTypeNode_1 = require("./BIP44CoinTypeNode");
const BIP44Node_1 = require("./BIP44Node");
const constants_1 = require("./constants");
const curves_1 = require("./curves");
const derivers_1 = require("./derivers");
const SLIP10Node_1 = require("./SLIP10Node");
/**
 * Takes a full or partial HD path string and returns the key corresponding to
 * the given path, with the following constraints:
 *
 * - If the path starts with a BIP-32 node, a parent key must be provided.
 * - If the path starts with a BIP-39 node, a parent key must NOT be provided.
 * - The path cannot exceed 5 BIP-32 nodes in length, optionally preceded by
 * a single BIP-39 node.
 *
 * WARNING: It is the consumer's responsibility to ensure that the path is valid
 * relative to its parent key.
 *
 * @param args - The arguments for deriving a key from a path.
 * @param args.path - A full or partial HD path, e.g.:
 * `bip39:SEED_PHRASE/bip32:44'/bip32:60'/bip32:0'/bip32:0/bip32:0`.
 * BIP-39 seed phrases must be lowercase, space-delimited, and 12-24 words long.
 * @param args.node - The node to derive from.
 * @param args.depth - The depth of the segment.
 * @returns The derived key.
 */
async function deriveKeyFromPath(args) {
    const { path, depth = path.length } = args;
    const node = 'node' in args ? args.node : undefined;
    const curve = 'curve' in args ? args.curve : node === null || node === void 0 ? void 0 : node.curve;
    if (node &&
        !(node instanceof SLIP10Node_1.SLIP10Node) &&
        !(node instanceof BIP44Node_1.BIP44Node) &&
        !(node instanceof BIP44CoinTypeNode_1.BIP44CoinTypeNode)) {
        throw new Error('Invalid arguments: Node must be a SLIP-10 node or a BIP-44 node when provided.');
    }
    if (!curve) {
        throw new Error('Invalid arguments: Must specify either a parent node or curve.');
    }
    validatePathSegment(path, Boolean(node === null || node === void 0 ? void 0 : node.privateKey) || Boolean(node === null || node === void 0 ? void 0 : node.publicKey), depth);
    // Derive through each part of path. `pathSegment` needs to be cast because
    // `HDPathTuple.reduce()` doesn't work. Note that the first element of the
    // path can be a Uint8Array.
    return await path.reduce(async (promise, pathNode, index) => {
        const derivedNode = await promise;
        if (typeof pathNode === 'string') {
            const [pathType, pathPart] = pathNode.split(':');
            (0, utils_1.assert)(hasDeriver(pathType), `Unknown derivation type: "${pathType}".`);
            const deriver = derivers_1.derivers[pathType];
            return await deriver.deriveChildKey({
                path: pathPart,
                node: derivedNode,
                curve: (0, curves_1.getCurveByName)(curve),
            });
        }
        // Only the first path segment can be a Uint8Array.
        (0, utils_1.assert)(index === 0, getMalformedError());
        return await derivers_1.derivers.bip39.deriveChildKey({
            path: pathNode,
            node: derivedNode,
            curve: (0, curves_1.getCurveByName)(curve),
        });
    }, Promise.resolve(node));
}
exports.deriveKeyFromPath = deriveKeyFromPath;
/**
 * Check if the given path type is a valid deriver.
 *
 * @param pathType - The path type to check.
 * @returns Whether the path type is a valid deriver.
 */
function hasDeriver(pathType) {
    return pathType in derivers_1.derivers;
}
/**
 * The path segment must be one of the following:
 * - A lone BIP-32 path node.
 * - A lone BIP-39 path node.
 * - A multipath.
 *
 * @param path - The path segment string to validate.
 * @param hasKey - Whether the path segment has a key.
 * @param depth - The depth of the segment.
 */
function validatePathSegment(path, hasKey, depth) {
    if (path.length === 0) {
        throw new Error(`Invalid HD path segment: The segment must not be empty.`);
    }
    let startsWithBip39 = false;
    path.forEach((node, index) => {
        if (index === 0) {
            startsWithBip39 =
                node instanceof Uint8Array || constants_1.BIP_39_PATH_REGEX.test(node);
            if (
            // TypeScript is unable to infer that `node` is a string here, so we
            // need to explicitly check it again.
            !(node instanceof Uint8Array) &&
                !startsWithBip39 &&
                !constants_1.BIP_32_PATH_REGEX.test(node) &&
                !constants_1.SLIP_10_PATH_REGEX.test(node)) {
                throw getMalformedError();
            }
        }
        else if (node instanceof Uint8Array ||
            (!constants_1.BIP_32_PATH_REGEX.test(node) && !constants_1.SLIP_10_PATH_REGEX.test(node))) {
            throw getMalformedError();
        }
    });
    if (depth === constants_1.MIN_BIP_44_DEPTH && (!startsWithBip39 || path.length !== 1)) {
        throw new Error(`Invalid HD path segment: The segment must consist of a single BIP-39 node for depths of ${constants_1.MIN_BIP_44_DEPTH}. Received: "${String(path)}".`);
    }
    if (!hasKey && !startsWithBip39) {
        throw new Error('Invalid derivation parameters: Must specify parent key if the first node of the path segment is not a BIP-39 node.');
    }
    if (hasKey && startsWithBip39) {
        throw new Error('Invalid derivation parameters: May not specify parent key if the path segment starts with a BIP-39 node.');
    }
    const pathWithoutKey = (startsWithBip39 ? path.slice(1) : path);
    if (pathWithoutKey.length > 0) {
        const firstSegmentType = pathWithoutKey[0].split(':')[0];
        (0, utils_1.assert)(pathWithoutKey.every((segment) => segment.startsWith(`${firstSegmentType}:`)), `Invalid HD path segment: Cannot mix 'bip32' and 'slip10' path segments.`);
    }
}
exports.validatePathSegment = validatePathSegment;
/**
 * Get the error for a malformed path segment.
 *
 * @returns The error.
 */
function getMalformedError() {
    return new Error('Invalid HD path segment: The path segment is malformed.');
}
//# sourceMappingURL=derivation.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\derivation.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\bip32.js", {"../constants":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js","../curves":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\index.js","../utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js","./shared":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\shared.js","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js","@noble/hashes/sha3":"F:\\metamask-extension\\node_modules\\@noble\\hashes\\sha3.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Cderivers%5Cbip32.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildKey = exports.publicKeyToEthAddress = exports.privateKeyToEthAddress = void 0;
const utils_1 = require("@metamask/utils");
const sha3_1 = require("@noble/hashes/sha3");
const constants_1 = require("../constants");
const curves_1 = require("../curves");
const utils_2 = require("../utils");
const shared_1 = require("./shared");
/**
 * Converts a BIP-32 private key to an Ethereum address.
 *
 * **WARNING:** Only validates that the key is non-zero and of the correct
 * length. It is the consumer's responsibility to ensure that the specified
 * key is a valid BIP-44 Ethereum `address_index` key.
 *
 * @param key - The `address_index` private key bytes to convert to an Ethereum
 * address.
 * @returns The Ethereum address corresponding to the given key.
 */
function privateKeyToEthAddress(key) {
    (0, utils_1.assert)(key instanceof Uint8Array && (0, utils_2.isValidBytesKey)(key, constants_1.BYTES_KEY_LENGTH), 'Invalid key: The key must be a 32-byte, non-zero Uint8Array.');
    const publicKey = curves_1.secp256k1.getPublicKey(key, false);
    return publicKeyToEthAddress(publicKey);
}
exports.privateKeyToEthAddress = privateKeyToEthAddress;
/**
 * Converts a BIP-32 public key to an Ethereum address.
 *
 * **WARNING:** Only validates that the key is non-zero and of the correct
 * length. It is the consumer's responsibility to ensure that the specified
 * key is a valid BIP-44 Ethereum `address_index` key.
 *
 * @param key - The `address_index` public key bytes to convert to an Ethereum
 * address.
 * @returns The Ethereum address corresponding to the given key.
 */
function publicKeyToEthAddress(key) {
    (0, utils_1.assert)(key instanceof Uint8Array &&
        (0, utils_2.isValidBytesKey)(key, curves_1.secp256k1.publicKeyLength), 'Invalid key: The key must be a 65-byte, non-zero Uint8Array.');
    return (0, sha3_1.keccak_256)(key.slice(1)).slice(-20);
}
exports.publicKeyToEthAddress = publicKeyToEthAddress;
/**
 * Derive a BIP-32 child key with a given path from a parent key.
 *
 * @param options - The options for deriving a child key.
 * @param options.path - The derivation path part to derive.
 * @param options.node - The node to derive from.
 * @param options.curve - The curve to use for derivation.
 * @returns The derived child key as a {@link SLIP10Node}.
 */
async function deriveChildKey(options) {
    (0, utils_1.assert)(options.curve.name === 'secp256k1', 'Invalid curve: Only secp256k1 is supported by BIP-32.');
    return (0, shared_1.deriveChildKey)(options, handleError);
}
exports.deriveChildKey = deriveChildKey;
/**
 * Handles an error thrown during derivation by incrementing the child index
 * and retrying.
 *
 * @param _ - The error that was thrown.
 * @param options - The options for deriving a child key.
 * @returns The options for deriving a child key with the child index
 * incremented by one.
 */
async function handleError(_, options) {
    const { childIndex, privateKey, publicKey, isHardened, curve, chainCode } = options;
    (0, utils_2.validateBIP32Index)(childIndex + 1);
    if (privateKey) {
        const secretExtension = await (0, shared_1.deriveSecretExtension)({
            privateKey,
            childIndex: childIndex + 1,
            isHardened,
            curve,
        });
        const newEntropy = (0, shared_1.generateEntropy)({
            chainCode,
            extension: secretExtension,
        });
        return Object.assign(Object.assign({}, options), { childIndex: childIndex + 1, entropy: newEntropy });
    }
    const publicExtension = (0, shared_1.derivePublicExtension)({
        parentPublicKey: publicKey,
        childIndex: childIndex + 1,
    });
    const newEntropy = (0, shared_1.generateEntropy)({
        chainCode,
        extension: publicExtension,
    });
    return Object.assign(Object.assign({}, options), { childIndex: childIndex + 1, entropy: newEntropy });
}
//# sourceMappingURL=bip32.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\derivers\\bip32.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\bip39.js", {"../SLIP10Node":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\SLIP10Node.js","../constants":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js","../utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js","@metamask/scure-bip39":"F:\\metamask-extension\\node_modules\\@metamask\\scure-bip39\\dist\\index.js","@metamask/scure-bip39/dist/wordlists/english":"F:\\metamask-extension\\node_modules\\@metamask\\scure-bip39\\dist\\wordlists\\english.js","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js","@noble/hashes/hmac":"F:\\metamask-extension\\node_modules\\@noble\\hashes\\hmac.js","@noble/hashes/sha512":"F:\\metamask-extension\\node_modules\\@noble\\hashes\\sha512.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Cderivers%5Cbip39.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBip39KeyFromSeed = exports.deriveChildKey = exports.bip39MnemonicToMultipath = void 0;
const scure_bip39_1 = require("@metamask/scure-bip39");
const english_1 = require("@metamask/scure-bip39/dist/wordlists/english");
const utils_1 = require("@metamask/utils");
const hmac_1 = require("@noble/hashes/hmac");
const sha512_1 = require("@noble/hashes/sha512");
const constants_1 = require("../constants");
const SLIP10Node_1 = require("../SLIP10Node");
const utils_2 = require("../utils");
/**
 * Convert a BIP-39 mnemonic phrase to a multi path.
 *
 * @param mnemonic - The BIP-39 mnemonic phrase to convert.
 * @returns The multi path.
 */
function bip39MnemonicToMultipath(mnemonic) {
    return `bip39:${mnemonic.toLowerCase().trim()}`;
}
exports.bip39MnemonicToMultipath = bip39MnemonicToMultipath;
/**
 * Create a {@link SLIP10Node} from a BIP-39 mnemonic phrase.
 *
 * @param options - The options for creating the node.
 * @param options.path - The multi path.
 * @param options.curve - The curve to use for derivation.
 * @returns The node.
 */
async function deriveChildKey({ path, curve, }) {
    return createBip39KeyFromSeed(await (0, scure_bip39_1.mnemonicToSeed)(path, english_1.wordlist), curve);
}
exports.deriveChildKey = deriveChildKey;
/**
 * Create a {@link SLIP10Node} from a BIP-39 seed.
 *
 * @param seed - The cryptographic seed bytes.
 * @param curve - The curve to use.
 * @returns An object containing the corresponding BIP-39 master key and chain
 * code.
 */
async function createBip39KeyFromSeed(seed, curve) {
    (0, utils_1.assert)(seed.length >= 16 && seed.length <= 64, 'Invalid seed: The seed must be between 16 and 64 bytes long.');
    const key = (0, hmac_1.hmac)(sha512_1.sha512, curve.secret, seed);
    const privateKey = key.slice(0, constants_1.BYTES_KEY_LENGTH);
    const chainCode = key.slice(constants_1.BYTES_KEY_LENGTH);
    (0, utils_1.assert)(curve.isValidPrivateKey(privateKey), 'Invalid private key: The private key must greater than 0 and less than the curve order.');
    const masterFingerprint = (0, utils_2.getFingerprint)(await curve.getPublicKey(privateKey, true));
    return SLIP10Node_1.SLIP10Node.fromExtendedKey({
        privateKey,
        chainCode,
        masterFingerprint,
        depth: 0,
        parentFingerprint: 0,
        index: 0,
        curve: curve.name,
    });
}
exports.createBip39KeyFromSeed = createBip39KeyFromSeed;
//# sourceMappingURL=bip39.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\derivers\\bip39.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\index.js", {"./bip32":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\bip32.js","./bip39":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\bip39.js","./slip10":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\slip10.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Cderivers%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.derivers = void 0;
const bip32 = __importStar(require("./bip32"));
const bip39 = __importStar(require("./bip39"));
const slip10 = __importStar(require("./slip10"));
exports.derivers = {
    bip32,
    bip39,
    slip10,
};
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\derivers\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\shared.js", {"../SLIP10Node":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\SLIP10Node.js","../constants":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js","../curves":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\index.js","../utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js","@noble/hashes/hmac":"F:\\metamask-extension\\node_modules\\@noble\\hashes\\hmac.js","@noble/hashes/sha512":"F:\\metamask-extension\\node_modules\\@noble\\hashes\\sha512.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Cderivers%5Cshared.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateNode = exports.generateEntropy = exports.privateAdd = exports.derivePublicChildKey = exports.derivePublicExtension = exports.deriveSecretExtension = exports.deriveChildKey = void 0;
const utils_1 = require("@metamask/utils");
const hmac_1 = require("@noble/hashes/hmac");
const sha512_1 = require("@noble/hashes/sha512");
const constants_1 = require("../constants");
const curves_1 = require("../curves");
const SLIP10Node_1 = require("../SLIP10Node");
const utils_2 = require("../utils");
/**
 * Derive a BIP-32 or SLIP-10 child key with a given path from a parent key.
 *
 * Since BIP-32 and SLIP-10 are very similar, this function can be used to
 * derive both types of keys.
 *
 * @param options - The options for deriving a child key.
 * @param options.path - The derivation path part to derive.
 * @param options.node - The node to derive from.
 * @param options.curve - The curve to use for derivation.
 * @param handleError - A function that can handle errors that occur during
 * derivation.
 * @returns The derived node.
 */
async function deriveChildKey({ path, node, curve }, handleError) {
    validateNode(node);
    const { childIndex, isHardened } = getValidatedPath(path, node, curve);
    const args = {
        chainCode: node.chainCodeBytes,
        childIndex,
        isHardened,
        depth: node.depth,
        parentFingerprint: node.fingerprint,
        masterFingerprint: node.masterFingerprint,
        curve,
    };
    if (node.privateKeyBytes) {
        const secretExtension = await deriveSecretExtension({
            privateKey: node.privateKeyBytes,
            childIndex,
            isHardened,
            curve,
        });
        const entropy = generateEntropy({
            chainCode: node.chainCodeBytes,
            extension: secretExtension,
        });
        return await deriveNode(Object.assign({ privateKey: node.privateKeyBytes, entropy }, args), handleError);
    }
    const publicExtension = derivePublicExtension({
        parentPublicKey: node.compressedPublicKeyBytes,
        childIndex,
    });
    const entropy = generateEntropy({
        chainCode: node.chainCodeBytes,
        extension: publicExtension,
    });
    return await deriveNode(Object.assign({ publicKey: node.compressedPublicKeyBytes, entropy }, args), handleError);
}
exports.deriveChildKey = deriveChildKey;
/**
 * Derive a SLIP-10 child key from a parent key.
 *
 * @param options - The options for deriving a child key.
 * @param options.privateKey - The private key to derive from.
 * @param options.publicKey - The public key to derive from.
 * @param options.entropy - The entropy to use for deriving the child key.
 * @param options.chainCode - The chain code to use for deriving the child key.
 * @param options.childIndex - The child index to use for deriving the child key.
 * @param options.isHardened - Whether the child key is hardened.
 * @param options.depth - The depth of the child key.
 * @param options.parentFingerprint - The fingerprint of the parent key.
 * @param options.masterFingerprint - The fingerprint of the master key.
 * @param options.curve - The curve to use for deriving the child key.
 * @param handleError - A function to handle errors during derivation.
 * @returns The derived child key as {@link SLIP10Node}.
 */
async function deriveNode(options, handleError) {
    const { privateKey, publicKey, entropy, childIndex, isHardened, depth, parentFingerprint, masterFingerprint, curve, } = options;
    try {
        if (privateKey) {
            return await derivePrivateChildKey({
                entropy,
                privateKey,
                depth,
                masterFingerprint,
                parentFingerprint,
                childIndex,
                isHardened,
                curve,
            });
        }
        return await derivePublicChildKey({
            entropy,
            publicKey,
            depth,
            masterFingerprint,
            parentFingerprint,
            childIndex,
            curve,
        });
    }
    catch (error) {
        return await deriveNode(await handleError(error, options), handleError);
    }
}
/**
 * Derive a BIP-32 secret extension from a parent key and child index.
 *
 * @param options - The options for deriving a secret extension.
 * @param options.privateKey - The parent private key bytes.
 * @param options.childIndex - The child index to derive.
 * @param options.isHardened - Whether the child index is hardened.
 * @param options.curve - The curve to use for derivation.
 * @returns The secret extension bytes.
 */
async function deriveSecretExtension({ privateKey, childIndex, isHardened, curve, }) {
    if (isHardened) {
        // Hardened child
        return (0, utils_1.concatBytes)([
            new Uint8Array([0]),
            privateKey,
            (0, utils_2.numberToUint32)(childIndex + constants_1.BIP_32_HARDENED_OFFSET),
        ]);
    }
    // Normal child
    const parentPublicKey = await curve.getPublicKey(privateKey, true);
    return derivePublicExtension({ parentPublicKey, childIndex });
}
exports.deriveSecretExtension = deriveSecretExtension;
/**
 * Derive a BIP-32 public extension from a parent key and child index.
 *
 * @param options - The options for deriving a public extension.
 * @param options.parentPublicKey - The parent public key bytes.
 * @param options.childIndex - The child index to derive.
 * @returns The public extension bytes.
 */
function derivePublicExtension({ parentPublicKey, childIndex, }) {
    return (0, utils_1.concatBytes)([parentPublicKey, (0, utils_2.numberToUint32)(childIndex)]);
}
exports.derivePublicExtension = derivePublicExtension;
/**
 * Derive a BIP-32 key from a parent key and secret extension.
 *
 * @param options - The options for deriving a key.
 * @param options.privateKey - The parent private key bytes.
 * @param options.entropy - The entropy bytes.
 * @param options.curve - The curve to use for derivation.
 * @returns The derived key.
 */
async function generateKey({ privateKey, entropy, curve, }) {
    const keyMaterial = entropy.slice(0, 32);
    const childChainCode = entropy.slice(32);
    // If curve is ed25519: The returned child key ki is parse256(IL).
    // https://github.com/satoshilabs/slips/blob/133ea52a8e43d338b98be208907e144277e44c0e/slip-0010.md#private-parent-key--private-child-key
    if (curve.name === 'ed25519') {
        const publicKey = await curve.getPublicKey(keyMaterial);
        return { privateKey: keyMaterial, publicKey, chainCode: childChainCode };
    }
    const childPrivateKey = privateAdd(privateKey, keyMaterial, curve);
    const publicKey = await curve.getPublicKey(childPrivateKey);
    return { privateKey: childPrivateKey, publicKey, chainCode: childChainCode };
}
/**
 * Derive a BIP-32 private child key with a given path from a parent key.
 *
 * @param args - The arguments for deriving a private child key.
 * @param args.entropy - The entropy to use for derivation.
 * @param args.privateKey - The parent private key to use for derivation.
 * @param args.depth - The depth of the parent node.
 * @param args.masterFingerprint - The fingerprint of the master node.
 * @param args.parentFingerprint - The fingerprint of the parent node.
 * @param args.childIndex - The child index to derive.
 * @param args.isHardened - Whether the child index is hardened.
 * @param args.curve - The curve to use for derivation.
 * @returns The derived {@link SLIP10Node}.
 */
async function derivePrivateChildKey({ entropy, privateKey, depth, masterFingerprint, parentFingerprint, childIndex, isHardened, curve, }) {
    const actualChildIndex = childIndex + (isHardened ? constants_1.BIP_32_HARDENED_OFFSET : 0);
    const { privateKey: childPrivateKey, chainCode: childChainCode } = await generateKey({
        privateKey,
        entropy,
        curve,
    });
    return await SLIP10Node_1.SLIP10Node.fromExtendedKey({
        privateKey: childPrivateKey,
        chainCode: childChainCode,
        depth: depth + 1,
        masterFingerprint,
        parentFingerprint,
        index: actualChildIndex,
        curve: curve.name,
    });
}
/**
 * Derive a BIP-32 public key from a parent key and public extension.
 *
 * @param options - The options for deriving a public key.
 * @param options.publicKey - The parent public key bytes.
 * @param options.entropy - The entropy bytes.
 * @param options.curve - The curve to use for derivation.
 * @returns The derived public key.
 */
function generatePublicKey({ publicKey, entropy, curve, }) {
    const keyMaterial = entropy.slice(0, 32);
    const childChainCode = entropy.slice(32);
    // This function may fail if the resulting key is invalid.
    const childPublicKey = curve.publicAdd(publicKey, keyMaterial);
    return {
        publicKey: childPublicKey,
        chainCode: childChainCode,
    };
}
/**
 * Derive a BIP-32 public child key with a given path from a parent key.
 *
 * @param args - The arguments for deriving a public child key.
 * @param args.entropy - The entropy to use for derivation.
 * @param args.publicKey - The parent public key to use for derivation.
 * @param args.depth - The depth of the parent node.
 * @param args.masterFingerprint - The fingerprint of the master node.
 * @param args.parentFingerprint - The fingerprint of the parent node.
 * @param args.childIndex - The child index to derive.
 * @param args.curve - The curve to use for derivation.
 * @returns The derived {@link SLIP10Node}.
 */
async function derivePublicChildKey({ entropy, publicKey, depth, masterFingerprint, parentFingerprint, childIndex, curve, }) {
    const { publicKey: childPublicKey, chainCode: childChainCode } = generatePublicKey({
        publicKey,
        entropy,
        curve,
    });
    return await SLIP10Node_1.SLIP10Node.fromExtendedKey({
        publicKey: childPublicKey,
        chainCode: childChainCode,
        depth: depth + 1,
        masterFingerprint,
        parentFingerprint,
        index: childIndex,
        curve: curve.name,
    });
}
exports.derivePublicChildKey = derivePublicChildKey;
/**
 * Add a tweak to the private key: `(privateKey + tweak) % n`.
 *
 * @param privateKeyBytes - The private key as 32 byte Uint8Array.
 * @param tweakBytes - The tweak as 32 byte Uint8Array.
 * @param curve - The curve to use.
 * @throws If the private key or tweak is invalid.
 * @returns The private key with the tweak added to it.
 */
function privateAdd(privateKeyBytes, tweakBytes, curve) {
    (0, utils_1.assert)((0, utils_2.isValidBytesKey)(tweakBytes, 32), 'Invalid tweak: Tweak must be a non-zero 32-byte Uint8Array.');
    const privateKey = (0, utils_1.bytesToBigInt)(privateKeyBytes);
    const tweak = (0, utils_1.bytesToBigInt)(tweakBytes);
    if (tweak >= curve.curve.n) {
        throw new Error('Invalid tweak: Tweak is larger than the curve order.');
    }
    const added = (0, curves_1.mod)(privateKey + tweak, curve.curve.n);
    const bytes = (0, utils_1.hexToBytes)(added.toString(16).padStart(64, '0'));
    if (!curve.isValidPrivateKey(bytes)) {
        throw new Error('Invalid private key or tweak: The resulting private key is invalid.');
    }
    return bytes;
}
exports.privateAdd = privateAdd;
/**
 * Generate 64 bytes of (deterministic) entropy from a chain code and secret
 * extension.
 *
 * @param args - The arguments for generating entropy.
 * @param args.chainCode - The parent chain code bytes.
 * @param args.extension - The extension bytes.
 * @returns The generated entropy bytes.
 */
function generateEntropy({ chainCode, extension }) {
    return (0, hmac_1.hmac)(sha512_1.sha512, chainCode, extension);
}
exports.generateEntropy = generateEntropy;
/**
 * Validate that a node is specified.
 *
 * @param node - The node to validate.
 * @throws If the node is not specified.
 */
function validateNode(node) {
    (0, utils_1.assert)(node, 'Invalid parameters: Must specify a node to derive from.');
}
exports.validateNode = validateNode;
/**
 * Validate a path.
 *
 * @param path - The path to validate.
 * @param node - The node to validate the path against.
 * @param curve - The curve to validate the path against.
 * @throws If the path is invalid.
 */
function validatePath(path, node, curve) {
    (0, utils_1.assert)(typeof path === 'string', 'Invalid path: Must be a string.');
    const isHardened = path.endsWith(`'`);
    (0, utils_1.assert)(!isHardened || node.privateKey, 'Invalid parameters: Cannot derive hardened child keys without a private key.');
    (0, utils_1.assert)(isHardened || curve.deriveUnhardenedKeys, `Invalid path: Cannot derive unhardened child keys with ${curve.name}.`);
}
/**
 * Validate a path and return the child index and whether it is hardened.
 *
 * @param path - The path to validate.
 * @param node - The node to validate the path against.
 * @param curve - The curve to validate the path against.
 * @returns The child index and whether it is hardened.
 */
function getValidatedPath(path, node, curve) {
    validatePath(path, node, curve);
    const indexPart = path.split(`'`)[0];
    const childIndex = parseInt(indexPart, 10);
    if (!constants_1.UNPREFIXED_PATH_REGEX.test(indexPart) ||
        !Number.isInteger(childIndex) ||
        childIndex < 0 ||
        childIndex >= constants_1.BIP_32_HARDENED_OFFSET) {
        throw new Error(`Invalid path: The index must be a non-negative decimal integer less than ${constants_1.BIP_32_HARDENED_OFFSET}.`);
    }
    return { childIndex, isHardened: path.includes(`'`) };
}
//# sourceMappingURL=shared.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\derivers\\shared.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\slip10.js", {"../constants":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js","../utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js","./shared":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\derivers\\shared.js","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Cderivers%5Cslip10.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveChildKey = void 0;
const utils_1 = require("@metamask/utils");
const constants_1 = require("../constants");
const utils_2 = require("../utils");
const shared_1 = require("./shared");
/**
 * Derive a SLIP-10 child key with a given path from a parent key.
 *
 * @param options - The options for deriving a child key.
 * @returns A tuple containing the derived private key, public key and chain
 * code.
 */
async function deriveChildKey(options) {
    return await (0, shared_1.deriveChildKey)(options, handleError);
}
exports.deriveChildKey = deriveChildKey;
/**
 * Handle an error that occurs during SLIP-10 derivation.
 *
 * @param error - The error that occurred.
 * @param options - The options that were used for derivation.
 * @returns The new options to use for derivation.
 */
async function handleError(error, options) {
    const { curve, isHardened, childIndex, entropy, chainCode } = options;
    // `ed25519` keys are always valid, so this error should never be thrown. If
    // it is, we re-throw it.
    if (curve.name === 'ed25519') {
        throw error;
    }
    const actualChildIndex = isHardened
        ? childIndex + constants_1.BIP_32_HARDENED_OFFSET
        : childIndex;
    // As per SLIP-10, if the resulting key is invalid, the new entropy is
    // generated as follows:
    // Key material (32 bytes), child chain code (32 bytes) =
    //   HMAC-SHA512(parent chain code, 0x01 || chain code from invalid key || index).
    const newEntropy = (0, shared_1.generateEntropy)({
        chainCode,
        extension: (0, utils_1.concatBytes)([
            0x01,
            entropy.slice(32, 64),
            (0, utils_2.numberToUint32)(actualChildIndex),
        ]),
    });
    return Object.assign(Object.assign({}, options), { entropy: newEntropy });
}
//# sourceMappingURL=slip10.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\derivers\\slip10.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\extended-keys.js", {"./BIP44Node":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\BIP44Node.js","./curves/secp256k1":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\secp256k1.js","./utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Cextended-keys.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeExtendedKey = exports.decodeExtendedKey = exports.PRIVATE_KEY_VERSION = exports.PUBLIC_KEY_VERSION = void 0;
const utils_1 = require("@metamask/utils");
const BIP44Node_1 = require("./BIP44Node");
const secp256k1_1 = require("./curves/secp256k1");
const utils_2 = require("./utils");
// https://github.com/bitcoin/bips/blob/274fa400d630ba757bec0c03b35ebe2345197108/bip-0032.mediawiki#Serialization_format
exports.PUBLIC_KEY_VERSION = 0x0488b21e;
exports.PRIVATE_KEY_VERSION = 0x0488ade4;
/**
 * Decodes an extended public or private key. In the case of an extended public key, the public key
 * is returned in the uncompressed form.
 *
 * Throws an error if the extended key is invalid.
 *
 * @param extendedKey - The extended key string to attempt to decode.
 * @returns The decoded extended key.
 */
const decodeExtendedKey = (extendedKey) => {
    const bytes = (0, utils_2.decodeBase58check)(extendedKey);
    if (bytes.length !== 78) {
        throw new Error(`Invalid extended key: Expected a length of 78, got ${bytes.length}.`);
    }
    const view = (0, utils_1.createDataView)(bytes);
    const version = view.getUint32(0, false);
    const depth = view.getUint8(4);
    (0, BIP44Node_1.validateBIP44Depth)(depth);
    const parentFingerprint = view.getUint32(5, false);
    const index = view.getUint32(9, false);
    const chainCode = bytes.slice(13, 45);
    if (!(0, utils_2.isValidBytesKey)(chainCode, 32)) {
        throw new Error(`Invalid extended key: Chain code must be a 32-byte non-zero byte array.`);
    }
    const key = bytes.slice(45, 78);
    if (!(0, utils_2.isValidBytesKey)(key, 33)) {
        throw new Error(`Invalid extended key: Key must be a 33-byte non-zero byte array.`);
    }
    const keyView = (0, utils_1.createDataView)(key);
    if (version === exports.PUBLIC_KEY_VERSION) {
        if (keyView.getUint8(0) !== 0x02 && keyView.getUint8(0) !== 0x03) {
            throw new Error(`Invalid extended key: Public key must start with 0x02 or 0x03.`);
        }
        return {
            version,
            depth,
            parentFingerprint,
            index,
            chainCode,
            publicKey: (0, secp256k1_1.decompressPublicKey)(key),
        };
    }
    if (version === exports.PRIVATE_KEY_VERSION) {
        if (keyView.getUint8(0) !== 0x00) {
            throw new Error(`Invalid extended key: Private key must start with 0x00.`);
        }
        return {
            version,
            depth,
            parentFingerprint,
            index,
            chainCode,
            privateKey: key.slice(1),
        };
    }
    throw new Error(`Invalid extended key: Expected a public (xpub) or private key (xprv) version.`);
};
exports.decodeExtendedKey = decodeExtendedKey;
/**
 * Encodes an extended public or private key. Assumes that all the inputs are verified beforehand.
 *
 * @param extendedKey - The extended key data to encode.
 * @returns The encoded extended key.
 */
const encodeExtendedKey = (extendedKey) => {
    const { version, depth, parentFingerprint, index, chainCode } = extendedKey;
    const bytes = new Uint8Array(78);
    const view = (0, utils_1.createDataView)(bytes);
    view.setUint32(0, version, false);
    view.setUint8(4, depth);
    view.setUint32(5, parentFingerprint, false);
    view.setUint32(9, index, false);
    bytes.set(chainCode, 13);
    if (extendedKey.version === exports.PUBLIC_KEY_VERSION) {
        const { publicKey } = extendedKey;
        const compressedPublicKey = (0, secp256k1_1.compressPublicKey)(publicKey);
        bytes.set(compressedPublicKey, 45);
    }
    if (extendedKey.version === exports.PRIVATE_KEY_VERSION) {
        const { privateKey } = extendedKey;
        bytes.set(privateKey, 46);
    }
    return (0, utils_2.encodeBase58check)(bytes);
};
exports.encodeExtendedKey = encodeExtendedKey;
//# sourceMappingURL=extended-keys.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\extended-keys.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\index.js", {"./BIP44CoinTypeNode":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\BIP44CoinTypeNode.js","./BIP44Node":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\BIP44Node.js","./SLIP10Node":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\SLIP10Node.js","./constants":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js","./curves":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\index.js","./utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Cindex.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidBIP32PathSegment = exports.getBIP44AddressKeyDeriver = exports.deriveBIP44AddressKey = exports.BIP_44_COIN_TYPE_DEPTH = exports.BIP44CoinTypeNode = exports.ed25519 = exports.secp256k1 = exports.SLIP10Node = exports.BIP44Node = void 0;
var BIP44Node_1 = require("./BIP44Node");
Object.defineProperty(exports, "BIP44Node", { enumerable: true, get: function () { return BIP44Node_1.BIP44Node; } });
var SLIP10Node_1 = require("./SLIP10Node");
Object.defineProperty(exports, "SLIP10Node", { enumerable: true, get: function () { return SLIP10Node_1.SLIP10Node; } });
var curves_1 = require("./curves");
Object.defineProperty(exports, "secp256k1", { enumerable: true, get: function () { return curves_1.secp256k1; } });
Object.defineProperty(exports, "ed25519", { enumerable: true, get: function () { return curves_1.ed25519; } });
var BIP44CoinTypeNode_1 = require("./BIP44CoinTypeNode");
Object.defineProperty(exports, "BIP44CoinTypeNode", { enumerable: true, get: function () { return BIP44CoinTypeNode_1.BIP44CoinTypeNode; } });
Object.defineProperty(exports, "BIP_44_COIN_TYPE_DEPTH", { enumerable: true, get: function () { return BIP44CoinTypeNode_1.BIP_44_COIN_TYPE_DEPTH; } });
Object.defineProperty(exports, "deriveBIP44AddressKey", { enumerable: true, get: function () { return BIP44CoinTypeNode_1.deriveBIP44AddressKey; } });
Object.defineProperty(exports, "getBIP44AddressKeyDeriver", { enumerable: true, get: function () { return BIP44CoinTypeNode_1.getBIP44AddressKeyDeriver; } });
__exportStar(require("./constants"), exports);
var utils_1 = require("./utils");
Object.defineProperty(exports, "isValidBIP32PathSegment", { enumerable: true, get: function () { return utils_1.isValidBIP32PathSegment; } });
//# sourceMappingURL=index.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\index.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\utils.js", {"./constants":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\constants.js","./curves":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\dist\\curves\\index.js","@metamask/scure-bip39/dist/wordlists/english":"F:\\metamask-extension\\node_modules\\@metamask\\scure-bip39\\dist\\wordlists\\english.js","@metamask/utils":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\index.js","@noble/hashes/ripemd160":"F:\\metamask-extension\\node_modules\\@noble\\hashes\\ripemd160.js","@noble/hashes/sha256":"F:\\metamask-extension\\node_modules\\@noble\\hashes\\sha256.js","@scure/base":"F:\\metamask-extension\\node_modules\\@scure\\base\\lib\\index.js"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cdist%5Cutils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.numberToUint32 = exports.validateCurve = exports.mnemonicPhraseToBytes = exports.getFingerprint = exports.encodeBase58check = exports.decodeBase58check = exports.getBytesUnsafe = exports.getBytes = exports.isValidInteger = exports.isValidBytesKey = exports.nullableHexStringToBytes = exports.hexStringToBytes = exports.isHardened = exports.isValidBIP32PathSegment = exports.isValidBIP32Index = exports.validateBIP32Index = exports.getBIP32NodeToken = exports.getUnhardenedBIP32NodeToken = exports.getHardenedBIP32NodeToken = exports.getBIP44CoinTypeToAddressPathTuple = exports.getBIP44ChangePathString = exports.getBIP44CoinTypePathString = void 0;
const english_1 = require("@metamask/scure-bip39/dist/wordlists/english");
const utils_1 = require("@metamask/utils");
const ripemd160_1 = require("@noble/hashes/ripemd160");
const sha256_1 = require("@noble/hashes/sha256");
const base_1 = require("@scure/base");
const constants_1 = require("./constants");
const curves_1 = require("./curves");
/**
 * Gets a string representation of a BIP-44 path of depth 2, i.e.:
 * `m / 44' / coin_type'`
 *
 * For display purposes only.
 *
 * @param coin_type - The `coin_type` index to create a path visualization for.
 * @returns The visualization of the BIP-44 path for thte specified `coin_type`.
 */
function getBIP44CoinTypePathString(coin_type) {
    return `m / ${constants_1.BIP44PurposeNodeToken} / ${getHardenedBIP32NodeToken(coin_type)}`;
}
exports.getBIP44CoinTypePathString = getBIP44CoinTypePathString;
/**
 * Gets a string representation of a BIP-44 path of depth 4, i.e.:
 * `m / 44' / coin_type' / account' / change`
 *
 * For display purposes only.
 *
 * @param coinTypePath - The parent `coin_type` path.
 * @param indices - The `account` and `change` index to create a path visualization for.
 * @returns The visualization of the BIP-44 path for the specified `coin_type`
 * and `change` indices.
 */
function getBIP44ChangePathString(coinTypePath, indices) {
    var _a, _b;
    return `${coinTypePath} / ${getHardenedBIP32NodeToken((_a = indices.account) !== null && _a !== void 0 ? _a : 0)} / ${getBIP32NodeToken((_b = indices.change) !== null && _b !== void 0 ? _b : 0)}`;
}
exports.getBIP44ChangePathString = getBIP44ChangePathString;
/**
 * Gets a BIP-44 path tuple of the form `account' / change / address_index`,
 * which can be used to derive address keys together with a `coin_type` key.
 *
 * @param indices - The BIP-44 derivation index values.
 * @param indices.account - The `account` index value.
 * @param indices.change - The `change` index value.
 * @param indices.address_index - The `address_index` index value.
 * @returns The `account' / change / address_index` path corresponding to the
 * specified indices.
 */
function getBIP44CoinTypeToAddressPathTuple({ account = 0, change = 0, address_index, }) {
    return [
        getHardenedBIP32NodeToken(account),
        getBIP32NodeToken(change),
        getBIP32NodeToken(address_index),
    ];
}
exports.getBIP44CoinTypeToAddressPathTuple = getBIP44CoinTypeToAddressPathTuple;
/**
 * A hardened BIP-32 node token, e.g. `bip32:0'`.
 * Validates that the index is a non-negative integer number, and throws an
 * error if validation fails.
 *
 * @param index - The index of the node.
 * @returns The hardened BIP-32 node token.
 */
function getHardenedBIP32NodeToken(index) {
    validateBIP32Index(index);
    return `${getUnhardenedBIP32NodeToken(index)}'`;
}
exports.getHardenedBIP32NodeToken = getHardenedBIP32NodeToken;
/**
 * An unhardened BIP-32 node token, e.g. `bip32:0`.
 * Validates that the index is a non-negative integer number, and throws an
 * error if validation fails.
 *
 * @param index - The index of the node.
 * @returns The unhardened BIP-32 node token.
 */
function getUnhardenedBIP32NodeToken(index) {
    validateBIP32Index(index);
    return `bip32:${index}`;
}
exports.getUnhardenedBIP32NodeToken = getUnhardenedBIP32NodeToken;
/**
 * A hardened or unhardened BIP-32 node token, e.g. `bip32:0` or `bip32:0'`.
 * Validates that the index is a non-negative integer number, and throws an
 * error if validation fails.
 *
 * @param index - The index of the node.
 * @returns The hardened or unhardened BIP-32 node token.
 */
function getBIP32NodeToken(index) {
    if (typeof index === 'number') {
        return getUnhardenedBIP32NodeToken(index);
    }
    if (!index ||
        !Number.isInteger(index.index) ||
        typeof index.hardened !== 'boolean') {
        throw new Error('Invalid BIP-32 index: Must be an object containing the index and whether it is hardened.');
    }
    if (index.hardened) {
        return getHardenedBIP32NodeToken(index.index);
    }
    return getUnhardenedBIP32NodeToken(index.index);
}
exports.getBIP32NodeToken = getBIP32NodeToken;
/**
 * Validates that the index is a non-negative integer number. Throws an
 * error if validation fails.
 *
 * @param addressIndex - The index to validate.
 */
function validateBIP32Index(addressIndex) {
    if (!isValidBIP32Index(addressIndex)) {
        throw new Error(`Invalid BIP-32 index: Must be a non-negative integer.`);
    }
}
exports.validateBIP32Index = validateBIP32Index;
/**
 * Check if the index is a valid BIP-32 index.
 *
 * @param index - The BIP-32 index to test.
 * @returns Whether the index is a non-negative integer number.
 */
function isValidBIP32Index(index) {
    return isValidInteger(index) && index <= constants_1.MAX_BIP_32_INDEX;
}
exports.isValidBIP32Index = isValidBIP32Index;
/**
 * Check if the value is a valid BIP-32 path segment, i.e., a string of the form
 * `0'`.
 *
 * @param segment - The BIP-32 path segment to test.
 * @returns Whether the path segment is a valid BIP-32 path segment.
 */
function isValidBIP32PathSegment(segment) {
    if (typeof segment !== 'string') {
        return false;
    }
    const match = segment.match(constants_1.UNPREFIXED_BIP_32_PATH_REGEX);
    if (!(match === null || match === void 0 ? void 0 : match.groups)) {
        return false;
    }
    const index = parseInt(match.groups.index, 10);
    return isValidInteger(index) && index <= constants_1.MAX_UNHARDENED_BIP_32_INDEX;
}
exports.isValidBIP32PathSegment = isValidBIP32PathSegment;
/**
 * Check if the value is a hardened BIP-32 index. This only checks if the value
 * ends with a `'` character, and does not validate that the index is a valid
 * BIP-32 index.
 *
 * @param bip32Token - The token to test.
 * @returns Whether the token is hardened, i.e. ends with `'`.
 */
function isHardened(bip32Token) {
    return bip32Token.endsWith(`'`);
}
exports.isHardened = isHardened;
/**
 * Get a `Uint8Array` from a hexadecimal string or a `Uint8Array`. If the input
 * is a hexadecimal string, it is converted to a `Uint8Array`. If the input is
 * a `Uint8Array`, it is returned as-is.
 *
 * @param hexString - The hexadecimal string to convert.
 * @returns The `Uint8Array` corresponding to the hexadecimal string.
 */
function hexStringToBytes(hexString) {
    if (hexString instanceof Uint8Array) {
        return hexString;
    }
    return (0, utils_1.hexToBytes)(hexString);
}
exports.hexStringToBytes = hexStringToBytes;
/**
 * The same as {@link hexStringToBytes}, but returns `undefined` if the input
 * is `undefined`.
 *
 * @param hexString - The hexadecimal string to convert.
 * @returns The `Uint8Array` corresponding to the hexadecimal string.
 */
function nullableHexStringToBytes(hexString) {
    if (hexString !== undefined) {
        return hexStringToBytes(hexString);
    }
    return undefined;
}
exports.nullableHexStringToBytes = nullableHexStringToBytes;
/**
 * Tests whether the specified `Uint8Array` is a valid BIP-32 key.
 * A valid bytes key is 64 bytes long and has at least one non-zero byte.
 *
 * @param bytes - The `Uint8Array` to test.
 * @param expectedLength - The expected length of the Uint8Array.
 * @returns Whether the Uint8Array represents a valid BIP-32 key.
 */
function isValidBytesKey(bytes, expectedLength) {
    if (bytes.length !== expectedLength) {
        return false;
    }
    for (const byte of bytes) {
        if (byte !== 0) {
            return true;
        }
    }
    return false;
}
exports.isValidBytesKey = isValidBytesKey;
/**
 * Tests whether the specified number is a valid integer equal to or greater than 0.
 *
 * @param value - The number to test.
 * @returns Whether the number is a valid integer.
 */
function isValidInteger(value) {
    return typeof value === 'number' && Number.isInteger(value) && value >= 0;
}
exports.isValidInteger = isValidInteger;
/**
 * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that the
 * length of the `Uint8Array` matches the specified length, and that the `Uint8Array`
 * is not empty.
 *
 * @param value - The value to convert to a `Uint8Array`.
 * @param length - The length to validate the `Uint8Array` against.
 * @returns The `Uint8Array` corresponding to the hexadecimal string.
 */
function getBytes(value, length) {
    if (value instanceof Uint8Array) {
        validateBytes(value, length);
        return value;
    }
    if (typeof value === 'string') {
        const bytes = (0, utils_1.hexToBytes)(value);
        validateBytes(bytes, length);
        return bytes;
    }
    throw new Error(`Invalid value: Expected an instance of Uint8Array or hexadecimal string.`);
}
exports.getBytes = getBytes;
/**
 * Get a `Uint8Array` from a hexadecimal string or `Uint8Array`. Validates that
 * the length of the `Uint8Array` matches the specified length.
 *
 * This function is "unsafe," in the sense that it does not validate that the
 * `Uint8Array` is not empty (i.e., all bytes are zero).
 *
 * @param value - The value to convert to a `Uint8Array`.
 * @param length - The length to validate the `Uint8Array` against.
 * @returns The `Uint8Array` corresponding to the hexadecimal string.
 */
function getBytesUnsafe(value, length) {
    if (value instanceof Uint8Array) {
        (0, utils_1.assert)(value.length === length, `Invalid value: Must be a ${length}-byte byte array.`);
        return value;
    }
    if (typeof value === 'string') {
        return getBytesUnsafe((0, utils_1.hexToBytes)(value), length);
    }
    throw new Error(`Invalid value: Expected an instance of Uint8Array or hexadecimal string.`);
}
exports.getBytesUnsafe = getBytesUnsafe;
/**
 * Validate that the specified `Uint8Array` is not empty and has the specified
 * length.
 *
 * @param bytes - The `Uint8Array` to validate.
 * @param length - The length to validate the `Uint8Array` against.
 * @throws An error if the `Uint8Array` is empty or has the wrong length.
 */
function validateBytes(bytes, length) {
    if (!isValidBytesKey(bytes, length)) {
        throw new Error(`Invalid value: Must be a non-zero ${length}-byte byte array.`);
    }
}
const decodeBase58check = (value) => {
    const base58Check = (0, base_1.base58check)(sha256_1.sha256);
    try {
        return base58Check.decode(value);
    }
    catch (_a) {
        throw new Error(`Invalid extended key: Value is not base58-encoded, or the checksum is invalid.`);
    }
};
exports.decodeBase58check = decodeBase58check;
const encodeBase58check = (value) => {
    const base58Check = (0, base_1.base58check)(sha256_1.sha256);
    return base58Check.encode(value);
};
exports.encodeBase58check = encodeBase58check;
/**
 * Get the fingerprint of a compressed public key as number.
 *
 * @param publicKey - The compressed public key to get the fingerprint for.
 * @returns The fingerprint of the public key.
 */
const getFingerprint = (publicKey) => {
    if (!isValidBytesKey(publicKey, 33)) {
        throw new Error(`Invalid public key: The key must be a 33-byte, non-zero byte array.`);
    }
    const bytes = (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(publicKey));
    const view = (0, utils_1.createDataView)(bytes);
    return view.getUint32(0, false);
};
exports.getFingerprint = getFingerprint;
/**
 * Get a secret recovery phrase (or mnemonic phrase) in string form as a
 * `Uint8Array`. The secret recovery phrase is split into words, and each word
 * is converted to a number using the BIP-39 word list. The numbers are then
 * converted to bytes, and the bytes are concatenated into a single
 * `Uint8Array`.
 *
 * @param mnemonicPhrase - The secret recovery phrase to convert.
 * @returns The `Uint8Array` corresponding to the secret recovery phrase.
 */
function mnemonicPhraseToBytes(mnemonicPhrase) {
    const words = mnemonicPhrase.split(' ');
    const indices = words.map((word) => {
        const index = english_1.wordlist.indexOf(word);
        (0, utils_1.assert)(index !== -1, `Invalid mnemonic phrase: Unknown word "${word}".`);
        return index;
    });
    return new Uint8Array(new Uint16Array(indices).buffer);
}
exports.mnemonicPhraseToBytes = mnemonicPhraseToBytes;
/**
 * Validates the curve name.
 *
 * @param curveName - The name of the curve to validate.
 */
function validateCurve(curveName) {
    if (!curveName || typeof curveName !== 'string') {
        throw new Error('Invalid curve: Must specify a curve.');
    }
    if (!Object.keys(curves_1.curves).includes(curveName)) {
        throw new Error(`Invalid curve: Only the following curves are supported: ${Object.keys(curves_1.curves).join(', ')}.`);
    }
}
exports.validateCurve = validateCurve;
/**
 * Get a 4-byte-long `Uint8Array` from a numeric value.
 *
 * @param value - The value to convert to a `Uint8Array`.
 * @returns The `Uint8Array` corresponding to the `bigint` value.
 */
function numberToUint32(value) {
    const bytes = new Uint8Array(4);
    const view = (0, utils_1.createDataView)(bytes);
    view.setUint32(0, value, false);
    return bytes;
}
exports.numberToUint32 = numberToUint32;
//# sourceMappingURL=utils.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree",file:"node_modules\\@metamask\\key-tree\\dist\\utils.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\assert.js", {"superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cassert.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertExhaustive = exports.assertStruct = exports.assert = exports.AssertionError = void 0;
const superstruct_1 = require("superstruct");
/**
 * Type guard for determining whether the given value is an error object with a
 * `message` property, such as an instance of Error.
 *
 * @param error - The object to check.
 * @returns True or false, depending on the result.
 */
function isErrorWithMessage(error) {
    return typeof error === 'object' && error !== null && 'message' in error;
}
/**
 * Check if a value is a constructor, i.e., a function that can be called with
 * the `new` keyword.
 *
 * @param fn - The value to check.
 * @returns `true` if the value is a constructor, or `false` otherwise.
 */
function isConstructable(fn) {
    /* istanbul ignore next */
    return Boolean(typeof fn?.prototype?.constructor?.name === 'string');
}
/**
 * Get the error message from an unknown error object. If the error object has
 * a `message` property, that property is returned. Otherwise, the stringified
 * error object is returned.
 *
 * @param error - The error object to get the message from.
 * @returns The error message.
 */
function getErrorMessage(error) {
    const message = isErrorWithMessage(error) ? error.message : String(error);
    // If the error ends with a period, remove it, as we'll add our own period.
    if (message.endsWith('.')) {
        return message.slice(0, -1);
    }
    return message;
}
/**
 * Initialise an {@link AssertionErrorConstructor} error.
 *
 * @param ErrorWrapper - The error class to use.
 * @param message - The error message.
 * @returns The error object.
 */
// eslint-disable-next-line @typescript-eslint/naming-convention
function getError(ErrorWrapper, message) {
    if (isConstructable(ErrorWrapper)) {
        return new ErrorWrapper({
            message,
        });
    }
    return ErrorWrapper({
        message,
    });
}
/**
 * The default error class that is thrown if an assertion fails.
 */
class AssertionError extends Error {
    constructor(options) {
        super(options.message);
        this.code = 'ERR_ASSERTION';
    }
}
exports.AssertionError = AssertionError;
/**
 * Same as Node.js assert.
 * If the value is falsy, throws an error, does nothing otherwise.
 *
 * @throws {@link AssertionError} If value is falsy.
 * @param value - The test that should be truthy to pass.
 * @param message - Message to be passed to {@link AssertionError} or an
 * {@link Error} instance to throw.
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}. If a custom error class is provided for
 * the `message` argument, this argument is ignored.
 */
function assert(value, message = 'Assertion failed.', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    if (!value) {
        if (message instanceof Error) {
            throw message;
        }
        throw getError(ErrorWrapper, message);
    }
}
exports.assert = assert;
/**
 * Assert a value against a Superstruct struct.
 *
 * @param value - The value to validate.
 * @param struct - The struct to validate against.
 * @param errorPrefix - A prefix to add to the error message. Defaults to
 * "Assertion failed".
 * @param ErrorWrapper - The error class to throw if the assertion fails.
 * Defaults to {@link AssertionError}.
 * @throws If the value is not valid.
 */
function assertStruct(value, struct, errorPrefix = 'Assertion failed', 
// eslint-disable-next-line @typescript-eslint/naming-convention
ErrorWrapper = AssertionError) {
    try {
        (0, superstruct_1.assert)(value, struct);
    }
    catch (error) {
        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessage(error)}.`);
    }
}
exports.assertStruct = assertStruct;
/**
 * Use in the default case of a switch that you want to be fully exhaustive.
 * Using this function forces the compiler to enforce exhaustivity during
 * compile-time.
 *
 * @example
 * ```
 * const number = 1;
 * switch (number) {
 *   case 0:
 *     ...
 *   case 1:
 *     ...
 *   default:
 *     assertExhaustive(snapPrefix);
 * }
 * ```
 * @param _object - The object on which the switch is being operated.
 */
function assertExhaustive(_object) {
    throw new Error('Invalid branch reached. Should be detected during compilation.');
}
exports.assertExhaustive = assertExhaustive;
//# sourceMappingURL=assert.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree>@metamask/utils",file:"node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\assert.js",}],
["F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\base64.js", {"./assert":"F:\\metamask-extension\\node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\assert.js","superstruct":"F:\\metamask-extension\\node_modules\\superstruct\\dist\\index.cjs"}, function(){
  with (this.scopeTerminator) {
  with (this.globalThis) {
    return function() {
      'use strict';
      // source: F:%5Cmetamask-extension%5Cnode_modules%5C@metamask%5Ckey-tree%5Cnode_modules%5C@metamask%5Cutils%5Cdist%5Cbase64.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.base64 = void 0;
const superstruct_1 = require("superstruct");
const assert_1 = require("./assert");
/**
 * Ensure that a provided string-based struct is valid base64.
 *
 * @param struct - The string based struct.
 * @param options - Optional options to specialize base64 validation. See {@link Base64Options} documentation.
 * @returns A superstruct validating base64.
 */
const base64 = (struct, options = {}) => {
    const paddingRequired = options.paddingRequired ?? false;
    const characterSet = options.characterSet ?? 'base64';
    let letters;
    if (characterSet === 'base64') {
        letters = String.raw `[A-Za-z0-9+\/]`;
    }
    else {
        (0, assert_1.assert)(characterSet === 'base64url');
        letters = String.raw `[-_A-Za-z0-9]`;
    }
    let re;
    if (paddingRequired) {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    else {
        re = new RegExp(`^(?:${letters}{4})*(?:${letters}{2,3}|${letters}{3}=|${letters}{2}==)?$`, 'u');
    }
    return (0, superstruct_1.pattern)(struct, re);
};
exports.base64 = base64;
//# sourceMappingURL=base64.js.map
      };
    };
  }
  }
}, {package:"@metamask/key-tree>@metamask/utils",file:"node_modules\\@metamask\\key-tree\\node_modules\\@metamask\\utils\\dist\\base64.js",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwNi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwOS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDEwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxMi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDEzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxNS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxOC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyMS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDIyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyNC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyNy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzMC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDMxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzMy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzNi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzOS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0Mi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0NS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0OC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1MS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDUyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1NC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1Ny5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2MC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDYxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2My5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2Ni5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2OS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDcwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3Mi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDczLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3NS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDc2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3OC50cyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDc5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wODAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA4MS50cyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDgyLnRzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wODMudHMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA4NC50cyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDg1LnRzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wODYudHMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA4Ny50cyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDg4LnRzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy9mYWlsLXR4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9yZmM0NjQ4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvbm9kZV9tb2R1bGVzL3ZhcmludC9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvYmFzZS10YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvaW50LXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvcHJpbnQuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvdmFyaW50LXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvcmZjNDY0OC5qcyIsIm5vZGVfbW9kdWxlcy9AZW5zZG9tYWlucy9jb250ZW50LWhhc2gvbm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL3V0aWwuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvY29uY2F0LmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZnJvbS1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy90by1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL3NyYy9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL3NyYy9wcm9maWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL2Rpc3QvYmFzZS1ldGgta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9kaXN0L2Jhc2UtZXRoLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9ybHAvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL2Rpc3QvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL2Rpc3QvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvQ29tcG9zZWRTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L01lcmdlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvT2JzZXJ2YWJsZVN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvYXNTdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvdGhyb3VnaDIvdGhyb3VnaDIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FkZHJlc3MtYm9vay1jb250cm9sbGVyL2Rpc3QvQWRkcmVzc0Jvb2tDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hZGRyZXNzLWJvb2stY29udHJvbGxlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hbm5vdW5jZW1lbnQtY29udHJvbGxlci9kaXN0L0Fubm91bmNlbWVudENvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2Fubm91bmNlbWVudC1jb250cm9sbGVyL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FwcHJvdmFsLWNvbnRyb2xsZXIvZGlzdC9BcHByb3ZhbENvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FwcHJvdmFsLWNvbnRyb2xsZXIvZGlzdC9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2FwcHJvdmFsLWNvbnRyb2xsZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYXBwcm92YWwtY29udHJvbGxlci9ub2RlX21vZHVsZXMvbmFub2lkL2luZGV4LmJyb3dzZXIuY2pzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9hcHByb3ZhbC1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9uYW5vaWQvdXJsLWFscGhhYmV0L2luZGV4LmNqcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svYnJvd3Nlci1wYXNzd29yZGVyL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1oZC1rZXlyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtaGQta2V5cmluZy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtaGQta2V5cmluZy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fc2hhMi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWhkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWhkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWhkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvaG1hYy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWhkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvcmlwZW1kMTYwLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtaGQta2V5cmluZy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9zaGEyNTYuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1oZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTUxMi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWhkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1oZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9Abm9ibGUvc2VjcDI1NmsxL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWhkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BzY3VyZS9iaXAzMi9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1oZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvaGRrZXkuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1oZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkva2VjY2FrLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtaGQta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1oZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWhkLWtleXJpbmcvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9jcnlwdG9Ccm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtaGQta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1oZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1oZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9jcmVhdGUtaW5mdXJhLW1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9jcmVhdGUtcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9mZXRjaC1jb25maWctZnJvbS1yZXEuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9kaXN0L2xvZ2dpbmctdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9ieXRlcy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY2hlY2tzdW0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jb2xsZWN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvaGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvanNvbi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbG9nZ2luZy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbnVtYmVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9vcGFxdWUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3ZlcnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLWNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXJlZi1yZXdyaXRlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXJlZi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9ibG9jay10cmFja2VyLWluc3BlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9pbmZsaWdodC1jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9sb2dnaW5nLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3Byb3ZpZGVyQXNNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3Byb3ZpZGVyRnJvbUVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9wcm92aWRlckZyb21NaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3JldHJ5T25FbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC91dGlscy9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC93YWxsZXQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stY2FjaGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stcmVmLXJld3JpdGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stcmVmLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXRyYWNrZXItaW5zcGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2ZldGNoLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2luZmxpZ2h0LWNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2xvZ2dpbmctdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvcHJvdmlkZXJBc01pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvcmV0cnlPbkVtcHR5LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3V0aWxzL2NhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3V0aWxzL3RpbWVvdXQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3Qvd2FsbGV0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYmFzZTY0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvYnl0ZXMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9jaGVja3N1bS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2NvZXJjZXJzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvY29sbGVjdGlvbnMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9oZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L2pzb24uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9sb2dnaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL3V0aWxzL2Rpc3QvbWlzYy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L251bWJlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L29wYXF1ZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay91dGlscy9kaXN0L3RpbWUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC92ZXJzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1wcm92aWRlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtcHJvdmlkZXIvZGlzdC9wcm92aWRlci1mcm9tLWVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLXByb3ZpZGVyL2Rpc3QvcHJvdmlkZXItZnJvbS1taWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtcHJvdmlkZXIvZGlzdC9zYWZlLWV2ZW50LWVtaXR0ZXItcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1rZXlyaW5nLWNvbnRyb2xsZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1rZXlyaW5nLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9lbmNyeXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgta2V5cmluZy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL2Rpc3QvZXRoZXJldW1qcy1hYmktdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1rZXlyaW5nLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWtleXJpbmctY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L3BlcnNvbmFsLXNpZ24uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1rZXlyaW5nLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9zaWduLXR5cGVkLWRhdGEuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1rZXlyaW5nLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWtleXJpbmctY29udHJvbGxlci9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWtleXJpbmctY29udHJvbGxlci9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1rZXlyaW5nLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgta2V5cmluZy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWtleXJpbmctY29udHJvbGxlci9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1rZXlyaW5nLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWtleXJpbmctY29udHJvbGxlci9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgta2V5cmluZy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMS1hZGFwdGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMS1saWIvZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMS1saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL2V0aGpzLXV0aWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9oZGtleS9saWIvaGRrZXkuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9lbGxpcHRpYy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2VsbGlwdGljL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL21lc3NhZ2VzLmpzb24iLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L2VuY3J5cHRpb24uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9kaXN0L2V0aGVyZXVtanMtYWJpLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL2Rpc3QvcGVyc29uYWwtc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL2Rpc3Qvc2lnbi10eXBlZC1kYXRhLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvZGlzdC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9fdTY0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaWctdXRpbC9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2lnLXV0aWwvbm9kZV9tb2R1bGVzL2V0aGpzLXV0aWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtc2ltcGxlLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaW1wbGUta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nhay5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpbXBsZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpbXBsZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvX3U2NC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpbXBsZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvY3J5cHRvQnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpbXBsZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvc2hhMy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXNpbXBsZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhlcmV1bS1jcnlwdG9ncmFwaHkvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1zaW1wbGUta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtdHJlem9yLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC10cmV6b3Ita2V5cmluZy9ub2RlX21vZHVsZXMvaGRrZXkvbGliL2hka2V5LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtdHJlem9yLWtleXJpbmcvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9lbGxpcHRpYy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXRyZXpvci1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXRyZXpvci1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLXRyZXpvci1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2VsbGlwdGljL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtdHJlem9yLWtleXJpbmcvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC10cmV6b3Ita2V5cmluZy9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9tZXNzYWdlcy5qc29uIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9nYXMtZmVlLWNvbnRyb2xsZXIvZGlzdC9HYXNGZWVDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9nYXMtZmVlLWNvbnRyb2xsZXIvZGlzdC9kZXRlcm1pbmVHYXNGZWVDYWxjdWxhdGlvbnMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2dhcy1mZWUtY29udHJvbGxlci9kaXN0L2ZldGNoQmxvY2tGZWVIaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9nYXMtZmVlLWNvbnRyb2xsZXIvZGlzdC9mZXRjaEdhc0VzdGltYXRlc1ZpYUV0aEZlZUhpc3RvcnkuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2dhcy1mZWUtY29udHJvbGxlci9kaXN0L2ZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeS9jYWxjdWxhdGVHYXNGZWVFc3RpbWF0ZXNGb3JQcmlvcml0eUxldmVscy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZ2FzLWZlZS1jb250cm9sbGVyL2Rpc3QvZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5L2ZldGNoTGF0ZXN0QmxvY2suanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2dhcy1mZWUtY29udHJvbGxlci9kaXN0L2ZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeS9tZWRpYW5PZi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZ2FzLWZlZS1jb250cm9sbGVyL2Rpc3QvZ2FzLXV0aWwuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2dhcy1mZWUtY29udHJvbGxlci9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9kaXN0L0JJUDQ0Q29pblR5cGVOb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9kaXN0L0JJUDQ0Tm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9TTElQMTBOb2RlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9kaXN0L2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9jdXJ2ZXMvY3VydmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL2Rpc3QvY3VydmVzL2VkMjU1MTkuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL2Rpc3QvY3VydmVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9kaXN0L2N1cnZlcy9zZWNwMjU2azEuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL2Rpc3QvZGVyaXZhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9kZXJpdmVycy9iaXAzMi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9kZXJpdmVycy9iaXAzOS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9kZXJpdmVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2sva2V5LXRyZWUvZGlzdC9kZXJpdmVycy9zaGFyZWQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL2Rpc3QvZGVyaXZlcnMvc2xpcDEwLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9rZXktdHJlZS9kaXN0L2V4dGVuZGVkLWtleXMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL2Rpc3QvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9hc3NlcnQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2tleS10cmVlL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svdXRpbHMvZGlzdC9iYXNlNjQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsQ0FBQztBQUFDLElBQUEsUUFBQSxHQUVIO0VBQ2IsT0FBTztFQUVQLE9BQU8sQ0FBQyxhQUFhLEVBQUU7SUFDckIsTUFBTSxpQkFBaUIsR0FBRyxJQUFBLGlCQUFTLEVBQUMsYUFBYSxDQUFDO0lBQ2xELGlCQUFpQixDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUN4QyxJQUFJO01BQ0YsSUFBSSxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssS0FBSyxFQUFFO1FBQ3pELE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztNQUMzQztNQUNBLFFBQVEsaUJBQWlCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsU0FBUztRQUN0RCxLQUFLLDhCQUE4QjtVQUNqQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRztZQUN2QyxJQUFJLEVBQUU7VUFDUixDQUFDO1VBQ0Q7UUFDRixLQUFLLDBCQUEwQjtVQUM3QixpQkFBaUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRztZQUN2QyxJQUFJLEVBQUU7VUFDUixDQUFDO1VBQ0Q7UUFDRjtNQUNGO0lBQ0YsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFO01BQ1Y7SUFBQTtJQUVGLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztFQUMzQztBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJELElBQUEsT0FBQSxHQUFBLE9BQUE7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBLE1BQU0sT0FBTyxHQUFHLENBQUM7QUFBQyxJQUFBLFFBQUEsR0FFSDtFQUNiLE9BQU87RUFFUCxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO01BQ2hDLE1BQU0sUUFBUSxHQUFHLGtDQUFrQyxDQUFDLEtBQUssQ0FBQztNQUMxRCxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDL0IsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFO01BQ1osT0FBTyxDQUFDLElBQUksQ0FBRSx3QkFBdUIsR0FBRyxDQUFDLEtBQU0sRUFBQyxDQUFDO0lBQ25EO0lBQ0EsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztFQUN2QztBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGtDQUFrQyxDQUFDLEtBQUssRUFBRTtFQUNqRCxNQUFNO0lBQUU7RUFBTyxDQUFDLEdBQUcsS0FBSztFQUN4QixNQUFNLFFBQVEsR0FBRztJQUNmLEdBQUcsS0FBSztJQUNSLGlCQUFpQixFQUFFO01BQ2pCLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSztNQUNsQixlQUFlLEVBQUUsTUFBTSxDQUFDLGVBQWU7TUFDdkMsZUFBZSxFQUFFLEtBQUssQ0FBQztJQUN6QjtFQUNGLENBQUM7RUFDRCxPQUFPLFFBQVEsQ0FBQyxLQUFLO0VBQ3JCLE9BQU8sUUFBUSxDQUFDLGVBQWU7RUFDL0IsT0FBTyxRQUFRLENBQUMsTUFBTSxDQUFDLGVBQWU7RUFFdEMsT0FBTyxRQUFRO0FBQ2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQSxNQUFNLE9BQU8sR0FBRyxDQUFDO0FBQUMsSUFBQSxRQUFBLEdBRUg7RUFDYixPQUFPO0VBRVAsT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQzdCLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLElBQUk7TUFDRixNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtNQUNoQyxNQUFNLFFBQVEsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDO01BQ3BDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUMvQixDQUFDLENBQUMsT0FBTyxHQUFHLEVBQUU7TUFDWixPQUFPLENBQUMsSUFBSSxDQUFFLHVCQUFzQixPQUFRLEdBQUUsR0FBRyxDQUFDLEtBQU0sRUFBQyxDQUFDO0lBQzVEO0lBQ0EsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztFQUN2QztBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLFlBQVksQ0FBQyxLQUFLLEVBQUU7RUFDM0IsTUFBTSxlQUFlLEdBQUcsS0FBSyxDQUFDLGlCQUFpQjs7RUFFL0M7RUFDQSxNQUFNLFFBQVEsR0FBRztJQUNmLEdBQUcsS0FBSztJQUNSLHFCQUFxQixFQUFFO01BQ3JCLGVBQWUsRUFBRSxlQUFlLENBQUM7SUFDbkM7RUFDRixDQUFDOztFQUVEO0VBQ0EsT0FBTyxRQUFRLENBQUMsaUJBQWlCLENBQUMsZUFBZTtFQUVqRCxPQUFPLFFBQVE7QUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBLE1BQU0sT0FBTyxHQUFHLENBQUM7QUFBQyxJQUFBLFFBQUEsR0FFSDtFQUNiLE9BQU87RUFFUCxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO01BQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7TUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQy9CLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRTtNQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUUsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUFDLENBQUM7SUFDNUQ7SUFDQSxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO0VBQ3ZDO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNLFFBQVEsR0FBRztJQUNmLEdBQUcsS0FBSztJQUNSLGtCQUFrQixFQUFFO01BQ2xCLFlBQVksRUFBRSxLQUFLLENBQUMsWUFBWSxJQUFJLEVBQUU7TUFDdEMsYUFBYSxFQUFFLEtBQUssQ0FBQyxhQUFhLElBQUk7SUFDeEM7RUFDRixDQUFDO0VBQ0QsT0FBTyxRQUFRLENBQUMsWUFBWTtFQUM1QixPQUFPLFFBQVEsQ0FBQyxhQUFhO0VBRTdCLE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ0EsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUEsTUFBTSxPQUFPLEdBQUcsQ0FBQztBQUFDLElBQUEsUUFBQSxHQUVIO0VBQ2IsT0FBTztFQUVQLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7TUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztNQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDL0IsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFO01BQ1osT0FBTyxDQUFDLElBQUksQ0FBRSx1QkFBc0IsT0FBUSxHQUFFLEdBQUcsQ0FBQyxLQUFNLEVBQUMsQ0FBQztJQUM1RDtJQUNBLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7RUFDdkM7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLE1BQU0sUUFBUSxHQUFHO0lBQ2YsR0FBRyxLQUFLO0lBQ1IsZ0JBQWdCLEVBQUU7TUFDaEIsV0FBVyxFQUFFLEtBQUssQ0FBQyxXQUFXLElBQUk7SUFDcEM7RUFDRixDQUFDO0VBQ0QsT0FBTyxRQUFRLENBQUMsV0FBVztFQUUzQixPQUFPLFFBQVE7QUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0JBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBLE1BQU0sT0FBTyxHQUFHLENBQUM7QUFBQyxJQUFBLFFBQUEsR0FFSDtFQUNiLE9BQU87RUFFUCxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO01BQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7TUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQy9CLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRTtNQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUUsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUFDLENBQUM7SUFDNUQ7SUFDQSxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO0VBQ3ZDO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNLFFBQVEsR0FBRyxJQUFBLGFBQUssRUFBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUU7SUFDaEMsa0JBQWtCLEVBQUU7TUFDbEIsZUFBZSxFQUFFLEtBQUssQ0FBQyxXQUFXLElBQUksS0FBSyxDQUFDLFlBQVksSUFBSSxLQUFLO01BQ2pFLGNBQWMsRUFBRSxLQUFLLENBQUMsY0FBYztNQUNwQyxjQUFjLEVBQUUsS0FBSyxDQUFDO0lBQ3hCO0VBQ0YsQ0FBQyxDQUFDO0VBQ0YsT0FBTyxRQUFRLENBQUMsV0FBVztFQUMzQixPQUFPLFFBQVEsQ0FBQyxZQUFZO0VBQzVCLE9BQU8sUUFBUSxDQUFDLGNBQWM7RUFDOUIsT0FBTyxRQUFRLENBQUMsY0FBYztFQUU5QixPQUFPLFFBQVE7QUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkNBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBLE1BQU0sT0FBTyxHQUFHLEVBQUU7QUFBQyxJQUFBLFFBQUEsR0FFSjtFQUNiLE9BQU87RUFFUCxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO01BQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7TUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQy9CLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRTtNQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUUsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUFDLENBQUM7SUFDNUQ7SUFDQSxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO0VBQ3ZDO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNLFFBQVEsR0FBRyxJQUFBLGFBQUssRUFBQyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUU7SUFDaEMsb0JBQW9CLEVBQUU7TUFDcEIsZ0JBQWdCLEVBQUUsS0FBSyxDQUFDLGdCQUFnQixJQUFJO0lBQzlDO0VBQ0YsQ0FBQyxDQUFDO0VBQ0YsT0FBTyxRQUFRLENBQUMsZ0JBQWdCO0VBRWhDLE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5QkEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUEsTUFBTSxPQUFPLEdBQUcsRUFBRTtBQUFDLElBQUEsUUFBQSxHQUVKO0VBQ2IsT0FBTztFQUVQLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7TUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztNQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDL0IsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFO01BQ1osT0FBTyxDQUFDLElBQUksQ0FBRSx1QkFBc0IsT0FBUSxHQUFFLEdBQUcsQ0FBQyxLQUFNLEVBQUMsQ0FBQztJQUM1RDtJQUNBLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7RUFDdkM7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQUs7RUFDdEIsT0FBTyxRQUFRLENBQUMsT0FBTztFQUN2QixPQUFPLFFBQVEsQ0FBQyxxQkFBcUI7RUFDckMsT0FBTyxRQUFRO0FBQ2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQSxNQUFNLE9BQU8sR0FBRyxFQUFFO0FBQUMsSUFBQSxRQUFBLEdBRUo7RUFDYixPQUFPO0VBRVAsT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQzdCLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLElBQUk7TUFDRixNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtNQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO01BQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUMvQixDQUFDLENBQUMsT0FBTyxHQUFHLEVBQUU7TUFDWixPQUFPLENBQUMsSUFBSSxDQUFFLHVCQUFzQixPQUFRLEdBQUUsR0FBRyxDQUFDLEtBQU0sRUFBQyxDQUFDO0lBQzVEO0lBQ0EsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztFQUN2QztBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBSztFQUN0QixRQUFRLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBRSxNQUFNLElBQUs7SUFDeEQsSUFBSSxNQUFNLENBQUMsSUFBSSxFQUFFO01BQ2YsTUFBTSxDQUFDLElBQUksR0FBRyxFQUFFO0lBQ2xCO0VBQ0YsQ0FBQyxDQUFDO0VBQ0YsT0FBTyxRQUFRO0FBQ2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQSxNQUFNLE9BQU8sR0FBRyxFQUFFO0FBQUMsSUFBQSxRQUFBLEdBRUo7RUFDYixPQUFPO0VBRVAsT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQzdCLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLElBQUk7TUFDRixNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtNQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO01BQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUMvQixDQUFDLENBQUMsT0FBTyxHQUFHLEVBQUU7TUFDWixPQUFPLENBQUMsSUFBSSxDQUFFLHVCQUFzQixPQUFRLEdBQUUsR0FBRyxDQUFDLEtBQU0sRUFBQyxDQUFDO0lBQzVEO0lBQ0EsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztFQUN2QztBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBSztFQUN0QixNQUFNO0lBQUU7RUFBTyxDQUFDLEdBQUcsUUFBUTtFQUMzQixJQUFJLE1BQU0sSUFBSSxNQUFNLENBQUMsUUFBUSxFQUFFO0lBQzdCLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO01BQ3RDLFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxTQUFTO0lBQzNDO0VBQ0Y7RUFDQSxPQUFPLFFBQVE7QUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBLE1BQU0sT0FBTyxHQUFHLEVBQUU7QUFBQyxJQUFBLFFBQUEsR0FFSjtFQUNiLE9BQU87RUFFUCxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO01BQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7TUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQy9CLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRTtNQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUUsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUFDLENBQUM7SUFDNUQ7SUFDQSxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO0VBQ3ZDO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNLFFBQVEsR0FBRyxLQUFLO0VBQ3RCLFFBQVEsQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLENBQUM7RUFDL0IsUUFBUSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVE7RUFDOUQsT0FBTyxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVE7RUFDL0IsT0FBTyxRQUFRO0FBQ2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsSUFBQSxZQUFBLEdBQUEsT0FBQTtBQVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFLQSxNQUFNLE9BQU8sR0FBRyxFQUFFO0FBQUMsSUFBQSxRQUFBLEdBRUo7RUFDYixPQUFPO0VBRVAsT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQzdCLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLElBQUk7TUFDRixNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtNQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO01BQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUMvQixDQUFDLENBQUMsT0FBTyxHQUFHLEVBQUU7TUFDWixPQUFPLENBQUMsSUFBSSxDQUFFLHVCQUFzQixPQUFRLEdBQUUsR0FBRyxDQUFDLEtBQU0sRUFBQyxDQUFDO0lBQzVEO0lBQ0EsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztFQUN2QztBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBSztFQUN0QixNQUFNO0lBQUU7RUFBc0IsQ0FBQyxHQUFHLFFBQVE7RUFDMUMsSUFBSSxxQkFBcUIsSUFBSSxxQkFBcUIsQ0FBQyxZQUFZLEVBQUU7SUFDL0QsTUFBTTtNQUFFO0lBQWEsQ0FBQyxHQUFHLHFCQUFxQjtJQUM5QyxRQUFRLENBQUMscUJBQXFCLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUUsTUFBTSxJQUFLO01BQ3pFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFO1FBQ2YsT0FBTyxNQUFNO01BQ2YsQ0FBQyxNQUFNLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEtBQUssd0JBQXdCLEVBQUU7UUFDMUQsTUFBTSxDQUFDLE1BQU0sR0FBRyw4QkFBaUIsQ0FBQyxNQUFNO01BQzFDO01BQ0EsT0FBTyxNQUFNO0lBQ2YsQ0FBQyxDQUFDO0VBQ0o7RUFDQSxPQUFPLFFBQVE7QUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLFlBQUEsR0FBQSxPQUFBO0FBUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBLE1BQU0sT0FBTyxHQUFHLEVBQUU7QUFBQyxJQUFBLFFBQUEsR0FFSjtFQUNiLE9BQU87RUFFUCxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO01BQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7TUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQy9CLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRTtNQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUUsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUFDLENBQUM7SUFDNUQ7SUFDQSxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO0VBQ3ZDO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNLFFBQVEsR0FBRyxLQUFLO0VBQ3RCLE1BQU07SUFBRTtFQUFzQixDQUFDLEdBQUcsUUFBUTtFQUMxQyxJQUFJLHFCQUFxQixJQUFJLHFCQUFxQixDQUFDLFlBQVksRUFBRTtJQUMvRCxNQUFNO01BQUU7SUFBYSxDQUFDLEdBQUcsUUFBUSxDQUFDLHFCQUFxQjtJQUV2RCxRQUFRLENBQUMscUJBQXFCLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUUsTUFBTSxJQUFLO01BQ3pFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxFQUFFO1FBQ2YsT0FBTyxNQUFNO01BQ2Y7TUFDQSxJQUNFLE1BQU0sQ0FBQyxHQUFHLEtBQUssc0RBQXNELEVBQ3JFO1FBQ0EsTUFBTSxDQUFDLE1BQU0sR0FBRyw4QkFBaUIsQ0FBQyxTQUFTO1FBQzNDLE9BQU8sTUFBTSxDQUFDLEdBQUc7TUFDbkI7TUFDQSxPQUFPLE1BQU07SUFDZixDQUFDLENBQUM7RUFDSjtFQUNBLE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQ0EsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsWUFBQSxHQUFBLE9BQUE7QUFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBLE1BQU0sT0FBTyxHQUFHLEVBQUU7QUFBQyxJQUFBLFFBQUEsR0FFSjtFQUNiLE9BQU87RUFFUCxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO01BQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7TUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQy9CLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRTtNQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUUsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUFDLENBQUM7SUFDNUQ7SUFDQSxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO0VBQ3ZDO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNLFFBQVEsR0FBRyxLQUFLO0VBQ3RCLE1BQU07SUFBRTtFQUFzQixDQUFDLEdBQUcsUUFBUTtFQUMxQyxJQUFJLHFCQUFxQixJQUFJLHFCQUFxQixDQUFDLFlBQVksRUFBRTtJQUMvRCxNQUFNO01BQUU7SUFBYSxDQUFDLEdBQUcsUUFBUSxDQUFDLHFCQUFxQjtJQUN2RCxRQUFRLENBQUMscUJBQXFCLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUUsTUFBTSxJQUFLO01BQ3pFLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxLQUFLLDhCQUFpQixDQUFDLE1BQU0sRUFBRTtRQUMvQyxPQUFPLE1BQU07TUFDZjtNQUNBLElBQUksTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLEVBQUU7UUFDbEQsTUFBTSxDQUFDLE1BQU0sR0FBRyw4QkFBaUIsQ0FBQyxTQUFTO1FBQzNDLE9BQU8sTUFBTSxDQUFDLEdBQUc7TUFDbkI7TUFDQSxPQUFPLE1BQU07SUFDZixDQUFDLENBQUM7RUFDSjtFQUNBLE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2Q0EsSUFBQSxVQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEseUJBQUEsT0FBQSxDQUFBLDBEQUFBLENBQUEsQ0FBQTs7Ozs7OztBQUtBLE1BQU0sVUFBVSxFQUFFLENBQUE7QUFBQyxJQUFBLFdBRUo7RUFDYixPQUFPO0VBRVAsT0FBTyx3QkFBd0I7SUFDN0IsTUFBTSxnQkFBZ0IsQ0FBQSxDQUFBLEVBQUEsT0FBQSxVQUFTLEVBQUMscUJBQXFCLENBQUMsQ0FBQTtJQUN0RCxhQUFhLEtBQUssUUFBUSxHQUFHLE9BQU8sQ0FBQTtJQUNwQyxJQUFJO01BQ0YsTUFBTSxRQUFRLGFBQWEsS0FBSyxDQUFBO01BQ2hDLE1BQU0sV0FBVyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUE7TUFDdEMsYUFBYSxLQUFLLEdBQUcsUUFBUSxDQUFBO0tBQzlCLENBQUMsWUFBWTtNQUNaLE9BQU8sS0FBSyxDQUFFLENBQUEsb0JBQUEsRUFBc0IsT0FBUSxDQUFBLEVBQUUsR0FBRyxNQUFPLENBQUEsQ0FBQyxDQUFDLENBQUE7S0FDNUQ7SUFDQSxPQUFPLE9BQU8sUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFBO0dBQ3ZDO0NBQ0QsQ0FBQTtBQUFBLE9BQUEsUUFBQSxHQUFBLFFBQUEsQ0FBQTtBQUVELCtCQUErQjtFQUM3QixNQUFNLFdBQVcsS0FBSyxDQUFBO0VBQ3RCLE1BQU07O0dBQXlCLEdBQUcsUUFBUSxDQUFBO0VBQzFDLElBQUkscUJBQXFCLElBQUkscUJBQXFCLGFBQWEsRUFBRTtJQUMvRCxNQUFNOztLQUFnQixHQUFHLFFBQVEsc0JBQXNCLENBQUE7SUFDdkQsUUFBUSxzQkFBc0IsYUFBYSxHQUFHLFlBQVksSUFBSSxDQUFFLFVBQVc7O01BRXpFLElBQUksQ0FBQyxNQUFNLFFBQVEsSUFBSSxNQUFNLFFBQVEsT0FBTyxLQUFLLENBQUMsRUFBRTtRQUNsRCxNQUFNLFdBQVcsQ0FBQSxDQUFBLEVBQUEsc0JBQUEsbUJBQWtCLEVBQUMsTUFBTSxDQUFDLENBQUE7UUFDM0MsTUFBTSxRQUFRLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQTtRQUMzQixPQUFPLE1BQU0sQ0FBQTtPQUNmOztNQUVBLE1BQU0sYUFBYSxDQUFBLENBQUEsRUFBQSxzQkFBQSw0QkFBMkIsRUFBQyxNQUFNLFFBQVEsQ0FBQTs7YUFFcEQsQ0FBRSxTQUFVO1FBQ2pCLE9BQU8sQ0FBQyxLQUFLLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLE9BQU8sR0FBRyxDQUFDLENBQUE7T0FDakQsQ0FBQyxDQUFBO01BQ0osTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFBO01BQzNCLE9BQU8sTUFBTSxDQUFBO0tBQ2QsQ0FBQyxDQUFBO0dBQ0o7RUFDQSxPQUFPLFFBQVEsQ0FBQTtDQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0NBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLFlBQUEsR0FBQSxPQUFBO0FBUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBLE1BQU0sT0FBTyxHQUFHLEVBQUU7QUFBQyxJQUFBLFFBQUEsR0FFSjtFQUNiLE9BQU87RUFFUCxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO01BQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7TUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQy9CLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRTtNQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUUsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUFDLENBQUM7SUFDNUQ7SUFDQSxPQUFPLE9BQU8sQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDO0VBQ3ZDO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNLFFBQVEsR0FBRyxLQUFLO0VBQ3RCLE1BQU07SUFBRTtFQUFzQixDQUFDLEdBQUcsUUFBUTtFQUMxQyxJQUFJLHFCQUFxQixJQUFJLHFCQUFxQixDQUFDLFlBQVksRUFBRTtJQUMvRCxNQUFNO01BQUU7SUFBYSxDQUFDLEdBQUcsUUFBUSxDQUFDLHFCQUFxQjtJQUV2RCxRQUFRLENBQUMscUJBQXFCLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQzVELENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxNQUFNLEtBQUs7TUFDckIsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLDhCQUFpQixDQUFDLFNBQVMsRUFBRTtRQUNqRCxPQUFPLE1BQU07TUFDZjtNQUVBLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FDeEIsTUFBTSxDQUFFLEVBQUUsSUFBSyxFQUFFLENBQUMsTUFBTSxLQUFLLDhCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUN6RCxNQUFNLENBQUUsRUFBRSxJQUFLLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQ3pELE1BQU0sQ0FDSixFQUFFLElBQUssRUFBRSxDQUFDLGlCQUFpQixDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsaUJBQWlCLENBQUMsSUFDakUsQ0FBQztNQUNILE1BQU0scUJBQXFCLEdBQUcsZUFBZSxDQUFDLFlBQVksQ0FBQztNQUUzRCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQ3RCLE1BQU0sQ0FBRSxFQUFFLElBQUssRUFBRSxDQUFDLE1BQU0sS0FBSyw4QkFBaUIsQ0FBQyxTQUFTLENBQUMsQ0FDekQsTUFBTSxDQUFFLEVBQUUsSUFBSyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUN6RCxNQUFNLENBQ0osRUFBRSxJQUFLLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDLGlCQUFpQixDQUFDLElBQ2pFLENBQUM7TUFDSCxNQUFNLHNCQUFzQixHQUFHLHdCQUF3QixDQUNyRCxVQUFVLEVBQ1YscUJBQ0YsQ0FBQztNQUVELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQ3ZCLHNCQUFzQixFQUN0QixxQkFDRixDQUFDO01BRUQsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEdBQUcsUUFBUSxHQUFHLENBQUMsRUFBRTtRQUN0RCxNQUFNLENBQUMsTUFBTSxHQUFHLDhCQUFpQixDQUFDLE1BQU07UUFDeEMsTUFBTSxDQUFDLEdBQUcsR0FBRztVQUNYLE9BQU8sRUFBRSxnQkFBZ0I7VUFDekIsSUFBSSxFQUFFO1FBQ1IsQ0FBQztNQUNIO01BQ0EsT0FBTyxNQUFNO0lBQ2YsQ0FDRixDQUFDO0VBQ0g7RUFDQSxPQUFPLFFBQVE7QUFDakI7QUFFQSxTQUFTLHdCQUF3QixDQUFDLE1BQU0sRUFBRSxVQUFVLEVBQUU7RUFDcEQsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBRSxNQUFNLElBQUs7SUFDcEMsTUFBTTtNQUFFO0lBQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxRQUFRO0lBQ2pDLE9BQU8sUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDNUIsQ0FBQyxDQUFDO0VBRUYsSUFBSSxPQUFPLEdBQUcsVUFBVTtFQUN4QixPQUFPLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDL0IsT0FBTyxJQUFJLENBQUM7RUFDZDtFQUVBLE9BQU8sT0FBTztBQUNoQjtBQUVBLFNBQVMsZUFBZSxDQUFDLE1BQU0sRUFBRTtFQUMvQixNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFFLE1BQU0sSUFBSztJQUNwQyxNQUFNO01BQUU7SUFBTSxDQUFDLEdBQUcsTUFBTSxDQUFDLFFBQVE7SUFDakMsT0FBTyxRQUFRLENBQUMsS0FBSyxJQUFJLEtBQUssRUFBRSxFQUFFLENBQUM7RUFDckMsQ0FBQyxDQUFDO0VBQ0YsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQztFQUNqRCxPQUFPLFlBQVk7QUFDckI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNUZBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQSxNQUFNLE9BQU8sR0FBRyxFQUFFO0FBQUMsSUFBQSxRQUFBLEdBRUo7RUFDYixPQUFPO0VBRVAsT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQzdCLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLElBQUk7TUFDRixNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtNQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO01BQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUMvQixDQUFDLENBQUMsT0FBTyxHQUFHLEVBQUU7TUFDWixPQUFPLENBQUMsSUFBSSxDQUFFLHVCQUFzQixPQUFRLEdBQUUsR0FBRyxDQUFDLEtBQU0sRUFBQyxDQUFDO0lBQzVEO0lBQ0EsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQztFQUN2QztBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBSztFQUN0QixJQUFJLFVBQVUsSUFBSSxRQUFRLElBQUksRUFBRSxlQUFlLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFO0lBQ3JFLFFBQVEsQ0FBQyxRQUFRLENBQUMsYUFBYSxHQUFHO01BQ2hDLE9BQU8sRUFBRSxRQUFRO01BQ2pCLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ2pCLENBQUM7RUFDSDtFQUNBLE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ0EsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUEsTUFBTSxPQUFPLEdBQUcsRUFBRTtBQUFDLElBQUEsUUFBQSxHQUVKO0VBQ2IsT0FBTztFQUVQLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7TUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztNQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDL0IsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFO01BQ1osT0FBTyxDQUFDLElBQUksQ0FBRSx1QkFBc0IsT0FBUSxHQUFFLEdBQUcsQ0FBQyxLQUFNLEVBQUMsQ0FBQztJQUM1RDtJQUNBLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7RUFDdkM7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQUs7RUFDdEIsT0FBTyxRQUFRLENBQUMsbUJBQW1CO0VBQ25DLE9BQU8sUUFBUSxDQUFDLFlBQVk7RUFDNUIsT0FBTyxRQUFRO0FBQ2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsSUFBQSxZQUFBLEdBQUEsT0FBQTtBQVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0EsTUFBTSxPQUFPLEdBQUcsRUFBRTtBQUFDLElBQUEsUUFBQSxHQUVKO0VBQ2IsT0FBTztFQUVQLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7TUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztNQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDL0IsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFO01BQ1osT0FBTyxDQUFDLElBQUksQ0FBRSx1QkFBc0IsT0FBUSxHQUFFLEdBQUcsQ0FBQyxLQUFNLEVBQUMsQ0FBQztJQUM1RDtJQUNBLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7RUFDdkM7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQUs7RUFDdEIsTUFBTTtJQUFFO0VBQXNCLENBQUMsR0FBRyxRQUFRO0VBQzFDLElBQUkscUJBQXFCLElBQUkscUJBQXFCLENBQUMsWUFBWSxFQUFFO0lBQy9ELE1BQU07TUFBRTtJQUFhLENBQUMsR0FBRyxRQUFRLENBQUMscUJBQXFCO0lBRXZELFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBRSxNQUFNLElBQUs7TUFDekUsSUFDRSxNQUFNLENBQUMsTUFBTSxLQUFLLDhCQUFpQixDQUFDLFNBQVMsSUFDN0MsTUFBTSxDQUFDLGFBQWEsRUFDcEI7UUFDQSxPQUFPLE1BQU07TUFDZjtNQUNBLE1BQU0sQ0FBQyxhQUFhLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO01BQzNDLE9BQU8sTUFBTTtJQUNmLENBQUMsQ0FBQztFQUNKO0VBQ0EsT0FBTyxRQUFRO0FBQ2pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hDQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsSUFBQSxZQUFBLEdBQUEsT0FBQTtBQVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0EsTUFBTSxPQUFPLEdBQUcsRUFBRTtBQUFDLElBQUEsUUFBQSxHQUVKO0VBQ2IsT0FBTztFQUVQLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7TUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztNQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDL0IsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFO01BQ1osT0FBTyxDQUFDLElBQUksQ0FBRSx1QkFBc0IsT0FBUSxHQUFFLEdBQUcsQ0FBQyxLQUFNLEVBQUMsQ0FBQztJQUM1RDtJQUNBLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7RUFDdkM7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQUs7RUFFdEIsTUFBTTtJQUFFO0VBQXNCLENBQUMsR0FBRyxRQUFRO0VBQzFDLElBQUkscUJBQXFCLElBQUkscUJBQXFCLENBQUMsWUFBWSxFQUFFO0lBQy9ELE1BQU07TUFBRTtJQUFhLENBQUMsR0FBRyxRQUFRLENBQUMscUJBQXFCO0lBRXZELElBQUksWUFBWSxDQUFDLE1BQU0sSUFBSSxFQUFFLEVBQUU7TUFDN0IsT0FBTyxRQUFRO0lBQ2pCO0lBRUEsTUFBTSxhQUFhLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzVDLElBQUksU0FBUyxHQUFHLElBQUk7SUFDcEIsT0FBTyxhQUFhLENBQUMsTUFBTSxHQUFHLEVBQUUsSUFBSSxTQUFTLEVBQUU7TUFDN0MsTUFBTSxPQUFPLEdBQUcsYUFBYSxDQUFDLFNBQVMsQ0FBRSxNQUFNLElBQUs7UUFDbEQsT0FDRSxNQUFNLENBQUMsTUFBTSxLQUFLLDhCQUFpQixDQUFDLE1BQU0sSUFDMUMsTUFBTSxDQUFDLE1BQU0sS0FBSyw4QkFBaUIsQ0FBQyxRQUFRLElBQzVDLE1BQU0sQ0FBQyxNQUFNLEtBQUssOEJBQWlCLENBQUMsU0FBUyxJQUM3QyxNQUFNLENBQUMsTUFBTSxLQUFLLDhCQUFpQixDQUFDLE9BQU87TUFFL0MsQ0FBQyxDQUFDO01BQ0YsSUFBSSxPQUFPLEdBQUcsQ0FBQyxFQUFFO1FBQ2YsU0FBUyxHQUFHLEtBQUs7TUFDbkIsQ0FBQyxNQUFNO1FBQ0wsYUFBYSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO01BQ2xDO0lBQ0Y7SUFFQSxRQUFRLENBQUMscUJBQXFCLENBQUMsWUFBWSxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztFQUN2RTtFQUNBLE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNyREEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsWUFBQSxHQUFBLE9BQUE7QUFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBS0EsTUFBTSxPQUFPLEdBQUcsRUFBRTtBQUFDLElBQUEsUUFBQSxHQUVKO0VBQ2IsT0FBTztFQUVQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBSztFQUN0QixJQUFJLENBQUMsUUFBUSxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE9BQU8sUUFBUTtFQUNqQjtFQUNBLE1BQU07SUFBRTtFQUFhLENBQUMsR0FBRyxRQUFRLENBQUMscUJBQXFCO0VBQ3ZELFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FDNUQsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLO0lBQ2IsSUFDRSxNQUFNLENBQUMsTUFBTSxLQUFLLDhCQUFpQixDQUFDLFVBQVUsSUFDOUMsTUFBTSxDQUFDLFFBQVEsSUFDZixNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksRUFDcEI7TUFDQSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUMzRDtJQUNBLE9BQU8sTUFBTTtFQUNmLENBQ0YsQ0FBQztFQUNELE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0EsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsS0FBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLFlBQUEsR0FBQSxPQUFBO0FBUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBLE1BQU0sT0FBTyxHQUFHLEVBQUU7QUFBQyxJQUFBLFFBQUEsR0FFSjtFQUNiLE9BQU87RUFFUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUM3QixPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQUs7RUFFdEIsSUFBSSxRQUFRLENBQUMscUJBQXFCLEVBQUU7SUFDbEMsSUFBSSxRQUFRLENBQUMscUJBQXFCLENBQUMsWUFBWSxFQUFFO01BQy9DLE1BQU07UUFBRTtNQUFhLENBQUMsR0FBRyxRQUFRLENBQUMscUJBQXFCO01BQ3ZELFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FDM0QsTUFBTSxJQUFLO1FBQ1YsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLDhCQUFpQixDQUFDLFVBQVUsRUFBRTtVQUNsRCxPQUFPLE1BQU07UUFDZjtRQUNBLE1BQU0sQ0FBQyxRQUFRLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUNwRCxPQUFPLE1BQU07TUFDZixDQUNGLENBQUM7SUFDSDtFQUNGO0VBRUEsT0FBTyxRQUFRO0FBQ2pCO0FBRUEsU0FBUyxpQkFBaUIsQ0FBQyxRQUFRLEVBQUU7RUFDbkM7RUFDQSxNQUFNLFNBQVMsR0FBRztJQUNoQixJQUFJLEVBQUcsSUFBSSxJQUFLLElBQUEsa0JBQVksRUFBQyxJQUFJLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNoRCxFQUFFLEVBQUUsQ0FBQSxLQUFNLElBQUEsa0JBQVksRUFBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDakQsS0FBSyxFQUFHLEtBQUssSUFBSyxJQUFBLGtCQUFZLEVBQUMsS0FBSyxDQUFDO0lBQ3JDLEtBQUssRUFBRyxLQUFLLElBQUssSUFBQSxrQkFBWSxFQUFDLEtBQUssQ0FBQztJQUNyQyxJQUFJLEVBQUcsSUFBSSxJQUFLLElBQUEsa0JBQVksRUFBQyxJQUFJLENBQUM7SUFDbEMsR0FBRyxFQUFHLEdBQUcsSUFBSyxJQUFBLGtCQUFZLEVBQUMsR0FBRyxDQUFDO0lBQy9CLFFBQVEsRUFBRyxRQUFRLElBQUssSUFBQSxrQkFBWSxFQUFDLFFBQVE7RUFDL0MsQ0FBQzs7RUFFRDtFQUNBLE1BQU0sa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO0VBQzdCLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFFLEdBQUcsSUFBSztJQUN0QyxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsRUFBRTtNQUNqQixrQkFBa0IsQ0FBQyxHQUFHLENBQUMsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3pEO0VBQ0YsQ0FBQyxDQUFDO0VBRUYsT0FBTyxrQkFBa0I7QUFDM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUEsTUFBTSxPQUFPLEdBQUcsRUFBRTtBQUFDLElBQUEsUUFBQSxHQUVKO0VBQ2IsT0FBTztFQUNQLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7TUFDaEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQzVDLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRTtNQUNaLE9BQU8sQ0FBQyxJQUFJLENBQUUsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUFDLENBQUM7TUFDMUQsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQztJQUM1QjtJQUNBLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7RUFDdkM7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLElBQUksQ0FBQyxLQUFLLENBQUMscUJBQXFCLEVBQUU7SUFDNUQsT0FBTyxLQUFLO0VBQ2Q7RUFFQSxJQUFJLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLGVBQWUsRUFBRTtJQUM1QyxPQUFPLEtBQUs7RUFDZDtFQUVBLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FDbEQsS0FBSyxDQUFDLGlCQUFpQixDQUFDLGVBQzFCLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxVQUFVLEVBQUUsT0FBTyxLQUFLO0lBQ2hDLFVBQVUsQ0FBQyxPQUFPLENBQUMsR0FBRztNQUNwQixJQUFJLEVBQUUsS0FBSyxDQUFDLGlCQUFpQixDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUM7TUFDdEQ7SUFDRixDQUFDO0lBQ0QsT0FBTyxVQUFVO0VBQ25CLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztFQUNOLE9BQU8sS0FBSyxDQUFDLGlCQUFpQixDQUFDLGVBQWU7RUFDOUMsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekNBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLFlBQUEsR0FBQSxPQUFBO0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlBLE1BQU0sT0FBTyxHQUFHLEVBQUU7QUFBQyxJQUFBLFFBQUEsR0FFSjtFQUNiLE9BQU87RUFFUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUM3QixPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQUs7RUFFdEIsSUFBSSxRQUFRLENBQUMscUJBQXFCLEVBQUU7SUFDbEMsSUFBSSxRQUFRLENBQUMscUJBQXFCLENBQUMsWUFBWSxFQUFFO01BQy9DLE1BQU07UUFBRTtNQUFhLENBQUMsR0FBRyxRQUFRLENBQUMscUJBQXFCO01BQ3ZELFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FDOUQsTUFBTSxJQUFLLE1BQU0sQ0FBQyxNQUFNLEtBQUssOEJBQWlCLENBQUMsUUFDbEQsQ0FBQztJQUNIO0VBQ0Y7RUFFQSxPQUFPLFFBQVE7QUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0JBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0EsTUFBTSxPQUFPLEdBQUcsRUFBRTtBQUFDLElBQUEsUUFBQSxHQUVKO0VBQ2IsT0FBTztFQUVQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBSztFQUV0QixJQUFJLFFBQVEsQ0FBQyxxQkFBcUIsRUFBRTtJQUNsQyxJQUNFLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLElBQ3JDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEVBQ3pDO01BQ0EsTUFBTTtRQUFFLFVBQVU7UUFBRTtNQUFPLENBQUMsR0FBRyxRQUFRLENBQUMscUJBQXFCO01BQzdELFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDO01BQ2pELE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsT0FBTyxDQUFFLFFBQVEsSUFBSztRQUM1QyxRQUFRLENBQUMscUJBQXFCLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxHQUFHO1VBQ3ZELE9BQU8sRUFBRTtRQUNYLENBQUM7TUFDSCxDQUFDLENBQUM7TUFDRixRQUFRLENBQUMscUJBQXFCLENBQUMsTUFBTSxHQUFHLEVBQUU7SUFDNUM7RUFDRjtFQUVBLE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQ0EsSUFBQSxZQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsT0FBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUFvQyxTQUFBLHVCQUFBLEdBQUEsV0FBQSxHQUFBLElBQUEsR0FBQSxDQUFBLFVBQUEsR0FBQSxHQUFBLEtBQUEsT0FBQSxFQUFBLEdBQUE7QUFGcEM7O0FBSUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQSxNQUFNLE9BQU8sR0FBRyxJQUFJO0FBQ3BCLE1BQU0sT0FBTyxHQUFHLEVBQUUsR0FBRyxPQUFPO0FBQzVCLE1BQU0sS0FBSyxHQUFHLEVBQUUsR0FBRyxPQUFPO0FBQzFCLE1BQU0saUJBQWlCLEdBQUcsRUFBRSxHQUFHLEtBQUs7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSxJQUFBLFFBQUEsR0FNZTtFQUNiLE9BQU87RUFFUCxPQUFPLEVBQUUsSUFBQSxlQUFXLEVBQ2xCLE9BQU8sRUFDUCx1Q0FBdUMsRUFDdEMsTUFBTSxJQUFLO0lBQ1YsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLE1BQU0sS0FBSyw4QkFBaUIsQ0FBQyxRQUFRO0lBQy9ELE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxhQUFhO0lBQ3hDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QixPQUFPLFVBQVUsSUFBSSxHQUFHLEdBQUcsV0FBVyxHQUFHLGlCQUFpQjtFQUM1RCxDQUNGO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QkQsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQSxNQUFNLE9BQU8sR0FBRyxFQUFFO0FBQUMsSUFBQSxRQUFBLEdBRUo7RUFDYixPQUFPO0VBRVAsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDN0IsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNLFFBQVEsR0FBRyxLQUFLO0VBQ3RCLElBQUksS0FBSyxDQUFDLHFCQUFxQixFQUFFO0lBQy9CLE1BQU07TUFBRTtJQUFzQixDQUFDLEdBQUcsUUFBUSxDQUFDLHFCQUFxQjtJQUNoRSxJQUFJLHFCQUFxQixFQUFFO01BQ3pCLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLEtBQUs7UUFDNUM7UUFDQSxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUU7VUFDL0QsT0FBTyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPO1FBQzdDO01BQ0YsQ0FBQyxDQUFDO01BQ0YsUUFBUSxDQUFDLHFCQUFxQixDQUFDLHFCQUFxQixHQUNsRCxxQkFBcUI7SUFDekI7RUFDRjtFQUNBLElBQUksS0FBSyxDQUFDLGlCQUFpQixFQUFFO0lBQzNCLElBQ0UsUUFBUSxDQUFDLGlCQUFpQixDQUFDLE9BQU87SUFDbEM7SUFDQSxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUMsRUFDMUQ7TUFDQSxPQUFPLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPO0lBQzNDO0lBRUEsSUFDRSxRQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxJQUNuQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLE9BQU87SUFDM0M7SUFDQSxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQ25FO01BQ0EsT0FBTyxRQUFRLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLE9BQU87SUFDcEQ7RUFDRjtFQUVBLE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxREEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQURBOztBQUdBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBSEEsSUFBQSxRQUFBLEdBSWU7RUFDYixPQUFPO0VBRVAsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDN0IsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNO0lBQUUsaUJBQWlCO0lBQUU7RUFBc0IsQ0FBQyxHQUFHLEtBQUs7RUFFMUQsSUFBSSxpQkFBaUIsSUFBSSxxQkFBcUIsRUFBRTtJQUM5QyxNQUFNO01BQUU7SUFBTSxDQUFDLEdBQUcsaUJBQWlCO0lBQ25DLHFCQUFxQixDQUFDLG1CQUFtQixHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUM7RUFDNUQ7RUFFQSxPQUFPLEtBQUs7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQkEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUMxQyxPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLE1BQU07SUFBRTtFQUFzQixDQUFDLEdBQUcsS0FBSztFQUV2QyxJQUFJLHFCQUFxQixFQUFFO0lBQ3pCLE1BQU07TUFBRTtJQUFPLENBQUMsR0FBRyxxQkFBcUIsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDO0lBQzNEO0lBQ0E7SUFDQSxxQkFBcUIsQ0FBQyxvQkFBb0IsR0FBRyxNQUFNO0VBQ3JEO0VBRUEsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEJBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUEsTUFBTSxPQUFPLEdBQUcsRUFBRTtBQUFDLElBQUEsUUFBQSxHQUVKO0VBQ2IsT0FBTztFQUVQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBSztFQUN0QjtFQUNBLElBQUksS0FBSyxDQUFDLGdCQUFnQixFQUFFO0lBQzFCLE9BQU8sUUFBUSxDQUFDLGdCQUFnQjtFQUNsQztFQUNBLE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQkEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBSEEsSUFBQSxRQUFBLEdBSWU7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQzFDLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTTtJQUFFO0VBQXNCLENBQUMsR0FBRyxLQUFLO0VBRXZDLElBQUkscUJBQXFCLEVBQUU7SUFDekIsTUFBTSxZQUFZLEdBQUcscUJBQXFCLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQztJQUU3RCxJQUNFLENBQUMsWUFBWSxDQUFDLFdBQVcsSUFDekIsT0FBTyxxQkFBcUIsQ0FBQyxtQkFBbUIsS0FBSyxXQUFXLEVBQ2hFO01BQ0E7TUFDQSxxQkFBcUIsQ0FBQyxtQkFBbUIsR0FBRyxJQUFJO01BQ2hELFlBQVksQ0FBQyxXQUFXLEdBQUcsSUFBSTtJQUNqQztFQUNGO0VBRUEsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBSUEsTUFBTSxPQUFPLEdBQUcsRUFBRTtBQUFDLElBQUEsUUFBQSxHQUVKO0VBQ2IsT0FBTztFQUVQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUM7SUFDdkQsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixJQUNFLEtBQUssQ0FBQyxxQkFBcUIsSUFDM0IsS0FBSyxDQUFDLHFCQUFxQixDQUFDLFNBQVMsS0FBSyxTQUFTLEVBQ25EO0lBQ0EsT0FBTyxLQUFLLENBQUMscUJBQXFCLENBQUMsU0FBUztFQUM5QztFQUNBLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBRkEsSUFBQSxRQUFBLEdBR2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQzFDLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTTtJQUFFO0VBQXNCLENBQUMsR0FBRyxLQUFLO0VBRXZDLElBQUkscUJBQXFCLEVBQUU7SUFDekIsTUFBTSxZQUFZLEdBQUcscUJBQXFCLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQztJQUU3RCxJQUFJLE9BQU8sWUFBWSxDQUFDLFdBQVcsS0FBSyxXQUFXLEVBQUU7TUFDbkQsT0FBTyxZQUFZLENBQUMsV0FBVztJQUNqQztFQUNGO0VBRUEsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOUJBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLGdCQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSxJQUFBLFFBQUEsR0FLZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxhQUFhLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDMUMsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixJQUFJLEtBQUssQ0FBQyxxQkFBcUIsRUFBRTtJQUMvQixNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMscUJBQXFCLENBQUMsV0FBVztJQUVsRCxNQUFNLFFBQVEsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLE1BQU0sY0FBYyxHQUFHLENBQUMsQ0FBQzs7SUFFekI7SUFDQSxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBRSxDQUFDLElBQUs7TUFDL0IsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO0lBQ3pCLENBQUMsQ0FBQzs7SUFFRjtJQUNBLEtBQUssTUFBTSxFQUFFLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUU7TUFDbEM7TUFDQSxjQUFjLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO01BQ3ZCLEtBQUssTUFBTSxPQUFPLElBQUksRUFBRSxFQUFFO1FBQ3hCLElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sS0FBSyxFQUFFLEVBQUU7VUFDOUIsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssR0FBRyxLQUFLO1VBQ3pCLElBQUksSUFBQSxpQ0FBZ0IsRUFBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdEMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssR0FBRyxJQUFJO1VBQzFCO1VBQ0EsY0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUM7UUFDM0M7TUFDRjtJQUNGO0lBRUEsS0FBSyxDQUFDLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxjQUFjO0VBQzFEO0VBRUEsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcERBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFGQSxJQUFBLFFBQUEsR0FHZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxhQUFhLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDMUMsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNO0lBQUUsZ0JBQWdCLEVBQUUscUJBQXFCLEdBQUcsQ0FBQztFQUFFLENBQUMsR0FBRyxLQUFLO0VBQzlELE1BQU07SUFBRSxPQUFPLEdBQUcsQ0FBQztFQUFFLENBQUMsR0FBRyxxQkFBcUI7RUFFOUMsSUFBSSxPQUFPLENBQUMsaUJBQWlCLEVBQUU7SUFDN0IsT0FBTyxLQUFLO0VBQ2Q7RUFFQSxPQUFPO0lBQ0wsR0FBRyxLQUFLO0lBQ1IsZ0JBQWdCLEVBQUU7TUFDaEIsR0FBRyxxQkFBcUI7TUFDeEIsT0FBTyxFQUFFO1FBQ1AsR0FBRyxPQUFPO1FBQ1YsaUJBQWlCLEVBQUU7TUFDckI7SUFDRjtFQUNGLENBQUM7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ0EsSUFBQSxVQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsa0JBQUEsT0FBQSxDQUFBLHlDQUFBLENBQUEsQ0FBQTtBQUVBLE1BQU0sVUFBVSxFQUFFLENBQUE7QUFFbEIsTUFBTSwwQkFBMEIsNENBQTRDLENBQUE7QUFDNUUsTUFBTSxzQkFBc0IsS0FBSyxDQUFBO0FBQ2pDLE1BQU0sbUJBQW1CLEtBQUssQ0FBQTtBQUU5QixrQkFBa0IsUUFBUSxFQUFFLEVBQUU7RUFDNUIsT0FDRSxLQUFLLElBQ0wsT0FBTyxLQUFLLEtBQUssUUFBUSxJQUN6QixLQUFLLE9BQU8sS0FBSyxtQkFBbUIsSUFDcEMsQ0FBQSxDQUFBLEVBQUEsZUFBQSxxQkFBb0IsRUFBQyxLQUFLLFFBQVEsQ0FBQyxLQUFLLHVCQUF1QixDQUFBO0NBRW5FOzs7Ozs7Ozs7QUFFQSxJQUFBLFdBT2U7RUFDYixPQUFPO0VBQ1AsYUFBYSx3QkFBd0I7SUFDbkMsTUFBTSxnQkFBZ0IsQ0FBQSxDQUFBLEVBQUEsT0FBQSxVQUFTLEVBQUMscUJBQXFCLENBQUMsQ0FBQTtJQUN0RCxhQUFhLEtBQUssUUFBUSxHQUFHLE9BQU8sQ0FBQTtJQUNwQyxNQUFNLFFBQVEsYUFBYSxLQUFLLENBQUE7SUFDaEMsYUFBYSxLQUFLLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQzFDLE9BQU8sYUFBYSxDQUFBO0dBQ3RCO0NBQ0QsQ0FBQTtBQUFBLE9BQUEsUUFBQSxHQUFBLFFBQUEsQ0FBQTtBQUVELCtCQUErQjtFQUM3QixNQUFNOztHQUF5QixHQUFHLEtBQUssQ0FBQTtFQUV2QyxJQUFJLHFCQUFxQixFQUFFO0lBQ3pCLE1BQU0sU0FBUyxxQkFBcUIsT0FBTyxJQUFJLEVBQUUsQ0FBQTtJQUNqRCxJQUFJLEtBQUssUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO01BQ3pCLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFO1FBQzFCLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO1VBQ25CLEtBQUssT0FBTyxHQUFHLGdCQUFnQixDQUFBO1NBQ2pDO09BQ0Y7S0FDRjtJQUVBLE1BQU0sZ0JBQWdCLHFCQUFxQixjQUFjLElBQUksRUFBRSxDQUFBO0lBQy9ELElBQUksYUFBYSxJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRTtNQUN0RCxLQUFLLE1BQU0sT0FBTyxJQUFJLE1BQU0sS0FBSyxDQUFDLGFBQWEsQ0FBQyxFQUFFO1FBQ2hELE1BQU0sZ0JBQWdCLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQTtRQUM1QyxJQUFJLGFBQWEsSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUU7VUFDdEQsS0FBSyxNQUFNLE9BQU8sSUFBSSxNQUFNLEtBQUssQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUNoRCxNQUFNLGtCQUFrQixhQUFhLENBQUMsT0FBTyxDQUFDLENBQUE7WUFDOUMsSUFBSSxLQUFLLFFBQVEsQ0FBQyxlQUFlLENBQUMsRUFBRTtjQUNsQyxLQUFLLE1BQU0sS0FBSyxJQUFJLGVBQWUsRUFBRTtnQkFDbkMsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7a0JBQ25CLEtBQUssT0FBTyxHQUFHLGdCQUFnQixDQUFBO2lCQUNqQztlQUNGO2FBQ0Y7V0FDRjtTQUNGO09BQ0Y7S0FDRjtHQUNGO0VBRUEsT0FBTyxLQUFLLENBQUE7Q0FDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEVBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFBQSxRQUFBLEdBS2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQzFDLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsT0FBTyxLQUFLLENBQUMsMEJBQTBCO0VBQ3ZDLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBRkEsSUFBQSxRQUFBLEdBR2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQzFDLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsSUFBSSxLQUFLLENBQUMscUJBQXFCLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLFdBQVcsRUFBRTtJQUMxRSxLQUFLLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLGlCQUFpQixHQUN2RCxLQUFLLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLG1CQUFtQjtJQUM3RCxPQUFPLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsbUJBQW1CO0VBQ3BFO0VBQ0EsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUhBLElBQUEsUUFBQSxHQUllO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUMxQyxPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLElBQUksS0FBSyxDQUFDLGtCQUFrQixFQUFFO0lBQzVCLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxrQ0FBa0MsR0FBRyxLQUFLO0VBQ3JFLENBQUMsTUFBTTtJQUNMLEtBQUssQ0FBQyxrQkFBa0IsR0FBRztNQUN6QixrQ0FBa0MsRUFBRTtJQUN0QyxDQUFDO0VBQ0g7RUFDQSxPQUFPLEtBQUs7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QkEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUMxQyxPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQUEsSUFBQSxxQkFBQTtFQUM3QixJQUFJLEtBQUssYUFBTCxLQUFLLGdCQUFBLHFCQUFBLEdBQUwsS0FBSyxDQUFFLHFCQUFxQixjQUFBLHFCQUFBLGVBQTVCLHFCQUFBLENBQThCLGlCQUFpQixFQUFFO0lBQ25ELE9BQU8sS0FBSyxDQUFDLHFCQUFxQixDQUFDLGlCQUFpQjtFQUN0RDtFQUNBLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBRkEsSUFBQSxRQUFBLEdBR2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQzFDLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFBQSxJQUFBLHFCQUFBO0VBQzdCLElBQ0UsUUFBTyxLQUFLLGFBQUwsS0FBSyx3QkFBQSxxQkFBQSxHQUFMLEtBQUssQ0FBRSxrQkFBa0IsY0FBQSxxQkFBQSx1QkFBekIscUJBQUEsQ0FBMkIsNkJBQTZCLE1BQy9ELFdBQVcsRUFDWDtJQUNBLE9BQU8sS0FBSyxDQUFDLGtCQUFrQixDQUFDLDZCQUE2QjtFQUMvRDtFQUNBLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCQSxJQUFBLFVBQUEsT0FBQSxDQUFBLFFBQUEsQ0FBQSxDQUFBO0FBRUEsTUFBTSxVQUFVLEVBQUUsQ0FBQTs7Ozs7QUFFbEIsSUFBQSxXQUdlO0VBQ2IsT0FBTztFQUNQLGFBQWEsd0JBQXdCO0lBQ25DLE1BQU0sZ0JBQWdCLENBQUEsQ0FBQSxFQUFBLE9BQUEsVUFBUyxFQUFDLHFCQUFxQixDQUFDLENBQUE7SUFDdEQsYUFBYSxLQUFLLFFBQVEsR0FBRyxPQUFPLENBQUE7SUFDcEMsTUFBTSxRQUFRLGFBQWEsS0FBSyxDQUFBO0lBQ2hDLGFBQWEsS0FBSyxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUMxQyxPQUFPLGFBQWEsQ0FBQTtHQUN0QjtDQUNELENBQUE7QUFBQSxPQUFBLFFBQUEsR0FBQSxRQUFBLENBQUE7QUFFRCxNQUFNLG1CQUFtQixDQUFDLFNBQVMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFBO0FBRXRELCtCQUErQjtFQUFBLElBQUEscUJBQUEsQ0FBQTtFQUM3QixJQUFJLGdCQUFnQixTQUFTLENBQUMsS0FBSyxLQUFBLElBQUEsSUFBTCxLQUFLLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUEsQ0FBQSx3QkFBTCxLQUFLLHNCQUF1QixNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUE1QixxQkFBQSxZQUF5QyxDQUFDLEVBQUU7SUFDeEUsS0FBSyxzQkFBc0IsWUFBWSxHQUFHLFdBQVcsQ0FBQTtHQUN2RDtFQUNBLE9BQU8sS0FBSyxDQUFBO0NBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBRkEsSUFBQSxRQUFBLEdBR2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQzFDLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsSUFBSSxRQUFPLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxnQkFBZ0IsTUFBSyxXQUFXLEVBQUU7SUFDbEQsT0FBTyxLQUFLLENBQUMsZ0JBQWdCO0VBQy9CO0VBQ0EsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkJBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFGQSxJQUFBLFFBQUEsR0FHZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxhQUFhLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDMUMsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUFBLElBQUEscUJBQUE7RUFDN0IsTUFBTSxZQUFZLEdBQUcsS0FBSyxhQUFMLEtBQUssd0JBQUEscUJBQUEsR0FBTCxLQUFLLENBQUUscUJBQXFCLGNBQUEscUJBQUEsdUJBQTVCLHFCQUFBLENBQThCLFlBQVk7RUFDL0QsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxFQUFFO0lBQy9CLFlBQVksQ0FBQyxPQUFPLENBQUUsV0FBVyxJQUFLO01BQ3BDLElBQUksT0FBTyxXQUFXLENBQUMsaUJBQWlCLEtBQUssUUFBUSxFQUFFO1FBQ3JELFdBQVcsQ0FBQyxpQkFBaUIsR0FDM0IsV0FBVyxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO01BQzVDO0lBQ0YsQ0FBQyxDQUFDO0VBQ0o7RUFDQSxPQUFPLEtBQUs7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QkEsSUFBQSxVQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQTtBQUVBLE1BQU0sVUFBVSxFQUFFLENBQUE7Ozs7Ozs7Ozs7Ozs7O0FBRWxCLElBQUEsV0FZZTtFQUNiLE9BQU87RUFDUCxhQUFhLHdCQUF3QjtJQUNuQyxNQUFNLGdCQUFnQixDQUFBLENBQUEsRUFBQSxPQUFBLFVBQVMsRUFBQyxxQkFBcUIsQ0FBQyxDQUFBO0lBQ3RELGFBQWEsS0FBSyxRQUFRLEdBQUcsT0FBTyxDQUFBO0lBQ3BDLE1BQU0sUUFBUSxhQUFhLEtBQUssQ0FBQTtJQUNoQyxhQUFhLEtBQUssR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUE7SUFDMUMsT0FBTyxhQUFhLENBQUE7R0FDdEI7Q0FDRCxDQUFBO0FBQUEsT0FBQSxRQUFBLEdBQUEsUUFBQSxDQUFBO0FBRUQsTUFBTSxXQUFXLGlCQUFpQixDQUFBO0FBQ2xDLE1BQU0sZUFBZSwwQkFBMEIsQ0FBQTtBQUUvQyx3QkFBd0IsUUFBUSxFQUFFLEVBQUU7RUFBQSxJQUFBLHFCQUFBLEVBQUEsc0JBQUEsRUFBQSxzQkFBQSxFQUFBLHFCQUFBLEVBQUEscUJBQUEsRUFBQSxxQkFBQSxFQUFBLHFCQUFBLEVBQUEsc0JBQUEsRUFBQSxxQkFBQSxDQUFBOztFQUVsQyxDQUFBLHdCQUFPLEtBQUssa0JBQWtCLE1BQUEsSUFBQSxJQUFBLHFCQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsSUFBQSxHQUE5QixPQUFPLHFCQUFBLFNBQWlDLENBQUE7OztFQUd4QyxNQUFNLFdBQVcsQ0FBQSxDQUFBLHlCQUFBLEtBQUssa0JBQWtCLE1BQUEsSUFBQSxJQUFBLHNCQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQXZCLHNCQUFBLFNBQWlDLEtBQUksRUFBRSxDQUFBO0VBQ3hELE1BQU0sZ0NBQ0osUUFBUSxLQUFLLEtBQUssS0FBSyxLQUN0QixPQUFPLFFBQVEsUUFBUSxLQUFLLFFBQVEsSUFDbkMsQ0FBQyxZQUFZLEtBQUssQ0FBQyxRQUFRLFFBQVEsQ0FBQyxDQUFDLENBQUE7RUFDekMsSUFBSSw2QkFBNkIsSUFBSSxRQUFRLEtBQUssS0FBSyxXQUFXLEVBQUU7SUFDbEUsS0FBSyxrQkFBa0IsU0FBUyxHQUFHO01BQ2pDLE1BQU0sU0FBUztNQUNmLFFBQVEsRUFBRTtNQUNWLFNBQVMsS0FBSztNQUNkLFVBQVUsRUFBRTtNQUNaLFVBQVUsRUFBRTtNQUNaLFFBQVEsS0FBQTtLQUNULENBQUE7R0FDRixNQUFNLElBQUEsQ0FBQSx5QkFBSSxLQUFLLGtCQUFrQixNQUFBLElBQUEsSUFBQSxzQkFBQSxLQUFBLEtBQUEsQ0FBQSxJQUF2QixzQkFBQSxTQUFpQyxFQUFFO0lBQUEsSUFBQSxzQkFBQSxFQUFBLHNCQUFBLENBQUE7SUFDNUMsSUFBSSxXQUFXLElBQUksS0FBSyxrQkFBa0IsU0FBUyxFQUFFO01BQ25ELE1BQU0sU0FBUyxLQUFLLGtCQUFrQixTQUFTLFVBQVUsQ0FBQTtNQUN6RCxLQUFLLGtCQUFrQixTQUFTLE9BQU8sR0FBRyxNQUFNLENBQUE7S0FDbEQ7SUFDQSxDQUFBLHlCQUFPLEtBQUssa0JBQWtCLE1BQUEsSUFBQSxJQUFBLHNCQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsSUFBQSxHQUFBLENBQUEseUJBQXZCLHNCQUFBLFNBQWlDLE1BQUEsSUFBQSxJQUFBLHNCQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsSUFBQSxHQUF4QyxPQUFPLHNCQUFBLFVBQTRDLENBQUE7R0FDckQ7OztFQUdBLElBQUksQ0FBQyxLQUFLLHNCQUFzQixFQUFFO0lBQ2hDLEtBQUssc0JBQXNCLEdBQUcsRUFBRSxDQUFBO0dBQ2xDO0VBQ0EsSUFBSSxDQUFDLEtBQUssc0JBQXNCLHNCQUFzQixFQUFFO0lBQ3RELEtBQUssc0JBQXNCLHNCQUFzQixHQUFHLEVBQUUsQ0FBQTtHQUN4RDtFQUNBLEtBQUssc0JBQXNCLHNCQUFzQixRQUFRLENBQUM7SUFDeEQsUUFBUSx1QkFBdUI7SUFDL0IsU0FBUyxPQUFPO0lBQ2hCLFFBQVEsS0FBSztJQUNiLFVBQVUsZ0JBQWdCO0lBQzFCLFVBQVUsRUFBQztHQUNaLENBQUMsQ0FBQTs7O0VBR0YsQ0FBQSx3QkFBTyxLQUFLLHlCQUF5QixNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLElBQUEsR0FBckMsT0FBTyxxQkFBQSxlQUE4QyxDQUFBOzs7RUFHckQsTUFBTSxlQUFZLENBQUEsd0JBQUcsS0FBSyxzQkFBc0IsTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBM0IscUJBQUEsYUFBeUMsQ0FBQTtFQUM5RCxJQUFJLEtBQUssUUFBUSxDQUFDLFlBQVksQ0FBQyxFQUFFO0lBQy9CLFlBQVksUUFBUSxDQUFFLGVBQWdCO01BQ3BDLE1BQU0sb0JBQW9CLFdBQVcsS0FBQSxJQUFBLElBQVgsV0FBVyxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFYLFdBQVcsa0JBQW1CLENBQUE7TUFDeEQsSUFDRSxPQUFPLGlCQUFpQixLQUFLLFFBQVEsSUFDckMsUUFBUSxLQUFLLENBQUMsaUJBQWlCLENBQUMsRUFDaEM7UUFDQSxXQUFXLGtCQUFrQixHQUFHLFFBQVEsQ0FDdEMsaUJBQWlCLEVBQ2pCLEVBQ0YsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUE7T0FDaEI7S0FDRCxDQUFDLENBQUE7R0FDSjs7O0VBR0EsTUFBTSxjQUFjLENBQUEsQ0FBQSx3QkFBQSxLQUFLLHNCQUFzQixNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUEzQixxQkFBQSxZQUF3QyxLQUFJLEVBQUUsQ0FBQTtFQUNsRSxNQUFNLEtBQUssQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFFLGNBQWU7SUFDL0MsSUFBSSxTQUFTLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRTtNQUM5QixNQUFNLFVBQVcsQ0FBQSxFQUFBLEVBQUksUUFBUSxDQUFDLFVBQVUsRUFBRSxFQUFFLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBRSxDQUFBLENBQUMsQ0FBQTtNQUM1RCxjQUFjLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFBO01BRWhELElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQ3hCLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUE7T0FDdkQsTUFBTTtRQUNMLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUE7T0FDaEQ7TUFDQSxPQUFPLFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQTtLQUNoQztHQUNELENBQUMsQ0FBQTs7O0VBR0YsQ0FBQSx3QkFBTyxLQUFLLCtCQUErQixNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLElBQUEsR0FBQSxDQUFBLHlCQUFwQyxxQkFBQSxxQ0FDaUMsTUFBQSxJQUFBLElBQUEsc0JBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxJQUFBLEdBRHhDLE9BQU8sc0JBQUEsVUFDNEMsQ0FBQTs7O0VBR25ELE1BQU0sZ0JBQWEsQ0FBQSx3QkFBRyxLQUFLLHNCQUFzQixNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUEzQixxQkFBQSxjQUEwQyxDQUFBO0VBQ2hFLElBQUksYUFBYSxFQUFFO0lBQ2pCLE1BQU0sS0FBSyxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUUsV0FBWTtNQUFBLElBQUEscUJBQUEsRUFBQSxzQkFBQSxDQUFBO01BQzlDLE1BQU0sa0JBQWtCLENBQUEsQ0FBQSx3QkFBQSxhQUFhLENBQUMsT0FBTyxDQUFDLE1BQUEsSUFBQSxJQUFBLHFCQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQXRCLHFCQUFBLFVBQWlDLEtBQUksRUFBRSxDQUFBO01BRS9ELElBQUksZUFBZSxPQUFPLEdBQUcsQ0FBQyxFQUFFO1FBQzlCLE1BQU0sWUFBWSxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxFQUFFLENBQUE7UUFFbEQsSUFBSSxTQUFTLE9BQU8sR0FBRyxDQUFDLEVBQUU7VUFDeEIsYUFBYSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEdBQUcsZ0JBQWdCLENBQzNDLGVBQWUsRUFDZixTQUNGLENBQUMsQ0FBQTtTQUNGLE1BQU07VUFDTCxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksR0FBRyxlQUFlLENBQUE7U0FDOUM7T0FDRjtNQUNBLENBQUEseUJBQU8sYUFBYSxDQUFDLE9BQU8sQ0FBQyxNQUFBLElBQUEsSUFBQSxzQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLElBQUEsR0FBN0IsT0FBTyxzQkFBQSxVQUFpQyxDQUFBO0tBQ3pDLENBQUMsQ0FBQTtHQUNKO0VBRUEsT0FBTyxLQUFLLENBQUE7Q0FDZDs7Ozs7Ozs7O0FBU0EsbUVBQW1FO0VBQ2pFLE1BQU0sb0JBQW9CLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUE7O0VBRXZELE1BQU0sYUFBYTtJQUFFLEdBQUcsV0FBVyxDQUFDLFVBQVUsQ0FBQTtHQUFHLENBQUE7OztFQUdqRCxNQUFNLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxRQUFRLENBQUUsV0FBWTtJQUNsRCxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxPQUFPLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxRQUFRLEVBQUU7TUFDbEUsTUFBTSxjQUFjLEVBQUUsQ0FBQTs7OztNQUl0QixJQUFJLEdBQUcsQ0FBQyxDQUNOLEdBQUcsTUFBTSxLQUFLLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQ25DLEdBQUcsTUFBTSxLQUFLLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQ2pELENBQUMsUUFBUSxDQUFFLE9BQVE7UUFBQSxJQUFBLHFCQUFBLENBQUE7O1FBRWxCLFdBQVcsQ0FBQyxHQUFHLENBQUMsR0FDZCxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUEsQ0FBQSx3QkFBSSxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBMUIscUJBQUEsQ0FBNkIsR0FBRyxDQUFDLENBQUEsSUFBSSxFQUFFLENBQUE7T0FDdEUsQ0FBQyxDQUFBO01BRUYsVUFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLFdBQVcsQ0FBQTtLQUNsQyxNQUFNLElBQ0wsaUJBQWlCLENBQUMsT0FBTyxDQUFDLElBQzFCLE9BQU8saUJBQWlCLENBQUMsT0FBTyxDQUFDLEtBQUssUUFBUSxFQUM5Qzs7O01BR0EsVUFBVSxDQUFDLE9BQU8sQ0FBQyxHQUFHLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFBO0tBQ2xEO0dBQ0QsQ0FBQyxDQUFBO0VBRUYsV0FBVyxDQUFDLFVBQVUsQ0FBQyxHQUFHLFVBQVUsQ0FBQTtDQUN0Qzs7Ozs7Ozs7O0FBU0EsaURBQWlEO0VBQy9DLE1BQU0sT0FBTyxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUUsU0FBVTtJQUMvQyxJQUFJLEtBQUssSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7TUFDdEMsS0FBSyxRQUFRLEdBQUcsT0FBTyxDQUFBO0tBQ3pCO0dBQ0QsQ0FBQyxDQUFBO0NBQ0o7Ozs7Ozs7Ozs7QUFVQSxzREFBc0Q7RUFDcEQsTUFBTSxxQkFBcUIsZUFBZSxDQUFDLGVBQWUsQ0FBQyxDQUFBO0VBQzNELE1BQU0sZUFBZSxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUE7RUFFL0MsTUFBTSxlQUFlLEVBQUUsQ0FBQTtFQUN2QixJQUFJLEdBQUcsQ0FBQyxDQUNOLEdBQUcsTUFBTSxLQUFLLENBQUMsa0JBQWtCLENBQUMsRUFDbEMsR0FBRyxNQUFNLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FDN0IsQ0FBQyxRQUFRLENBQUUsZ0JBQWlCO0lBQzNCLFlBQVksS0FBSyxDQUFDO01BQ2hCLEdBQUcsa0JBQWtCLENBQUMsWUFBWSxDQUFDO01BQ25DLEdBQUcsWUFBWSxDQUFDLFlBQVksQ0FBQTtLQUM3QixDQUFDLENBQUE7R0FDSCxDQUFDLENBQUE7RUFFRixPQUFPLFlBQVksQ0FBQTtFQUVuQixnQ0FBZ0M7SUFDOUIsT0FBTyxLQUFLLE9BQU8sQ0FBQyxnQkFBZ0I7TUFDbEMsSUFBSSxLQUFLLEtBQUEsSUFBQSxJQUFMLEtBQUssS0FBQSxLQUFBLENBQUEsSUFBTCxLQUFLLFFBQVMsSUFBSSxRQUFPLEtBQUssS0FBQSxJQUFBLElBQUwsS0FBSyxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFMLEtBQUssUUFBUyxDQUFBLEtBQUssUUFBUSxFQUFFO1FBQ3hELEdBQUcsQ0FBQyxLQUFLLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQTtPQUM1QjtNQUNBLE9BQU8sR0FBRyxDQUFBO0tBQ1gsRUFBRSxFQUFFLENBQUMsQ0FBQTtHQUNSO0NBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ25PQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBRkEsSUFBQSxRQUFBLEdBR2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQzFDLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUU7RUFDbEMsSUFBSSxLQUFLLENBQUMscUJBQXFCLEVBQUU7SUFDL0IsTUFBTTtNQUFFLGFBQWE7TUFBRSx3QkFBd0I7TUFBRTtJQUFxQixDQUFDLEdBQ3JFLEtBQUssQ0FBQyxxQkFBcUI7SUFDN0IsS0FBSyxDQUFDLHFCQUFxQixHQUFHLEtBQUssQ0FBQyxxQkFBcUIsSUFBSSxDQUFDLENBQUM7SUFFL0QsSUFBSSxhQUFhLEtBQUssU0FBUyxFQUFFO01BQy9CLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxhQUFhLEdBQUcsYUFBYTtNQUN6RCxPQUFPLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxhQUFhO0lBQ2xEO0lBRUEsSUFBSSx3QkFBd0IsS0FBSyxTQUFTLEVBQUU7TUFDMUMsS0FBSyxDQUFDLHFCQUFxQixDQUFDLHdCQUF3QixHQUNsRCx3QkFBd0I7TUFDMUIsT0FBTyxLQUFLLENBQUMscUJBQXFCLENBQUMsd0JBQXdCO0lBQzdEO0lBRUEsSUFBSSxvQkFBb0IsS0FBSyxTQUFTLEVBQUU7TUFDdEMsS0FBSyxDQUFDLHFCQUFxQixDQUFDLG9CQUFvQixHQUFHLG9CQUFvQjtNQUN2RSxPQUFPLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxvQkFBb0I7SUFDekQ7RUFDRjtFQUNBLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pDQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTtBQUVsQixNQUFNLHlCQUF5QixHQUFHLENBQ2hDLDZDQUE2QyxFQUM3Qyw4QkFBOEIsRUFDOUIsYUFBYSxFQUNiLHNDQUFzQyxFQUN0Qyx1QkFBdUIsRUFDdkIsa0NBQWtDLEVBQ2xDLGlEQUFpRCxFQUNqRCxrQ0FBa0MsRUFDbEMsbUJBQW1CLENBQ3BCOztBQUVEO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBRXBDLHlCQUF5QixDQUFDLE9BQU8sQ0FBRSxHQUFHO01BQUEsSUFBQSxvQkFBQTtNQUFBLFFBQUEsb0JBQUEsR0FDcEMsTUFBTSxDQUFDLFlBQVksY0FBQSxvQkFBQSx1QkFBbkIsb0JBQUEsQ0FBcUIsVUFBVSxDQUFDLEdBQUcsQ0FBQztJQUFBLENBQ3RDLENBQUM7SUFFRCxPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9CRCxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsSUFBQSxRQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUMxQyxPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQUEsSUFBQSxxQkFBQSxFQUFBLHFCQUFBO0VBQzdCLE1BQU07SUFBRSxPQUFPO0lBQUU7RUFBSyxDQUFDLEdBQUcsQ0FBQSxLQUFLLGFBQUwsS0FBSyx3QkFBQSxxQkFBQSxHQUFMLEtBQUssQ0FBRSxpQkFBaUIsY0FBQSxxQkFBQSx1QkFBeEIscUJBQUEsQ0FBMEIsUUFBUSxLQUFJLENBQUMsQ0FBQztFQUNsRSxNQUFNLFdBQVcsSUFBQSxxQkFBQSxHQUFHLDBCQUFpQixDQUFDLElBQUksQ0FBQyxjQUFBLHFCQUFBLHVCQUF2QixxQkFBQSxDQUF5QixPQUFPO0VBRXBELElBQUksV0FBVyxJQUFJLE9BQU8sS0FBSyxXQUFXLEVBQUU7SUFDMUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxPQUFPLEdBQUcsV0FBVztFQUN4RDtFQUNBLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsSUFBQSxRQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBLElBQUEsUUFBQSxHQU1lO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUMxQyxPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFO0VBQ2xDLElBQUksS0FBSyxDQUFDLHFCQUFxQixFQUFFO0lBQy9CLE1BQU07TUFBRSxhQUFhO01BQUUsbUJBQW1CO01BQUU7SUFBc0IsQ0FBQyxHQUNqRSxLQUFLLENBQUMscUJBQXFCO0lBRTdCLE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO0lBQzNCLE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxDQUFDO0lBRWpDLElBQUksYUFBYSxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtNQUMxRCxLQUFLLE1BQU0sT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUU7UUFDaEQsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQzlCLElBQUksYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLHNCQUFhLENBQUMsR0FBRyxDQUFDLEVBQUU7VUFDN0MscUJBQXFCLENBQUMsT0FBTyxDQUFFLE1BQU0sSUFBSztZQUN4QyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQ3ZDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxzQkFBYSxDQUFDLEdBQUcsQ0FBQztVQUM3QyxDQUFDLENBQUM7UUFDSjtRQUNBLEtBQUssTUFBTSxZQUFZLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRTtVQUM5RCxRQUFRLFlBQVk7WUFDbEIsS0FBSyxzQkFBYSxDQUFDLE9BQU87Y0FDeEIsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsa0JBQVMsQ0FBQyxPQUFPLENBQUMsR0FDMUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLHNCQUFhLENBQUMsT0FBTyxDQUFDO2NBQy9DO1lBQ0YsS0FBSyxTQUFTO2NBQ1osZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU87Y0FDakU7WUFDRixLQUFLLFNBQVM7Y0FDWixnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTztjQUNqRTtZQUNGLEtBQUssc0JBQWEsQ0FBQyxNQUFNO2NBQ3ZCLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLGtCQUFTLENBQUMsTUFBTSxDQUFDLEdBQ3pDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxzQkFBYSxDQUFDLE1BQU0sQ0FBQztjQUM5QztZQUNGLEtBQUssT0FBTztjQUNWLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLO2NBQ2hFO1lBQ0Y7Y0FDRTtVQUNKO1FBQ0Y7TUFDRjtNQUNBLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxhQUFhLEdBQUcsZ0JBQWdCO0lBQzlEO0lBRUEsSUFBSSxtQkFBbUIsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtNQUN0RSxLQUFLLE1BQU0sT0FBTyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsRUFBRTtRQUN0RCxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDcEMsSUFBSSxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxzQkFBYSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1VBQ25ELHFCQUFxQixDQUFDLE9BQU8sQ0FBRSxNQUFNLElBQUs7WUFDeEMsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUM3QyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxzQkFBYSxDQUFDLEdBQUcsQ0FBQztVQUNuRCxDQUFDLENBQUM7UUFDSjtRQUNBLEtBQUssTUFBTSxZQUFZLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFO1VBQ3BFLFFBQVEsWUFBWTtZQUNsQixLQUFLLHNCQUFhLENBQUMsT0FBTztjQUN4QixzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxrQkFBUyxDQUFDLE9BQU8sQ0FBQyxHQUNoRCxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxzQkFBYSxDQUFDLE9BQU8sQ0FBQztjQUNyRDtZQUNGLEtBQUssU0FBUztjQUNaLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUNwQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPO2NBQ3RDO1lBQ0YsS0FBSyxTQUFTO2NBQ1osc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQ3BDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU87Y0FDdEM7WUFDRixLQUFLLHNCQUFhLENBQUMsTUFBTTtjQUN2QixzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxrQkFBUyxDQUFDLE1BQU0sQ0FBQyxHQUMvQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxzQkFBYSxDQUFDLE1BQU0sQ0FBQztjQUNwRDtZQUNGLEtBQUssT0FBTztjQUNWLHNCQUFzQixDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUNyQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLO2NBQ3BDO1lBQ0Y7Y0FDRTtVQUNKO1FBQ0Y7TUFDRjtNQUNBLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxtQkFBbUIsR0FBRyxzQkFBc0I7SUFDMUU7RUFDRjtFQUNBLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFHQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsSUFBQSxZQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUMxQyxPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQUEsSUFBQSxxQkFBQSxFQUFBLHFCQUFBO0VBQzdCLE1BQU0sWUFBWSxHQUFHLEtBQUssYUFBTCxLQUFLLHdCQUFBLHFCQUFBLEdBQUwsS0FBSyxDQUFFLHFCQUFxQixjQUFBLHFCQUFBLHVCQUE1QixxQkFBQSxDQUE4QixZQUFZO0VBQy9ELE1BQU0sb0JBQW9CLEdBQ3hCLEtBQUssYUFBTCxLQUFLLHdCQUFBLHFCQUFBLEdBQUwsS0FBSyxDQUFFLDhCQUE4QixjQUFBLHFCQUFBLHVCQUFyQyxxQkFBQSxDQUF1QyxvQkFBb0I7RUFDN0QsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxFQUFFO0lBQy9CLFlBQVksQ0FBQyxPQUFPLENBQUUsV0FBVyxJQUFLO01BQ3BDLElBQUksV0FBVyxFQUFFO1FBQ2YsSUFDRSxXQUFXLENBQUMsSUFBSSxLQUFLLDRCQUFlLENBQUMsS0FBSyxJQUMxQyxXQUFXLENBQUMsSUFBSSxLQUFLLDRCQUFlLENBQUMsTUFBTSxFQUMzQztVQUNBLFdBQVcsQ0FBQyxJQUFJLEdBQUcsV0FBVyxDQUFDLG1CQUFtQjtRQUNwRDtRQUNBLE9BQU8sV0FBVyxDQUFDLG1CQUFtQjtNQUN4QztJQUNGLENBQUMsQ0FBQztFQUNKO0VBQ0EsSUFBSSxvQkFBb0IsRUFBRTtJQUN4QixNQUFNLDJCQUEyQixHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQUM7SUFDeEUsMkJBQTJCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsV0FBVyxDQUFDLEtBQUs7TUFDMUQsSUFBSSxXQUFXLEVBQUU7UUFDZixPQUFPLFdBQVcsQ0FBQyxtQkFBbUI7UUFDdEMsS0FBSyxDQUFDLDhCQUE4QixDQUFDLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxHQUFHO1VBQy9ELEdBQUcsV0FBVztVQUNkLElBQUksRUFBRSw0QkFBZSxDQUFDO1FBQ3hCLENBQUM7TUFDSDtJQUNGLENBQUMsQ0FBQztFQUNKO0VBQ0EsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakRBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFO0FBRWxCLFNBQVMsZUFBZSxDQUFDLFFBQVEsRUFBRTtFQUNqQyxPQUNFLE9BQU8sUUFBUSxLQUFLLFFBQVEsSUFDM0IsT0FBTyxRQUFRLEtBQUssUUFBUSxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFFO0FBRW5FOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEEsSUFBQSxRQUFBLEdBSWU7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDN0IsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNLFFBQVEsR0FBRyxLQUFLO0VBRXRCLElBQUksQ0FBQyxRQUFRLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsT0FBTyxRQUFRO0VBQ2pCO0VBRUEsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sSUFBSSxFQUFFO0VBQzFEO0VBQ0EsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQUU7RUFBUyxDQUFDLEtBQzdDLGVBQWUsQ0FBQyxRQUFRLENBQzFCLENBQUM7RUFDRCxLQUFLLE1BQU0sS0FBSyxJQUFJLFdBQVcsRUFBRTtJQUMvQjtJQUNBLElBQUksT0FBTyxLQUFLLENBQUMsUUFBUSxLQUFLLFFBQVEsRUFBRTtNQUN0QztNQUNBLEtBQUssQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUM7SUFDM0M7RUFDRjtFQUNBLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxNQUFNLEdBQUcsV0FBVztFQUVuRCxNQUFNO0lBQUU7RUFBYyxDQUFDLEdBQUcsUUFBUSxDQUFDLHFCQUFxQjtFQUN4RCxJQUFJLGFBQWEsSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUU7SUFDdEQsS0FBSyxNQUFNLE9BQU8sSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFO01BQ2hELE1BQU0sYUFBYSxHQUFHLGFBQWEsQ0FBQyxPQUFPLENBQUM7TUFDNUMsSUFBSSxhQUFhLElBQUksT0FBTyxhQUFhLEtBQUssUUFBUSxFQUFFO1FBQ3RELEtBQUssTUFBTSxPQUFPLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRTtVQUNoRCxNQUFNLGVBQWUsR0FBRyxhQUFhLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRTtVQUNwRDtVQUNBLE1BQU0sb0JBQW9CLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQUU7VUFBUyxDQUFDLEtBQy9ELGVBQWUsQ0FBQyxRQUFRLENBQzFCLENBQUM7VUFDRDtVQUNBLEtBQUssTUFBTSxLQUFLLElBQUksb0JBQW9CLEVBQUU7WUFDeEMsSUFBSSxPQUFPLEtBQUssQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFO2NBQ3RDO2NBQ0EsS0FBSyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQztZQUMzQztVQUNGO1VBQ0EsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFHLG9CQUFvQjtRQUMvQztNQUNGO0lBQ0Y7RUFDRjtFQUNBLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxhQUFhLEdBQUcsYUFBYTtFQUU1RCxPQUFPLFFBQVE7QUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUVBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLFFBQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBRkEsSUFBQSxRQUFBLEdBR2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQzFDLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxNQUFNLG9CQUFvQixHQUFHLFNBQVM7QUFFdEMsMEJBQWlCLENBQUMsT0FBTyxHQUFHO0VBQzFCLFNBQVMsRUFBRSxHQUFHO0VBQ2QsT0FBTyxFQUFFLEtBQUs7RUFDZCxNQUFNLEVBQUU7QUFDVixDQUFDO0FBQ0QsMEJBQWlCLENBQUMsT0FBTyxHQUFHO0VBQzFCLFNBQVMsRUFBRSxHQUFHO0VBQ2QsT0FBTyxFQUFFLEtBQUs7RUFDZCxNQUFNLEVBQUU7QUFDVixDQUFDO0FBQ0QsMEJBQWlCLENBQUMsS0FBSyxHQUFHO0VBQ3hCLFNBQVMsRUFBRSxJQUFJO0VBQ2YsT0FBTyxFQUFFLE1BQU07RUFDZixNQUFNLEVBQUU7QUFDVixDQUFDO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQUEsSUFBQSxxQkFBQTtFQUM3QixJQUNFLEtBQUssYUFBTCxLQUFLLGdCQUFBLHFCQUFBLEdBQUwsS0FBSyxDQUFFLDhCQUE4QixjQUFBLHFCQUFBLGVBQXJDLHFCQUFBLENBQXVDLG9DQUFvQyxFQUMzRTtJQUNBLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxtQ0FBbUMsR0FDdEUsSUFBQSxlQUFPLEVBQ0wsS0FBSyxDQUFDLDhCQUE4QixDQUNqQyxvQ0FBb0M7SUFDdkM7SUFDQTtJQUNBO0lBQ0EsQ0FBQyxDQUFDLEVBQUUsR0FBRztNQUFBLElBQUEscUJBQUE7TUFBQSxPQUFLLEVBQUEscUJBQUEsR0FBQSwwQkFBaUIsQ0FBQyxHQUFHLENBQUMsY0FBQSxxQkFBQSx1QkFBdEIscUJBQUEsQ0FBd0IsT0FBTyxLQUFJLG9CQUFvQjtJQUFBLENBQ3JFLENBQUM7SUFDSDtJQUNBO0lBQ0E7SUFDQTtJQUNBLE9BQU8sS0FBSyxDQUFDLDhCQUE4QixDQUN4QyxtQ0FBbUMsQ0FBQyxvQkFBb0IsQ0FBQztJQUM1RCxPQUFPLEtBQUssQ0FBQyw4QkFBOEIsQ0FDeEMsb0NBQW9DO0VBQ3pDO0VBQ0EsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkEsSUFBQSxRQUFBLEdBS2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFFcEMsTUFBTTtNQUFFO0lBQXNCLENBQUMsR0FBRyxhQUFhLENBQUMsSUFBSTtJQUVwRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMscUJBQXFCLGFBQXJCLHFCQUFxQix1QkFBckIscUJBQXFCLENBQUUsTUFBTSxDQUFDLEVBQUU7TUFDaEQscUJBQXFCLENBQUMsTUFBTSxHQUFHLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQ2hFLENBQUM7UUFBRTtNQUFRLENBQUMsS0FBSyxPQUNuQixDQUFDO0lBQ0g7SUFFQSxJQUNFLHFCQUFxQixhQUFyQixxQkFBcUIsZUFBckIscUJBQXFCLENBQUUsYUFBYSxJQUNwQyxPQUFPLHFCQUFxQixDQUFDLGFBQWEsS0FBSyxRQUFRLEVBQ3ZEO01BQ0EsTUFBTSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxhQUFhLENBQUMsQ0FBQyxPQUFPLENBQUUsT0FBTyxJQUFLO1FBQ3BFLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQ3hCLHFCQUFxQixDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQzdDLENBQUM7UUFDRCxNQUFNLENBQUMsT0FBTyxDQUFFLEtBQUssSUFBSztVQUN4QixxQkFBcUIsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQ2pELHFCQUFxQixDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQ3hELENBQUM7WUFBRTtVQUFRLENBQUMsS0FBSyxPQUNuQixDQUFDO1FBQ0wsQ0FBQyxDQUFDO01BQ0osQ0FBQyxDQUFDO0lBQ0o7SUFFQSxJQUNFLHFCQUFxQixhQUFyQixxQkFBcUIsZUFBckIscUJBQXFCLENBQUUsV0FBVyxJQUNsQyxXQUFXLElBQUkscUJBQXFCLENBQUMsV0FBVyxFQUNoRDtNQUNBLE9BQU8scUJBQXFCLENBQUMsV0FBVyxDQUFDLFNBQVM7SUFDcEQ7SUFFQSxPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2pERCxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsSUFBQSxTQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQXlELFNBQUEsdUJBQUEsR0FBQSxXQUFBLEdBQUEsSUFBQSxHQUFBLENBQUEsVUFBQSxHQUFBLEdBQUEsS0FBQSxPQUFBLEVBQUEsR0FBQTtBQUV6RCxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFGQSxJQUFBLFFBQUEsR0FHZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxhQUFhLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDMUMsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUFBLElBQUEscUJBQUE7RUFDN0IsSUFDRSxLQUFLLGFBQUwsS0FBSyxnQkFBQSxxQkFBQSxHQUFMLEtBQUssQ0FBRSxxQkFBcUIsY0FBQSxxQkFBQSxlQUE1QixxQkFBQSxDQUE4QixZQUFZLElBQzFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLHFCQUFxQixDQUFDLFlBQVksQ0FBQyxJQUN2RCxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUMzQyxJQUFJLElBQ0gsT0FBTyxJQUFJLEtBQUssUUFBUSxJQUFJLE9BQU8sSUFBSSxDQUFDLFFBQVEsS0FBSyxXQUN6RCxDQUFDLEVBQ0Q7SUFDQSxLQUFLLENBQUMscUJBQXFCLENBQUMsWUFBWSxHQUFHLElBQUEsYUFBSyxFQUM5QyxLQUFLLENBQUMscUJBQXFCLENBQUMsWUFBWTtJQUN4QztJQUNBO0lBQ0MsRUFBRSxJQUFLO01BQ04sSUFBSSxPQUFPLEVBQUUsQ0FBQyxFQUFFLEtBQUssV0FBVyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQ2xEO1FBQ0E7UUFDQSxFQUFFLENBQUMsRUFBRSxHQUFHLElBQUEsaUJBQVEsRUFBQyxDQUFDO01BQ3BCO01BQ0EsT0FBTyxFQUFFLENBQUMsRUFBRTtJQUNkLENBQ0YsQ0FBQztFQUNIO0VBQ0EsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0NBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFGQSxJQUFBLFFBQUEsR0FHZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxhQUFhLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDMUMsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUFBLElBQUEscUJBQUE7RUFDN0IsQ0FBQSxxQkFBQSxHQUFPLEtBQUssQ0FBQyxrQkFBa0IsY0FBQSxxQkFBQSxxQkFBL0IsT0FBTyxxQkFBQSxDQUEwQiwrQkFBK0I7RUFFaEUsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEJBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFRQSxJQUFBLFlBQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFIQSxJQUFBLFFBQUEsR0FJZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxhQUFhLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDMUMsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUFBLElBQUEscUJBQUE7RUFDN0IsTUFBTSxZQUFZLEdBQUcsS0FBSyxhQUFMLEtBQUssd0JBQUEscUJBQUEsR0FBTCxLQUFLLENBQUUscUJBQXFCLGNBQUEscUJBQUEsdUJBQTVCLHFCQUFBLENBQThCLFlBQVk7RUFDL0QsSUFBSSxJQUFBLHFCQUFhLEVBQUMsWUFBWSxDQUFDLEVBQUU7SUFDL0IsTUFBTSx5QkFBeUIsR0FBRyxJQUFBLGVBQU8sRUFDdkMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFDMUIsRUFBRSxJQUFLO01BQUEsSUFBQSxZQUFBO01BQ04sT0FBUSxJQUFBLFlBQUEsR0FBRSxFQUFFLENBQUMsUUFBUSxjQUFBLFlBQUEsdUJBQVgsWUFBQSxDQUFhLEtBQU0sSUFBRyxFQUFFLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQyxpQkFBa0IsRUFBQztJQUN0RSxDQUNGLENBQUM7SUFFRCxNQUFNLGNBQWMsR0FBRyxJQUFBLGNBQU0sRUFBQyx5QkFBeUIsRUFBRyxLQUFLLElBQUs7TUFDbEUsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUNkLEVBQUUsSUFDRCxFQUFFLENBQUMsSUFBSSxLQUFLLDRCQUFlLENBQUMsTUFBTSxJQUNsQyxFQUFFLENBQUMsSUFBSSxLQUFLLDRCQUFlLENBQUMsS0FDaEMsQ0FBQztJQUNILENBQUMsQ0FBQztJQUNGLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLEdBQUcsSUFBQSxhQUFLLEVBQzlDLElBQUEsY0FBTSxFQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxFQUN2QyxFQUFFLElBQUssRUFBRSxDQUFDLEVBQ2IsQ0FBQztFQUNIO0VBRUEsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkRBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFO0FBQ2xCLE1BQU0sd0JBQXdCLEdBQUcsQ0FBQztBQUNsQyxNQUFNLHlCQUF5QixHQUFHLFlBQVk7O0FBRTlDO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFBQSxJQUFBLHFCQUFBO0VBQzdCLE1BQU0sYUFBYSxHQUFHLEtBQUssYUFBTCxLQUFLLHdCQUFBLHFCQUFBLEdBQUwsS0FBSyxDQUFFLHNCQUFzQixjQUFBLHFCQUFBLHVCQUE3QixxQkFBQSxDQUErQixhQUFhO0VBQ2xFLElBQUksSUFBQSxxQkFBYSxFQUFDLGFBQWEsQ0FBQyxFQUFFO0lBQUEsSUFBQSxxQkFBQTtJQUNoQyxJQUNFLEVBQUEscUJBQUEsR0FBQSxhQUFhLENBQUMsd0JBQXdCLENBQUMsY0FBQSxxQkFBQSx1QkFBdkMscUJBQUEsQ0FBeUMsSUFBSSxNQUM3Qyx5QkFBeUIsRUFDekI7TUFDQSxPQUFPLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxhQUFhLENBQy9DLHdCQUF3QixDQUN6QjtJQUNIO0VBQ0Y7RUFDQSxPQUFPLEtBQUs7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsQ0EsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTSxXQUFXLEdBQUcsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0VBQ3hDLElBQUksS0FBSyxDQUFDLGtCQUFrQixFQUFFO0lBQzVCLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxrQ0FBa0MsR0FBRyxLQUFLO0lBQ25FLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQywrQkFBK0IsR0FBRyxXQUFXO0VBQ3hFLENBQUMsTUFBTTtJQUNMLEtBQUssQ0FBQyxrQkFBa0IsR0FBRztNQUN6QixrQ0FBa0MsRUFBRSxLQUFLO01BQ3pDLCtCQUErQixFQUFFO0lBQ25DLENBQUM7RUFDSDtFQUNBLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9CQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBRkEsSUFBQSxRQUFBLEdBR2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDN0IsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixJQUFJLEtBQUssQ0FBQyxxQkFBcUIsRUFBRTtJQUMvQixNQUFNO01BQUU7SUFBcUIsQ0FBQyxHQUFHLEtBQUssQ0FBQyxxQkFBcUI7SUFDNUQsSUFBSSxvQkFBb0IsS0FBSyxTQUFTLEVBQUU7TUFDdEMsT0FBTyxLQUFLLENBQUMscUJBQXFCLENBQUMsb0JBQW9CO0lBQ3pEO0VBQ0Y7RUFDQSxPQUFPLEtBQUs7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQkEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFBQSxJQUFBLHFCQUFBLEVBQUEsc0JBQUEsRUFBQSxzQkFBQSxFQUFBLHNCQUFBLEVBQUEsc0JBQUEsRUFBQSxzQkFBQSxFQUFBLHNCQUFBLEVBQUEsc0JBQUE7RUFDN0IsTUFBTSxhQUFhLEdBQUcsS0FBSyxhQUFMLEtBQUssd0JBQUEscUJBQUEsR0FBTCxLQUFLLENBQUUscUJBQXFCLGNBQUEscUJBQUEsdUJBQTVCLHFCQUFBLENBQThCLGFBQWE7RUFDakUsTUFBTSxtQkFBbUIsR0FBRyxLQUFLLGFBQUwsS0FBSyx3QkFBQSxzQkFBQSxHQUFMLEtBQUssQ0FBRSxxQkFBcUIsY0FBQSxzQkFBQSx1QkFBNUIsc0JBQUEsQ0FBOEIsbUJBQW1CO0VBRTdFLE1BQU0sWUFBWSxHQUFHLENBQUMsQ0FBQztFQUN2QixJQUFJLGFBQWEsRUFBRTtJQUNqQixNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLE9BQU8sQ0FBRSxjQUFjLElBQUs7TUFDckQsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUUsT0FBTyxJQUFLO1FBQzlELE1BQU0sV0FBVyxHQUFHLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFDMUQsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLEtBQUssU0FBUyxFQUFFO1VBQ3ZDLFlBQVksQ0FBQyxPQUFPLENBQUMsR0FBRztZQUFFLENBQUMsY0FBYyxHQUFHO1VBQVksQ0FBQztRQUMzRCxDQUFDLE1BQU07VUFDTCxZQUFZLENBQUMsT0FBTyxDQUFDLEdBQUc7WUFDdEIsR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDO1lBQ3hCLENBQUMsY0FBYyxHQUFHO1VBQ3BCLENBQUM7UUFDSDtNQUNGLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztFQUNKO0VBRUEsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLENBQUM7RUFDOUIsSUFBSSxtQkFBbUIsRUFBRTtJQUN2QixNQUFNLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsT0FBTyxDQUFFLGNBQWMsSUFBSztNQUMzRCxNQUFNLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFFLE9BQU8sSUFBSztRQUNwRSxNQUFNLGtCQUFrQixHQUFHLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztRQUN2RSxJQUFJLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxLQUFLLFNBQVMsRUFBRTtVQUM5QyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsR0FBRztZQUM3QixDQUFDLGNBQWMsR0FBRztVQUNwQixDQUFDO1FBQ0gsQ0FBQyxNQUFNO1VBQ0wsbUJBQW1CLENBQUMsT0FBTyxDQUFDLEdBQUc7WUFDN0IsR0FBRyxtQkFBbUIsQ0FBQyxPQUFPLENBQUM7WUFDL0IsQ0FBQyxjQUFjLEdBQUc7VUFDcEIsQ0FBQztRQUNIO01BQ0YsQ0FBQyxDQUFDO0lBQ0osQ0FBQyxDQUFDO0VBQ0o7RUFFQSxJQUFJLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRTtJQUMxQixLQUFLLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxHQUFHLFlBQVk7SUFDL0MsS0FBSyxDQUFDLGdCQUFnQixDQUFDLGdCQUFnQixHQUFHLG1CQUFtQjtFQUMvRCxDQUFDLE1BQU07SUFDTCxLQUFLLENBQUMsZ0JBQWdCLEdBQUc7TUFDdkIsU0FBUyxFQUFFLFlBQVk7TUFDdkIsZ0JBQWdCLEVBQUU7SUFDcEIsQ0FBQztFQUNIO0VBRU8sS0FBSyxhQUFMLEtBQUssc0JBQUEsc0JBQUEsR0FBTCxLQUFLLENBQUUscUJBQXFCLGNBQUEsc0JBQUEscUJBQW5DLE9BQU8sc0JBQUEsQ0FBOEIsbUJBQW1CO0VBQ2pELEtBQUssYUFBTCxLQUFLLHNCQUFBLHNCQUFBLEdBQUwsS0FBSyxDQUFFLHFCQUFxQixjQUFBLHNCQUFBLHFCQUFuQyxPQUFPLHNCQUFBLENBQThCLGFBQWE7RUFDM0MsS0FBSyxhQUFMLEtBQUssc0JBQUEsc0JBQUEsR0FBTCxLQUFLLENBQUUscUJBQXFCLGNBQUEsc0JBQUEscUJBQW5DLE9BQU8sc0JBQUEsQ0FBOEIsV0FBVztFQUN6QyxLQUFLLGFBQUwsS0FBSyxzQkFBQSxzQkFBQSxHQUFMLEtBQUssQ0FBRSxxQkFBcUIsY0FBQSxzQkFBQSxxQkFBbkMsT0FBTyxzQkFBQSxDQUE4QixZQUFZO0VBQzFDLEtBQUssYUFBTCxLQUFLLHNCQUFBLHNCQUFBLEdBQUwsS0FBSyxDQUFFLHFCQUFxQixjQUFBLHNCQUFBLHFCQUFuQyxPQUFPLHNCQUFBLENBQThCLE1BQU07RUFDcEMsS0FBSyxhQUFMLEtBQUssc0JBQUEsc0JBQUEsR0FBTCxLQUFLLENBQUUscUJBQXFCLGNBQUEsc0JBQUEscUJBQW5DLE9BQU8sc0JBQUEsQ0FBOEIsZUFBZTtFQUVwRCxPQUFPLEtBQUs7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RUEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsWUFBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFO0FBRWxCLE1BQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxDQUFDOztBQUVoQztBQUNBO0FBQ0E7QUFGQSxJQUFBLFFBQUEsR0FHZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUM3QixPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQUEsSUFBQSxxQkFBQTtFQUM3QixNQUFNLFlBQVksR0FBRyxLQUFLLGFBQUwsS0FBSyx3QkFBQSxxQkFBQSxHQUFMLEtBQUssQ0FBRSxxQkFBcUIsY0FBQSxxQkFBQSx1QkFBNUIscUJBQUEsQ0FBOEIsWUFBWTtFQUMvRCxJQUFJLElBQUEscUJBQWEsRUFBQyxZQUFZLENBQUMsRUFBRTtJQUMvQixLQUFLLE1BQU0sRUFBRSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUU7TUFDNUMsSUFBSSxFQUFFLENBQUMsSUFBSSxLQUFLLFVBQVUsRUFBRTtRQUMxQixFQUFFLENBQUMsSUFBSSxHQUFHLDRCQUFlLENBQUMsVUFBVTtNQUN0QztNQUNBLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRTtRQUNkLEVBQUUsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFFLE9BQU8sSUFBSztVQUMxQixJQUFJLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLElBQUksS0FBSyxVQUFVLEVBQUU7WUFDL0MsT0FBTyxDQUFDLElBQUksR0FBRyw0QkFBZSxDQUFDLFVBQVU7VUFDM0M7VUFDQSxPQUFPLE9BQU87UUFDaEIsQ0FBQyxDQUFDO01BQ0o7SUFDRjtFQUNGO0VBQ0EsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeENBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFGQSxJQUFBLFFBQUEsR0FHZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUM3QixPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLElBQUksS0FBSyxDQUFDLHFCQUFxQixFQUFFO0lBQy9CLE1BQU07TUFBRSxtQkFBbUI7TUFBRTtJQUFrQixDQUFDLEdBQzlDLEtBQUssQ0FBQyxxQkFBcUI7SUFDN0IsS0FBSyxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQyxvQkFBb0IsSUFBSSxDQUFDLENBQUM7SUFFN0QsSUFBSSxtQkFBbUIsS0FBSyxTQUFTLEVBQUU7TUFDckMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLG1CQUFtQixHQUFHLG1CQUFtQjtNQUNwRSxPQUFPLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxtQkFBbUI7SUFDeEQ7SUFDQSxJQUFJLGlCQUFpQixLQUFLLFNBQVMsRUFBRTtNQUNuQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsaUJBQWlCLEdBQUcsaUJBQWlCO01BQ2hFLE9BQU8sS0FBSyxDQUFDLHFCQUFxQixDQUFDLGlCQUFpQjtJQUN0RDtFQUNGO0VBRUEsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLGdCQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFBQSxJQUFBLHFCQUFBO0VBQzdCLE1BQU0sb0JBQW9CLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQzdDLHFDQUFvQixDQUFDLE1BQU0sR0FDM0IscUNBQW9CLENBQUMsR0FBRztFQUM1QixNQUFNLGFBQWEsR0FBRyxPQUFPLEVBQUEscUJBQUEsR0FBQyxLQUFLLENBQUMscUJBQXFCLGNBQUEscUJBQUEsdUJBQTNCLHFCQUFBLENBQTZCLGFBQWEsQ0FBQztFQUN6RSxNQUFNLFFBQVEsR0FBRztJQUNmLEdBQUcsS0FBSztJQUNSLHFCQUFxQixFQUFFO01BQ3JCLElBQUcsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLHFCQUFxQjtNQUMvQixtQkFBbUIsRUFBRSxhQUFhLEdBQzlCLHFDQUFvQixDQUFDLElBQUksR0FDekI7SUFDTjtFQUNGLENBQUM7RUFDRCxPQUFPLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxhQUFhO0VBQ25ELE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ0EsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsVUFBQSxHQUFBLHNCQUFBLENBQUEsT0FBQTtBQUNBLElBQUEsUUFBQSxHQUFBLE9BQUE7QUFBZ0UsU0FBQSx1QkFBQSxHQUFBLFdBQUEsR0FBQSxJQUFBLEdBQUEsQ0FBQSxVQUFBLEdBQUEsR0FBQSxLQUFBLE9BQUEsRUFBQSxHQUFBO0FBRWhFLE1BQU0sMEJBQTBCLEdBQUksU0FBUyxJQUMzQyxJQUFJLGtCQUFTLENBQUMsU0FBUyxJQUFJLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBRTdDLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBSEEsSUFBQSxRQUFBLEdBSWU7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDN0IsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUFBLElBQUEscUJBQUEsRUFBQSxxQkFBQSxFQUFBLHFCQUFBO0VBQzdCLE1BQU0scUJBQXFCLEdBQUcsQ0FBQSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUscUJBQXFCLEtBQUksQ0FBQyxDQUFDO0VBQ2hFLE1BQU0sV0FBVyxHQUFHLHFCQUFxQixDQUFDLFdBQVcsSUFBSSxDQUFDLENBQUM7RUFFM0QsSUFBSSxXQUFXLENBQUMsZ0JBQWdCLEVBQUU7SUFDaEMsT0FBTyxLQUFLO0VBQ2Q7RUFFQSxNQUFNLFlBQVksR0FBRyxDQUFBLEtBQUssYUFBTCxLQUFLLHdCQUFBLHFCQUFBLEdBQUwsS0FBSyxDQUFFLHFCQUFxQixjQUFBLHFCQUFBLHVCQUE1QixxQkFBQSxDQUE4QixZQUFZLEtBQUksQ0FBQyxDQUFDO0VBQ3JFLE1BQU0sUUFBUSxHQUFHLEVBQUEscUJBQUEsR0FBQSxLQUFLLENBQUMsaUJBQWlCLGNBQUEscUJBQUEsdUJBQXZCLHFCQUFBLENBQXlCLFFBQVEsS0FBSSxDQUFDLENBQUM7RUFDeEQsTUFBTSxjQUFjLEdBQUcsRUFBQSxxQkFBQSxHQUFBLEtBQUssQ0FBQyx3QkFBd0IsY0FBQSxxQkFBQSx1QkFBOUIscUJBQUEsQ0FBZ0MsY0FBYyxLQUFJLENBQUMsQ0FBQztFQUUzRSxNQUFNLHlCQUF5QixHQUFHLG9CQUFXLENBQUMsUUFBUSxDQUFDLFFBQVEsYUFBUixRQUFRLHVCQUFSLFFBQVEsQ0FBRSxPQUFPLENBQUM7RUFDekUsTUFBTSw4QkFBOEIsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FDckUsQ0FBQztJQUFFO0VBQVEsQ0FBQyxLQUFLLG9CQUFXLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FDL0MsQ0FBQztFQUNELE1BQU0sK0JBQStCLEdBQUcsb0JBQVcsQ0FBQyxJQUFJLENBQUUsT0FBTyxJQUFLO0lBQ3BFLE1BQU0sc0JBQXNCLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDM0UsTUFBTSx5Q0FBeUMsR0FDN0Msc0JBQXNCLENBQUMsSUFBSSxDQUFDLDBCQUEwQixDQUFDO0lBQ3pELE9BQU8seUNBQXlDO0VBQ2xELENBQUMsQ0FBQztFQUNGLE1BQU0sbUJBQW1CLEdBQ3ZCLHlCQUF5QixJQUN6Qiw4QkFBOEIsSUFDOUIsK0JBQStCO0VBRWpDLE1BQU0sUUFBUSxHQUFHO0lBQ2YsR0FBRyxLQUFLO0lBQ1IscUJBQXFCLEVBQUU7TUFDckIsR0FBRyxxQkFBcUI7TUFDeEIsV0FBVyxFQUFFO1FBQ1gsR0FBRyxXQUFXO1FBQ2QsZ0JBQWdCLEVBQUU7TUFDcEI7SUFDRjtFQUNGLENBQUM7RUFFRCxPQUFPLFFBQVE7QUFDakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEVBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUhBLElBQUEsUUFBQSxHQUllO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTTtJQUNKLHFCQUFxQixHQUFHLENBQUMsQ0FBQztJQUMxQixtQkFBbUIsR0FBRyxDQUFDLENBQUM7SUFDeEIsR0FBRztFQUNMLENBQUMsR0FBRyxLQUFLO0VBRVQsTUFBTTtJQUNKLGNBQWMsR0FBRyxDQUFDLENBQUM7SUFDbkIsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZCLGNBQWMsR0FBRztFQUNuQixDQUFDLEdBQUcsbUJBQW1CO0VBRXZCLE9BQU87SUFDTCxHQUFHLGNBQWM7SUFDakIsb0JBQW9CLEVBQUUsNEJBQTRCLENBQUMscUJBQXFCLENBQUM7SUFDekUsdUJBQXVCLEVBQUU7TUFDdkIscUJBQXFCLEVBQUUsY0FBYztNQUNyQyxpQkFBaUIsRUFBRTtJQUNyQixDQUFDO0lBQ0QseUJBQXlCLEVBQ3ZCLGlDQUFpQyxDQUFDLGNBQWM7RUFDcEQsQ0FBQztBQUNIO0FBRUEsU0FBUyw0QkFBNEIsQ0FBQyxxQkFBcUIsRUFBRTtFQUMzRCxNQUFNO0lBQUUsT0FBTyxHQUFHLENBQUM7RUFBRSxDQUFDLEdBQUcscUJBQXFCOztFQUU5QztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7RUFFRSxNQUFNLFlBQVksR0FBRyxjQUFjO0VBQ25DLE1BQU0sZUFBZSxHQUFHLDBCQUEwQjtFQUNsRCxNQUFNLGVBQWUsR0FBRyxpQkFBaUI7RUFFekMsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQzdDLENBQUMsV0FBVyxFQUFFLENBQUMsTUFBTSxFQUFFLFdBQVcsQ0FBQyxLQUFLO0lBQ3RDLE1BQU07TUFDSixXQUFXLEVBQUUsQ0FBQyxxQkFBcUI7SUFDckMsQ0FBQyxHQUFHLFdBQVc7O0lBRWY7SUFDQTtJQUNBLE1BQU0sU0FBUyxHQUFHLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQ2pELE1BQU0sSUFBSyxNQUFNLENBQUMsSUFBSSxLQUFLLGVBQzlCLENBQUM7SUFFRCxNQUFNLGFBQWEsR0FBRztNQUNwQixHQUFHLHFCQUFxQjtNQUN4QixPQUFPLEVBQUUsQ0FBQztRQUFFLElBQUksRUFBRSxlQUFlO1FBQUUsS0FBSyxFQUFFLFNBQVMsQ0FBQztNQUFNLENBQUM7SUFDN0QsQ0FBQzs7SUFFRDtJQUNBLE9BQU8sYUFBYSxDQUFDLFVBQVUsQ0FBQztJQUVoQyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUc7TUFDcEIsTUFBTTtNQUNOLFdBQVcsRUFBRTtRQUNYLENBQUMsWUFBWSxHQUFHO01BQ2xCO0lBQ0YsQ0FBQztJQUNELE9BQU8sV0FBVztFQUNwQixDQUFDLEVBQ0QsQ0FBQyxDQUNILENBQUM7RUFFRCxPQUFPO0lBQ0w7RUFDRixDQUFDO0FBQ0g7QUFFQSxTQUFTLGlDQUFpQyxDQUFDLGNBQWMsRUFBRTtFQUN6RDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7RUFFRSxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLE1BQU0sQ0FDM0QsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEtBQUs7SUFDbkMsTUFBTTtNQUNKLElBQUksR0FBRyxJQUFJO01BQ1gsSUFBSSxHQUFHLElBQUk7TUFDWCxXQUFXLEdBQUcsSUFBSTtNQUNsQixHQUFHO0lBQ0wsQ0FBQyxHQUFHLFFBQVE7O0lBRVo7SUFDQSxPQUFPLEtBQUssQ0FBQyxXQUFXO0lBQ3hCLE9BQU8sS0FBSyxDQUFDLElBQUk7SUFFakIsSUFBSSxNQUFNLEVBQUU7TUFDVixXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUc7UUFDcEIsSUFBSTtRQUNKLE9BQU8sRUFBRSxJQUFJO1FBQ2IsV0FBVztRQUNYLEdBQUcsS0FBSztRQUNSO01BQ0YsQ0FBQztJQUNIO0lBQ0EsT0FBTyxXQUFXO0VBQ3BCLENBQUMsRUFDRCxDQUFDLENBQ0gsQ0FBQztFQUVELE9BQU87SUFDTDtFQUNGLENBQUM7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSkEsSUFBQSwwQkFBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBRkEsSUFBQSxRQUFBLEdBR2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDN0IsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUFBLElBQUEscUJBQUE7RUFDN0IsSUFBSSxRQUFPLEtBQUssYUFBTCxLQUFLLHdCQUFBLHFCQUFBLEdBQUwsS0FBSyxDQUFFLHlCQUF5QixjQUFBLHFCQUFBLHVCQUFoQyxxQkFBQSxDQUFrQyxlQUFlLE1BQUssUUFBUSxFQUFFO0lBQ3pFLE1BQU07TUFDSix5QkFBeUIsRUFBRTtRQUFFO01BQWdCO0lBQy9DLENBQUMsR0FBRyxLQUFLOztJQUVUO0lBQ0EsTUFBTSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxPQUFPLENBQUUsUUFBUSxJQUFLO01BQ25ELElBQ0UsUUFBUSxJQUNSLE9BQU8sUUFBUSxLQUFLLFFBQVEsSUFDNUIsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUN4QjtRQUNBLFFBQVEsQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsR0FDdkMsc0NBQVcsQ0FBQyxTQUFTLEdBQ3JCLHNDQUFXLENBQUMsT0FBTztNQUN6QjtJQUNGLENBQUMsQ0FBQztFQUNKO0VBQ0EsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeENBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUhBLElBQUEsUUFBQSxHQUllO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFBQSxJQUFBLHFCQUFBO0VBQzdCLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLGFBQUwsS0FBSyx3QkFBQSxxQkFBQSxHQUFMLEtBQUssQ0FBRSx1QkFBdUIsY0FBQSxxQkFBQSx1QkFBOUIscUJBQUEsQ0FBZ0MscUJBQXFCLENBQUMsRUFBRTtJQUN4RSxNQUFNO01BQ0osdUJBQXVCLEVBQUU7UUFBRTtNQUFzQjtJQUNuRCxDQUFDLEdBQUcsS0FBSzs7SUFFVDtJQUNBLHFCQUFxQixDQUFDLE9BQU8sQ0FBRSxRQUFRLElBQUs7TUFDMUMsSUFDRSxRQUFRLElBQ1IsT0FBTyxRQUFRLEtBQUssUUFBUSxJQUM1QixDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQ3hCO1FBQ0EsT0FBTyxRQUFRLENBQUMsT0FBTztRQUN2QixPQUFPLFFBQVEsQ0FBQyxRQUFRO01BQzFCO0lBQ0YsQ0FBQyxDQUFDO0VBQ0o7RUFDQSxPQUFPLEtBQUs7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2Q0EsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsSUFBSSxLQUFLLENBQUMsc0JBQXNCLEVBQUU7SUFDaEMsS0FBSyxDQUFDLHNCQUFzQixHQUFHO01BQzdCLGFBQWEsRUFBRSxLQUFLLENBQUMsc0JBQXNCLENBQUM7SUFDOUMsQ0FBQztJQUNELE9BQU8sS0FBSyxDQUFDLHNCQUFzQjtFQUNyQztFQUNBLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBRkEsSUFBQSxRQUFBLEdBR2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDN0IsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUM3QixNQUFNLHFCQUFxQixHQUFHLENBQUEsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLHFCQUFxQixLQUFJLENBQUMsQ0FBQztFQUVoRSxPQUFPO0lBQ0wsR0FBRyxLQUFLO0lBQ1IscUJBQXFCLEVBQUU7TUFDckIsR0FBRyxxQkFBcUI7TUFDeEIsZUFBZSxFQUFFLENBQUM7SUFDcEI7RUFDRixDQUFDO0FBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFGQSxJQUFBLFFBQUEsR0FHZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUM3QixPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQzdCLE1BQU0scUJBQXFCLEdBQUcsQ0FBQSxLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUscUJBQXFCLEtBQUksQ0FBQyxDQUFDO0VBRWhFLE9BQU87SUFDTCxHQUFHLEtBQUs7SUFDUixxQkFBcUIsRUFBRTtNQUNyQixHQUFHLHFCQUFxQjtNQUN4QixlQUFlLEVBQUUsQ0FBQztJQUNwQjtFQUNGLENBQUM7QUFDSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QkEsSUFBQSxVQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsYUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxjQUFBLENBQUEsQ0FBQSxDQUFBO0FBQ0EsSUFBQSxXQUFBLE9BQUEsQ0FBQSxtQ0FBQSxDQUFBLENBQUE7QUFBOEQscUNBQUEsRUFBQSxPQUFBLEdBQUEsSUFBQSxHQUFBLFdBQUEsR0FBQSxHQUFBLEdBQUEsRUFBQSxTQUFBLEdBQUEsRUFBQSxDQUFBLEVBQUE7QUFFOUQsTUFBTSxVQUFVLEVBQUUsQ0FBQTtBQUVsQixNQUFNLDZCQUE4QixhQUNsQyxJQUFJLFVBQUEsUUFBUyxDQUFDLFNBQVMsSUFBSSxLQUFLLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUU3QyxNQUFNLCtCQUErQixDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUE7QUFDM0QsTUFBTSw4QkFBOEI7RUFDbEMsT0FBTztJQUNMLFFBQVEsQ0FBQSxDQUFBLEVBQUEsUUFBQSxVQUFTLEVBQUM7TUFBRSxTQUFTLFNBQUE7S0FBVyxDQUFDO0lBQ3pDLFVBQVUsU0FBUztJQUNuQixRQUFRLFlBQUE7R0FDVDtFQUNELFFBQVE7SUFDTixRQUFRLENBQUEsQ0FBQSxFQUFBLFFBQUEsVUFBUyxFQUFDO01BQUUsU0FBUyxPQUFBO0tBQVMsQ0FBQztJQUN2QyxVQUFVLE9BQU87SUFDakIsUUFBUSxVQUFBO0dBQ1Q7RUFDRCxPQUFPO0lBQ0wsUUFBUSxDQUFBLENBQUEsRUFBQSxRQUFBLFVBQVMsRUFBQztNQUFFLFNBQVMsU0FBQTtLQUFXLENBQUM7SUFDekMsVUFBVSxTQUFTO0lBQ25CLFFBQVEsWUFBQTtHQUNWO0NBQ0QsQ0FBQTs7Ozs7OztBQUVELElBQUEsV0FLZTtFQUNiLE9BQU87RUFDUCxhQUFhLHdCQUF3QjtJQUNuQyxNQUFNLGdCQUFnQixDQUFBLENBQUEsRUFBQSxPQUFBLFVBQVMsRUFBQyxxQkFBcUIsQ0FBQyxDQUFBO0lBQ3RELGFBQWEsS0FBSyxRQUFRLEdBQUcsT0FBTyxDQUFBO0lBQ3BDLE1BQU0sUUFBUSxhQUFhLEtBQUssQ0FBQTtJQUNoQyxNQUFNLFdBQVcsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBQ3RDLGFBQWEsS0FBSyxHQUFHLFFBQVEsQ0FBQTtJQUM3QixPQUFPLGFBQWEsQ0FBQTtHQUN0QjtDQUNELENBQUE7QUFBQSxPQUFBLFFBQUEsR0FBQSxRQUFBLENBQUE7QUFFRCwrQkFBK0I7RUFBQSxJQUFBLHFCQUFBLEVBQUEscUJBQUEsQ0FBQTtFQUM3QixNQUFNLHdCQUF3QixDQUFBLEtBQUssS0FBQSxJQUFBLElBQUwsS0FBSyxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFMLEtBQUssc0JBQXVCLEtBQUksRUFBRSxDQUFBO0VBQ2hFLE1BQU0sY0FBYyxxQkFBcUIsWUFBWSxJQUFJLEVBQUUsQ0FBQTtFQUMzRCxNQUFNLG9CQUFvQixDQUFBLEtBQUssS0FBQSxJQUFBLElBQUwsS0FBSyxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFMLEtBQUssa0JBQW1CLEtBQUksRUFBRSxDQUFBO0VBQ3hELE1BQU0sV0FBVyxDQUFBLGlCQUFpQixLQUFBLElBQUEsSUFBakIsaUJBQWlCLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQWpCLGlCQUFpQixTQUFVLEtBQUksRUFBRSxDQUFBO0VBRWxELE1BQU0sK0JBQStCLDRCQUE0QixPQUFPLENBQ3JFLFdBQVksT0FBTyxNQUFLLFFBQVEsS0FBQSxJQUFBLElBQVIsUUFBUSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFSLFFBQVEsUUFBUyxDQUM1QyxDQUFDLENBQUE7Ozs7RUFJRCxJQUNFLENBQUMsV0FBVyxpQkFBaUIsSUFDN0IsNEJBQTRCLE9BQU8sS0FBSyxDQUFDLEVBQ3pDO0lBQ0EsT0FBTyxLQUFLLENBQUE7R0FDZDtFQUVBLE1BQU0sZUFBZSxDQUFBLEtBQUssS0FBQSxJQUFBLElBQUwsS0FBSyxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFBLENBQUEsd0JBQUwsS0FBSyxzQkFBdUIsTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBNUIscUJBQUEsYUFBMEMsS0FBSSxFQUFFLENBQUE7RUFDckUsTUFBTSxpQkFBaUIsQ0FBQSxDQUFBLHdCQUFBLEtBQUsseUJBQXlCLE1BQUEsSUFBQSxJQUFBLHFCQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQTlCLHFCQUFBLGVBQThDLEtBQUksRUFBRSxDQUFBO0VBRTNFLE1BQU0sc0RBQXNELE1BQU0sT0FBTyxDQUN2RSxZQUNGLENBQUMsT0FDUSxDQUFDLENBQUM7O0dBQVcsS0FBSyw0QkFBNEIsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQ3BFLENBQUMsQ0FBQzs7R0FBVyxLQUFLLE9BQU8sQ0FBQyxDQUFBO0VBQ2hDLE1BQU0sbURBQ0osNEJBQTRCLE9BQU8sQ0FBRSxXQUFZO0lBQy9DLE1BQU0seUJBQXlCLE1BQU0sT0FBTyxDQUMxQyxjQUFjLENBQUMsT0FBTyxDQUFDLElBQUksRUFDN0IsQ0FBQyxDQUFBO0lBQ0QsTUFBTSw0Q0FDSixzQkFBc0IsS0FBSyxDQUFDLDBCQUEwQixDQUFDLENBQUE7SUFDekQsT0FBTyx5Q0FBeUMsQ0FBQTtHQUNqRCxDQUFDLENBQUE7RUFDSixNQUFNLHFDQUFxQyxDQUFBLENBQUEsRUFBQSxPQUFBLEtBQUksRUFBQyxDQUM5QyxHQUFHLGdEQUFnRCxFQUNuRCxHQUFHLG1EQUFtRCxFQUN0RCxHQUFHLDRCQUE0QixDQUNoQyxDQUFDLENBQUE7RUFFRixNQUFNLDJCQUNKLHFCQUFxQixzQkFBc0IsSUFBSSxFQUFFLENBQUE7RUFFbkQsa0NBQWtDLFFBQVEsQ0FBRSxXQUFZO0lBQ3RELElBQ0UsQ0FBQyx3QkFBd0IsS0FBSyxDQUMzQixjQUFlLFVBQVUsUUFBUSxLQUFLLE9BQ3pDLENBQUMsRUFDRDtNQUNBLHdCQUF3QixRQUFRLENBQUM7UUFDL0IsUUFBUSwyQkFBMkIsQ0FBQyxPQUFPLENBQUMsT0FBTztRQUNuRCxPQUFPO1FBQ1AsUUFBUSwyQkFBMkIsQ0FBQyxPQUFPLENBQUMsT0FBTztRQUNuRCxVQUFVLDJCQUEyQixDQUFDLE9BQU8sQ0FBQyxTQUFTO1FBQ3ZELFVBQVUsRUFBQztPQUNaLENBQUMsQ0FBQTtLQUNKO0dBQ0QsQ0FBQyxDQUFBO0VBRUYsSUFBSSx3QkFBd0IsT0FBTyxFQUFFO0lBQ25DLHFCQUFxQixzQkFBc0IsR0FBRyx3QkFBd0IsQ0FBQTtHQUN4RTtFQUVBLElBQUksNEJBQTRCLE9BQU8sRUFBRTtJQUN2QyxNQUFNLHlCQUF5Qiw0QkFBNEIsQ0FBQyxDQUFDLENBQUMsQ0FBQTtJQUM5RCxpQkFBaUIsU0FBUyxHQUFHO01BQzNCLEdBQUcsaUJBQWlCLFNBQVM7TUFDN0IsTUFBTSxLQUFLO01BQ1gsUUFBUSwyQkFBMkIsQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPO01BQ2xFLFNBQVMsc0JBQXNCO01BQy9CLFVBQVUsMkJBQTJCLENBQUMsc0JBQXNCLENBQUMsU0FBUztNQUN0RSxRQUFRLDJCQUEyQixDQUFDLHNCQUFzQixDQUFDLE9BQUM7S0FDN0QsQ0FBQTtHQUNIO0VBRUEsT0FBTztJQUNMLEdBQUcsS0FBSztJQUNSLHVCQUF1QjtNQUNyQixHQUFHLHFCQUFBO0tBQ0o7SUFDRCxtQkFBbUI7TUFDakIsR0FBRyxpQkFBQTtLQUNMO0dBQ0QsQ0FBQTtDQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuSUEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRWxCO0FBQ0E7QUFDQTtBQUZBLElBQUEsUUFBQSxHQUdlO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsT0FBTyxLQUFLLENBQUMsa0JBQWtCO0VBQy9CLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBRkEsSUFBQSxRQUFBLEdBR2U7RUFDYixPQUFPO0VBQ1AsTUFBTSxPQUFPLENBQUMscUJBQXFCLEVBQUU7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7SUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztJQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDN0IsT0FBTyxhQUFhO0VBQ3RCO0FBQ0YsQ0FBQztBQUFBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsUUFBQTtBQUVELFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtFQUFBLElBQUEscUJBQUE7RUFDN0IsSUFBSSxLQUFLLENBQUMsc0JBQXNCLEVBQUU7SUFDaEMsTUFBTTtNQUNKLHVCQUF1QjtNQUN2QixlQUFlO01BQ2YsbUJBQW1CO01BQ25CLEdBQUc7SUFDTCxDQUFDLEdBQUcsS0FBSyxDQUFDLHNCQUFzQjtJQUNoQyxLQUFLLENBQUMsYUFBYSxHQUFHO01BQ3BCLElBQUksdUJBQXVCLEdBQ3ZCO1FBQUUsZUFBZSxFQUFFO01BQXdCLENBQUMsR0FDNUMsQ0FBQyxDQUFDLENBQUM7TUFDUCxJQUFJLGVBQWUsR0FBRztRQUFFLE9BQU8sRUFBRTtNQUFnQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7TUFDeEQsSUFBSSxtQkFBbUIsR0FBRztRQUFFLFdBQVcsRUFBRTtNQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7TUFDcEUsR0FBRztJQUNMLENBQUM7SUFDRCxPQUFPLEtBQUssQ0FBQyxzQkFBc0I7RUFDckM7RUFFQSxLQUFBLHFCQUFBLEdBQUksS0FBSyxDQUFDLHFCQUFxQixjQUFBLHFCQUFBLGVBQTNCLHFCQUFBLENBQTZCLHVCQUF1QixFQUFFO0lBQ3hELEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxlQUFlLEdBQ3pDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyx1QkFBdUI7SUFDckQsT0FBTyxLQUFLLENBQUMscUJBQXFCLENBQUMsdUJBQXVCO0VBQzVEO0VBRUEsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0NBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUhBLElBQUEsUUFBQSxHQUllO0VBQ2IsT0FBTztFQUNQLE1BQU0sT0FBTyxDQUFDLHFCQUFxQixFQUFFO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztJQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO0lBQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUM7SUFDdEMsYUFBYSxDQUFDLElBQUksR0FBRyxRQUFRO0lBQzdCLE9BQU8sYUFBYTtFQUN0QjtBQUNGLENBQUM7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7QUFFRCxTQUFTLGNBQWMsQ0FBQyxLQUFLLEVBQUU7RUFDN0IsTUFBTSxtQkFBbUIsR0FBRyxDQUFBLEtBQUssYUFBTCxLQUFLLHVCQUFMLEtBQUssQ0FBRSxtQkFBbUIsS0FBSSxDQUFDLENBQUM7RUFFNUQsTUFBTTtJQUFFO0VBQWtCLENBQUMsR0FBRyxtQkFBbUI7RUFFakQsSUFBSSxTQUFTO0VBQ2IsSUFBSSxVQUFVO0VBQ2Q7RUFDQSxLQUFLLE1BQU0sT0FBTyxJQUFJLGlCQUFpQixFQUFFO0lBQ3ZDLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJO0lBQzNDLFVBQVUsR0FBRyxDQUFDLENBQUM7SUFDZjtJQUNBLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRTtNQUM1QixLQUFLLE1BQU0sS0FBSyxJQUFJLFNBQVMsRUFBRTtRQUM3QixVQUFVLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEtBQUs7TUFDbkM7SUFDRixDQUFDLE1BQU0sSUFDTCxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEtBQ3ZDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDLEVBQzFEO01BQ0E7TUFDQTtNQUNBO01BQ0EsS0FBSyxNQUFNLFlBQVksSUFBSSxTQUFTLEVBQUU7UUFDcEMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxTQUFTLENBQUMsWUFBWSxDQUFDO01BQ3ZFO0lBQ0Y7SUFDQSxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEdBQzdCLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxVQUFVLEdBQUcsU0FBUztFQUMvRDtFQUNBLG1CQUFtQixDQUFDLGlCQUFpQixHQUFHLGlCQUFpQjtFQUV6RCxPQUFPO0lBQ0wsR0FBRyxLQUFLO0lBQ1IsbUJBQW1CLEVBQUU7TUFDbkIsR0FBRztJQUNMO0VBQ0YsQ0FBQztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxREEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsTUFBQSxHQUFBLE9BQUE7QUFFTyxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQSxPQUFBLENBQUEsT0FBQSxHQUFBLE9BQUE7QUFTTyxlQUFlLE9BQU8sQ0FBQyxxQkFHN0IsRUFBRTtFQUNELE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztFQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0VBQ3BDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUM7RUFDdkQsT0FBTyxhQUFhO0FBQ3RCO0FBRUEsU0FBUyxjQUFjLENBQUMsS0FBOEIsRUFBRTtFQUN0RCxJQUNFLENBQUMsSUFBQSxrQkFBVyxFQUFDLEtBQUssRUFBRSxvQkFBb0IsQ0FBQyxJQUN6QyxDQUFDLElBQUEsZUFBUSxFQUFDLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxFQUNuQztJQUNBLE9BQU8sS0FBSztFQUNkO0VBQ0EsTUFBTTtJQUFFO0VBQW1CLENBQUMsR0FBRyxLQUFLO0VBRXBDLE9BQU8sa0JBQWtCLENBQUMsUUFBUTtFQUNsQyxPQUFPLGtCQUFrQixDQUFDLFdBQVc7RUFFckMsT0FBTyxLQUFLO0FBQ2Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUVsQjtBQUNBO0FBQ0E7QUFGQSxJQUFBLFFBQUEsR0FHZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUM3QixPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQUEsSUFBQSxxQkFBQSxFQUFBLGVBQUE7RUFDN0IsSUFDRSxDQUFBLEtBQUssYUFBTCxLQUFLLHdCQUFBLHFCQUFBLEdBQUwsS0FBSyxDQUFFLGtCQUFrQixjQUFBLHFCQUFBLHVCQUF6QixxQkFBQSxDQUEyQixvQ0FBb0MsTUFDL0QsU0FBUyxFQUNUO0lBQ0EsT0FBTyxLQUFLLENBQUMsa0JBQWtCLENBQUMsb0NBQW9DO0VBQ3RFO0VBQ0EsSUFBSSxDQUFBLEtBQUssYUFBTCxLQUFLLHdCQUFBLGVBQUEsR0FBTCxLQUFLLENBQUUsUUFBUSxjQUFBLGVBQUEsdUJBQWYsZUFBQSxDQUFpQix5QkFBeUIsTUFBSyxTQUFTLEVBQUU7SUFDNUQsT0FBTyxLQUFLLENBQUMsUUFBUSxDQUFDLHlCQUF5QjtFQUNqRDtFQUNBLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlCQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFIQSxJQUFBLFFBQUEsR0FJZTtFQUNiLE9BQU87RUFDUCxNQUFNLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRTtJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7SUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztJQUNwQyxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBSTtJQUNoQyxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDO0lBQ3RDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsUUFBUTtJQUM3QixPQUFPLGFBQWE7RUFDdEI7QUFDRixDQUFDO0FBQUEsT0FBQSxDQUFBLE9BQUEsR0FBQSxRQUFBO0FBRUQsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFO0VBQUEsSUFBQSxlQUFBO0VBQzdCLElBQUksQ0FBQSxLQUFLLGFBQUwsS0FBSyx3QkFBQSxlQUFBLEdBQUwsS0FBSyxDQUFFLFFBQVEsY0FBQSxlQUFBLHVCQUFmLGVBQUEsQ0FBaUIsb0JBQW9CLE1BQUssU0FBUyxFQUFFO0lBQ3ZELE9BQU8sS0FBSyxDQUFDLFFBQVEsQ0FBQyxvQkFBb0I7RUFDNUM7RUFFQSxPQUFPLEtBQUs7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLE1BQUEsR0FBQSxPQUFBO0FBRU8sTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsT0FBQTtBQVdPLGVBQWUsT0FBTyxDQUFDLHFCQUc3QixFQUFFO0VBQ0QsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0VBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87RUFDcEMsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQUk7RUFDaEMsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQztFQUN0QyxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7RUFDN0IsT0FBTyxhQUFhO0FBQ3RCOztBQUVBO0FBQ0EsU0FBUyxjQUFjLENBQUMsS0FBOEIsRUFBRTtFQUN0RCxJQUNFLENBQUMsSUFBQSxrQkFBVyxFQUFDLEtBQUssRUFBRSxnQkFBZ0IsQ0FBQyxJQUNyQyxDQUFDLElBQUEsa0JBQVcsRUFBQyxLQUFLLEVBQUUsc0JBQXNCLENBQUMsSUFDM0MsQ0FBQyxJQUFBLGVBQVEsRUFBQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsRUFDckM7SUFDQSxPQUFPLEtBQUs7RUFDZDtFQUNBLE1BQU07SUFBRTtFQUFxQixDQUFDLEdBQUcsS0FBSztFQUV0QyxNQUFNO0lBQUU7RUFBUyxDQUFDLEdBQUcsb0JBQW9CO0VBRXpDLElBQUksQ0FBQyxJQUFBLGVBQVEsRUFBQyxRQUFRLENBQUMsRUFBRTtJQUN2QixPQUFPLEtBQUs7RUFDZDtFQUVBLE1BQU0sVUFBVSxHQUFHLGNBQWM7RUFFakMsS0FBSyxNQUFNLENBQUMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7SUFDN0QsSUFBSSxDQUFDLElBQUEsZUFBUSxFQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBQSxlQUFRLEVBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFO01BQ3hELE9BQU8sS0FBSztJQUNkO0lBQ0E7SUFDQTtJQUNBLElBQUksSUFBSSxHQUFHLENBQUM7SUFDWixJQUFJLEVBQUU7SUFDTixNQUFNO01BQUU7SUFBWSxDQUFDLEdBQUcsT0FBTztJQUMvQjtJQUNBLE1BQU0sa0JBQWtCLEdBQUc7TUFBRSxHQUFHO0lBQVksQ0FBQztJQUM3QyxLQUFLLE1BQU0sQ0FBQyxjQUFjLEVBQUUsVUFBVSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTtNQUN0RTtNQUNBLElBQUksY0FBYyxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsRUFBRTtRQUN6QyxJQUNFLENBQUMsSUFBQSxlQUFRLEVBQUMsVUFBVSxDQUFDLElBQ3JCLENBQUMsSUFBQSxrQkFBVyxFQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsSUFDOUIsQ0FBQyxJQUFBLGtCQUFXLEVBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxFQUNoQztVQUNBLE9BQU8sS0FBSztRQUNkO1FBQ0E7UUFDQSxJQUFJLENBQUMsSUFBQSxrQkFBVyxFQUFDLGtCQUFrQixFQUFFLGFBQWEsQ0FBQyxFQUFFO1VBQ25ELGtCQUFrQixDQUFDLFdBQVcsR0FBRztZQUMvQixPQUFPLEVBQUUsQ0FBQztjQUFFLElBQUksRUFBRSxTQUFTO2NBQUUsS0FBSyxFQUFFLENBQUM7WUFBRSxDQUFDLENBQUM7WUFDekMsT0FBTyxFQUFFLFdBQVc7WUFDcEIsZ0JBQWdCLEVBQUU7VUFDcEIsQ0FBQztRQUNIOztRQUVBO1FBQ0EsSUFBSSxDQUFDLElBQUEsZUFBUSxFQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxFQUFFO1VBQzdDLE9BQU8sS0FBSztRQUNkO1FBRUEsSUFDRSxDQUFDLElBQUEsZUFBTyxFQUNMLGtCQUFrQixDQUFDLFdBQVcsQ0FBNkIsT0FDOUQsQ0FBQyxFQUNEO1VBQ0EsT0FBTyxLQUFLO1FBQ2Q7O1FBRUE7UUFDQSxNQUFNLE1BQU0sR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUM7UUFDdEQsTUFBTSxNQUFNLEdBQ1Qsa0JBQWtCLENBQUMsV0FBVyxDQUM1QixPQUFPLENBQ1YsQ0FBQyxDQUFDO1FBRUosSUFBSSxDQUFDLElBQUEsZUFBUSxFQUFDLE1BQU0sQ0FBQyxFQUFFO1VBQ3JCLE9BQU8sS0FBSztRQUNkO1FBRUEsSUFDRSxDQUFDLElBQUEsa0JBQVcsRUFBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLElBQzVCLE1BQU0sQ0FBQyxJQUFJLEtBQUssU0FBUyxJQUN6QixDQUFDLElBQUEsa0JBQVcsRUFBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLElBQzdCLENBQUMsSUFBQSxlQUFRLEVBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUN2QjtVQUNBLE9BQU8sS0FBSztRQUNkO1FBQ0EsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFFekIsSUFDRSxPQUFPLFVBQVUsQ0FBQyxJQUFJLEtBQUssUUFBUSxJQUNuQyxPQUFPLFVBQVUsQ0FBQyxFQUFFLEtBQUssUUFBUSxFQUNqQztVQUNBLE9BQU8sS0FBSztRQUNkOztRQUVBO1FBQ0EsSUFBSSxVQUFVLENBQUMsSUFBSSxHQUFHLElBQUksRUFBRTtVQUMxQixJQUFJLEdBQUcsVUFBVSxDQUFDLElBQUk7VUFDdEIsRUFBRSxHQUFHLFVBQVUsQ0FBQyxFQUFFO1FBQ3BCOztRQUVBO1FBQ0EsT0FBTyxrQkFBa0IsQ0FBQyxjQUFjLENBQUM7TUFDM0M7SUFDRjs7SUFFQTtJQUNBO0lBQ0EsSUFBSSxrQkFBa0IsQ0FBQyxXQUFXLEVBQUU7TUFDakMsa0JBQWtCLENBQUMsV0FBVyxDQUE2QixJQUFJLEdBQUcsSUFBSTtNQUN0RSxrQkFBa0IsQ0FBQyxXQUFXLENBQTZCLEVBQUUsR0FBRyxFQUFFO01BQ25FLE9BQU8sQ0FBQyxXQUFXLEdBQUcsa0JBQWtCO0lBQzFDO0VBQ0Y7RUFFQSxPQUFPLEtBQUs7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0lBLElBQUEsVUFBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUE7QUFDQSxJQUFBLFNBQUEsT0FBQSxDQUFBLGlCQUFBLENBQUEsQ0FBQTtBQUNBLElBQUEsUUFBQSxPQUFBLENBQUEsTUFBQSxDQUFBLENBQUE7QUFFTyxNQUFNLFVBQVUsRUFBRSxDQUFBOzs7Ozs7Ozs7Ozs7QUFFekIsT0FBQSxRQUFBLEdBQUEsT0FBQSxDQUFBO0FBVU8sOENBR0o7RUFDRCxNQUFNLGdCQUFnQixDQUFBLENBQUEsRUFBQSxPQUFBLFVBQVMsRUFBQyxxQkFBcUIsQ0FBQyxDQUFBO0VBQ3RELGFBQWEsS0FBSyxRQUFRLEdBQUcsT0FBTyxDQUFBO0VBQ3BDLGFBQWEsS0FBSyxHQUFHLGNBQWMsQ0FBQyxhQUFhLEtBQUssQ0FBQyxDQUFBO0VBQ3ZELE9BQU8sYUFBYSxDQUFBO0NBQ3RCO0FBRUEsK0JBQXdEO0VBQ3RELElBQ0UsQ0FBQyxDQUFBLENBQUEsRUFBQSxNQUFBLFlBQVcsRUFBQyxLQUFLLEVBQUUsdUJBQXVCLENBQUMsSUFDNUMsQ0FBQyxDQUFBLENBQUEsRUFBQSxNQUFBLFNBQVEsRUFBQyxLQUFLLHNCQUFzQixDQUFDLElBQ3RDLENBQUMsQ0FBQSxDQUFBLEVBQUEsTUFBQSxTQUFRLEVBQUMsS0FBSyxrQkFBa0IsQ0FBQyxJQUNsQyxDQUFDLENBQUEsQ0FBQSxFQUFBLE1BQUEsWUFBVyxFQUFDLEtBQUssc0JBQXNCLEVBQUUsdUJBQXVCLENBQUMsSUFDbEUsQ0FBQyxLQUFLLFFBQVEsQ0FBQyxLQUFLLHNCQUFzQixzQkFBc0IsQ0FBQyxJQUNqRSxDQUFDLEtBQUssc0JBQXNCLHNCQUFzQixNQUFNLENBQUMsTUFBQSxTQUFRLENBQUMsRUFDbEU7SUFDQSxPQUFPLEtBQUssQ0FBQTtHQUNkO0VBQ0EsTUFBTTs7O0dBQTRDLEdBQUcsS0FBSyxDQUFBO0VBQzFELE1BQU07O0dBQXlCLEdBQUcscUJBQXFCLENBQUE7RUFDdkQsSUFBSSxDQUFDLEtBQUssUUFBUSxDQUFDLHFCQUFxQixDQUFDLEVBQUU7SUFDekMsT0FBTyxLQUFLLENBQUE7R0FDZDtFQUVBLE1BQU0sd0JBQXdCLHFCQUFxQixPQUFPLENBQ3hELDJCQUVFOzs7Ozs7R0FBK0MsS0FDNUM7SUFDSCxNQUFNLHlCQUF5QixDQUFBLENBQUEsRUFBQSxLQUFBLEdBQUUsR0FBRSxDQUFBO0lBQ25DLE9BQU87TUFDTCxHQUFHLHdCQUF3QjtNQUMzQixDQUFDLHNCQUFzQixHQUFHO1FBQ3hCLE1BQU07UUFDTixPQUFPO1FBQ1AsTUFBTTtRQUNOLFFBQVE7UUFDUixRQUFBO09BQ0Y7S0FDRCxDQUFBO0dBQ0YsRUFDRCxFQUNGLENBQUMsQ0FBQTtFQUVELE9BQU8scUJBQXFCLHNCQUFzQixDQUFBO0VBRWxELE9BQU87SUFDTCxHQUFHLEtBQUs7SUFDUixtQkFBbUI7TUFDakIsR0FBRyxpQkFBaUI7TUFDcEIscUJBQUE7S0FDRDtJQUNELHVCQUF1QjtNQUNyQixHQUFHLHFCQUFBO0tBQ0w7R0FDRCxDQUFBO0NBQ0g7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzRUEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsTUFBQSxHQUFBLE9BQUE7QUFFTyxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsT0FBQTtBQVVPLGVBQWUsT0FBTyxDQUFDLHFCQUc3QixFQUFFO0VBQ0QsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0VBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87RUFDcEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQztFQUN2RCxPQUFPLGFBQWE7QUFDdEI7QUFFQSxTQUFTLGNBQWMsQ0FBQyxLQUE4QixFQUFFO0VBQ3RELElBQUksQ0FBQyxJQUFBLGVBQVEsRUFBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsRUFBRTtJQUN0QyxPQUFPLEtBQUs7RUFDZDtFQUNBLE1BQU07SUFBRTtFQUFrQixDQUFDLEdBQUcsS0FBSztFQUVuQyxJQUFJLENBQUMsSUFBQSxlQUFRLEVBQUMsaUJBQWlCLENBQUMscUJBQXFCLENBQUMsRUFBRTtJQUN0RCxPQUFPLEtBQUs7RUFDZDtFQUVBLE1BQU07SUFBRTtFQUFzQixDQUFDLEdBQUcsaUJBQWlCO0VBRW5ELE1BQU0sd0JBQWlFLEdBQUcsQ0FBQyxDQUFDO0VBRTVFLEtBQUssTUFBTSxzQkFBc0IsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEVBQUU7SUFDdkUsTUFBTSxvQkFBb0IsR0FBRyxxQkFBcUIsQ0FBQyxzQkFBc0IsQ0FBQztJQUMxRSxJQUFJLENBQUMsSUFBQSxlQUFRLEVBQUMsb0JBQW9CLENBQUMsRUFBRTtNQUNuQyxPQUFPLEtBQUs7SUFDZDtJQUNBLHdCQUF3QixDQUFDLHNCQUFzQixDQUFDLEdBQUc7TUFDakQsR0FBRyxvQkFBb0I7TUFDdkIsRUFBRSxFQUFFO0lBQ04sQ0FBQztFQUNIO0VBRUEsT0FBTztJQUNMLEdBQUcsS0FBSztJQUNSLGlCQUFpQixFQUFFO01BQ2pCLEdBQUcsaUJBQWlCO01BQ3BCLHFCQUFxQixFQUFFO0lBQ3pCO0VBQ0YsQ0FBQztBQUNIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6REEsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsTUFBQSxHQUFBLE9BQUE7QUFFTyxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQSxPQUFBLENBQUEsT0FBQSxHQUFBLE9BQUE7QUFTTyxlQUFlLE9BQU8sQ0FBQyxxQkFHN0IsRUFBRTtFQUNELE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztFQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0VBQ3BDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUM7RUFDdkQsT0FBTyxhQUFhO0FBQ3RCO0FBRUEsU0FBUyxjQUFjLENBQUMsS0FBOEIsRUFBRTtFQUN0RCxJQUNFLENBQUMsSUFBQSxrQkFBVyxFQUFDLEtBQUssRUFBRSxtQkFBbUIsQ0FBQyxJQUN4QyxDQUFDLElBQUEsZUFBUSxFQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUNsQyxDQUFDLElBQUEsa0JBQVcsRUFBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUUsU0FBUyxDQUFDLEVBQ2hEO0lBQ0EsT0FBTyxLQUFLO0VBQ2Q7RUFFQSxNQUFNLGlCQUFpQixHQUFHO0lBQUUsR0FBRyxLQUFLLENBQUM7RUFBa0IsQ0FBQztFQUV4RCxJQUFJLGlCQUFpQixDQUFDLE9BQU8sS0FBSyxTQUFTLEVBQUU7SUFDM0MsaUJBQWlCLENBQUMsU0FBUyxHQUFHLElBQUk7SUFDbEMsaUJBQWlCLENBQUMsYUFBYSxHQUFHLFNBQVM7RUFDN0MsQ0FBQyxNQUFNO0lBQ0wsaUJBQWlCLENBQUMsU0FBUyxHQUFHLGlCQUFpQixDQUFDLE9BQU87SUFDdkQsaUJBQWlCLENBQUMsYUFBYSxHQUFHLFdBQVc7RUFDL0M7RUFFQSxPQUFPLGlCQUFpQixDQUFDLE9BQU87RUFFaEMsT0FBTztJQUFFLEdBQUcsS0FBSztJQUFFO0VBQWtCLENBQUM7QUFDeEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlDQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBQ0EsSUFBQSxNQUFBLEdBQUEsT0FBQTtBQUVPLE1BQU0sT0FBTyxHQUFHLEVBQUU7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBLE9BQUEsQ0FBQSxPQUFBLEdBQUEsT0FBQTtBQVNPLGVBQWUsT0FBTyxDQUFDLHFCQUc3QixFQUFFO0VBQ0QsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0VBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87RUFDcEMsYUFBYSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQztFQUN2RCxPQUFPLGFBQWE7QUFDdEI7QUFFQSxTQUFTLGNBQWMsQ0FBQyxLQUE4QixFQUFFO0VBQ3RELElBQUksQ0FBQyxJQUFBLGVBQVEsRUFBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsRUFBRTtJQUN0QyxPQUFPLEtBQUs7RUFDZDtFQUVBLE9BQU8sS0FBSyxDQUFDLGlCQUFpQixDQUFDLHFCQUFxQjtFQUVwRCxPQUFPLEtBQUs7QUFDZDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaENBLElBQUEsTUFBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBRU8sTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkEsT0FBQSxDQUFBLE9BQUEsR0FBQSxPQUFBO0FBU08sZUFBZSxPQUFPLENBQUMscUJBRzdCLEVBQUU7RUFDRCxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFTLEVBQUMscUJBQXFCLENBQUM7RUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztFQUNwQyxhQUFhLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDO0VBQ3ZELE9BQU8sYUFBYTtBQUN0QjtBQUVBLFNBQVMsY0FBYyxDQUFDLEtBQThCLEVBQUU7RUFDdEQsSUFDRSxJQUFBLGtCQUFXLEVBQUMsS0FBSyxFQUFFLG1CQUFtQixDQUFDLElBQ3ZDLElBQUEsZUFBUSxFQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUNqQyxJQUFBLGtCQUFXLEVBQUMsS0FBSyxDQUFDLGlCQUFpQixFQUFFLFVBQVUsQ0FBQyxFQUNoRDtJQUNBLE1BQU0sc0JBQXNCLEdBQUcsS0FBSyxDQUFDLGlCQUFpQjtJQUN0RCxzQkFBc0IsQ0FBQyxjQUFjLEdBQUcsc0JBQXNCLENBQUMsUUFBUTtJQUN2RSxPQUFPLHNCQUFzQixDQUFDLFFBQVE7SUFFdEMsT0FBTztNQUNMLEdBQUcsS0FBSztNQUNSLGlCQUFpQixFQUFFO0lBQ3JCLENBQUM7RUFDSDtFQUNBLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q0EsSUFBQSxNQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsT0FBQSxHQUFBLE9BQUE7QUFFTyxNQUFNLE9BQU8sR0FBRyxFQUFFOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQSxPQUFBLENBQUEsT0FBQSxHQUFBLE9BQUE7QUFTTyxlQUFlLE9BQU8sQ0FBQyxxQkFHN0IsRUFBRTtFQUNELE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztFQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0VBQ3BDLGFBQWEsQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUM7RUFDdkQsT0FBTyxhQUFhO0FBQ3RCO0FBRUEsU0FBUyxjQUFjLENBQUMsS0FBOEIsRUFBRTtFQUN0RCxJQUFJLENBQUMsSUFBQSxlQUFRLEVBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQUU7SUFDckMsT0FBTyxLQUFLO0VBQ2Q7RUFFQSxPQUFPLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxlQUFlO0VBRTdDLE9BQU8sS0FBSztBQUNkOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ0EsSUFBQSxNQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsZUFBQSxHQUFBLE9BQUE7QUFDQSxJQUFBLE9BQUEsR0FBQSxPQUFBO0FBT08sTUFBTSxPQUFPLEdBQUcsRUFBRTs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQSxPQUFBLENBQUEsT0FBQSxHQUFBLE9BQUE7QUFnQk8sZUFBZSxPQUFPLENBQzNCLHFCQUFvQyxFQUNaO0VBQ3hCLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQVMsRUFBQyxxQkFBcUIsQ0FBQztFQUN0RCxhQUFhLENBQUMsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO0VBQ3BDLFdBQVcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDO0VBQy9CLE9BQU8sYUFBYTtBQUN0QjtBQUVBLFNBQVMsV0FBVyxDQUFDLEtBQThCLEVBQVE7RUFDekQsSUFBSSxJQUFBLGtCQUFXLEVBQUMsS0FBSyxFQUFFLGVBQWUsQ0FBQyxJQUFJLElBQUEsZUFBUSxFQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsRUFBRTtJQUN4RSxNQUFNLGtCQUFrQixHQUFHLEtBQUssQ0FBQyxhQUFhOztJQUU5QztJQUNBLElBQ0UsSUFBQSxrQkFBVyxFQUFDLGtCQUFrQixFQUFFLGlCQUFpQixDQUFDLElBQ2xELElBQUEsZUFBUSxFQUFDLGtCQUFrQixDQUFDLGVBQWUsQ0FBQyxFQUM1QztNQUNBLE1BQU07UUFBRTtNQUFnQixDQUFDLEdBQUcsa0JBQWtCO01BRTlDLElBQ0UsTUFBTSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxLQUFLLENBQUUsT0FBTyxJQUN6QyxJQUFBLGVBQVEsRUFBQyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQ25DLENBQUMsRUFDRDtRQUNBLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUMsT0FBTyxDQUFFLE9BQU8sSUFBSztVQUNoRCxNQUFNLHFCQUFxQixHQUFHLGVBQWUsQ0FBQyxPQUFPLENBQUM7VUFFdEQsSUFBSSxJQUFBLGVBQVEsRUFBQyxxQkFBcUIsQ0FBQyxFQUFFO1lBQ25DLGVBQWUsQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFBLGVBQU8sRUFDaEMscUJBQXFCLEVBQ3JCLENBQUMsQ0FBQyxFQUFFLE9BQWUsS0FBSyxLQUFLLENBQUMsT0FBTyxDQUN2QyxDQUFDO1VBQ0g7UUFDRixDQUFDLENBQUM7TUFDSjtJQUNGOztJQUVBO0lBQ0EsSUFDRSxJQUFBLGtCQUFXLEVBQUMsa0JBQWtCLEVBQUUsU0FBUyxDQUFDLElBQzFDLElBQUEsZUFBUSxFQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxFQUNwQztNQUNBLE1BQU07UUFBRTtNQUFRLENBQUMsR0FBRyxrQkFBa0I7TUFFdEMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBRSxPQUFPLElBQUssSUFBQSxlQUFRLEVBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUN2RSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBRSxPQUFPLElBQUs7VUFDeEMsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztVQUV0QyxJQUFJLElBQUEsZUFBUSxFQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQzNCLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFBLGVBQU8sRUFBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLEVBQUUsT0FBZSxLQUMzRCxLQUFLLENBQUMsT0FBTyxDQUNmLENBQUM7VUFDSDtRQUNGLENBQUMsQ0FBQztNQUNKO0lBQ0Y7SUFFQSxLQUFLLENBQUMsYUFBYSxHQUFHLGtCQUFrQjtFQUMxQztFQUVBLElBQ0UsSUFBQSxrQkFBVyxFQUFDLEtBQUssRUFBRSxxQkFBcUIsQ0FBQyxJQUN6QyxJQUFBLGVBQVEsRUFBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsRUFDbkM7SUFDQSxNQUFNLHdCQUF3QixHQUFHLEtBQUssQ0FBQyxtQkFBbUI7O0lBRTFEO0lBQ0EsSUFDRSxJQUFBLGtCQUFXLEVBQUMsd0JBQXdCLEVBQUUsbUJBQW1CLENBQUMsSUFDMUQsSUFBQSxlQUFRLEVBQUMsd0JBQXdCLENBQUMsaUJBQWlCLENBQUMsRUFDcEQ7TUFDQSx3QkFBd0IsQ0FBQyxpQkFBaUIsR0FBRyxJQUFBLGVBQU8sRUFDbEQsd0JBQXdCLENBQUMsaUJBQWlCLEVBQzFDLENBQUMsQ0FBQyxFQUFFLE9BQWUsS0FBSyxLQUFLLENBQUMsT0FBTyxDQUN2QyxDQUFDO0lBQ0g7RUFDRjtFQUVBLElBQ0UsSUFBQSxrQkFBVyxFQUFDLEtBQUssRUFBRSxrQkFBa0IsQ0FBQyxJQUN0QyxJQUFBLGVBQVEsRUFBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsRUFDaEM7SUFDQSxNQUFNLHFCQUFxQixHQUFHLEtBQUssQ0FBQyxnQkFBZ0I7O0lBRXBEO0lBQ0EsSUFDRSxJQUFBLGtCQUFXLEVBQUMscUJBQXFCLEVBQUUsV0FBVyxDQUFDLElBQy9DLElBQUEsZUFBUSxFQUFDLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxFQUN6QztNQUNBLE1BQU07UUFBRTtNQUFVLENBQUMsR0FBRyxxQkFBcUI7TUFFM0MscUJBQXFCLENBQUMsU0FBUyxHQUFHLElBQUEsZUFBTyxFQUN2QyxTQUFTLEVBQ1QsQ0FBQyxDQUFDLEVBQUUsT0FBZSxLQUFLLEtBQUssQ0FBQyxPQUFPLENBQ3ZDLENBQUM7SUFDSDs7SUFFQTtJQUNBLElBQ0UsSUFBQSxrQkFBVyxFQUFDLHFCQUFxQixFQUFFLGtCQUFrQixDQUFDLElBQ3RELElBQUEsZUFBUSxFQUFDLHFCQUFxQixDQUFDLGdCQUFnQixDQUFDLEVBQ2hEO01BQ0EsTUFBTTtRQUFFO01BQWlCLENBQUMsR0FBRyxxQkFBcUI7TUFFbEQscUJBQXFCLENBQUMsZ0JBQWdCLEdBQUcsSUFBQSxlQUFPLEVBQzlDLGdCQUFnQixFQUNoQixDQUFDLENBQUMsRUFBRSxPQUFlLEtBQUssS0FBSyxDQUFDLE9BQU8sQ0FDdkMsQ0FBQztJQUNIOztJQUVBO0lBQ0EsSUFDRSxJQUFBLGtCQUFXLEVBQUMscUJBQXFCLEVBQUUsbUJBQW1CLENBQUMsSUFDdkQsSUFBQSxlQUFRLEVBQUMscUJBQXFCLENBQUMsaUJBQWlCLENBQUMsRUFDakQ7TUFDQSxNQUFNO1FBQUU7TUFBa0IsQ0FBQyxHQUFHLHFCQUFxQjtNQUVuRCxxQkFBcUIsQ0FBQyxpQkFBaUIsR0FBRyxJQUFBLGVBQU8sRUFDL0MsaUJBQWlCLEVBQ2pCLENBQUMsQ0FBQyxFQUFFLE9BQWUsS0FBSyxLQUFLLENBQUMsT0FBTyxDQUN2QyxDQUFDO0lBQ0g7SUFFQSxLQUFLLENBQUMsZ0JBQWdCLEdBQUcscUJBQXFCO0VBQ2hEO0FBQ0Y7QUFFQSxTQUFTLEtBQUssQ0FBQyxLQUEyQixFQUFPO0VBQy9DLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLElBQUEsd0JBQWlCLEVBQUMsS0FBSyxDQUFDLEVBQUU7SUFDekQsT0FBTyxLQUFLO0VBQ2Q7RUFDQSxNQUFNLFNBQVMsR0FBRyxrQkFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FDNUIsS0FBSyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsR0FDbEIsSUFBSSxrQkFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7RUFDN0MsT0FBUSxLQUFJLFNBQVUsRUFBQztBQUN6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuS0EsSUFBQSxPQUFBLEdBQUEsT0FBQTtBQUNBLElBQUEsWUFBQSxHQUFBLE9BQUE7QUFFZSxTQUFTLFdBQVcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRTtFQUM5RCxPQUFPLFVBQVUscUJBQXFCLEVBQUU7SUFDdEMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBUyxFQUFDLHFCQUFxQixDQUFDO0lBQ3RELGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU87SUFDcEMsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUFJO01BQ2hDLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQztNQUN6RCxhQUFhLENBQUMsSUFBSSxHQUFHLFFBQVE7SUFDL0IsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFO01BQ1osT0FBTyxDQUFDLElBQUksQ0FBRSx1QkFBc0IsT0FBUSxHQUFFLEdBQUcsQ0FBQyxLQUFNLEVBQUMsQ0FBQztJQUM1RDtJQUNBLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7RUFDdkMsQ0FBQztBQUNIO0FBRUEsU0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUU7RUFDaEQsTUFBTSxRQUFRLEdBQUcsS0FBSztFQUN0QixNQUFNO0lBQUU7RUFBc0IsQ0FBQyxHQUFHLFFBQVE7RUFDMUMsSUFBSSxxQkFBcUIsSUFBSSxxQkFBcUIsQ0FBQyxZQUFZLEVBQUU7SUFDL0QsTUFBTTtNQUFFO0lBQWEsQ0FBQyxHQUFHLHFCQUFxQjtJQUU5QyxRQUFRLENBQUMscUJBQXFCLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUUsTUFBTSxJQUFLO01BQ3pFLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQUU7UUFDdEIsT0FBTyxNQUFNO01BQ2Y7TUFFQSxNQUFNLENBQUMsTUFBTSxHQUFHLDhCQUFpQixDQUFDLE1BQU07TUFDeEMsTUFBTSxDQUFDLEdBQUcsR0FBRztRQUNYLE9BQU8sRUFBRSxNQUFNO1FBQ2YsSUFBSSxFQUFHLGdEQUErQyxNQUFPO01BQy9ELENBQUM7TUFFRCxPQUFPLE1BQU07SUFDZixDQUFDLENBQUM7RUFDSjtFQUNBLE9BQU8sUUFBUTtBQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQ0EsSUFBQSxDQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxFQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxFQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxFQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxFQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxFQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxFQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxFQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxFQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxJQUFBLEdBQUEsdUJBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxHQUFBLEdBQUEsc0JBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxJQUFBLEdBQUEsdUJBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxJQUFBLEdBQUEsdUJBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxJQUFBLEdBQUEsdUJBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxJQUFBLEdBQUEsdUJBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxJQUFBLEdBQUEsdUJBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxJQUFBLEdBQUEsdUJBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxJQUFBLEdBQUEsdUJBQUEsQ0FBQSxPQUFBO0FBQ0EsSUFBQSxJQUFBLEdBQUEsdUJBQUEsQ0FBQSxPQUFBO0FBQThCLFNBQUEseUJBQUEsV0FBQSxlQUFBLE9BQUEsa0NBQUEsaUJBQUEsT0FBQSxPQUFBLFFBQUEsZ0JBQUEsT0FBQSxPQUFBLFlBQUEsd0JBQUEsWUFBQSxDQUFBLFdBQUEsV0FBQSxXQUFBLEdBQUEsZ0JBQUEsR0FBQSxpQkFBQSxLQUFBLFdBQUE7QUFBQSxTQUFBLHdCQUFBLEdBQUEsRUFBQSxXQUFBLFNBQUEsV0FBQSxJQUFBLEdBQUEsSUFBQSxHQUFBLENBQUEsVUFBQSxXQUFBLEdBQUEsUUFBQSxHQUFBLG9CQUFBLEdBQUEsd0JBQUEsR0FBQSw0QkFBQSxPQUFBLEVBQUEsR0FBQSxVQUFBLEtBQUEsR0FBQSx3QkFBQSxDQUFBLFdBQUEsT0FBQSxLQUFBLElBQUEsS0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLFlBQUEsS0FBQSxDQUFBLEdBQUEsQ0FBQSxHQUFBLFNBQUEsTUFBQSxXQUFBLHFCQUFBLEdBQUEsTUFBQSxDQUFBLGNBQUEsSUFBQSxNQUFBLENBQUEsd0JBQUEsV0FBQSxHQUFBLElBQUEsR0FBQSxRQUFBLEdBQUEsa0JBQUEsTUFBQSxDQUFBLFNBQUEsQ0FBQSxjQUFBLENBQUEsSUFBQSxDQUFBLEdBQUEsRUFBQSxHQUFBLFNBQUEsSUFBQSxHQUFBLHFCQUFBLEdBQUEsTUFBQSxDQUFBLHdCQUFBLENBQUEsR0FBQSxFQUFBLEdBQUEsY0FBQSxJQUFBLEtBQUEsSUFBQSxDQUFBLEdBQUEsSUFBQSxJQUFBLENBQUEsR0FBQSxLQUFBLE1BQUEsQ0FBQSxjQUFBLENBQUEsTUFBQSxFQUFBLEdBQUEsRUFBQSxJQUFBLFlBQUEsTUFBQSxDQUFBLEdBQUEsSUFBQSxHQUFBLENBQUEsR0FBQSxTQUFBLE1BQUEsQ0FBQSxPQUFBLEdBQUEsR0FBQSxNQUFBLEtBQUEsSUFBQSxLQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsRUFBQSxNQUFBLFlBQUEsTUFBQTtBQUFBLFNBQUEsdUJBQUEsR0FBQSxXQUFBLEdBQUEsSUFBQSxHQUFBLENBQUEsVUFBQSxHQUFBLEdBQUEsS0FBQSxPQUFBLEVBQUEsR0FBQTtBQTdGOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQTBGQSxNQUFNLFVBQVUsR0FBRyxDQUNqQixTQUFJLEVBQ0osVUFBSSxFQUNKLFVBQUksRUFDSixVQUFJLEVBQ0osVUFBSSxFQUNKLFVBQUksRUFDSixVQUFJLEVBQ0osVUFBSSxFQUNKLFVBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osV0FBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osSUFBSSxFQUNKLFdBQUksRUFDSixXQUFJLEVBQ0osSUFBSSxFQUNKLElBQUksRUFDSixJQUFJLEVBQ0osSUFBSSxFQUNKLElBQUksRUFDSixJQUFJLEVBQ0osSUFBSSxFQUNKLElBQUksQ0FDTDtBQUFDLElBQUEsUUFBQSxHQUVhLFVBQVU7QUFBQSxPQUFBLENBQUEsT0FBQSxHQUFBLFFBQUE7Ozs7Ozs7Ozs7Ozs7O0FDekx6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoZUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDcFBBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN2VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdlRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ3pYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JHQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDelhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDckdBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2g2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3ROQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDM1dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDdlhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUMzb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNwaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNwdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVPQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDclhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzVnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNU9BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3JRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYmFja2dyb3VuZC0xLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUodmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3Qgc2FmZVZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAodmVyc2lvbmVkRGF0YSk7XHJcbiAgICBzYWZlVmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnR5cGUgIT09ICdycGMnKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzYWZlVmVyc2lvbmVkRGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoIChzYWZlVmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQpIHtcclxuICAgICAgICBjYXNlICdodHRwczovL3Rlc3RycGMubWV0YW1hc2suaW8vJzpcclxuICAgICAgICAgIHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAndGVzdG5ldCcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnaHR0cHM6Ly9ycGMubWV0YW1hc2suaW8vJzpcclxuICAgICAgICAgIHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnbWFpbm5ldCcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gTm8gZGVmYXVsdFxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgIC8vIGVtcHR5XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNhZmVWZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gbW92ZXMgc3RhdGUgZnJvbSB0aGUgZmxhdCBzdGF0ZSB0cmllIGludG8gS2V5cmluZ0NvbnRyb2xsZXIgc3Vic3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDU7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHNlbGVjdFN1YnN0YXRlRm9yS2V5cmluZ0NvbnRyb2xsZXIoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjNSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gc2VsZWN0U3Vic3RhdGVGb3JLZXlyaW5nQ29udHJvbGxlcihzdGF0ZSkge1xyXG4gIGNvbnN0IHsgY29uZmlnIH0gPSBzdGF0ZTtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgS2V5cmluZ0NvbnRyb2xsZXI6IHtcclxuICAgICAgdmF1bHQ6IHN0YXRlLnZhdWx0LFxyXG4gICAgICBzZWxlY3RlZEFjY291bnQ6IGNvbmZpZy5zZWxlY3RlZEFjY291bnQsXHJcbiAgICAgIHdhbGxldE5pY2tuYW1lczogc3RhdGUud2FsbGV0Tmlja25hbWVzLFxyXG4gICAgfSxcclxuICB9O1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS52YXVsdDtcclxuICBkZWxldGUgbmV3U3RhdGUud2FsbGV0Tmlja25hbWVzO1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb25maWcuc2VsZWN0ZWRBY2NvdW50O1xyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vdmVzIEtleXJpbmdDb250cm9sbGVyLnNlbGVjdGVkQWRkcmVzcyB0byBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2VsZWN0ZWRBZGRyZXNzXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSBtaWdyYXRlU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gbWlncmF0ZVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3Qga2V5cmluZ1N1YnN0YXRlID0gc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXI7XHJcblxyXG4gIC8vIGFkZCBuZXcgc3RhdGVcclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XHJcbiAgICAgIHNlbGVjdGVkQWRkcmVzczoga2V5cmluZ1N1YnN0YXRlLnNlbGVjdGVkQWNjb3VudCxcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gcm0gb2xkIHN0YXRlXHJcbiAgZGVsZXRlIG5ld1N0YXRlLktleXJpbmdDb250cm9sbGVyLnNlbGVjdGVkQWNjb3VudDtcclxuXHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsIi8qXHJcblxyXG5UaGlzIG1pZ3JhdGlvbiBicmVha3Mgb3V0IHRoZSBUcmFuc2FjdGlvbk1hbmFnZXIgc3Vic3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIFRyYW5zYWN0aW9uTWFuYWdlcjoge1xyXG4gICAgICB0cmFuc2FjdGlvbnM6IHN0YXRlLnRyYW5zYWN0aW9ucyB8fCBbXSxcclxuICAgICAgZ2FzTXVsdGlwbGllcjogc3RhdGUuZ2FzTXVsdGlwbGllciB8fCAxLFxyXG4gICAgfSxcclxuICB9O1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS50cmFuc2FjdGlvbnM7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLmdhc011bHRpcGxpZXI7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gYnJlYWtzIG91dCB0aGUgTm90aWNlQ29udHJvbGxlciBzdWJzdGF0ZVxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gODtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgTm90aWNlQ29udHJvbGxlcjoge1xyXG4gICAgICBub3RpY2VzTGlzdDogc3RhdGUubm90aWNlc0xpc3QgfHwgW10sXHJcbiAgICB9LFxyXG4gIH07XHJcbiAgZGVsZXRlIG5ld1N0YXRlLm5vdGljZXNMaXN0O1xyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIGJyZWFrcyBvdXQgdGhlIEN1cnJlbmN5Q29udHJvbGxlciBzdWJzdGF0ZVxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCwgbWVyZ2UgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBtZXJnZSh7fSwgc3RhdGUsIHtcclxuICAgIEN1cnJlbmN5Q29udHJvbGxlcjoge1xyXG4gICAgICBjdXJyZW50Q3VycmVuY3k6IHN0YXRlLmN1cnJlbnRGaWF0IHx8IHN0YXRlLmZpYXRDdXJyZW5jeSB8fCAnVVNEJyxcclxuICAgICAgY29udmVyc2lvblJhdGU6IHN0YXRlLmNvbnZlcnNpb25SYXRlLFxyXG4gICAgICBjb252ZXJzaW9uRGF0ZTogc3RhdGUuY29udmVyc2lvbkRhdGUsXHJcbiAgICB9LFxyXG4gIH0pO1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jdXJyZW50RmlhdDtcclxuICBkZWxldGUgbmV3U3RhdGUuZmlhdEN1cnJlbmN5O1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb252ZXJzaW9uUmF0ZTtcclxuICBkZWxldGUgbmV3U3RhdGUuY29udmVyc2lvbkRhdGU7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gYnJlYWtzIG91dCB0aGUgU2hhcGVTaGlmdENvbnRyb2xsZXIgc3Vic3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAsIG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxMDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IG1lcmdlKHt9LCBzdGF0ZSwge1xyXG4gICAgU2hhcGVTaGlmdENvbnRyb2xsZXI6IHtcclxuICAgICAgc2hhcGVTaGlmdFR4TGlzdDogc3RhdGUuc2hhcGVTaGlmdFR4TGlzdCB8fCBbXSxcclxuICAgIH0sXHJcbiAgfSk7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLnNoYXBlU2hpZnRUeExpc3Q7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0aGUgZGlzY2FpbWVyIHN0YXRlIGZyb20gb3VyIGFwcCwgd2hpY2ggd2FzIGludGVncmF0ZWQgaW50byBvdXIgbm90aWNlcy5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDExO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLlRPU0hhc2g7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLmlzRGlzY2xhaW1lckNvbmZpcm1lZDtcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vZGlmaWVzIG91ciBub3RpY2VzIHRvIGRlbGV0ZSB0aGVpciBib2R5IGFmdGVyIGJlaW5nIHJlYWQuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxMjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG4gIG5ld1N0YXRlLk5vdGljZUNvbnRyb2xsZXIubm90aWNlc0xpc3QuZm9yRWFjaCgobm90aWNlKSA9PiB7XHJcbiAgICBpZiAobm90aWNlLnJlYWQpIHtcclxuICAgICAgbm90aWNlLmJvZHkgPSAnJztcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vZGlmaWVzIHRoZSBuZXR3b3JrIGNvbmZpZyBmcm9tIGFtYmlndW91cyAndGVzdG5ldCcgdG8gZXhwbGljaXQgJ3JvcHN0ZW4nXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxMztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG4gIGNvbnN0IHsgY29uZmlnIH0gPSBuZXdTdGF0ZTtcclxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5wcm92aWRlcikge1xyXG4gICAgaWYgKGNvbmZpZy5wcm92aWRlci50eXBlID09PSAndGVzdG5ldCcpIHtcclxuICAgICAgbmV3U3RhdGUuY29uZmlnLnByb3ZpZGVyLnR5cGUgPSAncm9wc3Rlbic7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyBwcm92aWRlciBmcm9tIGNvbmZpZyBhbmQgbW92ZXMgaXQgdG9vIE5ldHdvcmtDb250cm9sbGVyLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMTQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlciA9IHt9O1xyXG4gIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyID0gbmV3U3RhdGUuY29uZmlnLnByb3ZpZGVyO1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb25maWcucHJvdmlkZXI7XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsIi8qXHJcblxyXG5UaGlzIG1pZ3JhdGlvbiBzZXRzIHRyYW5zYWN0aW9ucyB3aXRoIHRoZSAnR2F2ZSB1cCBzdWJtaXR0aW5nIHR4LicgZXJyIG1lc3NhZ2VcclxudG8gYSAnZmFpbGVkJyBzdGF0ZWRcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXR1cyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDE1O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xyXG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgaWYgKCF0eE1ldGEuZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgfSBlbHNlIGlmICh0eE1ldGEuZXJyLm1lc3NhZ2UgPT09ICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJykge1xyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdpdGggdGhlICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJyBlcnIgbWVzc2FnZVxyXG50byBhICdmYWlsZWQnIHN0YXRlZFxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMTY7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XHJcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xyXG5cclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgaWYgKCF0eE1ldGEuZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHhNZXRhLmVyciA9PT0gJ3RyYW5zYWN0aW9uIHdpdGggdGhlIHNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZC4nXHJcbiAgICAgICkge1xyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQ7XHJcbiAgICAgICAgZGVsZXRlIHR4TWV0YS5lcnI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdobyB3ZXJlIHJldHJpZWQgYW5kIG1hcmtlZCBhcyBmYWlsZWQgdG8gc3VibWl0dGVkXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxNztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcclxuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XHJcbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodHhNZXRhKSA9PiB7XHJcbiAgICAgIGlmICghdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHhNZXRhLnJldHJ5Q291bnQgPiAwICYmIHR4TWV0YS5yZXRyeUNvdW50IDwgMikge1xyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQ7XHJcbiAgICAgICAgZGVsZXRlIHR4TWV0YS5lcnI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHVwZGF0ZXMgXCJ0cmFuc2FjdGlvbiBzdGF0ZSBoaXN0b3J5XCIgdG8gZGlmZnMgc3R5bGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQge1xyXG4gIHNuYXBzaG90RnJvbVR4TWV0YSxcclxuICBtaWdyYXRlRnJvbVNuYXBzaG90c1RvRGlmZnMsXHJcbn0gZnJvbSAnLi4vY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zL2xpYi90eC1zdGF0ZS1oaXN0b3J5LWhlbHBlcnMnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDE4O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xyXG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgLy8gbm8gaGlzdG9yeTogaW5pdGlhbGl6ZVxyXG4gICAgICBpZiAoIXR4TWV0YS5oaXN0b3J5IHx8IHR4TWV0YS5oaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gc25hcHNob3RGcm9tVHhNZXRhKHR4TWV0YSk7XHJcbiAgICAgICAgdHhNZXRhLmhpc3RvcnkgPSBbc25hcHNob3RdO1xyXG4gICAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICAgIH1cclxuICAgICAgLy8gaGFzIGhpc3Rvcnk6IG1pZ3JhdGVcclxuICAgICAgY29uc3QgbmV3SGlzdG9yeSA9IG1pZ3JhdGVGcm9tU25hcHNob3RzVG9EaWZmcyh0eE1ldGEuaGlzdG9yeSlcclxuICAgICAgICAvLyByZW1vdmUgZW1wdHkgZGlmZnNcclxuICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCBlbnRyeS5sZW5ndGggPiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB0eE1ldGEuaGlzdG9yeSA9IG5ld0hpc3Rvcnk7XHJcbiAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsIi8qXHJcblxyXG5UaGlzIG1pZ3JhdGlvbiBzZXRzIHRyYW5zYWN0aW9ucyBhcyBmYWlsZWRcclxud2hvcyBub25jZSBpcyB0b28gaGlnaFxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMTk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XHJcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xyXG5cclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKFxyXG4gICAgICAodHhNZXRhLCBfLCB0eExpc3QpID0+IHtcclxuICAgICAgICBpZiAodHhNZXRhLnN0YXR1cyAhPT0gVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHhNZXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY29uZmlybWVkVHhzID0gdHhMaXN0XHJcbiAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHguc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5jb25maXJtZWQpXHJcbiAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHgudHhQYXJhbXMuZnJvbSA9PT0gdHhNZXRhLnR4UGFyYW1zLmZyb20pXHJcbiAgICAgICAgICAuZmlsdGVyKFxyXG4gICAgICAgICAgICAodHgpID0+IHR4Lm1ldGFtYXNrTmV0d29ya0lkLmZyb20gPT09IHR4TWV0YS5tZXRhbWFza05ldHdvcmtJZC5mcm9tLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBoaWdoZXN0Q29uZmlybWVkTm9uY2UgPSBnZXRIaWdoZXN0Tm9uY2UoY29uZmlybWVkVHhzKTtcclxuXHJcbiAgICAgICAgY29uc3QgcGVuZGluZ1R4cyA9IHR4TGlzdFxyXG4gICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuc3VibWl0dGVkKVxyXG4gICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnR4UGFyYW1zLmZyb20gPT09IHR4TWV0YS50eFBhcmFtcy5mcm9tKVxyXG4gICAgICAgICAgLmZpbHRlcihcclxuICAgICAgICAgICAgKHR4KSA9PiB0eC5tZXRhbWFza05ldHdvcmtJZC5mcm9tID09PSB0eE1ldGEubWV0YW1hc2tOZXR3b3JrSWQuZnJvbSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgaGlnaGVzdENvbnRpbnVvdXNOb25jZSA9IGdldEhpZ2hlc3RDb250aW51b3VzRnJvbShcclxuICAgICAgICAgIHBlbmRpbmdUeHMsXHJcbiAgICAgICAgICBoaWdoZXN0Q29uZmlybWVkTm9uY2UsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWF4Tm9uY2UgPSBNYXRoLm1heChcclxuICAgICAgICAgIGhpZ2hlc3RDb250aW51b3VzTm9uY2UsXHJcbiAgICAgICAgICBoaWdoZXN0Q29uZmlybWVkTm9uY2UsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKHBhcnNlSW50KHR4TWV0YS50eFBhcmFtcy5ub25jZSwgMTYpID4gbWF4Tm9uY2UgKyAxKSB7XHJcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkO1xyXG4gICAgICAgICAgdHhNZXRhLmVyciA9IHtcclxuICAgICAgICAgICAgbWVzc2FnZTogJ25vbmNlIHRvbyBoaWdoJyxcclxuICAgICAgICAgICAgbm90ZTogJ21pZ3JhdGlvbiAwMTkgY3VzdG9tIGVycm9yJyxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICAgIH0sXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhpZ2hlc3RDb250aW51b3VzRnJvbSh0eExpc3QsIHN0YXJ0UG9pbnQpIHtcclxuICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcclxuICAgIGNvbnN0IHsgbm9uY2UgfSA9IHR4TWV0YS50eFBhcmFtcztcclxuICAgIHJldHVybiBwYXJzZUludChub25jZSwgMTYpO1xyXG4gIH0pO1xyXG5cclxuICBsZXQgaGlnaGVzdCA9IHN0YXJ0UG9pbnQ7XHJcbiAgd2hpbGUgKG5vbmNlcy5pbmNsdWRlcyhoaWdoZXN0KSkge1xyXG4gICAgaGlnaGVzdCArPSAxO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGhpZ2hlc3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhpZ2hlc3ROb25jZSh0eExpc3QpIHtcclxuICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcclxuICAgIGNvbnN0IHsgbm9uY2UgfSA9IHR4TWV0YS50eFBhcmFtcztcclxuICAgIHJldHVybiBwYXJzZUludChub25jZSB8fCAnMHgwJywgMTYpO1xyXG4gIH0pO1xyXG4gIGNvbnN0IGhpZ2hlc3ROb25jZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIG5vbmNlcyk7XHJcbiAgcmV0dXJuIGhpZ2hlc3ROb25jZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gZW5zdXJlcyBwcmV2aW91cyBpbnN0YWxsYXRpb25zXHJcbmdldCBhIGBmaXJzdFRpbWVJbmZvYCBrZXkgb24gdGhlIG1ldGFtYXNrIHN0YXRlLFxyXG5zbyB0aGF0IHdlIGNhbiB2ZXJzaW9uIG5vdGljZXMgaW4gdGhlIGZ1dHVyZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDIwO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgaWYgKCdtZXRhbWFzaycgaW4gbmV3U3RhdGUgJiYgISgnZmlyc3RUaW1lSW5mbycgaW4gbmV3U3RhdGUubWV0YW1hc2spKSB7XHJcbiAgICBuZXdTdGF0ZS5tZXRhbWFzay5maXJzdFRpbWVJbmZvID0ge1xyXG4gICAgICB2ZXJzaW9uOiAnMy4xMi4wJyxcclxuICAgICAgZGF0ZTogRGF0ZS5ub3coKSxcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0aGUgQmxhY2tMaXN0Q29udHJvbGxlciBmcm9tIGRpc2sgc3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDIxO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLkJsYWNrbGlzdENvbnRyb2xsZXI7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLlJlY2VudEJsb2NrcztcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIGFkZHMgc3VibWl0dGVkVGltZSB0byB0aGUgdHhNZXRhIGlmIGl0IGlzIG5vdCB0aGVpclxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XHJcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xyXG5cclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgIT09IFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZCB8fFxyXG4gICAgICAgIHR4TWV0YS5zdWJtaXR0ZWRUaW1lXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICAgIH1cclxuICAgICAgdHhNZXRhLnN1Ym1pdHRlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHJlbW92ZXMgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIG5vIGxvbmdlciB1c2VmdWxsIGRvd24gdG8gNDAgdG90YWxcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXR1cyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDIzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcblxyXG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcclxuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XHJcblxyXG4gICAgaWYgKHRyYW5zYWN0aW9ucy5sZW5ndGggPD0gNDApIHtcclxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJldmVyc2VUeExpc3QgPSB0cmFuc2FjdGlvbnMucmV2ZXJzZSgpO1xyXG4gICAgbGV0IHN0cmlwcGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAocmV2ZXJzZVR4TGlzdC5sZW5ndGggPiA0MCAmJiBzdHJpcHBpbmcpIHtcclxuICAgICAgY29uc3QgdHhJbmRleCA9IHJldmVyc2VUeExpc3QuZmluZEluZGV4KCh0eE1ldGEpID0+IHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuZmFpbGVkIHx8XHJcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5yZWplY3RlZCB8fFxyXG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkIHx8XHJcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5kcm9wcGVkXHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICh0eEluZGV4IDwgMCkge1xyXG4gICAgICAgIHN0cmlwcGluZyA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldmVyc2VUeExpc3Quc3BsaWNlKHR4SW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHJldmVyc2VUeExpc3QucmV2ZXJzZSgpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIGVuc3VyZXMgdGhhdCB0aGUgZnJvbSBhZGRyZXNzIGluIHR4UGFyYW1zIGlzIHRvIGxvd2VyIGNhc2UgZm9yXHJcbmFsbCB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uc1xyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgaWYgKCFuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIpIHtcclxuICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICB9XHJcbiAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcChcclxuICAgICh0eE1ldGEsIF8pID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQgJiZcclxuICAgICAgICB0eE1ldGEudHhQYXJhbXMgJiZcclxuICAgICAgICB0eE1ldGEudHhQYXJhbXMuZnJvbVxyXG4gICAgICApIHtcclxuICAgICAgICB0eE1ldGEudHhQYXJhbXMuZnJvbSA9IHR4TWV0YS50eFBhcmFtcy5mcm9tLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0sXHJcbiAgKTtcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG4vKlxyXG5cclxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcclxuXHJcbiovXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uL2xpYi91dGlsJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAyNTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcikge1xyXG4gICAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoXHJcbiAgICAgICAgKHR4TWV0YSkgPT4ge1xyXG4gICAgICAgICAgaWYgKHR4TWV0YS5zdGF0dXMgIT09IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHR4TWV0YS50eFBhcmFtcyA9IG5vcm1hbGl6ZVR4UGFyYW1zKHR4TWV0YS50eFBhcmFtcyk7XHJcbiAgICAgICAgICByZXR1cm4gdHhNZXRhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVR4UGFyYW1zKHR4UGFyYW1zKSB7XHJcbiAgLy8gZnVuY3Rpb25zIHRoYXQgaGFuZGxlIG5vcm1hbGl6aW5nIG9mIHRoYXQga2V5IGluIHR4UGFyYW1zXHJcbiAgY29uc3Qgd2hpdGVMaXN0ID0ge1xyXG4gICAgZnJvbTogKGZyb20pID0+IGFkZEhleFByZWZpeChmcm9tKS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgdG86ICgpID0+IGFkZEhleFByZWZpeCh0eFBhcmFtcy50bykudG9Mb3dlckNhc2UoKSxcclxuICAgIG5vbmNlOiAobm9uY2UpID0+IGFkZEhleFByZWZpeChub25jZSksXHJcbiAgICB2YWx1ZTogKHZhbHVlKSA9PiBhZGRIZXhQcmVmaXgodmFsdWUpLFxyXG4gICAgZGF0YTogKGRhdGEpID0+IGFkZEhleFByZWZpeChkYXRhKSxcclxuICAgIGdhczogKGdhcykgPT4gYWRkSGV4UHJlZml4KGdhcyksXHJcbiAgICBnYXNQcmljZTogKGdhc1ByaWNlKSA9PiBhZGRIZXhQcmVmaXgoZ2FzUHJpY2UpLFxyXG4gIH07XHJcblxyXG4gIC8vIGFwcGx5IG9ubHkga2V5cyBpbiB0aGUgd2hpdGVMaXN0XHJcbiAgY29uc3Qgbm9ybWFsaXplZFR4UGFyYW1zID0ge307XHJcbiAgT2JqZWN0LmtleXMod2hpdGVMaXN0KS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgIGlmICh0eFBhcmFtc1trZXldKSB7XHJcbiAgICAgIG5vcm1hbGl6ZWRUeFBhcmFtc1trZXldID0gd2hpdGVMaXN0W2tleV0odHhQYXJhbXNba2V5XSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBub3JtYWxpemVkVHhQYXJhbXM7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vdmVzIHRoZSBpZGVudGl0aWVzIHN0b3JlZCBpbiB0aGUgS2V5cmluZ0NvbnRyb2xsZXJcclxuIGludG8gdGhlIFByZWZlcmVuY2VzQ29udHJvbGxlclxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjY7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKCFzdGF0ZS5LZXlyaW5nQ29udHJvbGxlciB8fCAhc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICBpZiAoIXN0YXRlLktleXJpbmdDb250cm9sbGVyLndhbGxldE5pY2tuYW1lcykge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmlkZW50aXRpZXMgPSBPYmplY3Qua2V5cyhcclxuICAgIHN0YXRlLktleXJpbmdDb250cm9sbGVyLndhbGxldE5pY2tuYW1lcyxcclxuICApLnJlZHVjZSgoaWRlbnRpdGllcywgYWRkcmVzcykgPT4ge1xyXG4gICAgaWRlbnRpdGllc1thZGRyZXNzXSA9IHtcclxuICAgICAgbmFtZTogc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIud2FsbGV0Tmlja25hbWVzW2FkZHJlc3NdLFxyXG4gICAgICBhZGRyZXNzLFxyXG4gICAgfTtcclxuICAgIHJldHVybiBpZGVudGl0aWVzO1xyXG4gIH0sIHt9KTtcclxuICBkZWxldGUgc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIud2FsbGV0Tmlja25hbWVzO1xyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXHJcbi8qXHJcblxyXG5ub3JtYWxpemVzIHR4UGFyYW1zIG9uIHVuY29uZmlybWVkIHR4c1xyXG5cclxuKi9cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25TdGF0dXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAyNztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcikge1xyXG4gICAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5maWx0ZXIoXHJcbiAgICAgICAgKHR4TWV0YSkgPT4gdHhNZXRhLnN0YXR1cyAhPT0gVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG4vKlxyXG5cclxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcclxuXHJcbiovXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjg7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcblxyXG4gIGlmIChuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcclxuICAgIGlmIChcclxuICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2VucyAmJlxyXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuaWRlbnRpdGllc1xyXG4gICAgKSB7XHJcbiAgICAgIGNvbnN0IHsgaWRlbnRpdGllcywgdG9rZW5zIH0gPSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XHJcbiAgICAgIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0ge307XHJcbiAgICAgIE9iamVjdC5rZXlzKGlkZW50aXRpZXMpLmZvckVhY2goKGlkZW50aXR5KSA9PiB7XHJcbiAgICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbaWRlbnRpdHldID0ge1xyXG4gICAgICAgICAgbWFpbm5ldDogdG9rZW5zLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG5pbXBvcnQgeyBUcmFuc2FjdGlvblN0YXR1cyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5pbXBvcnQgZmFpbFR4c1RoYXQgZnJvbSAnLi9mYWlsLXR4JztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAyOTtcclxuXHJcbi8vIHRpbWVcclxuY29uc3Qgc2Vjb25kcyA9IDEwMDA7XHJcbmNvbnN0IG1pbnV0ZXMgPSA2MCAqIHNlY29uZHM7XHJcbmNvbnN0IGhvdXJzID0gNjAgKiBtaW51dGVzO1xyXG5jb25zdCB1bmFjY2VwdGFibGVEZWxheSA9IDEyICogaG91cnM7XHJcblxyXG4vKlxyXG5cclxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcclxuXHJcbiovXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZTogZmFpbFR4c1RoYXQoXHJcbiAgICB2ZXJzaW9uLFxyXG4gICAgJ1N0dWNrIGluIGFwcHJvdmVkIHN0YXRlIGZvciB0b28gbG9uZy4nLFxyXG4gICAgKHR4TWV0YSkgPT4ge1xyXG4gICAgICBjb25zdCBpc0FwcHJvdmVkID0gdHhNZXRhLnN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuYXBwcm92ZWQ7XHJcbiAgICAgIGNvbnN0IGNyZWF0ZWRUaW1lID0gdHhNZXRhLnN1Ym1pdHRlZFRpbWU7XHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgIHJldHVybiBpc0FwcHJvdmVkICYmIG5vdyAtIGNyZWF0ZWRUaW1lID4gdW5hY2NlcHRhYmxlRGVsYXk7XHJcbiAgICB9LFxyXG4gICksXHJcbn07XHJcbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcclxuLypcclxuXHJcbnJlbW92ZXMgaW52YWxpZCBjaGFpZHMgZnJvbSBwcmVmZXJlbmNlcyBhbmQgbmV0d29ya0NvbnRyb2xsZXIgZm9yIGN1c3RvbSBycGNzXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzMDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IGZyZXF1ZW50UnBjTGlzdERldGFpbCB9ID0gbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xyXG4gICAgaWYgKGZyZXF1ZW50UnBjTGlzdERldGFpbCkge1xyXG4gICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWwuZm9yRWFjaCgocnBjLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICAgIGlmIChCb29sZWFuKHJwYy5jaGFpbklkKSAmJiBOdW1iZXIuaXNOYU4ocGFyc2VJbnQocnBjLmNoYWluSWQpKSkge1xyXG4gICAgICAgICAgZGVsZXRlIGZyZXF1ZW50UnBjTGlzdERldGFpbFtpbmRleF0uY2hhaW5JZDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID1cclxuICAgICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcikge1xyXG4gICAgaWYgKFxyXG4gICAgICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5uZXR3b3JrICYmXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICBOdW1iZXIuaXNOYU4ocGFyc2VJbnQobmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIubmV0d29yaykpXHJcbiAgICApIHtcclxuICAgICAgZGVsZXRlIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLm5ldHdvcms7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciAmJlxyXG4gICAgICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlci5jaGFpbklkICYmXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICBOdW1iZXIuaXNOYU4ocGFyc2VJbnQobmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIuY2hhaW5JZCkpXHJcbiAgICApIHtcclxuICAgICAgZGVsZXRlIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDMxO1xyXG5cclxuLypcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gcHJvcGVybHkgc2V0IHRoZSBjb21wbGV0ZWRPbmJvYXJkaW5nIGZsYWcgYmFzZWQgb24gdGhlIHN0YXRlXHJcbiAqIG9mIHRoZSBLZXlyaW5nQ29udHJvbGxlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBLZXlyaW5nQ29udHJvbGxlciwgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcclxuXHJcbiAgaWYgKEtleXJpbmdDb250cm9sbGVyICYmIFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgeyB2YXVsdCB9ID0gS2V5cmluZ0NvbnRyb2xsZXI7XHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkT25ib2FyZGluZyA9IEJvb2xlYW4odmF1bHQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzI7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gc2V0IHRoZSB7QGNvZGUgY29tcGxldGVkVWlNaWdyYXRpb259IGZsYWcgYmFzZWQgb24gdGhlIHVzZXIncyBVSSBwcmVmZXJlbmNlc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgfSA9IHN0YXRlO1xyXG5cclxuICBpZiAoUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IGJldGFVSSB9ID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmZlYXR1cmVGbGFncyB8fCB7fTtcclxuICAgIC8vIFVzZXJzIHdobyBoYXZlIGJlZW4gdXNpbmcgdGhlIFwiYmV0YVwiIFVJIGFyZSBjb25zaWRlcmVkIHRvIGhhdmUgY29tcGxldGVkIHRoZSBtaWdyYXRpb25cclxuICAgIC8vIGFzIHRoZXknbGwgc2VlIG5vIGRpZmZlcmVuY2UgaW4gdGhpcyB2ZXJzaW9uXHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkVWlNaWdyYXRpb24gPSBiZXRhVUk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG4vKlxyXG5cclxuQ2xlYW5zIHVwIG5vdGljZXMgYW5kIGFzc29jYXRlZCBub3RpY2UgY29udHJvbGxlciBjb2RlXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzMztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICAvLyB0cmFuc2Zvcm0gc3RhdGUgaGVyZVxyXG4gIGlmIChzdGF0ZS5Ob3RpY2VDb250cm9sbGVyKSB7XHJcbiAgICBkZWxldGUgbmV3U3RhdGUuTm90aWNlQ29udHJvbGxlcjtcclxuICB9XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzQ7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gZW5hYmxlIHRoZSB7QGNvZGUgcHJpdmFjeU1vZGV9IGZlYXR1cmUgZmxhZyBhbmQgc2V0IHRoZSB1c2VyIGFzIGJlaW5nIG1pZ3JhdGVkXHJcbiAqIGlmIGl0IHdhcyB7QGNvZGUgZmFsc2V9LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgfSA9IHN0YXRlO1xyXG5cclxuICBpZiAoUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCBmZWF0dXJlRmxhZ3MgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZmVhdHVyZUZsYWdzIHx8IHt9O1xyXG5cclxuICAgIGlmIChcclxuICAgICAgIWZlYXR1cmVGbGFncy5wcml2YWN5TW9kZSAmJlxyXG4gICAgICB0eXBlb2YgUHJlZmVyZW5jZXNDb250cm9sbGVyLm1pZ3JhdGVkUHJpdmFjeU1vZGUgPT09ICd1bmRlZmluZWQnXHJcbiAgICApIHtcclxuICAgICAgLy8gTWFyayB0aGUgc3RhdGUgaGFzIGJlaW5nIG1pZ3JhdGVkIGFuZCBlbmFibGUgUHJpdmFjeSBNb2RlXHJcbiAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5taWdyYXRlZFByaXZhY3lNb2RlID0gdHJ1ZTtcclxuICAgICAgZmVhdHVyZUZsYWdzLnByaXZhY3lNb2RlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXHJcbi8qXHJcblxyXG5SZW1vdmVzIHRoZSBkZXByZWNhdGVkICdzZWVkV29yZHMnIHN0YXRlXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzNTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmIChcclxuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlciAmJlxyXG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnNlZWRXb3JkcyAhPT0gdW5kZWZpbmVkXHJcbiAgKSB7XHJcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnNlZWRXb3JkcztcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzY7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gcmVtb3ZlIHRoZSB7QGNvZGUgcHJpdmFjeU1vZGV9IGZlYXR1cmUgZmxhZy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IHsgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcclxuXHJcbiAgaWYgKFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgZmVhdHVyZUZsYWdzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmZlYXR1cmVGbGFncyB8fCB7fTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGZlYXR1cmVGbGFncy5wcml2YWN5TW9kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgZGVsZXRlIGZlYXR1cmVGbGFncy5wcml2YWN5TW9kZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBub3JtYWxpemVFbnNOYW1lIH0gZnJvbSAnQG1ldGFtYXNrL2NvbnRyb2xsZXItdXRpbHMnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDM3O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWlncmF0aW9uIGlzIHRvIHVwZGF0ZSB0aGUgYWRkcmVzcyBib29rIHN0YXRlXHJcbiAqIHRvIHRoZSBuZXcgc2NoZW1hIHdpdGggY2hhaW5JZCBhcyBhIGtleS5cclxuICogYW5kIHRvIGFkZCB0aGUgaXNFbnMgZmxhZyB0byBhbGwgZW50cmllc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgYWIgPSBzdGF0ZS5BZGRyZXNzQm9va0NvbnRyb2xsZXIuYWRkcmVzc0Jvb2s7XHJcblxyXG4gICAgY29uc3QgY2hhaW5JZHMgPSBuZXcgU2V0KCk7XHJcbiAgICBjb25zdCBuZXdBZGRyZXNzQm9vayA9IHt9O1xyXG5cclxuICAgIC8vIGFkZCBhbGwgb2YgdGhlIGNoYWluSWRzIHRvIGEgc2V0XHJcbiAgICBPYmplY3QudmFsdWVzKGFiKS5mb3JFYWNoKCh2KSA9PiB7XHJcbiAgICAgIGNoYWluSWRzLmFkZCh2LmNoYWluSWQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gZmlsbCB0aGUgY2hhaW5JZCBvYmplY3Qgd2l0aCB0aGUgZW50cmllcyB3aXRoIHRoZSBtYXRjaGluZyBjaGFpbklkXHJcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGNoYWluSWRzLnZhbHVlcygpKSB7XHJcbiAgICAgIC8vIG1ha2UgYW4gZW1wdHkgb2JqZWN0IGVudHJ5IGZvciBlYWNoIGNoYWluSWRcclxuICAgICAgbmV3QWRkcmVzc0Jvb2tbaWRdID0ge307XHJcbiAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBpbiBhYikge1xyXG4gICAgICAgIGlmIChhYlthZGRyZXNzXS5jaGFpbklkID09PSBpZCkge1xyXG4gICAgICAgICAgYWJbYWRkcmVzc10uaXNFbnMgPSBmYWxzZTtcclxuICAgICAgICAgIGlmIChub3JtYWxpemVFbnNOYW1lKGFiW2FkZHJlc3NdLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIGFiW2FkZHJlc3NdLmlzRW5zID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5ld0FkZHJlc3NCb29rW2lkXVthZGRyZXNzXSA9IGFiW2FkZHJlc3NdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlci5hZGRyZXNzQm9vayA9IG5ld0FkZHJlc3NCb29rO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzg7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gYXNzaWduIGFsbCB1c2VycyB0byBhIHRlc3QgZ3JvdXAgZm9yIHRoZSBmdWxsU2NyZWVuVnNQb3B1cCBhL2IgdGVzdFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBBQlRlc3RDb250cm9sbGVyOiBBQlRlc3RDb250cm9sbGVyU3RhdGUgPSB7fSB9ID0gc3RhdGU7XHJcbiAgY29uc3QgeyBhYlRlc3RzID0ge30gfSA9IEFCVGVzdENvbnRyb2xsZXJTdGF0ZTtcclxuXHJcbiAgaWYgKGFiVGVzdHMuZnVsbFNjcmVlblZzUG9wdXApIHtcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIEFCVGVzdENvbnRyb2xsZXI6IHtcclxuICAgICAgLi4uQUJUZXN0Q29udHJvbGxlclN0YXRlLFxyXG4gICAgICBhYlRlc3RzOiB7XHJcbiAgICAgICAgLi4uYWJUZXN0cyxcclxuICAgICAgICBmdWxsU2NyZWVuVnNQb3B1cDogJ2NvbnRyb2wnLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IHRvQ2hlY2tzdW1IZXhBZGRyZXNzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzOTtcclxuXHJcbmNvbnN0IERBSV9WMV9DT05UUkFDVF9BRERSRVNTID0gJzB4ODlkMjRBNmI0Q2NCMUI2ZkFBMjYyNWZFNTYyYkREOWEyMzI2MDM1OSc7XHJcbmNvbnN0IERBSV9WMV9UT0tFTl9TWU1CT0wgPSAnREFJJztcclxuY29uc3QgU0FJX1RPS0VOX1NZTUJPTCA9ICdTQUknO1xyXG5cclxuZnVuY3Rpb24gaXNPbGREYWkodG9rZW4gPSB7fSkge1xyXG4gIHJldHVybiAoXHJcbiAgICB0b2tlbiAmJlxyXG4gICAgdHlwZW9mIHRva2VuID09PSAnb2JqZWN0JyAmJlxyXG4gICAgdG9rZW4uc3ltYm9sID09PSBEQUlfVjFfVE9LRU5fU1lNQk9MICYmXHJcbiAgICB0b0NoZWNrc3VtSGV4QWRkcmVzcyh0b2tlbi5hZGRyZXNzKSA9PT0gREFJX1YxX0NPTlRSQUNUX0FERFJFU1NcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBtaWdyYXRpb24gcmVuYW1lcyB0aGUgRGFpIHRva2VuIHRvIFNhaS5cclxuICpcclxuICogQXMgb2YgMjAxOS0xMS0xOCBEYWkgaXMgbm93IGNhbGxlZCBTYWkgKHJlZnMgaHR0cHM6Ly9naXQuaW8vSmVvb1ApIHRvIGZhY2lsaXRhdGVcclxuICogTWFrZXIncyB1cGdyYWRlIHRvIE11bHRpLUNvbGxhdGVyYWwgRGFpIGFuZCB0aGlzIG1pZ3JhdGlvbiByZW5hbWVzIHRoZSB0b2tlblxyXG4gKiBhdCB0aGUgb2xkIGFkZHJlc3MuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gc3RhdGU7XHJcblxyXG4gIGlmIChQcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcclxuICAgIGNvbnN0IHRva2VucyA9IFByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgfHwgW107XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XHJcbiAgICAgICAgaWYgKGlzT2xkRGFpKHRva2VuKSkge1xyXG4gICAgICAgICAgdG9rZW4uc3ltYm9sID0gU0FJX1RPS0VOX1NZTUJPTDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhY2NvdW50VG9rZW5zID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgfHwge307XHJcbiAgICBpZiAoYWNjb3VudFRva2VucyAmJiB0eXBlb2YgYWNjb3VudFRva2VucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnMpKSB7XHJcbiAgICAgICAgY29uc3QgbmV0d29ya1Rva2VucyA9IGFjY291bnRUb2tlbnNbYWRkcmVzc107XHJcbiAgICAgICAgaWYgKG5ldHdvcmtUb2tlbnMgJiYgdHlwZW9mIG5ldHdvcmtUb2tlbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IG5ldHdvcmsgb2YgT2JqZWN0LmtleXMobmV0d29ya1Rva2VucykpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW5zT25OZXR3b3JrID0gbmV0d29ya1Rva2Vuc1tuZXR3b3JrXTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW5zT25OZXR3b3JrKSkge1xyXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zT25OZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPbGREYWkodG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRva2VuLnN5bWJvbCA9IFNBSV9UT0tFTl9TWU1CT0w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0MDtcclxuXHJcbi8qKlxyXG4gKiBTaXRlIGNvbm5lY3Rpb25zIGFyZSBub3cgbWFuYWdlZCBieSB0aGUgUGVybWlzc2lvbnNDb250cm9sbGVyLCBhbmQgdGhlXHJcbiAqIFByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyIGlzIHJlbW92ZWQuIFRoaXMgbWlncmF0aW9uIGRlbGV0ZXMgYWxsXHJcbiAqIFByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgZGVsZXRlIHN0YXRlLlByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyO1xyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQxO1xyXG5cclxuLyoqXHJcbiAqIFByZWZlcmVuY2VzQ29udHJvbGxlci5hdXRvTG9nb3V0VGltZUxpbWl0IC0+IGF1dG9Mb2NrVGltZUxpbWl0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyICYmIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5wcmVmZXJlbmNlcykge1xyXG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2NrVGltZUxpbWl0ID1cclxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2dvdXRUaW1lTGltaXQ7XHJcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2dvdXRUaW1lTGltaXQ7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQyO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYGNvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd25gIHRvIGBmYWxzZWAgaWYgaXQgaGFzbid0IHlldCBiZWVuIHNldCxcclxuICogc28gdGhhdCBleGlzdGluZyB1c2VycyBhcmUgaW50cm9kdWNlZCB0byB0aGUgbmV3IGNvbm5lY3RlZCBzdGF0dXMgaW5kaWNhdG9yXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyKSB7XHJcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIuY29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93biA9IGZhbHNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIgPSB7XHJcbiAgICAgIGNvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd246IGZhbHNlLFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNDM7XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHVudXNlZCAnY3VycmVudEFjY291bnRUYWInIHN0YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uY3VycmVudEFjY291bnRUYWIpIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuY3VycmVudEFjY291bnRUYWI7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ0O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB1bnVzZWQgJ21rck1pZ3JhdGlvblJlbWluZGVyVGltZXN0YW1wJyBzdGF0ZSBmcm9tIHRoZSBgQXBwU3RhdGVDb250cm9sbGVyYFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKFxyXG4gICAgdHlwZW9mIHN0YXRlPy5BcHBTdGF0ZUNvbnRyb2xsZXI/Lm1rck1pZ3JhdGlvblJlbWluZGVyVGltZXN0YW1wICE9PVxyXG4gICAgJ3VuZGVmaW5lZCdcclxuICApIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIubWtyTWlncmF0aW9uUmVtaW5kZXJUaW1lc3RhbXA7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ1O1xyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIHtAY29kZSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuaXBmc0dhdGV3YXl9IHdpdGggJ2R3ZWIubGluaycgaWYgc2V0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuY29uc3Qgb3V0ZGF0ZWRHYXRld2F5cyA9IFsnaXBmcy5pbycsICdpcGZzLmR3ZWIubGluayddO1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAob3V0ZGF0ZWRHYXRld2F5cy5pbmNsdWRlcyhzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5pcGZzR2F0ZXdheSkpIHtcclxuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5pcGZzR2F0ZXdheSA9ICdkd2ViLmxpbmsnO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0NjtcclxuXHJcbi8qKlxyXG4gKiBEZWxldGUge0Bjb2RlIEFCVGVzdENvbnRyb2xsZXJ9IHN0YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAodHlwZW9mIHN0YXRlPy5BQlRlc3RDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgZGVsZXRlIHN0YXRlLkFCVGVzdENvbnRyb2xsZXI7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ3O1xyXG5cclxuLyoqXHJcbiAqIFN0cmluZ2lmeSB0aGUgYG1ldGFtYXNrTmV0d29ya0lkYCBwcm9wZXJ0eSBvZiBhbGwgdHJhbnNhY3Rpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSkge1xyXG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPVxyXG4gICAgICAgICAgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ4O1xyXG5cclxuLyoqXHJcbiAqIDEuICBEZWxldGUgTmV0d29ya0NvbnRyb2xsZXIuc2V0dGluZ3NcclxuICogMmEuIE1pZ3JhdGUgTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIgdG8gUmlua2VieSBpZiBzZXQgdG8gdHlwZSAncnBjJyBvclxyXG4gKiAgICAgJ2xvY2FsaG9zdCcuXHJcbiAqIDJiLiBSZS1rZXkgcHJvdmlkZXIucnBjVGFyZ2V0IHRvIHByb3ZpZGVyLnJwY1VybFxyXG4gKiAzLiAgQWRkIGxvY2FsaG9zdCBuZXR3b3JrIHRvIGZyZXF1ZW50UnBjTGlzdERldGFpbC5cclxuICogNC4gIERlbGV0ZSBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuY2FjaGVkQmFsYW5jZXNcclxuICogNS4gIENvbnZlcnQgdHJhbnNhY3Rpb25zIG1ldGFtYXNrTmV0d29ya0lkIHRvIGRlY2ltYWwgaWYgdGhleSBhcmUgaGV4XHJcbiAqIDYuICBDb252ZXJ0IGFkZHJlc3MgYm9vayBrZXlzIGZyb20gZGVjaW1hbCB0byBoZXhcclxuICogNy4gIERlbGV0ZSBsb2NhbGhvc3Qga2V5IGluIEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlclxyXG4gKiA4LiAgTWVyZ2UgJ2xvY2FsaG9zdCcgdG9rZW5zIGludG8gJ3JwYycgdG9rZW5zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuY29uc3QgaGV4UmVnRXggPSAvXjB4WzAtOWEtZl0rJC9pdTtcclxuY29uc3QgY2hhaW5JZFJlZ0V4ID0gL14weFsxLTlhLWZdK1swLTlhLWZdKiQvaXU7XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSA9IHt9KSB7XHJcbiAgLy8gMS4gRGVsZXRlIE5ldHdvcmtDb250cm9sbGVyLnNldHRpbmdzXHJcbiAgZGVsZXRlIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyPy5zZXR0aW5ncztcclxuXHJcbiAgLy8gMi4gTWlncmF0ZSBOZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciB0byBSaW5rZWJ5IG9yIHJlbmFtZSBycGNUYXJnZXQga2V5XHJcbiAgY29uc3QgcHJvdmlkZXIgPSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIgfHwge307XHJcbiAgY29uc3QgaXNDdXN0b21ScGNXaXRoSW52YWxpZENoYWluSWQgPVxyXG4gICAgcHJvdmlkZXIudHlwZSA9PT0gJ3JwYycgJiZcclxuICAgICh0eXBlb2YgcHJvdmlkZXIuY2hhaW5JZCAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgIWNoYWluSWRSZWdFeC50ZXN0KHByb3ZpZGVyLmNoYWluSWQpKTtcclxuICBpZiAoaXNDdXN0b21ScGNXaXRoSW52YWxpZENoYWluSWQgfHwgcHJvdmlkZXIudHlwZSA9PT0gJ2xvY2FsaG9zdCcpIHtcclxuICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyID0ge1xyXG4gICAgICB0eXBlOiAncmlua2VieScsXHJcbiAgICAgIHJwY1VybDogJycsXHJcbiAgICAgIGNoYWluSWQ6ICcweDQnLFxyXG4gICAgICBuaWNrbmFtZTogJycsXHJcbiAgICAgIHJwY1ByZWZzOiB7fSxcclxuICAgICAgdGlja2VyOiAnRVRIJyxcclxuICAgIH07XHJcbiAgfSBlbHNlIGlmIChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIpIHtcclxuICAgIGlmICgncnBjVGFyZ2V0JyBpbiBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlcikge1xyXG4gICAgICBjb25zdCBycGNVcmwgPSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlci5ycGNUYXJnZXQ7XHJcbiAgICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLnJwY1VybCA9IHJwY1VybDtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXI/LnJwY1RhcmdldDtcclxuICB9XHJcblxyXG4gIC8vIDMuICBBZGQgbG9jYWxob3N0IG5ldHdvcmsgdG8gZnJlcXVlbnRScGNMaXN0RGV0YWlsLlxyXG4gIGlmICghc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSB7fTtcclxuICB9XHJcbiAgaWYgKCFzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsKSB7XHJcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID0gW107XHJcbiAgfVxyXG4gIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwudW5zaGlmdCh7XHJcbiAgICBycGNVcmw6ICdodHRwOi8vbG9jYWxob3N0Ojg1NDUnLFxyXG4gICAgY2hhaW5JZDogJzB4NTM5JyxcclxuICAgIHRpY2tlcjogJ0VUSCcsXHJcbiAgICBuaWNrbmFtZTogJ0xvY2FsaG9zdCA4NTQ1JyxcclxuICAgIHJwY1ByZWZzOiB7fSxcclxuICB9KTtcclxuXHJcbiAgLy8gNC4gIERlbGV0ZSBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuY2FjaGVkQmFsYW5jZXNcclxuICBkZWxldGUgc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcztcclxuXHJcbiAgLy8gNS4gIENvbnZlcnQgdHJhbnNhY3Rpb25zIG1ldGFtYXNrTmV0d29ya0lkIHRvIGRlY2ltYWwgaWYgdGhleSBhcmUgaGV4XHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSkge1xyXG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1ldGFtYXNrTmV0d29ya0lkID0gdHJhbnNhY3Rpb24/Lm1ldGFtYXNrTmV0d29ya0lkO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHlwZW9mIG1ldGFtYXNrTmV0d29ya0lkID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIGhleFJlZ0V4LnRlc3QobWV0YW1hc2tOZXR3b3JrSWQpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLm1ldGFtYXNrTmV0d29ya0lkID0gcGFyc2VJbnQoXHJcbiAgICAgICAgICBtZXRhbWFza05ldHdvcmtJZCxcclxuICAgICAgICAgIDE2LFxyXG4gICAgICAgICkudG9TdHJpbmcoMTApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIDYuICBDb252ZXJ0IGFkZHJlc3MgYm9vayBrZXlzIGZyb20gZGVjaW1hbCB0byBoZXhcclxuICBjb25zdCBhZGRyZXNzQm9vayA9IHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlcj8uYWRkcmVzc0Jvb2sgfHwge307XHJcbiAgT2JqZWN0LmtleXMoYWRkcmVzc0Jvb2spLmZvckVhY2goKG5ldHdvcmtLZXkpID0+IHtcclxuICAgIGlmICgvXlxcZCskL2l1LnRlc3QobmV0d29ya0tleSkpIHtcclxuICAgICAgY29uc3QgY2hhaW5JZCA9IGAweCR7cGFyc2VJbnQobmV0d29ya0tleSwgMTApLnRvU3RyaW5nKDE2KX1gO1xyXG4gICAgICB1cGRhdGVDaGFpbklkcyhhZGRyZXNzQm9va1tuZXR3b3JrS2V5XSwgY2hhaW5JZCk7XHJcblxyXG4gICAgICBpZiAoYWRkcmVzc0Jvb2tbY2hhaW5JZF0pIHtcclxuICAgICAgICBtZXJnZUFkZHJlc3NCb29rS2V5cyhhZGRyZXNzQm9vaywgbmV0d29ya0tleSwgY2hhaW5JZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRkcmVzc0Jvb2tbY2hhaW5JZF0gPSBhZGRyZXNzQm9va1tuZXR3b3JrS2V5XTtcclxuICAgICAgfVxyXG4gICAgICBkZWxldGUgYWRkcmVzc0Jvb2tbbmV0d29ya0tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIDcuICBEZWxldGUgbG9jYWxob3N0IGtleSBpbiBJbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXJcclxuICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXHJcbiAgICA/LmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2Nrc0J5TmV0d29yaz8ubG9jYWxob3N0O1xyXG5cclxuICAvLyA4LiAgTWVyZ2UgJ2xvY2FsaG9zdCcgdG9rZW5zIGludG8gJ3JwYycgdG9rZW5zXHJcbiAgY29uc3QgYWNjb3VudFRva2VucyA9IHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcj8uYWNjb3VudFRva2VucztcclxuICBpZiAoYWNjb3VudFRva2Vucykge1xyXG4gICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xyXG4gICAgICBjb25zdCBsb2NhbGhvc3RUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FjY291bnRdPy5sb2NhbGhvc3QgfHwgW107XHJcblxyXG4gICAgICBpZiAobG9jYWxob3N0VG9rZW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBycGNUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FjY291bnRdLnJwYyB8fCBbXTtcclxuXHJcbiAgICAgICAgaWYgKHJwY1Rva2Vucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBhY2NvdW50VG9rZW5zW2FjY291bnRdLnJwYyA9IG1lcmdlVG9rZW5BcnJheXMoXHJcbiAgICAgICAgICAgIGxvY2FsaG9zdFRva2VucyxcclxuICAgICAgICAgICAgcnBjVG9rZW5zLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWNjb3VudFRva2Vuc1thY2NvdW50XS5ycGMgPSBsb2NhbGhvc3RUb2tlbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGRlbGV0ZSBhY2NvdW50VG9rZW5zW2FjY291bnRdPy5sb2NhbGhvc3Q7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyB0aGUgdHdvIGdpdmVuIGtleXMgZm9yIHRoZSBnaXZlbiBhZGRyZXNzIGJvb2sgaW4gcGxhY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBhZGRyZXNzQm9va1xyXG4gKiBAcGFyYW0gbmV0d29ya0tleVxyXG4gKiBAcGFyYW0gY2hhaW5JZEtleVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VBZGRyZXNzQm9va0tleXMoYWRkcmVzc0Jvb2ssIG5ldHdvcmtLZXksIGNoYWluSWRLZXkpIHtcclxuICBjb25zdCBuZXR3b3JrS2V5RW50cmllcyA9IGFkZHJlc3NCb29rW25ldHdvcmtLZXldIHx8IHt9O1xyXG4gIC8vIEZvciB0aGUgbmV3IGVudHJpZXMsIHN0YXJ0IGJ5IGNvcHlpbmcgdGhlIGV4aXN0aW5nIGVudHJpZXMgZm9yIHRoZSBjaGFpbklkXHJcbiAgY29uc3QgbmV3RW50cmllcyA9IHsgLi4uYWRkcmVzc0Jvb2tbY2hhaW5JZEtleV0gfTtcclxuXHJcbiAgLy8gRm9yIGVhY2ggYWRkcmVzcyBvZiB0aGUgb2xkL25ldHdvcmtJZCBrZXkgZW50cmllc1xyXG4gIE9iamVjdC5rZXlzKG5ldHdvcmtLZXlFbnRyaWVzKS5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XHJcbiAgICBpZiAobmV3RW50cmllc1thZGRyZXNzXSAmJiB0eXBlb2YgbmV3RW50cmllc1thZGRyZXNzXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgY29uc3QgbWVyZ2VkRW50cnkgPSB7fTtcclxuXHJcbiAgICAgIC8vIENvbGxlY3QgYWxsIGtleXMgZnJvbSBib3RoIGVudHJpZXMgYW5kIG1lcmdlIHRoZSBjb3JyZXNwb25kaW5nIGNoYWluSWRcclxuICAgICAgLy8gZW50cnkgd2l0aCB0aGUgbmV0d29ya0lkIGVudHJ5XHJcbiAgICAgIG5ldyBTZXQoW1xyXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKG5ld0VudHJpZXNbYWRkcmVzc10pLFxyXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdIHx8IHt9KSxcclxuICAgICAgXSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgLy8gVXNlIG5vbi1lbXB0eSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQga2V5LCBpZiBhbnlcclxuICAgICAgICBtZXJnZWRFbnRyeVtrZXldID1cclxuICAgICAgICAgIG5ld0VudHJpZXNbYWRkcmVzc11ba2V5XSB8fCBuZXR3b3JrS2V5RW50cmllc1thZGRyZXNzXT8uW2tleV0gfHwgJyc7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbmV3RW50cmllc1thZGRyZXNzXSA9IG1lcmdlZEVudHJ5O1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc10gJiZcclxuICAgICAgdHlwZW9mIG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdID09PSAnb2JqZWN0J1xyXG4gICAgKSB7XHJcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgY2hhaW5JZCBlbnRyeSwganVzdCB1c2UgdGhlIG5ldHdvcmtJZCBlbnRyeVxyXG4gICAgICAvLyBkaXJlY3RseVxyXG4gICAgICBuZXdFbnRyaWVzW2FkZHJlc3NdID0gbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc107XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGFkZHJlc3NCb29rW2NoYWluSWRLZXldID0gbmV3RW50cmllcztcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIGNoYWluSWQga2V5IHZhbHVlcyB0byB0aGUgZ2l2ZW4gY2hhaW5JZCBpbiBwbGFjZSBmb3IgYWxsIHZhbHVlc1xyXG4gKiBvZiB0aGUgZ2l2ZW4gbmV0d29ya0VudHJpZXMgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gbmV0d29ya0VudHJpZXNcclxuICogQHBhcmFtIGNoYWluSWRcclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZUNoYWluSWRzKG5ldHdvcmtFbnRyaWVzLCBjaGFpbklkKSB7XHJcbiAgT2JqZWN0LnZhbHVlcyhuZXR3b3JrRW50cmllcykuZm9yRWFjaCgoZW50cnkpID0+IHtcclxuICAgIGlmIChlbnRyeSAmJiB0eXBlb2YgZW50cnkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGVudHJ5LmNoYWluSWQgPSBjaGFpbklkO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHRoZSB0d28gZ2l2ZW4sIG5vbi1lbXB0eSBhcnJheXMgb2YgdG9rZW4gb2JqZWN0cyBhbmQgcmV0dXJucyBhIG5ld1xyXG4gKiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGxvY2FsaG9zdFRva2Vuc1xyXG4gKiBAcGFyYW0gcnBjVG9rZW5zXHJcbiAqIEByZXR1cm5zIHtBcnJheTxvYmplY3Q+fVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VUb2tlbkFycmF5cyhsb2NhbGhvc3RUb2tlbnMsIHJwY1Rva2Vucykge1xyXG4gIGNvbnN0IGxvY2FsaG9zdFRva2Vuc01hcCA9IHRva2VuQXJyYXlUb01hcChsb2NhbGhvc3RUb2tlbnMpO1xyXG4gIGNvbnN0IHJwY1Rva2Vuc01hcCA9IHRva2VuQXJyYXlUb01hcChycGNUb2tlbnMpO1xyXG5cclxuICBjb25zdCBtZXJnZWRUb2tlbnMgPSBbXTtcclxuICBuZXcgU2V0KFtcclxuICAgIC4uLk9iamVjdC5rZXlzKGxvY2FsaG9zdFRva2Vuc01hcCksXHJcbiAgICAuLi5PYmplY3Qua2V5cyhycGNUb2tlbnNNYXApLFxyXG4gIF0pLmZvckVhY2goKHRva2VuQWRkcmVzcykgPT4ge1xyXG4gICAgbWVyZ2VkVG9rZW5zLnB1c2goe1xyXG4gICAgICAuLi5sb2NhbGhvc3RUb2tlbnNNYXBbdG9rZW5BZGRyZXNzXSxcclxuICAgICAgLi4ucnBjVG9rZW5zTWFwW3Rva2VuQWRkcmVzc10sXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG1lcmdlZFRva2VucztcclxuXHJcbiAgZnVuY3Rpb24gdG9rZW5BcnJheVRvTWFwKGFycmF5KSB7XHJcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKChtYXAsIHRva2VuKSA9PiB7XHJcbiAgICAgIGlmICh0b2tlbj8uYWRkcmVzcyAmJiB0eXBlb2YgdG9rZW4/LmFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgbWFwW3Rva2VuLmFkZHJlc3NdID0gdG9rZW47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH0sIHt9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0OTtcclxuXHJcbi8qKlxyXG4gKiBNaWdyYXRlIG1ldGFNZXRyaWNzIHN0YXRlIHRvIHRoZSBuZXcgTWV0YU1ldHJpY3MgY29udHJvbGxlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlID0ge30pIHtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IG1ldGFNZXRyaWNzSWQsIHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcywgbWV0YU1ldHJpY3NTZW5kQ291bnQgfSA9XHJcbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcjtcclxuICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlciA9IHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlciA/PyB7fTtcclxuXHJcbiAgICBpZiAobWV0YU1ldHJpY3NJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5tZXRhTWV0cmljc0lkID0gbWV0YU1ldHJpY3NJZDtcclxuICAgICAgZGVsZXRlIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5tZXRhTWV0cmljc0lkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzID1cclxuICAgICAgICBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3M7XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtZXRhTWV0cmljc1NlbmRDb3VudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5tZXRhTWV0cmljc1NlbmRDb3VudCA9IG1ldGFNZXRyaWNzU2VuZENvdW50O1xyXG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA1MDtcclxuXHJcbmNvbnN0IExFR0FDWV9MT0NBTF9TVE9SQUdFX0tFWVMgPSBbXHJcbiAgJ01FVEFTV0FQX0dBU19QUklDRV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxyXG4gICdNRVRBU1dBUF9HQVNfUFJJQ0VfRVNUSU1BVEVTJyxcclxuICAnY2FjaGVkRmV0Y2gnLFxyXG4gICdCQVNJQ19QUklDRV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxyXG4gICdCQVNJQ19QUklDRV9FU1RJTUFURVMnLFxyXG4gICdCQVNJQ19HQVNfQU5EX1RJTUVfQVBJX0VTVElNQVRFUycsXHJcbiAgJ0JBU0lDX0dBU19BTkRfVElNRV9BUElfRVNUSU1BVEVTX0xBU1RfUkVUUklFVkVEJyxcclxuICAnR0FTX0FQSV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxyXG4gICdHQVNfQVBJX0VTVElNQVRFUycsXHJcbl07XHJcblxyXG4vKipcclxuICogTWlncmF0ZSBtZXRhTWV0cmljcyBzdGF0ZSB0byB0aGUgbmV3IE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcblxyXG4gICAgTEVHQUNZX0xPQ0FMX1NUT1JBR0VfS0VZUy5mb3JFYWNoKChrZXkpID0+XHJcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2U/LnJlbW92ZUl0ZW0oa2V5KSxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgQlVJTFRfSU5fTkVUV09SS1MgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDUxO1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgY2hhaW5JZCBpbiB0aGUgTmV0d29yayBDb250cm9sbGVyIHByb3ZpZGVyIGRhdGEgZm9yIGFsbCBpbmZ1cmEgbmV0d29ya3NcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IHsgY2hhaW5JZCwgdHlwZSB9ID0gc3RhdGU/Lk5ldHdvcmtDb250cm9sbGVyPy5wcm92aWRlciB8fCB7fTtcclxuICBjb25zdCBlbnVtQ2hhaW5JZCA9IEJVSUxUX0lOX05FVFdPUktTW3R5cGVdPy5jaGFpbklkO1xyXG5cclxuICBpZiAoZW51bUNoYWluSWQgJiYgY2hhaW5JZCAhPT0gZW51bUNoYWluSWQpIHtcclxuICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQgPSBlbnVtQ2hhaW5JZDtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IENIQUlOX0lEUywgTkVUV09SS19UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNTI7XHJcblxyXG4vKipcclxuICogTWlncmF0ZSB0b2tlbnMgaW4gUHJlZmVyZW5jZXMgdG8gYmUga2V5ZWQgYnkgY2hhaW5JZCBpbnN0ZWFkIG9mXHJcbiAqIHByb3ZpZGVyVHlwZS4gVG8gcHJldmVudCBicmVha2luZyB1c2VyJ3MgTWV0YU1hc2sgYW5kIHNlbGVjdGVkXHJcbiAqIHRva2VucywgdGhpcyBtaWdyYXRpb24gY29waWVzIHRoZSBSUEMgZW50cnkgaW50byAqZXZlcnkqIGN1c3RvbSBSUENcclxuICogY2hhaW5JZC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSA9IHt9KSB7XHJcbiAgaWYgKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgeyBhY2NvdW50VG9rZW5zLCBhY2NvdW50SGlkZGVuVG9rZW5zLCBmcmVxdWVudFJwY0xpc3REZXRhaWwgfSA9XHJcbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcjtcclxuXHJcbiAgICBjb25zdCBuZXdBY2NvdW50VG9rZW5zID0ge307XHJcbiAgICBjb25zdCBuZXdBY2NvdW50SGlkZGVuVG9rZW5zID0ge307XHJcblxyXG4gICAgaWYgKGFjY291bnRUb2tlbnMgJiYgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykubGVuZ3RoID4gMCkge1xyXG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykpIHtcclxuICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdID0ge307XHJcbiAgICAgICAgaWYgKGFjY291bnRUb2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFUy5SUENdKSB7XHJcbiAgICAgICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWwuZm9yRWFjaCgoZGV0YWlsKSA9PiB7XHJcbiAgICAgICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc11bZGV0YWlsLmNoYWluSWRdID1cclxuICAgICAgICAgICAgICBhY2NvdW50VG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRVMuUlBDXTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyVHlwZSBvZiBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zW2FkZHJlc3NdKSkge1xyXG4gICAgICAgICAgc3dpdGNoIChwcm92aWRlclR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBORVRXT1JLX1RZUEVTLk1BSU5ORVQ6XHJcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVtDSEFJTl9JRFMuTUFJTk5FVF0gPVxyXG4gICAgICAgICAgICAgICAgYWNjb3VudFRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLk1BSU5ORVRdO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdyb3BzdGVuJzpcclxuICAgICAgICAgICAgICBuZXdBY2NvdW50VG9rZW5zW2FkZHJlc3NdWycweDMnXSA9IGFjY291bnRUb2tlbnNbYWRkcmVzc10ucm9wc3RlbjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlua2VieSc6XHJcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVsnMHg0J10gPSBhY2NvdW50VG9rZW5zW2FkZHJlc3NdLnJpbmtlYnk7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgTkVUV09SS19UWVBFUy5HT0VSTEk6XHJcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVtDSEFJTl9JRFMuR09FUkxJXSA9XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50VG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRVMuR09FUkxJXTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAna292YW4nOlxyXG4gICAgICAgICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc11bJzB4MmEnXSA9IGFjY291bnRUb2tlbnNbYWRkcmVzc10ua292YW47XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0gbmV3QWNjb3VudFRva2VucztcclxuICAgIH1cclxuXHJcbiAgICBpZiAoYWNjb3VudEhpZGRlblRva2VucyAmJiBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zKSkge1xyXG4gICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc10gPSB7fTtcclxuICAgICAgICBpZiAoYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLlJQQ10pIHtcclxuICAgICAgICAgIGZyZXF1ZW50UnBjTGlzdERldGFpbC5mb3JFYWNoKChkZXRhaWwpID0+IHtcclxuICAgICAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtkZXRhaWwuY2hhaW5JZF0gPVxyXG4gICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFUy5SUENdO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcHJvdmlkZXJUeXBlIG9mIE9iamVjdC5rZXlzKGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc10pKSB7XHJcbiAgICAgICAgICBzd2l0Y2ggKHByb3ZpZGVyVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIE5FVFdPUktfVFlQRVMuTUFJTk5FVDpcclxuICAgICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW0NIQUlOX0lEUy5NQUlOTkVUXSA9XHJcbiAgICAgICAgICAgICAgICBhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRVMuTUFJTk5FVF07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3JvcHN0ZW4nOlxyXG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bJzB4MyddID1cclxuICAgICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc10ucm9wc3RlbjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAncmlua2VieSc6XHJcbiAgICAgICAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVsnMHg0J10gPVxyXG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXS5yaW5rZWJ5O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIE5FVFdPUktfVFlQRVMuR09FUkxJOlxyXG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bQ0hBSU5fSURTLkdPRVJMSV0gPVxyXG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLkdPRVJMSV07XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2tvdmFuJzpcclxuICAgICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdWycweDJhJ10gPVxyXG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXS5rb3ZhbjtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRIaWRkZW5Ub2tlbnMgPSBuZXdBY2NvdW50SGlkZGVuVG9rZW5zO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNTM7XHJcblxyXG4vKipcclxuICogRGVwcmVjYXRlIHRyYW5zYWN0aW9uQ2F0ZWdvcnkgYW5kIGNvbnNvbGlkYXRlIG9uICd0eXBlJ1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zO1xyXG4gIGNvbnN0IGluY29taW5nVHJhbnNhY3Rpb25zID1cclxuICAgIHN0YXRlPy5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXI/LmluY29taW5nVHJhbnNhY3Rpb25zO1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHRyYW5zYWN0aW9ucykpIHtcclxuICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKCh0cmFuc2FjdGlvbikgPT4ge1xyXG4gICAgICBpZiAodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0cmFuc2FjdGlvbi50eXBlICE9PSBUcmFuc2FjdGlvblR5cGUucmV0cnkgJiZcclxuICAgICAgICAgIHRyYW5zYWN0aW9uLnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5jYW5jZWxcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHRyYW5zYWN0aW9uLnR5cGUgPSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkNhdGVnb3J5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25DYXRlZ29yeTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGlmIChpbmNvbWluZ1RyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgaW5jb21pbmdUcmFuc2FjdGlvbnNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoaW5jb21pbmdUcmFuc2FjdGlvbnMpO1xyXG4gICAgaW5jb21pbmdUcmFuc2FjdGlvbnNFbnRyaWVzLmZvckVhY2goKFtrZXksIHRyYW5zYWN0aW9uXSkgPT4ge1xyXG4gICAgICBpZiAodHJhbnNhY3Rpb24pIHtcclxuICAgICAgICBkZWxldGUgdHJhbnNhY3Rpb24udHJhbnNhY3Rpb25DYXRlZ29yeTtcclxuICAgICAgICBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuaW5jb21pbmdUcmFuc2FjdGlvbnNba2V5XSA9IHtcclxuICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxyXG4gICAgICAgICAgdHlwZTogVHJhbnNhY3Rpb25UeXBlLmluY29taW5nLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA1NDtcclxuXHJcbmZ1bmN0aW9uIGlzVmFsaWREZWNpbWFscyhkZWNpbWFscykge1xyXG4gIHJldHVybiAoXHJcbiAgICB0eXBlb2YgZGVjaW1hbHMgPT09ICdudW1iZXInIHx8XHJcbiAgICAodHlwZW9mIGRlY2ltYWxzID09PSAnc3RyaW5nJyAmJiBkZWNpbWFscy5tYXRjaCgvXigweCk/XFxkKyQvdSkpXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1pZ3JhdGVzIHByZWZlcmVuY2UgdG9rZW5zIHdpdGggZGVjaW1hbHMgdHlwZWQgYXMgc3RyaW5nIHRvIG51bWJlci5cclxuICogSXQgYWxzbyByZW1vdmVzIGFueSB0b2tlbnMgd2l0aCBjb3JydXB0ZWQgb3IgaW5jb252ZXJ0aWJsZSBkZWNpbWFsIHZhbHVlcy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG5cclxuICBpZiAoIW5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdG9rZW5zID0gbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2VucyB8fCBbXTtcclxuICAvLyBGaWx0ZXIgb3V0IGFueSB0b2tlbnMgd2l0aCBjb3JydXB0ZWQgZGVjaW1hbCB2YWx1ZXNcclxuICBjb25zdCB2YWxpZFRva2VucyA9IHRva2Vucy5maWx0ZXIoKHsgZGVjaW1hbHMgfSkgPT5cclxuICAgIGlzVmFsaWREZWNpbWFscyhkZWNpbWFscyksXHJcbiAgKTtcclxuICBmb3IgKGNvbnN0IHRva2VuIG9mIHZhbGlkVG9rZW5zKSB7XHJcbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIGRlY2ltYWwgdmFsdWUgdHlwZSBzdHJpbmcsIGNvbnZlcnQgdG8gYSBudW1iZXIuXHJcbiAgICBpZiAodHlwZW9mIHRva2VuLmRlY2ltYWxzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmFkaXhcclxuICAgICAgdG9rZW4uZGVjaW1hbHMgPSBwYXJzZUludCh0b2tlbi5kZWNpbWFscyk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgPSB2YWxpZFRva2VucztcclxuXHJcbiAgY29uc3QgeyBhY2NvdW50VG9rZW5zIH0gPSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XHJcbiAgaWYgKGFjY291bnRUb2tlbnMgJiYgdHlwZW9mIGFjY291bnRUb2tlbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykpIHtcclxuICAgICAgY29uc3QgbmV0d29ya1Rva2VucyA9IGFjY291bnRUb2tlbnNbYWRkcmVzc107XHJcbiAgICAgIGlmIChuZXR3b3JrVG9rZW5zICYmIHR5cGVvZiBuZXR3b3JrVG9rZW5zID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGZvciAoY29uc3QgbmV0d29yayBvZiBPYmplY3Qua2V5cyhuZXR3b3JrVG9rZW5zKSkge1xyXG4gICAgICAgICAgY29uc3QgdG9rZW5zT25OZXR3b3JrID0gbmV0d29ya1Rva2Vuc1tuZXR3b3JrXSB8fCBbXTtcclxuICAgICAgICAgIC8vIEZpbHRlciBvdXQgYW55IHRva2VucyB3aXRoIGNvcnJ1cHRlZCBkZWNpbWFsIHZhbHVlc1xyXG4gICAgICAgICAgY29uc3QgdmFsaWRUb2tlbnNPbk5ldHdvcmsgPSB0b2tlbnNPbk5ldHdvcmsuZmlsdGVyKCh7IGRlY2ltYWxzIH0pID0+XHJcbiAgICAgICAgICAgIGlzVmFsaWREZWNpbWFscyhkZWNpbWFscyksXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBkZWNpbWFsIHZhbHVlIHR5cGUgc3RyaW5nLCBjb252ZXJ0IHRvIGEgbnVtYmVyLlxyXG4gICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB2YWxpZFRva2Vuc09uTmV0d29yaykge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuLmRlY2ltYWxzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICAgICAgICAgIHRva2VuLmRlY2ltYWxzID0gcGFyc2VJbnQodG9rZW4uZGVjaW1hbHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBuZXR3b3JrVG9rZW5zW25ldHdvcmtdID0gdmFsaWRUb2tlbnNPbk5ldHdvcms7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0gYWNjb3VudFRva2VucztcclxuXHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCwgbWFwS2V5cyB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IEJVSUxUX0lOX05FVFdPUktTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA1NTtcclxuXHJcbi8qKlxyXG4gKiByZXBsYWNlICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcmsnIHdpdGggJ2luY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkJ1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmNvbnN0IFVOS05PV05fQ0hBSU5fSURfS0VZID0gJ1VOS05PV04nO1xyXG5cclxuQlVJTFRfSU5fTkVUV09SS1Mucmlua2VieSA9IHtcclxuICBuZXR3b3JrSWQ6ICc0JyxcclxuICBjaGFpbklkOiAnMHg0JyxcclxuICB0aWNrZXI6ICdFVEgnLFxyXG59O1xyXG5CVUlMVF9JTl9ORVRXT1JLUy5yb3BzdGVuID0ge1xyXG4gIG5ldHdvcmtJZDogJzMnLFxyXG4gIGNoYWluSWQ6ICcweDMnLFxyXG4gIHRpY2tlcjogJ0VUSCcsXHJcbn07XHJcbkJVSUxUX0lOX05FVFdPUktTLmtvdmFuID0ge1xyXG4gIG5ldHdvcmtJZDogJzQyJyxcclxuICBjaGFpbklkOiAnMHgyYScsXHJcbiAgdGlja2VyOiAnRVRIJyxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKFxyXG4gICAgc3RhdGU/LkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcj8uaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrXHJcbiAgKSB7XHJcbiAgICBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tCeUNoYWluSWQgPVxyXG4gICAgICBtYXBLZXlzKFxyXG4gICAgICAgIHN0YXRlLkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlclxyXG4gICAgICAgICAgLmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2Nrc0J5TmV0d29yayxcclxuICAgICAgICAvLyB1c2luZyBvcHRpb25hbCBjaGFpbmluZyBpbiBjYXNlIHVzZXIncyBzdGF0ZSBoYXMgZmV0Y2hlZCBibG9ja3MgZm9yXHJcbiAgICAgICAgLy8gUlBDIG5ldHdvcmsgdHlwZXMgKHdoaWNoIGRvbid0IG1hcCB0byBhIHNpbmdsZSBjaGFpbklkKS4gVGhpcyBzaG91bGRcclxuICAgICAgICAvLyBub3QgYmUgcG9zc2libGUsIGJ1dCBpdCdzIHNhZmVyXHJcbiAgICAgICAgKF8sIGtleSkgPT4gQlVJTFRfSU5fTkVUV09SS1Nba2V5XT8uY2hhaW5JZCA/PyBVTktOT1dOX0NIQUlOX0lEX0tFWSxcclxuICAgICAgKTtcclxuICAgIC8vIE5vdyB0aGF0IG1haW5uZXQgYW5kIHRlc3QgbmV0IGxhc3QgZmV0Y2hlZCBibG9ja3MgYXJlIGtleWVkIGJ5IHRoZWlyXHJcbiAgICAvLyByZXNwZWN0aXZlIGNoYWluSWRzLCB3ZSBjYW4gc2FmZWx5IGRlbGV0ZSBhbnl0aGluZyB3ZSBoYWQgZm9yIGN1c3RvbVxyXG4gICAgLy8gbmV0d29ya3MuIEFueSBjdXN0b20gbmV0d29yayB0aGF0IHNoYXJlcyBhIGNoYWluSWQgd2l0aCBvbmUgb2YgdGhlXHJcbiAgICAvLyBhZm9yZW1lbnRpb25lZCBuZXR3b3JrcyB3aWxsIHVzZSB0aGUgdmFsdWUgc3RvcmVkIGJ5IGNoYWluSWQuXHJcbiAgICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXHJcbiAgICAgIC5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja0J5Q2hhaW5JZFtVTktOT1dOX0NIQUlOX0lEX0tFWV07XHJcbiAgICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXHJcbiAgICAgIC5pbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcms7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDU2O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0b2tlbnMgdGhhdCBkb24ndCBoYXZlIGFuIGFkZHJlc3MgZHVlIHRvXHJcbiAqIGxhY2sgb2YgcHJldmlvdXMgYWRkVG9rZW4gdmFsaWRhdGlvbi4gIEFsc28gcmVtb3Zlc1xyXG4gKiBhbiB1bndhbnRlZCwgdW5kZWZpbmVkIGltYWdlIHByb3BlcnR5XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG5cclxuICAgIGNvbnN0IHsgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcblxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoUHJlZmVyZW5jZXNDb250cm9sbGVyPy50b2tlbnMpKSB7XHJcbiAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zLmZpbHRlcihcclxuICAgICAgICAoeyBhZGRyZXNzIH0pID0+IGFkZHJlc3MsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRUb2tlbnMgJiZcclxuICAgICAgdHlwZW9mIFByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID09PSAnb2JqZWN0J1xyXG4gICAgKSB7XHJcbiAgICAgIE9iamVjdC5rZXlzKFByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zKS5mb3JFYWNoKChhY2NvdW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2hhaW5zID0gT2JqZWN0LmtleXMoXHJcbiAgICAgICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1thY2NvdW50XSxcclxuICAgICAgICApO1xyXG4gICAgICAgIGNoYWlucy5mb3JFYWNoKChjaGFpbikgPT4ge1xyXG4gICAgICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbYWNjb3VudF1bY2hhaW5dID1cclxuICAgICAgICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbYWNjb3VudF1bY2hhaW5dLmZpbHRlcihcclxuICAgICAgICAgICAgICAoeyBhZGRyZXNzIH0pID0+IGFkZHJlc3MsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChcclxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hc3NldEltYWdlcyAmJlxyXG4gICAgICAndW5kZWZpbmVkJyBpbiBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYXNzZXRJbWFnZXNcclxuICAgICkge1xyXG4gICAgICBkZWxldGUgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFzc2V0SW1hZ2VzLnVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGtleUJ5IH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IGNyZWF0ZUlkIGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3JhbmRvbS1pZCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNTc7XHJcblxyXG4vKipcclxuICogcmVwbGFjZSAnaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrJyB3aXRoICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja0J5Q2hhaW5JZCdcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmIChcclxuICAgIHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucyAmJlxyXG4gICAgQXJyYXkuaXNBcnJheShzdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSAmJlxyXG4gICAgIXN0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMuc29tZShcclxuICAgICAgKGl0ZW0pID0+XHJcbiAgICAgICAgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnIHx8IHR5cGVvZiBpdGVtLnR4UGFyYW1zID09PSAndW5kZWZpbmVkJyxcclxuICAgIClcclxuICApIHtcclxuICAgIHN0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSBrZXlCeShcclxuICAgICAgc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyxcclxuICAgICAgLy8gSW4gY2FzZSBmb3Igc29tZSByZWFzb24gYW55IG9mIGEgdXNlcidzIHRyYW5zYWN0aW9ucyBkbyBub3QgaGF2ZSBhbiBpZFxyXG4gICAgICAvLyBnZW5lcmF0ZSBhIG5ldyBvbmUgZm9yIHRoZSB0cmFuc2FjdGlvbi5cclxuICAgICAgKHR4KSA9PiB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0eC5pZCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHguaWQgPT09IG51bGwpIHtcclxuICAgICAgICAgIC8vIFRoaXMgbXV0YXRlcyB0aGUgaXRlbSBpbiB0aGUgYXJyYXksIHNvIHdpbGwgcmVzdWx0IGluIGEgY2hhbmdlIHRvXHJcbiAgICAgICAgICAvLyB0aGUgc3RhdGUuXHJcbiAgICAgICAgICB0eC5pZCA9IGNyZWF0ZUlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eC5pZDtcclxuICAgICAgfSxcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDU4O1xyXG5cclxuLyoqXHJcbiAqIERlbGV0ZXMgdGhlIHN3YXBzV2VsY29tZU1lc3NhZ2VIYXNCZWVuU2hvd24gcHJvcGVydHkgZnJvbSBzdGF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgZGVsZXRlIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlcj8uc3dhcHNXZWxjb21lTWVzc2FnZUhhc0JlZW5TaG93bjtcclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgY2xvbmVEZWVwLFxyXG4gIGNvbmNhdCxcclxuICBncm91cEJ5LFxyXG4gIGtleUJ5LFxyXG4gIHBpY2tCeSxcclxuICBpc1BsYWluT2JqZWN0LFxyXG59IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDU5O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgb3JwaGFuZWQgY2FuY2VsIGFuZCByZXRyeSB0cmFuc2FjdGlvbnMgdGhhdCBubyBsb25nZXIgaGF2ZSB0aGVcclxuICogb3JpZ2luYWwgdHJhbnNhY3Rpb24gaW4gc3RhdGUsIHdoaWNoIHJlc3VsdHMgaW4gYnVncy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucztcclxuICBpZiAoaXNQbGFpbk9iamVjdCh0cmFuc2FjdGlvbnMpKSB7XHJcbiAgICBjb25zdCBub25jZU5ldHdvcmtHcm91cGVkT2JqZWN0ID0gZ3JvdXBCeShcclxuICAgICAgT2JqZWN0LnZhbHVlcyh0cmFuc2FjdGlvbnMpLFxyXG4gICAgICAodHgpID0+IHtcclxuICAgICAgICByZXR1cm4gYCR7dHgudHhQYXJhbXM/Lm5vbmNlfS0ke3R4LmNoYWluSWQgPz8gdHgubWV0YW1hc2tOZXR3b3JrSWR9YDtcclxuICAgICAgfSxcclxuICAgICk7XHJcblxyXG4gICAgY29uc3Qgd2l0aG91dE9ycGhhbnMgPSBwaWNrQnkobm9uY2VOZXR3b3JrR3JvdXBlZE9iamVjdCwgKGdyb3VwKSA9PiB7XHJcbiAgICAgIHJldHVybiBncm91cC5zb21lKFxyXG4gICAgICAgICh0eCkgPT5cclxuICAgICAgICAgIHR4LnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5jYW5jZWwgJiZcclxuICAgICAgICAgIHR4LnR5cGUgIT09IFRyYW5zYWN0aW9uVHlwZS5yZXRyeSxcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gICAgc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IGtleUJ5KFxyXG4gICAgICBjb25jYXQoLi4uT2JqZWN0LnZhbHVlcyh3aXRob3V0T3JwaGFucykpLFxyXG4gICAgICAodHgpID0+IHR4LmlkLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGlzUGxhaW5PYmplY3QgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDYwO1xyXG5jb25zdCBTVVBQT1JUX05PVElGSUNBVElPTl9LRVkgPSAyO1xyXG5jb25zdCBTVVBQT1JUX05PVElGSUNBVElPTl9EQVRFID0gJzIwMjAtMDgtMzEnO1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgdGhlIHN1cHBvcnQgc3VydmV5IG5vdGlmaWNhdGlvblxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5vdGlmaWNhdGlvbnMgPSBzdGF0ZT8uTm90aWZpY2F0aW9uQ29udHJvbGxlcj8ubm90aWZpY2F0aW9ucztcclxuICBpZiAoaXNQbGFpbk9iamVjdChub3RpZmljYXRpb25zKSkge1xyXG4gICAgaWYgKFxyXG4gICAgICBub3RpZmljYXRpb25zW1NVUFBPUlRfTk9USUZJQ0FUSU9OX0tFWV0/LmRhdGUgPT09XHJcbiAgICAgIFNVUFBPUlRfTk9USUZJQ0FUSU9OX0RBVEVcclxuICAgICkge1xyXG4gICAgICBkZWxldGUgc3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlci5ub3RpZmljYXRpb25zW1xyXG4gICAgICAgIFNVUFBPUlRfTk9USUZJQ0FUSU9OX0tFWVxyXG4gICAgICBdO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2MTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGF0dHJpYnV0ZXMgcmVsYXRlZCB0byByZWNvdmVyeSBzZWVkIHBocmFzZSByZW1pbmRlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgaWYgKHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlcikge1xyXG4gICAgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyLnJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd24gPSBmYWxzZTtcclxuICAgIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlci5yZWNvdmVyeVBocmFzZVJlbWluZGVyTGFzdFNob3duID0gY3VycmVudFRpbWU7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0YXRlLkFwcFN0YXRlQ29udHJvbGxlciA9IHtcclxuICAgICAgcmVjb3ZlcnlQaHJhc2VSZW1pbmRlckhhc0JlZW5TaG93bjogZmFsc2UsXHJcbiAgICAgIHJlY292ZXJ5UGhyYXNlUmVtaW5kZXJMYXN0U2hvd246IGN1cnJlbnRUaW1lLFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNjI7XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBtZXRhTWV0cmljc1NlbmRDb3VudCBmcm9tIE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IG1ldGFNZXRyaWNzU2VuZENvdW50IH0gPSBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXI7XHJcbiAgICBpZiAobWV0YU1ldHJpY3NTZW5kQ291bnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBkZWxldGUgc3RhdGUuTWV0YU1ldHJpY3NDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2MztcclxuXHJcbi8qKlxyXG4gKiBNb3ZlcyB0b2tlbiBzdGF0ZSBmcm9tIHByZWZlcmVuY2VzIGNvbnRyb2xsZXIgdG8gVG9rZW5zQ29udHJvbGxlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IGFjY291bnRUb2tlbnMgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50VG9rZW5zO1xyXG4gIGNvbnN0IGFjY291bnRIaWRkZW5Ub2tlbnMgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50SGlkZGVuVG9rZW5zO1xyXG5cclxuICBjb25zdCBuZXdBbGxUb2tlbnMgPSB7fTtcclxuICBpZiAoYWNjb3VudFRva2Vucykge1xyXG4gICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudEFkZHJlc3MpID0+IHtcclxuICAgICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2Vuc1thY2NvdW50QWRkcmVzc10pLmZvckVhY2goKGNoYWluSWQpID0+IHtcclxuICAgICAgICBjb25zdCB0b2tlbnNBcnJheSA9IGFjY291bnRUb2tlbnNbYWNjb3VudEFkZHJlc3NdW2NoYWluSWRdO1xyXG4gICAgICAgIGlmIChuZXdBbGxUb2tlbnNbY2hhaW5JZF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgbmV3QWxsVG9rZW5zW2NoYWluSWRdID0geyBbYWNjb3VudEFkZHJlc3NdOiB0b2tlbnNBcnJheSB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdBbGxUb2tlbnNbY2hhaW5JZF0gPSB7XHJcbiAgICAgICAgICAgIC4uLm5ld0FsbFRva2Vuc1tjaGFpbklkXSxcclxuICAgICAgICAgICAgW2FjY291bnRBZGRyZXNzXTogdG9rZW5zQXJyYXksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGNvbnN0IG5ld0FsbElnbm9yZWRUb2tlbnMgPSB7fTtcclxuICBpZiAoYWNjb3VudEhpZGRlblRva2Vucykge1xyXG4gICAgT2JqZWN0LmtleXMoYWNjb3VudEhpZGRlblRva2VucykuZm9yRWFjaCgoYWNjb3VudEFkZHJlc3MpID0+IHtcclxuICAgICAgT2JqZWN0LmtleXMoYWNjb3VudEhpZGRlblRva2Vuc1thY2NvdW50QWRkcmVzc10pLmZvckVhY2goKGNoYWluSWQpID0+IHtcclxuICAgICAgICBjb25zdCBpZ25vcmVkVG9rZW5zQXJyYXkgPSBhY2NvdW50SGlkZGVuVG9rZW5zW2FjY291bnRBZGRyZXNzXVtjaGFpbklkXTtcclxuICAgICAgICBpZiAobmV3QWxsSWdub3JlZFRva2Vuc1tjaGFpbklkXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBuZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdID0ge1xyXG4gICAgICAgICAgICBbYWNjb3VudEFkZHJlc3NdOiBpZ25vcmVkVG9rZW5zQXJyYXksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdID0ge1xyXG4gICAgICAgICAgICAuLi5uZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdLFxyXG4gICAgICAgICAgICBbYWNjb3VudEFkZHJlc3NdOiBpZ25vcmVkVG9rZW5zQXJyYXksXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmIChzdGF0ZS5Ub2tlbnNDb250cm9sbGVyKSB7XHJcbiAgICBzdGF0ZS5Ub2tlbnNDb250cm9sbGVyLmFsbFRva2VucyA9IG5ld0FsbFRva2VucztcclxuICAgIHN0YXRlLlRva2Vuc0NvbnRyb2xsZXIuYWxsSWdub3JlZFRva2VucyA9IG5ld0FsbElnbm9yZWRUb2tlbnM7XHJcbiAgfSBlbHNlIHtcclxuICAgIHN0YXRlLlRva2Vuc0NvbnRyb2xsZXIgPSB7XHJcbiAgICAgIGFsbFRva2VuczogbmV3QWxsVG9rZW5zLFxyXG4gICAgICBhbGxJZ25vcmVkVG9rZW5zOiBuZXdBbGxJZ25vcmVkVG9rZW5zLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50SGlkZGVuVG9rZW5zO1xyXG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hY2NvdW50VG9rZW5zO1xyXG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5hc3NldEltYWdlcztcclxuICBkZWxldGUgc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uaGlkZGVuVG9rZW5zO1xyXG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy50b2tlbnM7XHJcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnN1Z2dlc3RlZFRva2VucztcclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCwgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDY0O1xyXG5cclxuY29uc3QgU0VOVF9FVEhFUiA9ICdzZW50RXRoZXInOyAvLyB0aGUgbGVnYWN5IHRyYW5zYWN0aW9uIHR5cGUgYmVpbmcgcmVwbGFjZWQgaW4gdGhpcyBtaWdyYXRpb24gd2l0aCBUcmFuc2FjdGlvblR5cGUuc2ltcGxlU2VuZFxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgbWV0YU1ldHJpY3NTZW5kQ291bnQgZnJvbSBNZXRhTWV0cmljcyBjb250cm9sbGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zO1xyXG4gIGlmIChpc1BsYWluT2JqZWN0KHRyYW5zYWN0aW9ucykpIHtcclxuICAgIGZvciAoY29uc3QgdHggb2YgT2JqZWN0LnZhbHVlcyh0cmFuc2FjdGlvbnMpKSB7XHJcbiAgICAgIGlmICh0eC50eXBlID09PSBTRU5UX0VUSEVSKSB7XHJcbiAgICAgICAgdHgudHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5zaW1wbGVTZW5kO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0eC5oaXN0b3J5KSB7XHJcbiAgICAgICAgdHguaGlzdG9yeS5tYXAoKHR4RXZlbnQpID0+IHtcclxuICAgICAgICAgIGlmICh0eEV2ZW50LnR5cGUgJiYgdHhFdmVudC50eXBlID09PSBTRU5UX0VUSEVSKSB7XHJcbiAgICAgICAgICAgIHR4RXZlbnQudHlwZSA9IFRyYW5zYWN0aW9uVHlwZS5zaW1wbGVTZW5kO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIHR4RXZlbnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNjU7XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBtZXRhTWV0cmljc1NlbmRDb3VudCBmcm9tIE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IGNvbXBsZXRlZE9uYm9hcmRpbmcsIGZpcnN0VGltZUZsb3dUeXBlIH0gPVxyXG4gICAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XHJcbiAgICBzdGF0ZS5PbmJvYXJkaW5nQ29udHJvbGxlciA9IHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyID8/IHt9O1xyXG5cclxuICAgIGlmIChjb21wbGV0ZWRPbmJvYXJkaW5nICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgc3RhdGUuT25ib2FyZGluZ0NvbnRyb2xsZXIuY29tcGxldGVkT25ib2FyZGluZyA9IGNvbXBsZXRlZE9uYm9hcmRpbmc7XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkT25ib2FyZGluZztcclxuICAgIH1cclxuICAgIGlmIChmaXJzdFRpbWVGbG93VHlwZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyLmZpcnN0VGltZUZsb3dUeXBlID0gZmlyc3RUaW1lRmxvd1R5cGU7XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZmlyc3RUaW1lRmxvd1R5cGU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgTGVkZ2VyVHJhbnNwb3J0VHlwZXMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2hhcmR3YXJlLXdhbGxldHMnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDY2O1xyXG5cclxuLyoqXHJcbiAqIENoYW5nZXMgdGhlIHVzZUxlZGdlckxpdmUgYm9vbGVhbiBwcm9wZXJ0eSB0byB0aGUgbGVkZ2VyVHJhbnNwb3J0VHlwZSBlbnVtXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgZGVmYXVsdFRyYW5zcG9ydFR5cGUgPSB3aW5kb3cubmF2aWdhdG9yLmhpZFxyXG4gICAgPyBMZWRnZXJUcmFuc3BvcnRUeXBlcy53ZWJoaWRcclxuICAgIDogTGVkZ2VyVHJhbnNwb3J0VHlwZXMudTJmO1xyXG4gIGNvbnN0IHVzZUxlZGdlckxpdmUgPSBCb29sZWFuKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcj8udXNlTGVkZ2VyTGl2ZSk7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5zdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICBsZWRnZXJUcmFuc3BvcnRUeXBlOiB1c2VMZWRnZXJMaXZlXHJcbiAgICAgICAgPyBMZWRnZXJUcmFuc3BvcnRUeXBlcy5saXZlXHJcbiAgICAgICAgOiBkZWZhdWx0VHJhbnNwb3J0VHlwZSxcclxuICAgIH0sXHJcbiAgfTtcclxuICBkZWxldGUgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnVzZUxlZGdlckxpdmU7XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcclxuaW1wb3J0IHsgVEVTVF9DSEFJTlMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xyXG5cclxuY29uc3QgaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8gPSAoaGV4TnVtYmVyKSA9PlxyXG4gIG5ldyBCaWdOdW1iZXIoaGV4TnVtYmVyIHx8ICcweDAnLCAxNikuZ3QoMCk7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNjc7XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgc2hvd1Rlc3ROZXR3b3JrcyBwcm9wZXJ0eSB0byB0cnVlIGlmIGl0IHdhcyBmYWxzZSBvciB1bmRlZmluZWQsIGFuZCB0aGVyZSBpcyBldmlkZW5jZVxyXG4gKiB0aGF0IHRoZSB1c2VyIGhhcyB1c2VkIGEgdGVzdCBuZXRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyIHx8IHt9O1xyXG4gIGNvbnN0IHByZWZlcmVuY2VzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzIHx8IHt9O1xyXG5cclxuICBpZiAocHJlZmVyZW5jZXMuc2hvd1Rlc3ROZXR3b3Jrcykge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zIHx8IHt9O1xyXG4gIGNvbnN0IHByb3ZpZGVyID0gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXI/LnByb3ZpZGVyIHx8IHt9O1xyXG4gIGNvbnN0IGNhY2hlZEJhbGFuY2VzID0gc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcyB8fCB7fTtcclxuXHJcbiAgY29uc3QgdXNlcklzQ3VycmVudGx5T25BVGVzdE5ldCA9IFRFU1RfQ0hBSU5TLmluY2x1ZGVzKHByb3ZpZGVyPy5jaGFpbklkKTtcclxuICBjb25zdCB1c2VySGFzTWFkZUFUZXN0TmV0VHJhbnNhY3Rpb24gPSBPYmplY3QudmFsdWVzKHRyYW5zYWN0aW9ucykuc29tZShcclxuICAgICh7IGNoYWluSWQgfSkgPT4gVEVTVF9DSEFJTlMuaW5jbHVkZXMoY2hhaW5JZCksXHJcbiAgKTtcclxuICBjb25zdCB1c2VySGFzQUNhY2hlZEJhbGFuY2VPbkFUZXN0bmV0ID0gVEVTVF9DSEFJTlMuc29tZSgoY2hhaW5JZCkgPT4ge1xyXG4gICAgY29uc3QgY2FjaGVkQmFsYW5jZXNGb3JDaGFpbiA9IE9iamVjdC52YWx1ZXMoY2FjaGVkQmFsYW5jZXNbY2hhaW5JZF0gfHwge30pO1xyXG4gICAgY29uc3QgdXNlckhhc0FCYWxhbmNlR3JlYXRlclRoYW5aZXJvT25UaGlzQ2hhaW4gPVxyXG4gICAgICBjYWNoZWRCYWxhbmNlc0ZvckNoYWluLnNvbWUoaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8pO1xyXG4gICAgcmV0dXJuIHVzZXJIYXNBQmFsYW5jZUdyZWF0ZXJUaGFuWmVyb09uVGhpc0NoYWluO1xyXG4gIH0pO1xyXG4gIGNvbnN0IHVzZXJIYXNVc2VkQVRlc3RuZXQgPVxyXG4gICAgdXNlcklzQ3VycmVudGx5T25BVGVzdE5ldCB8fFxyXG4gICAgdXNlckhhc01hZGVBVGVzdE5ldFRyYW5zYWN0aW9uIHx8XHJcbiAgICB1c2VySGFzQUNhY2hlZEJhbGFuY2VPbkFUZXN0bmV0O1xyXG5cclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XHJcbiAgICAgIC4uLlByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgcHJlZmVyZW5jZXM6IHtcclxuICAgICAgICAuLi5wcmVmZXJlbmNlcyxcclxuICAgICAgICBzaG93VGVzdE5ldHdvcmtzOiB1c2VySGFzVXNlZEFUZXN0bmV0LFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2ODtcclxuXHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSBQZXJtaXNzaW9uc0NvbnRyb2xsZXIgYW5kIFBlcm1pc3Npb25zTWV0YWRhdGEgc3Vic3RhdGVzXHJcbiAqIHRvIG1hdGNoIHRoZSBuZXcgcGVybWlzc2lvbiBzeXN0ZW0uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgUGVybWlzc2lvbnNDb250cm9sbGVyID0ge30sXHJcbiAgICBQZXJtaXNzaW9uc01ldGFkYXRhID0ge30sXHJcbiAgICAuLi5yZW1haW5pbmdTdGF0ZVxyXG4gIH0gPSBzdGF0ZTtcclxuXHJcbiAgY29uc3Qge1xyXG4gICAgZG9tYWluTWV0YWRhdGEgPSB7fSxcclxuICAgIHBlcm1pc3Npb25zSGlzdG9yeSA9IHt9LFxyXG4gICAgcGVybWlzc2lvbnNMb2cgPSBbXSxcclxuICB9ID0gUGVybWlzc2lvbnNNZXRhZGF0YTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLnJlbWFpbmluZ1N0YXRlLFxyXG4gICAgUGVybWlzc2lvbkNvbnRyb2xsZXI6IGdldFBlcm1pc3Npb25Db250cm9sbGVyU3RhdGUoUGVybWlzc2lvbnNDb250cm9sbGVyKSxcclxuICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB7XHJcbiAgICAgIHBlcm1pc3Npb25BY3Rpdml0eUxvZzogcGVybWlzc2lvbnNMb2csXHJcbiAgICAgIHBlcm1pc3Npb25IaXN0b3J5OiBwZXJtaXNzaW9uc0hpc3RvcnksXHJcbiAgICB9LFxyXG4gICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjpcclxuICAgICAgZ2V0U3ViamVjdE1ldGFkYXRhQ29udHJvbGxlclN0YXRlKGRvbWFpbk1ldGFkYXRhKSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9uQ29udHJvbGxlclN0YXRlKFBlcm1pc3Npb25zQ29udHJvbGxlcikge1xyXG4gIGNvbnN0IHsgZG9tYWlucyA9IHt9IH0gPSBQZXJtaXNzaW9uc0NvbnRyb2xsZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4YW1wbGUgZXhpc3RpbmcgZG9tYWluIGVudHJ5LiBFdmVyeSBleGlzdGluZyBkb21haW4gd2lsbCBoYXZlIGEgc2luZ2xlXHJcbiAgICogZXRoX2FjY291bnRzIHBlcm1pc3Npb24sIHdoaWNoIHNpbXBsaWZpZXMgdGhlIHRyYW5zZm9ybS5cclxuICAgKlxyXG4gICAqICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pbyc6IHtcclxuICAgKiAgIHBlcm1pc3Npb25zOiBbXHJcbiAgICogICAgIHtcclxuICAgKiAgICAgICAnQGNvbnRleHQnOiBbJ2h0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9ycGMtY2FwJ10sXHJcbiAgICogICAgICAgJ2NhdmVhdHMnOiBbXHJcbiAgICogICAgICAgICB7XHJcbiAgICogICAgICAgICAgIG5hbWU6ICdwcmltYXJ5QWNjb3VudE9ubHknLFxyXG4gICAqICAgICAgICAgICB0eXBlOiAnbGltaXRSZXNwb25zZUxlbmd0aCcsXHJcbiAgICogICAgICAgICAgIHZhbHVlOiAxLFxyXG4gICAqICAgICAgICAgfSxcclxuICAgKiAgICAgICAgIHtcclxuICAgKiAgICAgICAgICAgbmFtZTogJ2V4cG9zZWRBY2NvdW50cycsXHJcbiAgICogICAgICAgICAgIHR5cGU6ICdmaWx0ZXJSZXNwb25zZScsXHJcbiAgICogICAgICAgICAgIHZhbHVlOiBbJzB4MGM5N2E1YzgxZTUwYTAyZmY4YmU3M2NjM2YwYTA1NjllNjFmNGVkOCddLFxyXG4gICAqICAgICAgICAgfSxcclxuICAgKiAgICAgICBdLFxyXG4gICAqICAgICAgICdkYXRlJzogMTYxNjAwNjM2OTQ5OCxcclxuICAgKiAgICAgICAnaWQnOiAnM2QwYmRjMjctZThlNC00ZmIwLWEyNGItMzQwZDYxZjZhM2ZhJyxcclxuICAgKiAgICAgICAnaW52b2tlcic6ICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pbycsXHJcbiAgICogICAgICAgJ3BhcmVudENhcGFiaWxpdHknOiAnZXRoX2FjY291bnRzJyxcclxuICAgKiAgICAgfSxcclxuICAgKiAgIF0sXHJcbiAgICogfSxcclxuICAgKi9cclxuXHJcbiAgY29uc3QgRVRIX0FDQ09VTlRTID0gJ2V0aF9hY2NvdW50cyc7XHJcbiAgY29uc3QgTkVXX0NBVkVBVF9UWVBFID0gJ3Jlc3RyaWN0UmV0dXJuZWRBY2NvdW50cyc7XHJcbiAgY29uc3QgT0xEX0NBVkVBVF9OQU1FID0gJ2V4cG9zZWRBY2NvdW50cyc7XHJcblxyXG4gIGNvbnN0IHN1YmplY3RzID0gT2JqZWN0LmVudHJpZXMoZG9tYWlucykucmVkdWNlKFxyXG4gICAgKHRyYW5zZm9ybWVkLCBbb3JpZ2luLCBkb21haW5FbnRyeV0pID0+IHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHBlcm1pc3Npb25zOiBbZXRoQWNjb3VudHNQZXJtaXNzaW9uXSxcclxuICAgICAgfSA9IGRvbWFpbkVudHJ5O1xyXG5cclxuICAgICAgLy8gVGhlcmUgYXJlIHR3byBjYXZlYXRzIGZvciBlYWNoIGV0aF9hY2NvdW50cyBwZXJtaXNzaW9uLCBidXQgd2Ugb25seVxyXG4gICAgICAvLyBuZWVkIHRoZSB2YWx1ZSBvZiBvbmUgb2YgdGhlbSBpbiB0aGUgbmV3IHBlcm1pc3Npb24gc3lzdGVtLlxyXG4gICAgICBjb25zdCBvbGRDYXZlYXQgPSBldGhBY2NvdW50c1Blcm1pc3Npb24uY2F2ZWF0cy5maW5kKFxyXG4gICAgICAgIChjYXZlYXQpID0+IGNhdmVhdC5uYW1lID09PSBPTERfQ0FWRUFUX05BTUUsXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBuZXdQZXJtaXNzaW9uID0ge1xyXG4gICAgICAgIC4uLmV0aEFjY291bnRzUGVybWlzc2lvbixcclxuICAgICAgICBjYXZlYXRzOiBbeyB0eXBlOiBORVdfQ0FWRUFUX1RZUEUsIHZhbHVlOiBvbGRDYXZlYXQudmFsdWUgfV0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBXZSBuZXZlciB1c2VkIHRoaXMsIGFuZCBqdXN0IG9taXQgaXQgaW4gdGhlIG5ldyBzeXN0ZW0uXHJcbiAgICAgIGRlbGV0ZSBuZXdQZXJtaXNzaW9uWydAY29udGV4dCddO1xyXG5cclxuICAgICAgdHJhbnNmb3JtZWRbb3JpZ2luXSA9IHtcclxuICAgICAgICBvcmlnaW4sXHJcbiAgICAgICAgcGVybWlzc2lvbnM6IHtcclxuICAgICAgICAgIFtFVEhfQUNDT1VOVFNdOiBuZXdQZXJtaXNzaW9uLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcclxuICAgIH0sXHJcbiAgICB7fSxcclxuICApO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3ViamVjdHMsXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U3ViamVjdE1ldGFkYXRhQ29udHJvbGxlclN0YXRlKGRvbWFpbk1ldGFkYXRhKSB7XHJcbiAgLyoqXHJcbiAgICogRXhhbXBsZSBleGlzdGluZyBkb21haW5NZXRhZGF0YSBlbnRyeS5cclxuICAgKlxyXG4gICAqIFwiaHR0cHM6Ly93d3cueW91dHViZS5jb21cIjoge1xyXG4gICAqICAgXCJob3N0XCI6IFwid3d3LnlvdXR1YmUuY29tXCIsXHJcbiAgICogICBcImljb25cIjogbnVsbCxcclxuICAgKiAgIFwibGFzdFVwZGF0ZWRcIjogMTYzNzY5NzkxNDkwOCxcclxuICAgKiAgIFwibmFtZVwiOiBcIllvdVR1YmVcIlxyXG4gICAqIH1cclxuICAgKi9cclxuXHJcbiAgY29uc3Qgc3ViamVjdE1ldGFkYXRhID0gT2JqZWN0LmVudHJpZXMoZG9tYWluTWV0YWRhdGEpLnJlZHVjZShcclxuICAgICh0cmFuc2Zvcm1lZCwgW29yaWdpbiwgbWV0YWRhdGFdKSA9PiB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBuYW1lID0gbnVsbCxcclxuICAgICAgICBpY29uID0gbnVsbCxcclxuICAgICAgICBleHRlbnNpb25JZCA9IG51bGwsXHJcbiAgICAgICAgLi4ub3RoZXJcclxuICAgICAgfSA9IG1ldGFkYXRhO1xyXG5cclxuICAgICAgLy8gV2UncmUgZ2V0dGluZyByaWQgb2YgdGhlc2UuXHJcbiAgICAgIGRlbGV0ZSBvdGhlci5sYXN0VXBkYXRlZDtcclxuICAgICAgZGVsZXRlIG90aGVyLmhvc3Q7XHJcblxyXG4gICAgICBpZiAob3JpZ2luKSB7XHJcbiAgICAgICAgdHJhbnNmb3JtZWRbb3JpZ2luXSA9IHtcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICBpY29uVXJsOiBpY29uLFxyXG4gICAgICAgICAgZXh0ZW5zaW9uSWQsXHJcbiAgICAgICAgICAuLi5vdGhlcixcclxuICAgICAgICAgIG9yaWdpbixcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcclxuICAgIH0sXHJcbiAgICB7fSxcclxuICApO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3ViamVjdE1ldGFkYXRhLFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgU3ViamVjdFR5cGUgfSBmcm9tICdAbWV0YW1hc2svc3ViamVjdC1tZXRhZGF0YS1jb250cm9sbGVyJztcclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2OTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBgc3ViamVjdFR5cGVgIHByb3BlcnR5IHRvIGFsbCBzdWJqZWN0IG1ldGFkYXRhLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmICh0eXBlb2Ygc3RhdGU/LlN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI/LnN1YmplY3RNZXRhZGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjogeyBzdWJqZWN0TWV0YWRhdGEgfSxcclxuICAgIH0gPSBzdGF0ZTtcclxuXHJcbiAgICAvLyBtdXRhdGUgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlci5zdWJqZWN0TWV0YWRhdGEgaW4gcGxhY2VcclxuICAgIE9iamVjdC52YWx1ZXMoc3ViamVjdE1ldGFkYXRhKS5mb3JFYWNoKChtZXRhZGF0YSkgPT4ge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgbWV0YWRhdGEgJiZcclxuICAgICAgICB0eXBlb2YgbWV0YWRhdGEgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgIUFycmF5LmlzQXJyYXkobWV0YWRhdGEpXHJcbiAgICAgICkge1xyXG4gICAgICAgIG1ldGFkYXRhLnN1YmplY3RUeXBlID0gbWV0YWRhdGEuZXh0ZW5zaW9uSWRcclxuICAgICAgICAgID8gU3ViamVjdFR5cGUuRXh0ZW5zaW9uXHJcbiAgICAgICAgICA6IFN1YmplY3RUeXBlLldlYnNpdGU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA3MDtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSBgcmVxdWVzdGAgYW5kIGByZXNwb25zZWAgcHJvcGVydGllcyBmcm9tXHJcbiAqIGBQZXJtaXNzaW9uTG9nQ29udHJvbGxlci5wZXJtaXNzaW9uQWN0aXZpdHlMb2dgIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGU/LlBlcm1pc3Npb25Mb2dDb250cm9sbGVyPy5wZXJtaXNzaW9uQWN0aXZpdHlMb2cpKSB7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB7IHBlcm1pc3Npb25BY3Rpdml0eUxvZyB9LFxyXG4gICAgfSA9IHN0YXRlO1xyXG5cclxuICAgIC8vIG11dGF0ZSBhY3Rpdml0eSBsb2cgZW50cmllcyBpbiBwbGFjZVxyXG4gICAgcGVybWlzc2lvbkFjdGl2aXR5TG9nLmZvckVhY2goKGxvZ0VudHJ5KSA9PiB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBsb2dFbnRyeSAmJlxyXG4gICAgICAgIHR5cGVvZiBsb2dFbnRyeSA9PT0gJ29iamVjdCcgJiZcclxuICAgICAgICAhQXJyYXkuaXNBcnJheShsb2dFbnRyeSlcclxuICAgICAgKSB7XHJcbiAgICAgICAgZGVsZXRlIGxvZ0VudHJ5LnJlcXVlc3Q7XHJcbiAgICAgICAgZGVsZXRlIGxvZ0VudHJ5LnJlc3BvbnNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNzE7XHJcblxyXG4vKipcclxuICogUmVuYW1lcyBOb3RpZmljYXRpb25Db250cm9sbGVyIHRvIEFubm91bmNlbWVudENvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlcikge1xyXG4gICAgc3RhdGUuQW5ub3VuY2VtZW50Q29udHJvbGxlciA9IHtcclxuICAgICAgYW5ub3VuY2VtZW50czogc3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlci5ub3RpZmljYXRpb25zLFxyXG4gICAgfTtcclxuICAgIGRlbGV0ZSBzdGF0ZS5Ob3RpZmljYXRpb25Db250cm9sbGVyO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA3MjtcclxuXHJcbi8qKlxyXG4gKiBTaG91bGQgZW1wdHkgdGhlIGBrbm93bk1ldGhvZERhdGFgIG9iamVjdCBpbiBQcmVmZXJlbmNlc0NvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyIHx8IHt9O1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcclxuICAgICAgLi4uUHJlZmVyZW5jZXNDb250cm9sbGVyLFxyXG4gICAgICBrbm93bk1ldGhvZERhdGE6IHt9LFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNzM7XHJcblxyXG4vKipcclxuICogU2hvdWxkIGVtcHR5IHRoZSBga25vd25NZXRob2REYXRhYCBvYmplY3QgaW4gUHJlZmVyZW5jZXNDb250cm9sbGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgUHJlZmVyZW5jZXNDb250cm9sbGVyID0gc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlciB8fCB7fTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XHJcbiAgICAgIC4uLlByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAga25vd25NZXRob2REYXRhOiB7fSxcclxuICAgIH0sXHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIHVuaXEgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XHJcbmltcG9ydCB7IGdldFJwY1VybCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNzQ7XHJcblxyXG5jb25zdCBoZXhOdW1iZXJJc0dyZWF0ZXJUaGFuWmVybyA9IChoZXhOdW1iZXIpID0+XHJcbiAgbmV3IEJpZ051bWJlcihoZXhOdW1iZXIgfHwgJzB4MCcsIDE2KS5ndCgwKTtcclxuXHJcbmNvbnN0IERFUFJFQ0FURURfVEVTVF9ORVRfQ0hBSU5JRFMgPSBbJzB4MycsICcweDJhJywgJzB4NCddO1xyXG5jb25zdCBERVBSRUNBVEVEX1RFU1RfTkVUX0RFVEFJTFMgPSB7XHJcbiAgJzB4Myc6IHtcclxuICAgIHJwY1VybDogZ2V0UnBjVXJsKHsgbmV0d29yazogJ3JvcHN0ZW4nIH0pLFxyXG4gICAgbmlja25hbWU6ICdSb3BzdGVuJyxcclxuICAgIHRpY2tlcjogJ1JvcHN0ZW5FVEgnLFxyXG4gIH0sXHJcbiAgJzB4MmEnOiB7XHJcbiAgICBycGNVcmw6IGdldFJwY1VybCh7IG5ldHdvcms6ICdrb3ZhbicgfSksXHJcbiAgICBuaWNrbmFtZTogJ0tvdmFuJyxcclxuICAgIHRpY2tlcjogJ0tvdmFuRVRIJyxcclxuICB9LFxyXG4gICcweDQnOiB7XHJcbiAgICBycGNVcmw6IGdldFJwY1VybCh7IG5ldHdvcms6ICdyaW5rZWJ5JyB9KSxcclxuICAgIG5pY2tuYW1lOiAnUmlua2VieScsXHJcbiAgICB0aWNrZXI6ICdSaW5rZWJ5RVRIJyxcclxuICB9LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1pZ3JhdGVzIHRoZSB1c2VyIGRlZmF1bHQgYnV0IGRlcHJlY2F0ZWQgdGVzdG5ldCBuZXR3b3JrcyB0byBjdXN0b20gbmV0d29ya3MsIGFuZFxyXG4gKiBpZiB0aGUgY3VycmVudCBuZXR3b3JrIGlzIG9uZSBzdWNoIG5ldHdvcmssIHVwZGF0ZXMgdGhlIG5ldHdvcmsgcHJvdmlkZXIgZGV0YWlscyBzbyB0aGF0IGl0XHJcbiAqIHdpbGwgd29yayBhcyBhIGN1c3RvbSBycGNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyIHx8IHt9O1xyXG4gIGNvbnN0IHByZWZlcmVuY2VzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzIHx8IHt9O1xyXG4gIGNvbnN0IE5ldHdvcmtDb250cm9sbGVyID0gc3RhdGU/Lk5ldHdvcmtDb250cm9sbGVyIHx8IHt9O1xyXG4gIGNvbnN0IHByb3ZpZGVyID0gTmV0d29ya0NvbnRyb2xsZXI/LnByb3ZpZGVyIHx8IHt9O1xyXG5cclxuICBjb25zdCBjdXJyZW50bHlPbkRlcHJlY2F0ZWROZXR3b3JrID0gREVQUkVDQVRFRF9URVNUX05FVF9DSEFJTklEUy5maWx0ZXIoXHJcbiAgICAoY2hhaW5JZCkgPT4gY2hhaW5JZCA9PT0gcHJvdmlkZXI/LmNoYWluSWQsXHJcbiAgKTtcclxuXHJcbiAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3Qgd2FudCB0byBzZWUgdGVzdCBuZXR3b3JrcywgYW5kIGlmIHRoZSB0aGUgdXNlciBpcyBub3Qgb24gYSBkZXByZWNhdGVkIHRlc3QgbmV0d29yaywgdGhlblxyXG4gIC8vIG5vIG5lZWQgdG8gbWlncmF0ZSB0aGUgdGVzdCBuZXR3b3JrIGRhdGEgdG8gYSBjdXN0b20gbmV0d29ya1xyXG4gIGlmIChcclxuICAgICFwcmVmZXJlbmNlcy5zaG93VGVzdE5ldHdvcmtzICYmXHJcbiAgICBjdXJyZW50bHlPbkRlcHJlY2F0ZWROZXR3b3JrLmxlbmd0aCA9PT0gMFxyXG4gICkge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zIHx8IHt9O1xyXG4gIGNvbnN0IGNhY2hlZEJhbGFuY2VzID0gc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcyB8fCB7fTtcclxuXHJcbiAgY29uc3QgZGVwcmVjYXRlZFRlc3RuZXRzT25XaGljaFRoZVVzZXJIYXNNYWRlQVRyYW5zYWN0aW9uID0gT2JqZWN0LnZhbHVlcyhcclxuICAgIHRyYW5zYWN0aW9ucyxcclxuICApXHJcbiAgICAuZmlsdGVyKCh7IGNoYWluSWQgfSkgPT4gREVQUkVDQVRFRF9URVNUX05FVF9DSEFJTklEUy5pbmNsdWRlcyhjaGFpbklkKSlcclxuICAgIC5tYXAoKHsgY2hhaW5JZCB9KSA9PiBjaGFpbklkKTtcclxuICBjb25zdCBkZXByZWNhdGVkVGVzdG5ldHNPbldoaWNoVGhlVXNlckhhc0NhY2hlZEJhbGFuY2UgPVxyXG4gICAgREVQUkVDQVRFRF9URVNUX05FVF9DSEFJTklEUy5maWx0ZXIoKGNoYWluSWQpID0+IHtcclxuICAgICAgY29uc3QgY2FjaGVkQmFsYW5jZXNGb3JDaGFpbiA9IE9iamVjdC52YWx1ZXMoXHJcbiAgICAgICAgY2FjaGVkQmFsYW5jZXNbY2hhaW5JZF0gfHwge30sXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHVzZXJIYXNBQmFsYW5jZUdyZWF0ZXJUaGFuWmVyb09uVGhpc0NoYWluID1cclxuICAgICAgICBjYWNoZWRCYWxhbmNlc0ZvckNoYWluLnNvbWUoaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8pO1xyXG4gICAgICByZXR1cm4gdXNlckhhc0FCYWxhbmNlR3JlYXRlclRoYW5aZXJvT25UaGlzQ2hhaW47XHJcbiAgICB9KTtcclxuICBjb25zdCBkZXByZWNhdGVkVGVzdG5ldHNUaGF0SGF2ZUJlZW5Vc2VkID0gdW5pcShbXHJcbiAgICAuLi5kZXByZWNhdGVkVGVzdG5ldHNPbldoaWNoVGhlVXNlckhhc0NhY2hlZEJhbGFuY2UsXHJcbiAgICAuLi5kZXByZWNhdGVkVGVzdG5ldHNPbldoaWNoVGhlVXNlckhhc01hZGVBVHJhbnNhY3Rpb24sXHJcbiAgICAuLi5jdXJyZW50bHlPbkRlcHJlY2F0ZWROZXR3b3JrLFxyXG4gIF0pO1xyXG5cclxuICBjb25zdCBuZXdGcmVxdWVudFJwY0xpc3REZXRhaWwgPVxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLmZyZXF1ZW50UnBjTGlzdERldGFpbCA/PyBbXTtcclxuXHJcbiAgZGVwcmVjYXRlZFRlc3RuZXRzVGhhdEhhdmVCZWVuVXNlZC5mb3JFYWNoKChjaGFpbklkKSA9PiB7XHJcbiAgICBpZiAoXHJcbiAgICAgICFuZXdGcmVxdWVudFJwY0xpc3REZXRhaWwuZmluZChcclxuICAgICAgICAocnBjRGV0YWlscykgPT4gcnBjRGV0YWlscy5jaGFpbklkID09PSBjaGFpbklkLFxyXG4gICAgICApXHJcbiAgICApIHtcclxuICAgICAgbmV3RnJlcXVlbnRScGNMaXN0RGV0YWlsLnVuc2hpZnQoe1xyXG4gICAgICAgIHJwY1VybDogREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTW2NoYWluSWRdLnJwY1VybCxcclxuICAgICAgICBjaGFpbklkLFxyXG4gICAgICAgIHRpY2tlcjogREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTW2NoYWluSWRdLnRpY2tlcixcclxuICAgICAgICBuaWNrbmFtZTogREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTW2NoYWluSWRdLm5pY2tuYW1lLFxyXG4gICAgICAgIHJwY1ByZWZzOiB7fSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGlmIChuZXdGcmVxdWVudFJwY0xpc3REZXRhaWwubGVuZ3RoKSB7XHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID0gbmV3RnJlcXVlbnRScGNMaXN0RGV0YWlsO1xyXG4gIH1cclxuXHJcbiAgaWYgKGN1cnJlbnRseU9uRGVwcmVjYXRlZE5ldHdvcmsubGVuZ3RoKSB7XHJcbiAgICBjb25zdCBzZWxlY3RlZE5ldHdvcmtDaGFpbklkID0gY3VycmVudGx5T25EZXByZWNhdGVkTmV0d29ya1swXTtcclxuICAgIE5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyID0ge1xyXG4gICAgICAuLi5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlcixcclxuICAgICAgdHlwZTogJ3JwYycsXHJcbiAgICAgIHJwY1VybDogREVQUkVDQVRFRF9URVNUX05FVF9ERVRBSUxTW3NlbGVjdGVkTmV0d29ya0NoYWluSWRdLnJwY1VybCxcclxuICAgICAgY2hhaW5JZDogc2VsZWN0ZWROZXR3b3JrQ2hhaW5JZCxcclxuICAgICAgbmlja25hbWU6IERFUFJFQ0FURURfVEVTVF9ORVRfREVUQUlMU1tzZWxlY3RlZE5ldHdvcmtDaGFpbklkXS5uaWNrbmFtZSxcclxuICAgICAgdGlja2VyOiBERVBSRUNBVEVEX1RFU1RfTkVUX0RFVEFJTFNbc2VsZWN0ZWROZXR3b3JrQ2hhaW5JZF0udGlja2VyLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICB9LFxyXG4gICAgTmV0d29ya0NvbnRyb2xsZXI6IHtcclxuICAgICAgLi4uTmV0d29ya0NvbnRyb2xsZXIsXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA3NTtcclxuXHJcbi8qKlxyXG4gKiBEZWxldGUgdGhlIFRocmVlQm94Q29udHJvbGxlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBkZWxldGUgc3RhdGUuVGhyZWVCb3hDb250cm9sbGVyO1xyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDc2O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0byBgQG1ldGFtYXNrL2NvbnRyb2xsZXJzQDMzLjAuMGAgKHJlbmFtZSBcIkNvbGxlY3RpYmxlXCIgdG8gXCJORlRcIikuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKHN0YXRlLkNvbGxlY3RpYmxlc0NvbnRyb2xsZXIpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgYWxsQ29sbGVjdGlibGVDb250cmFjdHMsXHJcbiAgICAgIGFsbENvbGxlY3RpYmxlcyxcclxuICAgICAgaWdub3JlZENvbGxlY3RpYmxlcyxcclxuICAgICAgLi4ucmVtYWluaW5nU3RhdGVcclxuICAgIH0gPSBzdGF0ZS5Db2xsZWN0aWJsZXNDb250cm9sbGVyO1xyXG4gICAgc3RhdGUuTmZ0Q29udHJvbGxlciA9IHtcclxuICAgICAgLi4uKGFsbENvbGxlY3RpYmxlQ29udHJhY3RzXHJcbiAgICAgICAgPyB7IGFsbE5mdENvbnRyYWN0czogYWxsQ29sbGVjdGlibGVDb250cmFjdHMgfVxyXG4gICAgICAgIDoge30pLFxyXG4gICAgICAuLi4oYWxsQ29sbGVjdGlibGVzID8geyBhbGxOZnRzOiBhbGxDb2xsZWN0aWJsZXMgfSA6IHt9KSxcclxuICAgICAgLi4uKGlnbm9yZWRDb2xsZWN0aWJsZXMgPyB7IGlnbm9yZWROZnRzOiBpZ25vcmVkQ29sbGVjdGlibGVzIH0gOiB7fSksXHJcbiAgICAgIC4uLnJlbWFpbmluZ1N0YXRlLFxyXG4gICAgfTtcclxuICAgIGRlbGV0ZSBzdGF0ZS5Db2xsZWN0aWJsZXNDb250cm9sbGVyO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcj8udXNlQ29sbGVjdGlibGVEZXRlY3Rpb24pIHtcclxuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci51c2VOZnREZXRlY3Rpb24gPVxyXG4gICAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudXNlQ29sbGVjdGlibGVEZXRlY3Rpb247XHJcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNzc7XHJcblxyXG4vKipcclxuICogUHJpb3IgdG8gdG9rZW4gZGV0ZWN0aW9uIHYyIHRoZSBkYXRhIHByb3BlcnR5IGluIHRva2Vuc0NoYWluc0NhY2hlIHdhcyBhbiBhcnJheSxcclxuICogaW4gdjIgd2UgY2hhbmdlcyB0aGF0IHRvIGFuIG9iamVjdC4gSW4gdGhpcyBtaWdyYXRpb24gd2UgYXJlIGNvbnZlcnRpbmcgdGhlIGRhdGEgYXMgYXJyYXkgdG8gb2JqZWN0LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IFRva2VuTGlzdENvbnRyb2xsZXIgPSBzdGF0ZT8uVG9rZW5MaXN0Q29udHJvbGxlciB8fCB7fTtcclxuXHJcbiAgY29uc3QgeyB0b2tlbnNDaGFpbnNDYWNoZSB9ID0gVG9rZW5MaXN0Q29udHJvbGxlcjtcclxuXHJcbiAgbGV0IGRhdGFDYWNoZTtcclxuICBsZXQgZGF0YU9iamVjdDtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICBmb3IgKGNvbnN0IGNoYWluSWQgaW4gdG9rZW5zQ2hhaW5zQ2FjaGUpIHtcclxuICAgIGRhdGFDYWNoZSA9IHRva2Vuc0NoYWluc0NhY2hlW2NoYWluSWRdLmRhdGE7XHJcbiAgICBkYXRhT2JqZWN0ID0ge307XHJcbiAgICAvLyBpZiB0aGUgZGF0YSBpcyBhcnJheSBjb252ZXIgdGhhdCB0byBvYmplY3RcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFDYWNoZSkpIHtcclxuICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBkYXRhQ2FjaGUpIHtcclxuICAgICAgICBkYXRhT2JqZWN0W3Rva2VuLmFkZHJlc3NdID0gdG9rZW47XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgIE9iamVjdC5rZXlzKGRhdGFDYWNoZSlbMF0udG9Mb3dlckNhc2UoKSAhPT1cclxuICAgICAgZGF0YUNhY2hlW09iamVjdC5rZXlzKGRhdGFDYWNoZSlbMF1dLmFkZHJlc3MudG9Mb3dlckNhc2UoKVxyXG4gICAgKSB7XHJcbiAgICAgIC8vIGZvciB0aGUgdXNlcnMgd2hvIGFscmVhZHkgdXBkYXRlZCB0byB0aGUgcmVjZW50IHZlcnNpb25cclxuICAgICAgLy8gYW5kIHRoZSBkYXRhQ2FjaGUgaXMgYWxyZWFkeSBhbiBvYmplY3Qga2V5ZWQgd2l0aCAwLDEsMiwzIGV0Y1xyXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgZm9yIChjb25zdCB0b2tlbkFkZHJlc3MgaW4gZGF0YUNhY2hlKSB7XHJcbiAgICAgICAgZGF0YU9iamVjdFtkYXRhQ2FjaGVbdG9rZW5BZGRyZXNzXS5hZGRyZXNzXSA9IGRhdGFDYWNoZVt0b2tlbkFkZHJlc3NdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICB0b2tlbnNDaGFpbnNDYWNoZVtjaGFpbklkXS5kYXRhID1cclxuICAgICAgT2JqZWN0LmtleXMoZGF0YU9iamVjdCkubGVuZ3RoID4gMCA/IGRhdGFPYmplY3QgOiBkYXRhQ2FjaGU7XHJcbiAgfVxyXG4gIFRva2VuTGlzdENvbnRyb2xsZXIudG9rZW5zQ2hhaW5zQ2FjaGUgPSB0b2tlbnNDaGFpbnNDYWNoZTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgVG9rZW5MaXN0Q29udHJvbGxlcjoge1xyXG4gICAgICAuLi5Ub2tlbkxpc3RDb250cm9sbGVyLFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IGhhc1Byb3BlcnR5LCBpc09iamVjdCB9IGZyb20gJ0BtZXRhbWFzay91dGlscyc7XHJcblxyXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IDc4O1xyXG5cclxuLyoqXHJcbiAqIFRoZWBAbWV0YW1hc2svcGhpc2hpbmctY29udHJvbGxlcmAgc3RhdGUgd2FzIHVwZGF0ZWQgaW4gdjIuMC4wLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cclxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XHJcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxufSkge1xyXG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XHJcbiAgaWYgKFxyXG4gICAgIWhhc1Byb3BlcnR5KHN0YXRlLCAnUGhpc2hpbmdDb250cm9sbGVyJykgfHxcclxuICAgICFpc09iamVjdChzdGF0ZS5QaGlzaGluZ0NvbnRyb2xsZXIpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG4gIGNvbnN0IHsgUGhpc2hpbmdDb250cm9sbGVyIH0gPSBzdGF0ZTtcclxuXHJcbiAgZGVsZXRlIFBoaXNoaW5nQ29udHJvbGxlci5waGlzaGluZztcclxuICBkZWxldGUgUGhpc2hpbmdDb250cm9sbGVyLmxhc3RGZXRjaGVkO1xyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA3OTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgY29sbGVjdGlibGVzRHJvcGRvd25TdGF0ZSBhbmQgY29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkOi5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoXHJcbiAgICBzdGF0ZT8uQXBwU3RhdGVDb250cm9sbGVyPy5jb2xsZWN0aWJsZXNEZXRlY3Rpb25Ob3RpY2VEaXNtaXNzZWQgIT09XHJcbiAgICB1bmRlZmluZWRcclxuICApIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIuY29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkO1xyXG4gIH1cclxuICBpZiAoc3RhdGU/Lm1ldGFtYXNrPy5jb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5tZXRhbWFzay5jb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA4MDtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcG9ydGZvbGlvIHRvb2x0aXAgaGFzIGJlZW4gbW92ZWQgdG8gYSBidXR0b24gb24gdGhlIGhvbWUgc2NyZWVuIHNvXHJcbiAqIHRoaXMgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIG5lZWRlZCBpbiBzdGF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmIChzdGF0ZT8ubWV0YW1hc2s/LnNob3dQb3J0Zm9saW9Ub29sdGlwICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5tZXRhbWFzay5zaG93UG9ydGZvbGlvVG9vbHRpcDtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIGlzQXJyYXkgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBoYXNQcm9wZXJ0eSwgaXNPYmplY3QgfSBmcm9tICdAbWV0YW1hc2svdXRpbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSA4MTtcclxuXHJcbi8qKlxyXG4gKiBQcmlvciB0byB0aGlzIG1pZ3JhdGlvbiwgc25hcCA8PiBkYXBwIHBlcm1pc3Npb25zIHdlcmUgd2lsZGNhcmRzIGkuZS4gYHdhbGxldF9zbmFwXypgLlxyXG4gKiBOb3cgdGhlIHBlcm1pc3Npb24gaGFzIGJlZW4gY2hhbmdlZCB0byBgd2FsbGV0X3NuYXBgIGFuZCB0aGUgY3VycmVudCBzbmFwIHBlcm1pc3Npb25zXHJcbiAqIHRoYXQgYXJlIHVuZGVyIHdpbGRjYXJkcyB3aWxsIGJlIGFkZGVkIGFzIGNhdmVhdHMgdG8gYSBwYXJlbnQgYHdhbGxldF9zbmFwYCBwZXJtaXNzaW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cclxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XHJcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxufSkge1xyXG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbn1cclxuXHJcbi8vIFdlIHJldHVybiBzdGF0ZSBBUyBJUyBpZiB0aGVyZSBpcyBhbnkgY29ycnVwdGlvblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcclxuICBpZiAoXHJcbiAgICAhaGFzUHJvcGVydHkoc3RhdGUsICdTbmFwQ29udHJvbGxlcicpIHx8XHJcbiAgICAhaGFzUHJvcGVydHkoc3RhdGUsICdQZXJtaXNzaW9uQ29udHJvbGxlcicpIHx8XHJcbiAgICAhaXNPYmplY3Qoc3RhdGUuUGVybWlzc2lvbkNvbnRyb2xsZXIpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG4gIGNvbnN0IHsgUGVybWlzc2lvbkNvbnRyb2xsZXIgfSA9IHN0YXRlO1xyXG5cclxuICBjb25zdCB7IHN1YmplY3RzIH0gPSBQZXJtaXNzaW9uQ29udHJvbGxlcjtcclxuXHJcbiAgaWYgKCFpc09iamVjdChzdWJqZWN0cykpIHtcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNuYXBQcmVmaXggPSAnd2FsbGV0X3NuYXBfJztcclxuXHJcbiAgZm9yIChjb25zdCBbc3ViamVjdE5hbWUsIHN1YmplY3RdIG9mIE9iamVjdC5lbnRyaWVzKHN1YmplY3RzKSkge1xyXG4gICAgaWYgKCFpc09iamVjdChzdWJqZWN0KSB8fCAhaXNPYmplY3Qoc3ViamVjdC5wZXJtaXNzaW9ucykpIHtcclxuICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG4gICAgLy8gV2Uga2VlcCB0cmFjayBvZiB0aGUgbGF0ZXN0IHBlcm1pc3Npb24ncyBkYXRlIGFuZCBhc3NvY2lhdGVkIGlkXHJcbiAgICAvLyB0byBhc3NpZ24gdG8gdGhlIHdhbGxldF9zbmFwIHBlcm1pc3Npb24gYWZ0ZXIgaXRlcmF0aW5nIHRocm91Z2ggYWxsIHBlcm1pc3Npb25zXHJcbiAgICBsZXQgZGF0ZSA9IDE7XHJcbiAgICBsZXQgaWQ7XHJcbiAgICBjb25zdCB7IHBlcm1pc3Npb25zIH0gPSBzdWJqZWN0O1xyXG4gICAgLy8gTmV3IHBlcm1pc3Npb25zIG9iamVjdCB0aGF0IHdlIHVzZSB0byB0YWNrIG9uIHRoZSBgd2FsbGV0X3NuYXBgIHBlcm1pc3Npb25cclxuICAgIGNvbnN0IHVwZGF0ZWRQZXJtaXNzaW9ucyA9IHsgLi4ucGVybWlzc2lvbnMgfTtcclxuICAgIGZvciAoY29uc3QgW3Blcm1pc3Npb25OYW1lLCBwZXJtaXNzaW9uXSBvZiBPYmplY3QuZW50cmllcyhwZXJtaXNzaW9ucykpIHtcclxuICAgICAgLy8gY2hlY2sgaWYgdGhlIHBlcm1pc3Npb24gaXMgbmFtZXNwYWNlZFxyXG4gICAgICBpZiAocGVybWlzc2lvbk5hbWUuc3RhcnRzV2l0aChzbmFwUHJlZml4KSkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFpc09iamVjdChwZXJtaXNzaW9uKSB8fFxyXG4gICAgICAgICAgIWhhc1Byb3BlcnR5KHBlcm1pc3Npb24sICdpZCcpIHx8XHJcbiAgICAgICAgICAhaGFzUHJvcGVydHkocGVybWlzc2lvbiwgJ2RhdGUnKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSBjcmVhdGUgYSB3YWxsZXRfc25hcCBrZXkgaWYgd2UgYWxyZWFkeSBkb24ndCBoYXZlIG9uZVxyXG4gICAgICAgIGlmICghaGFzUHJvcGVydHkodXBkYXRlZFBlcm1pc3Npb25zLCAnd2FsbGV0X3NuYXAnKSkge1xyXG4gICAgICAgICAgdXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwID0ge1xyXG4gICAgICAgICAgICBjYXZlYXRzOiBbeyB0eXBlOiAnc25hcElkcycsIHZhbHVlOiB7fSB9XSxcclxuICAgICAgICAgICAgaW52b2tlcjogc3ViamVjdE5hbWUsXHJcbiAgICAgICAgICAgIHBhcmVudENhcGFiaWxpdHk6ICd3YWxsZXRfc25hcCcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV4aXN0aW5nIHBlcm1pc3Npb24gaXMgdmFsaWRcclxuICAgICAgICBpZiAoIWlzT2JqZWN0KHVwZGF0ZWRQZXJtaXNzaW9ucy53YWxsZXRfc25hcCkpIHtcclxuICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFpc0FycmF5KFxyXG4gICAgICAgICAgICAodXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KS5jYXZlYXRzLFxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkaW5nIHRoZSBzbmFwIG5hbWUgdG8gdGhlIHdhbGxldF9zbmFwIHBlcm1pc3Npb24ncyBjYXZlYXQgdmFsdWVcclxuICAgICAgICBjb25zdCBzbmFwSWQgPSBwZXJtaXNzaW9uTmFtZS5zbGljZShzbmFwUHJlZml4Lmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3QgY2F2ZWF0ID0gKFxyXG4gICAgICAgICAgKHVwZGF0ZWRQZXJtaXNzaW9ucy53YWxsZXRfc25hcCBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxyXG4gICAgICAgICAgICAuY2F2ZWF0cyBhcyB1bmtub3duW11cclxuICAgICAgICApWzBdO1xyXG5cclxuICAgICAgICBpZiAoIWlzT2JqZWN0KGNhdmVhdCkpIHtcclxuICAgICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICFoYXNQcm9wZXJ0eShjYXZlYXQsICd0eXBlJykgfHxcclxuICAgICAgICAgIGNhdmVhdC50eXBlICE9PSAnc25hcElkcycgfHxcclxuICAgICAgICAgICFoYXNQcm9wZXJ0eShjYXZlYXQsICd2YWx1ZScpIHx8XHJcbiAgICAgICAgICAhaXNPYmplY3QoY2F2ZWF0LnZhbHVlKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXZlYXQudmFsdWVbc25hcElkXSA9IHt9O1xyXG5cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICB0eXBlb2YgcGVybWlzc2lvbi5kYXRlICE9PSAnbnVtYmVyJyB8fFxyXG4gICAgICAgICAgdHlwZW9mIHBlcm1pc3Npb24uaWQgIT09ICdzdHJpbmcnXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB1cGRhdGluZyB0aGUgZGF0ZSAmIGlkIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCBhbGwgcGVybWlzc2lvbnNcclxuICAgICAgICBpZiAocGVybWlzc2lvbi5kYXRlID4gZGF0ZSkge1xyXG4gICAgICAgICAgZGF0ZSA9IHBlcm1pc3Npb24uZGF0ZTtcclxuICAgICAgICAgIGlkID0gcGVybWlzc2lvbi5pZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIGZpbmFsbHkgZGVsZXRpbmcgdGhlIHN0YWxlIHBlcm1pc3Npb25cclxuICAgICAgICBkZWxldGUgdXBkYXRlZFBlcm1pc3Npb25zW3Blcm1pc3Npb25OYW1lXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIHdlIHJlYXNzaWduIHRoZSBkYXRlIGFuZCBpZCBoZXJlIGFmdGVyIGl0ZXJhdGluZyB0aHJvdWdoIGFsbCBwZXJtaXNzaW9uc1xyXG4gICAgLy8gYW5kIHVwZGF0ZSB0aGUgc3ViamVjdCB3aXRoIHRoZSB1cGRhdGVkIHBlcm1pc3Npb25zXHJcbiAgICBpZiAodXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwKSB7XHJcbiAgICAgICh1cGRhdGVkUGVybWlzc2lvbnMud2FsbGV0X3NuYXAgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pLmRhdGUgPSBkYXRlO1xyXG4gICAgICAodXBkYXRlZFBlcm1pc3Npb25zLndhbGxldF9zbmFwIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KS5pZCA9IGlkO1xyXG4gICAgICBzdWJqZWN0LnBlcm1pc3Npb25zID0gdXBkYXRlZFBlcm1pc3Npb25zO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IGhhc1Byb3BlcnR5LCBpc09iamVjdCB9IGZyb20gJ0BtZXRhbWFzay91dGlscyc7XHJcbmltcG9ydCB7IHY0IH0gZnJvbSAndXVpZCc7XHJcblxyXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IDgyO1xyXG5cclxuLyoqXHJcbiAqIE1pZ3JhdGUgdGhlIGZyZXF1ZW50UnBjTGlzdERldGFpbCBmcm9tIHRoZSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgdG8gdGhlIE5ldHdvcmtDb250cm9sbGVyLCBjb252ZXJ0IGl0IGZyb20gYW4gYXJyYXkgdG8gYW4gb2JqZWN0XHJcbiAqIGtleWVkIGJ5IHJhbmRvbSB1dWlkcy5cclxuICpcclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YSAtIFZlcnNpb25lZCBNZXRhTWFzayBleHRlbnNpb24gc3RhdGUsIGV4YWN0bHkgd2hhdCB3ZSBwZXJzaXN0IHRvIGRpc3QuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YSAtIFN0YXRlIG1ldGFkYXRhLlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiAtIFRoZSBjdXJyZW50IHN0YXRlIHZlcnNpb24uXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEuZGF0YSAtIFRoZSBwZXJzaXN0ZWQgTWV0YU1hc2sgc3RhdGUsIGtleWVkIGJ5IGNvbnRyb2xsZXIuXHJcbiAqIEByZXR1cm5zIFVwZGF0ZWQgdmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YToge1xyXG4gIG1ldGE6IHsgdmVyc2lvbjogbnVtYmVyIH07XHJcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcbn0pIHtcclxuICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHZlcnNpb25lZERhdGEuZGF0YSk7XHJcbiAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xyXG4gIGlmIChcclxuICAgICFoYXNQcm9wZXJ0eShzdGF0ZSwgJ1ByZWZlcmVuY2VzQ29udHJvbGxlcicpIHx8XHJcbiAgICAhaXNPYmplY3Qoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB8fFxyXG4gICAgIWlzT2JqZWN0KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyKSB8fFxyXG4gICAgIWhhc1Byb3BlcnR5KHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlciwgJ2ZyZXF1ZW50UnBjTGlzdERldGFpbCcpIHx8XHJcbiAgICAhQXJyYXkuaXNBcnJheShzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsKSB8fFxyXG4gICAgIXN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwuZXZlcnkoaXNPYmplY3QpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG4gIGNvbnN0IHsgUHJlZmVyZW5jZXNDb250cm9sbGVyLCBOZXR3b3JrQ29udHJvbGxlciB9ID0gc3RhdGU7XHJcbiAgY29uc3QgeyBmcmVxdWVudFJwY0xpc3REZXRhaWwgfSA9IFByZWZlcmVuY2VzQ29udHJvbGxlcjtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkoZnJlcXVlbnRScGNMaXN0RGV0YWlsKSkge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbmV0d29ya0NvbmZpZ3VyYXRpb25zID0gZnJlcXVlbnRScGNMaXN0RGV0YWlsLnJlZHVjZShcclxuICAgIChcclxuICAgICAgbmV0d29ya0NvbmZpZ3VyYXRpb25zQWNjLFxyXG4gICAgICB7IHJwY1VybCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSwgcnBjUHJlZnMgfSxcclxuICAgICkgPT4ge1xyXG4gICAgICBjb25zdCBuZXR3b3JrQ29uZmlndXJhdGlvbklkID0gdjQoKTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5uZXR3b3JrQ29uZmlndXJhdGlvbnNBY2MsXHJcbiAgICAgICAgW25ldHdvcmtDb25maWd1cmF0aW9uSWRdOiB7XHJcbiAgICAgICAgICBycGNVcmwsXHJcbiAgICAgICAgICBjaGFpbklkLFxyXG4gICAgICAgICAgdGlja2VyLFxyXG4gICAgICAgICAgcnBjUHJlZnMsXHJcbiAgICAgICAgICBuaWNrbmFtZSxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIHt9LFxyXG4gICk7XHJcblxyXG4gIGRlbGV0ZSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICBOZXR3b3JrQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5OZXR3b3JrQ29udHJvbGxlcixcclxuICAgICAgbmV0d29ya0NvbmZpZ3VyYXRpb25zLFxyXG4gICAgfSxcclxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAbWV0YW1hc2svdXRpbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSA4MztcclxuXHJcbi8qKlxyXG4gKiBFbnN1cmUgdGhhdCBlYWNoIG5ldHdvcmtDb25maWd1cmF0aW9ucyBvYmplY3QgaW4gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXIubmV0d29ya0NvbmZpZ3VyYXRpb25zIGhhcyBhblxyXG4gKiBgaWRgIHByb3BlcnR5IHdoaWNoIG1hdGNoZXMgdGhlIGtleSBwb2ludGluZyB0aGF0IG9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cclxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XHJcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxufSkge1xyXG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XHJcbiAgaWYgKCFpc09iamVjdChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcikpIHtcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcbiAgY29uc3QgeyBOZXR3b3JrQ29udHJvbGxlciB9ID0gc3RhdGU7XHJcblxyXG4gIGlmICghaXNPYmplY3QoTmV0d29ya0NvbnRyb2xsZXIubmV0d29ya0NvbmZpZ3VyYXRpb25zKSkge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgeyBuZXR3b3JrQ29uZmlndXJhdGlvbnMgfSA9IE5ldHdvcmtDb250cm9sbGVyO1xyXG5cclxuICBjb25zdCBuZXdOZXR3b3JrQ29uZmlndXJhdGlvbnM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIHVua25vd24+PiA9IHt9O1xyXG5cclxuICBmb3IgKGNvbnN0IG5ldHdvcmtDb25maWd1cmF0aW9uSWQgb2YgT2JqZWN0LmtleXMobmV0d29ya0NvbmZpZ3VyYXRpb25zKSkge1xyXG4gICAgY29uc3QgbmV0d29ya0NvbmZpZ3VyYXRpb24gPSBuZXR3b3JrQ29uZmlndXJhdGlvbnNbbmV0d29ya0NvbmZpZ3VyYXRpb25JZF07XHJcbiAgICBpZiAoIWlzT2JqZWN0KG5ldHdvcmtDb25maWd1cmF0aW9uKSkge1xyXG4gICAgICByZXR1cm4gc3RhdGU7XHJcbiAgICB9XHJcbiAgICBuZXdOZXR3b3JrQ29uZmlndXJhdGlvbnNbbmV0d29ya0NvbmZpZ3VyYXRpb25JZF0gPSB7XHJcbiAgICAgIC4uLm5ldHdvcmtDb25maWd1cmF0aW9uLFxyXG4gICAgICBpZDogbmV0d29ya0NvbmZpZ3VyYXRpb25JZCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICBOZXR3b3JrQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5OZXR3b3JrQ29udHJvbGxlcixcclxuICAgICAgbmV0d29ya0NvbmZpZ3VyYXRpb25zOiBuZXdOZXR3b3JrQ29uZmlndXJhdGlvbnMsXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgaGFzUHJvcGVydHksIGlzT2JqZWN0IH0gZnJvbSAnQG1ldGFtYXNrL3V0aWxzJztcclxuXHJcbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gODQ7XHJcblxyXG4vKipcclxuICogVGhlIGBuZXR3b3JrYCBwcm9wZXJ0eSBpbiBzdGF0ZSB3YXMgcmVwbGFjZWQgd2l0aCBgbmV0d29ya0lkYCBhbmQgYG5ldHdvcmtTdGF0dXNgLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cclxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XHJcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxufSkge1xyXG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XHJcbiAgaWYgKFxyXG4gICAgIWhhc1Byb3BlcnR5KHN0YXRlLCAnTmV0d29ya0NvbnRyb2xsZXInKSB8fFxyXG4gICAgIWlzT2JqZWN0KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyKSB8fFxyXG4gICAgIWhhc1Byb3BlcnR5KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLCAnbmV0d29yaycpXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICBjb25zdCBOZXR3b3JrQ29udHJvbGxlciA9IHsgLi4uc3RhdGUuTmV0d29ya0NvbnRyb2xsZXIgfTtcclxuXHJcbiAgaWYgKE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmsgPT09ICdsb2FkaW5nJykge1xyXG4gICAgTmV0d29ya0NvbnRyb2xsZXIubmV0d29ya0lkID0gbnVsbDtcclxuICAgIE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmtTdGF0dXMgPSAndW5rbm93bic7XHJcbiAgfSBlbHNlIHtcclxuICAgIE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcmtJZCA9IE5ldHdvcmtDb250cm9sbGVyLm5ldHdvcms7XHJcbiAgICBOZXR3b3JrQ29udHJvbGxlci5uZXR3b3JrU3RhdHVzID0gJ2F2YWlsYWJsZSc7XHJcbiAgfVxyXG5cclxuICBkZWxldGUgTmV0d29ya0NvbnRyb2xsZXIubmV0d29yaztcclxuXHJcbiAgcmV0dXJuIHsgLi4uc3RhdGUsIE5ldHdvcmtDb250cm9sbGVyIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAbWV0YW1hc2svdXRpbHMnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSA4NTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIG5vdy1vYnNvbGV0ZSBuZXR3b3JrIGNvbnRyb2xsZXIgYHByZXZpb3VzUHJvdmlkZXJTdG9yZWAgc3RhdGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEgLSBWZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLCBleGFjdGx5IHdoYXQgd2UgcGVyc2lzdCB0byBkaXN0LlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLm1ldGEgLSBTdGF0ZSBtZXRhZGF0YS5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gLSBUaGUgY3VycmVudCBzdGF0ZSB2ZXJzaW9uLlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLmRhdGEgLSBUaGUgcGVyc2lzdGVkIE1ldGFNYXNrIHN0YXRlLCBrZXllZCBieSBjb250cm9sbGVyLlxyXG4gKiBAcmV0dXJucyBVcGRhdGVkIHZlcnNpb25lZCBNZXRhTWFzayBleHRlbnNpb24gc3RhdGUuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGE6IHtcclxuICBtZXRhOiB7IHZlcnNpb246IG51bWJlciB9O1xyXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG59KSB7XHJcbiAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZSh2ZXJzaW9uZWREYXRhLmRhdGEpO1xyXG4gIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIHtcclxuICBpZiAoIWlzT2JqZWN0KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyKSkge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgZGVsZXRlIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByZXZpb3VzUHJvdmlkZXJTdG9yZTtcclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGhhc1Byb3BlcnR5LCBpc09iamVjdCB9IGZyb20gJ0BtZXRhbWFzay91dGlscyc7XHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IDg2O1xyXG5cclxuLyoqXHJcbiAqIFJlbmFtZSBuZXR3b3JrIGNvbnRyb2xsZXIgYHByb3ZpZGVyYCBzdGF0ZSB0byBgcHJvdmlkZXJDb25maWdgLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhIC0gVmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZSwgZXhhY3RseSB3aGF0IHdlIHBlcnNpc3QgdG8gZGlzdC5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5tZXRhIC0gU3RhdGUgbWV0YWRhdGEuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uIC0gVGhlIGN1cnJlbnQgc3RhdGUgdmVyc2lvbi5cclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YS5kYXRhIC0gVGhlIHBlcnNpc3RlZCBNZXRhTWFzayBzdGF0ZSwga2V5ZWQgYnkgY29udHJvbGxlci5cclxuICogQHJldHVybnMgVXBkYXRlZCB2ZXJzaW9uZWQgTWV0YU1hc2sgZXh0ZW5zaW9uIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhOiB7XHJcbiAgbWV0YTogeyB2ZXJzaW9uOiBudW1iZXIgfTtcclxuICBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxufSkge1xyXG4gIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGU6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSB7XHJcbiAgaWYgKFxyXG4gICAgaGFzUHJvcGVydHkoc3RhdGUsICdOZXR3b3JrQ29udHJvbGxlcicpICYmXHJcbiAgICBpc09iamVjdChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcikgJiZcclxuICAgIGhhc1Byb3BlcnR5KHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLCAncHJvdmlkZXInKVxyXG4gICkge1xyXG4gICAgY29uc3QgbmV0d29ya0NvbnRyb2xsZXJTdGF0ZSA9IHN0YXRlLk5ldHdvcmtDb250cm9sbGVyO1xyXG4gICAgbmV0d29ya0NvbnRyb2xsZXJTdGF0ZS5wcm92aWRlckNvbmZpZyA9IG5ldHdvcmtDb250cm9sbGVyU3RhdGUucHJvdmlkZXI7XHJcbiAgICBkZWxldGUgbmV0d29ya0NvbnRyb2xsZXJTdGF0ZS5wcm92aWRlcjtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAuLi5zdGF0ZSxcclxuICAgICAgTmV0d29ya0NvbnRyb2xsZXI6IG5ldHdvcmtDb250cm9sbGVyU3RhdGUsXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICdAbWV0YW1hc2svdXRpbHMnO1xyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSA4NztcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIG5vdy1vYnNvbGV0ZSB0b2tlbnMgY29udHJvbGxlciBgc3VnZ2VzdGVkQXNzZXRzYCBzdGF0ZS5cclxuICpcclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YSAtIFZlcnNpb25lZCBNZXRhTWFzayBleHRlbnNpb24gc3RhdGUsIGV4YWN0bHkgd2hhdCB3ZSBwZXJzaXN0IHRvIGRpc3QuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YSAtIFN0YXRlIG1ldGFkYXRhLlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiAtIFRoZSBjdXJyZW50IHN0YXRlIHZlcnNpb24uXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEuZGF0YSAtIFRoZSBwZXJzaXN0ZWQgTWV0YU1hc2sgc3RhdGUsIGtleWVkIGJ5IGNvbnRyb2xsZXIuXHJcbiAqIEByZXR1cm5zIFVwZGF0ZWQgdmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YToge1xyXG4gIG1ldGE6IHsgdmVyc2lvbjogbnVtYmVyIH07XHJcbiAgZGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XHJcbn0pIHtcclxuICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHZlcnNpb25lZERhdGEuZGF0YSk7XHJcbiAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPikge1xyXG4gIGlmICghaXNPYmplY3Qoc3RhdGUuVG9rZW5zQ29udHJvbGxlcikpIHtcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG4gIGRlbGV0ZSBzdGF0ZS5Ub2tlbnNDb250cm9sbGVyLnN1Z2dlc3RlZEFzc2V0cztcclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGhhc1Byb3BlcnR5LCBIZXgsIGlzT2JqZWN0LCBpc1N0cmljdEhleFN0cmluZyB9IGZyb20gJ0BtZXRhbWFzay91dGlscyc7XHJcbmltcG9ydCB7IEJOIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcclxuaW1wb3J0IHsgY2xvbmVEZWVwLCBtYXBLZXlzIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbnR5cGUgVmVyc2lvbmVkRGF0YSA9IHtcclxuICBtZXRhOiB7IHZlcnNpb246IG51bWJlciB9O1xyXG4gIGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSA4ODtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIG1pZ3JhdGlvbiBkb2VzIGEgZmV3IHRoaW5nczpcclxuICpcclxuICogLSBSZWJ1aWxkcyBgYWxsTmZ0Q29udHJhY3RzYCBhbmQgYGFsbE5mdHNgIGluIE5mdENvbnRyb2xsZXIgc3RhdGUgdG8gYmUga2V5ZWRcclxuICogYnkgYSBoZXggY2hhaW4gSUQgcmF0aGVyIHRoYW4gYSBkZWNpbWFsIGNoYWluIElELlxyXG4gKiAtIFJlYnVpbGRzIGB0b2tlbnNDaGFpbnNDYWNoZWAgaW4gVG9rZW5MaXN0Q29udHJvbGxlciB0byBiZSBrZXllZCBieSBhIGhleFxyXG4gKiBjaGFpbiBJRCByYXRoZXIgdGhhbiBhIGRlY2ltYWwgY2hhaW4gSUQuXHJcbiAqIC0gUmVidWlsZHMgYGFsbFRva2Vuc2AgYW5kIGBhbGxJZ25vcmVkVG9rZW5zYCBpbiBUb2tlbnNDb250cm9sbGVyIHRvIGJlIGtleWVkXHJcbiAqIGJ5IGEgaGV4IGNoYWluIElEIHJhdGhlciB0aGFuIGEgZGVjaW1hbCBjaGFpbiBJRC5cclxuICpcclxuICogQHBhcmFtIG9yaWdpbmFsVmVyc2lvbmVkRGF0YSAtIFZlcnNpb25lZCBNZXRhTWFzayBleHRlbnNpb24gc3RhdGUsIGV4YWN0bHkgd2hhdCB3ZSBwZXJzaXN0IHRvIGRpc3QuXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEubWV0YSAtIFN0YXRlIG1ldGFkYXRhLlxyXG4gKiBAcGFyYW0gb3JpZ2luYWxWZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiAtIFRoZSBjdXJyZW50IHN0YXRlIHZlcnNpb24uXHJcbiAqIEBwYXJhbSBvcmlnaW5hbFZlcnNpb25lZERhdGEuZGF0YSAtIFRoZSBwZXJzaXN0ZWQgTWV0YU1hc2sgc3RhdGUsIGtleWVkIGJ5IGNvbnRyb2xsZXIuXHJcbiAqIEByZXR1cm5zIFVwZGF0ZWQgdmVyc2lvbmVkIE1ldGFNYXNrIGV4dGVuc2lvbiBzdGF0ZS5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtaWdyYXRlKFxyXG4gIG9yaWdpbmFsVmVyc2lvbmVkRGF0YTogVmVyc2lvbmVkRGF0YSxcclxuKTogUHJvbWlzZTxWZXJzaW9uZWREYXRhPiB7XHJcbiAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICBtaWdyYXRlRGF0YSh2ZXJzaW9uZWREYXRhLmRhdGEpO1xyXG4gIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtaWdyYXRlRGF0YShzdGF0ZTogUmVjb3JkPHN0cmluZywgdW5rbm93bj4pOiB2b2lkIHtcclxuICBpZiAoaGFzUHJvcGVydHkoc3RhdGUsICdOZnRDb250cm9sbGVyJykgJiYgaXNPYmplY3Qoc3RhdGUuTmZ0Q29udHJvbGxlcikpIHtcclxuICAgIGNvbnN0IG5mdENvbnRyb2xsZXJTdGF0ZSA9IHN0YXRlLk5mdENvbnRyb2xsZXI7XHJcblxyXG4gICAgLy8gTWlncmF0ZSBOZnRDb250cm9sbGVyLmFsbE5mdENvbnRyYWN0c1xyXG4gICAgaWYgKFxyXG4gICAgICBoYXNQcm9wZXJ0eShuZnRDb250cm9sbGVyU3RhdGUsICdhbGxOZnRDb250cmFjdHMnKSAmJlxyXG4gICAgICBpc09iamVjdChuZnRDb250cm9sbGVyU3RhdGUuYWxsTmZ0Q29udHJhY3RzKVxyXG4gICAgKSB7XHJcbiAgICAgIGNvbnN0IHsgYWxsTmZ0Q29udHJhY3RzIH0gPSBuZnRDb250cm9sbGVyU3RhdGU7XHJcblxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgT2JqZWN0LmtleXMoYWxsTmZ0Q29udHJhY3RzKS5ldmVyeSgoYWRkcmVzcykgPT5cclxuICAgICAgICAgIGlzT2JqZWN0KGFsbE5mdENvbnRyYWN0c1thZGRyZXNzXSksXHJcbiAgICAgICAgKVxyXG4gICAgICApIHtcclxuICAgICAgICBPYmplY3Qua2V5cyhhbGxOZnRDb250cmFjdHMpLmZvckVhY2goKGFkZHJlc3MpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5mdENvbnRyYWN0c0J5Q2hhaW5JZCA9IGFsbE5mdENvbnRyYWN0c1thZGRyZXNzXTtcclxuXHJcbiAgICAgICAgICBpZiAoaXNPYmplY3QobmZ0Q29udHJhY3RzQnlDaGFpbklkKSkge1xyXG4gICAgICAgICAgICBhbGxOZnRDb250cmFjdHNbYWRkcmVzc10gPSBtYXBLZXlzKFxyXG4gICAgICAgICAgICAgIG5mdENvbnRyYWN0c0J5Q2hhaW5JZCxcclxuICAgICAgICAgICAgICAoXywgY2hhaW5JZDogc3RyaW5nKSA9PiB0b0hleChjaGFpbklkKSxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1pZ3JhdGUgTmZ0Q29udHJvbGxlci5hbGxOZnRzXHJcbiAgICBpZiAoXHJcbiAgICAgIGhhc1Byb3BlcnR5KG5mdENvbnRyb2xsZXJTdGF0ZSwgJ2FsbE5mdHMnKSAmJlxyXG4gICAgICBpc09iamVjdChuZnRDb250cm9sbGVyU3RhdGUuYWxsTmZ0cylcclxuICAgICkge1xyXG4gICAgICBjb25zdCB7IGFsbE5mdHMgfSA9IG5mdENvbnRyb2xsZXJTdGF0ZTtcclxuXHJcbiAgICAgIGlmIChPYmplY3Qua2V5cyhhbGxOZnRzKS5ldmVyeSgoYWRkcmVzcykgPT4gaXNPYmplY3QoYWxsTmZ0c1thZGRyZXNzXSkpKSB7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoYWxsTmZ0cykuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbmZ0c0J5Q2hhaW5JZCA9IGFsbE5mdHNbYWRkcmVzc107XHJcblxyXG4gICAgICAgICAgaWYgKGlzT2JqZWN0KG5mdHNCeUNoYWluSWQpKSB7XHJcbiAgICAgICAgICAgIGFsbE5mdHNbYWRkcmVzc10gPSBtYXBLZXlzKG5mdHNCeUNoYWluSWQsIChfLCBjaGFpbklkOiBzdHJpbmcpID0+XHJcbiAgICAgICAgICAgICAgdG9IZXgoY2hhaW5JZCksXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5OZnRDb250cm9sbGVyID0gbmZ0Q29udHJvbGxlclN0YXRlO1xyXG4gIH1cclxuXHJcbiAgaWYgKFxyXG4gICAgaGFzUHJvcGVydHkoc3RhdGUsICdUb2tlbkxpc3RDb250cm9sbGVyJykgJiZcclxuICAgIGlzT2JqZWN0KHN0YXRlLlRva2VuTGlzdENvbnRyb2xsZXIpXHJcbiAgKSB7XHJcbiAgICBjb25zdCB0b2tlbkxpc3RDb250cm9sbGVyU3RhdGUgPSBzdGF0ZS5Ub2tlbkxpc3RDb250cm9sbGVyO1xyXG5cclxuICAgIC8vIE1pZ3JhdGUgVG9rZW5MaXN0Q29udHJvbGxlci50b2tlbnNDaGFpbnNDYWNoZVxyXG4gICAgaWYgKFxyXG4gICAgICBoYXNQcm9wZXJ0eSh0b2tlbkxpc3RDb250cm9sbGVyU3RhdGUsICd0b2tlbnNDaGFpbnNDYWNoZScpICYmXHJcbiAgICAgIGlzT2JqZWN0KHRva2VuTGlzdENvbnRyb2xsZXJTdGF0ZS50b2tlbnNDaGFpbnNDYWNoZSlcclxuICAgICkge1xyXG4gICAgICB0b2tlbkxpc3RDb250cm9sbGVyU3RhdGUudG9rZW5zQ2hhaW5zQ2FjaGUgPSBtYXBLZXlzKFxyXG4gICAgICAgIHRva2VuTGlzdENvbnRyb2xsZXJTdGF0ZS50b2tlbnNDaGFpbnNDYWNoZSxcclxuICAgICAgICAoXywgY2hhaW5JZDogc3RyaW5nKSA9PiB0b0hleChjaGFpbklkKSxcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChcclxuICAgIGhhc1Byb3BlcnR5KHN0YXRlLCAnVG9rZW5zQ29udHJvbGxlcicpICYmXHJcbiAgICBpc09iamVjdChzdGF0ZS5Ub2tlbnNDb250cm9sbGVyKVxyXG4gICkge1xyXG4gICAgY29uc3QgdG9rZW5zQ29udHJvbGxlclN0YXRlID0gc3RhdGUuVG9rZW5zQ29udHJvbGxlcjtcclxuXHJcbiAgICAvLyBNaWdyYXRlIFRva2Vuc0NvbnRyb2xsZXIuYWxsVG9rZW5zXHJcbiAgICBpZiAoXHJcbiAgICAgIGhhc1Byb3BlcnR5KHRva2Vuc0NvbnRyb2xsZXJTdGF0ZSwgJ2FsbFRva2VucycpICYmXHJcbiAgICAgIGlzT2JqZWN0KHRva2Vuc0NvbnRyb2xsZXJTdGF0ZS5hbGxUb2tlbnMpXHJcbiAgICApIHtcclxuICAgICAgY29uc3QgeyBhbGxUb2tlbnMgfSA9IHRva2Vuc0NvbnRyb2xsZXJTdGF0ZTtcclxuXHJcbiAgICAgIHRva2Vuc0NvbnRyb2xsZXJTdGF0ZS5hbGxUb2tlbnMgPSBtYXBLZXlzKFxyXG4gICAgICAgIGFsbFRva2VucyxcclxuICAgICAgICAoXywgY2hhaW5JZDogc3RyaW5nKSA9PiB0b0hleChjaGFpbklkKSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNaWdyYXRlIFRva2Vuc0NvbnRyb2xsZXIuYWxsSWdub3JlZFRva2Vuc1xyXG4gICAgaWYgKFxyXG4gICAgICBoYXNQcm9wZXJ0eSh0b2tlbnNDb250cm9sbGVyU3RhdGUsICdhbGxJZ25vcmVkVG9rZW5zJykgJiZcclxuICAgICAgaXNPYmplY3QodG9rZW5zQ29udHJvbGxlclN0YXRlLmFsbElnbm9yZWRUb2tlbnMpXHJcbiAgICApIHtcclxuICAgICAgY29uc3QgeyBhbGxJZ25vcmVkVG9rZW5zIH0gPSB0b2tlbnNDb250cm9sbGVyU3RhdGU7XHJcblxyXG4gICAgICB0b2tlbnNDb250cm9sbGVyU3RhdGUuYWxsSWdub3JlZFRva2VucyA9IG1hcEtleXMoXHJcbiAgICAgICAgYWxsSWdub3JlZFRva2VucyxcclxuICAgICAgICAoXywgY2hhaW5JZDogc3RyaW5nKSA9PiB0b0hleChjaGFpbklkKSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNaWdyYXRlIFRva2Vuc0NvbnRyb2xsZXIuYWxsRGV0ZWN0ZWRUb2tlbnNcclxuICAgIGlmIChcclxuICAgICAgaGFzUHJvcGVydHkodG9rZW5zQ29udHJvbGxlclN0YXRlLCAnYWxsRGV0ZWN0ZWRUb2tlbnMnKSAmJlxyXG4gICAgICBpc09iamVjdCh0b2tlbnNDb250cm9sbGVyU3RhdGUuYWxsRGV0ZWN0ZWRUb2tlbnMpXHJcbiAgICApIHtcclxuICAgICAgY29uc3QgeyBhbGxEZXRlY3RlZFRva2VucyB9ID0gdG9rZW5zQ29udHJvbGxlclN0YXRlO1xyXG5cclxuICAgICAgdG9rZW5zQ29udHJvbGxlclN0YXRlLmFsbERldGVjdGVkVG9rZW5zID0gbWFwS2V5cyhcclxuICAgICAgICBhbGxEZXRlY3RlZFRva2VucyxcclxuICAgICAgICAoXywgY2hhaW5JZDogc3RyaW5nKSA9PiB0b0hleChjaGFpbklkKSxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5Ub2tlbnNDb250cm9sbGVyID0gdG9rZW5zQ29udHJvbGxlclN0YXRlO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gdG9IZXgodmFsdWU6IG51bWJlciB8IHN0cmluZyB8IEJOKTogSGV4IHtcclxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiBpc1N0cmljdEhleFN0cmluZyh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9XHJcbiAgY29uc3QgaGV4U3RyaW5nID0gQk4uaXNCTih2YWx1ZSlcclxuICAgID8gdmFsdWUudG9TdHJpbmcoMTYpXHJcbiAgICA6IG5ldyBCTih2YWx1ZS50b1N0cmluZygpLCAxMCkudG9TdHJpbmcoMTYpO1xyXG4gIHJldHVybiBgMHgke2hleFN0cmluZ31gO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRyYW5zYWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmYWlsVHhzVGhhdCh2ZXJzaW9uLCByZWFzb24sIGNvbmRpdGlvbikge1xyXG4gIHJldHVybiBmdW5jdGlvbiAob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSwgY29uZGl0aW9uLCByZWFzb24pO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSwgY29uZGl0aW9uLCByZWFzb24pIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcclxuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBUcmFuc2FjdGlvbkNvbnRyb2xsZXI7XHJcblxyXG4gICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoKHR4TWV0YSkgPT4ge1xyXG4gICAgICBpZiAoIWNvbmRpdGlvbih0eE1ldGEpKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdHhNZXRhLnN0YXR1cyA9IFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZDtcclxuICAgICAgdHhNZXRhLmVyciA9IHtcclxuICAgICAgICBtZXNzYWdlOiByZWFzb24sXHJcbiAgICAgICAgbm90ZTogYFR4IGF1dG9tYXRpY2FsbHkgZmFpbGVkIGJ5IG1pZ3JhdGlvbiBiZWNhdXNlICR7cmVhc29ufWAsXHJcbiAgICAgIH07XHJcblxyXG4gICAgICByZXR1cm4gdHhNZXRhO1xyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvLyBNaWdyYXRpb25zIG11c3Qgc3RhcnQgYXQgdmVyc2lvbiAxIG9yIGxhdGVyLlxyXG4vLyBUaGV5IGFyZSBvYmplY3RzIHdpdGggYSBgdmVyc2lvbmAgbnVtYmVyXHJcbi8vIGFuZCBhIGBtaWdyYXRlYCBmdW5jdGlvbi5cclxuLy9cclxuLy8gVGhlIGBtaWdyYXRlYCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgcHJldmlvdXNcclxuLy8gY29uZmlnIGRhdGEgZm9ybWF0LCBhbmQgcmV0dXJucyB0aGUgbmV3IG9uZS5cclxuXHJcbmltcG9ydCBtMDAyIGZyb20gJy4vMDAyJztcclxuaW1wb3J0IG0wMDMgZnJvbSAnLi8wMDMnO1xyXG5pbXBvcnQgbTAwNCBmcm9tICcuLzAwNCc7XHJcbmltcG9ydCBtMDA1IGZyb20gJy4vMDA1JztcclxuaW1wb3J0IG0wMDYgZnJvbSAnLi8wMDYnO1xyXG5pbXBvcnQgbTAwNyBmcm9tICcuLzAwNyc7XHJcbmltcG9ydCBtMDA4IGZyb20gJy4vMDA4JztcclxuaW1wb3J0IG0wMDkgZnJvbSAnLi8wMDknO1xyXG5pbXBvcnQgbTAxMCBmcm9tICcuLzAxMCc7XHJcbmltcG9ydCBtMDExIGZyb20gJy4vMDExJztcclxuaW1wb3J0IG0wMTIgZnJvbSAnLi8wMTInO1xyXG5pbXBvcnQgbTAxMyBmcm9tICcuLzAxMyc7XHJcbmltcG9ydCBtMDE0IGZyb20gJy4vMDE0JztcclxuaW1wb3J0IG0wMTUgZnJvbSAnLi8wMTUnO1xyXG5pbXBvcnQgbTAxNiBmcm9tICcuLzAxNic7XHJcbmltcG9ydCBtMDE3IGZyb20gJy4vMDE3JztcclxuaW1wb3J0IG0wMTggZnJvbSAnLi8wMTgnO1xyXG5pbXBvcnQgbTAxOSBmcm9tICcuLzAxOSc7XHJcbmltcG9ydCBtMDIwIGZyb20gJy4vMDIwJztcclxuaW1wb3J0IG0wMjEgZnJvbSAnLi8wMjEnO1xyXG5pbXBvcnQgbTAyMiBmcm9tICcuLzAyMic7XHJcbmltcG9ydCBtMDIzIGZyb20gJy4vMDIzJztcclxuaW1wb3J0IG0wMjQgZnJvbSAnLi8wMjQnO1xyXG5pbXBvcnQgbTAyNSBmcm9tICcuLzAyNSc7XHJcbmltcG9ydCBtMDI2IGZyb20gJy4vMDI2JztcclxuaW1wb3J0IG0wMjcgZnJvbSAnLi8wMjcnO1xyXG5pbXBvcnQgbTAyOCBmcm9tICcuLzAyOCc7XHJcbmltcG9ydCBtMDI5IGZyb20gJy4vMDI5JztcclxuaW1wb3J0IG0wMzAgZnJvbSAnLi8wMzAnO1xyXG5pbXBvcnQgbTAzMSBmcm9tICcuLzAzMSc7XHJcbmltcG9ydCBtMDMyIGZyb20gJy4vMDMyJztcclxuaW1wb3J0IG0wMzMgZnJvbSAnLi8wMzMnO1xyXG5pbXBvcnQgbTAzNCBmcm9tICcuLzAzNCc7XHJcbmltcG9ydCBtMDM1IGZyb20gJy4vMDM1JztcclxuaW1wb3J0IG0wMzYgZnJvbSAnLi8wMzYnO1xyXG5pbXBvcnQgbTAzNyBmcm9tICcuLzAzNyc7XHJcbmltcG9ydCBtMDM4IGZyb20gJy4vMDM4JztcclxuaW1wb3J0IG0wMzkgZnJvbSAnLi8wMzknO1xyXG5pbXBvcnQgbTA0MCBmcm9tICcuLzA0MCc7XHJcbmltcG9ydCBtMDQxIGZyb20gJy4vMDQxJztcclxuaW1wb3J0IG0wNDIgZnJvbSAnLi8wNDInO1xyXG5pbXBvcnQgbTA0MyBmcm9tICcuLzA0Myc7XHJcbmltcG9ydCBtMDQ0IGZyb20gJy4vMDQ0JztcclxuaW1wb3J0IG0wNDUgZnJvbSAnLi8wNDUnO1xyXG5pbXBvcnQgbTA0NiBmcm9tICcuLzA0Nic7XHJcbmltcG9ydCBtMDQ3IGZyb20gJy4vMDQ3JztcclxuaW1wb3J0IG0wNDggZnJvbSAnLi8wNDgnO1xyXG5pbXBvcnQgbTA0OSBmcm9tICcuLzA0OSc7XHJcbmltcG9ydCBtMDUwIGZyb20gJy4vMDUwJztcclxuaW1wb3J0IG0wNTEgZnJvbSAnLi8wNTEnO1xyXG5pbXBvcnQgbTA1MiBmcm9tICcuLzA1Mic7XHJcbmltcG9ydCBtMDUzIGZyb20gJy4vMDUzJztcclxuaW1wb3J0IG0wNTQgZnJvbSAnLi8wNTQnO1xyXG5pbXBvcnQgbTA1NSBmcm9tICcuLzA1NSc7XHJcbmltcG9ydCBtMDU2IGZyb20gJy4vMDU2JztcclxuaW1wb3J0IG0wNTcgZnJvbSAnLi8wNTcnO1xyXG5pbXBvcnQgbTA1OCBmcm9tICcuLzA1OCc7XHJcbmltcG9ydCBtMDU5IGZyb20gJy4vMDU5JztcclxuaW1wb3J0IG0wNjAgZnJvbSAnLi8wNjAnO1xyXG5pbXBvcnQgbTA2MSBmcm9tICcuLzA2MSc7XHJcbmltcG9ydCBtMDYyIGZyb20gJy4vMDYyJztcclxuaW1wb3J0IG0wNjMgZnJvbSAnLi8wNjMnO1xyXG5pbXBvcnQgbTA2NCBmcm9tICcuLzA2NCc7XHJcbmltcG9ydCBtMDY1IGZyb20gJy4vMDY1JztcclxuaW1wb3J0IG0wNjYgZnJvbSAnLi8wNjYnO1xyXG5pbXBvcnQgbTA2NyBmcm9tICcuLzA2Nyc7XHJcbmltcG9ydCBtMDY4IGZyb20gJy4vMDY4JztcclxuaW1wb3J0IG0wNjkgZnJvbSAnLi8wNjknO1xyXG5pbXBvcnQgbTA3MCBmcm9tICcuLzA3MCc7XHJcbmltcG9ydCBtMDcxIGZyb20gJy4vMDcxJztcclxuaW1wb3J0IG0wNzIgZnJvbSAnLi8wNzInO1xyXG5pbXBvcnQgbTA3MyBmcm9tICcuLzA3Myc7XHJcbmltcG9ydCBtMDc0IGZyb20gJy4vMDc0JztcclxuaW1wb3J0IG0wNzUgZnJvbSAnLi8wNzUnO1xyXG5pbXBvcnQgbTA3NiBmcm9tICcuLzA3Nic7XHJcbmltcG9ydCBtMDc3IGZyb20gJy4vMDc3JztcclxuaW1wb3J0ICogYXMgbTA3OCBmcm9tICcuLzA3OCc7XHJcbmltcG9ydCBtMDc5IGZyb20gJy4vMDc5JztcclxuaW1wb3J0IG0wODAgZnJvbSAnLi8wODAnO1xyXG5pbXBvcnQgKiBhcyBtMDgxIGZyb20gJy4vMDgxJztcclxuaW1wb3J0ICogYXMgbTA4MiBmcm9tICcuLzA4Mic7XHJcbmltcG9ydCAqIGFzIG0wODMgZnJvbSAnLi8wODMnO1xyXG5pbXBvcnQgKiBhcyBtMDg0IGZyb20gJy4vMDg0JztcclxuaW1wb3J0ICogYXMgbTA4NSBmcm9tICcuLzA4NSc7XHJcbmltcG9ydCAqIGFzIG0wODYgZnJvbSAnLi8wODYnO1xyXG5pbXBvcnQgKiBhcyBtMDg3IGZyb20gJy4vMDg3JztcclxuaW1wb3J0ICogYXMgbTA4OCBmcm9tICcuLzA4OCc7XHJcblxyXG5jb25zdCBtaWdyYXRpb25zID0gW1xyXG4gIG0wMDIsXHJcbiAgbTAwMyxcclxuICBtMDA0LFxyXG4gIG0wMDUsXHJcbiAgbTAwNixcclxuICBtMDA3LFxyXG4gIG0wMDgsXHJcbiAgbTAwOSxcclxuICBtMDEwLFxyXG4gIG0wMTEsXHJcbiAgbTAxMixcclxuICBtMDEzLFxyXG4gIG0wMTQsXHJcbiAgbTAxNSxcclxuICBtMDE2LFxyXG4gIG0wMTcsXHJcbiAgbTAxOCxcclxuICBtMDE5LFxyXG4gIG0wMjAsXHJcbiAgbTAyMSxcclxuICBtMDIyLFxyXG4gIG0wMjMsXHJcbiAgbTAyNCxcclxuICBtMDI1LFxyXG4gIG0wMjYsXHJcbiAgbTAyNyxcclxuICBtMDI4LFxyXG4gIG0wMjksXHJcbiAgbTAzMCxcclxuICBtMDMxLFxyXG4gIG0wMzIsXHJcbiAgbTAzMyxcclxuICBtMDM0LFxyXG4gIG0wMzUsXHJcbiAgbTAzNixcclxuICBtMDM3LFxyXG4gIG0wMzgsXHJcbiAgbTAzOSxcclxuICBtMDQwLFxyXG4gIG0wNDEsXHJcbiAgbTA0MixcclxuICBtMDQzLFxyXG4gIG0wNDQsXHJcbiAgbTA0NSxcclxuICBtMDQ2LFxyXG4gIG0wNDcsXHJcbiAgbTA0OCxcclxuICBtMDQ5LFxyXG4gIG0wNTAsXHJcbiAgbTA1MSxcclxuICBtMDUyLFxyXG4gIG0wNTMsXHJcbiAgbTA1NCxcclxuICBtMDU1LFxyXG4gIG0wNTYsXHJcbiAgbTA1NyxcclxuICBtMDU4LFxyXG4gIG0wNTksXHJcbiAgbTA2MCxcclxuICBtMDYxLFxyXG4gIG0wNjIsXHJcbiAgbTA2MyxcclxuICBtMDY0LFxyXG4gIG0wNjUsXHJcbiAgbTA2NixcclxuICBtMDY3LFxyXG4gIG0wNjgsXHJcbiAgbTA2OSxcclxuICBtMDcwLFxyXG4gIG0wNzEsXHJcbiAgbTA3MixcclxuICBtMDczLFxyXG4gIG0wNzQsXHJcbiAgbTA3NSxcclxuICBtMDc2LFxyXG4gIG0wNzcsXHJcbiAgbTA3OCxcclxuICBtMDc5LFxyXG4gIG0wODAsXHJcbiAgbTA4MSxcclxuICBtMDgyLFxyXG4gIG0wODMsXHJcbiAgbTA4NCxcclxuICBtMDg1LFxyXG4gIG0wODYsXHJcbiAgbTA4NyxcclxuICBtMDg4LFxyXG5dO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgbWlncmF0aW9ucztcclxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZW5jb2RlVGV4dCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnkgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vdHlwZXNcIikuQmFzZU5hbWV9IEJhc2VOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL3R5cGVzXCIpLkJhc2VDb2RlfSBCYXNlQ29kZSAqL1xuXG4vKipcbiAqIENsYXNzIHRvIGVuY29kZS9kZWNvZGUgaW4gdGhlIHN1cHBvcnRlZCBCYXNlc1xuICpcbiAqL1xuY2xhc3MgQmFzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Jhc2VOYW1lfSBuYW1lXG4gICAqIEBwYXJhbSB7QmFzZUNvZGV9IGNvZGVcbiAgICogQHBhcmFtIHtDb2RlY0ZhY3Rvcnl9IGZhY3RvcnlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgY29kZSwgZmFjdG9yeSwgYWxwaGFiZXQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIHRoaXMuY29kZUJ1ZiA9IGVuY29kZVRleHQodGhpcy5jb2RlKVxuICAgIHRoaXMuYWxwaGFiZXQgPSBhbHBoYWJldFxuICAgIHRoaXMuY29kZWMgPSBmYWN0b3J5KGFscGhhYmV0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlbmNvZGUgKGJ1Zikge1xuICAgIHJldHVybiB0aGlzLmNvZGVjLmVuY29kZShidWYpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICovXG4gIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgZm9yIChjb25zdCBjaGFyIG9mIHN0cmluZykge1xuICAgICAgaWYgKHRoaXMuYWxwaGFiZXQgJiYgdGhpcy5hbHBoYWJldC5pbmRleE9mKGNoYXIpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgY2hhcmFjdGVyICcke2NoYXJ9JyBpbiAnJHtzdHJpbmd9J2ApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvZGVjLmRlY29kZShzdHJpbmcpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZVggPSByZXF1aXJlKCdAbXVsdGlmb3JtYXRzL2Jhc2UteCcpXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJylcbmNvbnN0IHsgcmZjNDY0OCB9ID0gcmVxdWlyZSgnLi9yZmM0NjQ4JylcbmNvbnN0IHsgZGVjb2RlVGV4dCwgZW5jb2RlVGV4dCB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnkgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjfSBDb2RlYyAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQmFzZU5hbWV9IEJhc2VOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5CYXNlQ29kZX0gQmFzZUNvZGUgKi9cblxuLyoqIEB0eXBlIHtDb2RlY0ZhY3Rvcnl9ICovXG5jb25zdCBpZGVudGl0eSA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGRlY29kZVRleHQsXG4gICAgZGVjb2RlOiBlbmNvZGVUZXh0XG4gIH1cbn1cblxuLyoqXG4gKlxuICogbmFtZSwgY29kZSwgaW1wbGVtZW50YXRpb24sIGFscGhhYmV0XG4gKlxuICogQHR5cGUge0FycmF5PFtCYXNlTmFtZSwgQmFzZUNvZGUsIENvZGVjRmFjdG9yeSwgc3RyaW5nXT59XG4gKi9cbmNvbnN0IGNvbnN0YW50cyA9IFtcbiAgWydpZGVudGl0eScsICdcXHgwMCcsIGlkZW50aXR5LCAnJ10sXG4gIFsnYmFzZTInLCAnMCcsIHJmYzQ2NDgoMSksICcwMSddLFxuICBbJ2Jhc2U4JywgJzcnLCByZmM0NjQ4KDMpLCAnMDEyMzQ1NjcnXSxcbiAgWydiYXNlMTAnLCAnOScsIGJhc2VYLCAnMDEyMzQ1Njc4OSddLFxuICBbJ2Jhc2UxNicsICdmJywgcmZjNDY0OCg0KSwgJzAxMjM0NTY3ODlhYmNkZWYnXSxcbiAgWydiYXNlMTZ1cHBlcicsICdGJywgcmZjNDY0OCg0KSwgJzAxMjM0NTY3ODlBQkNERUYnXSxcbiAgWydiYXNlMzJoZXgnLCAndicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1diddLFxuICBbJ2Jhc2UzMmhleHVwcGVyJywgJ1YnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnXSxcbiAgWydiYXNlMzJoZXhwYWQnLCAndCcsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nXSxcbiAgWydiYXNlMzJoZXhwYWR1cHBlcicsICdUJywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPSddLFxuICBbJ2Jhc2UzMicsICdiJywgcmZjNDY0OCg1KSwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3J10sXG4gIFsnYmFzZTMydXBwZXInLCAnQicsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NyddLFxuICBbJ2Jhc2UzMnBhZCcsICdjJywgcmZjNDY0OCg1KSwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PSddLFxuICBbJ2Jhc2UzMnBhZHVwcGVyJywgJ0MnLCByZmM0NjQ4KDUpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9J10sXG4gIFsnYmFzZTMyeicsICdoJywgcmZjNDY0OCg1KSwgJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5J10sXG4gIFsnYmFzZTM2JywgJ2snLCBiYXNlWCwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiddLFxuICBbJ2Jhc2UzNnVwcGVyJywgJ0snLCBiYXNlWCwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U1OGJ0YycsICd6JywgYmFzZVgsICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTU4ZmxpY2tyJywgJ1onLCBiYXNlWCwgJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXSxcbiAgWydiYXNlNjQnLCAnbScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ10sXG4gIFsnYmFzZTY0cGFkJywgJ00nLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXSxcbiAgWydiYXNlNjR1cmwnLCAndScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJ10sXG4gIFsnYmFzZTY0dXJscGFkJywgJ1UnLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nXVxuXVxuXG4vKiogQHR5cGUge1JlY29yZDxCYXNlTmFtZSxCYXNlPn0gKi9cbmNvbnN0IG5hbWVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzBdXSA9IG5ldyBCYXNlKHR1cHBsZVswXSwgdHVwcGxlWzFdLCB0dXBwbGVbMl0sIHR1cHBsZVszXSlcbiAgcmV0dXJuIHByZXZcbn0sIC8qKiBAdHlwZSB7UmVjb3JkPEJhc2VOYW1lLEJhc2U+fSAqLyh7fSkpXG5cbi8qKiBAdHlwZSB7UmVjb3JkPEJhc2VDb2RlLEJhc2U+fSAqL1xuY29uc3QgY29kZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMV1dID0gbmFtZXNbdHVwcGxlWzBdXVxuICByZXR1cm4gcHJldlxufSwgLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZUNvZGUsQmFzZT59ICovKHt9KSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWVzLFxuICBjb2Rlc1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjRmFjdG9yeX0gQ29kZWNGYWN0b3J5ICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBkZWNvZGUgPSAoc3RyaW5nLCBhbHBoYWJldCwgYml0c1BlckNoYXIpID0+IHtcbiAgLy8gQnVpbGQgdGhlIGNoYXJhY3RlciBsb29rdXAgdGFibGU6XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgY29uc3QgY29kZXMgPSB7fVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaVxuICB9XG5cbiAgLy8gQ291bnQgdGhlIHBhZGRpbmcgYnl0ZXM6XG4gIGxldCBlbmQgPSBzdHJpbmcubGVuZ3RoXG4gIHdoaWxlIChzdHJpbmdbZW5kIC0gMV0gPT09ICc9Jykge1xuICAgIC0tZW5kXG4gIH1cblxuICAvLyBBbGxvY2F0ZSB0aGUgb3V0cHV0OlxuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSgoZW5kICogYml0c1BlckNoYXIgLyA4KSB8IDApXG5cbiAgLy8gUGFyc2UgdGhlIGRhdGE6XG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBsZXQgd3JpdHRlbiA9IDAgLy8gTmV4dCBieXRlIHRvIHdyaXRlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICAvLyBSZWFkIG9uZSBjaGFyYWN0ZXIgZnJvbSB0aGUgc3RyaW5nOlxuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyICcgKyBzdHJpbmdbaV0pXG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIHRoZSBiaXRzIHRvIHRoZSBidWZmZXI6XG4gICAgYnVmZmVyID0gKGJ1ZmZlciA8PCBiaXRzUGVyQ2hhcikgfCB2YWx1ZVxuICAgIGJpdHMgKz0gYml0c1BlckNoYXJcblxuICAgIC8vIFdyaXRlIG91dCBzb21lIGJpdHMgaWYgdGhlIGJ1ZmZlciBoYXMgYSBieXRlJ3Mgd29ydGg6XG4gICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgYml0cyAtPSA4XG4gICAgICBvdXRbd3JpdHRlbisrXSA9IDB4ZmYgJiAoYnVmZmVyID4+IGJpdHMpXG4gICAgfVxuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgd2UgaGF2ZSByZWNlaXZlZCBqdXN0IGVub3VnaCBiaXRzOlxuICBpZiAoYml0cyA+PSBiaXRzUGVyQ2hhciB8fCAweGZmICYgKGJ1ZmZlciA8PCAoOCAtIGJpdHMpKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nXG4gIGNvbnN0IG1hc2sgPSAoMSA8PCBiaXRzUGVyQ2hhcikgLSAxXG4gIGxldCBvdXQgPSAnJ1xuXG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBTbHVycCBkYXRhIGludG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDgpIHwgZGF0YVtpXVxuICAgIGJpdHMgKz0gOFxuXG4gICAgLy8gV3JpdGUgb3V0IGFzIG11Y2ggYXMgd2UgY2FuOlxuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXJcbiAgICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA+PiBiaXRzKV1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJ0aWFsIGNoYXJhY3RlcjpcbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIChidWZmZXIgPDwgKGJpdHNQZXJDaGFyIC0gYml0cykpXVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmcgY2hhcmFjdGVycyB1bnRpbCB3ZSBoaXQgYSBieXRlIGJvdW5kYXJ5OlxuICBpZiAocGFkKSB7XG4gICAgd2hpbGUgKChvdXQubGVuZ3RoICogYml0c1BlckNoYXIpICYgNykge1xuICAgICAgb3V0ICs9ICc9J1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBSRkM0NjQ4IEZhY3RvcnlcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtDb2RlY0ZhY3Rvcnl9XG4gKi9cbmNvbnN0IHJmYzQ2NDggPSAoYml0c1BlckNoYXIpID0+IChhbHBoYWJldCkgPT4ge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGRlY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHJmYzQ2NDggfVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IHsgVGV4dEVuY29kZXIsIFRleHREZWNvZGVyIH0gPSByZXF1aXJlKCd3ZWItZW5jb2RpbmcnKVxuXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfSBieXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZGVjb2RlVGV4dCA9IChieXRlcykgPT4gdGV4dERlY29kZXIuZGVjb2RlKGJ5dGVzKVxuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlVGV4dCA9ICh0ZXh0KSA9PiB0ZXh0RW5jb2Rlci5lbmNvZGUodGV4dClcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IFVpbnQ4QXJyYXkgY3JlYXRlZCBieSBjb25jYXRlbmF0aW5nIHRoZSBwYXNzZWQgQXJyYXlzXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheUxpa2U8bnVtYmVyPj59IGFycnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBjb25jYXQgKGFycnMsIGxlbmd0aCkge1xuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgZm9yIChjb25zdCBhcnIgb2YgYXJycykge1xuICAgIG91dHB1dC5zZXQoYXJyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IGRlY29kZVRleHQsIGVuY29kZVRleHQsIGNvbmNhdCB9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCB8fCBzaGlmdCA+IDQ5KSB7XG4gICAgICByZWFkLmJ5dGVzID0gMFxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBkZWNvZGUgdmFyaW50JylcbiAgICB9XG4gICAgYiA9IGJ1Zltjb3VudGVyKytdXG4gICAgcmVzICs9IHNoaWZ0IDwgMjhcbiAgICAgID8gKGIgJiBSRVNUKSA8PCBzaGlmdFxuICAgICAgOiAoYiAmIFJFU1QpICogTWF0aC5wb3coMiwgc2hpZnQpXG4gICAgc2hpZnQgKz0gN1xuICB9IHdoaWxlIChiID49IE1TQilcblxuICByZWFkLmJ5dGVzID0gY291bnRlciAtIG9mZnNldFxuXG4gIHJldHVybiByZXNcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZW5jb2RlXG5cbnZhciBNU0IgPSAweDgwXG4gICwgUkVTVCA9IDB4N0ZcbiAgLCBNU0JBTEwgPSB+UkVTVFxuICAsIElOVCA9IE1hdGgucG93KDIsIDMxKVxuXG5mdW5jdGlvbiBlbmNvZGUobnVtLCBvdXQsIG9mZnNldCkge1xuICBpZiAoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgJiYgbnVtID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICBlbmNvZGUuYnl0ZXMgPSAwXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NvdWxkIG5vdCBlbmNvZGUgdmFyaW50JylcbiAgfVxuICBvdXQgPSBvdXQgfHwgW11cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgdmFyIG9sZE9mZnNldCA9IG9mZnNldFxuXG4gIHdoaWxlKG51bSA+PSBJTlQpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtIC89IDEyOFxuICB9XG4gIHdoaWxlKG51bSAmIE1TQkFMTCkge1xuICAgIG91dFtvZmZzZXQrK10gPSAobnVtICYgMHhGRikgfCBNU0JcbiAgICBudW0gPj4+PSA3XG4gIH1cbiAgb3V0W29mZnNldF0gPSBudW0gfCAwXG4gIFxuICBlbmNvZGUuYnl0ZXMgPSBvZmZzZXQgLSBvbGRPZmZzZXQgKyAxXG4gIFxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBlbmNvZGU6IHJlcXVpcmUoJy4vZW5jb2RlLmpzJylcbiAgLCBkZWNvZGU6IHJlcXVpcmUoJy4vZGVjb2RlLmpzJylcbiAgLCBlbmNvZGluZ0xlbmd0aDogcmVxdWlyZSgnLi9sZW5ndGguanMnKVxufVxuIiwiXG52YXIgTjEgPSBNYXRoLnBvdygyLCAgNylcbnZhciBOMiA9IE1hdGgucG93KDIsIDE0KVxudmFyIE4zID0gTWF0aC5wb3coMiwgMjEpXG52YXIgTjQgPSBNYXRoLnBvdygyLCAyOClcbnZhciBONSA9IE1hdGgucG93KDIsIDM1KVxudmFyIE42ID0gTWF0aC5wb3coMiwgNDIpXG52YXIgTjcgPSBNYXRoLnBvdygyLCA0OSlcbnZhciBOOCA9IE1hdGgucG93KDIsIDU2KVxudmFyIE45ID0gTWF0aC5wb3coMiwgNjMpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgPCBOMSA/IDFcbiAgOiB2YWx1ZSA8IE4yID8gMlxuICA6IHZhbHVlIDwgTjMgPyAzXG4gIDogdmFsdWUgPCBONCA/IDRcbiAgOiB2YWx1ZSA8IE41ID8gNVxuICA6IHZhbHVlIDwgTjYgPyA2XG4gIDogdmFsdWUgPCBONyA/IDdcbiAgOiB2YWx1ZSA8IE44ID8gOFxuICA6IHZhbHVlIDwgTjkgPyA5XG4gIDogICAgICAgICAgICAgIDEwXG4gIClcbn1cbiIsIi8vIERPIE5PVCBDSEFOR0UgVEhJUyBGSUxFLiBJVCBJUyBHRU5FUkFURUQgQlkgdG9vbHMvdXBkYXRlLXRhYmxlLmpzXG4vKiBlc2xpbnQgcXVvdGUtcHJvcHM6IG9mZiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHR5cGUge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuTmFtZU51bWJlck1hcH1cbiAqL1xuY29uc3QgYmFzZVRhYmxlID0gT2JqZWN0LmZyZWV6ZSh7XG4gICdpZGVudGl0eSc6IDB4MDAsXG4gICdjaWR2MSc6IDB4MDEsXG4gICdjaWR2Mic6IDB4MDIsXG4gICdjaWR2Myc6IDB4MDMsXG4gICdpcDQnOiAweDA0LFxuICAndGNwJzogMHgwNixcbiAgJ3NoYTEnOiAweDExLFxuICAnc2hhMi0yNTYnOiAweDEyLFxuICAnc2hhMi01MTInOiAweDEzLFxuICAnc2hhMy01MTInOiAweDE0LFxuICAnc2hhMy0zODQnOiAweDE1LFxuICAnc2hhMy0yNTYnOiAweDE2LFxuICAnc2hhMy0yMjQnOiAweDE3LFxuICAnc2hha2UtMTI4JzogMHgxOCxcbiAgJ3NoYWtlLTI1Nic6IDB4MTksXG4gICdrZWNjYWstMjI0JzogMHgxYSxcbiAgJ2tlY2Nhay0yNTYnOiAweDFiLFxuICAna2VjY2FrLTM4NCc6IDB4MWMsXG4gICdrZWNjYWstNTEyJzogMHgxZCxcbiAgJ2JsYWtlMyc6IDB4MWUsXG4gICdkY2NwJzogMHgyMSxcbiAgJ211cm11cjMtMTI4JzogMHgyMixcbiAgJ211cm11cjMtMzInOiAweDIzLFxuICAnaXA2JzogMHgyOSxcbiAgJ2lwNnpvbmUnOiAweDJhLFxuICAncGF0aCc6IDB4MmYsXG4gICdtdWx0aWNvZGVjJzogMHgzMCxcbiAgJ211bHRpaGFzaCc6IDB4MzEsXG4gICdtdWx0aWFkZHInOiAweDMyLFxuICAnbXVsdGliYXNlJzogMHgzMyxcbiAgJ2Rucyc6IDB4MzUsXG4gICdkbnM0JzogMHgzNixcbiAgJ2RuczYnOiAweDM3LFxuICAnZG5zYWRkcic6IDB4MzgsXG4gICdwcm90b2J1Zic6IDB4NTAsXG4gICdjYm9yJzogMHg1MSxcbiAgJ3Jhdyc6IDB4NTUsXG4gICdkYmwtc2hhMi0yNTYnOiAweDU2LFxuICAncmxwJzogMHg2MCxcbiAgJ2JlbmNvZGUnOiAweDYzLFxuICAnZGFnLXBiJzogMHg3MCxcbiAgJ2RhZy1jYm9yJzogMHg3MSxcbiAgJ2xpYnAycC1rZXknOiAweDcyLFxuICAnZ2l0LXJhdyc6IDB4NzgsXG4gICd0b3JyZW50LWluZm8nOiAweDdiLFxuICAndG9ycmVudC1maWxlJzogMHg3YyxcbiAgJ2xlb2Zjb2luLWJsb2NrJzogMHg4MSxcbiAgJ2xlb2Zjb2luLXR4JzogMHg4MixcbiAgJ2xlb2Zjb2luLXByJzogMHg4MyxcbiAgJ3NjdHAnOiAweDg0LFxuICAnZGFnLWpvc2UnOiAweDg1LFxuICAnZGFnLWNvc2UnOiAweDg2LFxuICAnZXRoLWJsb2NrJzogMHg5MCxcbiAgJ2V0aC1ibG9jay1saXN0JzogMHg5MSxcbiAgJ2V0aC10eC10cmllJzogMHg5MixcbiAgJ2V0aC10eCc6IDB4OTMsXG4gICdldGgtdHgtcmVjZWlwdC10cmllJzogMHg5NCxcbiAgJ2V0aC10eC1yZWNlaXB0JzogMHg5NSxcbiAgJ2V0aC1zdGF0ZS10cmllJzogMHg5NixcbiAgJ2V0aC1hY2NvdW50LXNuYXBzaG90JzogMHg5NyxcbiAgJ2V0aC1zdG9yYWdlLXRyaWUnOiAweDk4LFxuICAnYml0Y29pbi1ibG9jayc6IDB4YjAsXG4gICdiaXRjb2luLXR4JzogMHhiMSxcbiAgJ2JpdGNvaW4td2l0bmVzcy1jb21taXRtZW50JzogMHhiMixcbiAgJ3pjYXNoLWJsb2NrJzogMHhjMCxcbiAgJ3pjYXNoLXR4JzogMHhjMSxcbiAgJ2RvY2lkJzogMHhjZSxcbiAgJ3N0ZWxsYXItYmxvY2snOiAweGQwLFxuICAnc3RlbGxhci10eCc6IDB4ZDEsXG4gICdtZDQnOiAweGQ0LFxuICAnbWQ1JzogMHhkNSxcbiAgJ2JtdCc6IDB4ZDYsXG4gICdkZWNyZWQtYmxvY2snOiAweGUwLFxuICAnZGVjcmVkLXR4JzogMHhlMSxcbiAgJ2lwbGQtbnMnOiAweGUyLFxuICAnaXBmcy1ucyc6IDB4ZTMsXG4gICdzd2FybS1ucyc6IDB4ZTQsXG4gICdpcG5zLW5zJzogMHhlNSxcbiAgJ3plcm9uZXQnOiAweGU2LFxuICAnc2VjcDI1NmsxLXB1Yic6IDB4ZTcsXG4gICdibHMxMl8zODEtZzEtcHViJzogMHhlYSxcbiAgJ2JsczEyXzM4MS1nMi1wdWInOiAweGViLFxuICAneDI1NTE5LXB1Yic6IDB4ZWMsXG4gICdlZDI1NTE5LXB1Yic6IDB4ZWQsXG4gICdibHMxMl8zODEtZzFnMi1wdWInOiAweGVlLFxuICAnZGFzaC1ibG9jayc6IDB4ZjAsXG4gICdkYXNoLXR4JzogMHhmMSxcbiAgJ3N3YXJtLW1hbmlmZXN0JzogMHhmYSxcbiAgJ3N3YXJtLWZlZWQnOiAweGZiLFxuICAndWRwJzogMHgwMTExLFxuICAncDJwLXdlYnJ0Yy1zdGFyJzogMHgwMTEzLFxuICAncDJwLXdlYnJ0Yy1kaXJlY3QnOiAweDAxMTQsXG4gICdwMnAtc3RhcmR1c3QnOiAweDAxMTUsXG4gICdwMnAtY2lyY3VpdCc6IDB4MDEyMixcbiAgJ2RhZy1qc29uJzogMHgwMTI5LFxuICAndWR0JzogMHgwMTJkLFxuICAndXRwJzogMHgwMTJlLFxuICAndW5peCc6IDB4MDE5MCxcbiAgJ3AycCc6IDB4MDFhNSxcbiAgJ2lwZnMnOiAweDAxYTUsXG4gICdodHRwcyc6IDB4MDFiYixcbiAgJ29uaW9uJzogMHgwMWJjLFxuICAnb25pb24zJzogMHgwMWJkLFxuICAnZ2FybGljNjQnOiAweDAxYmUsXG4gICdnYXJsaWMzMic6IDB4MDFiZixcbiAgJ3Rscyc6IDB4MDFjMCxcbiAgJ3F1aWMnOiAweDAxY2MsXG4gICd3cyc6IDB4MDFkZCxcbiAgJ3dzcyc6IDB4MDFkZSxcbiAgJ3AycC13ZWJzb2NrZXQtc3Rhcic6IDB4MDFkZixcbiAgJ2h0dHAnOiAweDAxZTAsXG4gICdqc29uJzogMHgwMjAwLFxuICAnbWVzc2FnZXBhY2snOiAweDAyMDEsXG4gICdsaWJwMnAtcGVlci1yZWNvcmQnOiAweDAzMDEsXG4gICdzaGEyLTI1Ni10cnVuYzI1NC1wYWRkZWQnOiAweDEwMTIsXG4gICdyaXBlbWQtMTI4JzogMHgxMDUyLFxuICAncmlwZW1kLTE2MCc6IDB4MTA1MyxcbiAgJ3JpcGVtZC0yNTYnOiAweDEwNTQsXG4gICdyaXBlbWQtMzIwJzogMHgxMDU1LFxuICAneDExJzogMHgxMTAwLFxuICAncDI1Ni1wdWInOiAweDEyMDAsXG4gICdwMzg0LXB1Yic6IDB4MTIwMSxcbiAgJ3A1MjEtcHViJzogMHgxMjAyLFxuICAnZWQ0NDgtcHViJzogMHgxMjAzLFxuICAneDQ0OC1wdWInOiAweDEyMDQsXG4gICdlZDI1NTE5LXByaXYnOiAweDEzMDAsXG4gICdrYW5nYXJvb3R3ZWx2ZSc6IDB4MWQwMSxcbiAgJ3NtMy0yNTYnOiAweDUzNGQsXG4gICdibGFrZTJiLTgnOiAweGIyMDEsXG4gICdibGFrZTJiLTE2JzogMHhiMjAyLFxuICAnYmxha2UyYi0yNCc6IDB4YjIwMyxcbiAgJ2JsYWtlMmItMzInOiAweGIyMDQsXG4gICdibGFrZTJiLTQwJzogMHhiMjA1LFxuICAnYmxha2UyYi00OCc6IDB4YjIwNixcbiAgJ2JsYWtlMmItNTYnOiAweGIyMDcsXG4gICdibGFrZTJiLTY0JzogMHhiMjA4LFxuICAnYmxha2UyYi03Mic6IDB4YjIwOSxcbiAgJ2JsYWtlMmItODAnOiAweGIyMGEsXG4gICdibGFrZTJiLTg4JzogMHhiMjBiLFxuICAnYmxha2UyYi05Nic6IDB4YjIwYyxcbiAgJ2JsYWtlMmItMTA0JzogMHhiMjBkLFxuICAnYmxha2UyYi0xMTInOiAweGIyMGUsXG4gICdibGFrZTJiLTEyMCc6IDB4YjIwZixcbiAgJ2JsYWtlMmItMTI4JzogMHhiMjEwLFxuICAnYmxha2UyYi0xMzYnOiAweGIyMTEsXG4gICdibGFrZTJiLTE0NCc6IDB4YjIxMixcbiAgJ2JsYWtlMmItMTUyJzogMHhiMjEzLFxuICAnYmxha2UyYi0xNjAnOiAweGIyMTQsXG4gICdibGFrZTJiLTE2OCc6IDB4YjIxNSxcbiAgJ2JsYWtlMmItMTc2JzogMHhiMjE2LFxuICAnYmxha2UyYi0xODQnOiAweGIyMTcsXG4gICdibGFrZTJiLTE5Mic6IDB4YjIxOCxcbiAgJ2JsYWtlMmItMjAwJzogMHhiMjE5LFxuICAnYmxha2UyYi0yMDgnOiAweGIyMWEsXG4gICdibGFrZTJiLTIxNic6IDB4YjIxYixcbiAgJ2JsYWtlMmItMjI0JzogMHhiMjFjLFxuICAnYmxha2UyYi0yMzInOiAweGIyMWQsXG4gICdibGFrZTJiLTI0MCc6IDB4YjIxZSxcbiAgJ2JsYWtlMmItMjQ4JzogMHhiMjFmLFxuICAnYmxha2UyYi0yNTYnOiAweGIyMjAsXG4gICdibGFrZTJiLTI2NCc6IDB4YjIyMSxcbiAgJ2JsYWtlMmItMjcyJzogMHhiMjIyLFxuICAnYmxha2UyYi0yODAnOiAweGIyMjMsXG4gICdibGFrZTJiLTI4OCc6IDB4YjIyNCxcbiAgJ2JsYWtlMmItMjk2JzogMHhiMjI1LFxuICAnYmxha2UyYi0zMDQnOiAweGIyMjYsXG4gICdibGFrZTJiLTMxMic6IDB4YjIyNyxcbiAgJ2JsYWtlMmItMzIwJzogMHhiMjI4LFxuICAnYmxha2UyYi0zMjgnOiAweGIyMjksXG4gICdibGFrZTJiLTMzNic6IDB4YjIyYSxcbiAgJ2JsYWtlMmItMzQ0JzogMHhiMjJiLFxuICAnYmxha2UyYi0zNTInOiAweGIyMmMsXG4gICdibGFrZTJiLTM2MCc6IDB4YjIyZCxcbiAgJ2JsYWtlMmItMzY4JzogMHhiMjJlLFxuICAnYmxha2UyYi0zNzYnOiAweGIyMmYsXG4gICdibGFrZTJiLTM4NCc6IDB4YjIzMCxcbiAgJ2JsYWtlMmItMzkyJzogMHhiMjMxLFxuICAnYmxha2UyYi00MDAnOiAweGIyMzIsXG4gICdibGFrZTJiLTQwOCc6IDB4YjIzMyxcbiAgJ2JsYWtlMmItNDE2JzogMHhiMjM0LFxuICAnYmxha2UyYi00MjQnOiAweGIyMzUsXG4gICdibGFrZTJiLTQzMic6IDB4YjIzNixcbiAgJ2JsYWtlMmItNDQwJzogMHhiMjM3LFxuICAnYmxha2UyYi00NDgnOiAweGIyMzgsXG4gICdibGFrZTJiLTQ1Nic6IDB4YjIzOSxcbiAgJ2JsYWtlMmItNDY0JzogMHhiMjNhLFxuICAnYmxha2UyYi00NzInOiAweGIyM2IsXG4gICdibGFrZTJiLTQ4MCc6IDB4YjIzYyxcbiAgJ2JsYWtlMmItNDg4JzogMHhiMjNkLFxuICAnYmxha2UyYi00OTYnOiAweGIyM2UsXG4gICdibGFrZTJiLTUwNCc6IDB4YjIzZixcbiAgJ2JsYWtlMmItNTEyJzogMHhiMjQwLFxuICAnYmxha2Uycy04JzogMHhiMjQxLFxuICAnYmxha2Uycy0xNic6IDB4YjI0MixcbiAgJ2JsYWtlMnMtMjQnOiAweGIyNDMsXG4gICdibGFrZTJzLTMyJzogMHhiMjQ0LFxuICAnYmxha2Uycy00MCc6IDB4YjI0NSxcbiAgJ2JsYWtlMnMtNDgnOiAweGIyNDYsXG4gICdibGFrZTJzLTU2JzogMHhiMjQ3LFxuICAnYmxha2Uycy02NCc6IDB4YjI0OCxcbiAgJ2JsYWtlMnMtNzInOiAweGIyNDksXG4gICdibGFrZTJzLTgwJzogMHhiMjRhLFxuICAnYmxha2Uycy04OCc6IDB4YjI0YixcbiAgJ2JsYWtlMnMtOTYnOiAweGIyNGMsXG4gICdibGFrZTJzLTEwNCc6IDB4YjI0ZCxcbiAgJ2JsYWtlMnMtMTEyJzogMHhiMjRlLFxuICAnYmxha2Uycy0xMjAnOiAweGIyNGYsXG4gICdibGFrZTJzLTEyOCc6IDB4YjI1MCxcbiAgJ2JsYWtlMnMtMTM2JzogMHhiMjUxLFxuICAnYmxha2Uycy0xNDQnOiAweGIyNTIsXG4gICdibGFrZTJzLTE1Mic6IDB4YjI1MyxcbiAgJ2JsYWtlMnMtMTYwJzogMHhiMjU0LFxuICAnYmxha2Uycy0xNjgnOiAweGIyNTUsXG4gICdibGFrZTJzLTE3Nic6IDB4YjI1NixcbiAgJ2JsYWtlMnMtMTg0JzogMHhiMjU3LFxuICAnYmxha2Uycy0xOTInOiAweGIyNTgsXG4gICdibGFrZTJzLTIwMCc6IDB4YjI1OSxcbiAgJ2JsYWtlMnMtMjA4JzogMHhiMjVhLFxuICAnYmxha2Uycy0yMTYnOiAweGIyNWIsXG4gICdibGFrZTJzLTIyNCc6IDB4YjI1YyxcbiAgJ2JsYWtlMnMtMjMyJzogMHhiMjVkLFxuICAnYmxha2Uycy0yNDAnOiAweGIyNWUsXG4gICdibGFrZTJzLTI0OCc6IDB4YjI1ZixcbiAgJ2JsYWtlMnMtMjU2JzogMHhiMjYwLFxuICAnc2tlaW4yNTYtOCc6IDB4YjMwMSxcbiAgJ3NrZWluMjU2LTE2JzogMHhiMzAyLFxuICAnc2tlaW4yNTYtMjQnOiAweGIzMDMsXG4gICdza2VpbjI1Ni0zMic6IDB4YjMwNCxcbiAgJ3NrZWluMjU2LTQwJzogMHhiMzA1LFxuICAnc2tlaW4yNTYtNDgnOiAweGIzMDYsXG4gICdza2VpbjI1Ni01Nic6IDB4YjMwNyxcbiAgJ3NrZWluMjU2LTY0JzogMHhiMzA4LFxuICAnc2tlaW4yNTYtNzInOiAweGIzMDksXG4gICdza2VpbjI1Ni04MCc6IDB4YjMwYSxcbiAgJ3NrZWluMjU2LTg4JzogMHhiMzBiLFxuICAnc2tlaW4yNTYtOTYnOiAweGIzMGMsXG4gICdza2VpbjI1Ni0xMDQnOiAweGIzMGQsXG4gICdza2VpbjI1Ni0xMTInOiAweGIzMGUsXG4gICdza2VpbjI1Ni0xMjAnOiAweGIzMGYsXG4gICdza2VpbjI1Ni0xMjgnOiAweGIzMTAsXG4gICdza2VpbjI1Ni0xMzYnOiAweGIzMTEsXG4gICdza2VpbjI1Ni0xNDQnOiAweGIzMTIsXG4gICdza2VpbjI1Ni0xNTInOiAweGIzMTMsXG4gICdza2VpbjI1Ni0xNjAnOiAweGIzMTQsXG4gICdza2VpbjI1Ni0xNjgnOiAweGIzMTUsXG4gICdza2VpbjI1Ni0xNzYnOiAweGIzMTYsXG4gICdza2VpbjI1Ni0xODQnOiAweGIzMTcsXG4gICdza2VpbjI1Ni0xOTInOiAweGIzMTgsXG4gICdza2VpbjI1Ni0yMDAnOiAweGIzMTksXG4gICdza2VpbjI1Ni0yMDgnOiAweGIzMWEsXG4gICdza2VpbjI1Ni0yMTYnOiAweGIzMWIsXG4gICdza2VpbjI1Ni0yMjQnOiAweGIzMWMsXG4gICdza2VpbjI1Ni0yMzInOiAweGIzMWQsXG4gICdza2VpbjI1Ni0yNDAnOiAweGIzMWUsXG4gICdza2VpbjI1Ni0yNDgnOiAweGIzMWYsXG4gICdza2VpbjI1Ni0yNTYnOiAweGIzMjAsXG4gICdza2VpbjUxMi04JzogMHhiMzIxLFxuICAnc2tlaW41MTItMTYnOiAweGIzMjIsXG4gICdza2VpbjUxMi0yNCc6IDB4YjMyMyxcbiAgJ3NrZWluNTEyLTMyJzogMHhiMzI0LFxuICAnc2tlaW41MTItNDAnOiAweGIzMjUsXG4gICdza2VpbjUxMi00OCc6IDB4YjMyNixcbiAgJ3NrZWluNTEyLTU2JzogMHhiMzI3LFxuICAnc2tlaW41MTItNjQnOiAweGIzMjgsXG4gICdza2VpbjUxMi03Mic6IDB4YjMyOSxcbiAgJ3NrZWluNTEyLTgwJzogMHhiMzJhLFxuICAnc2tlaW41MTItODgnOiAweGIzMmIsXG4gICdza2VpbjUxMi05Nic6IDB4YjMyYyxcbiAgJ3NrZWluNTEyLTEwNCc6IDB4YjMyZCxcbiAgJ3NrZWluNTEyLTExMic6IDB4YjMyZSxcbiAgJ3NrZWluNTEyLTEyMCc6IDB4YjMyZixcbiAgJ3NrZWluNTEyLTEyOCc6IDB4YjMzMCxcbiAgJ3NrZWluNTEyLTEzNic6IDB4YjMzMSxcbiAgJ3NrZWluNTEyLTE0NCc6IDB4YjMzMixcbiAgJ3NrZWluNTEyLTE1Mic6IDB4YjMzMyxcbiAgJ3NrZWluNTEyLTE2MCc6IDB4YjMzNCxcbiAgJ3NrZWluNTEyLTE2OCc6IDB4YjMzNSxcbiAgJ3NrZWluNTEyLTE3Nic6IDB4YjMzNixcbiAgJ3NrZWluNTEyLTE4NCc6IDB4YjMzNyxcbiAgJ3NrZWluNTEyLTE5Mic6IDB4YjMzOCxcbiAgJ3NrZWluNTEyLTIwMCc6IDB4YjMzOSxcbiAgJ3NrZWluNTEyLTIwOCc6IDB4YjMzYSxcbiAgJ3NrZWluNTEyLTIxNic6IDB4YjMzYixcbiAgJ3NrZWluNTEyLTIyNCc6IDB4YjMzYyxcbiAgJ3NrZWluNTEyLTIzMic6IDB4YjMzZCxcbiAgJ3NrZWluNTEyLTI0MCc6IDB4YjMzZSxcbiAgJ3NrZWluNTEyLTI0OCc6IDB4YjMzZixcbiAgJ3NrZWluNTEyLTI1Nic6IDB4YjM0MCxcbiAgJ3NrZWluNTEyLTI2NCc6IDB4YjM0MSxcbiAgJ3NrZWluNTEyLTI3Mic6IDB4YjM0MixcbiAgJ3NrZWluNTEyLTI4MCc6IDB4YjM0MyxcbiAgJ3NrZWluNTEyLTI4OCc6IDB4YjM0NCxcbiAgJ3NrZWluNTEyLTI5Nic6IDB4YjM0NSxcbiAgJ3NrZWluNTEyLTMwNCc6IDB4YjM0NixcbiAgJ3NrZWluNTEyLTMxMic6IDB4YjM0NyxcbiAgJ3NrZWluNTEyLTMyMCc6IDB4YjM0OCxcbiAgJ3NrZWluNTEyLTMyOCc6IDB4YjM0OSxcbiAgJ3NrZWluNTEyLTMzNic6IDB4YjM0YSxcbiAgJ3NrZWluNTEyLTM0NCc6IDB4YjM0YixcbiAgJ3NrZWluNTEyLTM1Mic6IDB4YjM0YyxcbiAgJ3NrZWluNTEyLTM2MCc6IDB4YjM0ZCxcbiAgJ3NrZWluNTEyLTM2OCc6IDB4YjM0ZSxcbiAgJ3NrZWluNTEyLTM3Nic6IDB4YjM0ZixcbiAgJ3NrZWluNTEyLTM4NCc6IDB4YjM1MCxcbiAgJ3NrZWluNTEyLTM5Mic6IDB4YjM1MSxcbiAgJ3NrZWluNTEyLTQwMCc6IDB4YjM1MixcbiAgJ3NrZWluNTEyLTQwOCc6IDB4YjM1MyxcbiAgJ3NrZWluNTEyLTQxNic6IDB4YjM1NCxcbiAgJ3NrZWluNTEyLTQyNCc6IDB4YjM1NSxcbiAgJ3NrZWluNTEyLTQzMic6IDB4YjM1NixcbiAgJ3NrZWluNTEyLTQ0MCc6IDB4YjM1NyxcbiAgJ3NrZWluNTEyLTQ0OCc6IDB4YjM1OCxcbiAgJ3NrZWluNTEyLTQ1Nic6IDB4YjM1OSxcbiAgJ3NrZWluNTEyLTQ2NCc6IDB4YjM1YSxcbiAgJ3NrZWluNTEyLTQ3Mic6IDB4YjM1YixcbiAgJ3NrZWluNTEyLTQ4MCc6IDB4YjM1YyxcbiAgJ3NrZWluNTEyLTQ4OCc6IDB4YjM1ZCxcbiAgJ3NrZWluNTEyLTQ5Nic6IDB4YjM1ZSxcbiAgJ3NrZWluNTEyLTUwNCc6IDB4YjM1ZixcbiAgJ3NrZWluNTEyLTUxMic6IDB4YjM2MCxcbiAgJ3NrZWluMTAyNC04JzogMHhiMzYxLFxuICAnc2tlaW4xMDI0LTE2JzogMHhiMzYyLFxuICAnc2tlaW4xMDI0LTI0JzogMHhiMzYzLFxuICAnc2tlaW4xMDI0LTMyJzogMHhiMzY0LFxuICAnc2tlaW4xMDI0LTQwJzogMHhiMzY1LFxuICAnc2tlaW4xMDI0LTQ4JzogMHhiMzY2LFxuICAnc2tlaW4xMDI0LTU2JzogMHhiMzY3LFxuICAnc2tlaW4xMDI0LTY0JzogMHhiMzY4LFxuICAnc2tlaW4xMDI0LTcyJzogMHhiMzY5LFxuICAnc2tlaW4xMDI0LTgwJzogMHhiMzZhLFxuICAnc2tlaW4xMDI0LTg4JzogMHhiMzZiLFxuICAnc2tlaW4xMDI0LTk2JzogMHhiMzZjLFxuICAnc2tlaW4xMDI0LTEwNCc6IDB4YjM2ZCxcbiAgJ3NrZWluMTAyNC0xMTInOiAweGIzNmUsXG4gICdza2VpbjEwMjQtMTIwJzogMHhiMzZmLFxuICAnc2tlaW4xMDI0LTEyOCc6IDB4YjM3MCxcbiAgJ3NrZWluMTAyNC0xMzYnOiAweGIzNzEsXG4gICdza2VpbjEwMjQtMTQ0JzogMHhiMzcyLFxuICAnc2tlaW4xMDI0LTE1Mic6IDB4YjM3MyxcbiAgJ3NrZWluMTAyNC0xNjAnOiAweGIzNzQsXG4gICdza2VpbjEwMjQtMTY4JzogMHhiMzc1LFxuICAnc2tlaW4xMDI0LTE3Nic6IDB4YjM3NixcbiAgJ3NrZWluMTAyNC0xODQnOiAweGIzNzcsXG4gICdza2VpbjEwMjQtMTkyJzogMHhiMzc4LFxuICAnc2tlaW4xMDI0LTIwMCc6IDB4YjM3OSxcbiAgJ3NrZWluMTAyNC0yMDgnOiAweGIzN2EsXG4gICdza2VpbjEwMjQtMjE2JzogMHhiMzdiLFxuICAnc2tlaW4xMDI0LTIyNCc6IDB4YjM3YyxcbiAgJ3NrZWluMTAyNC0yMzInOiAweGIzN2QsXG4gICdza2VpbjEwMjQtMjQwJzogMHhiMzdlLFxuICAnc2tlaW4xMDI0LTI0OCc6IDB4YjM3ZixcbiAgJ3NrZWluMTAyNC0yNTYnOiAweGIzODAsXG4gICdza2VpbjEwMjQtMjY0JzogMHhiMzgxLFxuICAnc2tlaW4xMDI0LTI3Mic6IDB4YjM4MixcbiAgJ3NrZWluMTAyNC0yODAnOiAweGIzODMsXG4gICdza2VpbjEwMjQtMjg4JzogMHhiMzg0LFxuICAnc2tlaW4xMDI0LTI5Nic6IDB4YjM4NSxcbiAgJ3NrZWluMTAyNC0zMDQnOiAweGIzODYsXG4gICdza2VpbjEwMjQtMzEyJzogMHhiMzg3LFxuICAnc2tlaW4xMDI0LTMyMCc6IDB4YjM4OCxcbiAgJ3NrZWluMTAyNC0zMjgnOiAweGIzODksXG4gICdza2VpbjEwMjQtMzM2JzogMHhiMzhhLFxuICAnc2tlaW4xMDI0LTM0NCc6IDB4YjM4YixcbiAgJ3NrZWluMTAyNC0zNTInOiAweGIzOGMsXG4gICdza2VpbjEwMjQtMzYwJzogMHhiMzhkLFxuICAnc2tlaW4xMDI0LTM2OCc6IDB4YjM4ZSxcbiAgJ3NrZWluMTAyNC0zNzYnOiAweGIzOGYsXG4gICdza2VpbjEwMjQtMzg0JzogMHhiMzkwLFxuICAnc2tlaW4xMDI0LTM5Mic6IDB4YjM5MSxcbiAgJ3NrZWluMTAyNC00MDAnOiAweGIzOTIsXG4gICdza2VpbjEwMjQtNDA4JzogMHhiMzkzLFxuICAnc2tlaW4xMDI0LTQxNic6IDB4YjM5NCxcbiAgJ3NrZWluMTAyNC00MjQnOiAweGIzOTUsXG4gICdza2VpbjEwMjQtNDMyJzogMHhiMzk2LFxuICAnc2tlaW4xMDI0LTQ0MCc6IDB4YjM5NyxcbiAgJ3NrZWluMTAyNC00NDgnOiAweGIzOTgsXG4gICdza2VpbjEwMjQtNDU2JzogMHhiMzk5LFxuICAnc2tlaW4xMDI0LTQ2NCc6IDB4YjM5YSxcbiAgJ3NrZWluMTAyNC00NzInOiAweGIzOWIsXG4gICdza2VpbjEwMjQtNDgwJzogMHhiMzljLFxuICAnc2tlaW4xMDI0LTQ4OCc6IDB4YjM5ZCxcbiAgJ3NrZWluMTAyNC00OTYnOiAweGIzOWUsXG4gICdza2VpbjEwMjQtNTA0JzogMHhiMzlmLFxuICAnc2tlaW4xMDI0LTUxMic6IDB4YjNhMCxcbiAgJ3NrZWluMTAyNC01MjAnOiAweGIzYTEsXG4gICdza2VpbjEwMjQtNTI4JzogMHhiM2EyLFxuICAnc2tlaW4xMDI0LTUzNic6IDB4YjNhMyxcbiAgJ3NrZWluMTAyNC01NDQnOiAweGIzYTQsXG4gICdza2VpbjEwMjQtNTUyJzogMHhiM2E1LFxuICAnc2tlaW4xMDI0LTU2MCc6IDB4YjNhNixcbiAgJ3NrZWluMTAyNC01NjgnOiAweGIzYTcsXG4gICdza2VpbjEwMjQtNTc2JzogMHhiM2E4LFxuICAnc2tlaW4xMDI0LTU4NCc6IDB4YjNhOSxcbiAgJ3NrZWluMTAyNC01OTInOiAweGIzYWEsXG4gICdza2VpbjEwMjQtNjAwJzogMHhiM2FiLFxuICAnc2tlaW4xMDI0LTYwOCc6IDB4YjNhYyxcbiAgJ3NrZWluMTAyNC02MTYnOiAweGIzYWQsXG4gICdza2VpbjEwMjQtNjI0JzogMHhiM2FlLFxuICAnc2tlaW4xMDI0LTYzMic6IDB4YjNhZixcbiAgJ3NrZWluMTAyNC02NDAnOiAweGIzYjAsXG4gICdza2VpbjEwMjQtNjQ4JzogMHhiM2IxLFxuICAnc2tlaW4xMDI0LTY1Nic6IDB4YjNiMixcbiAgJ3NrZWluMTAyNC02NjQnOiAweGIzYjMsXG4gICdza2VpbjEwMjQtNjcyJzogMHhiM2I0LFxuICAnc2tlaW4xMDI0LTY4MCc6IDB4YjNiNSxcbiAgJ3NrZWluMTAyNC02ODgnOiAweGIzYjYsXG4gICdza2VpbjEwMjQtNjk2JzogMHhiM2I3LFxuICAnc2tlaW4xMDI0LTcwNCc6IDB4YjNiOCxcbiAgJ3NrZWluMTAyNC03MTInOiAweGIzYjksXG4gICdza2VpbjEwMjQtNzIwJzogMHhiM2JhLFxuICAnc2tlaW4xMDI0LTcyOCc6IDB4YjNiYixcbiAgJ3NrZWluMTAyNC03MzYnOiAweGIzYmMsXG4gICdza2VpbjEwMjQtNzQ0JzogMHhiM2JkLFxuICAnc2tlaW4xMDI0LTc1Mic6IDB4YjNiZSxcbiAgJ3NrZWluMTAyNC03NjAnOiAweGIzYmYsXG4gICdza2VpbjEwMjQtNzY4JzogMHhiM2MwLFxuICAnc2tlaW4xMDI0LTc3Nic6IDB4YjNjMSxcbiAgJ3NrZWluMTAyNC03ODQnOiAweGIzYzIsXG4gICdza2VpbjEwMjQtNzkyJzogMHhiM2MzLFxuICAnc2tlaW4xMDI0LTgwMCc6IDB4YjNjNCxcbiAgJ3NrZWluMTAyNC04MDgnOiAweGIzYzUsXG4gICdza2VpbjEwMjQtODE2JzogMHhiM2M2LFxuICAnc2tlaW4xMDI0LTgyNCc6IDB4YjNjNyxcbiAgJ3NrZWluMTAyNC04MzInOiAweGIzYzgsXG4gICdza2VpbjEwMjQtODQwJzogMHhiM2M5LFxuICAnc2tlaW4xMDI0LTg0OCc6IDB4YjNjYSxcbiAgJ3NrZWluMTAyNC04NTYnOiAweGIzY2IsXG4gICdza2VpbjEwMjQtODY0JzogMHhiM2NjLFxuICAnc2tlaW4xMDI0LTg3Mic6IDB4YjNjZCxcbiAgJ3NrZWluMTAyNC04ODAnOiAweGIzY2UsXG4gICdza2VpbjEwMjQtODg4JzogMHhiM2NmLFxuICAnc2tlaW4xMDI0LTg5Nic6IDB4YjNkMCxcbiAgJ3NrZWluMTAyNC05MDQnOiAweGIzZDEsXG4gICdza2VpbjEwMjQtOTEyJzogMHhiM2QyLFxuICAnc2tlaW4xMDI0LTkyMCc6IDB4YjNkMyxcbiAgJ3NrZWluMTAyNC05MjgnOiAweGIzZDQsXG4gICdza2VpbjEwMjQtOTM2JzogMHhiM2Q1LFxuICAnc2tlaW4xMDI0LTk0NCc6IDB4YjNkNixcbiAgJ3NrZWluMTAyNC05NTInOiAweGIzZDcsXG4gICdza2VpbjEwMjQtOTYwJzogMHhiM2Q4LFxuICAnc2tlaW4xMDI0LTk2OCc6IDB4YjNkOSxcbiAgJ3NrZWluMTAyNC05NzYnOiAweGIzZGEsXG4gICdza2VpbjEwMjQtOTg0JzogMHhiM2RiLFxuICAnc2tlaW4xMDI0LTk5Mic6IDB4YjNkYyxcbiAgJ3NrZWluMTAyNC0xMDAwJzogMHhiM2RkLFxuICAnc2tlaW4xMDI0LTEwMDgnOiAweGIzZGUsXG4gICdza2VpbjEwMjQtMTAxNic6IDB4YjNkZixcbiAgJ3NrZWluMTAyNC0xMDI0JzogMHhiM2UwLFxuICAncG9zZWlkb24tYmxzMTJfMzgxLWEyLWZjMSc6IDB4YjQwMSxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEtc2MnOiAweGI0MDIsXG4gICd6ZXJveGNlcnQtaW1wcmludC0yNTYnOiAweGNlMTEsXG4gICdmaWwtY29tbWl0bWVudC11bnNlYWxlZCc6IDB4ZjEwMSxcbiAgJ2ZpbC1jb21taXRtZW50LXNlYWxlZCc6IDB4ZjEwMixcbiAgJ2hvbG9jaGFpbi1hZHItdjAnOiAweDgwNzEyNCxcbiAgJ2hvbG9jaGFpbi1hZHItdjEnOiAweDgxNzEyNCxcbiAgJ2hvbG9jaGFpbi1rZXktdjAnOiAweDk0NzEyNCxcbiAgJ2hvbG9jaGFpbi1rZXktdjEnOiAweDk1NzEyNCxcbiAgJ2hvbG9jaGFpbi1zaWctdjAnOiAweGEyNzEyNCxcbiAgJ2hvbG9jaGFpbi1zaWctdjEnOiAweGEzNzEyNCxcbiAgJ3NreW5ldC1ucyc6IDB4YjE5OTEwXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgYmFzZVRhYmxlIH1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29uc3RhbnROdW1iZXJNYXB9IENvbnN0YW50TnVtYmVyTWFwICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuXG5jb25zdCBjb25zdGFudHMgPSAvKiogQHR5cGUge0NvbnN0YW50TnVtYmVyTWFwfSAqLyh7fSlcblxuZm9yIChjb25zdCBbbmFtZSwgY29kZV0gb2YgT2JqZWN0LmVudHJpZXMoYmFzZVRhYmxlKSkge1xuICBjb25zdCBjb25zdGFudCA9IG5hbWUudG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tL2csICdfJylcbiAgY29uc3RhbnRzW2NvbnN0YW50XSA9IGNvZGVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cylcbiIsIi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIG11bHRpY29kZWMgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBAbW9kdWxlIG11bHRpY29kZWNcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBtdWx0aWNvZGVjID0gcmVxdWlyZSgnbXVsdGljb2RlYycpXG4gKlxuICogY29uc3QgcHJlZml4ZWRQcm90b2J1ZiA9IG11bHRpY29kZWMuYWRkUHJlZml4KCdwcm90b2J1ZicsIHByb3RvYnVmQnVmZmVyKVxuICogLy8gcHJlZml4ZWRQcm90b2J1ZiAweDUwLi4uXG4gKlxuICovXG4ndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjTmFtZX0gQ29kZWNOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOdW1iZXJ9IENvZGVjTnVtYmVyICovXG5cbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5jb25zdCBpbnRUYWJsZSA9IHJlcXVpcmUoJy4vaW50LXRhYmxlJylcbmNvbnN0IGNvZGVjTmFtZVRvQ29kZVZhcmludCA9IHJlcXVpcmUoJy4vdmFyaW50LXRhYmxlJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgdWludDhBcnJheUNvbmNhdCA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2NvbmNhdCcpXG5cbi8qKlxuICogUHJlZml4IGEgYnVmZmVyIHdpdGggYSBtdWx0aWNvZGVjLXBhY2tlZC5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTmFtZXxVaW50OEFycmF5fSBtdWx0aWNvZGVjU3RyT3JDb2RlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBhZGRQcmVmaXggKG11bHRpY29kZWNTdHJPckNvZGUsIGRhdGEpIHtcbiAgbGV0IHByZWZpeFxuXG4gIGlmIChtdWx0aWNvZGVjU3RyT3JDb2RlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHByZWZpeCA9IHV0aWwudmFyaW50VWludDhBcnJheUVuY29kZShtdWx0aWNvZGVjU3RyT3JDb2RlKVxuICB9IGVsc2Uge1xuICAgIGlmIChjb2RlY05hbWVUb0NvZGVWYXJpbnRbbXVsdGljb2RlY1N0ck9yQ29kZV0pIHtcbiAgICAgIHByZWZpeCA9IGNvZGVjTmFtZVRvQ29kZVZhcmludFttdWx0aWNvZGVjU3RyT3JDb2RlXVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpY29kZWMgbm90IHJlY29nbml6ZWQnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdWludDhBcnJheUNvbmNhdChbcHJlZml4LCBkYXRhXSwgcHJlZml4Lmxlbmd0aCArIGRhdGEubGVuZ3RoKVxufVxuXG4vKipcbiAqIERlY2Fwc3VsYXRlIHRoZSBtdWx0aWNvZGVjLXBhY2tlZCBwcmVmaXggZnJvbSB0aGUgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBybVByZWZpeCAoZGF0YSkge1xuICB2YXJpbnQuZGVjb2RlKGRhdGEpXG4gIHJldHVybiBkYXRhLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlYyBvZiB0aGUgcHJlZml4ZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHByZWZpeGVkRGF0YVxuICogQHJldHVybnMge0NvZGVjTmFtZX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZWMgKHByZWZpeGVkRGF0YSkge1xuICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShwcmVmaXhlZERhdGEpXG4gIGNvbnN0IGNvZGVjTmFtZSA9IGludFRhYmxlLmdldChjb2RlKVxuICBpZiAoY29kZWNOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGUgJHtjb2RlfSBub3QgZm91bmRgKVxuICB9XG4gIHJldHVybiBjb2RlY05hbWVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGNvZGVjLlxuICpcbiAqIEBwYXJhbSB7Q29kZWNOdW1iZXJ9IGNvZGVjXG4gKiBAcmV0dXJucyB7Q29kZWNOYW1lfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0TmFtZSAoY29kZWMpIHtcbiAgcmV0dXJuIGludFRhYmxlLmdldChjb2RlYylcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIGNvZGVjXG4gKlxuICogQHBhcmFtIHtDb2RlY05hbWV9IG5hbWVcbiAqIEByZXR1cm5zIHtDb2RlY051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0TnVtYmVyIChuYW1lKSB7XG4gIGNvbnN0IGNvZGUgPSBjb2RlY05hbWVUb0NvZGVWYXJpbnRbbmFtZV1cbiAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ29kZWMgYCcgKyBuYW1lICsgJ2Agbm90IGZvdW5kJylcbiAgfVxuICByZXR1cm4gdmFyaW50LmRlY29kZShjb2RlKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBvZiB0aGUgcHJlZml4ZWQgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHByZWZpeGVkRGF0YVxuICogQHJldHVybnMge0NvZGVjTnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRDb2RlIChwcmVmaXhlZERhdGEpIHtcbiAgcmV0dXJuIHZhcmludC5kZWNvZGUocHJlZml4ZWREYXRhKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZSBhcyB2YXJpbnQgb2YgYSBjb2RlYyBuYW1lLlxuICpcbiAqIEBwYXJhbSB7Q29kZWNOYW1lfSBjb2RlY05hbWVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBnZXRDb2RlVmFyaW50IChjb2RlY05hbWUpIHtcbiAgY29uc3QgY29kZSA9IGNvZGVjTmFtZVRvQ29kZVZhcmludFtjb2RlY05hbWVdXG4gIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVjIGAnICsgY29kZWNOYW1lICsgJ2Agbm90IGZvdW5kJylcbiAgfVxuICByZXR1cm4gY29kZVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFyaW50IG9mIGEgY29kZS5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XG4gKi9cbmZ1bmN0aW9uIGdldFZhcmludCAoY29kZSkge1xuICByZXR1cm4gdmFyaW50LmVuY29kZShjb2RlKVxufVxuXG4vLyBNYWtlIHRoZSBjb25zdGFudHMgdG9wLWxldmVsIGNvbnN0YW50c1xuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuXG4vLyBIdW1hbiBmcmllbmRseSBuYW1lcyBmb3IgcHJpbnRpbmcsIGUuZy4gaW4gZXJyb3IgbWVzc2FnZXNcbmNvbnN0IHByaW50ID0gcmVxdWlyZSgnLi9wcmludCcpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRQcmVmaXgsXG4gIHJtUHJlZml4LFxuICBnZXRDb2RlYyxcbiAgZ2V0TmFtZSxcbiAgZ2V0TnVtYmVyLFxuICBnZXRDb2RlLFxuICBnZXRDb2RlVmFyaW50LFxuICBnZXRWYXJpbnQsXG4gIHByaW50LFxuICAuLi5jb25zdGFudHNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOYW1lfSBDb2RlY05hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY051bWJlcn0gQ29kZWNOdW1iZXIgKi9cblxuY29uc3QgeyBiYXNlVGFibGUgfSA9IHJlcXVpcmUoJy4vYmFzZS10YWJsZScpXG5cbi8qKlxuICogQHR5cGUge01hcDxDb2RlY051bWJlcixDb2RlY05hbWU+fVxuICovXG5jb25zdCBuYW1lVGFibGUgPSBuZXcgTWFwKClcblxuZm9yIChjb25zdCBlbmNvZGluZ05hbWUgaW4gYmFzZVRhYmxlKSB7XG4gIGNvbnN0IGNvZGUgPSBiYXNlVGFibGVbZW5jb2RpbmdOYW1lXVxuICBuYW1lVGFibGUuc2V0KGNvZGUsIC8qKiBAdHlwZSB7Q29kZWNOYW1lfSAqLyhlbmNvZGluZ05hbWUpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUobmFtZVRhYmxlKVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY05hbWV9IENvZGVjTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLk51bWJlck5hbWVNYXB9IE51bWJlck5hbWVNYXAgKi9cblxuY29uc3QgeyBiYXNlVGFibGUgfSA9IHJlcXVpcmUoJy4vYmFzZS10YWJsZScpXG5cbmNvbnN0IHRhYmxlQnlDb2RlID0gLyoqIEB0eXBlIHtOdW1iZXJOYW1lTWFwfSAqLyh7fSlcblxuZm9yIChjb25zdCBbbmFtZSwgY29kZV0gb2YgT2JqZWN0LmVudHJpZXMoYmFzZVRhYmxlKSkge1xuICBpZiAodGFibGVCeUNvZGVbY29kZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIHRhYmxlQnlDb2RlW2NvZGVdID0gLyoqIEB0eXBlIHtDb2RlY05hbWV9ICoqLyhuYW1lKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gLyoqIEB0eXBlIHtOdW1iZXJOYW1lTWFwfSAqLyhPYmplY3QuZnJlZXplKHRhYmxlQnlDb2RlKSlcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgdWludDhBcnJheVRvU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvdG8tc3RyaW5nJylcbmNvbnN0IHVpbnQ4QXJyYXlGcm9tU3RyaW5nID0gcmVxdWlyZSgndWludDhhcnJheXMvZnJvbS1zdHJpbmcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbnVtYmVyVG9VaW50OEFycmF5LFxuICB1aW50OEFycmF5VG9OdW1iZXIsXG4gIHZhcmludFVpbnQ4QXJyYXlFbmNvZGUsXG4gIHZhcmludEVuY29kZVxufVxuXG5mdW5jdGlvbiB1aW50OEFycmF5VG9OdW1iZXIgKGJ1Zikge1xuICByZXR1cm4gcGFyc2VJbnQodWludDhBcnJheVRvU3RyaW5nKGJ1ZiwgJ2Jhc2UxNicpLCAxNilcbn1cblxuZnVuY3Rpb24gbnVtYmVyVG9VaW50OEFycmF5IChudW0pIHtcbiAgbGV0IGhleFN0cmluZyA9IG51bS50b1N0cmluZygxNilcbiAgaWYgKGhleFN0cmluZy5sZW5ndGggJSAyID09PSAxKSB7XG4gICAgaGV4U3RyaW5nID0gJzAnICsgaGV4U3RyaW5nXG4gIH1cbiAgcmV0dXJuIHVpbnQ4QXJyYXlGcm9tU3RyaW5nKGhleFN0cmluZywgJ2Jhc2UxNicpXG59XG5cbmZ1bmN0aW9uIHZhcmludFVpbnQ4QXJyYXlFbmNvZGUgKGlucHV0KSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odmFyaW50LmVuY29kZSh1aW50OEFycmF5VG9OdW1iZXIoaW5wdXQpKSlcbn1cblxuZnVuY3Rpb24gdmFyaW50RW5jb2RlIChudW0pIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh2YXJpbnQuZW5jb2RlKG51bSkpXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLk5hbWVVaW50OEFycmF5TWFwfSBOYW1lVWludDhBcnJheU1hcCAqL1xuXG5jb25zdCB7IGJhc2VUYWJsZSB9ID0gcmVxdWlyZSgnLi9iYXNlLXRhYmxlJylcbmNvbnN0IHZhcmludEVuY29kZSA9IHJlcXVpcmUoJy4vdXRpbCcpLnZhcmludEVuY29kZVxuXG5jb25zdCB2YXJpbnRUYWJsZSA9IC8qKiBAdHlwZSB7TmFtZVVpbnQ4QXJyYXlNYXB9ICovICh7fSlcblxuZm9yIChjb25zdCBlbmNvZGluZ05hbWUgaW4gYmFzZVRhYmxlKSB7XG4gIGNvbnN0IGNvZGUgPSBiYXNlVGFibGVbZW5jb2RpbmdOYW1lXVxuICB2YXJpbnRUYWJsZVtlbmNvZGluZ05hbWVdID0gdmFyaW50RW5jb2RlKGNvZGUpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZSh2YXJpbnRUYWJsZSlcbiIsIi8vIEB0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2RlY1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihVaW50OEFycmF5KTpzdHJpbmd9IGVuY29kZVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihzdHJpbmcpOlVpbnQ4QXJyYXl9IGRlY29kZVxuICpcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbihzdHJpbmcpOkNvZGVjfSBDb2RlY0ZhY3RvcnlcbiAqL1xuXG5jbGFzcyBCYXNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAqIEBwYXJhbSB7Q29kZWNGYWN0b3J5fSBpbXBsZW1lbnRhdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChuYW1lLCBjb2RlLCBpbXBsZW1lbnRhdGlvbiwgYWxwaGFiZXQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIHRoaXMuY29kZUJ1ZiA9IEJ1ZmZlci5mcm9tKHRoaXMuY29kZSlcbiAgICB0aGlzLmFscGhhYmV0ID0gYWxwaGFiZXRcbiAgICB0aGlzLmVuZ2luZSA9IGltcGxlbWVudGF0aW9uKGFscGhhYmV0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBlbmNvZGUgKGJ1Zikge1xuICAgIHJldHVybiB0aGlzLmVuZ2luZS5lbmNvZGUoYnVmKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBkZWNvZGUgKHN0cmluZykge1xuICAgIGZvciAoY29uc3QgY2hhciBvZiBzdHJpbmcpIHtcbiAgICAgIGlmICh0aGlzLmFscGhhYmV0ICYmIHRoaXMuYWxwaGFiZXQuaW5kZXhPZihjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNoYXJhY3RlciAnJHtjaGFyfScgaW4gJyR7c3RyaW5nfSdgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbmdpbmUuZGVjb2RlKHN0cmluZylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VcbiIsIi8vIEB0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2VYID0gcmVxdWlyZSgnYmFzZS14JylcbmNvbnN0IEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UuanMnKVxuY29uc3QgcmZjNDY0OCA9IHJlcXVpcmUoJy4vcmZjNDY0OCcpXG5jb25zdCB7IGRlY29kZVRleHQsIGVuY29kZVRleHQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbmNvbnN0IGlkZW50aXR5ID0gKCkgPT4ge1xuICByZXR1cm4ge1xuICAgIGVuY29kZTogZGVjb2RlVGV4dCxcbiAgICBkZWNvZGU6IGVuY29kZVRleHRcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2Jhc2UnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeVxuICpcbiAqIG5hbWUsIGNvZGUsIGltcGxlbWVudGF0aW9uLCBhbHBoYWJldFxuICogQHR5cGUge0FycmF5PFtzdHJpbmcsIHN0cmluZywgQ29kZWNGYWN0b3J5LCBzdHJpbmddPn1cbiAqL1xuY29uc3QgY29uc3RhbnRzID0gW1xuICBbJ2lkZW50aXR5JywgJ1xceDAwJywgaWRlbnRpdHksICcnXSxcbiAgWydiYXNlMicsICcwJywgcmZjNDY0OCgxKSwgJzAxJ10sXG4gIFsnYmFzZTgnLCAnNycsIHJmYzQ2NDgoMyksICcwMTIzNDU2NyddLFxuICBbJ2Jhc2UxMCcsICc5JywgYmFzZVgsICcwMTIzNDU2Nzg5J10sXG4gIFsnYmFzZTE2JywgJ2YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OWFiY2RlZiddLFxuICBbJ2Jhc2UxNnVwcGVyJywgJ0YnLCByZmM0NjQ4KDQpLCAnMDEyMzQ1Njc4OUFCQ0RFRiddLFxuICBbJ2Jhc2UzMmhleCcsICd2JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2J10sXG4gIFsnYmFzZTMyaGV4dXBwZXInLCAnVicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVViddLFxuICBbJ2Jhc2UzMmhleHBhZCcsICd0JywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2PSddLFxuICBbJ2Jhc2UzMmhleHBhZHVwcGVyJywgJ1QnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVY9J10sXG4gIFsnYmFzZTMyJywgJ2InLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjcnXSxcbiAgWydiYXNlMzJ1cHBlcicsICdCJywgcmZjNDY0OCg1KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3J10sXG4gIFsnYmFzZTMycGFkJywgJ2MnLCByZmM0NjQ4KDUpLCAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1Njc9J10sXG4gIFsnYmFzZTMycGFkdXBwZXInLCAnQycsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2Nz0nXSxcbiAgWydiYXNlMzJ6JywgJ2gnLCByZmM0NjQ4KDUpLCAneWJuZHJmZzhlamttY3BxeG90MXV3aXN6YTM0NWg3NjknXSxcbiAgWydiYXNlMzYnLCAnaycsIGJhc2VYLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTM2dXBwZXInLCAnSycsIGJhc2VYLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTU4YnRjJywgJ3onLCBiYXNlWCwgJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlNThmbGlja3InLCAnWicsIGJhc2VYLCAnMTIzNDU2Nzg5YWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5ekFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U2NCcsICdtJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXSxcbiAgWydiYXNlNjRwYWQnLCAnTScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSddLFxuICBbJ2Jhc2U2NHVybCcsICd1JywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nXSxcbiAgWydiYXNlNjR1cmxwYWQnLCAnVScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fPSddXG5dXG5cbmNvbnN0IG5hbWVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzBdXSA9IG5ldyBCYXNlKHR1cHBsZVswXSwgdHVwcGxlWzFdLCB0dXBwbGVbMl0sIHR1cHBsZVszXSlcbiAgcmV0dXJuIHByZXZcbn0sIHt9KVxuXG5jb25zdCBjb2RlcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVsxXV0gPSBuYW1lc1t0dXBwbGVbMF1dXG4gIHJldHVybiBwcmV2XG59LCB7fSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWVzLFxuICBjb2Rlc1xufVxuIiwiLy8gQHRzLWNoZWNrXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbbXVsdGliYXNlXShodHRwczovL2dpdGh1Yi5jb20vbXVsdGlmb3JtYXRzL211bHRpYmFzZSkgc3BlY2lmaWNhdGlvbi5cbiAqXG4gKiBAbW9kdWxlIE11bHRpYmFzZVxuICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBjb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGRlY29kZVRleHQsIGFzQnVmZmVyIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL2Jhc2VcIil9IEJhc2UgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYnVmZmVyIHdpdGggdGhlIG11bHRpYmFzZSB2YXJpbnQrY29kZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVPckNvZGUgLSBUaGUgbXVsdGliYXNlIG5hbWUgb3IgY29kZSBudW1iZXIuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiAtIFRoZSBkYXRhIHRvIGJlIHByZWZpeGVkIHdpdGggbXVsdGliYXNlLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIG11bHRpYmFzZSAobmFtZU9yQ29kZSwgYnVmKSB7XG4gIGlmICghYnVmKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBhbiBlbmNvZGVkIGJ1ZmZlcicpXG4gIH1cbiAgY29uc3QgeyBuYW1lLCBjb2RlQnVmIH0gPSBlbmNvZGluZyhuYW1lT3JDb2RlKVxuICB2YWxpZEVuY29kZShuYW1lLCBidWYpXG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKGNvZGVCdWYubGVuZ3RoICsgYnVmLmxlbmd0aClcbiAgYnVmZmVyLnNldChjb2RlQnVmLCAwKVxuICBidWZmZXIuc2V0KGJ1ZiwgY29kZUJ1Zi5sZW5ndGgpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG4vKipcbiAqIEVuY29kZSBkYXRhIHdpdGggdGhlIHNwZWNpZmllZCBiYXNlIGFuZCBhZGQgdGhlIG11bHRpYmFzZSBwcmVmaXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JDb2RlIC0gVGhlIG11bHRpYmFzZSBuYW1lIG9yIGNvZGUgbnVtYmVyLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgLSBUaGUgZGF0YSB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICovXG5mdW5jdGlvbiBlbmNvZGUgKG5hbWVPckNvZGUsIGJ1Zikge1xuICBjb25zdCBlbmMgPSBlbmNvZGluZyhuYW1lT3JDb2RlKVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtlbmMuY29kZUJ1ZiwgQnVmZmVyLmZyb20oZW5jLmVuY29kZShidWYpKV0pXG59XG5cbi8qKlxuICogVGFrZXMgYSBVaW50OEFycmF5IG9yIHN0cmluZyBlbmNvZGVkIHdpdGggbXVsdGliYXNlIGhlYWRlciwgZGVjb2RlcyBpdCBhbmRcbiAqIHJldHVybnMgdGhlIGRlY29kZWQgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gZGF0YVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICovXG5mdW5jdGlvbiBkZWNvZGUgKGRhdGEpIHtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGRhdGEgPSBkZWNvZGVUZXh0KGRhdGEpXG4gIH1cbiAgY29uc3QgcHJlZml4ID0gZGF0YVswXVxuXG4gIC8vIE1ha2UgYWxsIGVuY29kaW5ncyBjYXNlLWluc2Vuc2l0aXZlIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGluY2x1ZGUgdXBwZXIgYW5kIGxvd2VyIGNoYXJzIGluIHRoZSBhbHBoYWJldFxuICBpZiAoWydmJywgJ0YnLCAndicsICdWJywgJ3QnLCAnVCcsICdiJywgJ0InLCAnYycsICdDJywgJ2gnLCAnaycsICdLJ10uaW5jbHVkZXMocHJlZml4KSkge1xuICAgIGRhdGEgPSBkYXRhLnRvTG93ZXJDYXNlKClcbiAgfVxuICBjb25zdCBlbmMgPSBlbmNvZGluZyhkYXRhWzBdKVxuICByZXR1cm4gYXNCdWZmZXIoZW5jLmRlY29kZShkYXRhLnN1YnN0cmluZygxKSkpXG59XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIGRhdGEgbXVsdGliYXNlIGVuY29kZWQ/XG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gZGF0YVxuICogQHJldHVybnMge2ZhbHNlfHN0cmluZ31cbiAqL1xuZnVuY3Rpb24gaXNFbmNvZGVkIChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGRhdGEgPSBkZWNvZGVUZXh0KGRhdGEpXG4gIH1cblxuICAvLyBFbnN1cmUgYnVmT3JTdHJpbmcgaXMgYSBzdHJpbmdcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSAhPT0gJ1tvYmplY3QgU3RyaW5nXScpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgZW5jID0gZW5jb2RpbmcoZGF0YVswXSlcbiAgICByZXR1cm4gZW5jLm5hbWVcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBlbmNvZGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gdmFsaWRFbmNvZGUgKG5hbWUsIGJ1Zikge1xuICBjb25zdCBlbmMgPSBlbmNvZGluZyhuYW1lKVxuICBlbmMuZGVjb2RlKGRlY29kZVRleHQoYnVmKSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGVuY29kaW5nIGJ5IG5hbWUgb3IgY29kZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9yQ29kZVxuICogQHJldHVybnMge0Jhc2V9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBlbmNvZGluZyAobmFtZU9yQ29kZSkge1xuICBpZiAoY29uc3RhbnRzLm5hbWVzW25hbWVPckNvZGVdKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5uYW1lc1tuYW1lT3JDb2RlXVxuICB9IGVsc2UgaWYgKGNvbnN0YW50cy5jb2Rlc1tuYW1lT3JDb2RlXSkge1xuICAgIHJldHVybiBjb25zdGFudHMuY29kZXNbbmFtZU9yQ29kZV1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGVuY29kaW5nOiAke25hbWVPckNvZGV9YClcbiAgfVxufVxuXG4vKipcbiAqIEdldCBlbmNvZGluZyBmcm9tIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7QmFzZX1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIGVuY29kaW5nRnJvbURhdGEgKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgZGF0YSA9IGRlY29kZVRleHQoZGF0YSlcbiAgfVxuXG4gIHJldHVybiBlbmNvZGluZyhkYXRhWzBdKVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBtdWx0aWJhc2VcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlXG5leHBvcnRzLmRlY29kZSA9IGRlY29kZVxuZXhwb3J0cy5pc0VuY29kZWQgPSBpc0VuY29kZWRcbmV4cG9ydHMuZW5jb2RpbmcgPSBlbmNvZGluZ1xuZXhwb3J0cy5lbmNvZGluZ0Zyb21EYXRhID0gZW5jb2RpbmdGcm9tRGF0YVxuZXhwb3J0cy5uYW1lcyA9IE9iamVjdC5mcmVlemUoY29uc3RhbnRzLm5hbWVzKVxuZXhwb3J0cy5jb2RlcyA9IE9iamVjdC5mcmVlemUoY29uc3RhbnRzLmNvZGVzKVxuIiwiLy8gQHRzLWNoZWNrXG4ndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2Jhc2UnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZGVjb2RlID0gKHN0cmluZywgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIC8vIEJ1aWxkIHRoZSBjaGFyYWN0ZXIgbG9va3VwIHRhYmxlOlxuICBjb25zdCBjb2RlcyA9IHt9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWxwaGFiZXQubGVuZ3RoOyArK2kpIHtcbiAgICBjb2Rlc1thbHBoYWJldFtpXV0gPSBpXG4gIH1cblxuICAvLyBDb3VudCB0aGUgcGFkZGluZyBieXRlczpcbiAgbGV0IGVuZCA9IHN0cmluZy5sZW5ndGhcbiAgd2hpbGUgKHN0cmluZ1tlbmQgLSAxXSA9PT0gJz0nKSB7XG4gICAgLS1lbmRcbiAgfVxuXG4gIC8vIEFsbG9jYXRlIHRoZSBvdXRwdXQ6XG4gIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KChlbmQgKiBiaXRzUGVyQ2hhciAvIDgpIHwgMClcblxuICAvLyBQYXJzZSB0aGUgZGF0YTpcbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGxldCB3cml0dGVuID0gMCAvLyBOZXh0IGJ5dGUgdG8gd3JpdGVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmQ7ICsraSkge1xuICAgIC8vIFJlYWQgb25lIGNoYXJhY3RlciBmcm9tIHRoZSBzdHJpbmc6XG4gICAgY29uc3QgdmFsdWUgPSBjb2Rlc1tzdHJpbmdbaV1dXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignSW52YWxpZCBjaGFyYWN0ZXIgJyArIHN0cmluZ1tpXSlcbiAgICB9XG5cbiAgICAvLyBBcHBlbmQgdGhlIGJpdHMgdG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IGJpdHNQZXJDaGFyKSB8IHZhbHVlXG4gICAgYml0cyArPSBiaXRzUGVyQ2hhclxuXG4gICAgLy8gV3JpdGUgb3V0IHNvbWUgYml0cyBpZiB0aGUgYnVmZmVyIGhhcyBhIGJ5dGUncyB3b3J0aDpcbiAgICBpZiAoYml0cyA+PSA4KSB7XG4gICAgICBiaXRzIC09IDhcbiAgICAgIG91dFt3cml0dGVuKytdID0gMHhmZiAmIChidWZmZXIgPj4gYml0cylcbiAgICB9XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB3ZSBoYXZlIHJlY2VpdmVkIGp1c3QgZW5vdWdoIGJpdHM6XG4gIGlmIChiaXRzID49IGJpdHNQZXJDaGFyIHx8IDB4ZmYgJiAoYnVmZmVyIDw8ICg4IC0gYml0cykpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBkYXRhJylcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBlbmNvZGUgPSAoZGF0YSwgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIGNvbnN0IHBhZCA9IGFscGhhYmV0W2FscGhhYmV0Lmxlbmd0aCAtIDFdID09PSAnPSdcbiAgY29uc3QgbWFzayA9ICgxIDw8IGJpdHNQZXJDaGFyKSAtIDFcbiAgbGV0IG91dCA9ICcnXG5cbiAgbGV0IGJpdHMgPSAwIC8vIE51bWJlciBvZiBiaXRzIGN1cnJlbnRseSBpbiB0aGUgYnVmZmVyXG4gIGxldCBidWZmZXIgPSAwIC8vIEJpdHMgd2FpdGluZyB0byBiZSB3cml0dGVuIG91dCwgTVNCIGZpcnN0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIC8vIFNsdXJwIGRhdGEgaW50byB0aGUgYnVmZmVyOlxuICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgOCkgfCBkYXRhW2ldXG4gICAgYml0cyArPSA4XG5cbiAgICAvLyBXcml0ZSBvdXQgYXMgbXVjaCBhcyB3ZSBjYW46XG4gICAgd2hpbGUgKGJpdHMgPiBiaXRzUGVyQ2hhcikge1xuICAgICAgYml0cyAtPSBiaXRzUGVyQ2hhclxuICAgICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiAoYnVmZmVyID4+IGJpdHMpXVxuICAgIH1cbiAgfVxuXG4gIC8vIFBhcnRpYWwgY2hhcmFjdGVyOlxuICBpZiAoYml0cykge1xuICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA8PCAoYml0c1BlckNoYXIgLSBiaXRzKSldXG4gIH1cblxuICAvLyBBZGQgcGFkZGluZyBjaGFyYWN0ZXJzIHVudGlsIHdlIGhpdCBhIGJ5dGUgYm91bmRhcnk6XG4gIGlmIChwYWQpIHtcbiAgICB3aGlsZSAoKG91dC5sZW5ndGggKiBiaXRzUGVyQ2hhcikgJiA3KSB7XG4gICAgICBvdXQgKz0gJz0nXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge0NvZGVjRmFjdG9yeX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSAoYml0c1BlckNoYXIpID0+IChhbHBoYWJldCkgPT4ge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGRlY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9XG4gIH1cbn1cbiIsIi8vIEB0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgeyBUZXh0RW5jb2RlciwgVGV4dERlY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbi8qKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ9IGJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBkZWNvZGVUZXh0ID0gKGJ5dGVzKSA9PiB0ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpXG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVUZXh0ID0gKHRleHQpID0+IHRleHRFbmNvZGVyLmVuY29kZSh0ZXh0KVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fSBieXRlc1xuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuY29uc3QgYXNCdWZmZXIgPSAoeyBidWZmZXIsIGJ5dGVMZW5ndGgsIGJ5dGVPZmZzZXQgfSkgPT5cbiAgQnVmZmVyLmZyb20oYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVjb2RlVGV4dCwgZW5jb2RlVGV4dCwgYXNCdWZmZXIgfVxuIiwiLyogZXNsaW50IHF1b3RlLXByb3BzOiBvZmYgKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBuYW1lcyA9IE9iamVjdC5mcmVlemUoe1xuICAnaWRlbnRpdHknOiAweDAwLFxuICAnc2hhMSc6IDB4MTEsXG4gICdzaGEyLTI1Nic6IDB4MTIsXG4gICdzaGEyLTUxMic6IDB4MTMsXG4gICdzaGEzLTUxMic6IDB4MTQsXG4gICdzaGEzLTM4NCc6IDB4MTUsXG4gICdzaGEzLTI1Nic6IDB4MTYsXG4gICdzaGEzLTIyNCc6IDB4MTcsXG4gICdzaGFrZS0xMjgnOiAweDE4LFxuICAnc2hha2UtMjU2JzogMHgxOSxcbiAgJ2tlY2Nhay0yMjQnOiAweDFhLFxuICAna2VjY2FrLTI1Nic6IDB4MWIsXG4gICdrZWNjYWstMzg0JzogMHgxYyxcbiAgJ2tlY2Nhay01MTInOiAweDFkLFxuICAnYmxha2UzJzogMHgxZSxcbiAgJ211cm11cjMtMTI4JzogMHgyMixcbiAgJ211cm11cjMtMzInOiAweDIzLFxuICAnZGJsLXNoYTItMjU2JzogMHg1NixcbiAgJ21kNCc6IDB4ZDQsXG4gICdtZDUnOiAweGQ1LFxuICAnYm10JzogMHhkNixcbiAgJ3NoYTItMjU2LXRydW5jMjU0LXBhZGRlZCc6IDB4MTAxMixcbiAgJ3JpcGVtZC0xMjgnOiAweDEwNTIsXG4gICdyaXBlbWQtMTYwJzogMHgxMDUzLFxuICAncmlwZW1kLTI1Nic6IDB4MTA1NCxcbiAgJ3JpcGVtZC0zMjAnOiAweDEwNTUsXG4gICd4MTEnOiAweDExMDAsXG4gICdzbTMtMjU2JzogMHg1MzRkLFxuICAnYmxha2UyYi04JzogMHhiMjAxLFxuICAnYmxha2UyYi0xNic6IDB4YjIwMixcbiAgJ2JsYWtlMmItMjQnOiAweGIyMDMsXG4gICdibGFrZTJiLTMyJzogMHhiMjA0LFxuICAnYmxha2UyYi00MCc6IDB4YjIwNSxcbiAgJ2JsYWtlMmItNDgnOiAweGIyMDYsXG4gICdibGFrZTJiLTU2JzogMHhiMjA3LFxuICAnYmxha2UyYi02NCc6IDB4YjIwOCxcbiAgJ2JsYWtlMmItNzInOiAweGIyMDksXG4gICdibGFrZTJiLTgwJzogMHhiMjBhLFxuICAnYmxha2UyYi04OCc6IDB4YjIwYixcbiAgJ2JsYWtlMmItOTYnOiAweGIyMGMsXG4gICdibGFrZTJiLTEwNCc6IDB4YjIwZCxcbiAgJ2JsYWtlMmItMTEyJzogMHhiMjBlLFxuICAnYmxha2UyYi0xMjAnOiAweGIyMGYsXG4gICdibGFrZTJiLTEyOCc6IDB4YjIxMCxcbiAgJ2JsYWtlMmItMTM2JzogMHhiMjExLFxuICAnYmxha2UyYi0xNDQnOiAweGIyMTIsXG4gICdibGFrZTJiLTE1Mic6IDB4YjIxMyxcbiAgJ2JsYWtlMmItMTYwJzogMHhiMjE0LFxuICAnYmxha2UyYi0xNjgnOiAweGIyMTUsXG4gICdibGFrZTJiLTE3Nic6IDB4YjIxNixcbiAgJ2JsYWtlMmItMTg0JzogMHhiMjE3LFxuICAnYmxha2UyYi0xOTInOiAweGIyMTgsXG4gICdibGFrZTJiLTIwMCc6IDB4YjIxOSxcbiAgJ2JsYWtlMmItMjA4JzogMHhiMjFhLFxuICAnYmxha2UyYi0yMTYnOiAweGIyMWIsXG4gICdibGFrZTJiLTIyNCc6IDB4YjIxYyxcbiAgJ2JsYWtlMmItMjMyJzogMHhiMjFkLFxuICAnYmxha2UyYi0yNDAnOiAweGIyMWUsXG4gICdibGFrZTJiLTI0OCc6IDB4YjIxZixcbiAgJ2JsYWtlMmItMjU2JzogMHhiMjIwLFxuICAnYmxha2UyYi0yNjQnOiAweGIyMjEsXG4gICdibGFrZTJiLTI3Mic6IDB4YjIyMixcbiAgJ2JsYWtlMmItMjgwJzogMHhiMjIzLFxuICAnYmxha2UyYi0yODgnOiAweGIyMjQsXG4gICdibGFrZTJiLTI5Nic6IDB4YjIyNSxcbiAgJ2JsYWtlMmItMzA0JzogMHhiMjI2LFxuICAnYmxha2UyYi0zMTInOiAweGIyMjcsXG4gICdibGFrZTJiLTMyMCc6IDB4YjIyOCxcbiAgJ2JsYWtlMmItMzI4JzogMHhiMjI5LFxuICAnYmxha2UyYi0zMzYnOiAweGIyMmEsXG4gICdibGFrZTJiLTM0NCc6IDB4YjIyYixcbiAgJ2JsYWtlMmItMzUyJzogMHhiMjJjLFxuICAnYmxha2UyYi0zNjAnOiAweGIyMmQsXG4gICdibGFrZTJiLTM2OCc6IDB4YjIyZSxcbiAgJ2JsYWtlMmItMzc2JzogMHhiMjJmLFxuICAnYmxha2UyYi0zODQnOiAweGIyMzAsXG4gICdibGFrZTJiLTM5Mic6IDB4YjIzMSxcbiAgJ2JsYWtlMmItNDAwJzogMHhiMjMyLFxuICAnYmxha2UyYi00MDgnOiAweGIyMzMsXG4gICdibGFrZTJiLTQxNic6IDB4YjIzNCxcbiAgJ2JsYWtlMmItNDI0JzogMHhiMjM1LFxuICAnYmxha2UyYi00MzInOiAweGIyMzYsXG4gICdibGFrZTJiLTQ0MCc6IDB4YjIzNyxcbiAgJ2JsYWtlMmItNDQ4JzogMHhiMjM4LFxuICAnYmxha2UyYi00NTYnOiAweGIyMzksXG4gICdibGFrZTJiLTQ2NCc6IDB4YjIzYSxcbiAgJ2JsYWtlMmItNDcyJzogMHhiMjNiLFxuICAnYmxha2UyYi00ODAnOiAweGIyM2MsXG4gICdibGFrZTJiLTQ4OCc6IDB4YjIzZCxcbiAgJ2JsYWtlMmItNDk2JzogMHhiMjNlLFxuICAnYmxha2UyYi01MDQnOiAweGIyM2YsXG4gICdibGFrZTJiLTUxMic6IDB4YjI0MCxcbiAgJ2JsYWtlMnMtOCc6IDB4YjI0MSxcbiAgJ2JsYWtlMnMtMTYnOiAweGIyNDIsXG4gICdibGFrZTJzLTI0JzogMHhiMjQzLFxuICAnYmxha2Uycy0zMic6IDB4YjI0NCxcbiAgJ2JsYWtlMnMtNDAnOiAweGIyNDUsXG4gICdibGFrZTJzLTQ4JzogMHhiMjQ2LFxuICAnYmxha2Uycy01Nic6IDB4YjI0NyxcbiAgJ2JsYWtlMnMtNjQnOiAweGIyNDgsXG4gICdibGFrZTJzLTcyJzogMHhiMjQ5LFxuICAnYmxha2Uycy04MCc6IDB4YjI0YSxcbiAgJ2JsYWtlMnMtODgnOiAweGIyNGIsXG4gICdibGFrZTJzLTk2JzogMHhiMjRjLFxuICAnYmxha2Uycy0xMDQnOiAweGIyNGQsXG4gICdibGFrZTJzLTExMic6IDB4YjI0ZSxcbiAgJ2JsYWtlMnMtMTIwJzogMHhiMjRmLFxuICAnYmxha2Uycy0xMjgnOiAweGIyNTAsXG4gICdibGFrZTJzLTEzNic6IDB4YjI1MSxcbiAgJ2JsYWtlMnMtMTQ0JzogMHhiMjUyLFxuICAnYmxha2Uycy0xNTInOiAweGIyNTMsXG4gICdibGFrZTJzLTE2MCc6IDB4YjI1NCxcbiAgJ2JsYWtlMnMtMTY4JzogMHhiMjU1LFxuICAnYmxha2Uycy0xNzYnOiAweGIyNTYsXG4gICdibGFrZTJzLTE4NCc6IDB4YjI1NyxcbiAgJ2JsYWtlMnMtMTkyJzogMHhiMjU4LFxuICAnYmxha2Uycy0yMDAnOiAweGIyNTksXG4gICdibGFrZTJzLTIwOCc6IDB4YjI1YSxcbiAgJ2JsYWtlMnMtMjE2JzogMHhiMjViLFxuICAnYmxha2Uycy0yMjQnOiAweGIyNWMsXG4gICdibGFrZTJzLTIzMic6IDB4YjI1ZCxcbiAgJ2JsYWtlMnMtMjQwJzogMHhiMjVlLFxuICAnYmxha2Uycy0yNDgnOiAweGIyNWYsXG4gICdibGFrZTJzLTI1Nic6IDB4YjI2MCxcbiAgJ3NrZWluMjU2LTgnOiAweGIzMDEsXG4gICdza2VpbjI1Ni0xNic6IDB4YjMwMixcbiAgJ3NrZWluMjU2LTI0JzogMHhiMzAzLFxuICAnc2tlaW4yNTYtMzInOiAweGIzMDQsXG4gICdza2VpbjI1Ni00MCc6IDB4YjMwNSxcbiAgJ3NrZWluMjU2LTQ4JzogMHhiMzA2LFxuICAnc2tlaW4yNTYtNTYnOiAweGIzMDcsXG4gICdza2VpbjI1Ni02NCc6IDB4YjMwOCxcbiAgJ3NrZWluMjU2LTcyJzogMHhiMzA5LFxuICAnc2tlaW4yNTYtODAnOiAweGIzMGEsXG4gICdza2VpbjI1Ni04OCc6IDB4YjMwYixcbiAgJ3NrZWluMjU2LTk2JzogMHhiMzBjLFxuICAnc2tlaW4yNTYtMTA0JzogMHhiMzBkLFxuICAnc2tlaW4yNTYtMTEyJzogMHhiMzBlLFxuICAnc2tlaW4yNTYtMTIwJzogMHhiMzBmLFxuICAnc2tlaW4yNTYtMTI4JzogMHhiMzEwLFxuICAnc2tlaW4yNTYtMTM2JzogMHhiMzExLFxuICAnc2tlaW4yNTYtMTQ0JzogMHhiMzEyLFxuICAnc2tlaW4yNTYtMTUyJzogMHhiMzEzLFxuICAnc2tlaW4yNTYtMTYwJzogMHhiMzE0LFxuICAnc2tlaW4yNTYtMTY4JzogMHhiMzE1LFxuICAnc2tlaW4yNTYtMTc2JzogMHhiMzE2LFxuICAnc2tlaW4yNTYtMTg0JzogMHhiMzE3LFxuICAnc2tlaW4yNTYtMTkyJzogMHhiMzE4LFxuICAnc2tlaW4yNTYtMjAwJzogMHhiMzE5LFxuICAnc2tlaW4yNTYtMjA4JzogMHhiMzFhLFxuICAnc2tlaW4yNTYtMjE2JzogMHhiMzFiLFxuICAnc2tlaW4yNTYtMjI0JzogMHhiMzFjLFxuICAnc2tlaW4yNTYtMjMyJzogMHhiMzFkLFxuICAnc2tlaW4yNTYtMjQwJzogMHhiMzFlLFxuICAnc2tlaW4yNTYtMjQ4JzogMHhiMzFmLFxuICAnc2tlaW4yNTYtMjU2JzogMHhiMzIwLFxuICAnc2tlaW41MTItOCc6IDB4YjMyMSxcbiAgJ3NrZWluNTEyLTE2JzogMHhiMzIyLFxuICAnc2tlaW41MTItMjQnOiAweGIzMjMsXG4gICdza2VpbjUxMi0zMic6IDB4YjMyNCxcbiAgJ3NrZWluNTEyLTQwJzogMHhiMzI1LFxuICAnc2tlaW41MTItNDgnOiAweGIzMjYsXG4gICdza2VpbjUxMi01Nic6IDB4YjMyNyxcbiAgJ3NrZWluNTEyLTY0JzogMHhiMzI4LFxuICAnc2tlaW41MTItNzInOiAweGIzMjksXG4gICdza2VpbjUxMi04MCc6IDB4YjMyYSxcbiAgJ3NrZWluNTEyLTg4JzogMHhiMzJiLFxuICAnc2tlaW41MTItOTYnOiAweGIzMmMsXG4gICdza2VpbjUxMi0xMDQnOiAweGIzMmQsXG4gICdza2VpbjUxMi0xMTInOiAweGIzMmUsXG4gICdza2VpbjUxMi0xMjAnOiAweGIzMmYsXG4gICdza2VpbjUxMi0xMjgnOiAweGIzMzAsXG4gICdza2VpbjUxMi0xMzYnOiAweGIzMzEsXG4gICdza2VpbjUxMi0xNDQnOiAweGIzMzIsXG4gICdza2VpbjUxMi0xNTInOiAweGIzMzMsXG4gICdza2VpbjUxMi0xNjAnOiAweGIzMzQsXG4gICdza2VpbjUxMi0xNjgnOiAweGIzMzUsXG4gICdza2VpbjUxMi0xNzYnOiAweGIzMzYsXG4gICdza2VpbjUxMi0xODQnOiAweGIzMzcsXG4gICdza2VpbjUxMi0xOTInOiAweGIzMzgsXG4gICdza2VpbjUxMi0yMDAnOiAweGIzMzksXG4gICdza2VpbjUxMi0yMDgnOiAweGIzM2EsXG4gICdza2VpbjUxMi0yMTYnOiAweGIzM2IsXG4gICdza2VpbjUxMi0yMjQnOiAweGIzM2MsXG4gICdza2VpbjUxMi0yMzInOiAweGIzM2QsXG4gICdza2VpbjUxMi0yNDAnOiAweGIzM2UsXG4gICdza2VpbjUxMi0yNDgnOiAweGIzM2YsXG4gICdza2VpbjUxMi0yNTYnOiAweGIzNDAsXG4gICdza2VpbjUxMi0yNjQnOiAweGIzNDEsXG4gICdza2VpbjUxMi0yNzInOiAweGIzNDIsXG4gICdza2VpbjUxMi0yODAnOiAweGIzNDMsXG4gICdza2VpbjUxMi0yODgnOiAweGIzNDQsXG4gICdza2VpbjUxMi0yOTYnOiAweGIzNDUsXG4gICdza2VpbjUxMi0zMDQnOiAweGIzNDYsXG4gICdza2VpbjUxMi0zMTInOiAweGIzNDcsXG4gICdza2VpbjUxMi0zMjAnOiAweGIzNDgsXG4gICdza2VpbjUxMi0zMjgnOiAweGIzNDksXG4gICdza2VpbjUxMi0zMzYnOiAweGIzNGEsXG4gICdza2VpbjUxMi0zNDQnOiAweGIzNGIsXG4gICdza2VpbjUxMi0zNTInOiAweGIzNGMsXG4gICdza2VpbjUxMi0zNjAnOiAweGIzNGQsXG4gICdza2VpbjUxMi0zNjgnOiAweGIzNGUsXG4gICdza2VpbjUxMi0zNzYnOiAweGIzNGYsXG4gICdza2VpbjUxMi0zODQnOiAweGIzNTAsXG4gICdza2VpbjUxMi0zOTInOiAweGIzNTEsXG4gICdza2VpbjUxMi00MDAnOiAweGIzNTIsXG4gICdza2VpbjUxMi00MDgnOiAweGIzNTMsXG4gICdza2VpbjUxMi00MTYnOiAweGIzNTQsXG4gICdza2VpbjUxMi00MjQnOiAweGIzNTUsXG4gICdza2VpbjUxMi00MzInOiAweGIzNTYsXG4gICdza2VpbjUxMi00NDAnOiAweGIzNTcsXG4gICdza2VpbjUxMi00NDgnOiAweGIzNTgsXG4gICdza2VpbjUxMi00NTYnOiAweGIzNTksXG4gICdza2VpbjUxMi00NjQnOiAweGIzNWEsXG4gICdza2VpbjUxMi00NzInOiAweGIzNWIsXG4gICdza2VpbjUxMi00ODAnOiAweGIzNWMsXG4gICdza2VpbjUxMi00ODgnOiAweGIzNWQsXG4gICdza2VpbjUxMi00OTYnOiAweGIzNWUsXG4gICdza2VpbjUxMi01MDQnOiAweGIzNWYsXG4gICdza2VpbjUxMi01MTInOiAweGIzNjAsXG4gICdza2VpbjEwMjQtOCc6IDB4YjM2MSxcbiAgJ3NrZWluMTAyNC0xNic6IDB4YjM2MixcbiAgJ3NrZWluMTAyNC0yNCc6IDB4YjM2MyxcbiAgJ3NrZWluMTAyNC0zMic6IDB4YjM2NCxcbiAgJ3NrZWluMTAyNC00MCc6IDB4YjM2NSxcbiAgJ3NrZWluMTAyNC00OCc6IDB4YjM2NixcbiAgJ3NrZWluMTAyNC01Nic6IDB4YjM2NyxcbiAgJ3NrZWluMTAyNC02NCc6IDB4YjM2OCxcbiAgJ3NrZWluMTAyNC03Mic6IDB4YjM2OSxcbiAgJ3NrZWluMTAyNC04MCc6IDB4YjM2YSxcbiAgJ3NrZWluMTAyNC04OCc6IDB4YjM2YixcbiAgJ3NrZWluMTAyNC05Nic6IDB4YjM2YyxcbiAgJ3NrZWluMTAyNC0xMDQnOiAweGIzNmQsXG4gICdza2VpbjEwMjQtMTEyJzogMHhiMzZlLFxuICAnc2tlaW4xMDI0LTEyMCc6IDB4YjM2ZixcbiAgJ3NrZWluMTAyNC0xMjgnOiAweGIzNzAsXG4gICdza2VpbjEwMjQtMTM2JzogMHhiMzcxLFxuICAnc2tlaW4xMDI0LTE0NCc6IDB4YjM3MixcbiAgJ3NrZWluMTAyNC0xNTInOiAweGIzNzMsXG4gICdza2VpbjEwMjQtMTYwJzogMHhiMzc0LFxuICAnc2tlaW4xMDI0LTE2OCc6IDB4YjM3NSxcbiAgJ3NrZWluMTAyNC0xNzYnOiAweGIzNzYsXG4gICdza2VpbjEwMjQtMTg0JzogMHhiMzc3LFxuICAnc2tlaW4xMDI0LTE5Mic6IDB4YjM3OCxcbiAgJ3NrZWluMTAyNC0yMDAnOiAweGIzNzksXG4gICdza2VpbjEwMjQtMjA4JzogMHhiMzdhLFxuICAnc2tlaW4xMDI0LTIxNic6IDB4YjM3YixcbiAgJ3NrZWluMTAyNC0yMjQnOiAweGIzN2MsXG4gICdza2VpbjEwMjQtMjMyJzogMHhiMzdkLFxuICAnc2tlaW4xMDI0LTI0MCc6IDB4YjM3ZSxcbiAgJ3NrZWluMTAyNC0yNDgnOiAweGIzN2YsXG4gICdza2VpbjEwMjQtMjU2JzogMHhiMzgwLFxuICAnc2tlaW4xMDI0LTI2NCc6IDB4YjM4MSxcbiAgJ3NrZWluMTAyNC0yNzInOiAweGIzODIsXG4gICdza2VpbjEwMjQtMjgwJzogMHhiMzgzLFxuICAnc2tlaW4xMDI0LTI4OCc6IDB4YjM4NCxcbiAgJ3NrZWluMTAyNC0yOTYnOiAweGIzODUsXG4gICdza2VpbjEwMjQtMzA0JzogMHhiMzg2LFxuICAnc2tlaW4xMDI0LTMxMic6IDB4YjM4NyxcbiAgJ3NrZWluMTAyNC0zMjAnOiAweGIzODgsXG4gICdza2VpbjEwMjQtMzI4JzogMHhiMzg5LFxuICAnc2tlaW4xMDI0LTMzNic6IDB4YjM4YSxcbiAgJ3NrZWluMTAyNC0zNDQnOiAweGIzOGIsXG4gICdza2VpbjEwMjQtMzUyJzogMHhiMzhjLFxuICAnc2tlaW4xMDI0LTM2MCc6IDB4YjM4ZCxcbiAgJ3NrZWluMTAyNC0zNjgnOiAweGIzOGUsXG4gICdza2VpbjEwMjQtMzc2JzogMHhiMzhmLFxuICAnc2tlaW4xMDI0LTM4NCc6IDB4YjM5MCxcbiAgJ3NrZWluMTAyNC0zOTInOiAweGIzOTEsXG4gICdza2VpbjEwMjQtNDAwJzogMHhiMzkyLFxuICAnc2tlaW4xMDI0LTQwOCc6IDB4YjM5MyxcbiAgJ3NrZWluMTAyNC00MTYnOiAweGIzOTQsXG4gICdza2VpbjEwMjQtNDI0JzogMHhiMzk1LFxuICAnc2tlaW4xMDI0LTQzMic6IDB4YjM5NixcbiAgJ3NrZWluMTAyNC00NDAnOiAweGIzOTcsXG4gICdza2VpbjEwMjQtNDQ4JzogMHhiMzk4LFxuICAnc2tlaW4xMDI0LTQ1Nic6IDB4YjM5OSxcbiAgJ3NrZWluMTAyNC00NjQnOiAweGIzOWEsXG4gICdza2VpbjEwMjQtNDcyJzogMHhiMzliLFxuICAnc2tlaW4xMDI0LTQ4MCc6IDB4YjM5YyxcbiAgJ3NrZWluMTAyNC00ODgnOiAweGIzOWQsXG4gICdza2VpbjEwMjQtNDk2JzogMHhiMzllLFxuICAnc2tlaW4xMDI0LTUwNCc6IDB4YjM5ZixcbiAgJ3NrZWluMTAyNC01MTInOiAweGIzYTAsXG4gICdza2VpbjEwMjQtNTIwJzogMHhiM2ExLFxuICAnc2tlaW4xMDI0LTUyOCc6IDB4YjNhMixcbiAgJ3NrZWluMTAyNC01MzYnOiAweGIzYTMsXG4gICdza2VpbjEwMjQtNTQ0JzogMHhiM2E0LFxuICAnc2tlaW4xMDI0LTU1Mic6IDB4YjNhNSxcbiAgJ3NrZWluMTAyNC01NjAnOiAweGIzYTYsXG4gICdza2VpbjEwMjQtNTY4JzogMHhiM2E3LFxuICAnc2tlaW4xMDI0LTU3Nic6IDB4YjNhOCxcbiAgJ3NrZWluMTAyNC01ODQnOiAweGIzYTksXG4gICdza2VpbjEwMjQtNTkyJzogMHhiM2FhLFxuICAnc2tlaW4xMDI0LTYwMCc6IDB4YjNhYixcbiAgJ3NrZWluMTAyNC02MDgnOiAweGIzYWMsXG4gICdza2VpbjEwMjQtNjE2JzogMHhiM2FkLFxuICAnc2tlaW4xMDI0LTYyNCc6IDB4YjNhZSxcbiAgJ3NrZWluMTAyNC02MzInOiAweGIzYWYsXG4gICdza2VpbjEwMjQtNjQwJzogMHhiM2IwLFxuICAnc2tlaW4xMDI0LTY0OCc6IDB4YjNiMSxcbiAgJ3NrZWluMTAyNC02NTYnOiAweGIzYjIsXG4gICdza2VpbjEwMjQtNjY0JzogMHhiM2IzLFxuICAnc2tlaW4xMDI0LTY3Mic6IDB4YjNiNCxcbiAgJ3NrZWluMTAyNC02ODAnOiAweGIzYjUsXG4gICdza2VpbjEwMjQtNjg4JzogMHhiM2I2LFxuICAnc2tlaW4xMDI0LTY5Nic6IDB4YjNiNyxcbiAgJ3NrZWluMTAyNC03MDQnOiAweGIzYjgsXG4gICdza2VpbjEwMjQtNzEyJzogMHhiM2I5LFxuICAnc2tlaW4xMDI0LTcyMCc6IDB4YjNiYSxcbiAgJ3NrZWluMTAyNC03MjgnOiAweGIzYmIsXG4gICdza2VpbjEwMjQtNzM2JzogMHhiM2JjLFxuICAnc2tlaW4xMDI0LTc0NCc6IDB4YjNiZCxcbiAgJ3NrZWluMTAyNC03NTInOiAweGIzYmUsXG4gICdza2VpbjEwMjQtNzYwJzogMHhiM2JmLFxuICAnc2tlaW4xMDI0LTc2OCc6IDB4YjNjMCxcbiAgJ3NrZWluMTAyNC03NzYnOiAweGIzYzEsXG4gICdza2VpbjEwMjQtNzg0JzogMHhiM2MyLFxuICAnc2tlaW4xMDI0LTc5Mic6IDB4YjNjMyxcbiAgJ3NrZWluMTAyNC04MDAnOiAweGIzYzQsXG4gICdza2VpbjEwMjQtODA4JzogMHhiM2M1LFxuICAnc2tlaW4xMDI0LTgxNic6IDB4YjNjNixcbiAgJ3NrZWluMTAyNC04MjQnOiAweGIzYzcsXG4gICdza2VpbjEwMjQtODMyJzogMHhiM2M4LFxuICAnc2tlaW4xMDI0LTg0MCc6IDB4YjNjOSxcbiAgJ3NrZWluMTAyNC04NDgnOiAweGIzY2EsXG4gICdza2VpbjEwMjQtODU2JzogMHhiM2NiLFxuICAnc2tlaW4xMDI0LTg2NCc6IDB4YjNjYyxcbiAgJ3NrZWluMTAyNC04NzInOiAweGIzY2QsXG4gICdza2VpbjEwMjQtODgwJzogMHhiM2NlLFxuICAnc2tlaW4xMDI0LTg4OCc6IDB4YjNjZixcbiAgJ3NrZWluMTAyNC04OTYnOiAweGIzZDAsXG4gICdza2VpbjEwMjQtOTA0JzogMHhiM2QxLFxuICAnc2tlaW4xMDI0LTkxMic6IDB4YjNkMixcbiAgJ3NrZWluMTAyNC05MjAnOiAweGIzZDMsXG4gICdza2VpbjEwMjQtOTI4JzogMHhiM2Q0LFxuICAnc2tlaW4xMDI0LTkzNic6IDB4YjNkNSxcbiAgJ3NrZWluMTAyNC05NDQnOiAweGIzZDYsXG4gICdza2VpbjEwMjQtOTUyJzogMHhiM2Q3LFxuICAnc2tlaW4xMDI0LTk2MCc6IDB4YjNkOCxcbiAgJ3NrZWluMTAyNC05NjgnOiAweGIzZDksXG4gICdza2VpbjEwMjQtOTc2JzogMHhiM2RhLFxuICAnc2tlaW4xMDI0LTk4NCc6IDB4YjNkYixcbiAgJ3NrZWluMTAyNC05OTInOiAweGIzZGMsXG4gICdza2VpbjEwMjQtMTAwMCc6IDB4YjNkZCxcbiAgJ3NrZWluMTAyNC0xMDA4JzogMHhiM2RlLFxuICAnc2tlaW4xMDI0LTEwMTYnOiAweGIzZGYsXG4gICdza2VpbjEwMjQtMTAyNCc6IDB4YjNlMCxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEnOiAweGI0MDEsXG4gICdwb3NlaWRvbi1ibHMxMl8zODEtYTItZmMxLXNjJzogMHhiNDAyXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbmFtZXMgfVxuIiwiLy8gQHRzLWNoZWNrXG4vKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cbi8qKlxuICogTXVsdGloYXNoIGltcGxlbWVudGF0aW9uIGluIEphdmFTY3JpcHQuXG4gKlxuICogQG1vZHVsZSBtdWx0aWhhc2hcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgbXVsdGliYXNlID0gcmVxdWlyZSgnbXVsdGliYXNlJylcbmNvbnN0IHZhcmludCA9IHJlcXVpcmUoJ3ZhcmludCcpXG5jb25zdCB7IG5hbWVzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IFRleHREZWNvZGVyIH0gPSByZXF1aXJlKCd3ZWItZW5jb2RpbmcnKVxuXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG5jb25zdCBjb2RlcyA9IHt9XG5cbmZvciAoY29uc3Qga2V5IGluIG5hbWVzKSB7XG4gIGNvZGVzW25hbWVzW2tleV1dID0ga2V5XG59XG5leHBvcnRzLm5hbWVzID0gbmFtZXNcbmV4cG9ydHMuY29kZXMgPSBPYmplY3QuZnJlZXplKGNvZGVzKVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIG11bHRpaGFzaCB0byBhIGhleCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGhhc2hcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9IZXhTdHJpbmcgPSBmdW5jdGlvbiB0b0hleFN0cmluZyAoaGFzaCkge1xuICBpZiAoIShoYXNoIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgcGFzc2VkIGEgVWludDhBcnJheScpXG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuaXNCdWZmZXIoaGFzaClcbiAgICA/IGhhc2hcbiAgICA6IEJ1ZmZlci5mcm9tKGhhc2guYnVmZmVyLCBoYXNoLmJ5dGVPZmZzZXQsIGhhc2guYnl0ZUxlbmd0aClcblxuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGhleCBlbmNvZGVkIHN0cmluZyB0byBhIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5mcm9tSGV4U3RyaW5nID0gZnVuY3Rpb24gZnJvbUhleFN0cmluZyAoaGFzaCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oaGFzaCwgJ2hleCcpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gbXVsdGloYXNoIHRvIGEgYmFzZTU4IGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaGFzaFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy50b0I1OFN0cmluZyA9IGZ1bmN0aW9uIHRvQjU4U3RyaW5nIChoYXNoKSB7XG4gIGlmICghKGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVzdCBiZSBwYXNzZWQgYSBVaW50OEFycmF5JylcbiAgfVxuXG4gIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUobXVsdGliYXNlLmVuY29kZSgnYmFzZTU4YnRjJywgaGFzaCkpLnNsaWNlKDEpXG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gYmFzZTU4IGVuY29kZWQgc3RyaW5nIHRvIGEgbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IGhhc2hcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZnJvbUI1OFN0cmluZyA9IGZ1bmN0aW9uIGZyb21CNThTdHJpbmcgKGhhc2gpIHtcbiAgY29uc3QgZW5jb2RlZCA9IGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgPyB0ZXh0RGVjb2Rlci5kZWNvZGUoaGFzaClcbiAgICA6IGhhc2hcblxuICByZXR1cm4gbXVsdGliYXNlLmRlY29kZSgneicgKyBlbmNvZGVkKVxufVxuXG4vKipcbiAqIERlY29kZSBhIGhhc2ggZnJvbSB0aGUgZ2l2ZW4gbXVsdGloYXNoLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnl0ZXNcbiAqIEByZXR1cm5zIHt7Y29kZTogbnVtYmVyLCBuYW1lOiBzdHJpbmcsIGxlbmd0aDogbnVtYmVyLCBkaWdlc3Q6IEJ1ZmZlcn19IHJlc3VsdFxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZSAoYnl0ZXMpIHtcbiAgaWYgKCEoYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIG11c3QgYmUgYSBVaW50OEFycmF5JylcbiAgfVxuICBsZXQgYnVmID0gQnVmZmVyLmlzQnVmZmVyKGJ5dGVzKVxuICAgID8gYnl0ZXNcbiAgICA6IEJ1ZmZlci5mcm9tKGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aClcblxuICBpZiAoYnVmLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCB0b28gc2hvcnQuIG11c3QgYmUgPiAyIGJ5dGVzLicpXG4gIH1cblxuICBjb25zdCBjb2RlID0gdmFyaW50LmRlY29kZShidWYpXG4gIGlmICghZXhwb3J0cy5pc1ZhbGlkQ29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIHVua25vd24gZnVuY3Rpb24gY29kZTogMHgke2NvZGUudG9TdHJpbmcoMTYpfWApXG4gIH1cbiAgYnVmID0gYnVmLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgY29uc3QgbGVuID0gdmFyaW50LmRlY29kZShidWYpXG4gIGlmIChsZW4gPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBtdWx0aWhhc2ggaW52YWxpZCBsZW5ndGg6ICR7bGVufWApXG4gIH1cbiAgYnVmID0gYnVmLnNsaWNlKHZhcmludC5kZWNvZGUuYnl0ZXMpXG5cbiAgaWYgKGJ1Zi5sZW5ndGggIT09IGxlbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIGxlbmd0aCBpbmNvbnNpc3RlbnQ6IDB4JHtidWYudG9TdHJpbmcoJ2hleCcpfWApXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvZGUsXG4gICAgbmFtZTogY29kZXNbY29kZV0sXG4gICAgbGVuZ3RoOiBsZW4sXG4gICAgZGlnZXN0OiBidWZcbiAgfVxufVxuXG4vKipcbiAqICBFbmNvZGUgYSBoYXNoIGRpZ2VzdCBhbG9uZyB3aXRoIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gY29kZS5cbiAqXG4gKiA+ICoqTm90ZToqKiB0aGUgbGVuZ3RoIGlzIGRlcml2ZWQgZnJvbSB0aGUgbGVuZ3RoIG9mIHRoZSBkaWdlc3QgaXRzZWxmLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGlnZXN0XG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGNvZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXVxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUgKGRpZ2VzdCwgY29kZSwgbGVuZ3RoKSB7XG4gIGlmICghZGlnZXN0IHx8IGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbXVsdGloYXNoIGVuY29kZSByZXF1aXJlcyBhdCBsZWFzdCB0d28gYXJnczogZGlnZXN0LCBjb2RlJylcbiAgfVxuXG4gIC8vIGVuc3VyZSBpdCdzIGEgaGFzaGZ1bmN0aW9uIGNvZGUuXG4gIGNvbnN0IGhhc2hmbiA9IGV4cG9ydHMuY29lcmNlQ29kZShjb2RlKVxuXG4gIGlmICghKGRpZ2VzdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3Qgc2hvdWxkIGJlIGEgVWludDhBcnJheScpXG4gIH1cblxuICBpZiAobGVuZ3RoID09IG51bGwpIHtcbiAgICBsZW5ndGggPSBkaWdlc3QubGVuZ3RoXG4gIH1cblxuICBpZiAobGVuZ3RoICYmIGRpZ2VzdC5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0IGxlbmd0aCBzaG91bGQgYmUgZXF1YWwgdG8gc3BlY2lmaWVkIGxlbmd0aC4nKVxuICB9XG5cbiAgY29uc3QgaGFzaCA9IHZhcmludC5lbmNvZGUoaGFzaGZuKVxuICBjb25zdCBsZW4gPSB2YXJpbnQuZW5jb2RlKGxlbmd0aClcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKGhhc2gubGVuZ3RoICsgbGVuLmxlbmd0aCArIGRpZ2VzdC5sZW5ndGgpXG4gIGJ1ZmZlci5zZXQoaGFzaCwgMClcbiAgYnVmZmVyLnNldChsZW4sIGhhc2gubGVuZ3RoKVxuICBidWZmZXIuc2V0KGRpZ2VzdCwgaGFzaC5sZW5ndGggKyBsZW4ubGVuZ3RoKVxuICByZXR1cm4gYnVmZmVyXG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoYXNoIGZ1bmN0aW9uIG5hbWUgaW50byB0aGUgbWF0Y2hpbmcgY29kZS5cbiAqIElmIHBhc3NlZCBhIG51bWJlciBpdCB3aWxsIHJldHVybiB0aGUgbnVtYmVyIGlmIGl0J3MgYSB2YWxpZCBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmNvZXJjZUNvZGUgPSBmdW5jdGlvbiBjb2VyY2VDb2RlIChuYW1lKSB7XG4gIGxldCBjb2RlID0gbmFtZVxuXG4gIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAobmFtZXNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgaGFzaCBmdW5jdGlvbiBuYW1lZDogJHtuYW1lfWApXG4gICAgfVxuICAgIGNvZGUgPSBuYW1lc1tuYW1lXVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb2RlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSGFzaCBmdW5jdGlvbiBjb2RlIHNob3VsZCBiZSBhIG51bWJlci4gR290OiAke2NvZGV9YClcbiAgfVxuXG4gIGlmIChjb2Rlc1tjb2RlXSA9PT0gdW5kZWZpbmVkICYmICFleHBvcnRzLmlzQXBwQ29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGZ1bmN0aW9uIGNvZGU6ICR7Y29kZX1gKVxuICB9XG5cbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2V0aGVyIGEgY29kZSBpcyBwYXJ0IG9mIHRoZSBhcHAgcmFuZ2VcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNBcHBDb2RlID0gZnVuY3Rpb24gYXBwQ29kZSAoY29kZSkge1xuICByZXR1cm4gY29kZSA+IDAgJiYgY29kZSA8IDB4MTBcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIG11bHRpaGFzaCBjb2RlIGlzIHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ29kZSA9IGZ1bmN0aW9uIHZhbGlkQ29kZSAoY29kZSkge1xuICBpZiAoZXhwb3J0cy5pc0FwcENvZGUoY29kZSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGNvZGVzW2NvZGVdKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBidWZmZXIgaXMgYSB2YWxpZCBtdWx0aWhhc2guIFRocm93cyBhbiBlcnJvciBpZiBpdCBpcyBub3QgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtdWx0aWhhc2hcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlIChtdWx0aWhhc2gpIHtcbiAgZXhwb3J0cy5kZWNvZGUobXVsdGloYXNoKSAvLyB0aHJvd3MgaWYgYmFkLlxufVxuZXhwb3J0cy52YWxpZGF0ZSA9IHZhbGlkYXRlXG5cbi8qKlxuICogUmV0dXJucyBhIHByZWZpeCBmcm9tIGEgdmFsaWQgbXVsdGloYXNoLiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgbm90IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gbXVsdGloYXNoXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMucHJlZml4ID0gZnVuY3Rpb24gcHJlZml4IChtdWx0aWhhc2gpIHtcbiAgdmFsaWRhdGUobXVsdGloYXNoKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShtdWx0aWhhc2guYnVmZmVyLCBtdWx0aWhhc2guYnl0ZU9mZnNldCwgMilcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgVWludDhBcnJheSBjcmVhdGVkIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIHBhc3NlZCBBcnJheUxpa2VzXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcnJheUxpa2U8bnVtYmVyPj59IGFycmF5c1xuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCAoYXJyYXlzLCBsZW5ndGgpIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIubGVuZ3RoLCAwKVxuICB9XG5cbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBsZXQgb2Zmc2V0ID0gMFxuXG4gIGZvciAoY29uc3QgYXJyIG9mIGFycmF5cykge1xuICAgIG91dHB1dC5zZXQoYXJyLCBvZmZzZXQpXG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25jYXRcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG5hbWVzIH0gPSByZXF1aXJlKCdtdWx0aWJhc2Uvc3JjL2NvbnN0YW50cycpXG5jb25zdCB7IFRleHRFbmNvZGVyIH0gPSByZXF1aXJlKCd3ZWItZW5jb2RpbmcnKVxuY29uc3QgdXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuXG4vKipcbiAqIEludGVycGVyZXRzIGVhY2ggY2hhcmFjdGVyIGluIGEgc3RyaW5nIGFzIGEgYnl0ZSBhbmRcbiAqIHJldHVybnMgYSBVaW50OEFycmF5IG9mIHRob3NlIGJ5dGVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0dXJuIGludG8gYW4gYXJyYXlcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5mdW5jdGlvbiBhc2NpaVN0cmluZ1RvVWludDhBcnJheSAoc3RyaW5nKSB7XG4gIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoc3RyaW5nLmxlbmd0aClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcbiAgfVxuXG4gIHJldHVybiBhcnJheVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBVaW50OEFycmF5YCBmcm9tIHRoZSBwYXNzZWQgc3RyaW5nXG4gKlxuICogU3VwcG9ydHMgYHV0ZjhgLCBgdXRmLThgIGFuZCBhbnkgZW5jb2Rpbmcgc3VwcG9ydGVkIGJ5IHRoZSBtdWx0aWJhc2UgbW9kdWxlLlxuICpcbiAqIEFsc28gYGFzY2lpYCB3aGljaCBpcyBzaW1pbGFyIHRvIG5vZGUncyAnYmluYXJ5JyBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gW2VuY29kaW5nPXV0ZjhdIHV0ZjgsIGJhc2UxNiwgYmFzZTY0LCBiYXNlNjR1cmxwYWQsIGV0Y1xuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tdWx0aWJhc2V8bXVsdGliYXNlfSBmb3Igc3VwcG9ydGVkIGVuY29kaW5ncyBvdGhlciB0aGFuIGB1dGY4YFxuICovXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIHV0ZjhFbmNvZGVyLmVuY29kZShzdHJpbmcpXG4gIH1cblxuICBpZiAoZW5jb2RpbmcgPT09ICdhc2NpaScpIHtcbiAgICByZXR1cm4gYXNjaWlTdHJpbmdUb1VpbnQ4QXJyYXkoc3RyaW5nKVxuICB9XG5cbiAgY29uc3QgY29kZWMgPSBuYW1lc1tlbmNvZGluZ11cblxuICBpZiAoIWNvZGVjKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhc2UnKVxuICB9XG5cbiAgcmV0dXJuIGNvZGVjLmRlY29kZShzdHJpbmcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnJvbVN0cmluZ1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbmFtZXMgfSA9IHJlcXVpcmUoJ211bHRpYmFzZS9zcmMvY29uc3RhbnRzJylcbmNvbnN0IHsgVGV4dERlY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5jb25zdCB1dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpXG5cbi8qKlxuICogVHVybnMgYSBVaW50OEFycmF5IG9mIGJ5dGVzIGludG8gYSBzdHJpbmcgd2l0aCBlYWNoXG4gKiBjaGFyYWN0ZXIgYmVpbmcgdGhlIGNoYXIgY29kZSBvZiB0aGUgY29ycmVzcG9uZGluZyBieXRlXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gdHVybiBpbnRvIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB1aW50OEFycmF5VG9Bc2NpaVN0cmluZyAoYXJyYXkpIHtcbiAgbGV0IHN0cmluZyA9ICcnXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKVxuICB9XG4gIHJldHVybiBzdHJpbmdcbn1cblxuLyoqXG4gKiBUdXJucyBhIGBVaW50OEFycmF5YCBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIFN1cHBvcnRzIGB1dGY4YCwgYHV0Zi04YCBhbmQgYW55IGVuY29kaW5nIHN1cHBvcnRlZCBieSB0aGUgbXVsdGliYXNlIG1vZHVsZS5cbiAqXG4gKiBBbHNvIGBhc2NpaWAgd2hpY2ggaXMgc2ltaWxhciB0byBub2RlJ3MgJ2JpbmFyeScgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gdHVybiBpbnRvIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gW2VuY29kaW5nPXV0ZjhdIFRoZSBlbmNvZGluZyB0byB1c2VcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAc2VlIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9tdWx0aWJhc2V8bXVsdGliYXNlfSBmb3Igc3VwcG9ydGVkIGVuY29kaW5ncyBvdGhlciB0aGFuIGB1dGY4YFxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAoYXJyYXksIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZShhcnJheSlcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgIHJldHVybiB1aW50OEFycmF5VG9Bc2NpaVN0cmluZyhhcnJheSlcbiAgfVxuXG4gIGNvbnN0IGNvZGVjID0gbmFtZXNbZW5jb2RpbmddXG5cbiAgaWYgKCFjb2RlYykge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBiYXNlJylcbiAgfVxuXG4gIHJldHVybiBjb2RlYy5lbmNvZGUoYXJyYXkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmdcbiIsIi8qXG5cdElTQyBMaWNlbnNlXG5cblx0Q29weXJpZ2h0IChjKSAyMDE5LCBQaWVycmUtTG91aXMgRGVzcGFpZ25lXG5cblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcblx0Y29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuXHRXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG5cdEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcblx0V0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG5cdEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG5cdE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJyk7XG5cbi8vIExhYmVsJ3MgbWF4IGxlbmd0aCBpbiBETlMgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxMDM0I3BhZ2UtNylcbmNvbnN0IGRuc0xhYmVsTWF4TGVuZ3RoID0gNjM7XG5cbi8qKlxuICogVGFrZSBhbnkgaXBmc0hhc2ggYW5kIGNvbnZlcnQgaXQgdG8gRE5TLWNvbXBhdGlibGUgQ0lEXG4gKiBAcGFyYW0ge3N0cmluZ30gaXBmc0hhc2ggYSByZWd1bGFyIGlwZnMgaGFzaCBlaXRoZXIgYSBjaWQgdjAgb3IgdjFcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlc3VsdGluZyBpcGZzIGhhc2ggYXMgYSBjaWQgdjFcbiAqL1xuY29uc3QgY2lkRm9yV2ViID0gKGlwZnNIYXNoKSA9PiB7XG5cdGxldCBjaWQgPSBuZXcgQ0lEKGlwZnNIYXNoKTtcblx0aWYgKGNpZC52ZXJzaW9uID09PSAwKSB7XG5cdFx0Y2lkID0gY2lkLnRvVjEoKTtcblx0fVxuICBsZXQgZG5zTGFiZWwgPSBjaWQudG9TdHJpbmcoJ2Jhc2UzMicpO1xuICBpZiAoZG5zTGFiZWwubGVuZ3RoID4gZG5zTGFiZWxNYXhMZW5ndGgpIHtcbiAgICBjb25zdCBiMzYgPSBjaWQudG9TdHJpbmcoJ2Jhc2UzNicpO1xuICAgIGlmIChiMzYubGVuZ3RoIDw9IGRuc0xhYmVsTWF4TGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYjM2O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnQ0lEIGlzIGxvbmdlciB0aGFuIEROUyBsaW1pdCBvZiA2MyBjaGFyYWN0ZXJzIGFuZCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHB1YmxpYyBnYXRld2F5cycpO1xuICB9XG5cdHJldHVybiBkbnNMYWJlbDtcbn1cblxuZXhwb3J0cy5jaWRGb3JXZWIgPSBjaWRGb3JXZWI7XG5cblxuLyoqXG4gKiBUYWtlIGFueSBpcGZzSGFzaCBhbmQgY29udmVydCBpdCB0byBhIENJRCB2MSBlbmNvZGVkIGluIGJhc2UzMi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpcGZzSGFzaCBhIHJlZ3VsYXIgaXBmcyBoYXNoIGVpdGhlciBhIGNpZCB2MCBvciB2MSAodjEgd2lsbCByZW1haW4gdW5jaGFuZ2VkKVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGlwZnMgaGFzaCBhcyBhIGNpZCB2MVxuICovXG5jb25zdCBjaWRWMFRvVjFCYXNlMzIgPSAoaXBmc0hhc2gpID0+IHtcblx0bGV0IGNpZCA9IG5ldyBDSUQoaXBmc0hhc2gpO1xuXHRpZiAoY2lkLnZlcnNpb24gPT09IDApIHtcblx0XHRjaWQgPSBjaWQudG9WMSgpO1xuXHR9XG5cdHJldHVybiBjaWQudG9TdHJpbmcoJ2Jhc2UzMicpO1xufVxuXG5leHBvcnRzLmNpZFYwVG9WMUJhc2UzMiA9IGNpZFYwVG9WMUJhc2UzMjtcbiIsIi8qXG5cdElTQyBMaWNlbnNlXG5cblx0Q29weXJpZ2h0IChjKSAyMDE5LCBQaWVycmUtTG91aXMgRGVzcGFpZ25lXG5cblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcblx0Y29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuXHRXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG5cdEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcblx0V0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG5cdEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG5cdE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBtdWx0aUMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJyk7XG5jb25zdCBtdWx0aUggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpO1xuXG5jb25zdCB7IGhleFN0cmluZ1RvQnVmZmVyLCBwcm9maWxlcyB9ID0gcmVxdWlyZSgnLi9wcm9maWxlcycpO1xuY29uc3QgeyBjaWRGb3JXZWIsIGNpZFYwVG9WMUJhc2UzMiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdC8vZXhwb3J0IHNvbWUgaGVscGVycyBmdW5jdGlvbnNcblx0aGVscGVyczoge1xuXHRcdGNpZEZvcldlYixcblx0XHRjaWRWMFRvVjFCYXNlMzIsXG5cdH0sXG5cblx0LyoqXG5cdCogRGVjb2RlIGEgQ29udGVudCBIYXNoLlxuXHQqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIGFuIGhleCBzdHJpbmcgY29udGFpbmluZyBhIGNvbnRlbnQgaGFzaFxuXHQqIEByZXR1cm4ge3N0cmluZ30gdGhlIGRlY29kZWQgY29udGVudFxuXHQqL1xuXHRkZWNvZGU6IGZ1bmN0aW9uIChjb250ZW50SGFzaCkge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyKGNvbnRlbnRIYXNoKTtcblx0XHRjb25zdCBjb2RlYyA9IG11bHRpQy5nZXRDb2RlYyhidWZmZXIpO1xuXHRcdGNvbnN0IHZhbHVlID0gbXVsdGlDLnJtUHJlZml4KGJ1ZmZlcik7XG5cdFx0bGV0IHByb2ZpbGUgPSBwcm9maWxlc1tjb2RlY107XG5cdFx0aWYgKCFwcm9maWxlKSBwcm9maWxlID0gcHJvZmlsZXNbJ2RlZmF1bHQnXTtcblx0XHRyZXR1cm4gcHJvZmlsZS5kZWNvZGUodmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEVuY29kZSBhbiBJUEZTIGFkZHJlc3MgaW50byBhIGNvbnRlbnQgaGFzaFxuXHQqIEBwYXJhbSB7c3RyaW5nfSBpcGZzSGFzaCBzdHJpbmcgY29udGFpbmluZyBhbiBJUEZTIGFkZHJlc3Ncblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgY29udGVudCBoYXNoXG5cdCovXG5cdGZyb21JcGZzOiBmdW5jdGlvbiAoaXBmc0hhc2gpIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ2lwZnMtbnMnLCBpcGZzSGFzaCk7XG5cdH0sXG5cblx0LyoqXG5cdCogRW5jb2RlIGEgU2t5bGluayBpbnRvIGEgY29udGVudCBoYXNoXG5cdCogQHBhcmFtIHtzdHJpbmd9IHNreWxpbmsgc3RyaW5nIGNvbnRhaW5pbmcgYSBTa3lsaW5rXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGNvbnRlbnQgaGFzaFxuXHQqL1xuXHRmcm9tU2t5bGluazogZnVuY3Rpb24gKHNreWxpbmspIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ3NreW5ldC1ucycsIHNreWxpbmspO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEVuY29kZSBhIFN3YXJtIGFkZHJlc3MgaW50byBhIGNvbnRlbnQgaGFzaFxuXHQqIEBwYXJhbSB7c3RyaW5nfSBzd2FybUhhc2ggc3RyaW5nIGNvbnRhaW5pbmcgYSBTd2FybSBhZGRyZXNzXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGNvbnRlbnQgaGFzaFxuXHQqL1xuXHRmcm9tU3dhcm06IGZ1bmN0aW9uIChzd2FybUhhc2gpIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ3N3YXJtLW5zJywgc3dhcm1IYXNoKTtcblx0fSxcblxuXHQvKipcblx0KiBHZW5lcmFsIHB1cnBvc2UgZW5jb2RpbmcgZnVuY3Rpb25cbiAgKiBAcGFyYW0ge3N0cmluZ30gY29kZWMgXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFxuICAqL1xuXHRlbmNvZGU6IGZ1bmN0aW9uIChjb2RlYywgdmFsdWUpIHtcblx0XHRsZXQgcHJvZmlsZSA9IHByb2ZpbGVzW2NvZGVjXTtcblx0XHRpZiAoIXByb2ZpbGUpIHByb2ZpbGUgPSBwcm9maWxlc1snZGVmYXVsdCddO1xuXHRcdGNvbnN0IGVuY29kZWRWYWx1ZSA9IHByb2ZpbGUuZW5jb2RlKHZhbHVlKTtcblx0XHRyZXR1cm4gbXVsdGlILnRvSGV4U3RyaW5nKG11bHRpQy5hZGRQcmVmaXgoY29kZWMsIGVuY29kZWRWYWx1ZSkpXG5cdH0sXG5cblx0LyoqXG5cdCogRXh0cmFjdCB0aGUgY29kZWMgb2YgYSBjb250ZW50IGhhc2hcblx0KiBAcGFyYW0ge3N0cmluZ30gaGFzaCBoZXggc3RyaW5nIGNvbnRhaW5pbmcgYSBjb250ZW50IGhhc2hcblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBleHRyYWN0ZWQgY29kZWNcblx0Ki9cblx0Z2V0Q29kZWM6IGZ1bmN0aW9uIChoYXNoKSB7XG5cdFx0bGV0IGJ1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyKGhhc2gpO1xuXHRcdHJldHVybiBtdWx0aUMuZ2V0Q29kZWMoYnVmZmVyKTtcblx0fSxcbn1cbiIsIi8qXG5cdElTQyBMaWNlbnNlXG5cblx0Q29weXJpZ2h0IChjKSAyMDE5LCBQaWVycmUtTG91aXMgRGVzcGFpZ25lXG5cblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcblx0Y29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuXHRXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG5cdEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcblx0V0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG5cdEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG5cdE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJyk7XG5jb25zdCBtdWx0aUggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpO1xuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnanMtYmFzZTY0JylcblxuLyoqXG4gKiBDb252ZXJ0IGFuIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIEJ1ZmZlciwgdGhlIHN0cmluZyBjYW4gc3RhcnQgd2l0aCBvciB3aXRob3V0ICcweCdcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXggYW4gaGV4YWRlY2ltYWwgdmFsdWVcbiAqIEByZXR1cm4ge0J1ZmZlcn0gdGhlIHJlc3VsdGluZyBCdWZmZXJcbiAqL1xuY29uc3QgaGV4U3RyaW5nVG9CdWZmZXIgPSAoaGV4KSA9PiB7XG5cdGxldCBwcmVmaXggPSBoZXguc2xpY2UoMCwgMik7XG5cdGxldCB2YWx1ZSA9IGhleC5zbGljZSgyKTtcblx0bGV0IHJlcyA9ICcnO1xuXHRpZiAocHJlZml4ID09PSAnMHgnKSByZXMgPSB2YWx1ZTtcblx0ZWxzZSByZXMgPSBoZXg7XG5cdHJldHVybiBtdWx0aUguZnJvbUhleFN0cmluZyhyZXMpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBJUE5TIGlkZW50aWZpZXIgIHRvIHNhZmVndWFyZCBhZ2FpbnN0IGluc2VjdXJlIG5hbWVzLlxuICogQHBhcmFtIHtDSUR9IG5hbWUgaXNlZCBpbiBpcG5zLW5zXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5jb25zdCBpc0NyeXB0b2dyYXBoaWNJUE5TID0gIChjaWQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IG11bHRpaGFzaCB9ID0gY2lkXG4gICAgLy8gQWRkaXRpb25hbCBjaGVjayBmb3IgaWRlbnRpZmllcnMgc2hvcnRlclxuICAgIC8vIHRoYW4gd2hhdCBpbmxpbmVkIEVEMjU1MTkgcHVia2V5IHdvdWxkIGJlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vuc2RvbWFpbnMvZW5zLWFwcC9pc3N1ZXMvODQ5I2lzc3VlY29tbWVudC03NzcwODg5NTBcbiAgICBpZiAobXVsdGloYXNoLmxlbmd0aCA8IDM4KSB7XG4gICAgICBjb25zdCBtaCA9IG11bHRpSC5kZWNvZGUobXVsdGloYXNoKVxuICAgICAgLy8gRUQyNTUxOSBwdWJrZXlzIGFyZSBpbmxpbmVkIHVzaW5nIGlkZW50aXR5IGhhc2ggZnVuY3Rpb25cbiAgICAgIC8vIGFuZCB3ZSBzaG91bGQgbm90IHNlZSBhbnl0aGluZyBzaG9ydGVyIHRoYW4gdGhhdFxuICAgICAgaWYgKG1oLm5hbWUgPT09ICdpZGVudGl0eScgJiYgbWgubGVuZ3RoIDwgMzYpIHtcbiAgICAgICAgLy8gT25lIGNhbiByZWFkIGlubGluZWQgc3RyaW5nIHZhbHVlIHZpYTpcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2lwbnMtbnMgaWQ6JywgU3RyaW5nKG11bHRpSC5kZWNvZGUobmV3IENJRCh2YWx1ZSkubXVsdGloYXNoKS5kaWdlc3QpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb2ssIENJRCBsb29rcyBmaW5lXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoXykgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4qIGxpc3Qgb2Yga25vd24gZW5jb2RpbmcsXG4qIGVuY29kaW5nIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBgc3RyaW5nYCBpbnB1dCxcbiogYW5kIHJldHVybiBhIGBCdWZmZXJgIHJlc3VsdFxuKi9cbmNvbnN0IGVuY29kZXMgPSB7XG4gIC8qKlxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgKi9cbiAgc2t5bmV0OiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gYmFzZTY0LnRvVWludDhBcnJheSh2YWx1ZSlcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICBzd2FybTogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgbXVsdGloYXNoID0gbXVsdGlILmVuY29kZShoZXhTdHJpbmdUb0J1ZmZlcih2YWx1ZSksICdrZWNjYWstMjU2Jyk7XG5cdFx0cmV0dXJuIG5ldyBDSUQoMSwgJ3N3YXJtLW1hbmlmZXN0JywgbXVsdGloYXNoKS5ieXRlcztcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICBpcGZzOiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gbmV3IENJRCh2YWx1ZSkudG9WMSgpLmJ5dGVzO1xuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICovXG4gIGlwbnM6ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGNpZCA9IG5ldyBDSUQodmFsdWUpXG4gICAgaWYgKCFpc0NyeXB0b2dyYXBoaWNJUE5TKGNpZCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2lwbnMtbnMgYWxsb3dzIG9ubHkgdmFsaWQgY3J5cHRvZ3JhcGhpYyBsaWJwMnAta2V5IGlkZW50aWZpZXJzLCB0cnkgdXNpbmcgRUQyNTUxOSBwdWJrZXkgaW5zdGVhZCcpXG4gICAgfVxuICAgIC8vIFJlcHJlc2VudCBJUE5TIG5hbWUgYXMgYSBDSUQgd2l0aCBsaWJwMnAta2V5IGNvZGVjXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9zcGVjcy9ibG9iL21hc3Rlci9SRkMvMDAwMS10ZXh0LXBlZXJpZC1jaWQubWRcbiAgICByZXR1cm4gbmV3IENJRCgxLCAnbGlicDJwLWtleScsIGNpZC5tdWx0aWhhc2gpLmJ5dGVzXG4gIH0sXG4gIC8qKlxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgKi9cbiAgdXRmODogKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpO1xuICB9LFxufTtcblxuLyoqIFxuKiBsaXN0IG9mIGtub3duIGRlY29kaW5nLFxuKiBkZWNvZGluZyBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgYEJ1ZmZlcmAgaW5wdXQsXG4qIGFuZCByZXR1cm4gYSBgc3RyaW5nYCByZXN1bHRcbiovXG5jb25zdCBkZWNvZGVzID0ge1xuICAvKipcbiAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgXG4gICovXG4gIGhleE11bHRpSGFzaDogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY2lkID0gbmV3IENJRCh2YWx1ZSk7XG4gICAgcmV0dXJuIG11bHRpSC5kZWNvZGUoY2lkLm11bHRpaGFzaCkuZGlnZXN0LnRvU3RyaW5nKCdoZXgnKTtcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIFxuICAqL1xuICBpcGZzOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjaWQgPSBuZXcgQ0lEKHZhbHVlKS50b1YxKCk7XG4gICAgcmV0dXJuIGNpZC50b1N0cmluZyhjaWQuY29kZWMgPT09ICdsaWJwMnAta2V5JyA/ICdiYXNlMzYnIDogJ2Jhc2UzMicpXG4gIH0sXG4gIC8qKlxuICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBcbiAgKi9cbiAgaXBuczogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY2lkID0gbmV3IENJRCh2YWx1ZSkudG9WMSgpXG4gICAgaWYgKCFpc0NyeXB0b2dyYXBoaWNJUE5TKGNpZCkpIHtcbiAgICAgICAgLy8gVmFsdWUgaXMgbm90IGEgbGlicDJwLWtleSwgcmV0dXJuIG9yaWdpbmFsIHN0cmluZ1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tlbnNkb21haW5zL2NvbnRlbnQtaGFzaF0gdXNlIG9mIG5vbi1jcnlwdG9ncmFwaGljIGlkZW50aWZpZXJzIGluIGlwbnMtbnMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkLCBtaWdyYXRlIHRvIEVEMjU1MTkgbGlicDJwLWtleScpXG4gICAgICAgIHJldHVybiBTdHJpbmcobXVsdGlILmRlY29kZShuZXcgQ0lEKHZhbHVlKS5tdWx0aWhhc2gpLmRpZ2VzdClcbiAgICAgICAgLy8gVE9ETzogc3RhcnQgdGhyb3dpbmcgYW4gZXJyb3IgKGFmdGVyIHNvbWUgZGVwcmVjYXRpb24gcGVyaW9kKVxuICAgICAgICAvLyB0aHJvdyBFcnJvcignaXBucy1ucyBhbGxvd3Mgb25seSB2YWxpZCBjcnlwdG9ncmFwaGljIGxpYnAycC1rZXkgaWRlbnRpZmllcnMsIHRyeSB1c2luZyBFRDI1NTE5IHB1YmtleSBpbnN0ZWFkJylcbiAgICB9XG4gICAgcmV0dXJuIGNpZC50b1N0cmluZygnYmFzZTM2JylcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIFxuICAqL1xuICB1dGY4OiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgfSxcbiAgYmFzZTY0OiAodmFsdWUpID0+IHtcbiAgICAvLyBgdHJ1ZWAgb3B0aW9uIG1ha2VzIGl0IFVSTCBzYWZlIChyZXBsYWNlcyAvIGFuZCArIHdpdGggLSBhbmQgXyApXG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tVWludDhBcnJheSh2YWx1ZSwgdHJ1ZSlcbiAgfVxufTtcblxuLyoqXG4qIGxpc3Qgb2Yga25vd24gZW5jb2RpbmcvZGVjb2RpbmcgZm9yIGEgZ2l2ZW4gY29kZWMsXG4qIGBlbmNvZGVgIHNob3VsZCBiZSBjaG9zZW4gYW1vbmcgdGhlIGBlbmNvZGVzYCBmdW5jdGlvbnNcbiogYGRlY29kZWAgc2hvdWxkIGJlIGNob3NlbiBhbW9uZyB0aGUgYGRlY29kZXNgIGZ1bmN0aW9uc1xuKi9cbmNvbnN0IHByb2ZpbGVzID0ge1xuICAnc2t5bmV0LW5zJzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy5za3luZXQsXG4gICAgZGVjb2RlOiBkZWNvZGVzLmJhc2U2NCxcbiAgfSxcbiAgJ3N3YXJtLW5zJzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy5zd2FybSxcbiAgICBkZWNvZGU6IGRlY29kZXMuaGV4TXVsdGlIYXNoLFxuICB9LFxuICAnaXBmcy1ucyc6IHtcbiAgICBlbmNvZGU6IGVuY29kZXMuaXBmcyxcbiAgICBkZWNvZGU6IGRlY29kZXMuaXBmcyxcbiAgfSxcbiAgJ2lwbnMtbnMnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLmlwbnMsXG4gICAgZGVjb2RlOiBkZWNvZGVzLmlwbnMsXG4gIH0sXG4gICdkZWZhdWx0Jzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy51dGY4LFxuICAgIGRlY29kZTogZGVjb2Rlcy51dGY4LFxuICB9LFxufTtcblxuZXhwb3J0cy5oZXhTdHJpbmdUb0J1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyO1xuZXhwb3J0cy5wcm9maWxlcyA9IHByb2ZpbGVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIEhES2V5ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2hka2V5JykpO1xudmFyIHV0aWwgPSByZXF1aXJlKCdAZXRoZXJldW1qcy91dGlsJyk7XG52YXIgcmxwID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3JscCcpKTtcbnZhciB0eCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4Jyk7XG52YXIgYmNVclJlZ2lzdHJ5RXRoID0gcmVxdWlyZSgnQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoJyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcblxuY29uc3Qga2V5cmluZ1R5cGUgPSBcIlFSIEhhcmR3YXJlIFdhbGxldCBEZXZpY2VcIjtcbmNvbnN0IHBhdGhCYXNlID0gXCJtXCI7XG5jb25zdCBNQVhfSU5ERVggPSAxMDAwO1xuY29uc3QgREVGQVVMVF9DSElMRFJFTl9QQVRIID0gXCIwLypcIjtcbnZhciBLRVlSSU5HX01PREU7XG5cbihmdW5jdGlvbiAoS0VZUklOR19NT0RFKSB7XG4gIEtFWVJJTkdfTU9ERVtcImhkXCJdID0gXCJoZFwiO1xuICBLRVlSSU5HX01PREVbXCJwdWJrZXlcIl0gPSBcInB1YmtleVwiO1xufSkoS0VZUklOR19NT0RFIHx8IChLRVlSSU5HX01PREUgPSB7fSkpO1xuXG52YXIgS0VZUklOR19BQ0NPVU5UO1xuXG4oZnVuY3Rpb24gKEtFWVJJTkdfQUNDT1VOVCkge1xuICBLRVlSSU5HX0FDQ09VTlRbXCJzdGFuZGFyZFwiXSA9IFwiYWNjb3VudC5zdGFuZGFyZFwiO1xuICBLRVlSSU5HX0FDQ09VTlRbXCJsZWRnZXJfbGl2ZVwiXSA9IFwiYWNjb3VudC5sZWRnZXJfbGl2ZVwiO1xuICBLRVlSSU5HX0FDQ09VTlRbXCJsZWRnZXJfbGVnYWN5XCJdID0gXCJhY2NvdW50LmxlZGdlcl9sZWdhY3lcIjtcbn0pKEtFWVJJTkdfQUNDT1VOVCB8fCAoS0VZUklOR19BQ0NPVU5UID0ge30pKTtcblxuY2xhc3MgQmFzZUtleXJpbmcge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMudmVyc2lvbiA9IDE7XG5cbiAgICB0aGlzLmdldEludGVyYWN0aW9uID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2V4dGVuZHM6IG1ldGhvZCBnZXRJbnRlcmFjdGlvbiBub3QgaW1wbGVtZW50ZWQsIHBsZWFzZSBleHRlbmQgQmFzZUtleXJpbmcgYnkgb3ZlcndyaXRpbmcgdGhpcyBtZXRob2QuXCIpO1xuICAgIH07XG5cbiAgICB0aGlzLnR5cGUgPSBrZXlyaW5nVHlwZTtcblxuICAgIHRoaXMucmVxdWVzdFNpZ25hdHVyZSA9IGFzeW5jIChfcmVxdWVzdElkLCBzaWduUmVxdWVzdCwgcmVxdWVzdFRpdGxlLCByZXF1ZXN0RGVzY3JpcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IGV0aFNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZXF1ZXN0U2lnbmF0dXJlKHNpZ25SZXF1ZXN0LCByZXF1ZXN0VGl0bGUsIHJlcXVlc3REZXNjcmlwdGlvbik7XG4gICAgICBjb25zdCByZXF1ZXN0SWRCdWZmZXIgPSBldGhTaWduYXR1cmUuZ2V0UmVxdWVzdElkKCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBldGhTaWduYXR1cmUuZ2V0U2lnbmF0dXJlKCk7XG5cbiAgICAgIGlmIChyZXF1ZXN0SWRCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC5zdHJpbmdpZnkocmVxdWVzdElkQnVmZmVyKTtcblxuICAgICAgICBpZiAocmVxdWVzdElkICE9PSBfcmVxdWVzdElkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IHJlYWQgc2lnbmF0dXJlIGVycm9yOiBtaXNtYXRjaGVkIHJlcXVlc3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByID0gc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgICAgIGNvbnN0IHMgPSBzaWduYXR1cmUuc2xpY2UoMzIsIDY0KTtcbiAgICAgIGNvbnN0IHYgPSBzaWduYXR1cmUuc2xpY2UoNjQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgdlxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX3JlYWRDcnlwdG9IREtleSA9IGNyeXB0b0hES2V5ID0+IHtcbiAgICAgIHZhciBfY3J5cHRvSERLZXkkZ2V0T3JpZ2ksIF9jcnlwdG9IREtleSRnZXRDaGlsZDtcblxuICAgICAgY29uc3QgaGRQYXRoID0gYG0vJHtjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRQYXRoKCl9YDtcbiAgICAgIGNvbnN0IHhmcCA9IChfY3J5cHRvSERLZXkkZ2V0T3JpZ2kgPSBjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRTb3VyY2VGaW5nZXJwcmludCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2NyeXB0b0hES2V5JGdldE9yaWdpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgY29uc3QgY2hpbGRyZW5QYXRoID0gKChfY3J5cHRvSERLZXkkZ2V0Q2hpbGQgPSBjcnlwdG9IREtleS5nZXRDaGlsZHJlbigpKSA9PSBudWxsID8gdm9pZCAwIDogX2NyeXB0b0hES2V5JGdldENoaWxkLmdldFBhdGgoKSkgfHwgREVGQVVMVF9DSElMRFJFTl9QQVRIO1xuICAgICAgY29uc3QgbmFtZSA9IGNyeXB0b0hES2V5LmdldE5hbWUoKTtcblxuICAgICAgaWYgKGNyeXB0b0hES2V5LmdldE5vdGUoKSA9PT0gS0VZUklOR19BQ0NPVU5ULnN0YW5kYXJkKSB7XG4gICAgICAgIHRoaXMua2V5cmluZ0FjY291bnQgPSBLRVlSSU5HX0FDQ09VTlQuc3RhbmRhcmQ7XG4gICAgICB9IGVsc2UgaWYgKGNyeXB0b0hES2V5LmdldE5vdGUoKSA9PT0gS0VZUklOR19BQ0NPVU5ULmxlZGdlcl9sZWdhY3kpIHtcbiAgICAgICAgdGhpcy5rZXlyaW5nQWNjb3VudCA9IEtFWVJJTkdfQUNDT1VOVC5sZWRnZXJfbGVnYWN5O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXhmcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8taGRrZXksIGNhbm5vdCBnZXQgc291cmNlIGZpbmdlcnByaW50XCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4cHViID0gY3J5cHRvSERLZXkuZ2V0QmlwMzJLZXkoKTtcbiAgICAgIHRoaXMueGZwID0geGZwO1xuICAgICAgdGhpcy54cHViID0geHB1YjtcbiAgICAgIHRoaXMuaGRQYXRoID0gaGRQYXRoO1xuICAgICAgdGhpcy5jaGlsZHJlblBhdGggPSBjaGlsZHJlblBhdGg7XG5cbiAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQgJiYgbmFtZSAhPT0gXCJcIikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50ID0gY3J5cHRvQWNjb3VudCA9PiB7XG4gICAgICB2YXIgX2NyeXB0b0FjY291bnQkZ2V0TWFzLCBfY3J5cHRvQWNjb3VudCRnZXRPdXQ7XG5cbiAgICAgIGNvbnN0IHhmcCA9IChfY3J5cHRvQWNjb3VudCRnZXRNYXMgPSBjcnlwdG9BY2NvdW50LmdldE1hc3RlckZpbmdlcnByaW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfY3J5cHRvQWNjb3VudCRnZXRNYXMudG9TdHJpbmcoXCJoZXhcIik7XG5cbiAgICAgIGlmICgheGZwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1hY2NvdW50LCBjYW5ub3QgZ2V0IG1hc3RlciBmaW5nZXJwcmludFwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy54ZnAgPSB4ZnA7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICBjb25zdCBvdXRwdXRzID0gY3J5cHRvQWNjb3VudC5nZXRPdXRwdXREZXNjcmlwdG9ycygpO1xuXG4gICAgICBpZiAoIW91dHB1dHMgfHwgb3V0cHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IGludmFsaWQgY3J5cHRvLWFjY291bnQsIG5vIGNyeXB0byBvdXRwdXQgZm91bmRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXRwdXRzLmxlbmd0aCAlIDUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IG9ubHkgc3VwcG9ydCA1eCBwdWJrZXkgYWNjb3VudHMgZm9yIG5vd1wiKTtcbiAgICAgIH1cblxuICAgICAgKF9jcnlwdG9BY2NvdW50JGdldE91dCA9IGNyeXB0b0FjY291bnQuZ2V0T3V0cHV0RGVzY3JpcHRvcnMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jcnlwdG9BY2NvdW50JGdldE91dC5mb3JFYWNoKG9kID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjcnlwdG9IREtleSA9IG9kLmdldEhES2V5KCk7XG5cbiAgICAgICAgICBpZiAoY3J5cHRvSERLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGNyeXB0b0hES2V5LmdldEtleSgpO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGBNLyR7Y3J5cHRvSERLZXkuZ2V0T3JpZ2luKCkuZ2V0UGF0aCgpfWA7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gXCIweFwiICsgdXRpbC5wdWJsaWNUb0FkZHJlc3Moa2V5LCB0cnVlKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IGNyeXB0b0hES2V5LmdldE5hbWUoKTtcblxuICAgICAgICAgICAgaWYgKGNyeXB0b0hES2V5LmdldE5vdGUoKSA9PT0gS0VZUklOR19BQ0NPVU5ULmxlZGdlcl9saXZlKSB7XG4gICAgICAgICAgICAgIHRoaXMua2V5cmluZ0FjY291bnQgPSBLRVlSSU5HX0FDQ09VTlQubGVkZ2VyX2xpdmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGhzW3V0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGF0aHNbdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPSBwYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9OyAvLyBwcml2YXRlIF9fcmVhZExlZGdlckxpdmVBY2NvdW50cyA9IGFzeW5jICgpID0+IHtcbiAgICAvLyAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCgpO1xuICAgIC8vICAgICBpZiAocmVzdWx0LmdldFJlZ2lzdHJ5VHlwZSgpID09PSBleHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fQUNDT1VOVCkge1xuICAgIC8vICAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX19yZWFkQ3J5cHRvQWNjb3VudChyZXN1bHQgYXMgQ3J5cHRvQWNjb3VudCk7XG4gICAgLy8gICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAvLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNLZXlzdG9uZUVycm9yI3B1YmtleV9hY2NvdW50Lm5vX25ld19hY2NvdW50YCk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXN0b25lRXJyb3IjcHVia2V5X2FjY291bnQudW5leHBlY3RlZF91cnR5cGVgKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH07XG5cblxuICAgIHRoaXMuZ2V0TmFtZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0QWNjb3VudFRvVW5sb2NrID0gaW5kZXggPT4ge1xuICAgICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgIH07XG5cbiAgICB0aGlzLl9fZ2V0Tm9ybWFsUGFnZSA9IGFzeW5jIGluY3JlbWVudCA9PiB7XG4gICAgICB0aGlzLnBhZ2UgKz0gaW5jcmVtZW50O1xuXG4gICAgICBpZiAodGhpcy5wYWdlIDw9IDApIHtcbiAgICAgICAgdGhpcy5wYWdlID0gMTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZnJvbSA9ICh0aGlzLnBhZ2UgLSAxKSAqIHRoaXMucGVyUGFnZTtcbiAgICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMucGVyUGFnZTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpO1xuICAgICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGJhbGFuY2U6IG51bGwsXG4gICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5kZXhlc1t1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IGk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9O1xuXG4gICAgdGhpcy5fX2dldExlZGdlckxpdmVQYWdlID0gYXN5bmMgaW5jcmVtZW50ID0+IHtcbiAgICAgIGNvbnN0IG5leHRQYWdlID0gdGhpcy5wYWdlICsgaW5jcmVtZW50O1xuICAgICAgY29uc3QgZnJvbSA9IChuZXh0UGFnZSAtIDEpICogdGhpcy5wZXJQYWdlO1xuICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgICBpbmRleDogaVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWdlICs9IGluY3JlbWVudDtcbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9O1xuXG4gICAgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXggPSBhc3luYyAocGIsIGkpID0+IHtcbiAgICAgIGlmICh0aGlzLmtleXJpbmdNb2RlID09PSBLRVlSSU5HX01PREUuaGQpIHtcbiAgICAgICAgdGhpcy5jaGVja0tleXJpbmcoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaGRrKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHRoaXMuaGRrID0gSERLZXkuZnJvbUV4dGVuZGVkS2V5KHRoaXMueHB1Yik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZHJlblBhdGggPSB0aGlzLmNoaWxkcmVuUGF0aC5yZXBsYWNlKFwiKlwiLCBTdHJpbmcoaSkpLnJlcGxhY2UoL1xcKi9nLCBcIjBcIik7XG4gICAgICAgIGNvbnN0IGRrZXkgPSB0aGlzLmhkay5kZXJpdmUoYCR7cGJ9LyR7Y2hpbGRyZW5QYXRofWApO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gXCIweFwiICsgdXRpbC5wdWJsaWNUb0FkZHJlc3MoZGtleS5wdWJsaWNLZXksIHRydWUpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICByZXR1cm4gdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHRoaXMucGF0aHMpW2ldO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNwdWJrZXlfYWNjb3VudC5ub19leHBlY3RlZF9hY2NvdW50YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvL2NvbW1vbiBwcm9wc1xuXG5cbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHRoaXMucGVyUGFnZSA9IDU7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEFjY291bnQgPSAwO1xuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMDtcbiAgICB0aGlzLm5hbWUgPSBcIlFSIEhhcmR3YXJlXCI7XG4gICAgdGhpcy5rZXlyaW5nTW9kZSA9IEtFWVJJTkdfTU9ERS5oZDtcbiAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gS0VZUklOR19BQ0NPVU5ULnN0YW5kYXJkO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy9oZCBwcm9wcztcblxuICAgIHRoaXMueGZwID0gXCJcIjtcbiAgICB0aGlzLnhwdWIgPSBcIlwiO1xuICAgIHRoaXMuaGRQYXRoID0gXCJcIjtcbiAgICB0aGlzLmNoaWxkcmVuUGF0aCA9IERFRkFVTFRfQ0hJTERSRU5fUEFUSDtcbiAgICB0aGlzLmluZGV4ZXMgPSB7fTsgLy9wdWJrZXkgcHJvcHM7XG5cbiAgICB0aGlzLnBhdGhzID0ge307XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKTtcbiAgfSAvL2luaXRpYWwgcmVhZFxuXG5cbiAgYXN5bmMgcmVhZEtleXJpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCgpO1xuICAgIHRoaXMuc3luY0tleXJpbmcocmVzdWx0KTtcbiAgfVxuXG4gIHN5bmNLZXlyaW5nKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUeXBlKCkgPT09IGJjVXJSZWdpc3RyeUV0aC5leHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkuZ2V0VHlwZSgpKSB7XG4gICAgICB0aGlzLmtleXJpbmdNb2RlID0gS0VZUklOR19NT0RFLmhkO1xuXG4gICAgICB0aGlzLl9fcmVhZENyeXB0b0hES2V5KGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleXJpbmdNb2RlID0gS0VZUklOR19NT0RFLnB1YmtleTtcblxuICAgICAgdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50KGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrS2V5cmluZygpIHtcbiAgICBpZiAoIXRoaXMueGZwIHx8ICF0aGlzLnhwdWIgfHwgIXRoaXMuaGRQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfa2V5cmluZzoga2V5cmluZyBub3QgZnVsZmlsbGVkLCBwbGVhc2UgY2FsbCBmdW5jdGlvbiBgcmVhZEtleXJpbmdgIGZpcnN0bHlcIik7XG4gICAgfVxuICB9XG5cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgLy9jb21tb25cbiAgICAgIGluaXRpYWxpemVkOiB0aGlzLmluaXRpYWxpemVkLFxuICAgICAgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMsXG4gICAgICBjdXJyZW50QWNjb3VudDogdGhpcy5jdXJyZW50QWNjb3VudCxcbiAgICAgIHBhZ2U6IHRoaXMucGFnZSxcbiAgICAgIHBlclBhZ2U6IHRoaXMucGVyUGFnZSxcbiAgICAgIGtleXJpbmdBY2NvdW50OiB0aGlzLmtleXJpbmdBY2NvdW50LFxuICAgICAga2V5cmluZ01vZGU6IHRoaXMua2V5cmluZ01vZGUsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICB4ZnA6IHRoaXMueGZwLFxuICAgICAgLy9oZFxuICAgICAgeHB1YjogdGhpcy54cHViLFxuICAgICAgaGRQYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgIGNoaWxkcmVuUGF0aDogdGhpcy5jaGlsZHJlblBhdGgsXG4gICAgICBpbmRleGVzOiB0aGlzLmluZGV4ZXMsXG4gICAgICAvL3B1YmtleVxuICAgICAgcGF0aHM6IHRoaXMucGF0aHNcbiAgICB9KTtcbiAgfVxuXG4gIGRlc2VyaWFsaXplKG9wdHMpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgLy9jb21tb24gcHJvcHM7XG4gICAgICB0aGlzLmFjY291bnRzID0gb3B0cy5hY2NvdW50cztcbiAgICAgIHRoaXMuY3VycmVudEFjY291bnQgPSBvcHRzLmN1cnJlbnRBY2NvdW50O1xuICAgICAgdGhpcy5wYWdlID0gb3B0cy5wYWdlO1xuICAgICAgdGhpcy5wZXJQYWdlID0gb3B0cy5wZXJQYWdlO1xuICAgICAgdGhpcy5uYW1lID0gb3B0cy5uYW1lO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IG9wdHMuaW5pdGlhbGl6ZWQ7XG4gICAgICB0aGlzLmtleXJpbmdNb2RlID0gb3B0cy5rZXlyaW5nTW9kZSB8fCBLRVlSSU5HX01PREUuaGQ7XG4gICAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gb3B0cy5rZXlyaW5nQWNjb3VudCB8fCBLRVlSSU5HX0FDQ09VTlQuc3RhbmRhcmQ7XG4gICAgICB0aGlzLnhmcCA9IG9wdHMueGZwOyAvL2hkIHByb3BzO1xuXG4gICAgICB0aGlzLnhwdWIgPSBvcHRzLnhwdWI7XG4gICAgICB0aGlzLmhkUGF0aCA9IG9wdHMuaGRQYXRoO1xuICAgICAgdGhpcy5pbmRleGVzID0gb3B0cy5pbmRleGVzO1xuICAgICAgdGhpcy5wYXRocyA9IG9wdHMucGF0aHM7XG4gICAgICB0aGlzLmNoaWxkcmVuUGF0aCA9IG9wdHMuY2hpbGRyZW5QYXRoIHx8IERFRkFVTFRfQ0hJTERSRU5fUEFUSDtcbiAgICB9XG4gIH1cblxuICBzZXRDdXJyZW50QWNjb3VudChpbmRleCkge1xuICAgIHRoaXMuY3VycmVudEFjY291bnQgPSBpbmRleDtcbiAgfVxuXG4gIGdldEN1cnJlbnRBY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRBY2NvdW50O1xuICB9XG5cbiAgZ2V0Q3VycmVudEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudHNbdGhpcy5jdXJyZW50QWNjb3VudF07XG4gIH1cblxuICBhc3luYyBhZGRBY2NvdW50cyhuID0gMSkge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLnVubG9ja2VkQWNjb3VudDtcbiAgICBjb25zdCB0byA9IGZyb20gKyBuO1xuICAgIGNvbnN0IG5ld0FjY291bnRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICBuZXdBY2NvdW50cy5wdXNoKGFkZHJlc3MpO1xuICAgICAgdGhpcy5wYWdlID0gMDtcbiAgICAgIHRoaXMudW5sb2NrZWRBY2NvdW50Kys7XG4gICAgfVxuXG4gICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHMuY29uY2F0KG5ld0FjY291bnRzKTtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50cztcbiAgfVxuXG4gIGdldEZpcnN0UGFnZSgpIHtcbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldE5leHRQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldFByZXZpb3VzUGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2dldFBhZ2UoLTEpO1xuICB9XG5cbiAgYXN5bmMgX19nZXRQYWdlKGluY3JlbWVudCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5yZWFkS2V5cmluZygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmtleXJpbmdNb2RlID09PSBLRVlSSU5HX01PREUuaGQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZ2V0Tm9ybWFsUGFnZShpbmNyZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2dldExlZGdlckxpdmVQYWdlKGluY3JlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFjY291bnRzKTtcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xuICAgIGlmICghdGhpcy5hY2NvdW50cy5tYXAoYSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoYSA9PiBhLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgdHgkMSkge1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdHgkMS50eXBlID09PSAwID8gYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnRyYW5zYWN0aW9uIDogYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnR5cGVkVHJhbnNhY3Rpb247XG4gICAgbGV0IG1lc3NhZ2VUb1NpZ247XG5cbiAgICBpZiAodHgkMS50eXBlID09PSAwKSB7XG4gICAgICBtZXNzYWdlVG9TaWduID0gQnVmZmVyLmZyb20ocmxwLmVuY29kZSh0eCQxLmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2VUb1NpZ24gPSB0eCQxLmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBjb25zdCBjaGFpbklkID0gTnVtYmVyKHR4JDEuY29tbW9uLmNoYWluSWQoKSk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC52NCgpO1xuICAgIGNvbnN0IGV0aFNpZ25SZXF1ZXN0ID0gYmNVclJlZ2lzdHJ5RXRoLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QobWVzc2FnZVRvU2lnbiwgZGF0YVR5cGUsIGhkUGF0aCwgdGhpcy54ZnAsIHJlcXVlc3RJZCwgY2hhaW5JZCk7XG4gICAgY29uc3Qge1xuICAgICAgcixcbiAgICAgIHMsXG4gICAgICB2XG4gICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShyZXF1ZXN0SWQsIGV0aFNpZ25SZXF1ZXN0LCBcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsICdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gdHguVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEoeyAuLi50eCQxLnRvSlNPTigpLFxuICAgICAgdHlwZTogdHgkMS50eXBlLFxuICAgICAgcixcbiAgICAgIHMsXG4gICAgICB2XG4gICAgfSwge1xuICAgICAgY29tbW9uOiB0eCQxLmNvbW1vblxuICAgIH0pO1xuICB9XG5cbiAgc2lnbk1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5zaWduUGVyc29uYWxNZXNzYWdlKHdpdGhBY2NvdW50LCBkYXRhKTtcbiAgfVxuXG4gIGFzeW5jIHNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIG1lc3NhZ2VIZXgpIHtcbiAgICBjb25zdCB1c2lnbmVkSGV4ID0gdXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlSGV4KTtcbiAgICBjb25zdCBoZFBhdGggPSBhd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3Mod2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKHVzaWduZWRIZXgsIFwiaGV4XCIpLCBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUucGVyc29uYWxNZXNzYWdlLCBoZFBhdGgsIHRoaXMueGZwLCByZXF1ZXN0SWQsIHVuZGVmaW5lZCwgd2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgdlxuICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUocmVxdWVzdElkLCBldGhTaWduUmVxdWVzdCwgXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCAnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoaXMgbWVzc2FnZSwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyk7XG4gICAgcmV0dXJuIFwiMHhcIiArIEJ1ZmZlci5jb25jYXQoW3IsIHMsIHZdKS50b1N0cmluZyhcImhleFwiKTtcbiAgfVxuXG4gIGFzeW5jIHNpZ25UeXBlZERhdGEod2l0aEFjY291bnQsIHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyh3aXRoQWNjb3VudCk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC52NCgpO1xuICAgIGNvbnN0IGV0aFNpZ25SZXF1ZXN0ID0gYmNVclJlZ2lzdHJ5RXRoLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkodHlwZWREYXRhKSwgXCJ1dGYtOFwiKSwgYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnR5cGVkRGF0YSwgaGRQYXRoLCB0aGlzLnhmcCwgcmVxdWVzdElkLCB1bmRlZmluZWQsIHdpdGhBY2NvdW50KTtcbiAgICBjb25zdCB7XG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnblJlcXVlc3QsIFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwgJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIGRhdGEsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO1xuICAgIHJldHVybiBcIjB4XCIgKyBCdWZmZXIuY29uY2F0KFtyLCBzLCB2XSkudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cblxuICBhc3luYyBfcGF0aEZyb21BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBpZiAodGhpcy5rZXlyaW5nTW9kZSA9PT0gS0VZUklOR19NT0RFLmhkKSB7XG4gICAgICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSB1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleGVzW2NoZWNrc3VtbWVkQWRkcmVzc107XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNQVhfSU5ERVg7IGkrKykge1xuICAgICAgICAgIGlmIChjaGVja3N1bW1lZEFkZHJlc3MgPT09IChhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBgJHt0aGlzLmhkUGF0aH0vJHt0aGlzLmNoaWxkcmVuUGF0aC5yZXBsYWNlKFwiKlwiLCBpbmRleC50b1N0cmluZygpKS5yZXBsYWNlKC9cXCovZywgXCIwXCIpfWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoZWNrc3VtbWVkQWRkcmVzcyA9IHV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoc1tjaGVja3N1bW1lZEFkZHJlc3NdO1xuXG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhZGRyZXNzXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gIH1cblxufVxuQmFzZUtleXJpbmcudHlwZSA9IGtleXJpbmdUeXBlO1xuXG5leHBvcnRzLkJhc2VLZXlyaW5nID0gQmFzZUtleXJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlLWV0aC1rZXlyaW5nLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO2Z1bmN0aW9uIGUoZSl7cmV0dXJuIGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZcImRlZmF1bHRcImluIGU/ZS5kZWZhdWx0OmV9T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHQscixpPWUocmVxdWlyZShcImhka2V5XCIpKSxzPXJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpLG49ZShyZXF1aXJlKFwicmxwXCIpKSxhPXJlcXVpcmUoXCJAZXRoZXJldW1qcy90eFwiKSxvPXJlcXVpcmUoXCJAa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS1ldGhcIiksaD1yZXF1aXJlKFwidXVpZFwiKTshZnVuY3Rpb24oZSl7ZS5oZD1cImhkXCIsZS5wdWJrZXk9XCJwdWJrZXlcIn0odHx8KHQ9e30pKSxmdW5jdGlvbihlKXtlLnN0YW5kYXJkPVwiYWNjb3VudC5zdGFuZGFyZFwiLGUubGVkZ2VyX2xpdmU9XCJhY2NvdW50LmxlZGdlcl9saXZlXCIsZS5sZWRnZXJfbGVnYWN5PVwiYWNjb3VudC5sZWRnZXJfbGVnYWN5XCJ9KHJ8fChyPXt9KSk7Y2xhc3MgY3tjb25zdHJ1Y3RvcihlKXt0aGlzLnZlcnNpb249MSx0aGlzLmdldEludGVyYWN0aW9uPSgpPT57dGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2V4dGVuZHM6IG1ldGhvZCBnZXRJbnRlcmFjdGlvbiBub3QgaW1wbGVtZW50ZWQsIHBsZWFzZSBleHRlbmQgQmFzZUtleXJpbmcgYnkgb3ZlcndyaXRpbmcgdGhpcyBtZXRob2QuXCIpfSx0aGlzLnR5cGU9XCJRUiBIYXJkd2FyZSBXYWxsZXQgRGV2aWNlXCIsdGhpcy5yZXF1ZXN0U2lnbmF0dXJlPWFzeW5jKGUsdCxyLGkpPT57Y29uc3Qgcz1hd2FpdCB0aGlzLmdldEludGVyYWN0aW9uKCkucmVxdWVzdFNpZ25hdHVyZSh0LHIsaSksbj1zLmdldFJlcXVlc3RJZCgpLGE9cy5nZXRTaWduYXR1cmUoKTtpZihuJiZoLnN0cmluZ2lmeShuKSE9PWUpdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IHJlYWQgc2lnbmF0dXJlIGVycm9yOiBtaXNtYXRjaGVkIHJlcXVlc3RJZFwiKTtyZXR1cm57cjphLnNsaWNlKDAsMzIpLHM6YS5zbGljZSgzMiw2NCksdjphLnNsaWNlKDY0KX19LHRoaXMuX19yZWFkQ3J5cHRvSERLZXk9ZT0+e3ZhciB0LGk7Y29uc3Qgcz1cIm0vXCIrZS5nZXRPcmlnaW4oKS5nZXRQYXRoKCksbj1udWxsPT0odD1lLmdldE9yaWdpbigpLmdldFNvdXJjZUZpbmdlcnByaW50KCkpP3ZvaWQgMDp0LnRvU3RyaW5nKFwiaGV4XCIpLGE9KG51bGw9PShpPWUuZ2V0Q2hpbGRyZW4oKSk/dm9pZCAwOmkuZ2V0UGF0aCgpKXx8XCIwLypcIixvPWUuZ2V0TmFtZSgpO2lmKGUuZ2V0Tm90ZSgpPT09ci5zdGFuZGFyZD90aGlzLmtleXJpbmdBY2NvdW50PXIuc3RhbmRhcmQ6ZS5nZXROb3RlKCk9PT1yLmxlZGdlcl9sZWdhY3kmJih0aGlzLmtleXJpbmdBY2NvdW50PXIubGVkZ2VyX2xlZ2FjeSksIW4pdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IGludmFsaWQgY3J5cHRvLWhka2V5LCBjYW5ub3QgZ2V0IHNvdXJjZSBmaW5nZXJwcmludFwiKTtjb25zdCBoPWUuZ2V0QmlwMzJLZXkoKTt0aGlzLnhmcD1uLHRoaXMueHB1Yj1oLHRoaXMuaGRQYXRoPXMsdGhpcy5jaGlsZHJlblBhdGg9YSx2b2lkIDAhPT1vJiZcIlwiIT09byYmKHRoaXMubmFtZT1vKSx0aGlzLmluaXRpYWxpemVkPSEwfSx0aGlzLl9fcmVhZENyeXB0b0FjY291bnQ9ZT0+e3ZhciB0LGk7Y29uc3Qgbj1udWxsPT0odD1lLmdldE1hc3RlckZpbmdlcnByaW50KCkpP3ZvaWQgMDp0LnRvU3RyaW5nKFwiaGV4XCIpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1hY2NvdW50LCBjYW5ub3QgZ2V0IG1hc3RlciBmaW5nZXJwcmludFwiKTt0aGlzLnhmcD1uLHRoaXMuaW5pdGlhbGl6ZWQ9ITA7bGV0IGE9ITE7Y29uc3Qgbz1lLmdldE91dHB1dERlc2NyaXB0b3JzKCk7aWYoIW98fDA9PT1vLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8tYWNjb3VudCwgbm8gY3J5cHRvIG91dHB1dCBmb3VuZFwiKTtpZihvLmxlbmd0aCU1IT0wKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBvbmx5IHN1cHBvcnQgNXggcHVia2V5IGFjY291bnRzIGZvciBub3dcIik7cmV0dXJuIG51bGw9PShpPWUuZ2V0T3V0cHV0RGVzY3JpcHRvcnMoKSl8fGkuZm9yRWFjaChlPT57dHJ5e2NvbnN0IHQ9ZS5nZXRIREtleSgpO2lmKHQpe2NvbnN0IGU9dC5nZXRLZXkoKSxpPVwiTS9cIit0LmdldE9yaWdpbigpLmdldFBhdGgoKSxuPVwiMHhcIitzLnB1YmxpY1RvQWRkcmVzcyhlLCEwKS50b1N0cmluZyhcImhleFwiKTt0aGlzLm5hbWU9dC5nZXROYW1lKCksdC5nZXROb3RlKCk9PT1yLmxlZGdlcl9saXZlJiYodGhpcy5rZXlyaW5nQWNjb3VudD1yLmxlZGdlcl9saXZlKSx2b2lkIDA9PT10aGlzLnBhdGhzW3MudG9DaGVja3N1bUFkZHJlc3MobildJiYoYT0hMCksdGhpcy5wYXRoc1tzLnRvQ2hlY2tzdW1BZGRyZXNzKG4pXT1pfX1jYXRjaChlKXt0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogXCIrZSl9fSksYX0sdGhpcy5nZXROYW1lPSgpPT50aGlzLm5hbWUsdGhpcy5zZXRBY2NvdW50VG9VbmxvY2s9ZT0+e3RoaXMudW5sb2NrZWRBY2NvdW50PXBhcnNlSW50KGUsMTApfSx0aGlzLl9fZ2V0Tm9ybWFsUGFnZT1hc3luYyBlPT57dGhpcy5wYWdlKz1lLHRoaXMucGFnZTw9MCYmKHRoaXMucGFnZT0xKTtjb25zdCB0PSh0aGlzLnBhZ2UtMSkqdGhpcy5wZXJQYWdlLHI9dCt0aGlzLnBlclBhZ2UsaT1bXTtmb3IobGV0IGU9dDtlPHI7ZSsrKXtjb25zdCB0PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpO2kucHVzaCh7YWRkcmVzczp0LGJhbGFuY2U6bnVsbCxpbmRleDplfSksdGhpcy5pbmRleGVzW3MudG9DaGVja3N1bUFkZHJlc3ModCldPWV9cmV0dXJuIGl9LHRoaXMuX19nZXRMZWRnZXJMaXZlUGFnZT1hc3luYyBlPT57Y29uc3QgdD0odGhpcy5wYWdlK2UtMSkqdGhpcy5wZXJQYWdlLHI9dCt0aGlzLnBlclBhZ2UsaT1bXTtmb3IobGV0IGU9dDtlPHI7ZSsrKXtjb25zdCB0PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpO2kucHVzaCh7YWRkcmVzczp0LGJhbGFuY2U6bnVsbCxpbmRleDplfSl9cmV0dXJuIHRoaXMucGFnZSs9ZSxpfSx0aGlzLl9fYWRkcmVzc0Zyb21JbmRleD1hc3luYyhlLHIpPT57aWYodGhpcy5rZXlyaW5nTW9kZT09PXQuaGQpe3RoaXMuY2hlY2tLZXlyaW5nKCksdGhpcy5oZGt8fCh0aGlzLmhkaz1pLmZyb21FeHRlbmRlZEtleSh0aGlzLnhwdWIpKTtjb25zdCB0PXRoaXMuY2hpbGRyZW5QYXRoLnJlcGxhY2UoXCIqXCIsU3RyaW5nKHIpKS5yZXBsYWNlKC9cXCovZyxcIjBcIiksbj10aGlzLmhkay5kZXJpdmUoYCR7ZX0vJHt0fWApLGE9XCIweFwiK3MucHVibGljVG9BZGRyZXNzKG4ucHVibGljS2V5LCEwKS50b1N0cmluZyhcImhleFwiKTtyZXR1cm4gcy50b0NoZWNrc3VtQWRkcmVzcyhhKX17Y29uc3QgZT1PYmplY3Qua2V5cyh0aGlzLnBhdGhzKVtyXTtpZihlKXJldHVybiBzLnRvQ2hlY2tzdW1BZGRyZXNzKGUpO3Rocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjcHVia2V5X2FjY291bnQubm9fZXhwZWN0ZWRfYWNjb3VudFwiKX19LHRoaXMucGFnZT0wLHRoaXMucGVyUGFnZT01LHRoaXMuYWNjb3VudHM9W10sdGhpcy5jdXJyZW50QWNjb3VudD0wLHRoaXMudW5sb2NrZWRBY2NvdW50PTAsdGhpcy5uYW1lPVwiUVIgSGFyZHdhcmVcIix0aGlzLmtleXJpbmdNb2RlPXQuaGQsdGhpcy5rZXlyaW5nQWNjb3VudD1yLnN0YW5kYXJkLHRoaXMuaW5pdGlhbGl6ZWQ9ITEsdGhpcy54ZnA9XCJcIix0aGlzLnhwdWI9XCJcIix0aGlzLmhkUGF0aD1cIlwiLHRoaXMuY2hpbGRyZW5QYXRoPVwiMC8qXCIsdGhpcy5pbmRleGVzPXt9LHRoaXMucGF0aHM9e30sdGhpcy5kZXNlcmlhbGl6ZShlKX1hc3luYyByZWFkS2V5cmluZygpe2NvbnN0IGU9YXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCgpO3RoaXMuc3luY0tleXJpbmcoZSl9c3luY0tleXJpbmcoZSl7ZS5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUeXBlKCk9PT1vLmV4dGVuZC5SZWdpc3RyeVR5cGVzLkNSWVBUT19IREtFWS5nZXRUeXBlKCk/KHRoaXMua2V5cmluZ01vZGU9dC5oZCx0aGlzLl9fcmVhZENyeXB0b0hES2V5KGUpKToodGhpcy5rZXlyaW5nTW9kZT10LnB1YmtleSx0aGlzLl9fcmVhZENyeXB0b0FjY291bnQoZSkpfWNoZWNrS2V5cmluZygpe2lmKCF0aGlzLnhmcHx8IXRoaXMueHB1Ynx8IXRoaXMuaGRQYXRoKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9rZXlyaW5nOiBrZXlyaW5nIG5vdCBmdWxmaWxsZWQsIHBsZWFzZSBjYWxsIGZ1bmN0aW9uIGByZWFkS2V5cmluZ2AgZmlyc3RseVwiKX1zZXJpYWxpemUoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtpbml0aWFsaXplZDp0aGlzLmluaXRpYWxpemVkLGFjY291bnRzOnRoaXMuYWNjb3VudHMsY3VycmVudEFjY291bnQ6dGhpcy5jdXJyZW50QWNjb3VudCxwYWdlOnRoaXMucGFnZSxwZXJQYWdlOnRoaXMucGVyUGFnZSxrZXlyaW5nQWNjb3VudDp0aGlzLmtleXJpbmdBY2NvdW50LGtleXJpbmdNb2RlOnRoaXMua2V5cmluZ01vZGUsbmFtZTp0aGlzLm5hbWUsdmVyc2lvbjp0aGlzLnZlcnNpb24seGZwOnRoaXMueGZwLHhwdWI6dGhpcy54cHViLGhkUGF0aDp0aGlzLmhkUGF0aCxjaGlsZHJlblBhdGg6dGhpcy5jaGlsZHJlblBhdGgsaW5kZXhlczp0aGlzLmluZGV4ZXMscGF0aHM6dGhpcy5wYXRoc30pfWRlc2VyaWFsaXplKGUpe2UmJih0aGlzLmFjY291bnRzPWUuYWNjb3VudHMsdGhpcy5jdXJyZW50QWNjb3VudD1lLmN1cnJlbnRBY2NvdW50LHRoaXMucGFnZT1lLnBhZ2UsdGhpcy5wZXJQYWdlPWUucGVyUGFnZSx0aGlzLm5hbWU9ZS5uYW1lLHRoaXMuaW5pdGlhbGl6ZWQ9ZS5pbml0aWFsaXplZCx0aGlzLmtleXJpbmdNb2RlPWUua2V5cmluZ01vZGV8fHQuaGQsdGhpcy5rZXlyaW5nQWNjb3VudD1lLmtleXJpbmdBY2NvdW50fHxyLnN0YW5kYXJkLHRoaXMueGZwPWUueGZwLHRoaXMueHB1Yj1lLnhwdWIsdGhpcy5oZFBhdGg9ZS5oZFBhdGgsdGhpcy5pbmRleGVzPWUuaW5kZXhlcyx0aGlzLnBhdGhzPWUucGF0aHMsdGhpcy5jaGlsZHJlblBhdGg9ZS5jaGlsZHJlblBhdGh8fFwiMC8qXCIpfXNldEN1cnJlbnRBY2NvdW50KGUpe3RoaXMuY3VycmVudEFjY291bnQ9ZX1nZXRDdXJyZW50QWNjb3VudCgpe3JldHVybiB0aGlzLmN1cnJlbnRBY2NvdW50fWdldEN1cnJlbnRBZGRyZXNzKCl7cmV0dXJuIHRoaXMuYWNjb3VudHNbdGhpcy5jdXJyZW50QWNjb3VudF19YXN5bmMgYWRkQWNjb3VudHMoZT0xKXtjb25zdCB0PXRoaXMudW5sb2NrZWRBY2NvdW50LHI9dCtlLGk9W107Zm9yKGxldCBlPXQ7ZTxyO2UrKyl7Y29uc3QgdD1hd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChcIm1cIixlKTtpLnB1c2godCksdGhpcy5wYWdlPTAsdGhpcy51bmxvY2tlZEFjY291bnQrK31yZXR1cm4gdGhpcy5hY2NvdW50cz10aGlzLmFjY291bnRzLmNvbmNhdChpKSx0aGlzLmFjY291bnRzfWdldEZpcnN0UGFnZSgpe3JldHVybiB0aGlzLnBhZ2U9MCx0aGlzLl9fZ2V0UGFnZSgxKX1nZXROZXh0UGFnZSgpe3JldHVybiB0aGlzLl9fZ2V0UGFnZSgxKX1nZXRQcmV2aW91c1BhZ2UoKXtyZXR1cm4gdGhpcy5fX2dldFBhZ2UoLTEpfWFzeW5jIF9fZ2V0UGFnZShlKXtyZXR1cm4gdGhpcy5pbml0aWFsaXplZHx8YXdhaXQgdGhpcy5yZWFkS2V5cmluZygpLHRoaXMua2V5cmluZ01vZGU9PT10LmhkP3RoaXMuX19nZXROb3JtYWxQYWdlKGUpOnRoaXMuX19nZXRMZWRnZXJMaXZlUGFnZShlKX1nZXRBY2NvdW50cygpe3JldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hY2NvdW50cyl9cmVtb3ZlQWNjb3VudChlKXtpZighdGhpcy5hY2NvdW50cy5tYXAoZT0+ZS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhlLnRvTG93ZXJDYXNlKCkpKXRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2V9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTt0aGlzLmFjY291bnRzPXRoaXMuYWNjb3VudHMuZmlsdGVyKHQ9PnQudG9Mb3dlckNhc2UoKSE9PWUudG9Mb3dlckNhc2UoKSl9YXN5bmMgc2lnblRyYW5zYWN0aW9uKGUsdCl7Y29uc3Qgcj0wPT09dC50eXBlP28uRGF0YVR5cGUudHJhbnNhY3Rpb246by5EYXRhVHlwZS50eXBlZFRyYW5zYWN0aW9uO2xldCBpO2k9MD09PXQudHlwZT9CdWZmZXIuZnJvbShuLmVuY29kZSh0LmdldE1lc3NhZ2VUb1NpZ24oITEpKSk6dC5nZXRNZXNzYWdlVG9TaWduKCExKTtjb25zdCBzPWF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhlKSxjPU51bWJlcih0LmNvbW1vbi5jaGFpbklkKCkpLGQ9aC52NCgpLHU9by5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KGkscixzLHRoaXMueGZwLGQsYykse3I6ZyxzOnksdjpwfT1hd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUoZCx1LFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoZSB0cmFuc2FjdGlvbiwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyk7cmV0dXJuIGEuVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEoey4uLnQudG9KU09OKCksdHlwZTp0LnR5cGUscjpnLHM6eSx2OnB9LHtjb21tb246dC5jb21tb259KX1zaWduTWVzc2FnZShlLHQpe3JldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2UoZSx0KX1hc3luYyBzaWduUGVyc29uYWxNZXNzYWdlKGUsdCl7Y29uc3Qgcj1zLnN0cmlwSGV4UHJlZml4KHQpLGk9YXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGUpLG49aC52NCgpLGE9by5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKHIsXCJoZXhcIiksby5EYXRhVHlwZS5wZXJzb25hbE1lc3NhZ2UsaSx0aGlzLnhmcCxuLHZvaWQgMCxlKSx7cjpjLHM6ZCx2OnV9PWF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShuLGEsXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhpcyBtZXNzYWdlLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtyZXR1cm5cIjB4XCIrQnVmZmVyLmNvbmNhdChbYyxkLHVdKS50b1N0cmluZyhcImhleFwiKX1hc3luYyBzaWduVHlwZWREYXRhKGUsdCl7Y29uc3Qgcj1hd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoZSksaT1oLnY0KCkscz1vLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkodCksXCJ1dGYtOFwiKSxvLkRhdGFUeXBlLnR5cGVkRGF0YSxyLHRoaXMueGZwLGksdm9pZCAwLGUpLHtyOm4sczphLHY6Y309YXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKGkscyxcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIGRhdGEsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO3JldHVyblwiMHhcIitCdWZmZXIuY29uY2F0KFtuLGEsY10pLnRvU3RyaW5nKFwiaGV4XCIpfWFzeW5jIF9wYXRoRnJvbUFkZHJlc3MoZSl7aWYodGhpcy5rZXlyaW5nTW9kZT09PXQuaGQpe2NvbnN0IHQ9cy50b0NoZWNrc3VtQWRkcmVzcyhlKTtsZXQgcj10aGlzLmluZGV4ZXNbdF07aWYodm9pZCAwPT09cilmb3IobGV0IGU9MDtlPDFlMztlKyspaWYodD09PWF3YWl0IHRoaXMuX19hZGRyZXNzRnJvbUluZGV4KFwibVwiLGUpKXtyPWU7YnJlYWt9aWYodm9pZCAwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7cmV0dXJuYCR7dGhpcy5oZFBhdGh9LyR7dGhpcy5jaGlsZHJlblBhdGgucmVwbGFjZShcIipcIixyLnRvU3RyaW5nKCkpLnJlcGxhY2UoL1xcKi9nLFwiMFwiKX1gfXtjb25zdCB0PXMudG9DaGVja3N1bUFkZHJlc3MoZSkscj10aGlzLnBhdGhzW3RdO2lmKHZvaWQgMD09PXIpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhZGRyZXNzXCIpO3JldHVybiByfX19Yy50eXBlPVwiUVIgSGFyZHdhcmUgV2FsbGV0IERldmljZVwiLGV4cG9ydHMuQmFzZUtleXJpbmc9Yztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtZXRoLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiXG4ndXNlIHN0cmljdCdcblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYXNlLWV0aC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYmFzZS1ldGgta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMnKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnV0aWxzID0gZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IHZvaWQgMDtcbi8qKlxuICogUkxQIEVuY29kaW5nIGJhc2VkIG9uIGh0dHBzOi8vZXRoLndpa2kvZW4vZnVuZGFtZW50YWxzL3JscFxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBpbiBkYXRhLCBjb252ZXJ0cyBpdCB0byBVaW50OEFycmF5IGlmIG5vdCxcbiAqIGFuZCBhZGRzIGEgbGVuZ3RoIGZvciByZWN1cnNpb24uXG4gKiBAcGFyYW0gaW5wdXQgV2lsbCBiZSBjb252ZXJ0ZWQgdG8gVWludDhBcnJheVxuICogQHJldHVybnMgVWludDhBcnJheSBvZiBlbmNvZGVkIGRhdGFcbiAqKi9cbmZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goZW5jb2RlKGlucHV0W2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmID0gY29uY2F0Qnl0ZXMoLi4ub3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKGVuY29kZUxlbmd0aChidWYubGVuZ3RoLCAxOTIpLCBidWYpO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dEJ1ZiA9IHRvQnl0ZXMoaW5wdXQpO1xuICAgIGlmIChpbnB1dEJ1Zi5sZW5ndGggPT09IDEgJiYgaW5wdXRCdWZbMF0gPCAxMjgpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0QnVmO1xuICAgIH1cbiAgICByZXR1cm4gY29uY2F0Qnl0ZXMoZW5jb2RlTGVuZ3RoKGlucHV0QnVmLmxlbmd0aCwgMTI4KSwgaW5wdXRCdWYpO1xufVxuZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG4vKipcbiAqIFNsaWNlcyBhIFVpbnQ4QXJyYXksIHRocm93cyBpZiB0aGUgc2xpY2UgZ29lcyBvdXQtb2YtYm91bmRzIG9mIHRoZSBVaW50OEFycmF5LlxuICogRS5nLiBgc2FmZVNsaWNlKGhleFRvQnl0ZXMoJ2FhJyksIDEsIDIpYCB3aWxsIHRocm93LlxuICogQHBhcmFtIGlucHV0XG4gKiBAcGFyYW0gc3RhcnRcbiAqIEBwYXJhbSBlbmRcbiAqL1xuZnVuY3Rpb24gc2FmZVNsaWNlKGlucHV0LCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQIChzYWZlU2xpY2UpOiBlbmQgc2xpY2Ugb2YgVWludDhBcnJheSBvdXQtb2YtYm91bmRzJyk7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dC5zbGljZShzdGFydCwgZW5kKTtcbn1cbi8qKlxuICogUGFyc2UgaW50ZWdlcnMuIENoZWNrIGlmIHRoZXJlIGlzIG5vIGxlYWRpbmcgemVyb3NcbiAqIEBwYXJhbSB2IFRoZSB2YWx1ZSB0byBwYXJzZVxuICovXG5mdW5jdGlvbiBkZWNvZGVMZW5ndGgodikge1xuICAgIGlmICh2WzBdID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4dHJhIHplcm9zJyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUhleEJ5dGUoYnl0ZXNUb0hleCh2KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgobGVuLCBvZmZzZXQpIHtcbiAgICBpZiAobGVuIDwgNTYpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbbGVuICsgb2Zmc2V0XSk7XG4gICAgfVxuICAgIGNvbnN0IGhleExlbmd0aCA9IG51bWJlclRvSGV4KGxlbik7XG4gICAgY29uc3QgbExlbmd0aCA9IGhleExlbmd0aC5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IG51bWJlclRvSGV4KG9mZnNldCArIDU1ICsgbExlbmd0aCk7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShoZXhUb0J5dGVzKGZpcnN0Qnl0ZSArIGhleExlbmd0aCkpO1xufVxuZnVuY3Rpb24gZGVjb2RlKGlucHV0LCBzdHJlYW0gPSBmYWxzZSkge1xuICAgIGlmICghaW5wdXQgfHwgaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oW10pO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dEJ5dGVzID0gdG9CeXRlcyhpbnB1dCk7XG4gICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoaW5wdXRCeXRlcyk7XG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gZGVjb2RlZDtcbiAgICB9XG4gICAgaWYgKGRlY29kZWQucmVtYWluZGVyLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiByZW1haW5kZXIgbXVzdCBiZSB6ZXJvJyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLmRhdGE7XG59XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbi8qKiBEZWNvZGUgYW4gaW5wdXQgd2l0aCBSTFAgKi9cbmZ1bmN0aW9uIF9kZWNvZGUoaW5wdXQpIHtcbiAgICBsZXQgbGVuZ3RoLCBsbGVuZ3RoLCBkYXRhLCBpbm5lclJlbWFpbmRlciwgZDtcbiAgICBjb25zdCBkZWNvZGVkID0gW107XG4gICAgY29uc3QgZmlyc3RCeXRlID0gaW5wdXRbMF07XG4gICAgaWYgKGZpcnN0Qnl0ZSA8PSAweDdmKSB7XG4gICAgICAgIC8vIGEgc2luZ2xlIGJ5dGUgd2hvc2UgdmFsdWUgaXMgaW4gdGhlIFsweDAwLCAweDdmXSByYW5nZSwgdGhhdCBieXRlIGlzIGl0cyBvd24gUkxQIGVuY29kaW5nLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogaW5wdXQuc2xpY2UoMCwgMSksXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKDEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiNykge1xuICAgICAgICAvLyBzdHJpbmcgaXMgMC01NSBieXRlcyBsb25nLiBBIHNpbmdsZSBieXRlIHdpdGggdmFsdWUgMHg4MCBwbHVzIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyBmb2xsb3dlZCBieSB0aGUgc3RyaW5nXG4gICAgICAgIC8vIFRoZSByYW5nZSBvZiB0aGUgZmlyc3QgYnl0ZSBpcyBbMHg4MCwgMHhiN11cbiAgICAgICAgbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHg3ZjtcbiAgICAgICAgLy8gc2V0IDB4ODAgbnVsbCB0byAwXG4gICAgICAgIGlmIChmaXJzdEJ5dGUgPT09IDB4ODApIHtcbiAgICAgICAgICAgIGRhdGEgPSBVaW50OEFycmF5LmZyb20oW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9IHNhZmVTbGljZShpbnB1dCwgMSwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID09PSAyICYmIGRhdGFbMF0gPCAweDgwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQIGVuY29kaW5nOiBpbnZhbGlkIHByZWZpeCwgc2luZ2xlIGJ5dGUgPCAweDgwIGFyZSBub3QgcHJlZml4ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4YmYpIHtcbiAgICAgICAgLy8gc3RyaW5nIGlzIGdyZWF0ZXIgdGhhbiA1NSBieXRlcyBsb25nLiBBIHNpbmdsZSBieXRlIHdpdGggdGhlIHZhbHVlICgweGI3IHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgbGVuZ3RoKSxcbiAgICAgICAgLy8gZm9sbG93ZWQgYnkgdGhlIGxlbmd0aCwgZm9sbG93ZWQgYnkgdGhlIHN0cmluZ1xuICAgICAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhiNjtcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCAtIDEgPCBsbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBub3QgZW5vdWdoIGJ5dGVzIGZvciBzdHJpbmcgbGVuZ3RoJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoID0gZGVjb2RlTGVuZ3RoKHNhZmVTbGljZShpbnB1dCwgMSwgbGxlbmd0aCkpO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiBleHBlY3RlZCBzdHJpbmcgbGVuZ3RoIHRvIGJlIGdyZWF0ZXIgdGhhbiA1NScpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEgPSBzYWZlU2xpY2UoaW5wdXQsIGxsZW5ndGgsIGxlbmd0aCArIGxsZW5ndGgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UobGVuZ3RoICsgbGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGY3KSB7XG4gICAgICAgIC8vIGEgbGlzdCBiZXR3ZWVuIDAtNTUgYnl0ZXMgbG9uZ1xuICAgICAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGJmO1xuICAgICAgICBpbm5lclJlbWFpbmRlciA9IHNhZmVTbGljZShpbnB1dCwgMSwgbGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgZCA9IF9kZWNvZGUoaW5uZXJSZW1haW5kZXIpO1xuICAgICAgICAgICAgZGVjb2RlZC5wdXNoKGQuZGF0YSk7XG4gICAgICAgICAgICBpbm5lclJlbWFpbmRlciA9IGQucmVtYWluZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkZWNvZGVkLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gYSBsaXN0IG92ZXIgNTUgYnl0ZXMgbG9uZ1xuICAgICAgICBsbGVuZ3RoID0gZmlyc3RCeXRlIC0gMHhmNjtcbiAgICAgICAgbGVuZ3RoID0gZGVjb2RlTGVuZ3RoKHNhZmVTbGljZShpbnB1dCwgMSwgbGxlbmd0aCkpO1xuICAgICAgICBpZiAobGVuZ3RoIDwgNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGVuY29kZWQgbGlzdCB0b28gc2hvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IGxsZW5ndGggKyBsZW5ndGg7XG4gICAgICAgIGlmICh0b3RhbExlbmd0aCA+IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogdG90YWwgbGVuZ3RoIGlzIGxhcmdlciB0aGFuIHRoZSBkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJSZW1haW5kZXIgPSBzYWZlU2xpY2UoaW5wdXQsIGxsZW5ndGgsIHRvdGFsTGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGlubmVyUmVtYWluZGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgZCA9IF9kZWNvZGUoaW5uZXJSZW1haW5kZXIpO1xuICAgICAgICAgICAgZGVjb2RlZC5wdXNoKGQuZGF0YSk7XG4gICAgICAgICAgICBpbm5lclJlbWFpbmRlciA9IGQucmVtYWluZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkZWNvZGVkLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZSh0b3RhbExlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxufVxuY29uc3QgY2FjaGVkSGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF92LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbmZ1bmN0aW9uIGJ5dGVzVG9IZXgodWludDhhKSB7XG4gICAgLy8gUHJlLWNhY2hpbmcgY2hhcnMgd2l0aCBgY2FjaGVkSGV4ZXNgIHNwZWVkcyB0aGlzIHVwIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBjYWNoZWRIZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZnVuY3Rpb24gcGFyc2VIZXhCeXRlKGhleEJ5dGUpIHtcbiAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgIHJldHVybiBieXRlO1xufVxuLy8gQ2FjaGluZyBzbG93cyBpdCBkb3duIDItM3hcbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvQnl0ZXM6IGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleFRvQnl0ZXM6IHJlY2VpdmVkIGludmFsaWQgdW5wYWRkZWQgaGV4Jyk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGFycmF5W2ldID0gcGFyc2VIZXhCeXRlKGhleC5zbGljZShqLCBqICsgMikpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vKiogQ29uY2F0ZW5hdGVzIHR3byBVaW50OEFycmF5cyBpbnRvIG9uZS4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmIChhcnJheXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gYXJyYXlzWzBdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGEsIGFycikgPT4gYSArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gYXJyYXlzW2ldO1xuICAgICAgICByZXN1bHQuc2V0KGFyciwgcGFkKTtcbiAgICAgICAgcGFkICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB1dGY4VG9CeXRlcyh1dGYpIHtcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHV0Zik7XG59XG4vKiogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBpdHMgaGV4YWRlY2ltYWwgdmFsdWUgKi9cbmZ1bmN0aW9uIG51bWJlclRvSGV4KGludGVnZXIpIHtcbiAgICBpZiAoaW50ZWdlciA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGludGVnZXIgYXMgYXJndW1lbnQsIG11c3QgYmUgdW5zaWduZWQhJyk7XG4gICAgfVxuICAgIGNvbnN0IGhleCA9IGludGVnZXIudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICUgMiA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbi8qKiBQYWQgYSBzdHJpbmcgdG8gYmUgZXZlbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKGEpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggJSAyID8gYDAke2F9YCA6IGE7XG59XG4vKiogQ2hlY2sgaWYgYSBzdHJpbmcgaXMgcHJlZml4ZWQgYnkgMHggKi9cbmZ1bmN0aW9uIGlzSGV4UHJlZml4ZWQoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPj0gMiAmJiBzdHJbMF0gPT09ICcwJyAmJiBzdHJbMV0gPT09ICd4Jztcbn1cbi8qKiBSZW1vdmVzIDB4IGZyb20gYSBnaXZlbiBTdHJpbmcgKi9cbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICByZXR1cm4gaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xufVxuLyoqIFRyYW5zZm9ybSBhbnl0aGluZyBpbnRvIGEgVWludDhBcnJheSAqL1xuZnVuY3Rpb24gdG9CeXRlcyh2KSB7XG4gICAgaWYgKHYgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChpc0hleFByZWZpeGVkKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyhwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgodikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXModik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHYgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIGlmICghdikge1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXgodikpO1xuICAgIH1cbiAgICBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndG9CeXRlczogcmVjZWl2ZWQgdW5zdXBwb3J0ZWQgdHlwZSAnICsgdHlwZW9mIHYpO1xufVxuZXhwb3J0cy51dGlscyA9IHtcbiAgICBieXRlc1RvSGV4LFxuICAgIGNvbmNhdEJ5dGVzLFxuICAgIGhleFRvQnl0ZXMsXG4gICAgdXRmOFRvQnl0ZXMsXG59O1xuY29uc3QgUkxQID0geyBlbmNvZGUsIGRlY29kZSB9O1xuZXhwb3J0cy5kZWZhdWx0ID0gUkxQO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXG4ndXNlIHN0cmljdCdcblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgYmFzZUV0aEtleXJpbmcgPSByZXF1aXJlKCdAa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nJyk7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgb2JzU3RvcmUgPSByZXF1aXJlKCdAbWV0YW1hc2svb2JzLXN0b3JlJyk7XG52YXIgYmNVclJlZ2lzdHJ5RXRoID0gcmVxdWlyZSgnQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoJyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcbnZhciB0eCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4Jyk7XG52YXIgcmxwID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3JscCcpKTtcblxuY2xhc3MgTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyIGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNsZWFuU3luY0xpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWhka2V5XCIpO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtYWNjb3VudFwiKTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwia2V5c3RvbmUtc3luY19jYW5jZWxcIik7XG4gICAgfTtcblxuICAgIHRoaXMuY2xlYW5TaWduTGlzdGVuZXJzID0gcmVxdWVzdElkID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGAke3JlcXVlc3RJZH0tc2lnbmVkYCk7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhgJHtyZXF1ZXN0SWR9LWNhbmNlbGVkYCk7XG4gICAgfTtcblxuICAgIHRoaXMucmVhZENyeXB0b0hES2V5T3JDcnlwdG9BY2NvdW50ID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgc3luYzoge1xuICAgICAgICAgICAgcmVhZGluZzogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIiwgY2JvciA9PiB7XG4gICAgICAgICAgY29uc3QgY3J5cHRvSERLZXkgPSBiY1VyUmVnaXN0cnlFdGguQ3J5cHRvSERLZXkuZnJvbUNCT1IoQnVmZmVyLmZyb20oY2JvciwgXCJoZXhcIikpO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoY3J5cHRvSERLZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIsIGNib3IgPT4ge1xuICAgICAgICAgIGNvbnN0IGNyeXB0b0FjY291bnQgPSBiY1VyUmVnaXN0cnlFdGguQ3J5cHRvQWNjb3VudC5mcm9tQ0JPUihCdWZmZXIuZnJvbShjYm9yLCBcImhleFwiKSk7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShjcnlwdG9BY2NvdW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX2NhbmNlbFwiLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIktleXN0b25lRXJyb3Ijc3luY19jYW5jZWwuIFN5bmMgcHJvY2VzcyBjYW5jZWxlZCwgcGxlYXNlIHJldHJ5XCIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJtaXRDcnlwdG9IREtleSA9IGNib3IgPT4ge1xuICAgICAgdGhpcy5lbWl0KFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWhka2V5XCIsIGNib3IpO1xuICAgIH07XG5cbiAgICB0aGlzLnN1Ym1pdENyeXB0b0FjY291bnQgPSBjYm9yID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIsIGNib3IpO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbmNlbFN5bmMgPSAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoXCJrZXlzdG9uZS1zeW5jX2NhbmNlbFwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlID0gKHNpZ25SZXF1ZXN0LCByZXF1ZXN0VGl0bGUsIHJlcXVlc3REZXNjcmlwdGlvbikgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdXIgPSBzaWduUmVxdWVzdC50b1VSKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZEJ1ZmZlciA9IHNpZ25SZXF1ZXN0LmdldFJlcXVlc3RJZCgpO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkLnN0cmluZ2lmeShyZXF1ZXN0SWRCdWZmZXIpO1xuICAgICAgICBjb25zdCBzaWduUGF5bG9hZCA9IHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgdHlwZTogdXIudHlwZSxcbiAgICAgICAgICAgIGNib3I6IHVyLmNib3IudG9TdHJpbmcoXCJoZXhcIilcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpdGxlOiByZXF1ZXN0VGl0bGUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHJlcXVlc3REZXNjcmlwdGlvblxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICBzaWduOiB7XG4gICAgICAgICAgICByZXF1ZXN0OiBzaWduUGF5bG9hZFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25jZShgJHtyZXF1ZXN0SWR9LXNpZ25lZGAsIGNib3IgPT4ge1xuICAgICAgICAgIGNvbnN0IGV0aFNpZ25hdHVyZSA9IGJjVXJSZWdpc3RyeUV0aC5FVEhTaWduYXR1cmUuZnJvbUNCT1IoQnVmZmVyLmZyb20oY2JvciwgXCJoZXhcIikpO1xuICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoZXRoU2lnbmF0dXJlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25jZShgJHtyZXF1ZXN0SWR9LWNhbmNlbGVkYCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI1R4X2NhbmNlbGVkLiBTaWduaW5nIGNhbmNlbGVkLCBwbGVhc2UgcmV0cnlcIikpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnN1Ym1pdFNpZ25hdHVyZSA9IChyZXF1ZXN0SWQsIGNib3IpID0+IHtcbiAgICAgIHRoaXMuZW1pdChgJHtyZXF1ZXN0SWR9LXNpZ25lZGAsIGNib3IpO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbmNlbFJlcXVlc3RTaWduYXR1cmUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBzaWduUGF5bG9hZCA9IHRoaXMubWVtU3RvcmUuZ2V0U3RhdGUoKS5zaWduLnJlcXVlc3Q7XG5cbiAgICAgIGlmIChzaWduUGF5bG9hZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH0gPSBzaWduUGF5bG9hZDtcbiAgICAgICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgc2lnbjoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChgJHtyZXF1ZXN0SWR9LWNhbmNlbGVkYCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmNsZWFuU3luY0xpc3RlbmVycygpO1xuICAgICAgY29uc3Qgc2lnblBheWxvYWQgPSB0aGlzLm1lbVN0b3JlLmdldFN0YXRlKCkuc2lnbi5yZXF1ZXN0O1xuXG4gICAgICBpZiAoc2lnblBheWxvYWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICB9ID0gc2lnblBheWxvYWQ7XG4gICAgICAgIHRoaXMuY2xlYW5TaWduTGlzdGVuZXJzKHJlcXVlc3RJZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0U3RhdGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgc3luYzoge1xuICAgICAgICAgIHJlYWRpbmc6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIHNpZ246IHt9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKE1ldGFtYXNrSW50ZXJhY3Rpb25Qcm92aWRlci5pbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIE1ldGFtYXNrSW50ZXJhY3Rpb25Qcm92aWRlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICB0aGlzLm1lbVN0b3JlID0gbmV3IG9ic1N0b3JlLk9ic2VydmFibGVTdG9yZSh7XG4gICAgICBzeW5jOiB7XG4gICAgICAgIHJlYWRpbmc6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc2lnbjoge30sXG4gICAgICBfdmVyc2lvbjogMVxuICAgIH0pO1xuICAgIE1ldGFtYXNrSW50ZXJhY3Rpb25Qcm92aWRlci5pbnN0YW5jZSA9IHRoaXM7XG4gIH1cblxufVxuXG5jbGFzcyBNZXRhTWFza0tleXJpbmcgZXh0ZW5kcyBiYXNlRXRoS2V5cmluZy5CYXNlS2V5cmluZyB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKTtcblxuICAgIHRoaXMuZ2V0SW50ZXJhY3Rpb24gPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IE1ldGFtYXNrSW50ZXJhY3Rpb25Qcm92aWRlcigpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0U3RvcmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmdldEludGVyYWN0aW9uKCkucmVzZXQoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRNZW1TdG9yZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmdldEludGVyYWN0aW9uKCkubWVtU3RvcmU7XG4gICAgfTtcblxuICAgIHRoaXMucmVtb3ZlQWNjb3VudCA9IGFkZHJlc3MgPT4ge1xuICAgICAgaWYgKCF0aGlzLmFjY291bnRzLm1hcChhID0+IGEudG9Mb3dlckNhc2UoKSkuaW5jbHVkZXMoYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFkZHJlc3MgJHthZGRyZXNzfSBub3QgZm91bmQgaW4gdGhpcyBrZXlyaW5nYCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWNjb3VudHMgPSB0aGlzLmFjY291bnRzLmZpbHRlcihhID0+IGEudG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICB9O1xuXG4gICAgdGhpcy5mb3JnZXREZXZpY2UgPSAoKSA9PiB7XG4gICAgICAvL2NvbW1vbiBwcm9wc1xuICAgICAgdGhpcy5wYWdlID0gMDtcbiAgICAgIHRoaXMucGVyUGFnZSA9IDU7XG4gICAgICB0aGlzLmFjY291bnRzID0gW107XG4gICAgICB0aGlzLmN1cnJlbnRBY2NvdW50ID0gMDtcbiAgICAgIHRoaXMubmFtZSA9IFwiUVIgSGFyZHdhcmVcIjtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy9oZCBwcm9wcztcblxuICAgICAgdGhpcy54ZnAgPSBcIlwiO1xuICAgICAgdGhpcy54cHViID0gXCJcIjtcbiAgICAgIHRoaXMuaGRQYXRoID0gXCJcIjtcbiAgICAgIHRoaXMuaW5kZXhlcyA9IHt9O1xuICAgICAgdGhpcy5oZGsgPSB1bmRlZmluZWQ7IC8vcHVia2V5IHByb3BzO1xuXG4gICAgICB0aGlzLnBhdGhzID0ge307XG4gICAgfTtcblxuICAgIHRoaXMuc3VibWl0Q3J5cHRvSERLZXkgPSB0aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0Q3J5cHRvSERLZXk7XG4gICAgdGhpcy5zdWJtaXRDcnlwdG9BY2NvdW50ID0gdGhpcy5nZXRJbnRlcmFjdGlvbigpLnN1Ym1pdENyeXB0b0FjY291bnQ7XG4gICAgdGhpcy5zdWJtaXRTaWduYXR1cmUgPSB0aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0U2lnbmF0dXJlO1xuICAgIHRoaXMuY2FuY2VsU3luYyA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5jYW5jZWxTeW5jO1xuICAgIHRoaXMuY2FuY2VsU2lnblJlcXVlc3QgPSB0aGlzLmdldEludGVyYWN0aW9uKCkuY2FuY2VsUmVxdWVzdFNpZ25hdHVyZTtcblxuICAgIGlmIChNZXRhTWFza0tleXJpbmcuaW5zdGFuY2UpIHtcbiAgICAgIE1ldGFNYXNrS2V5cmluZy5pbnN0YW5jZS5kZXNlcmlhbGl6ZShvcHRzKTtcbiAgICAgIHJldHVybiBNZXRhTWFza0tleXJpbmcuaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgTWV0YU1hc2tLZXlyaW5nLmluc3RhbmNlID0gdGhpcztcbiAgfVxuXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCB0eCQxKSB7XG4gICAgY29uc3QgZGF0YVR5cGUgPSB0eCQxLnR5cGUgPT09IDAgPyBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUudHJhbnNhY3Rpb24gOiBiY1VyUmVnaXN0cnlFdGguRGF0YVR5cGUudHlwZWRUcmFuc2FjdGlvbjtcbiAgICBsZXQgbWVzc2FnZVRvU2lnbjtcblxuICAgIGlmICh0eCQxLnR5cGUgPT09IDApIHtcbiAgICAgIG1lc3NhZ2VUb1NpZ24gPSBybHAuZW5jb2RlKHR4JDEuZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlVG9TaWduID0gdHgkMS5nZXRNZXNzYWdlVG9TaWduKGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBoZFBhdGggPSBhd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgY29uc3QgY2hhaW5JZCA9IHR4JDEuY29tbW9uLmNoYWluSWQoKTtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkLnY0KCk7XG4gICAgY29uc3QgZXRoU2lnblJlcXVlc3QgPSBiY1VyUmVnaXN0cnlFdGguRXRoU2lnblJlcXVlc3QuY29uc3RydWN0RVRIUmVxdWVzdChtZXNzYWdlVG9TaWduLCBkYXRhVHlwZSwgaGRQYXRoLCB0aGlzLnhmcCwgcmVxdWVzdElkLCBjaGFpbklkLCBhZGRyZXNzKTtcbiAgICBjb25zdCB7XG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnblJlcXVlc3QsIFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwgJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGUgdHJhbnNhY3Rpb24sIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO1xuICAgIGNvbnN0IHR4SnNvbiA9IHR4JDEudG9KU09OKCk7XG4gICAgdHhKc29uLnYgPSB2O1xuICAgIHR4SnNvbi5zID0gcztcbiAgICB0eEpzb24uciA9IHI7XG4gICAgdHhKc29uLnR5cGUgPSB0eCQxLnR5cGU7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0eC5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YSh0eEpzb24sIHtcbiAgICAgIGNvbW1vbjogdHgkMS5jb21tb25cbiAgICB9KTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cblxufVxuTWV0YU1hc2tLZXlyaW5nLnR5cGUgPSBiYXNlRXRoS2V5cmluZy5CYXNlS2V5cmluZy50eXBlO1xuXG5leHBvcnRzLk1ldGFNYXNrS2V5cmluZyA9IE1ldGFNYXNrS2V5cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nLmNqcy5kZXZlbG9wbWVudC5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciBlLHQ9cmVxdWlyZShcIkBrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmdcIikscz1yZXF1aXJlKFwiZXZlbnRzXCIpLG49cmVxdWlyZShcIkBtZXRhbWFzay9vYnMtc3RvcmVcIiksaT1yZXF1aXJlKFwiQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoXCIpLHI9cmVxdWlyZShcInV1aWRcIiksYz1yZXF1aXJlKFwiQGV0aGVyZXVtanMvdHhcIiksbz0oZT1yZXF1aXJlKFwicmxwXCIpKSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lLmRlZmF1bHQ6ZTtjbGFzcyBhIGV4dGVuZHMgcy5FdmVudEVtaXR0ZXJ7Y29uc3RydWN0b3IoKXtpZihzdXBlcigpLHRoaXMuY2xlYW5TeW5jTGlzdGVuZXJzPSgpPT57dGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIiksdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtYWNjb3VudFwiKSx0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcImtleXN0b25lLXN5bmNfY2FuY2VsXCIpfSx0aGlzLmNsZWFuU2lnbkxpc3RlbmVycz1lPT57dGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZStcIi1zaWduZWRcIiksdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZStcIi1jYW5jZWxlZFwiKX0sdGhpcy5yZWFkQ3J5cHRvSERLZXlPckNyeXB0b0FjY291bnQ9KCk9Pm5ldyBQcm9taXNlKChlLHQpPT57dGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7c3luYzp7cmVhZGluZzohMH19KSx0aGlzLm9uKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWhka2V5XCIsdD0+e2NvbnN0IHM9aS5DcnlwdG9IREtleS5mcm9tQ0JPUihCdWZmZXIuZnJvbSh0LFwiaGV4XCIpKTt0aGlzLnJlc2V0U3RhdGUoKSxlKHMpfSksdGhpcy5vbihcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIsdD0+e2NvbnN0IHM9aS5DcnlwdG9BY2NvdW50LmZyb21DQk9SKEJ1ZmZlci5mcm9tKHQsXCJoZXhcIikpO3RoaXMucmVzZXRTdGF0ZSgpLGUocyl9KSx0aGlzLm9uKFwia2V5c3RvbmUtc3luY19jYW5jZWxcIiwoKT0+e3RoaXMucmVzZXRTdGF0ZSgpLHQobmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNzeW5jX2NhbmNlbC4gU3luYyBwcm9jZXNzIGNhbmNlbGVkLCBwbGVhc2UgcmV0cnlcIikpfSl9KSx0aGlzLnN1Ym1pdENyeXB0b0hES2V5PWU9Pnt0aGlzLmVtaXQoXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIixlKX0sdGhpcy5zdWJtaXRDcnlwdG9BY2NvdW50PWU9Pnt0aGlzLmVtaXQoXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtYWNjb3VudFwiLGUpfSx0aGlzLmNhbmNlbFN5bmM9KCk9Pnt0aGlzLmVtaXQoXCJrZXlzdG9uZS1zeW5jX2NhbmNlbFwiKX0sdGhpcy5yZXF1ZXN0U2lnbmF0dXJlPShlLHQscyk9Pm5ldyBQcm9taXNlKChuLGMpPT57Y29uc3Qgbz1lLnRvVVIoKSxhPWUuZ2V0UmVxdWVzdElkKCksaD1yLnN0cmluZ2lmeShhKSx1PXtyZXF1ZXN0SWQ6aCxwYXlsb2FkOnt0eXBlOm8udHlwZSxjYm9yOm8uY2Jvci50b1N0cmluZyhcImhleFwiKX0sdGl0bGU6dCxkZXNjcmlwdGlvbjpzfTt0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtzaWduOntyZXF1ZXN0OnV9fSksdGhpcy5vbmNlKGgrXCItc2lnbmVkXCIsZT0+e2NvbnN0IHQ9aS5FVEhTaWduYXR1cmUuZnJvbUNCT1IoQnVmZmVyLmZyb20oZSxcImhleFwiKSk7dGhpcy5yZXNldFN0YXRlKCksbih0KX0pLHRoaXMub25jZShoK1wiLWNhbmNlbGVkXCIsKCk9Pnt0aGlzLnJlc2V0U3RhdGUoKSxjKG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjVHhfY2FuY2VsZWQuIFNpZ25pbmcgY2FuY2VsZWQsIHBsZWFzZSByZXRyeVwiKSl9KX0pLHRoaXMuc3VibWl0U2lnbmF0dXJlPShlLHQpPT57dGhpcy5lbWl0KGUrXCItc2lnbmVkXCIsdCl9LHRoaXMuY2FuY2VsUmVxdWVzdFNpZ25hdHVyZT0oKT0+e2NvbnN0IGU9dGhpcy5tZW1TdG9yZS5nZXRTdGF0ZSgpLnNpZ24ucmVxdWVzdDtpZihlKXtjb25zdHtyZXF1ZXN0SWQ6dH09ZTt0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtzaWduOnt9fSksdGhpcy5lbWl0KHQrXCItY2FuY2VsZWRcIil9fSx0aGlzLnJlc2V0PSgpPT57dGhpcy5jbGVhblN5bmNMaXN0ZW5lcnMoKTtjb25zdCBlPXRoaXMubWVtU3RvcmUuZ2V0U3RhdGUoKS5zaWduLnJlcXVlc3Q7aWYoZSl7Y29uc3R7cmVxdWVzdElkOnR9PWU7dGhpcy5jbGVhblNpZ25MaXN0ZW5lcnModCl9dGhpcy5yZXNldFN0YXRlKCl9LHRoaXMucmVzZXRTdGF0ZT0oKT0+e3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3N5bmM6e3JlYWRpbmc6ITF9LHNpZ246e319KX0sYS5pbnN0YW5jZSlyZXR1cm4gYS5pbnN0YW5jZTt0aGlzLm1lbVN0b3JlPW5ldyBuLk9ic2VydmFibGVTdG9yZSh7c3luYzp7cmVhZGluZzohMX0sc2lnbjp7fSxfdmVyc2lvbjoxfSksYS5pbnN0YW5jZT10aGlzfX1jbGFzcyBoIGV4dGVuZHMgdC5CYXNlS2V5cmluZ3tjb25zdHJ1Y3RvcihlKXtpZihzdXBlcihlKSx0aGlzLmdldEludGVyYWN0aW9uPSgpPT5uZXcgYSx0aGlzLnJlc2V0U3RvcmU9KCk9Pnt0aGlzLmdldEludGVyYWN0aW9uKCkucmVzZXQoKX0sdGhpcy5nZXRNZW1TdG9yZT0oKT0+dGhpcy5nZXRJbnRlcmFjdGlvbigpLm1lbVN0b3JlLHRoaXMucmVtb3ZlQWNjb3VudD1lPT57aWYoIXRoaXMuYWNjb3VudHMubWFwKGU9PmUudG9Mb3dlckNhc2UoKSkuaW5jbHVkZXMoZS50b0xvd2VyQ2FzZSgpKSl0aHJvdyBuZXcgRXJyb3IoYEFkZHJlc3MgJHtlfSBub3QgZm91bmQgaW4gdGhpcyBrZXlyaW5nYCk7dGhpcy5hY2NvdW50cz10aGlzLmFjY291bnRzLmZpbHRlcih0PT50LnRvTG93ZXJDYXNlKCkhPT1lLnRvTG93ZXJDYXNlKCkpfSx0aGlzLmZvcmdldERldmljZT0oKT0+e3RoaXMucGFnZT0wLHRoaXMucGVyUGFnZT01LHRoaXMuYWNjb3VudHM9W10sdGhpcy5jdXJyZW50QWNjb3VudD0wLHRoaXMubmFtZT1cIlFSIEhhcmR3YXJlXCIsdGhpcy5pbml0aWFsaXplZD0hMSx0aGlzLnhmcD1cIlwiLHRoaXMueHB1Yj1cIlwiLHRoaXMuaGRQYXRoPVwiXCIsdGhpcy5pbmRleGVzPXt9LHRoaXMuaGRrPXZvaWQgMCx0aGlzLnBhdGhzPXt9fSx0aGlzLnN1Ym1pdENyeXB0b0hES2V5PXRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5zdWJtaXRDcnlwdG9IREtleSx0aGlzLnN1Ym1pdENyeXB0b0FjY291bnQ9dGhpcy5nZXRJbnRlcmFjdGlvbigpLnN1Ym1pdENyeXB0b0FjY291bnQsdGhpcy5zdWJtaXRTaWduYXR1cmU9dGhpcy5nZXRJbnRlcmFjdGlvbigpLnN1Ym1pdFNpZ25hdHVyZSx0aGlzLmNhbmNlbFN5bmM9dGhpcy5nZXRJbnRlcmFjdGlvbigpLmNhbmNlbFN5bmMsdGhpcy5jYW5jZWxTaWduUmVxdWVzdD10aGlzLmdldEludGVyYWN0aW9uKCkuY2FuY2VsUmVxdWVzdFNpZ25hdHVyZSxoLmluc3RhbmNlKXJldHVybiBoLmluc3RhbmNlLmRlc2VyaWFsaXplKGUpLGguaW5zdGFuY2U7aC5pbnN0YW5jZT10aGlzfWFzeW5jIHNpZ25UcmFuc2FjdGlvbihlLHQpe2NvbnN0IHM9MD09PXQudHlwZT9pLkRhdGFUeXBlLnRyYW5zYWN0aW9uOmkuRGF0YVR5cGUudHlwZWRUcmFuc2FjdGlvbjtsZXQgbjtuPTA9PT10LnR5cGU/by5lbmNvZGUodC5nZXRNZXNzYWdlVG9TaWduKCExKSk6dC5nZXRNZXNzYWdlVG9TaWduKCExKTtjb25zdCBhPWF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhlKSxoPXQuY29tbW9uLmNoYWluSWQoKSx1PXIudjQoKSx5PWkuRXRoU2lnblJlcXVlc3QuY29uc3RydWN0RVRIUmVxdWVzdChuLHMsYSx0aGlzLnhmcCx1LGgsZSkse3I6bSxzOmcsdjpkfT1hd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUodSx5LFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoZSB0cmFuc2FjdGlvbiwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyksUz10LnRvSlNPTigpO3JldHVybiBTLnY9ZCxTLnM9ZyxTLnI9bSxTLnR5cGU9dC50eXBlLGMuVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEoUyx7Y29tbW9uOnQuY29tbW9ufSl9fWgudHlwZT10LkJhc2VLZXlyaW5nLnR5cGUsZXhwb3J0cy5NZXRhTWFza0tleXJpbmc9aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcy5tYXBcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wb3NlZFN0b3JlID0gdm9pZCAwO1xuY29uc3QgT2JzZXJ2YWJsZVN0b3JlXzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlU3RvcmVcIik7XG5jbGFzcyBDb21wb3NlZFN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbikge1xuICAgICAgICAvLyBUeXBlY2FzdDogUHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3JcbiAgICAgICAgc3VwZXIoe30pO1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hpbGRyZW5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fY2hpbGRyZW4pLmZvckVhY2goKGNoaWxkS2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2NoaWxkS2V5XTtcbiAgICAgICAgICAgIHRoaXMuX2FkZENoaWxkKGNoaWxkS2V5LCBjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hpbGQoY2hpbGRLZXksIGNoaWxkKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUZyb21DaGlsZCA9IChjaGlsZFZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHN0YXRlW2NoaWxkS2V5XSA9IGNoaWxkVmFsdWU7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGQuc3Vic2NyaWJlKHVwZGF0ZUZyb21DaGlsZCk7XG4gICAgICAgIHVwZGF0ZUZyb21DaGlsZChjaGlsZC5nZXRTdGF0ZSgpKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXBvc2VkU3RvcmUgPSBDb21wb3NlZFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tcG9zZWRTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVyZ2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIE1lcmdlZFN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiA9IFtdKSB7XG4gICAgICAgIC8vIFR5cGVjYXN0OiBQcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvclxuICAgICAgICBzdXBlcih7fSk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGlsZHJlblxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5fYWRkQ2hpbGQoY2hpbGQpKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlV2hvbGVTdGF0ZSgpO1xuICAgIH1cbiAgICBfYWRkQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3VwZGF0ZVdob2xlU3RhdGUoKSk7XG4gICAgfVxuICAgIF91cGRhdGVXaG9sZVN0YXRlKCkge1xuICAgICAgICBjb25zdCBjaGlsZFN0YXRlcyA9IHRoaXMuX2NoaWxkcmVuLm1hcCgoY2hpbGQpID0+IGNoaWxkLmdldFN0YXRlKCkpO1xuICAgICAgICAvLyBhcHBseSBzaGFsbG93IG1lcmdlIG92ZXIgc3RhdGVzXG4gICAgICAgIGNvbnN0IHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uY2hpbGRTdGF0ZXMpO1xuICAgICAgICB0aGlzLnB1dFN0YXRlKHN0YXRlKTtcbiAgICB9XG59XG5leHBvcnRzLk1lcmdlZFN0b3JlID0gTWVyZ2VkU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NZXJnZWRTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT2JzZXJ2YWJsZVN0b3JlID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlIGV4dGVuZHMgc2FmZV9ldmVudF9lbWl0dGVyXzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoaW5pdFN0YXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChpbml0U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gaW5pdFN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHlwZWNhc3QvZGVmYXVsdCBzdGF0ZTogUHJlc2VydmUgZXhpc3RpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgZ2V0U3RhdGVcbiAgICBnZXRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN0YXRlKCk7XG4gICAgfVxuICAgIC8vIHdyYXBwZXIgYXJvdW5kIGludGVybmFsIHB1dFN0YXRlXG4gICAgcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fcHV0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIG5ld1N0YXRlKTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUocGFydGlhbFN0YXRlKSB7XG4gICAgICAgIC8vIGlmIG5vbi1udWxsIG9iamVjdCwgbWVyZ2VcbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSAmJiB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUpLCBwYXJ0aWFsU3RhdGUpKTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBvYmplY3QsIHVzZSBuZXcgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMub24oJ3VwZGF0ZScsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgdW5zdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBwcml2YXRlXG4gICAgLy9cbiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2VcbiAgICBfZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLy8gd3JpdGUgdG8gcGVyc2lzdGVuY2VcbiAgICBfcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG59XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IE9ic2VydmFibGVTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGVTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZVN0cmVhbSBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3Iob2JzU3RvcmUpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLy8gcGFzcyB2YWx1ZXMsIG5vdCBzZXJpYWxpemF0aW9uc1xuICAgICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRvbnQgYnVmZmVyIG91dGdvaW5nIHVwZGF0ZXNcbiAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgLy8gc2F2ZSBoYW5kbGVyIHNvIHdlIGNhbiB1bnN1YnNjcmliZSBsYXRlclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSAoc3RhdGUpID0+IHRoaXMucHVzaChzdGF0ZSk7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBvYnNTdG9yZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMub2JzU3RvcmUgPSBvYnNTdG9yZTtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gZW1pdCBjdXJyZW50IHN0YXRlIG9uIG5ldyBkZXN0aW5hdGlvblxuICAgIHBpcGUoZGVzdCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5waXBlKGRlc3QsIG9wdGlvbnMpO1xuICAgICAgICBkZXN0LndyaXRlKHRoaXMub2JzU3RvcmUuZ2V0U3RhdGUoKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIHdyaXRlIGZyb20gaW5jb21pbmcgc3RyZWFtIHRvIHN0YXRlXG4gICAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUucHV0U3RhdGUoY2h1bmspO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICAvLyBub29wIC0gb3V0Z29pbmcgc3RyZWFtIGlzIGFza2luZyB1cyBpZiB3ZSBoYXZlIGRhdGEgd2UgYXJlbnQgZ2l2aW5nIGl0XG4gICAgX3JlYWQoX3NpemUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBldmVudCBlbWl0dGVyXG4gICAgX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnVuc3Vic2NyaWJlKHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHN1cGVyLl9kZXN0cm95KGVyciwgY2FsbGJhY2spO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0b3JlQXNTdHJlYW0ob2JzU3RvcmUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTdG9yZVN0cmVhbShvYnNTdG9yZSk7XG59XG5leHBvcnRzLnN0b3JlQXNTdHJlYW0gPSBzdG9yZUFzU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc1N0cmVhbVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29tcG9zZWRTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTWVyZ2VkU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdHJhbnNmb3JtXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZVRyYW5zZm9ybVN0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHRocm91Z2gyXzEgPSByZXF1aXJlKFwidGhyb3VnaDJcIik7XG5mdW5jdGlvbiBzdG9yZVRyYW5zZm9ybVN0cmVhbShzeW5jVHJhbnNmb3JtRm4pIHtcbiAgICByZXR1cm4gdGhyb3VnaDJfMS5vYmooKHN0YXRlLCBfZW5jb2RpbmcsIGNiKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHN5bmNUcmFuc2Zvcm1GbihzdGF0ZSk7XG4gICAgICAgICAgICBjYihudWxsLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnN0b3JlVHJhbnNmb3JtU3RyZWFtID0gc3RvcmVUcmFuc2Zvcm1TdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2Zvcm0uanMubWFwIiwidmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLlRyYW5zZm9ybVxuICAsIGluaGVyaXRzICA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuICAsIHh0ZW5kICAgICA9IHJlcXVpcmUoJ3h0ZW5kJylcblxuZnVuY3Rpb24gRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0cykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRzKVxuICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZVxufVxuXG5pbmhlcml0cyhEZXN0cm95YWJsZVRyYW5zZm9ybSwgVHJhbnNmb3JtKVxuXG5EZXN0cm95YWJsZVRyYW5zZm9ybS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm5cbiAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuICBcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVycilcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgc2VsZi5lbWl0KCdjbG9zZScpXG4gIH0pXG59XG5cbi8vIGEgbm9vcCBfdHJhbnNmb3JtIGZ1bmN0aW9uXG5mdW5jdGlvbiBub29wIChjaHVuaywgZW5jLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayhudWxsLCBjaHVuaylcbn1cblxuXG4vLyBjcmVhdGUgYSBuZXcgZXhwb3J0IGZ1bmN0aW9uLCB1c2VkIGJ5IGJvdGggdGhlIG1haW4gZXhwb3J0IGFuZFxuLy8gdGhlIC5jdG9yIGV4cG9ydCwgY29udGFpbnMgY29tbW9uIGxvZ2ljIGZvciBkZWFsaW5nIHdpdGggYXJndW1lbnRzXG5mdW5jdGlvbiB0aHJvdWdoMiAoY29uc3RydWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmbHVzaCAgICAgPSB0cmFuc2Zvcm1cbiAgICAgIHRyYW5zZm9ybSA9IG9wdGlvbnNcbiAgICAgIG9wdGlvbnMgICA9IHt9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm0gIT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRyYW5zZm9ybSA9IG5vb3BcblxuICAgIGlmICh0eXBlb2YgZmx1c2ggIT0gJ2Z1bmN0aW9uJylcbiAgICAgIGZsdXNoID0gbnVsbFxuXG4gICAgcmV0dXJuIGNvbnN0cnVjdChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKVxuICB9XG59XG5cblxuLy8gbWFpbiBleHBvcnQsIGp1c3QgbWFrZSBtZSBhIHRyYW5zZm9ybSBzdHJlYW0hXG5tb2R1bGUuZXhwb3J0cyA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRpb25zKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG5cblxuLy8gbWFrZSBtZSBhIHJldXNhYmxlIHByb3RvdHlwZSB0aGF0IEkgY2FuIGBuZXdgLCBvciBpbXBsaWNpdGx5IGBuZXdgXG4vLyB3aXRoIGEgY29uc3RydWN0b3IgY2FsbFxubW9kdWxlLmV4cG9ydHMuY3RvciA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIGZ1bmN0aW9uIFRocm91Z2gyIChvdmVycmlkZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUaHJvdWdoMikpXG4gICAgICByZXR1cm4gbmV3IFRocm91Z2gyKG92ZXJyaWRlKVxuXG4gICAgdGhpcy5vcHRpb25zID0geHRlbmQob3B0aW9ucywgb3ZlcnJpZGUpXG5cbiAgICBEZXN0cm95YWJsZVRyYW5zZm9ybS5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucylcbiAgfVxuXG4gIGluaGVyaXRzKFRocm91Z2gyLCBEZXN0cm95YWJsZVRyYW5zZm9ybSlcblxuICBUaHJvdWdoMi5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICBUaHJvdWdoMi5wcm90b3R5cGUuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gVGhyb3VnaDJcbn0pXG5cblxubW9kdWxlLmV4cG9ydHMub2JqID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKHh0ZW5kKHsgb2JqZWN0TW9kZTogdHJ1ZSwgaGlnaFdhdGVyTWFyazogMTYgfSwgb3B0aW9ucykpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzQm9va0NvbnRyb2xsZXIgPSBleHBvcnRzLkFkZHJlc3NUeXBlID0gdm9pZCAwO1xuY29uc3QgY29udHJvbGxlcl91dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9jb250cm9sbGVyLXV0aWxzXCIpO1xuY29uc3QgYmFzZV9jb250cm9sbGVyXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2Jhc2UtY29udHJvbGxlclwiKTtcbnZhciBBZGRyZXNzVHlwZTtcbihmdW5jdGlvbiAoQWRkcmVzc1R5cGUpIHtcbiAgICBBZGRyZXNzVHlwZVtcImV4dGVybmFsbHlPd25lZEFjY291bnRzXCJdID0gXCJFWFRFUk5BTExZX09XTkVEX0FDQ09VTlRTXCI7XG4gICAgQWRkcmVzc1R5cGVbXCJjb250cmFjdEFjY291bnRzXCJdID0gXCJDT05UUkFDVF9BQ0NPVU5UU1wiO1xuICAgIEFkZHJlc3NUeXBlW1wibm9uQWNjb3VudHNcIl0gPSBcIk5PTl9BQ0NPVU5UU1wiO1xufSkoQWRkcmVzc1R5cGUgPSBleHBvcnRzLkFkZHJlc3NUeXBlIHx8IChleHBvcnRzLkFkZHJlc3NUeXBlID0ge30pKTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IG1hbmFnZXMgYSBsaXN0IG9mIHJlY2lwaWVudCBhZGRyZXNzZXMgYXNzb2NpYXRlZCB3aXRoIG5pY2tuYW1lcy5cbiAqL1xuY2xhc3MgQWRkcmVzc0Jvb2tDb250cm9sbGVyIGV4dGVuZHMgYmFzZV9jb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gQWRkcmVzc0Jvb2tDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0FkZHJlc3NCb29rQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0geyBhZGRyZXNzQm9vazoge30gfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgY29udHJhY3QgZW50cmllcy5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBhZGRyZXNzQm9vazoge30gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNvbnRyYWN0IGVudHJ5IGJ5IGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIGlkIGlkZW50aWZpZXMgdGhlIGN1cnJlbnQgY2hhaW4uXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBSZWNpcGllbnQgYWRkcmVzcyB0byBkZWxldGUuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgZW50cnkgd2FzIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGNoYWluSWQsIGFkZHJlc3MpIHtcbiAgICAgICAgYWRkcmVzcyA9ICgwLCBjb250cm9sbGVyX3V0aWxzXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICBpZiAoISgwLCBjb250cm9sbGVyX3V0aWxzXzEuaXNWYWxpZEhleEFkZHJlc3MpKGFkZHJlc3MpIHx8XG4gICAgICAgICAgICAhdGhpcy5zdGF0ZS5hZGRyZXNzQm9va1tjaGFpbklkXSB8fFxuICAgICAgICAgICAgIXRoaXMuc3RhdGUuYWRkcmVzc0Jvb2tbY2hhaW5JZF1bYWRkcmVzc10pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzQm9vayA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuYWRkcmVzc0Jvb2spO1xuICAgICAgICBkZWxldGUgYWRkcmVzc0Jvb2tbY2hhaW5JZF1bYWRkcmVzc107XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhhZGRyZXNzQm9va1tjaGFpbklkXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgYWRkcmVzc0Jvb2tbY2hhaW5JZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoeyBhZGRyZXNzQm9vayB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBvciB1cGRhdGUgYSBjb250YWN0IGVudHJ5IGJ5IGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIFJlY2lwaWVudCBhZGRyZXNzIHRvIGFkZCBvciB1cGRhdGUuXG4gICAgICogQHBhcmFtIG5hbWUgLSBOaWNrbmFtZSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbiBpZCBpZGVudGlmaWVzIHRoZSBjdXJyZW50IGNoYWluLlxuICAgICAqIEBwYXJhbSBtZW1vIC0gVXNlcidzIG5vdGUgYWJvdXQgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gYWRkcmVzc1R5cGUgLSBDb250YWN0J3MgYWRkcmVzcyB0eXBlLlxuICAgICAqIEByZXR1cm5zIEJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgYWRkcmVzcyB3YXMgc3VjY2Vzc2Z1bGx5IHNldC5cbiAgICAgKi9cbiAgICBzZXQoYWRkcmVzcywgbmFtZSwgY2hhaW5JZCA9ICgwLCBjb250cm9sbGVyX3V0aWxzXzEudG9IZXgpKDEpLCBtZW1vID0gJycsIGFkZHJlc3NUeXBlKSB7XG4gICAgICAgIGFkZHJlc3MgPSAoMCwgY29udHJvbGxlcl91dGlsc18xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgaWYgKCEoMCwgY29udHJvbGxlcl91dGlsc18xLmlzVmFsaWRIZXhBZGRyZXNzKShhZGRyZXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBpc0VuczogZmFsc2UsXG4gICAgICAgICAgICBtZW1vLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFkZHJlc3NUeXBlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbnNOYW1lID0gKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS5ub3JtYWxpemVFbnNOYW1lKShuYW1lKTtcbiAgICAgICAgaWYgKGVuc05hbWUpIHtcbiAgICAgICAgICAgIGVudHJ5Lm5hbWUgPSBlbnNOYW1lO1xuICAgICAgICAgICAgZW50cnkuaXNFbnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIGFkZHJlc3NCb29rOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuYWRkcmVzc0Jvb2spLCB7IFtjaGFpbklkXTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLmFkZHJlc3NCb29rW2NoYWluSWRdKSwgeyBbYWRkcmVzc106IGVudHJ5IH0pIH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5BZGRyZXNzQm9va0NvbnRyb2xsZXIgPSBBZGRyZXNzQm9va0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBBZGRyZXNzQm9va0NvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BZGRyZXNzQm9va0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9BZGRyZXNzQm9va0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQW5ub3VuY2VtZW50Q29udHJvbGxlcl9pbnN0YW5jZXMsIF9Bbm5vdW5jZW1lbnRDb250cm9sbGVyX2FkZEFubm91bmNlbWVudHM7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFubm91bmNlbWVudENvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBiYXNlX2NvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svYmFzZS1jb250cm9sbGVyXCIpO1xuY29uc3QgY29udHJvbGxlck5hbWUgPSAnQW5ub3VuY2VtZW50Q29udHJvbGxlcic7XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgYW5ub3VuY2VtZW50czoge30sXG59O1xuY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgYW5ub3VuY2VtZW50czoge1xuICAgICAgICBwZXJzaXN0OiB0cnVlLFxuICAgICAgICBhbm9ueW1vdXM6IHRydWUsXG4gICAgfSxcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgZm9yIG1hbmFnaW5nIGluLWFwcCBhbm5vdW5jZW1lbnRzLlxuICovXG5jbGFzcyBBbm5vdW5jZW1lbnRDb250cm9sbGVyIGV4dGVuZHMgYmFzZV9jb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXJWMiB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEFubm91bmNlbWVudENvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gdGhpcyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gYXJncy5tZXNzZW5nZXIgLSBNZXNzZW5nZXIgdXNlZCB0byBjb21tdW5pY2F0ZSB3aXRoIEJhc2VWMiBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBhcmdzLnN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBhcmdzLmFsbEFubm91bmNlbWVudHMgLSBBbm5vdW5jZW1lbnRzIHRvIGJlIHBhc3NlZCB0aHJvdWdoIHRvICNhZGRBbm5vdW5jZW1lbnRzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBtZXNzZW5nZXIsIHN0YXRlLCBhbGxBbm5vdW5jZW1lbnRzLCB9KSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZFN0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3RhdGUpLCBzdGF0ZSk7XG4gICAgICAgIHN1cGVyKHsgbWVzc2VuZ2VyLCBtZXRhZGF0YSwgbmFtZTogY29udHJvbGxlck5hbWUsIHN0YXRlOiBtZXJnZWRTdGF0ZSB9KTtcbiAgICAgICAgX0Fubm91bmNlbWVudENvbnRyb2xsZXJfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQW5ub3VuY2VtZW50Q29udHJvbGxlcl9pbnN0YW5jZXMsIFwibVwiLCBfQW5ub3VuY2VtZW50Q29udHJvbGxlcl9hZGRBbm5vdW5jZW1lbnRzKS5jYWxsKHRoaXMsIGFsbEFubm91bmNlbWVudHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBzdGF0dXMgb2YgdGhlIHN0YXR1cyBvZiB0aGUgc3BlY2lmaWVkIGFubm91bmNlbWVudHNcbiAgICAgKiBvbmNlIGl0IGlzIHJlYWQgYnkgdGhlIHVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlld2VkSWRzIC0gVGhlIGFubm91bmNlbWVudCBJRHMgdG8gbWFyayBhcyB2aWV3ZWQuXG4gICAgICovXG4gICAgdXBkYXRlVmlld2VkKHZpZXdlZElkcykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoeyBhbm5vdW5jZW1lbnRzIH0pID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgT2JqZWN0LmtleXModmlld2VkSWRzKS5tYXAoTnVtYmVyKSkge1xuICAgICAgICAgICAgICAgIGFubm91bmNlbWVudHNbaWRdLmlzU2hvd24gPSB2aWV3ZWRJZHNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFubm91bmNlbWVudENvbnRyb2xsZXIgPSBBbm5vdW5jZW1lbnRDb250cm9sbGVyO1xuX0Fubm91bmNlbWVudENvbnRyb2xsZXJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0Fubm91bmNlbWVudENvbnRyb2xsZXJfYWRkQW5ub3VuY2VtZW50cyA9IGZ1bmN0aW9uIF9Bbm5vdW5jZW1lbnRDb250cm9sbGVyX2FkZEFubm91bmNlbWVudHMoYWxsQW5ub3VuY2VtZW50cykge1xuICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICBPYmplY3QudmFsdWVzKGFsbEFubm91bmNlbWVudHMpLmZvckVhY2goKGFubm91bmNlbWVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgc3RhdGUuYW5ub3VuY2VtZW50c1thbm5vdW5jZW1lbnQuaWRdID0gKF9hID0gc3RhdGUuYW5ub3VuY2VtZW50c1thbm5vdW5jZW1lbnQuaWRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFubm91bmNlbWVudCksIHsgaXNTaG93bjogZmFsc2UgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFubm91bmNlbWVudENvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Bbm5vdW5jZW1lbnRDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX0FwcHJvdmFsQ29udHJvbGxlcl9pbnN0YW5jZXMsIF9BcHByb3ZhbENvbnRyb2xsZXJfYXBwcm92YWxzLCBfQXBwcm92YWxDb250cm9sbGVyX29yaWdpbnMsIF9BcHByb3ZhbENvbnRyb2xsZXJfc2hvd0FwcHJvdmFsUmVxdWVzdCwgX0FwcHJvdmFsQ29udHJvbGxlcl90eXBlc0V4Y2x1ZGVkRnJvbVJhdGVMaW1pdGluZywgX0FwcHJvdmFsQ29udHJvbGxlcl9hZGQsIF9BcHByb3ZhbENvbnRyb2xsZXJfdmFsaWRhdGVBZGRQYXJhbXMsIF9BcHByb3ZhbENvbnRyb2xsZXJfYWRkUGVuZGluZ0FwcHJvdmFsT3JpZ2luLCBfQXBwcm92YWxDb250cm9sbGVyX2FkZFRvU3RvcmUsIF9BcHByb3ZhbENvbnRyb2xsZXJfZGVsZXRlLCBfQXBwcm92YWxDb250cm9sbGVyX2RlbGV0ZUFwcHJvdmFsQW5kR2V0Q2FsbGJhY2tzLCBfQXBwcm92YWxDb250cm9sbGVyX3Jlc3VsdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBwcm92YWxDb250cm9sbGVyID0gZXhwb3J0cy5BUFBST1ZBTF9UWVBFX1JFU1VMVF9TVUNDRVNTID0gZXhwb3J0cy5BUFBST1ZBTF9UWVBFX1JFU1VMVF9FUlJPUiA9IGV4cG9ydHMuT1JJR0lOX01FVEFNQVNLID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IG5hbm9pZF8xID0gcmVxdWlyZShcIm5hbm9pZFwiKTtcbmNvbnN0IGJhc2VfY29udHJvbGxlcl8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9iYXNlLWNvbnRyb2xsZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8vIENvbnN0YW50c1xuLy8gQXZvaWRpbmcgZGVwZW5kZW5jeSBvbiBjb250cm9sbGVyLXV0aWxzXG5leHBvcnRzLk9SSUdJTl9NRVRBTUFTSyA9ICdtZXRhbWFzayc7XG5leHBvcnRzLkFQUFJPVkFMX1RZUEVfUkVTVUxUX0VSUk9SID0gJ3Jlc3VsdF9lcnJvcic7XG5leHBvcnRzLkFQUFJPVkFMX1RZUEVfUkVTVUxUX1NVQ0NFU1MgPSAncmVzdWx0X3N1Y2Nlc3MnO1xuY29uc3QgY29udHJvbGxlck5hbWUgPSAnQXBwcm92YWxDb250cm9sbGVyJztcbmNvbnN0IHN0YXRlTWV0YWRhdGEgPSB7XG4gICAgcGVuZGluZ0FwcHJvdmFsczogeyBwZXJzaXN0OiBmYWxzZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgcGVuZGluZ0FwcHJvdmFsQ291bnQ6IHsgcGVyc2lzdDogZmFsc2UsIGFub255bW91czogZmFsc2UgfSxcbiAgICBhcHByb3ZhbEZsb3dzOiB7IHBlcnNpc3Q6IGZhbHNlLCBhbm9ueW1vdXM6IGZhbHNlIH0sXG59O1xuY29uc3QgZ2V0QWxyZWFkeVBlbmRpbmdNZXNzYWdlID0gKG9yaWdpbiwgdHlwZSkgPT4gYFJlcXVlc3Qgb2YgdHlwZSAnJHt0eXBlfScgYWxyZWFkeSBwZW5kaW5nIGZvciBvcmlnaW4gJHtvcmlnaW59LiBQbGVhc2Ugd2FpdC5gO1xuY29uc3QgZ2V0RGVmYXVsdFN0YXRlID0gKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBlbmRpbmdBcHByb3ZhbHM6IHt9LFxuICAgICAgICBwZW5kaW5nQXBwcm92YWxDb3VudDogMCxcbiAgICAgICAgYXBwcm92YWxGbG93czogW10sXG4gICAgfTtcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgZm9yIG1hbmFnaW5nIHJlcXVlc3RzIHRoYXQgcmVxdWlyZSB1c2VyIGFwcHJvdmFsLlxuICpcbiAqIEVuYWJsZXMgbGltaXRpbmcgdGhlIG51bWJlciBvZiBwZW5kaW5nIHJlcXVlc3RzIGJ5IG9yaWdpbiBhbmQgdHlwZSwgY291bnRpbmdcbiAqIHBlbmRpbmcgcmVxdWVzdHMsIGFuZCBtb3JlLlxuICpcbiAqIEFkZGluZyBhIHJlcXVlc3QgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvciByZWplY3RzIHdoZW4gdGhlIHJlcXVlc3RcbiAqIGlzIGFwcHJvdmVkIG9yIGRlbmllZCwgcmVzcGVjdGl2ZWx5LlxuICovXG5jbGFzcyBBcHByb3ZhbENvbnRyb2xsZXIgZXh0ZW5kcyBiYXNlX2NvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlclYyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3QgYW4gQXBwcm92YWwgY29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zaG93QXBwcm92YWxSZXF1ZXN0IC0gRnVuY3Rpb24gZm9yIG9wZW5pbmcgdGhlIFVJIHN1Y2ggdGhhdFxuICAgICAqIHRoZSByZXF1ZXN0IGNhbiBiZSBkaXNwbGF5ZWQgdG8gdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWVzc2VuZ2VyIC0gVGhlIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXIgZm9yIHRoZSBBcHByb3ZhbCBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gVGhlIGluaXRpYWwgY29udHJvbGxlciBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50eXBlc0V4Y2x1ZGVkRnJvbVJhdGVMaW1pdGluZyAtIEFycmF5IG9mIGFwcm92YWwgdHlwZXMgd2hpY2ggYWxsb3cgbXVsdGlwbGUgcGVuZGluZyBhcHByb3ZhbCByZXF1ZXN0cyBmcm9tIHRoZSBzYW1lIG9yaWdpbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3Nlbmdlciwgc2hvd0FwcHJvdmFsUmVxdWVzdCwgc3RhdGUgPSB7fSwgdHlwZXNFeGNsdWRlZEZyb21SYXRlTGltaXRpbmcgPSBbXSwgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiBjb250cm9sbGVyTmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0ZU1ldGFkYXRhLFxuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0RGVmYXVsdFN0YXRlKCkpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICBfQXBwcm92YWxDb250cm9sbGVyX2luc3RhbmNlcy5hZGQodGhpcyk7XG4gICAgICAgIF9BcHByb3ZhbENvbnRyb2xsZXJfYXBwcm92YWxzLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfQXBwcm92YWxDb250cm9sbGVyX29yaWdpbnMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9BcHByb3ZhbENvbnRyb2xsZXJfc2hvd0FwcHJvdmFsUmVxdWVzdC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0FwcHJvdmFsQ29udHJvbGxlcl90eXBlc0V4Y2x1ZGVkRnJvbVJhdGVMaW1pdGluZy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX2FwcHJvdmFscywgbmV3IE1hcCgpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9vcmlnaW5zLCBuZXcgTWFwKCksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX3Nob3dBcHByb3ZhbFJlcXVlc3QsIHNob3dBcHByb3ZhbFJlcXVlc3QsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX3R5cGVzRXhjbHVkZWRGcm9tUmF0ZUxpbWl0aW5nLCB0eXBlc0V4Y2x1ZGVkRnJvbVJhdGVMaW1pdGluZywgXCJmXCIpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyTWVzc2FnZUhhbmRsZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIGhlbHBlciBmb3IgcmVnaXN0ZXJpbmcgdGhpcyBjb250cm9sbGVyJ3MgbWVzc2FnaW5nIHN5c3RlbVxuICAgICAqIGFjdGlvbnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06Y2xlYXJSZXF1ZXN0c2AsIHRoaXMuY2xlYXIuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06YWRkUmVxdWVzdGAsIChvcHRzLCBzaG91bGRTaG93UmVxdWVzdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3VsZFNob3dSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQW5kU2hvd0FwcHJvdmFsUmVxdWVzdChvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06aGFzUmVxdWVzdGAsIHRoaXMuaGFzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmFjY2VwdFJlcXVlc3RgLCB0aGlzLmFjY2VwdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpyZWplY3RSZXF1ZXN0YCwgdGhpcy5yZWplY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06dXBkYXRlUmVxdWVzdFN0YXRlYCwgdGhpcy51cGRhdGVSZXF1ZXN0U3RhdGUuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06c3RhcnRGbG93YCwgdGhpcy5zdGFydEZsb3cuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06ZW5kRmxvd2AsIHRoaXMuZW5kRmxvdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpzZXRGbG93TG9hZGluZ1RleHRgLCB0aGlzLnNldEZsb3dMb2FkaW5nVGV4dC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpzaG93U3VjY2Vzc2AsIHRoaXMuc3VjY2Vzcy5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpzaG93RXJyb3JgLCB0aGlzLmVycm9yLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBhZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9pbnN0YW5jZXMsIFwibVwiLCBfQXBwcm92YWxDb250cm9sbGVyX2FkZCkuY2FsbCh0aGlzLCBvcHRzLm9yaWdpbiwgb3B0cy50eXBlLCBvcHRzLmlkLCBvcHRzLnJlcXVlc3REYXRhLCBvcHRzLnJlcXVlc3RTdGF0ZSwgb3B0cy5leHBlY3RzUmVzdWx0KTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX3Nob3dBcHByb3ZhbFJlcXVlc3QsIFwiZlwiKS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgYWRkKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9pbnN0YW5jZXMsIFwibVwiLCBfQXBwcm92YWxDb250cm9sbGVyX2FkZCkuY2FsbCh0aGlzLCBvcHRzLm9yaWdpbiwgb3B0cy50eXBlLCBvcHRzLmlkLCBvcHRzLnJlcXVlc3REYXRhLCBvcHRzLnJlcXVlc3RTdGF0ZSwgb3B0cy5leHBlY3RzUmVzdWx0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5mbyBmb3IgdGhlIGFwcHJvdmFsIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHJlcXVlc3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGlkLlxuICAgICAqL1xuICAgIGdldChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIHBlbmRpbmcgYXBwcm92YWxzLCBieSBvcmlnaW4gYW5kL29yIHR5cGUuXG4gICAgICpcbiAgICAgKiBJZiBvbmx5IGBvcmlnaW5gIGlzIHNwZWNpZmllZCwgYWxsIGFwcHJvdmFscyBmb3IgdGhhdCBvcmlnaW4gd2lsbCBiZVxuICAgICAqIGNvdW50ZWQsIHJlZ2FyZGxlc3Mgb2YgdHlwZS5cbiAgICAgKiBJZiBvbmx5IGB0eXBlYCBpcyBzcGVjaWZpZWQsIGFsbCBhcHByb3ZhbHMgZm9yIHRoYXQgdHlwZSB3aWxsIGJlIGNvdW50ZWQsXG4gICAgICogcmVnYXJkbGVzcyBvZiBvcmlnaW4uXG4gICAgICogSWYgYm90aCBgb3JpZ2luYCBhbmQgYHR5cGVgIGFyZSBzcGVjaWZpZWQsIDAgb3IgMSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBUaGUgYXBwcm92YWwgY291bnQgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0cy5vcmlnaW4gLSBBbiBhcHByb3ZhbCBvcmlnaW4uXG4gICAgICogQHBhcmFtIG9wdHMudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGFwcHJvdmFsIHJlcXVlc3QgY291bnQgZm9yIHRoZSBnaXZlbiBvcmlnaW4gYW5kL29yXG4gICAgICogdHlwZS5cbiAgICAgKi9cbiAgICBnZXRBcHByb3ZhbENvdW50KG9wdHMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghb3B0cy5vcmlnaW4gJiYgIW9wdHMudHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgb3JpZ2luLCB0eXBlLCBvciBib3RoLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luLCB0eXBlOiBfdHlwZSB9ID0gb3B0cztcbiAgICAgICAgaWYgKG9yaWdpbiAmJiBfdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BcHByb3ZhbENvbnRyb2xsZXJfb3JpZ2lucywgXCJmXCIpLmdldChvcmlnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KF90eXBlKSkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSgoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX29yaWdpbnMsIFwiZlwiKS5nZXQob3JpZ2luKSB8fCBuZXcgTWFwKCkpLnZhbHVlcygpKS5yZWR1Y2UoKHRvdGFsLCB2YWx1ZSkgPT4gdG90YWwgKyB2YWx1ZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBcInR5cGVcIiB3YXMgc3BlY2lmaWVkXG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgYXBwcm92YWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHMpKSB7XG4gICAgICAgICAgICBpZiAoYXBwcm92YWwudHlwZSA9PT0gX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b3RhbCBjb3VudCBvZiBhbGwgcGVuZGluZyBhcHByb3ZhbCByZXF1ZXN0cyBmb3IgYWxsIG9yaWdpbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgcGVuZGluZyBhcHByb3ZhbCByZXF1ZXN0IGNvdW50LlxuICAgICAqL1xuICAgIGdldFRvdGFsQXBwcm92YWxDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFsQ291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGVyZSdzIGEgcGVuZGluZyBhcHByb3ZhbCByZXF1ZXN0IHBlciB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cbiAgICAgKiBBdCBsZWFzdCBvbmUgcGFyYW1ldGVyIG11c3QgYmUgc3BlY2lmaWVkLiBBbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiB0aGVcbiAgICAgKiBwYXJhbWV0ZXJzIGFyZSBpbnZhbGlkLlxuICAgICAqXG4gICAgICogSWYgYGlkYCBpcyBzcGVjaWZpZWQsIGFsbCBvdGhlciBwYXJhbWV0ZXJzIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBJZiBgaWRgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBtZXRob2Qgd2lsbCBjaGVjayBmb3IgcmVxdWVzdHMgdGhhdCBtYXRjaFxuICAgICAqIGFsbCBvZiB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIElEIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0gb3B0cy5vcmlnaW4gLSBUaGUgb3JpZ2luIHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgdG8gY2hlY2sgZm9yLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiBhIG1hdGNoaW5nIGFwcHJvdmFsIGlzIGZvdW5kLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgaGFzKG9wdHMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgaWQsIG9yaWdpbiwgdHlwZTogX3R5cGUgfSA9IG9wdHM7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01heSBub3Qgc3BlY2lmeSBub24tc3RyaW5nIGlkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9hcHByb3ZhbHMsIFwiZlwiKS5oYXMoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdHlwZSAmJiB0eXBlb2YgX3R5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01heSBub3Qgc3BlY2lmeSBub24tc3RyaW5nIHR5cGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXkgbm90IHNwZWNpZnkgbm9uLXN0cmluZyBvcmlnaW4uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBvcmlnaW4gYW5kIHR5cGUgcGFpciBpZiB0eXBlIGFsc28gc3BlY2lmaWVkXG4gICAgICAgICAgICBpZiAoX3R5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbigoX2EgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BcHByb3ZhbENvbnRyb2xsZXJfb3JpZ2lucywgXCJmXCIpLmdldChvcmlnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KF90eXBlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX29yaWdpbnMsIFwiZlwiKS5oYXMob3JpZ2luKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3R5cGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXBwcm92YWwgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcHJvdmFsLnR5cGUgPT09IF90eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBhIHZhbGlkIGNvbWJpbmF0aW9uIG9mIGlkLCBvcmlnaW4sIGFuZCB0eXBlLicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgcHJvbWlzZSBvZiB0aGUgYXBwcm92YWwgd2l0aCB0aGUgZ2l2ZW4gaWQsIGFuZCBkZWxldGVzIHRoZVxuICAgICAqIGFwcHJvdmFsLiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gc3VjaCBhcHByb3ZhbCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJlc29sdmUgdGhlIGFwcHJvdmFsIHByb21pc2Ugd2l0aC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IGVpdGhlciByZXNvbHZlcyBvbmNlIGEgcmVzdWx0IGlzIHByb3ZpZGVkIGJ5XG4gICAgICogdGhlIGNyZWF0b3Igb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QsIG9yIGltbWVkaWF0ZWx5IGlmIGBvcHRpb25zLndhaXRGb3JSZXN1bHRgXG4gICAgICogaXMgYGZhbHNlYCBvciBgdW5kZWZpbmVkYC5cbiAgICAgKi9cbiAgICBhY2NlcHQoaWQsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFNhZmUgdG8gY2FzdCBhcyB0aGUgZGVsZXRlIG1ldGhvZCBiZWxvdyB3aWxsIHRocm93IGlmIHRoZSBJRCBpcyBub3QgZm91bmRcbiAgICAgICAgY29uc3QgYXBwcm92YWwgPSB0aGlzLmdldChpZCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RQcm9taXNlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX2luc3RhbmNlcywgXCJtXCIsIF9BcHByb3ZhbENvbnRyb2xsZXJfZGVsZXRlQXBwcm92YWxBbmRHZXRDYWxsYmFja3MpLmNhbGwodGhpcywgaWQpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0Q2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IChhY2NlcHRWYWx1ZSkgPT4gcmVzb2x2ZSh7IHZhbHVlOiBhY2NlcHRWYWx1ZSB9KSxcbiAgICAgICAgICAgICAgICBlcnJvcjogcmVqZWN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndhaXRGb3JSZXN1bHQpICYmICFhcHByb3ZhbC5leHBlY3RzUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBlcnJvcnNfMS5BcHByb3ZhbFJlcXVlc3ROb1Jlc3VsdFN1cHBvcnRFcnJvcihpZCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFZhbHVlID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53YWl0Rm9yUmVzdWx0KSA/IHJlc3VsdENhbGxiYWNrcyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVWYWx1ZSA9IGFwcHJvdmFsLmV4cGVjdHNSZXN1bHRcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWUsIHJlc3VsdENhbGxiYWNrczogcmVzdWx0VmFsdWUgfVxuICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgICAgICByZXF1ZXN0UHJvbWlzZS5yZXNvbHZlKHJlc29sdmVWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2FpdEZvclJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHsgdmFsdWU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlamVjdHMgdGhlIHByb21pc2Ugb2YgdGhlIGFwcHJvdmFsIHdpdGggdGhlIGdpdmVuIGlkLCBhbmQgZGVsZXRlcyB0aGVcbiAgICAgKiBhcHByb3ZhbC4gVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggYXBwcm92YWwgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byByZWplY3QgdGhlIGFwcHJvdmFsIHByb21pc2Ugd2l0aC5cbiAgICAgKi9cbiAgICByZWplY3QoaWQsIGVycm9yKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9pbnN0YW5jZXMsIFwibVwiLCBfQXBwcm92YWxDb250cm9sbGVyX2RlbGV0ZUFwcHJvdmFsQW5kR2V0Q2FsbGJhY2tzKS5jYWxsKHRoaXMsIGlkKS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIGFuZCBkZWxldGVzIGFsbCBhcHByb3ZhbCByZXF1ZXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWplY3Rpb25FcnJvciAtIFRoZSBFdGhlcmV1bVJwY0Vycm9yIHRvIHJlamVjdCB0aGUgYXBwcm92YWxcbiAgICAgKiByZXF1ZXN0cyB3aXRoLlxuICAgICAqL1xuICAgIGNsZWFyKHJlamVjdGlvbkVycm9yKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX2FwcHJvdmFscywgXCJmXCIpLmtleXMoKSkge1xuICAgICAgICAgICAgdGhpcy5yZWplY3QoaWQsIHJlamVjdGlvbkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BcHByb3ZhbENvbnRyb2xsZXJfb3JpZ2lucywgXCJmXCIpLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbHMgPSB7fTtcbiAgICAgICAgICAgIGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFsQ291bnQgPSAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVxdWVzdCBzdGF0ZSBvZiB0aGUgYXBwcm92YWwgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnJlcXVlc3RTdGF0ZSAtIEFkZGl0aW9uYWwgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3RcbiAgICAgKi9cbiAgICB1cGRhdGVSZXF1ZXN0U3RhdGUob3B0cykge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFsc1tvcHRzLmlkXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkFwcHJvdmFsUmVxdWVzdE5vdEZvdW5kRXJyb3Iob3B0cy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIC8vIFR5cGVjYXN0OiB0cygyNTg5KVxuICAgICAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzW29wdHMuaWRdLnJlcXVlc3RTdGF0ZSA9XG4gICAgICAgICAgICAgICAgb3B0cy5yZXF1ZXN0U3RhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgYXBwcm92YWwgZmxvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBiYWcuXG4gICAgICogQHBhcmFtIG9wdHMuaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIGZsb3cuXG4gICAgICogQHBhcmFtIG9wdHMubG9hZGluZ1RleHQgLSBUaGUgbG9hZGluZyB0ZXh0IHRoYXQgd2lsbCBiZSBhc3NvY2lhdGVkIHRvIHRoZSBhcHByb3ZhbCBmbG93LlxuICAgICAqIEByZXR1cm5zIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgYXBwcm92YWwgZmxvdyBpZC5cbiAgICAgKi9cbiAgICBzdGFydEZsb3cob3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGlkID0gKF9hID0gb3B0cy5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKDAsIG5hbm9pZF8xLm5hbm9pZCkoKTtcbiAgICAgICAgY29uc3QgbG9hZGluZ1RleHQgPSAoX2IgPSBvcHRzLmxvYWRpbmdUZXh0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZHJhZnRTdGF0ZS5hcHByb3ZhbEZsb3dzLnB1c2goeyBpZCwgbG9hZGluZ1RleHQgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BcHByb3ZhbENvbnRyb2xsZXJfc2hvd0FwcHJvdmFsUmVxdWVzdCwgXCJmXCIpLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB7IGlkLCBsb2FkaW5nVGV4dCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmRzIHRoZSBjdXJyZW50IGFwcHJvdmFsIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLmlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCBmbG93IHRoYXQgd2lsbCBiZSBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBlbmRGbG93KHsgaWQgfSkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdGUuYXBwcm92YWxGbG93cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Ob0FwcHJvdmFsRmxvd3NFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGbG93ID0gdGhpcy5zdGF0ZS5hcHByb3ZhbEZsb3dzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgaWYgKGlkICE9PSBjdXJyZW50Rmxvdy5pZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkVuZEludmFsaWRGbG93RXJyb3IoaWQsIHRoaXMuc3RhdGUuYXBwcm92YWxGbG93cy5tYXAoKGZsb3cpID0+IGZsb3cuaWQpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZHJhZnRTdGF0ZS5hcHByb3ZhbEZsb3dzLnBvcCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbG9hZGluZyB0ZXh0IGZvciB0aGUgYXBwcm92YWwgZmxvdy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBiYWcuXG4gICAgICogQHBhcmFtIG9wdHMuaWQgLSBUaGUgYXBwcm92YWwgZmxvdyBsb2FkaW5nIHRleHQgdGhhdCB3aWxsIGJlIGRpc3BsYXllZC5cbiAgICAgKiBAcGFyYW0gb3B0cy5sb2FkaW5nVGV4dCAtIFRoZSBsb2FkaW5nIHRleHQgdGhhdCB3aWxsIGJlIGFzc29jaWF0ZWQgdG8gdGhlIGFwcHJvdmFsIGZsb3cuXG4gICAgICovXG4gICAgc2V0Rmxvd0xvYWRpbmdUZXh0KHsgaWQsIGxvYWRpbmdUZXh0IH0pIHtcbiAgICAgICAgY29uc3QgZmxvd0luZGV4ID0gdGhpcy5zdGF0ZS5hcHByb3ZhbEZsb3dzLmZpbmRJbmRleCgoZmxvdykgPT4gZmxvdy5pZCA9PT0gaWQpO1xuICAgICAgICBpZiAoZmxvd0luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLk1pc3NpbmdBcHByb3ZhbEZsb3dFcnJvcihpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGRyYWZ0U3RhdGUuYXBwcm92YWxGbG93c1tmbG93SW5kZXhdLmxvYWRpbmdUZXh0ID0gbG9hZGluZ1RleHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IGEgc3VjY2VzcyBwYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAgICAgKiBAcGFyYW0gb3B0cy5tZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdGV4dCBvciBjb21wb25lbnRzIHRvIGRpc3BsYXkgaW4gdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIG9wdHMuaGVhZGVyIC0gVGhlIHRleHQgb3IgY29tcG9uZW50cyB0byBkaXNwbGF5IGluIHRoZSBoZWFkZXIgb2YgdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIG9wdHMuZmxvd1RvRW5kIC0gVGhlIElEIG9mIHRoZSBhcHByb3ZhbCBmbG93IHRvIGVuZCBvbmNlIHRoZSBzdWNjZXNzIHBhZ2UgaXMgYXBwcm92ZWQuXG4gICAgICogQHJldHVybnMgRW1wdHkgb2JqZWN0IHRvIHN1cHBvcnQgZnV0dXJlIGFkZGl0aW9ucy5cbiAgICAgKi9cbiAgICBzdWNjZXNzKG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX2luc3RhbmNlcywgXCJtXCIsIF9BcHByb3ZhbENvbnRyb2xsZXJfcmVzdWx0KS5jYWxsKHRoaXMsIGV4cG9ydHMuQVBQUk9WQUxfVFlQRV9SRVNVTFRfU1VDQ0VTUywgb3B0cywge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdHMubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IG9wdHMuaGVhZGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IGFuIGVycm9yIHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRzLm1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0ZXh0IG9yIGNvbXBvbmVudHMgdG8gZGlzcGxheSBpbiB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0gb3B0cy5oZWFkZXIgLSBUaGUgdGV4dCBvciBjb21wb25lbnRzIHRvIGRpc3BsYXkgaW4gdGhlIGhlYWRlciBvZiB0aGUgcGFnZS5cbiAgICAgKiBAcGFyYW0gb3B0cy5mbG93VG9FbmQgLSBUaGUgSUQgb2YgdGhlIGFwcHJvdmFsIGZsb3cgdG8gZW5kIG9uY2UgdGhlIGVycm9yIHBhZ2UgaXMgYXBwcm92ZWQuXG4gICAgICogQHJldHVybnMgRW1wdHkgb2JqZWN0IHRvIHN1cHBvcnQgZnV0dXJlIGFkZGl0aW9ucy5cbiAgICAgKi9cbiAgICBlcnJvcihvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9pbnN0YW5jZXMsIFwibVwiLCBfQXBwcm92YWxDb250cm9sbGVyX3Jlc3VsdCkuY2FsbCh0aGlzLCBleHBvcnRzLkFQUFJPVkFMX1RZUEVfUkVTVUxUX0VSUk9SLCBvcHRzLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IG9wdHMuZXJyb3IsXG4gICAgICAgICAgICAgICAgaGVhZGVyOiBvcHRzLmhlYWRlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFwcHJvdmFsQ29udHJvbGxlciA9IEFwcHJvdmFsQ29udHJvbGxlcjtcbl9BcHByb3ZhbENvbnRyb2xsZXJfYXBwcm92YWxzID0gbmV3IFdlYWtNYXAoKSwgX0FwcHJvdmFsQ29udHJvbGxlcl9vcmlnaW5zID0gbmV3IFdlYWtNYXAoKSwgX0FwcHJvdmFsQ29udHJvbGxlcl9zaG93QXBwcm92YWxSZXF1ZXN0ID0gbmV3IFdlYWtNYXAoKSwgX0FwcHJvdmFsQ29udHJvbGxlcl90eXBlc0V4Y2x1ZGVkRnJvbVJhdGVMaW1pdGluZyA9IG5ldyBXZWFrTWFwKCksIF9BcHByb3ZhbENvbnRyb2xsZXJfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX0FwcHJvdmFsQ29udHJvbGxlcl9hZGQgPSBmdW5jdGlvbiBfQXBwcm92YWxDb250cm9sbGVyX2FkZChvcmlnaW4sIHR5cGUsIGlkID0gKDAsIG5hbm9pZF8xLm5hbm9pZCkoKSwgcmVxdWVzdERhdGEsIHJlcXVlc3RTdGF0ZSwgZXhwZWN0c1Jlc3VsdCkge1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9pbnN0YW5jZXMsIFwibVwiLCBfQXBwcm92YWxDb250cm9sbGVyX3ZhbGlkYXRlQWRkUGFyYW1zKS5jYWxsKHRoaXMsIGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhLCByZXF1ZXN0U3RhdGUpO1xuICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX3R5cGVzRXhjbHVkZWRGcm9tUmF0ZUxpbWl0aW5nLCBcImZcIikuaW5jbHVkZXModHlwZSkgJiZcbiAgICAgICAgdGhpcy5oYXMoeyBvcmlnaW4sIHR5cGUgfSkpIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLnJlc291cmNlVW5hdmFpbGFibGUoZ2V0QWxyZWFkeVBlbmRpbmdNZXNzYWdlKG9yaWdpbiwgdHlwZSkpO1xuICAgIH1cbiAgICAvLyBhZGQgcGVuZGluZyBhcHByb3ZhbFxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9hcHByb3ZhbHMsIFwiZlwiKS5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BcHByb3ZhbENvbnRyb2xsZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0FwcHJvdmFsQ29udHJvbGxlcl9hZGRQZW5kaW5nQXBwcm92YWxPcmlnaW4pLmNhbGwodGhpcywgb3JpZ2luLCB0eXBlKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX2luc3RhbmNlcywgXCJtXCIsIF9BcHByb3ZhbENvbnRyb2xsZXJfYWRkVG9TdG9yZSkuY2FsbCh0aGlzLCBpZCwgb3JpZ2luLCB0eXBlLCByZXF1ZXN0RGF0YSwgcmVxdWVzdFN0YXRlLCBleHBlY3RzUmVzdWx0KTtcbiAgICB9KTtcbn0sIF9BcHByb3ZhbENvbnRyb2xsZXJfdmFsaWRhdGVBZGRQYXJhbXMgPSBmdW5jdGlvbiBfQXBwcm92YWxDb250cm9sbGVyX3ZhbGlkYXRlQWRkUGFyYW1zKGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhLCByZXF1ZXN0U3RhdGUpIHtcbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gbnVsbDtcbiAgICBpZiAoIWlkIHx8IHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gJ011c3Qgc3BlY2lmeSBub24tZW1wdHkgc3RyaW5nIGlkLic7XG4gICAgfVxuICAgIGVsc2UgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9hcHByb3ZhbHMsIFwiZlwiKS5oYXMoaWQpKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IGBBcHByb3ZhbCByZXF1ZXN0IHdpdGggaWQgJyR7aWR9JyBhbHJlYWR5IGV4aXN0cy5gO1xuICAgIH1cbiAgICBlbHNlIGlmICghb3JpZ2luIHx8IHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdNdXN0IHNwZWNpZnkgbm9uLWVtcHR5IHN0cmluZyBvcmlnaW4uJztcbiAgICB9XG4gICAgZWxzZSBpZiAoIXR5cGUgfHwgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdNdXN0IHNwZWNpZnkgbm9uLWVtcHR5IHN0cmluZyB0eXBlLic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlcXVlc3REYXRhICYmXG4gICAgICAgICh0eXBlb2YgcmVxdWVzdERhdGEgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkocmVxdWVzdERhdGEpKSkge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSAnUmVxdWVzdCBkYXRhIG11c3QgYmUgYSBwbGFpbiBvYmplY3QgaWYgc3BlY2lmaWVkLic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlcXVlc3RTdGF0ZSAmJlxuICAgICAgICAodHlwZW9mIHJlcXVlc3RTdGF0ZSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShyZXF1ZXN0U3RhdGUpKSkge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSAnUmVxdWVzdCBzdGF0ZSBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0IGlmIHNwZWNpZmllZC4nO1xuICAgIH1cbiAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChlcnJvck1lc3NhZ2UpO1xuICAgIH1cbn0sIF9BcHByb3ZhbENvbnRyb2xsZXJfYWRkUGVuZGluZ0FwcHJvdmFsT3JpZ2luID0gZnVuY3Rpb24gX0FwcHJvdmFsQ29udHJvbGxlcl9hZGRQZW5kaW5nQXBwcm92YWxPcmlnaW4ob3JpZ2luLCB0eXBlKSB7XG4gICAgbGV0IG9yaWdpbk1hcCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9vcmlnaW5zLCBcImZcIikuZ2V0KG9yaWdpbik7XG4gICAgaWYgKCFvcmlnaW5NYXApIHtcbiAgICAgICAgb3JpZ2luTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BcHByb3ZhbENvbnRyb2xsZXJfb3JpZ2lucywgXCJmXCIpLnNldChvcmlnaW4sIG9yaWdpbk1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IG9yaWdpbk1hcC5nZXQodHlwZSkgfHwgMDtcbiAgICBvcmlnaW5NYXAuc2V0KHR5cGUsIGN1cnJlbnRWYWx1ZSArIDEpO1xufSwgX0FwcHJvdmFsQ29udHJvbGxlcl9hZGRUb1N0b3JlID0gZnVuY3Rpb24gX0FwcHJvdmFsQ29udHJvbGxlcl9hZGRUb1N0b3JlKGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhLCByZXF1ZXN0U3RhdGUsIGV4cGVjdHNSZXN1bHQpIHtcbiAgICBjb25zdCBhcHByb3ZhbCA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9yaWdpbixcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgcmVxdWVzdERhdGE6IHJlcXVlc3REYXRhIHx8IG51bGwsXG4gICAgICAgIHJlcXVlc3RTdGF0ZTogcmVxdWVzdFN0YXRlIHx8IG51bGwsXG4gICAgICAgIGV4cGVjdHNSZXN1bHQ6IGV4cGVjdHNSZXN1bHQgfHwgZmFsc2UsXG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAvLyBUeXBlY2FzdDogdHMoMjU4OSlcbiAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXSA9IGFwcHJvdmFsO1xuICAgICAgICBkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbENvdW50ID0gT2JqZWN0LmtleXMoZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzKS5sZW5ndGg7XG4gICAgfSk7XG59LCBfQXBwcm92YWxDb250cm9sbGVyX2RlbGV0ZSA9IGZ1bmN0aW9uIF9BcHByb3ZhbENvbnRyb2xsZXJfZGVsZXRlKGlkKSB7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQXBwcm92YWxDb250cm9sbGVyX2FwcHJvdmFscywgXCJmXCIpLmRlbGV0ZShpZCk7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgb25seSBjYWxsZWQgYWZ0ZXIgdmVyaWZ5aW5nIHRoYXQgdGhlIGFwcHJvdmFsIHdpdGggdGhlXG4gICAgLy8gc3BlY2lmaWVkIGlkIGV4aXN0cy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgIGNvbnN0IHsgb3JpZ2luLCB0eXBlIH0gPSB0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbaWRdO1xuICAgIGNvbnN0IG9yaWdpbk1hcCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9vcmlnaW5zLCBcImZcIikuZ2V0KG9yaWdpbik7XG4gICAgY29uc3Qgb3JpZ2luVG90YWxDb3VudCA9IHRoaXMuZ2V0QXBwcm92YWxDb3VudCh7IG9yaWdpbiB9KTtcbiAgICBjb25zdCBvcmlnaW5UeXBlQ291bnQgPSBvcmlnaW5NYXAuZ2V0KHR5cGUpO1xuICAgIGlmIChvcmlnaW5Ub3RhbENvdW50ID09PSAxKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9vcmlnaW5zLCBcImZcIikuZGVsZXRlKG9yaWdpbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvcmlnaW5NYXAuc2V0KHR5cGUsIG9yaWdpblR5cGVDb3VudCAtIDEpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICBkZWxldGUgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXTtcbiAgICAgICAgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxDb3VudCA9IE9iamVjdC5rZXlzKGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFscykubGVuZ3RoO1xuICAgIH0pO1xufSwgX0FwcHJvdmFsQ29udHJvbGxlcl9kZWxldGVBcHByb3ZhbEFuZEdldENhbGxiYWNrcyA9IGZ1bmN0aW9uIF9BcHByb3ZhbENvbnRyb2xsZXJfZGVsZXRlQXBwcm92YWxBbmRHZXRDYWxsYmFja3MoaWQpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9BcHByb3ZhbENvbnRyb2xsZXJfYXBwcm92YWxzLCBcImZcIikuZ2V0KGlkKTtcbiAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQXBwcm92YWxSZXF1ZXN0Tm90Rm91bmRFcnJvcihpZCk7XG4gICAgfVxuICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcHJvdmFsQ29udHJvbGxlcl9pbnN0YW5jZXMsIFwibVwiLCBfQXBwcm92YWxDb250cm9sbGVyX2RlbGV0ZSkuY2FsbCh0aGlzLCBpZCk7XG4gICAgcmV0dXJuIGNhbGxiYWNrcztcbn0sIF9BcHByb3ZhbENvbnRyb2xsZXJfcmVzdWx0ID0gZnVuY3Rpb24gX0FwcHJvdmFsQ29udHJvbGxlcl9yZXN1bHQodHlwZSwgb3B0cywgcmVxdWVzdERhdGEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5hZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IGV4cG9ydHMuT1JJR0lOX01FVEFNQVNLLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRmFpbGVkIHRvIGRpc3BsYXkgcmVzdWx0IHBhZ2UnLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAob3B0cy5mbG93VG9FbmQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZEZsb3coeyBpZDogb3B0cy5mbG93VG9FbmQgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ0ZhaWxlZCB0byBlbmQgZmxvdycsIHsgaWQ6IG9wdHMuZmxvd1RvRW5kLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBBcHByb3ZhbENvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcHByb3ZhbENvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1pc3NpbmdBcHByb3ZhbEZsb3dFcnJvciA9IGV4cG9ydHMuRW5kSW52YWxpZEZsb3dFcnJvciA9IGV4cG9ydHMuTm9BcHByb3ZhbEZsb3dzRXJyb3IgPSBleHBvcnRzLkFwcHJvdmFsUmVxdWVzdE5vUmVzdWx0U3VwcG9ydEVycm9yID0gZXhwb3J0cy5BcHByb3ZhbFJlcXVlc3ROb3RGb3VuZEVycm9yID0gdm9pZCAwO1xuY2xhc3MgQXBwcm92YWxSZXF1ZXN0Tm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpZCkge1xuICAgICAgICBzdXBlcihgQXBwcm92YWwgcmVxdWVzdCB3aXRoIGlkICcke2lkfScgbm90IGZvdW5kLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwcm92YWxSZXF1ZXN0Tm90Rm91bmRFcnJvciA9IEFwcHJvdmFsUmVxdWVzdE5vdEZvdW5kRXJyb3I7XG5jbGFzcyBBcHByb3ZhbFJlcXVlc3ROb1Jlc3VsdFN1cHBvcnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpZCkge1xuICAgICAgICBzdXBlcihgQXBwcm92YWwgYWNjZXB0YW5jZSByZXF1ZXN0ZWQgcmVzdWx0IGJ1dCByZXF1ZXN0IHdpdGggaWQgJyR7aWR9JyBkb2VzIG5vdCBzdXBwb3J0IGl0LmApO1xuICAgIH1cbn1cbmV4cG9ydHMuQXBwcm92YWxSZXF1ZXN0Tm9SZXN1bHRTdXBwb3J0RXJyb3IgPSBBcHByb3ZhbFJlcXVlc3ROb1Jlc3VsdFN1cHBvcnRFcnJvcjtcbmNsYXNzIE5vQXBwcm92YWxGbG93c0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihgTm8gYXBwcm92YWwgZmxvd3MgZm91bmQuYCk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob0FwcHJvdmFsRmxvd3NFcnJvciA9IE5vQXBwcm92YWxGbG93c0Vycm9yO1xuY2xhc3MgRW5kSW52YWxpZEZsb3dFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgZmxvd0lkcykge1xuICAgICAgICBzdXBlcihgQXR0ZW1wdGVkIHRvIGVuZCBmbG93IHdpdGggaWQgJyR7aWR9JyB3aGljaCBkb2VzIG5vdCBtYXRjaCBjdXJyZW50IGZsb3cgd2l0aCBpZCAnJHtmbG93SWRzLnNsaWNlKC0xKVswXX0nLiBBbGwgRmxvd3M6ICR7Zmxvd0lkcy5qb2luKCcsICcpfWApO1xuICAgIH1cbn1cbmV4cG9ydHMuRW5kSW52YWxpZEZsb3dFcnJvciA9IEVuZEludmFsaWRGbG93RXJyb3I7XG5jbGFzcyBNaXNzaW5nQXBwcm92YWxGbG93RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaWQpIHtcbiAgICAgICAgc3VwZXIoYE5vIGFwcHJvdmFsIGZsb3dzIGZvdW5kIHdpdGggaWQgJyR7aWR9Jy5gKTtcbiAgICB9XG59XG5leHBvcnRzLk1pc3NpbmdBcHByb3ZhbEZsb3dFcnJvciA9IE1pc3NpbmdBcHByb3ZhbEZsb3dFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0FwcHJvdmFsQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImxldCB7IHVybEFscGhhYmV0IH0gPSByZXF1aXJlKCcuL3VybC1hbHBoYWJldC9pbmRleC5janMnKVxubGV0IHJhbmRvbSA9IGJ5dGVzID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKVxubGV0IGN1c3RvbVJhbmRvbSA9IChhbHBoYWJldCwgZGVmYXVsdFNpemUsIGdldFJhbmRvbSkgPT4ge1xuICBsZXQgbWFzayA9ICgyIDw8IChNYXRoLmxvZyhhbHBoYWJldC5sZW5ndGggLSAxKSAvIE1hdGguTE4yKSkgLSAxXG4gIGxldCBzdGVwID0gLX4oKDEuNiAqIG1hc2sgKiBkZWZhdWx0U2l6ZSkgLyBhbHBoYWJldC5sZW5ndGgpXG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gJydcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbGV0IGJ5dGVzID0gZ2V0UmFuZG9tKHN0ZXApXG4gICAgICBsZXQgaiA9IHN0ZXBcbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgaWQgKz0gYWxwaGFiZXRbYnl0ZXNbal0gJiBtYXNrXSB8fCAnJ1xuICAgICAgICBpZiAoaWQubGVuZ3RoID09PSBzaXplKSByZXR1cm4gaWRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmxldCBjdXN0b21BbHBoYWJldCA9IChhbHBoYWJldCwgc2l6ZSA9IDIxKSA9PlxuICBjdXN0b21SYW5kb20oYWxwaGFiZXQsIHNpemUsIHJhbmRvbSlcbmxldCBuYW5vaWQgPSAoc2l6ZSA9IDIxKSA9PlxuICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHNpemUpKS5yZWR1Y2UoKGlkLCBieXRlKSA9PiB7XG4gICAgYnl0ZSAmPSA2M1xuICAgIGlmIChieXRlIDwgMzYpIHtcbiAgICAgIGlkICs9IGJ5dGUudG9TdHJpbmcoMzYpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjIpIHtcbiAgICAgIGlkICs9IChieXRlIC0gMjYpLnRvU3RyaW5nKDM2KS50b1VwcGVyQ2FzZSgpXG4gICAgfSBlbHNlIGlmIChieXRlID4gNjIpIHtcbiAgICAgIGlkICs9ICctJ1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCArPSAnXydcbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH0sICcnKVxubW9kdWxlLmV4cG9ydHMgPSB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQsIGN1c3RvbVJhbmRvbSwgdXJsQWxwaGFiZXQsIHJhbmRvbSB9XG4iLCJsZXQgdXJsQWxwaGFiZXQgPVxuICAndXNlYW5kb20tMjZUMTk4MzQwUFg3NXB4SkFDS1ZFUllNSU5EQlVTSFdPTEZfR1FaYmZnaGprbHF2d3l6cmljdCdcbm1vZHVsZS5leHBvcnRzID0geyB1cmxBbHBoYWJldCB9XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2VuZXJhdGVTYWx0ID0gZXhwb3J0cy5zZXJpYWxpemVCdWZmZXJGb3JTdG9yYWdlID0gZXhwb3J0cy5zZXJpYWxpemVCdWZmZXJGcm9tU3RvcmFnZSA9IGV4cG9ydHMua2V5RnJvbVBhc3N3b3JkID0gZXhwb3J0cy5leHBvcnRLZXkgPSBleHBvcnRzLmltcG9ydEtleSA9IGV4cG9ydHMuZGVjcnlwdFdpdGhLZXkgPSBleHBvcnRzLmRlY3J5cHRXaXRoRGV0YWlsID0gZXhwb3J0cy5kZWNyeXB0ID0gZXhwb3J0cy5lbmNyeXB0V2l0aEtleSA9IGV4cG9ydHMuZW5jcnlwdFdpdGhEZXRhaWwgPSBleHBvcnRzLmVuY3J5cHQgPSB2b2lkIDA7XG5jb25zdCBFWFBPUlRfRk9STUFUID0gJ2p3ayc7XG5jb25zdCBERVJJVkVEX0tFWV9GT1JNQVQgPSAnQUVTLUdDTSc7XG5jb25zdCBTVFJJTkdfRU5DT0RJTkcgPSAndXRmLTgnO1xuLyoqXG4gKiBFbmNyeXB0cyBhIGRhdGEgb2JqZWN0IHRoYXQgY2FuIGJlIGFueSBzZXJpYWxpemFibGUgdmFsdWUgdXNpbmdcbiAqIGEgcHJvdmlkZWQgcGFzc3dvcmQuXG4gKlxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHBhc3N3b3JkIHRvIHVzZSBmb3IgZW5jcnlwdGlvbi5cbiAqIEBwYXJhbSBkYXRhT2JqIC0gVGhlIGRhdGEgdG8gZW5jcnlwdC5cbiAqIEBwYXJhbSBrZXkgLSBUaGUgQ3J5cHRvS2V5IHRvIGVuY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSBzYWx0IC0gVGhlIHNhbHQgdG8gdXNlIHRvIGVuY3J5cHQuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIHZhdWx0LlxuICovXG5hc3luYyBmdW5jdGlvbiBlbmNyeXB0KHBhc3N3b3JkLCBkYXRhT2JqLCBrZXksIHNhbHQgPSBnZW5lcmF0ZVNhbHQoKSkge1xuICAgIGNvbnN0IGNyeXB0b0tleSA9IGtleSB8fCAoYXdhaXQga2V5RnJvbVBhc3N3b3JkKHBhc3N3b3JkLCBzYWx0KSk7XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IGVuY3J5cHRXaXRoS2V5KGNyeXB0b0tleSwgZGF0YU9iaik7XG4gICAgcGF5bG9hZC5zYWx0ID0gc2FsdDtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG59XG5leHBvcnRzLmVuY3J5cHQgPSBlbmNyeXB0O1xuLyoqXG4gKiBFbmNyeXB0cyBhIGRhdGEgb2JqZWN0IHRoYXQgY2FuIGJlIGFueSBzZXJpYWxpemFibGUgdmFsdWUgdXNpbmdcbiAqIGEgcHJvdmlkZWQgcGFzc3dvcmQuXG4gKlxuICogQHBhcmFtIHBhc3N3b3JkIC0gQSBwYXNzd29yZCB0byB1c2UgZm9yIGVuY3J5cHRpb24uXG4gKiBAcGFyYW0gZGF0YU9iaiAtIFRoZSBkYXRhIHRvIGVuY3J5cHQuXG4gKiBAcGFyYW0gc2FsdCAtIFRoZSBzYWx0IHVzZWQgdG8gZW5jcnlwdC5cbiAqIEByZXR1cm5zIFRoZSB2YXVsdCBhbmQgZXhwb3J0ZWQga2V5IHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdFdpdGhEZXRhaWwocGFzc3dvcmQsIGRhdGFPYmosIHNhbHQgPSBnZW5lcmF0ZVNhbHQoKSkge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IGtleUZyb21QYXNzd29yZChwYXNzd29yZCwgc2FsdCwgdHJ1ZSk7XG4gICAgY29uc3QgZXhwb3J0ZWRLZXlTdHJpbmcgPSBhd2FpdCBleHBvcnRLZXkoa2V5KTtcbiAgICBjb25zdCB2YXVsdCA9IGF3YWl0IGVuY3J5cHQocGFzc3dvcmQsIGRhdGFPYmosIGtleSwgc2FsdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmF1bHQsXG4gICAgICAgIGV4cG9ydGVkS2V5U3RyaW5nLFxuICAgIH07XG59XG5leHBvcnRzLmVuY3J5cHRXaXRoRGV0YWlsID0gZW5jcnlwdFdpdGhEZXRhaWw7XG4vKipcbiAqIEVuY3J5cHRzIHRoZSBwcm92aWRlZCBzZXJpYWxpemFibGUgamF2YXNjcmlwdCBvYmplY3QgdXNpbmcgdGhlXG4gKiBwcm92aWRlZCBDcnlwdG9LZXkgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGN5cGhlciB0ZXh0IGFuZFxuICogdGhlIGluaXRpYWxpemF0aW9uIHZlY3RvciB1c2VkLlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUgQ3J5cHRvS2V5IHRvIGVuY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSBkYXRhT2JqIC0gQSBzZXJpYWxpemFibGUgSmF2YVNjcmlwdCBvYmplY3QgdG8gZW5jcnlwdC5cbiAqIEByZXR1cm5zIFRoZSBlbmNyeXB0ZWQgZGF0YS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW5jcnlwdFdpdGhLZXkoa2V5LCBkYXRhT2JqKSB7XG4gICAgY29uc3QgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGFPYmopO1xuICAgIGNvbnN0IGRhdGFCdWZmZXIgPSBCdWZmZXIuZnJvbShkYXRhLCBTVFJJTkdfRU5DT0RJTkcpO1xuICAgIGNvbnN0IHZlY3RvciA9IGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDE2KSk7XG4gICAgY29uc3QgYnVmID0gYXdhaXQgZ2xvYmFsLmNyeXB0by5zdWJ0bGUuZW5jcnlwdCh7XG4gICAgICAgIG5hbWU6IERFUklWRURfS0VZX0ZPUk1BVCxcbiAgICAgICAgaXY6IHZlY3RvcixcbiAgICB9LCBrZXksIGRhdGFCdWZmZXIpO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1Zik7XG4gICAgY29uc3QgdmVjdG9yU3RyID0gQnVmZmVyLmZyb20odmVjdG9yKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgdmF1bHRTdHIgPSBCdWZmZXIuZnJvbShidWZmZXIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB2YXVsdFN0cixcbiAgICAgICAgaXY6IHZlY3RvclN0cixcbiAgICB9O1xufVxuZXhwb3J0cy5lbmNyeXB0V2l0aEtleSA9IGVuY3J5cHRXaXRoS2V5O1xuLyoqXG4gKiBHaXZlbiBhIHBhc3N3b3JkIGFuZCBhIGN5cGhlciB0ZXh0LCBkZWNyeXB0cyB0aGUgdGV4dCBhbmQgcmV0dXJuc1xuICogdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gcGFzc3dvcmQgLSBUaGUgcGFzc3dvcmQgdG8gZGVjcnlwdCB3aXRoLlxuICogQHBhcmFtIHRleHQgLSBUaGUgY3lwaGVyIHRleHQgdG8gZGVjcnlwdC5cbiAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IHRvIGRlY3J5cHQgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgZGF0YS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdChwYXNzd29yZCwgdGV4dCwga2V5KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgY29uc3QgeyBzYWx0IH0gPSBwYXlsb2FkO1xuICAgIGNvbnN0IGNyeXB0b0tleSA9IGtleSB8fCAoYXdhaXQga2V5RnJvbVBhc3N3b3JkKHBhc3N3b3JkLCBzYWx0KSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVjcnlwdFdpdGhLZXkoY3J5cHRvS2V5LCBwYXlsb2FkKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZWNyeXB0ID0gZGVjcnlwdDtcbi8qKlxuICogR2l2ZW4gYSBwYXNzd29yZCBhbmQgYSBjeXBoZXIgdGV4dCwgZGVjcnlwdHMgdGhlIHRleHQgYW5kIHJldHVybnNcbiAqIHRoZSByZXN1bHRpbmcgdmFsdWUsIGtleVN0cmluZywgYW5kIHNhbHQuXG4gKlxuICogQHBhcmFtIHBhc3N3b3JkIC0gVGhlIHBhc3N3b3JkIHRvIGRlY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSB0ZXh0IC0gVGhlIGVuY3J5cHRlZCB2YXVsdCB0byBkZWNyeXB0LlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCB2YXVsdCBhbG9uZyB3aXRoIHRoZSBzYWx0IGFuZCBleHBvcnRlZCBrZXkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRXaXRoRGV0YWlsKHBhc3N3b3JkLCB0ZXh0KSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgY29uc3QgeyBzYWx0IH0gPSBwYXlsb2FkO1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IGtleUZyb21QYXNzd29yZChwYXNzd29yZCwgc2FsdCwgdHJ1ZSk7XG4gICAgY29uc3QgZXhwb3J0ZWRLZXlTdHJpbmcgPSBhd2FpdCBleHBvcnRLZXkoa2V5KTtcbiAgICBjb25zdCB2YXVsdCA9IGF3YWl0IGRlY3J5cHQocGFzc3dvcmQsIHRleHQsIGtleSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXhwb3J0ZWRLZXlTdHJpbmcsXG4gICAgICAgIHZhdWx0LFxuICAgICAgICBzYWx0LFxuICAgIH07XG59XG5leHBvcnRzLmRlY3J5cHRXaXRoRGV0YWlsID0gZGVjcnlwdFdpdGhEZXRhaWw7XG4vKipcbiAqIEdpdmVuIGEgQ3J5cHRvS2V5IGFuZCBhbiBFbmNyeXB0aW9uUmVzdWx0IG9iamVjdCBjb250YWluaW5nIHRoZSBpbml0aWFsaXphdGlvblxuICogdmVjdG9yIChpdikgYW5kIGRhdGEgdG8gZGVjcnlwdCwgcmV0dXJuIHRoZSByZXN1bHRpbmcgZGVjcnlwdGVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUgQ3J5cHRvS2V5IHRvIGRlY3J5cHQgd2l0aC5cbiAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIHBheWxvYWQgdG8gZGVjcnlwdCwgcmV0dXJuZWQgZnJvbSBhbiBlbmNyeXB0aW9uIG1ldGhvZC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgZGF0YS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdFdpdGhLZXkoa2V5LCBwYXlsb2FkKSB7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IEJ1ZmZlci5mcm9tKHBheWxvYWQuZGF0YSwgJ2Jhc2U2NCcpO1xuICAgIGNvbnN0IHZlY3RvciA9IEJ1ZmZlci5mcm9tKHBheWxvYWQuaXYsICdiYXNlNjQnKTtcbiAgICBsZXQgZGVjcnlwdGVkT2JqO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVjcnlwdCh7IG5hbWU6IERFUklWRURfS0VZX0ZPUk1BVCwgaXY6IHZlY3RvciB9LCBrZXksIGVuY3J5cHRlZERhdGEpO1xuICAgICAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0gbmV3IFVpbnQ4QXJyYXkocmVzdWx0KTtcbiAgICAgICAgY29uc3QgZGVjcnlwdGVkU3RyID0gQnVmZmVyLmZyb20oZGVjcnlwdGVkRGF0YSkudG9TdHJpbmcoU1RSSU5HX0VOQ09ESU5HKTtcbiAgICAgICAgZGVjcnlwdGVkT2JqID0gSlNPTi5wYXJzZShkZWNyeXB0ZWRTdHIpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzd29yZCcpO1xuICAgIH1cbiAgICByZXR1cm4gZGVjcnlwdGVkT2JqO1xufVxuZXhwb3J0cy5kZWNyeXB0V2l0aEtleSA9IGRlY3J5cHRXaXRoS2V5O1xuLyoqXG4gKiBSZWNlaXZlcyBhbiBleHBvcnRlZCBDcnlwdG9LZXkgc3RyaW5nIGFuZCBjcmVhdGVzIGEga2V5LlxuICpcbiAqIEBwYXJhbSBrZXlTdHJpbmcgLSBUaGUga2V5IHN0cmluZyB0byBpbXBvcnQuXG4gKiBAcmV0dXJucyBBIENyeXB0b0tleS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW1wb3J0S2V5KGtleVN0cmluZykge1xuICAgIGNvbnN0IGtleSA9IGF3YWl0IHdpbmRvdy5jcnlwdG8uc3VidGxlLmltcG9ydEtleShFWFBPUlRfRk9STUFULCBKU09OLnBhcnNlKGtleVN0cmluZyksIERFUklWRURfS0VZX0ZPUk1BVCwgdHJ1ZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gICAgcmV0dXJuIGtleTtcbn1cbmV4cG9ydHMuaW1wb3J0S2V5ID0gaW1wb3J0S2V5O1xuLyoqXG4gKiBSZWNlaXZlcyBhbiBleHBvcnRlZCBDcnlwdG9LZXkgc3RyaW5nLCBjcmVhdGVzIGEga2V5LFxuICogYW5kIGRlY3J5cHRzIGNpcGhlciB0ZXh0IHdpdGggdGhlIHJlY29uc3RydWN0ZWQga2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUgQ3J5cHRvS2V5IHRvIGV4cG9ydC5cbiAqIEByZXR1cm5zIEEga2V5IHN0cmluZy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXhwb3J0S2V5KGtleSkge1xuICAgIGNvbnN0IGV4cG9ydGVkS2V5ID0gYXdhaXQgd2luZG93LmNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KEVYUE9SVF9GT1JNQVQsIGtleSk7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGV4cG9ydGVkS2V5KTtcbn1cbmV4cG9ydHMuZXhwb3J0S2V5ID0gZXhwb3J0S2V5O1xuLyoqXG4gKiBHZW5lcmF0ZSBhIENyeXB0b0tleSBmcm9tIGEgcGFzc3dvcmQgYW5kIHJhbmRvbSBzYWx0LlxuICpcbiAqIEBwYXJhbSBwYXNzd29yZCAtIFRoZSBwYXNzd29yZCB0byB1c2UgdG8gZ2VuZXJhdGUga2V5LlxuICogQHBhcmFtIHNhbHQgLSBUaGUgc2FsdCBzdHJpbmcgdG8gdXNlIGluIGtleSBkZXJpdmF0aW9uLlxuICogQHBhcmFtIGV4cG9ydGFibGUgLSBTaG91bGQgdGhlIGRlcml2ZWQga2V5IGJlIGV4cG9ydGFibGUuXG4gKiBAcmV0dXJucyBBIENyeXB0b0tleSBmb3IgZW5jcnlwdGlvbiBhbmQgZGVjcnlwdGlvbi5cbiAqL1xuYXN5bmMgZnVuY3Rpb24ga2V5RnJvbVBhc3N3b3JkKHBhc3N3b3JkLCBzYWx0LCBleHBvcnRhYmxlID0gZmFsc2UpIHtcbiAgICBjb25zdCBwYXNzQnVmZmVyID0gQnVmZmVyLmZyb20ocGFzc3dvcmQsIFNUUklOR19FTkNPRElORyk7XG4gICAgY29uc3Qgc2FsdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHNhbHQsICdiYXNlNjQnKTtcbiAgICBjb25zdCBrZXkgPSBhd2FpdCBnbG9iYWwuY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIHBhc3NCdWZmZXIsIHsgbmFtZTogJ1BCS0RGMicgfSwgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XG4gICAgY29uc3QgZGVyaXZlZEtleSA9IGF3YWl0IGdsb2JhbC5jcnlwdG8uc3VidGxlLmRlcml2ZUtleSh7XG4gICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICBzYWx0OiBzYWx0QnVmZmVyLFxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwMCxcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgIH0sIGtleSwgeyBuYW1lOiBERVJJVkVEX0tFWV9GT1JNQVQsIGxlbmd0aDogMjU2IH0sIGV4cG9ydGFibGUsIFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgIHJldHVybiBkZXJpdmVkS2V5O1xufVxuZXhwb3J0cy5rZXlGcm9tUGFzc3dvcmQgPSBrZXlGcm9tUGFzc3dvcmQ7XG4vKipcbiAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyBpbnRvIGEgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBzdHIgLSBIZXggZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nIGVjb2RlZCBhcyBhIGJ5dGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlckZyb21TdG9yYWdlKHN0cikge1xuICAgIGNvbnN0IHN0cmlwU3RyID0gc3RyLnNsaWNlKDAsIDIpID09PSAnMHgnID8gc3RyLnNsaWNlKDIpIDogc3RyO1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KHN0cmlwU3RyLmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaXBTdHIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgY29uc3Qgc2VnID0gc3RyaXBTdHIuc3Vic3RyKGksIDIpO1xuICAgICAgICBidWZbaSAvIDJdID0gcGFyc2VJbnQoc2VnLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5leHBvcnRzLnNlcmlhbGl6ZUJ1ZmZlckZyb21TdG9yYWdlID0gc2VyaWFsaXplQnVmZmVyRnJvbVN0b3JhZ2U7XG4vKipcbiAqIENvbnZlcnRzIGEgYnVmZmVyIGludG8gYSBoZXggc3RyaW5nIHJlYWR5IGZvciBzdG9yYWdlLlxuICpcbiAqIEBwYXJhbSBidWZmZXIgLSBCdWZmZXIgdG8gc2VyaWFsaXplLlxuICogQHJldHVybnMgQSBoZXggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ1ZmZlckZvclN0b3JhZ2UoYnVmZmVyKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcweCc7XG4gICAgYnVmZmVyLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgIHJlc3VsdCArPSB1bnByZWZpeGVkSGV4KHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5zZXJpYWxpemVCdWZmZXJGb3JTdG9yYWdlID0gc2VyaWFsaXplQnVmZmVyRm9yU3RvcmFnZTtcbi8qKlxuICogQ29udmVydHMgYSBudW1iZXIgaW50byBoZXggdmFsdWUsIGFuZCBlbnN1cmVzIHByb3BlciBsZWFkaW5nIDBcbiAqIGZvciBzaW5nbGUgY2hhcmFjdGVycyBzdHJpbmdzLlxuICpcbiAqIEBwYXJhbSBudW0gLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gc3RyaW5nLlxuICogQHJldHVybnMgQW4gdW5wcmVmaXhlZCBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiB1bnByZWZpeGVkSGV4KG51bSkge1xuICAgIGxldCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHdoaWxlIChoZXgubGVuZ3RoIDwgMikge1xuICAgICAgICBoZXggPSBgMCR7aGV4fWA7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBzdHJpbmcgZm9yIHVzZSBhcyBhIHNhbHQgaW4gQ3J5cHRvS2V5IGdlbmVyYXRpb24uXG4gKlxuICogQHBhcmFtIGJ5dGVDb3VudCAtIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyBBIHJhbmRvbWx5IGdlbmVyYXRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU2FsdChieXRlQ291bnQgPSAzMikge1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShieXRlQ291bnQpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHZpZXcpO1xuICAgIC8vIFVpbnQ4QXJyYXkgaXMgYSBmaXhlZCBsZW5ndGggYXJyYXkgYW5kIHRodXMgZG9lcyBub3QgaGF2ZSBtZXRob2RzIGxpa2UgcG9wLCBldGNcbiAgICAvLyBzbyBUeXBlU2NyaXB0IGNvbXBsYWlucyBhYm91dCBjYXN0aW5nIGl0IHRvIGFuIGFycmF5LiBBcnJheS5mcm9tKCkgd29ya3MgaGVyZSBmb3JcbiAgICAvLyBnZXR0aW5nIHRoZSBwcm9wZXIgdHlwZSwgYnV0IGl0IHJlc3VsdHMgaW4gYSBmdW5jdGlvbmFsIGRpZmZlcmVuY2UuIEluIG9yZGVyIHRvXG4gICAgLy8gY2FzdCwgeW91IGhhdmUgdG8gZmlyc3QgY2FzdCB2aWV3IHRvIHVua25vd24gdGhlbiBjYXN0IHRoZSB1bmtub3duIHZhbHVlIHRvIG51bWJlcltdXG4gICAgLy8gVHlwZVNjcmlwdCBmdHc6IGRvdWJsZSBvcHQgaW4gdG8gd3JpdGUgcG90ZW50aWFsbHkgdHlwZS1taXNtYXRjaGVkIGNvZGUuXG4gICAgY29uc3QgYjY0ZW5jb2RlZCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB2aWV3KSk7XG4gICAgcmV0dXJuIGI2NGVuY29kZWQ7XG59XG5leHBvcnRzLmdlbmVyYXRlU2FsdCA9IGdlbmVyYXRlU2FsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImNvbnN0IHsgSERLZXkgfSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9oZGtleScpO1xuY29uc3QgeyBrZWNjYWsyNTYgfSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsnKTtcbmNvbnN0IHsgYnl0ZXNUb0hleCB9ID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3V0aWxzJyk7XG5jb25zdCB7XG4gIHN0cmlwSGV4UHJlZml4LFxuICBwcml2YXRlVG9QdWJsaWMsXG4gIHB1YmxpY1RvQWRkcmVzcyxcbiAgZWNzaWduLFxuICBhcnJUb0J1ZkFycixcbiAgYnVmZmVyVG9IZXgsXG59ID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdXRpbCcpO1xuY29uc3QgYmlwMzkgPSByZXF1aXJlKCdAbWV0YW1hc2svc2N1cmUtYmlwMzknKTtcbmNvbnN0IHsgd29yZGxpc3QgfSA9IHJlcXVpcmUoJ0BtZXRhbWFzay9zY3VyZS1iaXAzOS9kaXN0L3dvcmRsaXN0cy9lbmdsaXNoJyk7XG5jb25zdCB7XG4gIGNvbmNhdFNpZyxcbiAgZGVjcnlwdCxcbiAgZ2V0RW5jcnlwdGlvblB1YmxpY0tleSxcbiAgbm9ybWFsaXplLFxuICBwZXJzb25hbFNpZ24sXG4gIHNpZ25UeXBlZERhdGEsXG4gIFNpZ25UeXBlZERhdGFWZXJzaW9uLFxufSA9IHJlcXVpcmUoJ0BtZXRhbWFzay9ldGgtc2lnLXV0aWwnKTtcblxuLy8gT3B0aW9uczpcbmNvbnN0IGhkUGF0aFN0cmluZyA9IGBtLzQ0Jy82MCcvMCcvMGA7XG5jb25zdCB0eXBlID0gJ0hEIEtleSBUcmVlJztcblxuY2xhc3MgSGRLZXlyaW5nIHtcbiAgLyogUFVCTElDIE1FVEhPRFMgKi9cbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLl93YWxsZXRzID0gW107XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKTtcbiAgfVxuXG4gIGdlbmVyYXRlUmFuZG9tTW5lbW9uaWMoKSB7XG4gICAgdGhpcy5faW5pdEZyb21NbmVtb25pYyhiaXAzOS5nZW5lcmF0ZU1uZW1vbmljKHdvcmRsaXN0KSk7XG4gIH1cblxuICBfdWludDhBcnJheVRvU3RyaW5nKG1uZW1vbmljKSB7XG4gICAgY29uc3QgcmVjb3ZlcmVkSW5kaWNlcyA9IEFycmF5LmZyb20oXG4gICAgICBuZXcgVWludDE2QXJyYXkobmV3IFVpbnQ4QXJyYXkobW5lbW9uaWMpLmJ1ZmZlciksXG4gICAgKTtcbiAgICByZXR1cm4gcmVjb3ZlcmVkSW5kaWNlcy5tYXAoKGkpID0+IHdvcmRsaXN0W2ldKS5qb2luKCcgJyk7XG4gIH1cblxuICBfc3RyaW5nVG9VaW50OEFycmF5KG1uZW1vbmljKSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IG1uZW1vbmljLnNwbGl0KCcgJykubWFwKCh3b3JkKSA9PiB3b3JkbGlzdC5pbmRleE9mKHdvcmQpKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KGluZGljZXMpLmJ1ZmZlcik7XG4gIH1cblxuICBfbW5lbW9uaWNUb1VpbnQ4QXJyYXkobW5lbW9uaWMpIHtcbiAgICBsZXQgbW5lbW9uaWNEYXRhID0gbW5lbW9uaWM7XG4gICAgLy8gd2hlbiBlbmNyeXB0ZWQvZGVjcnlwdGVkLCBidWZmZXJzIGdldCBjYXN0IGludG8ganMgb2JqZWN0IHdpdGggYSBwcm9wZXJ0eSB0eXBlIHNldCB0byBidWZmZXJcbiAgICBpZiAobW5lbW9uaWMgJiYgbW5lbW9uaWMudHlwZSAmJiBtbmVtb25pYy50eXBlID09PSAnQnVmZmVyJykge1xuICAgICAgbW5lbW9uaWNEYXRhID0gbW5lbW9uaWMuZGF0YTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAvLyB0aGlzIGJsb2NrIGlzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHZhdWx0cyB0aGF0IHdlcmUgcHJldmlvdXNseSBzdG9yZWQgYXMgYnVmZmVycywgbnVtYmVyIGFycmF5cyBvciBwbGFpbiB0ZXh0IHN0cmluZ3NcbiAgICAgIHR5cGVvZiBtbmVtb25pY0RhdGEgPT09ICdzdHJpbmcnIHx8XG4gICAgICBCdWZmZXIuaXNCdWZmZXIobW5lbW9uaWNEYXRhKSB8fFxuICAgICAgQXJyYXkuaXNBcnJheShtbmVtb25pY0RhdGEpXG4gICAgKSB7XG4gICAgICBsZXQgbW5lbW9uaWNBc1N0cmluZyA9IG1uZW1vbmljRGF0YTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1uZW1vbmljRGF0YSkpIHtcbiAgICAgICAgbW5lbW9uaWNBc1N0cmluZyA9IEJ1ZmZlci5mcm9tKG1uZW1vbmljRGF0YSkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKG1uZW1vbmljRGF0YSkpIHtcbiAgICAgICAgbW5lbW9uaWNBc1N0cmluZyA9IG1uZW1vbmljRGF0YS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX3N0cmluZ1RvVWludDhBcnJheShtbmVtb25pY0FzU3RyaW5nKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgbW5lbW9uaWNEYXRhIGluc3RhbmNlb2YgT2JqZWN0ICYmXG4gICAgICAhKG1uZW1vbmljRGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgKSB7XG4gICAgICAvLyB3aGVuIGVuY3J5cHRlZC9kZWNyeXB0ZWQgdGhlIFVpbnQ4QXJyYXkgYmVjb21lcyBhIGpzIG9iamVjdCB3ZSBuZWVkIHRvIGNhc3QgYmFjayB0byBhIFVpbnQ4QXJyYXlcbiAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oT2JqZWN0LnZhbHVlcyhtbmVtb25pY0RhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG1uZW1vbmljRGF0YTtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBtbmVtb25pY0FzU3RyaW5nID0gdGhpcy5fdWludDhBcnJheVRvU3RyaW5nKHRoaXMubW5lbW9uaWMpO1xuICAgIGNvbnN0IHVpbnQ4QXJyYXlNbmVtb25pYyA9IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKS5lbmNvZGUoXG4gICAgICBtbmVtb25pY0FzU3RyaW5nLFxuICAgICk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIG1uZW1vbmljOiBBcnJheS5mcm9tKHVpbnQ4QXJyYXlNbmVtb25pYyksXG4gICAgICBudW1iZXJPZkFjY291bnRzOiB0aGlzLl93YWxsZXRzLmxlbmd0aCxcbiAgICAgIGhkUGF0aDogdGhpcy5oZFBhdGgsXG4gICAgfSk7XG4gIH1cblxuICBkZXNlcmlhbGl6ZShvcHRzID0ge30pIHtcbiAgICBpZiAob3B0cy5udW1iZXJPZkFjY291bnRzICYmICFvcHRzLm1uZW1vbmljKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFdGgtSGQtS2V5cmluZzogRGVzZXJpYWxpemUgbWV0aG9kIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBhbiBvcHRzIHZhbHVlIGZvciBudW1iZXJPZkFjY291bnRzIGFuZCBubyBtZW5tb25pYycsXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0V0aC1IZC1LZXlyaW5nOiBTZWNyZXQgcmVjb3ZlcnkgcGhyYXNlIGFscmVhZHkgcHJvdmlkZWQnLFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLl93YWxsZXRzID0gW107XG4gICAgdGhpcy5tbmVtb25pYyA9IG51bGw7XG4gICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB0aGlzLmhkUGF0aCA9IG9wdHMuaGRQYXRoIHx8IGhkUGF0aFN0cmluZztcblxuICAgIGlmIChvcHRzLm1uZW1vbmljKSB7XG4gICAgICB0aGlzLl9pbml0RnJvbU1uZW1vbmljKG9wdHMubW5lbW9uaWMpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm51bWJlck9mQWNjb3VudHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZEFjY291bnRzKG9wdHMubnVtYmVyT2ZBY2NvdW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gIH1cblxuICBhZGRBY2NvdW50cyhudW1iZXJPZkFjY291bnRzID0gMSkge1xuICAgIGlmICghdGhpcy5yb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aC1IZC1LZXlyaW5nOiBObyBzZWNyZXQgcmVjb3ZlcnkgcGhyYXNlIHByb3ZpZGVkJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkTGVuID0gdGhpcy5fd2FsbGV0cy5sZW5ndGg7XG4gICAgY29uc3QgbmV3V2FsbGV0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBvbGRMZW47IGkgPCBudW1iZXJPZkFjY291bnRzICsgb2xkTGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHdhbGxldCA9IHRoaXMucm9vdC5kZXJpdmVDaGlsZChpKTtcbiAgICAgIG5ld1dhbGxldHMucHVzaCh3YWxsZXQpO1xuICAgICAgdGhpcy5fd2FsbGV0cy5wdXNoKHdhbGxldCk7XG4gICAgfVxuICAgIGNvbnN0IGhleFdhbGxldHMgPSBuZXdXYWxsZXRzLm1hcCgodykgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3Nmcm9tUHVibGljS2V5KHcucHVibGljS2V5KTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGhleFdhbGxldHMpO1xuICB9XG5cbiAgZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldHMubWFwKCh3KSA9PiB0aGlzLl9hZGRyZXNzZnJvbVB1YmxpY0tleSh3LnB1YmxpY0tleSkpO1xuICB9XG5cbiAgLyogQkFTRSBLRVlSSU5HIE1FVEhPRFMgKi9cblxuICAvLyByZXR1cm5zIGFuIGFkZHJlc3Mgc3BlY2lmaWMgdG8gYW4gYXBwXG4gIGFzeW5jIGdldEFwcEtleUFkZHJlc3MoYWRkcmVzcywgb3JpZ2luKSB7XG4gICAgaWYgKCFvcmlnaW4gfHwgdHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ29yaWdpbicgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdgKTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fZ2V0V2FsbGV0Rm9yQWNjb3VudChhZGRyZXNzLCB7XG4gICAgICB3aXRoQXBwS2V5T3JpZ2luOiBvcmlnaW4sXG4gICAgfSk7XG4gICAgY29uc3QgYXBwS2V5QWRkcmVzcyA9IG5vcm1hbGl6ZShcbiAgICAgIHB1YmxpY1RvQWRkcmVzcyh3YWxsZXQucHVibGljS2V5KS50b1N0cmluZygnaGV4JyksXG4gICAgKTtcblxuICAgIHJldHVybiBhcHBLZXlBZGRyZXNzO1xuICB9XG5cbiAgLy8gZXhwb3J0QWNjb3VudCBzaG91bGQgcmV0dXJuIGEgaGV4LWVuY29kZWQgcHJpdmF0ZSBrZXk6XG4gIGFzeW5jIGV4cG9ydEFjY291bnQoYWRkcmVzcywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fZ2V0V2FsbGV0Rm9yQWNjb3VudChhZGRyZXNzLCBvcHRzKTtcbiAgICByZXR1cm4gYnl0ZXNUb0hleCh3YWxsZXQucHJpdmF0ZUtleSk7XG4gIH1cblxuICAvLyB0eCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZXRoZXJldW1qcy10cmFuc2FjdGlvbiBjbGFzcy5cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHR4LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcihhZGRyZXNzLCBvcHRzKTtcbiAgICBjb25zdCBzaWduZWRUeCA9IHR4LnNpZ24ocHJpdktleSk7XG4gICAgLy8gTmV3ZXIgdmVyc2lvbnMgb2YgRXRoZXJldW1qcy10eCBhcmUgaW1tdXRhYmxlIGFuZCByZXR1cm4gYSBuZXcgdHggb2JqZWN0XG4gICAgcmV0dXJuIHNpZ25lZFR4ID09PSB1bmRlZmluZWQgPyB0eCA6IHNpZ25lZFR4O1xuICB9XG5cbiAgLy8gRm9yIGV0aF9zaWduLCB3ZSBuZWVkIHRvIHNpZ24gYXJiaXRyYXJ5IGRhdGE6XG4gIGFzeW5jIHNpZ25NZXNzYWdlKGFkZHJlc3MsIGRhdGEsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBzdHJpcEhleFByZWZpeChkYXRhKTtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcihhZGRyZXNzLCBvcHRzKTtcbiAgICBjb25zdCBtc2dTaWcgPSBlY3NpZ24oQnVmZmVyLmZyb20obWVzc2FnZSwgJ2hleCcpLCBwcml2S2V5KTtcbiAgICBjb25zdCByYXdNc2dTaWcgPSBjb25jYXRTaWcobXNnU2lnLnYsIG1zZ1NpZy5yLCBtc2dTaWcucyk7XG4gICAgcmV0dXJuIHJhd01zZ1NpZztcbiAgfVxuXG4gIC8vIEZvciBwZXJzb25hbF9zaWduLCB3ZSBuZWVkIHRvIHByZWZpeCB0aGUgbWVzc2FnZTpcbiAgYXN5bmMgc2lnblBlcnNvbmFsTWVzc2FnZShhZGRyZXNzLCBtc2dIZXgsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHByaXZLZXkgPSB0aGlzLl9nZXRQcml2YXRlS2V5Rm9yKGFkZHJlc3MsIG9wdHMpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBCdWZmZXIuZnJvbShwcml2S2V5LCAnaGV4Jyk7XG4gICAgY29uc3Qgc2lnID0gcGVyc29uYWxTaWduKHsgcHJpdmF0ZUtleSwgZGF0YTogbXNnSGV4IH0pO1xuICAgIHJldHVybiBzaWc7XG4gIH1cblxuICAvLyBGb3IgZXRoX2RlY3J5cHRNZXNzYWdlOlxuICBhc3luYyBkZWNyeXB0TWVzc2FnZSh3aXRoQWNjb3VudCwgZW5jcnlwdGVkRGF0YSkge1xuICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX2dldFdhbGxldEZvckFjY291bnQod2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHsgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUFzVWludDhBcnJheSB9ID0gd2FsbGV0O1xuICAgIGNvbnN0IHByaXZhdGVLZXlBc0hleCA9IEJ1ZmZlci5mcm9tKHByaXZhdGVLZXlBc1VpbnQ4QXJyYXkpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBjb25zdCBzaWcgPSBkZWNyeXB0KHsgcHJpdmF0ZUtleTogcHJpdmF0ZUtleUFzSGV4LCBlbmNyeXB0ZWREYXRhIH0pO1xuICAgIHJldHVybiBzaWc7XG4gIH1cblxuICAvLyBwZXJzb25hbF9zaWduVHlwZWREYXRhLCBzaWducyBkYXRhIGFsb25nIHdpdGggdGhlIHNjaGVtYVxuICBhc3luYyBzaWduVHlwZWREYXRhKFxuICAgIHdpdGhBY2NvdW50LFxuICAgIHR5cGVkRGF0YSxcbiAgICBvcHRzID0geyB2ZXJzaW9uOiBTaWduVHlwZWREYXRhVmVyc2lvbi5WMSB9LFxuICApIHtcbiAgICAvLyBUcmVhdCBpbnZhbGlkIHZlcnNpb25zIGFzIFwiVjFcIlxuICAgIGNvbnN0IHZlcnNpb24gPSBPYmplY3Qua2V5cyhTaWduVHlwZWREYXRhVmVyc2lvbikuaW5jbHVkZXMob3B0cy52ZXJzaW9uKVxuICAgICAgPyBvcHRzLnZlcnNpb25cbiAgICAgIDogU2lnblR5cGVkRGF0YVZlcnNpb24uVjE7XG5cbiAgICBjb25zdCBwcml2YXRlS2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcih3aXRoQWNjb3VudCwgb3B0cyk7XG4gICAgcmV0dXJuIHNpZ25UeXBlZERhdGEoeyBwcml2YXRlS2V5LCBkYXRhOiB0eXBlZERhdGEsIHZlcnNpb24gfSk7XG4gIH1cblxuICByZW1vdmVBY2NvdW50KGFjY291bnQpIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplKGFjY291bnQpO1xuICAgIGlmIChcbiAgICAgICF0aGlzLl93YWxsZXRzXG4gICAgICAgIC5tYXAoKHsgcHVibGljS2V5IH0pID0+IHRoaXMuX2FkZHJlc3Nmcm9tUHVibGljS2V5KHB1YmxpY0tleSkpXG4gICAgICAgIC5pbmNsdWRlcyhhZGRyZXNzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7YWRkcmVzc30gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO1xuICAgIH1cblxuICAgIHRoaXMuX3dhbGxldHMgPSB0aGlzLl93YWxsZXRzLmZpbHRlcihcbiAgICAgICh7IHB1YmxpY0tleSB9KSA9PiB0aGlzLl9hZGRyZXNzZnJvbVB1YmxpY0tleShwdWJsaWNLZXkpICE9PSBhZGRyZXNzLFxuICAgICk7XG4gIH1cblxuICAvLyBnZXQgcHVibGljIGtleSBmb3IgbmFjbFxuICBhc3luYyBnZXRFbmNyeXB0aW9uUHVibGljS2V5KHdpdGhBY2NvdW50LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcih3aXRoQWNjb3VudCwgb3B0cyk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0RW5jcnlwdGlvblB1YmxpY0tleShwcml2S2V5KTtcbiAgICByZXR1cm4gcHVibGljS2V5O1xuICB9XG5cbiAgX2dldFByaXZhdGVLZXlGb3IoYWRkcmVzcywgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBhZGRyZXNzLicpO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXQgPSB0aGlzLl9nZXRXYWxsZXRGb3JBY2NvdW50KGFkZHJlc3MsIG9wdHMpO1xuICAgIHJldHVybiB3YWxsZXQucHJpdmF0ZUtleTtcbiAgfVxuXG4gIF9nZXRXYWxsZXRGb3JBY2NvdW50KGFjY291bnQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemUoYWNjb3VudCk7XG4gICAgbGV0IHdhbGxldCA9IHRoaXMuX3dhbGxldHMuZmluZCgoeyBwdWJsaWNLZXkgfSkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX2FkZHJlc3Nmcm9tUHVibGljS2V5KHB1YmxpY0tleSkgPT09IGFkZHJlc3M7XG4gICAgfSk7XG4gICAgaWYgKCF3YWxsZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSEQgS2V5cmluZyAtIFVuYWJsZSB0byBmaW5kIG1hdGNoaW5nIGFkZHJlc3MuJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMud2l0aEFwcEtleU9yaWdpbikge1xuICAgICAgY29uc3QgeyBwcml2YXRlS2V5IH0gPSB3YWxsZXQ7XG4gICAgICBjb25zdCBhcHBLZXlPcmlnaW5CdWZmZXIgPSBCdWZmZXIuZnJvbShvcHRzLndpdGhBcHBLZXlPcmlnaW4sICd1dGY4Jyk7XG4gICAgICBjb25zdCBhcHBLZXlCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtwcml2YXRlS2V5LCBhcHBLZXlPcmlnaW5CdWZmZXJdKTtcbiAgICAgIGNvbnN0IGFwcEtleVByaXZhdGVLZXkgPSBhcnJUb0J1ZkFycihrZWNjYWsyNTYoYXBwS2V5QnVmZmVyLCAyNTYpKTtcbiAgICAgIGNvbnN0IGFwcEtleVB1YmxpY0tleSA9IHByaXZhdGVUb1B1YmxpYyhhcHBLZXlQcml2YXRlS2V5KTtcbiAgICAgIHdhbGxldCA9IHsgcHJpdmF0ZUtleTogYXBwS2V5UHJpdmF0ZUtleSwgcHVibGljS2V5OiBhcHBLZXlQdWJsaWNLZXkgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2FsbGV0O1xuICB9XG5cbiAgLyogUFJJVkFURSAvIFVUSUxJVFkgTUVUSE9EUyAqL1xuXG4gIC8qKlxuICAgKiBTZXRzIGFwcHJvcHJpYXRlIHByb3BlcnRpZXMgZm9yIHRoZSBrZXlyaW5nIGJhc2VkIG9uIHRoZSBnaXZlblxuICAgKiBCSVAzOS1jb21wbGlhbnQgbW5lbW9uaWMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PG51bWJlcj58QnVmZmVyfSBtbmVtb25pYyAtIEEgc2VlZCBwaHJhc2UgcmVwcmVzZW50ZWRcbiAgICogYXMgYSBzdHJpbmcsIGFuIGFycmF5IG9mIFVURi04IGJ5dGVzLCBvciBhIEJ1ZmZlci4gTW5lbW9uaWMgaW5wdXRcbiAgICogcGFzc2VkIGFzIHR5cGUgYnVmZmVyIG9yIGFycmF5IG9mIFVURi04IGJ5dGVzIG11c3QgYmUgTkZLRCBub3JtYWxpemVkLlxuICAgKi9cbiAgX2luaXRGcm9tTW5lbW9uaWMobW5lbW9uaWMpIHtcbiAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFdGgtSGQtS2V5cmluZzogU2VjcmV0IHJlY292ZXJ5IHBocmFzZSBhbHJlYWR5IHByb3ZpZGVkJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5tbmVtb25pYyA9IHRoaXMuX21uZW1vbmljVG9VaW50OEFycmF5KG1uZW1vbmljKTtcblxuICAgIC8vIHZhbGlkYXRlIGJlZm9yZSBpbml0aWFsaXppbmdcbiAgICBjb25zdCBpc1ZhbGlkID0gYmlwMzkudmFsaWRhdGVNbmVtb25pYyh0aGlzLm1uZW1vbmljLCB3b3JkbGlzdCk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdFdGgtSGQtS2V5cmluZzogSW52YWxpZCBzZWNyZXQgcmVjb3ZlcnkgcGhyYXNlIHByb3ZpZGVkJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvbm8tc3luY1xuICAgIGNvbnN0IHNlZWQgPSBiaXAzOS5tbmVtb25pY1RvU2VlZFN5bmModGhpcy5tbmVtb25pYywgd29yZGxpc3QpO1xuICAgIHRoaXMuaGRXYWxsZXQgPSBIREtleS5mcm9tTWFzdGVyU2VlZChzZWVkKTtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmhkV2FsbGV0LmRlcml2ZSh0aGlzLmhkUGF0aCk7XG4gIH1cblxuICAvLyBzbWFsbCBoZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCBwdWJsaWNLZXkgaW4gVWludDhBcnJheSBmb3JtIHRvIGEgcHVibGljQWRkcmVzcyBhcyBhIGhleFxuICBfYWRkcmVzc2Zyb21QdWJsaWNLZXkocHVibGljS2V5KSB7XG4gICAgcmV0dXJuIGJ1ZmZlclRvSGV4KFxuICAgICAgcHVibGljVG9BZGRyZXNzKEJ1ZmZlci5mcm9tKHB1YmxpY0tleSksIHRydWUpLFxuICAgICkudG9Mb3dlckNhc2UoKTtcbiAgfVxufVxuXG5IZEtleXJpbmcudHlwZSA9IHR5cGU7XG5tb2R1bGUuZXhwb3J0cyA9IEhkS2V5cmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vdXRwdXQgPSBleHBvcnRzLmV4aXN0cyA9IGV4cG9ydHMuaGFzaCA9IGV4cG9ydHMuYnl0ZXMgPSBleHBvcnRzLmJvb2wgPSBleHBvcnRzLm51bWJlciA9IHZvaWQgMDtcbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBwb3NpdGl2ZSBpbnRlZ2VyOiAke259YCk7XG59XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG5leHBvcnRzLmJvb2wgPSBib29sO1xuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgVWludDhBcnJheScpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBVaW50OEFycmF5IG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5leHBvcnRzLmJ5dGVzID0gYnl0ZXM7XG5mdW5jdGlvbiBoYXNoKGhhc2gpIHtcbiAgICBpZiAodHlwZW9mIGhhc2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGhhc2guY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5leHBvcnRzLmV4aXN0cyA9IGV4aXN0cztcbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnRzLm91dHB1dCA9IG91dHB1dDtcbmNvbnN0IGFzc2VydCA9IHtcbiAgICBudW1iZXIsXG4gICAgYm9vbCxcbiAgICBieXRlcyxcbiAgICBoYXNoLFxuICAgIGV4aXN0cyxcbiAgICBvdXRwdXQsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gYXNzZXJ0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNIQTIgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIEJhc2UgU0hBMiBjbGFzcyAoUkZDIDYyMzQpXG5jbGFzcyBTSEEyIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpbiBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKCh2LCBpKSA9PiBvdmlldy5zZXRVaW50MzIoNCAqIGksIHYsIGlzTEUpKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMiA9IFNIQTI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkID0gZXhwb3J0cy50b0JpZyA9IGV4cG9ydHMuc3BsaXQgPSBleHBvcnRzLmZyb21CaWcgPSB2b2lkIDA7XG5jb25zdCBVMzJfTUFTSzY0ID0gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmV4cG9ydHMuZnJvbUJpZyA9IGZyb21CaWc7XG5mdW5jdGlvbiBzcGxpdChsc3QsIGxlID0gZmFsc2UpIHtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbHN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG5leHBvcnRzLnRvQmlnID0gdG9CaWc7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgbCkgPT4gaDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RsU0ggPSAoaCwgbCwgcykgPT4gKGggPDwgcykgfCAobCA+Pj4gKDMyIC0gcykpO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5jb25zdCByb3RsQkwgPSAoaCwgbCwgcykgPT4gKGggPDwgKHMgLSAzMikpIHwgKGwgPj4+ICg2NCAtIHMpKTtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbi8vIFJlbW92aW5nIFwiZXhwb3J0XCIgaGFzIDUlIHBlcmYgcGVuYWx0eSAtXy1cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbmV4cG9ydHMuYWRkID0gYWRkO1xuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnOiBleHBvcnRzLnRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHU2NDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSB2b2lkIDA7XG5leHBvcnRzLmNyeXB0byA9IHtcbiAgICBub2RlOiB1bmRlZmluZWQsXG4gICAgd2ViOiB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkLFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5obWFjID0gdm9pZCAwO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIEhNQUMgKFJGQyAyMTA0KVxuY2xhc3MgSE1BQyBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lmhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKF9rZXkpO1xuICAgICAgICB0aGlzLmlIYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmlIYXNoLnVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKGJ1Zik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0LmJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5jb25zdCBobWFjID0gKGhhc2gsIGtleSwgbWVzc2FnZSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KS51cGRhdGUobWVzc2FnZSkuZGlnZXN0KCk7XG5leHBvcnRzLmhtYWMgPSBobWFjO1xuZXhwb3J0cy5obWFjLmNyZWF0ZSA9IChoYXNoLCBrZXkpID0+IG5ldyBITUFDKGhhc2gsIGtleSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5SSVBFTUQxNjAgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4vLyBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC9wZGYvQUItOTYwMS9BQi05NjAxLnBkZlxuY29uc3QgUmhvID0gbmV3IFVpbnQ4QXJyYXkoWzcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDhdKTtcbmNvbnN0IElkID0gVWludDhBcnJheS5mcm9tKHsgbGVuZ3RoOiAxNiB9LCAoXywgaSkgPT4gaSk7XG5jb25zdCBQaSA9IElkLm1hcCgoaSkgPT4gKDkgKiBpICsgNSkgJSAxNik7XG5sZXQgaWR4TCA9IFtJZF07XG5sZXQgaWR4UiA9IFtQaV07XG5mb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKylcbiAgICBmb3IgKGxldCBqIG9mIFtpZHhMLCBpZHhSXSlcbiAgICAgICAgai5wdXNoKGpbaV0ubWFwKChrKSA9PiBSaG9ba10pKTtcbmNvbnN0IHNoaWZ0cyA9IFtcbiAgICBbMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4XSxcbiAgICBbMTIsIDEzLCAxMSwgMTUsIDYsIDksIDksIDcsIDEyLCAxNSwgMTEsIDEzLCA3LCA4LCA3LCA3XSxcbiAgICBbMTMsIDE1LCAxNCwgMTEsIDcsIDcsIDYsIDgsIDEzLCAxNCwgMTMsIDEyLCA1LCA1LCA2LCA5XSxcbiAgICBbMTQsIDExLCAxMiwgMTQsIDgsIDYsIDUsIDUsIDE1LCAxMiwgMTUsIDE0LCA5LCA5LCA4LCA2XSxcbiAgICBbMTUsIDEyLCAxMywgMTMsIDksIDUsIDgsIDYsIDE0LCAxMSwgMTIsIDExLCA4LCA2LCA1LCA1XSxcbl0ubWFwKChpKSA9PiBuZXcgVWludDhBcnJheShpKSk7XG5jb25zdCBzaGlmdHNMID0gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSID0gaWR4Ui5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzW2ldW2pdKSk7XG5jb25zdCBLbCA9IG5ldyBVaW50MzJBcnJheShbMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZV0pO1xuY29uc3QgS3IgPSBuZXcgVWludDMyQXJyYXkoWzB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDBdKTtcbi8vIFRoZSByb3RhdGUgbGVmdCAoY2lyY3VsYXIgbGVmdCBzaGlmdCkgb3BlcmF0aW9uIGZvciB1aW50MzJcbmNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICh3b3JkID4+PiAoMzIgLSBzaGlmdCkpO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiBmKGdyb3VwLCB4LCB5LCB6KSB7XG4gICAgaWYgKGdyb3VwID09PSAwKVxuICAgICAgICByZXR1cm4geCBeIHkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGVsc2UgaWYgKGdyb3VwID09PSAzKVxuICAgICAgICByZXR1cm4gKHggJiB6KSB8ICh5ICYgfnopO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuY29uc3QgQlVGID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIF9zaGEyX2pzXzEuU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IDB4ZWZjZGFiODkgfCAwO1xuICAgICAgICB0aGlzLmgyID0gMHg5OGJhZGNmZSB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2IHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IDB4YzNkMmUxZjAgfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgaDAsIGgxLCBoMiwgaDMsIGg0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW2gwLCBoMSwgaDIsIGgzLCBoNF07XG4gICAgfVxuICAgIHNldChoMCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgdGhpcy5oMCA9IGgwIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IGgxIHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IGgyIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IGgzIHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IGg0IHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIEJVRltpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgYWwgPSB0aGlzLmgwIHwgMCwgYXIgPSBhbCwgYmwgPSB0aGlzLmgxIHwgMCwgYnIgPSBibCwgY2wgPSB0aGlzLmgyIHwgMCwgY3IgPSBjbCwgZGwgPSB0aGlzLmgzIHwgMCwgZHIgPSBkbCwgZWwgPSB0aGlzLmg0IHwgMCwgZXIgPSBlbDtcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBpdGVyYXRpbmcgMCB0byA4MCwgd2Ugc3BsaXQgaXQgaW50byA1IGdyb3Vwc1xuICAgICAgICAvLyBBbmQgdXNlIHRoZSBncm91cHMgaW4gY29uc3RhbnRzLCBmdW5jdGlvbnMsIGV0Yy4gTXVjaCBzaW1wbGVyXG4gICAgICAgIGZvciAobGV0IGdyb3VwID0gMDsgZ3JvdXAgPCA1OyBncm91cCsrKSB7XG4gICAgICAgICAgICBjb25zdCByR3JvdXAgPSA0IC0gZ3JvdXA7XG4gICAgICAgICAgICBjb25zdCBoYmwgPSBLbFtncm91cF0sIGhiciA9IEtyW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBybCA9IGlkeExbZ3JvdXBdLCByciA9IGlkeFJbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNsID0gc2hpZnRzTFtncm91cF0sIHNyID0gc2hpZnRzUltncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGwgPSAocm90bChhbCArIGYoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGW3JsW2ldXSArIGhibCwgc2xbaV0pICsgZWwpIHwgMDtcbiAgICAgICAgICAgICAgICBhbCA9IGVsLCBlbCA9IGRsLCBkbCA9IHJvdGwoY2wsIDEwKSB8IDAsIGNsID0gYmwsIGJsID0gdGw7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMiBsb29wcyBhcmUgMTAlIGZhc3RlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHIgPSAocm90bChhciArIGYockdyb3VwLCBiciwgY3IsIGRyKSArIEJVRltycltpXV0gKyBoYnIsIHNyW2ldKSArIGVyKSB8IDA7XG4gICAgICAgICAgICAgICAgYXIgPSBlciwgZXIgPSBkciwgZHIgPSByb3RsKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBCVUYuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLlJJUEVNRDE2MCA9IFJJUEVNRDE2MDtcbi8qKlxuICogUklQRU1ELTE2MCAtIGEgaGFzaCBmdW5jdGlvbiBmcm9tIDE5OTBzLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBtc2cgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBSSVBFTUQxNjAoKSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjU2ID0gdm9pZCAwO1xuY29uc3QgX3NoYTJfanNfMSA9IHJlcXVpcmUoXCIuL19zaGEyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG4vLyBNYWpvcml0eSBmdW5jdGlvbiwgdHJ1ZSBpZiBhbnkgdHdvIGlucHVzdCBpcyB0cnVlXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSVYgPSBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIF9zaGEyX2pzXzEuU0hBMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBJVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IElWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBJVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IElWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBJVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShXMTUsIDcpIF4gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzIsIDE3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCA2KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDExKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDEzKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTI1Nl9XLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMjU2KCkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYTM4NCA9IGV4cG9ydHMuc2hhNTEyXzI1NiA9IGV4cG9ydHMuc2hhNTEyID0gZXhwb3J0cy5TSEE1MTIgPSB2b2lkIDA7XG5jb25zdCBfc2hhMl9qc18xID0gcmVxdWlyZShcIi4vX3NoYTIuanNcIik7XG5jb25zdCBfdTY0X2pzXzEgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUm91bmQgY29udGFudHMgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBbU0hBNTEyX0toLCBTSEE1MTJfS2xdID0gX3U2NF9qc18xLmRlZmF1bHQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5jb25zdCBTSEE1MTJfV19IID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSBuZXcgVWludDMyQXJyYXkoODApO1xuY2xhc3MgU0hBNTEyIGV4dGVuZHMgX3NoYTJfanNfMS5TSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMTI4LCA2NCwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZSB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIEFsc28gbG9va3MgY2xlYW5lciBhbmQgZWFzaWVyIHRvIHZlcmlmeSB3aXRoIHNwZWMuXG4gICAgICAgIC8vIEluaXRpYWwgc3RhdGUgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTkpOlxuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHg2YTA5ZTY2NyB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGYzYmNjOTA4IHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4YmI2N2FlODUgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHg4NGNhYTczYiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDNjNmVmMzcyIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4ZmU5NGY4MmIgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHhhNTRmZjUzYSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDVmMWQzNmYxIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4NTEwZTUyN2YgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhZGU2ODJkMSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweDliMDU2ODhjIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4MmIzZTZjMWYgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgxZjgzZDlhYiB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweGZiNDFiZDZiIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4NWJlMGNkMTkgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHgxMzdlMjE3OSB8IDA7XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCkge1xuICAgICAgICB0aGlzLkFoID0gQWggfCAwO1xuICAgICAgICB0aGlzLkFsID0gQWwgfCAwO1xuICAgICAgICB0aGlzLkJoID0gQmggfCAwO1xuICAgICAgICB0aGlzLkJsID0gQmwgfCAwO1xuICAgICAgICB0aGlzLkNoID0gQ2ggfCAwO1xuICAgICAgICB0aGlzLkNsID0gQ2wgfCAwO1xuICAgICAgICB0aGlzLkRoID0gRGggfCAwO1xuICAgICAgICB0aGlzLkRsID0gRGwgfCAwO1xuICAgICAgICB0aGlzLkVoID0gRWggfCAwO1xuICAgICAgICB0aGlzLkVsID0gRWwgfCAwO1xuICAgICAgICB0aGlzLkZoID0gRmggfCAwO1xuICAgICAgICB0aGlzLkZsID0gRmwgfCAwO1xuICAgICAgICB0aGlzLkdoID0gR2ggfCAwO1xuICAgICAgICB0aGlzLkdsID0gR2wgfCAwO1xuICAgICAgICB0aGlzLkhoID0gSGggfCAwO1xuICAgICAgICB0aGlzLkhsID0gSGwgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA2NCB3b3JkcyB3WzE2Li43OV0gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNCkge1xuICAgICAgICAgICAgU0hBNTEyX1dfSFtpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCk7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gdmlldy5nZXRVaW50MzIoKG9mZnNldCArPSA0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gczAgOj0gKHdbaS0xNV0gcmlnaHRyb3RhdGUgMSkgeG9yICh3W2ktMTVdIHJpZ2h0cm90YXRlIDgpIHhvciAod1tpLTE1XSByaWdodHNoaWZ0IDcpXG4gICAgICAgICAgICBjb25zdCBXMTVoID0gU0hBNTEyX1dfSFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcxNWwgPSBTSEE1MTJfV19MW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczBoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gX3U2NF9qc18xLmRlZmF1bHQuc2hyU0goVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICBjb25zdCBzMGwgPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5zaHJTTChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIC8vIHMxIDo9ICh3W2ktMl0gcmlnaHRyb3RhdGUgMTkpIHhvciAod1tpLTJdIHJpZ2h0cm90YXRlIDYxKSB4b3IgKHdbaS0yXSByaWdodHNoaWZ0IDYpXG4gICAgICAgICAgICBjb25zdCBXMmggPSBTSEE1MTJfV19IW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMmwgPSBTSEE1MTJfV19MW2kgLSAyXSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMWggPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gX3U2NF9qc18xLmRlZmF1bHQuc2hyU0goVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgY29uc3QgczFsID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNMKFcyaCwgVzJsLCAxOSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIF91NjRfanNfMS5kZWZhdWx0LnNoclNMKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIC8vIFNIQTI1Nl9XW2ldID0gczAgKyBzMSArIFNIQTI1Nl9XW2kgLSA3XSArIFNIQTI1Nl9XW2kgLSAxNl07XG4gICAgICAgICAgICBjb25zdCBTVU1sID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKEVoLCBFbCwgMTQpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKEVoLCBFbCwgMTgpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChFaCwgRWwsIDE0KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChFaCwgRWwsIDE4KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQ1TChIbCwgc2lnbWExbCwgQ0hJbCwgU0hBNTEyX0tsW2ldLCBTSEE1MTJfV19MW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKEFoLCBBbCwgMjgpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEFoLCBBbCwgMzQpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChBaCwgQWwsIDI4KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCTChBaCwgQWwsIDM0KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDNMKFQxbCwgc2lnbWEwbCwgTUFKbCk7XG4gICAgICAgICAgICBBaCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgQmggfCAwLCBCbCB8IDApKTtcbiAgICAgICAgKHsgaDogQ2gsIGw6IENsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgRWggfCAwLCBFbCB8IDApKTtcbiAgICAgICAgKHsgaDogRmgsIGw6IEZsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgSGggfCAwLCBIbCB8IDApKTtcbiAgICAgICAgdGhpcy5zZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEE1MTJfV19ILmZpbGwoMCk7XG4gICAgICAgIFNIQTUxMl9XX0wuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5TSEE1MTIgPSBTSEE1MTI7XG5jbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4MjIzMTIxOTQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmYzJiZjcyYyB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDlmNTU1ZmEzIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4Yzg0YzY0YzIgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgyMzkzYjg2YiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDZmNTNiMTUxIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4OTYzODc3MTkgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1OTQwZWFiZCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDk2MjgzZWUyIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YTg4ZWZmZTMgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHhiZTVlMWUyNSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDUzODYzOTkyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MmIwMTk5ZmMgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHgyYzg1YjhhYSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDBlYjcyZGRjIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4ODFjNTJjYTIgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDMyO1xuICAgIH1cbn1cbmNsYXNzIFNIQTM4NCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweGNiYmI5ZDVkIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4YzEwNTllZDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg2MjlhMjkyYSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDM2N2NkNTA3IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4OTE1OTAxNWEgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMDcwZGQxNyB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDE1MmZlY2Q4IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4ZjcwZTU5MzkgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg2NzMzMjY2NyB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGZmYzAwYjMxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OGViNDRhODcgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg2ODU4MTUxMSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweGRiMGMyZTBkIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NjRmOThmYTcgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg0N2I1NDgxZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweGJlZmE0ZmE0IHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSA0ODtcbiAgICB9XG59XG5leHBvcnRzLnNoYTUxMiA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTUxMigpKTtcbmV4cG9ydHMuc2hhNTEyXzI1NiA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG5leHBvcnRzLnNoYTM4NCA9ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IFNIQTM4NCgpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGV4cG9ydHMuY2hlY2tPcHRzID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9CeXRlcyA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLmFzeW5jTG9vcCA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmlzTEUgPSBleHBvcnRzLnJvdHIgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTggPSB2b2lkIDA7XG4vLyBUaGUgaW1wb3J0IGhlcmUgaXMgdmlhIHRoZSBwYWNrYWdlIG5hbWUuIFRoaXMgaXMgdG8gZW5zdXJlXG4vLyB0aGF0IGV4cG9ydHMgbWFwcGluZy9yZXNvbHV0aW9uIGRvZXMgZmFsbCBpbnRvIHBsYWNlLlxuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9jcnlwdG9cIik7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5jb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLnU4ID0gdTg7XG5jb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG5leHBvcnRzLnUzMiA9IHUzMjtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy5jcmVhdGVWaWV3ID0gY3JlYXRlVmlldztcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5leHBvcnRzLnJvdHIgPSByb3RyO1xuZXhwb3J0cy5pc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbi8vIFRoZXJlIGlzIGFsbW9zdCBubyBiaWcgZW5kaWFuIGhhcmR3YXJlLCBidXQganMgdHlwZWQgYXJyYXlzIHVzZXMgcGxhdGZvcm0gc3BlY2lmaWMgZW5kaWFubmVzcy5cbi8vIFNvLCBqdXN0IHRvIGJlIHN1cmUgbm90IHRvIGNvcnJ1cHQgYW55dGhpbmcuXG5pZiAoIWV4cG9ydHMuaXNMRSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbiBsaXR0bGUtZW5kaWFuIGhhcmR3YXJlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4ZGUsIDB4YWQsIDB4YmUsIDB4ZWZdKSlcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBpZiAoISh1aW50OGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnZGVhZGJlZWYnKVxuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoaGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LiBIb3dldmVyLCBjYWxsIHRvIGFzeW5jIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIFByb21pc2Vcbi8vIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb24gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5hc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgKDAsIGV4cG9ydHMubmV4dFRpY2spKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG5mdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0eXBlIGlzIFVpbnQ4QXJyYXkgKGdvdCAke3R5cGVvZiBkYXRhfSlgKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG4vKipcbiAqIENvbmNhdHMgVWludDhBcnJheS1zIGludG8gb25lOyBsaWtlIGBCdWZmZXIuY29uY2F0KFtidWYxLCBidWYyXSlgXG4gKiBAZXhhbXBsZSBjb25jYXRCeXRlcyhidWYxLCBidWYyKVxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBpZiAoIWFycmF5cy5ldmVyeSgoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgbGlzdCBleHBlY3RlZCcpO1xuICAgIGlmIChhcnJheXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gYXJyYXlzWzBdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGEsIGFycikgPT4gYSArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gYXJyYXlzW2ldO1xuICAgICAgICByZXN1bHQuc2V0KGFyciwgcGFkKTtcbiAgICAgICAgcGFkICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5mdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgIWlzUGxhaW5PYmplY3Qob3B0cykpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydHMuY2hlY2tPcHRzID0gY2hlY2tPcHRzO1xuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGhhc2hDID0gKG1lc3NhZ2UpID0+IGhhc2hDb25zdHJ1Y3RvcigpLnVwZGF0ZSh0b0J5dGVzKG1lc3NhZ2UpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gd3JhcENvbnN0cnVjdG9yO1xuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHM7XG4vKipcbiAqIFNlY3VyZSBQUk5HXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvXzEuY3J5cHRvLndlYikge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLndlYi5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3J5cHRvXzEuY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGNyeXB0b18xLmNyeXB0by5ub2RlLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKS5idWZmZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSByYW5kb21CeXRlcyBmdW5jdGlvblwiKTtcbiAgICB9XG59XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qISBub2JsZS1zZWNwMjU2azEgLSBNSVQgTGljZW5zZSAoYykgMjAxOSBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXRpbHMgPSBleHBvcnRzLnNjaG5vcnIgPSBleHBvcnRzLnZlcmlmeSA9IGV4cG9ydHMuc2lnblN5bmMgPSBleHBvcnRzLnNpZ24gPSBleHBvcnRzLmdldFNoYXJlZFNlY3JldCA9IGV4cG9ydHMucmVjb3ZlclB1YmxpY0tleSA9IGV4cG9ydHMuZ2V0UHVibGljS2V5ID0gZXhwb3J0cy5TaWduYXR1cmUgPSBleHBvcnRzLlBvaW50ID0gZXhwb3J0cy5DVVJWRSA9IHZvaWQgMDtcbmNvbnN0IG5vZGVDcnlwdG8gPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgXzNuID0gQmlnSW50KDMpO1xuY29uc3QgXzhuID0gQmlnSW50KDgpO1xuY29uc3QgUE9XXzJfMjU2ID0gXzJuICoqIEJpZ0ludCgyNTYpO1xuY29uc3QgQ1VSVkUgPSB7XG4gICAgYTogXzBuLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBQOiBQT1dfMl8yNTYgLSBfMm4gKiogQmlnSW50KDMyKSAtIEJpZ0ludCg5NzcpLFxuICAgIG46IFBPV18yXzI1NiAtIEJpZ0ludCgnNDMyNDIwMzg2NTY1NjU5NjU2ODUyNDIwODY2Mzk0OTY4MTQ1NTk5JyksXG4gICAgaDogXzFuLFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxufTtcbmV4cG9ydHMuQ1VSVkUgPSBDVVJWRTtcbmZ1bmN0aW9uIHdlaXN0cmFzcyh4KSB7XG4gICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICBjb25zdCB4MiA9IG1vZCh4ICogeCk7XG4gICAgY29uc3QgeDMgPSBtb2QoeDIgKiB4KTtcbiAgICByZXR1cm4gbW9kKHgzICsgYSAqIHggKyBiKTtcbn1cbmNvbnN0IFVTRV9FTkRPTU9SUEhJU00gPSBDVVJWRS5hID09PSBfMG47XG5jbGFzcyBKYWNvYmlhblBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB6KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMueiA9IHo7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIFBvaW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSmFjb2JpYW5Qb2ludCNmcm9tQWZmaW5lOiBleHBlY3RlZCBQb2ludCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChwLngsIHAueSwgXzFuKTtcbiAgICB9XG4gICAgc3RhdGljIHRvQWZmaW5lQmF0Y2gocG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IHRvSW52ID0gaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC56KSk7XG4gICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSk7XG4gICAgfVxuICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC50b0FmZmluZUJhdGNoKHBvaW50cykubWFwKEphY29iaWFuUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIEphY29iaWFuUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSmFjb2JpYW5Qb2ludCBleHBlY3RlZCcpO1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgeDogWDIsIHk6IFkyLCB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgIGNvbnN0IFoxWjEgPSBtb2QoWjEgKiogXzJuKTtcbiAgICAgICAgY29uc3QgWjJaMiA9IG1vZChaMiAqKiBfMm4pO1xuICAgICAgICBjb25zdCBVMSA9IG1vZChYMSAqIFoyWjIpO1xuICAgICAgICBjb25zdCBVMiA9IG1vZChYMiAqIFoxWjEpO1xuICAgICAgICBjb25zdCBTMSA9IG1vZChtb2QoWTEgKiBaMikgKiBaMloyKTtcbiAgICAgICAgY29uc3QgUzIgPSBtb2QobW9kKFkyICogWjEpICogWjFaMSk7XG4gICAgICAgIHJldHVybiBVMSA9PT0gVTIgJiYgUzEgPT09IFMyO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludCh0aGlzLngsIG1vZCgtdGhpcy55KSwgdGhpcy56KTtcbiAgICB9XG4gICAgZG91YmxlKCkge1xuICAgICAgICBjb25zdCB7IHg6IFgxLCB5OiBZMSwgejogWjEgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IEEgPSBtb2QoWDEgKiogXzJuKTtcbiAgICAgICAgY29uc3QgQiA9IG1vZChZMSAqKiBfMm4pO1xuICAgICAgICBjb25zdCBDID0gbW9kKEIgKiogXzJuKTtcbiAgICAgICAgY29uc3QgRCA9IG1vZChfMm4gKiAobW9kKChYMSArIEIpICoqIF8ybikgLSBBIC0gQykpO1xuICAgICAgICBjb25zdCBFID0gbW9kKF8zbiAqIEEpO1xuICAgICAgICBjb25zdCBGID0gbW9kKEUgKiogXzJuKTtcbiAgICAgICAgY29uc3QgWDMgPSBtb2QoRiAtIF8ybiAqIEQpO1xuICAgICAgICBjb25zdCBZMyA9IG1vZChFICogKEQgLSBYMykgLSBfOG4gKiBDKTtcbiAgICAgICAgY29uc3QgWjMgPSBtb2QoXzJuICogWTEgKiBaMSk7XG4gICAgICAgIHJldHVybiBuZXcgSmFjb2JpYW5Qb2ludChYMywgWTMsIFozKTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgSmFjb2JpYW5Qb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKYWNvYmlhblBvaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGNvbnN0IHsgeDogWDEsIHk6IFkxLCB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB4OiBYMiwgeTogWTIsIHo6IFoyIH0gPSBvdGhlcjtcbiAgICAgICAgaWYgKFgyID09PSBfMG4gfHwgWTIgPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoWDEgPT09IF8wbiB8fCBZMSA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICBjb25zdCBaMVoxID0gbW9kKFoxICoqIF8ybik7XG4gICAgICAgIGNvbnN0IFoyWjIgPSBtb2QoWjIgKiogXzJuKTtcbiAgICAgICAgY29uc3QgVTEgPSBtb2QoWDEgKiBaMloyKTtcbiAgICAgICAgY29uc3QgVTIgPSBtb2QoWDIgKiBaMVoxKTtcbiAgICAgICAgY29uc3QgUzEgPSBtb2QobW9kKFkxICogWjIpICogWjJaMik7XG4gICAgICAgIGNvbnN0IFMyID0gbW9kKG1vZChZMiAqIFoxKSAqIFoxWjEpO1xuICAgICAgICBjb25zdCBIID0gbW9kKFUyIC0gVTEpO1xuICAgICAgICBjb25zdCByID0gbW9kKFMyIC0gUzEpO1xuICAgICAgICBpZiAoSCA9PT0gXzBuKSB7XG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG91YmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5aRVJPO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEhIID0gbW9kKEggKiogXzJuKTtcbiAgICAgICAgY29uc3QgSEhIID0gbW9kKEggKiBISCk7XG4gICAgICAgIGNvbnN0IFYgPSBtb2QoVTEgKiBISCk7XG4gICAgICAgIGNvbnN0IFgzID0gbW9kKHIgKiogXzJuIC0gSEhIIC0gXzJuICogVik7XG4gICAgICAgIGNvbnN0IFkzID0gbW9kKHIgKiAoViAtIFgzKSAtIFMxICogSEhIKTtcbiAgICAgICAgY29uc3QgWjMgPSBtb2QoWjEgKiBaMiAqIEgpO1xuICAgICAgICByZXR1cm4gbmV3IEphY29iaWFuUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgfVxuICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICBjb25zdCBQMCA9IEphY29iaWFuUG9pbnQuWkVSTztcbiAgICAgICAgaWYgKHR5cGVvZiBzY2FsYXIgPT09ICdiaWdpbnQnICYmIHNjYWxhciA9PT0gXzBuKVxuICAgICAgICAgICAgcmV0dXJuIFAwO1xuICAgICAgICBsZXQgbiA9IG5vcm1hbGl6ZVNjYWxhcihzY2FsYXIpO1xuICAgICAgICBpZiAobiA9PT0gXzFuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICghVVNFX0VORE9NT1JQSElTTSkge1xuICAgICAgICAgICAgbGV0IHAgPSBQMDtcbiAgICAgICAgICAgIGxldCBkID0gdGhpcztcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gc3BsaXRTY2FsYXJFbmRvKG4pO1xuICAgICAgICBsZXQgazFwID0gUDA7XG4gICAgICAgIGxldCBrMnAgPSBQMDtcbiAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgIGlmIChrMSAmIF8xbilcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5hZGQoZCk7XG4gICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICBrMiA+Pj0gXzFuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICBrMnAgPSBuZXcgSmFjb2JpYW5Qb2ludChtb2QoazJwLnggKiBDVVJWRS5iZXRhKSwgazJwLnksIGsycC56KTtcbiAgICAgICAgcmV0dXJuIGsxcC5hZGQoazJwKTtcbiAgICB9XG4gICAgcHJlY29tcHV0ZVdpbmRvdyhXKSB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBVU0VfRU5ET01PUlBISVNNID8gMTI4IC8gVyArIDEgOiAyNTYgLyBXICsgMTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgYmFzZSA9IHA7XG4gICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMiAqKiAoVyAtIDEpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgIH1cbiAgICB3TkFGKG4sIGFmZmluZVBvaW50KSB7XG4gICAgICAgIGlmICghYWZmaW5lUG9pbnQgJiYgdGhpcy5lcXVhbHMoSmFjb2JpYW5Qb2ludC5CQVNFKSlcbiAgICAgICAgICAgIGFmZmluZVBvaW50ID0gUG9pbnQuQkFTRTtcbiAgICAgICAgY29uc3QgVyA9IChhZmZpbmVQb2ludCAmJiBhZmZpbmVQb2ludC5fV0lORE9XX1NJWkUpIHx8IDE7XG4gICAgICAgIGlmICgyNTYgJSBXKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50I3dOQUY6IEludmFsaWQgcHJlY29tcHV0YXRpb24gd2luZG93LCBtdXN0IGJlIHBvd2VyIG9mIDInKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJlY29tcHV0ZXMgPSBhZmZpbmVQb2ludCAmJiBwb2ludFByZWNvbXB1dGVzLmdldChhZmZpbmVQb2ludCk7XG4gICAgICAgIGlmICghcHJlY29tcHV0ZXMpIHtcbiAgICAgICAgICAgIHByZWNvbXB1dGVzID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFcpO1xuICAgICAgICAgICAgaWYgKGFmZmluZVBvaW50ICYmIFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBwcmVjb21wdXRlcyA9IEphY29iaWFuUG9pbnQubm9ybWFsaXplWihwcmVjb21wdXRlcyk7XG4gICAgICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQoYWZmaW5lUG9pbnQsIHByZWNvbXB1dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcCA9IEphY29iaWFuUG9pbnQuWkVSTztcbiAgICAgICAgbGV0IGYgPSBKYWNvYmlhblBvaW50LlpFUk87XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSAxICsgKFVTRV9FTkRPTU9SUEhJU00gPyAxMjggLyBXIDogMjU2IC8gVyk7XG4gICAgICAgIGNvbnN0IHdpbmRvd1NpemUgPSAyICoqIChXIC0gMSk7XG4gICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7XG4gICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgIGlmICh3Yml0cyA+IHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcHIgPSBwcmVjb21wdXRlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cgJSAyKVxuICAgICAgICAgICAgICAgICAgICBwciA9IHByLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICAgIGYgPSBmLmFkZChwcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY2FjaGVkID0gcHJlY29tcHV0ZXNbb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzIDwgMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gY2FjaGVkLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChjYWNoZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyLCBhZmZpbmVQb2ludCkge1xuICAgICAgICBsZXQgbiA9IG5vcm1hbGl6ZVNjYWxhcihzY2FsYXIpO1xuICAgICAgICBsZXQgcG9pbnQ7XG4gICAgICAgIGxldCBmYWtlO1xuICAgICAgICBpZiAoVVNFX0VORE9NT1JQSElTTSkge1xuICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gc3BsaXRTY2FsYXJFbmRvKG4pO1xuICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSwgYWZmaW5lUG9pbnQpO1xuICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMiwgYWZmaW5lUG9pbnQpO1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMnAgPSBrMnAubmVnYXRlKCk7XG4gICAgICAgICAgICBrMnAgPSBuZXcgSmFjb2JpYW5Qb2ludChtb2QoazJwLnggKiBDVVJWRS5iZXRhKSwgazJwLnksIGsycC56KTtcbiAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgZmFrZSA9IGYxcC5hZGQoZjJwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKG4sIGFmZmluZVBvaW50KTtcbiAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgfVxuICAgIHRvQWZmaW5lKGludlogPSBpbnZlcnQodGhpcy56KSkge1xuICAgICAgICBjb25zdCB7IHgsIHksIHogfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGl6MSA9IGludlo7XG4gICAgICAgIGNvbnN0IGl6MiA9IG1vZChpejEgKiBpejEpO1xuICAgICAgICBjb25zdCBpejMgPSBtb2QoaXoyICogaXoxKTtcbiAgICAgICAgY29uc3QgYXggPSBtb2QoeCAqIGl6Mik7XG4gICAgICAgIGNvbnN0IGF5ID0gbW9kKHkgKiBpejMpO1xuICAgICAgICBjb25zdCB6eiA9IG1vZCh6ICogaXoxKTtcbiAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChheCwgYXkpO1xuICAgIH1cbn1cbkphY29iaWFuUG9pbnQuQkFTRSA9IG5ldyBKYWNvYmlhblBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuKTtcbkphY29iaWFuUG9pbnQuWkVSTyA9IG5ldyBKYWNvYmlhblBvaW50KF8wbiwgXzFuLCBfMG4pO1xuY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5jbGFzcyBQb2ludCB7XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5kZWxldGUodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQ29tcHJlc3NlZEhleChieXRlcykge1xuICAgICAgICBjb25zdCBpc1Nob3J0ID0gYnl0ZXMubGVuZ3RoID09PSAzMjtcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXIoaXNTaG9ydCA/IGJ5dGVzIDogYnl0ZXMuc3ViYXJyYXkoMSkpO1xuICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICBjb25zdCB5MiA9IHdlaXN0cmFzcyh4KTtcbiAgICAgICAgbGV0IHkgPSBzcXJ0TW9kKHkyKTtcbiAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgIGlmIChpc1Nob3J0KSB7XG4gICAgICAgICAgICBpZiAoaXNZT2RkKVxuICAgICAgICAgICAgICAgIHkgPSBtb2QoLXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXNGaXJzdEJ5dGVPZGQgPSAoYnl0ZXNbMF0gJiAxKSA9PT0gMTtcbiAgICAgICAgICAgIGlmIChpc0ZpcnN0Qnl0ZU9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgIHkgPSBtb2QoLXkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tVW5jb21wcmVzc2VkSGV4KGJ5dGVzKSB7XG4gICAgICAgIGNvbnN0IHggPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KDEsIDMzKSk7XG4gICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KDMzLCA2NSkpO1xuICAgICAgICBjb25zdCBwb2ludCA9IG5ldyBQb2ludCh4LCB5KTtcbiAgICAgICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBlbnN1cmVCeXRlcyhoZXgpO1xuICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGJ5dGVzWzBdO1xuICAgICAgICBpZiAobGVuID09PSAzMiB8fCAobGVuID09PSAzMyAmJiAoaGVhZGVyID09PSAweDAyIHx8IGhlYWRlciA9PT0gMHgwMykpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQ29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbiA9PT0gNjUgJiYgaGVhZGVyID09PSAweDA0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbVVuY29tcHJlc3NlZEhleChieXRlcyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQuZnJvbUhleDogcmVjZWl2ZWQgaW52YWxpZCBwb2ludC4gRXhwZWN0ZWQgMzItMzMgY29tcHJlc3NlZCBieXRlcyBvciA2NSB1bmNvbXByZXNzZWQgYnl0ZXMsIG5vdCAke2xlbn1gKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU2lnbmF0dXJlKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpIHtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBoID0gdHJ1bmNhdGVIYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBpZiAocmVjb3ZlcnkgIT09IDAgJiYgcmVjb3ZlcnkgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlY292ZXIgc2lnbmF0dXJlOiBpbnZhbGlkIHJlY292ZXJ5IGJpdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHJlY292ZXJ5ICYgMSA/ICcwMycgOiAnMDInO1xuICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1UbzMyYlN0cihyKSk7XG4gICAgICAgIGNvbnN0IHsgbiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHJpbnYgPSBpbnZlcnQociwgbik7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKC1oICogcmludiwgbik7XG4gICAgICAgIGNvbnN0IHUyID0gbW9kKHMgKiByaW52LCBuKTtcbiAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTtcbiAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVjb3ZlciBzaWduYXR1cmU6IHBvaW50IGF0IGluZmluaWZ5Jyk7XG4gICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgcmV0dXJuIFE7XG4gICAgfVxuICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGhleFRvQnl0ZXModGhpcy50b0hleChpc0NvbXByZXNzZWQpKTtcbiAgICB9XG4gICAgdG9IZXgoaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeCA9IG51bVRvMzJiU3RyKHRoaXMueCk7XG4gICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMueSAmIF8xbiA/ICcwMycgOiAnMDInO1xuICAgICAgICAgICAgcmV0dXJuIGAke3ByZWZpeH0ke3h9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgMDQke3h9JHtudW1UbzMyYlN0cih0aGlzLnkpfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9IZXhYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCh0cnVlKS5zbGljZSgyKTtcbiAgICB9XG4gICAgdG9SYXdYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgbXNnID0gJ1BvaW50IGlzIG5vdCBvbiBlbGxpcHRpYyBjdXJ2ZSc7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpIHx8ICFpc1ZhbGlkRmllbGRFbGVtZW50KHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBtb2QoeSAqIHkpO1xuICAgICAgICBjb25zdCByaWdodCA9IHdlaXN0cmFzcyh4KTtcbiAgICAgICAgaWYgKG1vZChsZWZ0IC0gcmlnaHQpICE9PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55O1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCBtb2QoLXRoaXMueSkpO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUodGhpcykuZG91YmxlKCkudG9BZmZpbmUoKTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBKYWNvYmlhblBvaW50LmZyb21BZmZpbmUodGhpcykuYWRkKEphY29iaWFuUG9pbnQuZnJvbUFmZmluZShvdGhlcikpLnRvQWZmaW5lKCk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICByZXR1cm4gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpLm11bHRpcGx5KHNjYWxhciwgdGhpcykudG9BZmZpbmUoKTtcbiAgICB9XG4gICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICBjb25zdCBQID0gSmFjb2JpYW5Qb2ludC5mcm9tQWZmaW5lKHRoaXMpO1xuICAgICAgICBjb25zdCBhUCA9IGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgdGhpcyAhPT0gUG9pbnQuQkFTRSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpO1xuICAgICAgICBjb25zdCBiUSA9IEphY29iaWFuUG9pbnQuZnJvbUFmZmluZShRKS5tdWx0aXBseVVuc2FmZShiKTtcbiAgICAgICAgY29uc3Qgc3VtID0gYVAuYWRkKGJRKTtcbiAgICAgICAgcmV0dXJuIHN1bS5lcXVhbHMoSmFjb2JpYW5Qb2ludC5aRVJPKSA/IHVuZGVmaW5lZCA6IHN1bS50b0FmZmluZSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcblBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5KTtcblBvaW50LlpFUk8gPSBuZXcgUG9pbnQoXzBuLCBfMG4pO1xuZnVuY3Rpb24gc2xpY2VERVIocykge1xuICAgIHJldHVybiBOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpID49IDggPyAnMDAnICsgcyA6IHM7XG59XG5mdW5jdGlvbiBwYXJzZURFUkludChkYXRhKSB7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDwgMiB8fCBkYXRhWzBdICE9PSAweDAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlciB0YWc6ICR7Ynl0ZXNUb0hleChkYXRhKX1gKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gZGF0YVsxXTtcbiAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgIGlmICghbGVuIHx8IHJlcy5sZW5ndGggIT09IGxlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHdyb25nIGxlbmd0aGApO1xuICAgIH1cbiAgICBpZiAocmVzWzBdID09PSAweDAwICYmIHJlc1sxXSA8PSAweDdmKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdHJhaWxpbmcgbGVuZ3RoJyk7XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGE6IGJ5dGVzVG9OdW1iZXIocmVzKSwgbGVmdDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9O1xufVxuZnVuY3Rpb24gcGFyc2VERVJTaWduYXR1cmUoZGF0YSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPSAweDMwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzaWduYXR1cmUgdGFnOiAke2J5dGVzVG9IZXgoZGF0YSl9YCk7XG4gICAgfVxuICAgIGlmIChkYXRhWzFdICE9PSBkYXRhLmxlbmd0aCAtIDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZTogaW5jb3JyZWN0IGxlbmd0aCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGRhdGE6IHIsIGxlZnQ6IHNCeXRlcyB9ID0gcGFyc2VERVJJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgY29uc3QgeyBkYXRhOiBzLCBsZWZ0OiByQnl0ZXNMZWZ0IH0gPSBwYXJzZURFUkludChzQnl0ZXMpO1xuICAgIGlmIChyQnl0ZXNMZWZ0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmc6ICR7Ynl0ZXNUb0hleChyQnl0ZXNMZWZ0KX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgciwgcyB9O1xufVxuY2xhc3MgU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihyLCBzKSB7XG4gICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICBjb25zdCBhcnIgPSBpc1VpbnQ4YShoZXgpO1xuICAgICAgICBjb25zdCBuYW1lID0gJ1NpZ25hdHVyZS5mcm9tQ29tcGFjdCc7XG4gICAgICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJyAmJiAhYXJyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtuYW1lfTogRXhwZWN0ZWQgc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICAgICAgY29uc3Qgc3RyID0gYXJyID8gYnl0ZXNUb0hleChoZXgpIDogaGV4O1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCAhPT0gMTI4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9OiBFeHBlY3RlZCA2NC1ieXRlIGhleGApO1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShoZXhUb051bWJlcihzdHIuc2xpY2UoMCwgNjQpKSwgaGV4VG9OdW1iZXIoc3RyLnNsaWNlKDY0LCAxMjgpKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICBjb25zdCBhcnIgPSBpc1VpbnQ4YShoZXgpO1xuICAgICAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycgJiYgIWFycilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFNpZ25hdHVyZS5mcm9tREVSOiBFeHBlY3RlZCBzdHJpbmcgb3IgVWludDhBcnJheWApO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHBhcnNlREVSU2lnbmF0dXJlKGFyciA/IGhleCA6IGhleFRvQnl0ZXMoaGV4KSk7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbURFUihoZXgpO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihyKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBTaWduYXR1cmU6IHIgbXVzdCBiZSAwIDwgciA8IG4nKTtcbiAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIocykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgU2lnbmF0dXJlOiBzIG11c3QgYmUgMCA8IHMgPCBuJyk7XG4gICAgfVxuICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICBjb25zdCBIQUxGID0gQ1VSVkUubiA+PiBfMW47XG4gICAgICAgIHJldHVybiB0aGlzLnMgPiBIQUxGO1xuICAgIH1cbiAgICBub3JtYWxpemVTKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIENVUlZFLm4gLSB0aGlzLnMpIDogdGhpcztcbiAgICB9XG4gICAgdG9ERVJSYXdCeXRlcyhpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KGlzQ29tcHJlc3NlZCkpO1xuICAgIH1cbiAgICB0b0RFUkhleChpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzSGV4ID0gc2xpY2VERVIobnVtYmVyVG9IZXhVbnBhZGRlZCh0aGlzLnMpKTtcbiAgICAgICAgaWYgKGlzQ29tcHJlc3NlZClcbiAgICAgICAgICAgIHJldHVybiBzSGV4O1xuICAgICAgICBjb25zdCBySGV4ID0gc2xpY2VERVIobnVtYmVyVG9IZXhVbnBhZGRlZCh0aGlzLnIpKTtcbiAgICAgICAgY29uc3QgckxlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQockhleC5sZW5ndGggLyAyKTtcbiAgICAgICAgY29uc3Qgc0xlbiA9IG51bWJlclRvSGV4VW5wYWRkZWQoc0hleC5sZW5ndGggLyAyKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gbnVtYmVyVG9IZXhVbnBhZGRlZChySGV4Lmxlbmd0aCAvIDIgKyBzSGV4Lmxlbmd0aCAvIDIgKyA0KTtcbiAgICAgICAgcmV0dXJuIGAzMCR7bGVuZ3RofTAyJHtyTGVufSR7ckhleH0wMiR7c0xlbn0ke3NIZXh9YDtcbiAgICB9XG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9ERVJSYXdCeXRlcygpO1xuICAgIH1cbiAgICB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9ERVJIZXgoKTtcbiAgICB9XG4gICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgIH1cbiAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgIHJldHVybiBudW1UbzMyYlN0cih0aGlzLnIpICsgbnVtVG8zMmJTdHIodGhpcy5zKTtcbiAgICB9XG59XG5leHBvcnRzLlNpZ25hdHVyZSA9IFNpZ25hdHVyZTtcbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmICghYXJyYXlzLmV2ZXJ5KGlzVWludDhhKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGxpc3QgZXhwZWN0ZWQnKTtcbiAgICBpZiAoYXJyYXlzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGFycmF5c1swXTtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheXMucmVkdWNlKChhLCBhcnIpID0+IGEgKyBhcnIubGVuZ3RoLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhcnIubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNVaW50OGEoYnl0ZXMpIHtcbiAgICByZXR1cm4gYnl0ZXMgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xufVxuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICBpZiAoISh1aW50OGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1t1aW50OGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZnVuY3Rpb24gbnVtVG8zMmJTdHIobnVtKSB7XG4gICAgaWYgKG51bSA+IFBPV18yXzI1NilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBudW1iZXIgPCAyXjI1NicpO1xuICAgIHJldHVybiBudW0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCAnMCcpO1xufVxuZnVuY3Rpb24gbnVtVG8zMmIobnVtKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtVG8zMmJTdHIobnVtKSk7XG59XG5mdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvTnVtYmVyOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoYDB4JHtoZXh9YCk7XG59XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdoZXhUb0J5dGVzOiBleHBlY3RlZCBzdHJpbmcsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXhUb0J5dGVzOiByZWNlaXZlZCBpbnZhbGlkIHVucGFkZGVkIGhleCcgKyBoZXgubGVuZ3RoKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIGVuc3VyZUJ5dGVzKGhleCkge1xuICAgIHJldHVybiBoZXggaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gVWludDhBcnJheS5mcm9tKGhleCkgOiBoZXhUb0J5dGVzKGhleCk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVTY2FsYXIobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgJiYgbnVtID4gMClcbiAgICAgICAgcmV0dXJuIEJpZ0ludChudW0pO1xuICAgIGlmICh0eXBlb2YgbnVtID09PSAnYmlnaW50JyAmJiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSlcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB2YWxpZCBwcml2YXRlIHNjYWxhcjogMCA8IHNjYWxhciA8IGN1cnZlLm4nKTtcbn1cbmZ1bmN0aW9uIG1vZChhLCBiID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIpIHtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBQO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gc3FydE1vZCh4KSB7XG4gICAgY29uc3QgeyBQIH0gPSBDVVJWRTtcbiAgICBjb25zdCBfNm4gPSBCaWdJbnQoNik7XG4gICAgY29uc3QgXzExbiA9IEJpZ0ludCgxMSk7XG4gICAgY29uc3QgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyk7XG4gICAgY29uc3QgXzQ0biA9IEJpZ0ludCg0NCk7XG4gICAgY29uc3QgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeCAqIHggKiB4KSAlIFA7XG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHgpICUgUDtcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24pICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybikgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4pICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4bikgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0bikgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82bikgKiBiMikgJSBQO1xuICAgIHJldHVybiBwb3cyKHQyLCBfMm4pO1xufVxuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvID0gQ1VSVkUuUCkge1xuICAgIGlmIChudW1iZXIgPT09IF8wbiB8fCBtb2R1bG8gPD0gXzBuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBpbnRlZ2VycywgZ290IG49JHtudW1iZXJ9IG1vZD0ke21vZHVsb31gKTtcbiAgICB9XG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgY29uc3QgcSA9IGIgLyBhO1xuICAgICAgICBjb25zdCByID0gYiAlIGE7XG4gICAgICAgIGNvbnN0IG0gPSB4IC0gdSAqIHE7XG4gICAgICAgIGNvbnN0IG4gPSB5IC0gdiAqIHE7XG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG5mdW5jdGlvbiBpbnZlcnRCYXRjaChudW1zLCBwID0gQ1VSVkUuUCkge1xuICAgIGNvbnN0IHNjcmF0Y2ggPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIGNvbnN0IGxhc3RNdWx0aXBsaWVkID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChudW0gPT09IF8wbilcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHNjcmF0Y2hbaV0gPSBhY2M7XG4gICAgICAgIHJldHVybiBtb2QoYWNjICogbnVtLCBwKTtcbiAgICB9LCBfMW4pO1xuICAgIGNvbnN0IGludmVydGVkID0gaW52ZXJ0KGxhc3RNdWx0aXBsaWVkLCBwKTtcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAobnVtID09PSBfMG4pXG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICBzY3JhdGNoW2ldID0gbW9kKGFjYyAqIHNjcmF0Y2hbaV0sIHApO1xuICAgICAgICByZXR1cm4gbW9kKGFjYyAqIG51bSwgcCk7XG4gICAgfSwgaW52ZXJ0ZWQpO1xuICAgIHJldHVybiBzY3JhdGNoO1xufVxuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbmNvbnN0IFBPV18yXzEyOCA9IF8ybiAqKiBCaWdJbnQoMTI4KTtcbmZ1bmN0aW9uIHNwbGl0U2NhbGFyRW5kbyhrKSB7XG4gICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICBjb25zdCBhMSA9IEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpO1xuICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgIGNvbnN0IGIyID0gYTE7XG4gICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICBpZiAoazFuZWcpXG4gICAgICAgIGsxID0gbiAtIGsxO1xuICAgIGlmIChrMm5lZylcbiAgICAgICAgazIgPSBuIC0gazI7XG4gICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXJFbmRvOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbn1cbmZ1bmN0aW9uIHRydW5jYXRlSGFzaChoYXNoKSB7XG4gICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICBjb25zdCBieXRlTGVuZ3RoID0gaGFzaC5sZW5ndGg7XG4gICAgY29uc3QgZGVsdGEgPSBieXRlTGVuZ3RoICogOCAtIDI1NjtcbiAgICBsZXQgaCA9IGJ5dGVzVG9OdW1iZXIoaGFzaCk7XG4gICAgaWYgKGRlbHRhID4gMClcbiAgICAgICAgaCA9IGggPj4gQmlnSW50KGRlbHRhKTtcbiAgICBpZiAoaCA+PSBuKVxuICAgICAgICBoIC09IG47XG4gICAgcmV0dXJuIGg7XG59XG5jbGFzcyBIbWFjRHJiZyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudiA9IG5ldyBVaW50OEFycmF5KDMyKS5maWxsKDEpO1xuICAgICAgICB0aGlzLmsgPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgwKTtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICB9XG4gICAgaG1hYyguLi52YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMudXRpbHMuaG1hY1NoYTI1Nih0aGlzLmssIC4uLnZhbHVlcyk7XG4gICAgfVxuICAgIGhtYWNTeW5jKC4uLnZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIGV4cG9ydHMudXRpbHMuaG1hY1NoYTI1NlN5bmMgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V0aWxzLmhtYWNTaGEyNTZTeW5jIGlzIHVuZGVmaW5lZCwgeW91IG5lZWQgdG8gc2V0IGl0Jyk7XG4gICAgICAgIGNvbnN0IHJlcyA9IGV4cG9ydHMudXRpbHMuaG1hY1NoYTI1NlN5bmModGhpcy5rLCAuLi52YWx1ZXMpO1xuICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG8gdXNlIHN5bmMgc2lnbigpLCBlbnN1cmUgdXRpbHMuaG1hY1NoYTI1NiBpcyBzeW5jJyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGluY3IoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ZXIgPj0gMTAwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCAxLDAwMCBrIHZhbHVlcyBmb3Igc2lnbigpLCBhbGwgd2VyZSBpbnZhbGlkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb3VudGVyICs9IDE7XG4gICAgfVxuICAgIGFzeW5jIHJlc2VlZChzZWVkID0gbmV3IFVpbnQ4QXJyYXkoKSkge1xuICAgICAgICB0aGlzLmsgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52LCBVaW50OEFycmF5LmZyb20oWzB4MDBdKSwgc2VlZCk7XG4gICAgICAgIHRoaXMudiA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYpO1xuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuayA9IGF3YWl0IHRoaXMuaG1hYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMV0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gYXdhaXQgdGhpcy5obWFjKHRoaXMudik7XG4gICAgfVxuICAgIHJlc2VlZFN5bmMoc2VlZCA9IG5ldyBVaW50OEFycmF5KCkpIHtcbiAgICAgICAgdGhpcy5rID0gdGhpcy5obWFjU3luYyh0aGlzLnYsIFVpbnQ4QXJyYXkuZnJvbShbMHgwMF0pLCBzZWVkKTtcbiAgICAgICAgdGhpcy52ID0gdGhpcy5obWFjU3luYyh0aGlzLnYpO1xuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuayA9IHRoaXMuaG1hY1N5bmModGhpcy52LCBVaW50OEFycmF5LmZyb20oWzB4MDFdKSwgc2VlZCk7XG4gICAgICAgIHRoaXMudiA9IHRoaXMuaG1hY1N5bmModGhpcy52KTtcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGUoKSB7XG4gICAgICAgIHRoaXMuaW5jcigpO1xuICAgICAgICB0aGlzLnYgPSBhd2FpdCB0aGlzLmhtYWModGhpcy52KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudjtcbiAgICB9XG4gICAgZ2VuZXJhdGVTeW5jKCkge1xuICAgICAgICB0aGlzLmluY3IoKTtcbiAgICAgICAgdGhpcy52ID0gdGhpcy5obWFjU3luYyh0aGlzLnYpO1xuICAgICAgICByZXR1cm4gdGhpcy52O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG59XG5mdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgIHJldHVybiBfMG4gPCBudW0gJiYgbnVtIDwgQ1VSVkUuUDtcbn1cbmZ1bmN0aW9uIGttZFRvU2lnKGtCeXRlcywgbSwgZCkge1xuICAgIGNvbnN0IGsgPSBieXRlc1RvTnVtYmVyKGtCeXRlcyk7XG4gICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG4gfSA9IENVUlZFO1xuICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspO1xuICAgIGNvbnN0IHIgPSBtb2QocS54LCBuKTtcbiAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IG1vZChpbnZlcnQoaywgbikgKiBtb2QobSArIGQgKiByLCBuKSwgbik7XG4gICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHNpZyA9IG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgY29uc3QgcmVjb3ZlcnkgPSAocS54ID09PSBzaWcuciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pO1xuICAgIHJldHVybiB7IHNpZywgcmVjb3ZlcnkgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByaXZhdGVLZXkoa2V5KSB7XG4gICAgbGV0IG51bTtcbiAgICBpZiAodHlwZW9mIGtleSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgbnVtID0ga2V5O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcihrZXkpICYmIGtleSA+IDApIHtcbiAgICAgICAgbnVtID0gQmlnSW50KGtleSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChrZXkubGVuZ3RoICE9PSA2NClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgMzIgYnl0ZXMgb2YgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgbnVtID0gaGV4VG9OdW1iZXIoa2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNVaW50OGEoa2V5KSkge1xuICAgICAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIDMyIGJ5dGVzIG9mIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIG51bSA9IGJ5dGVzVG9OdW1iZXIoa2V5KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHZhbGlkIHByaXZhdGUga2V5Jyk7XG4gICAgfVxuICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcHJpdmF0ZSBrZXk6IDAgPCBrZXkgPCBuJyk7XG4gICAgcmV0dXJuIG51bTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNLZXkpIHtcbiAgICBpZiAocHVibGljS2V5IGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgICAgcHVibGljS2V5LmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBpZiAoc2lnbmF0dXJlIGluc3RhbmNlb2YgU2lnbmF0dXJlKSB7XG4gICAgICAgIHNpZ25hdHVyZS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gU2lnbmF0dXJlLmZyb21ERVIoc2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2lnbmF0dXJlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgaXNDb21wcmVzc2VkID0gZmFsc2UpIHtcbiAgICByZXR1cm4gUG9pbnQuZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0cy5nZXRQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXk7XG5mdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIGlzQ29tcHJlc3NlZCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIFBvaW50LmZyb21TaWduYXR1cmUobXNnSGFzaCwgc2lnbmF0dXJlLCByZWNvdmVyeSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xufVxuZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleTtcbmZ1bmN0aW9uIGlzUHViKGl0ZW0pIHtcbiAgICBjb25zdCBhcnIgPSBpc1VpbnQ4YShpdGVtKTtcbiAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgIGlmIChhcnIpXG4gICAgICAgIHJldHVybiBsZW4gPT09IDMzIHx8IGxlbiA9PT0gNjU7XG4gICAgaWYgKHN0cilcbiAgICAgICAgcmV0dXJuIGxlbiA9PT0gNjYgfHwgbGVuID09PSAxMzA7XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSBmYWxzZSkge1xuICAgIGlmIChpc1B1Yihwcml2YXRlQSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldFNoYXJlZFNlY3JldDogZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICBpZiAoIWlzUHViKHB1YmxpY0IpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnZXRTaGFyZWRTZWNyZXQ6IHNlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgY29uc3QgYiA9IG5vcm1hbGl6ZVB1YmxpY0tleShwdWJsaWNCKTtcbiAgICBiLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbn1cbmV4cG9ydHMuZ2V0U2hhcmVkU2VjcmV0ID0gZ2V0U2hhcmVkU2VjcmV0O1xuZnVuY3Rpb24gYml0czJpbnQoYnl0ZXMpIHtcbiAgICBjb25zdCBzbGljZSA9IGJ5dGVzLmxlbmd0aCA+IDMyID8gYnl0ZXMuc2xpY2UoMCwgMzIpIDogYnl0ZXM7XG4gICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXIoc2xpY2UpO1xufVxuZnVuY3Rpb24gYml0czJvY3RldHMoYnl0ZXMpIHtcbiAgICBjb25zdCB6MSA9IGJpdHMyaW50KGJ5dGVzKTtcbiAgICBjb25zdCB6MiA9IG1vZCh6MSwgQ1VSVkUubik7XG4gICAgcmV0dXJuIGludDJvY3RldHMoejIgPCBfMG4gPyB6MSA6IHoyKTtcbn1cbmZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGJpZ2ludCcpO1xuICAgIGNvbnN0IGhleCA9IG51bVRvMzJiU3RyKG51bSk7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4KTtcbn1cbmZ1bmN0aW9uIGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZhdGVLZXksIGV4dHJhRW50cm9weSkge1xuICAgIGlmIChtc2dIYXNoID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbjogZXhwZWN0ZWQgdmFsaWQgbWVzc2FnZSBoYXNoLCBub3QgXCIke21zZ0hhc2h9XCJgKTtcbiAgICBjb25zdCBoMSA9IGVuc3VyZUJ5dGVzKG1zZ0hhc2gpO1xuICAgIGNvbnN0IGQgPSBub3JtYWxpemVQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGJpdHMyb2N0ZXRzKGgxKV07XG4gICAgaWYgKGV4dHJhRW50cm9weSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChleHRyYUVudHJvcHkgPT09IHRydWUpXG4gICAgICAgICAgICBleHRyYUVudHJvcHkgPSBleHBvcnRzLnV0aWxzLnJhbmRvbUJ5dGVzKDMyKTtcbiAgICAgICAgY29uc3QgZSA9IGVuc3VyZUJ5dGVzKGV4dHJhRW50cm9weSk7XG4gICAgICAgIGlmIChlLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IEV4cGVjdGVkIDMyIGJ5dGVzIG9mIGV4dHJhIGRhdGEnKTtcbiAgICAgICAgc2VlZEFyZ3MucHVzaChlKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlZCA9IGNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTtcbiAgICBjb25zdCBtID0gYml0czJpbnQoaDEpO1xuICAgIHJldHVybiB7IHNlZWQsIG0sIGQgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplU2lnKHJlY1NpZywgb3B0cykge1xuICAgIGxldCB7IHNpZywgcmVjb3ZlcnkgfSA9IHJlY1NpZztcbiAgICBjb25zdCB7IGNhbm9uaWNhbCwgZGVyLCByZWNvdmVyZWQgfSA9IE9iamVjdC5hc3NpZ24oeyBjYW5vbmljYWw6IHRydWUsIGRlcjogdHJ1ZSB9LCBvcHRzKTtcbiAgICBpZiAoY2Fub25pY2FsICYmIHNpZy5oYXNIaWdoUygpKSB7XG4gICAgICAgIHNpZyA9IHNpZy5ub3JtYWxpemVTKCk7XG4gICAgICAgIHJlY292ZXJ5IF49IDE7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGRlciA/IHNpZy50b0RFUlJhd0J5dGVzKCkgOiBzaWcudG9Db21wYWN0UmF3Qnl0ZXMoKTtcbiAgICByZXR1cm4gcmVjb3ZlcmVkID8gW2hhc2hlZCwgcmVjb3ZlcnldIDogaGFzaGVkO1xufVxuYXN5bmMgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHNlZWQsIG0sIGQgfSA9IGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMuZXh0cmFFbnRyb3B5KTtcbiAgICBsZXQgc2lnO1xuICAgIGNvbnN0IGRyYmcgPSBuZXcgSG1hY0RyYmcoKTtcbiAgICBhd2FpdCBkcmJnLnJlc2VlZChzZWVkKTtcbiAgICB3aGlsZSAoIShzaWcgPSBrbWRUb1NpZyhhd2FpdCBkcmJnLmdlbmVyYXRlKCksIG0sIGQpKSlcbiAgICAgICAgYXdhaXQgZHJiZy5yZXNlZWQoKTtcbiAgICByZXR1cm4gZmluYWxpemVTaWcoc2lnLCBvcHRzKTtcbn1cbmV4cG9ydHMuc2lnbiA9IHNpZ247XG5mdW5jdGlvbiBzaWduU3luYyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IHNlZWQsIG0sIGQgfSA9IGluaXRTaWdBcmdzKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMuZXh0cmFFbnRyb3B5KTtcbiAgICBsZXQgc2lnO1xuICAgIGNvbnN0IGRyYmcgPSBuZXcgSG1hY0RyYmcoKTtcbiAgICBkcmJnLnJlc2VlZFN5bmMoc2VlZCk7XG4gICAgd2hpbGUgKCEoc2lnID0ga21kVG9TaWcoZHJiZy5nZW5lcmF0ZVN5bmMoKSwgbSwgZCkpKVxuICAgICAgICBkcmJnLnJlc2VlZFN5bmMoKTtcbiAgICByZXR1cm4gZmluYWxpemVTaWcoc2lnLCBvcHRzKTtcbn1cbmV4cG9ydHMuc2lnblN5bmMgPSBzaWduU3luYztcbmNvbnN0IHZvcHRzID0geyBzdHJpY3Q6IHRydWUgfTtcbmZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IHZvcHRzKSB7XG4gICAgbGV0IHNpZztcbiAgICB0cnkge1xuICAgICAgICBzaWcgPSBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKG1zZ0hhc2gpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IHIsIHMgfSA9IHNpZztcbiAgICBpZiAob3B0cy5zdHJpY3QgJiYgc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBoID0gdHJ1bmNhdGVIYXNoKG1zZ0hhc2gpO1xuICAgIGxldCBQO1xuICAgIHRyeSB7XG4gICAgICAgIFAgPSBub3JtYWxpemVQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgeyBuIH0gPSBDVVJWRTtcbiAgICBjb25zdCBzaW52ID0gaW52ZXJ0KHMsIG4pO1xuICAgIGNvbnN0IHUxID0gbW9kKGggKiBzaW52LCBuKTtcbiAgICBjb25zdCB1MiA9IG1vZChyICogc2ludiwgbik7XG4gICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKTtcbiAgICBpZiAoIVIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB2ID0gbW9kKFIueCwgbik7XG4gICAgcmV0dXJuIHYgPT09IHI7XG59XG5leHBvcnRzLnZlcmlmeSA9IHZlcmlmeTtcbmZ1bmN0aW9uIGZpbmFsaXplU2Nobm9yckNoYWxsZW5nZShjaCkge1xuICAgIHJldHVybiBtb2QoYnl0ZXNUb051bWJlcihjaCksIENVUlZFLm4pO1xufVxuZnVuY3Rpb24gaGFzRXZlblkocG9pbnQpIHtcbiAgICByZXR1cm4gKHBvaW50LnkgJiBfMW4pID09PSBfMG47XG59XG5jbGFzcyBTY2hub3JyU2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihyLCBzKSB7XG4gICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMoaGV4KTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gNjQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBTY2hub3JyU2lnbmF0dXJlLmZyb21IZXg6IGV4cGVjdGVkIDY0IGJ5dGVzLCBub3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgIGNvbnN0IHIgPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyKGJ5dGVzLnN1YmFycmF5KDMyLCA2NCkpO1xuICAgICAgICByZXR1cm4gbmV3IFNjaG5vcnJTaWduYXR1cmUociwgcyk7XG4gICAgfVxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXNWYWxpZEZpZWxkRWxlbWVudChyKSB8fCAhaXNXaXRoaW5DdXJ2ZU9yZGVyKHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZScpO1xuICAgIH1cbiAgICB0b0hleCgpIHtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiU3RyKHRoaXMucikgKyBudW1UbzMyYlN0cih0aGlzLnMpO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyh0aGlzLnRvSGV4KCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd1goKTtcbn1cbmZ1bmN0aW9uIGluaXRTY2hub3JyU2lnQXJncyhtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc2lnbjogRXhwZWN0ZWQgdmFsaWQgbWVzc2FnZSwgbm90IFwiJHttZXNzYWdlfVwiYCk7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKG1lc3NhZ2UpO1xuICAgIGNvbnN0IGQwID0gbm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICBjb25zdCByYW5kID0gZW5zdXJlQnl0ZXMoYXV4UmFuZCk7XG4gICAgaWYgKHJhbmQubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2lnbjogRXhwZWN0ZWQgMzIgYnl0ZXMgb2YgYXV4IHJhbmRvbW5lc3MnKTtcbiAgICBjb25zdCBQID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZDApO1xuICAgIGNvbnN0IHB4ID0gUC50b1Jhd1goKTtcbiAgICBjb25zdCBkID0gaGFzRXZlblkoUCkgPyBkMCA6IENVUlZFLm4gLSBkMDtcbiAgICByZXR1cm4geyBtLCBQLCBweCwgZCwgcmFuZCB9O1xufVxuZnVuY3Rpb24gaW5pdFNjaG5vcnJOb25jZShkLCB0MGgpIHtcbiAgICByZXR1cm4gbnVtVG8zMmIoZCBeIGJ5dGVzVG9OdW1iZXIodDBoKSk7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVNjaG5vcnJOb25jZShrMGgpIHtcbiAgICBjb25zdCBrMCA9IG1vZChieXRlc1RvTnVtYmVyKGswaCksIENVUlZFLm4pO1xuICAgIGlmIChrMCA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IENyZWF0aW9uIG9mIHNpZ25hdHVyZSBmYWlsZWQuIGsgaXMgemVybycpO1xuICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShrMCk7XG4gICAgY29uc3QgcnggPSBSLnRvUmF3WCgpO1xuICAgIGNvbnN0IGsgPSBoYXNFdmVuWShSKSA/IGswIDogQ1VSVkUubiAtIGswO1xuICAgIHJldHVybiB7IFIsIHJ4LCBrIH07XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVNjaG5vcnJTaWcoUiwgaywgZSwgZCkge1xuICAgIHJldHVybiBuZXcgU2Nobm9yclNpZ25hdHVyZShSLngsIG1vZChrICsgZSAqIGQsIENVUlZFLm4pKS50b1Jhd0J5dGVzKCk7XG59XG5hc3luYyBmdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gZXhwb3J0cy51dGlscy5yYW5kb21CeXRlcygpKSB7XG4gICAgY29uc3QgeyBtLCBweCwgZCwgcmFuZCB9ID0gaW5pdFNjaG5vcnJTaWdBcmdzKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQpO1xuICAgIGNvbnN0IHQgPSBpbml0U2Nobm9yck5vbmNlKGQsIGF3YWl0IGV4cG9ydHMudXRpbHMudGFnZ2VkSGFzaChUQUdTLmF1eCwgcmFuZCkpO1xuICAgIGNvbnN0IHsgUiwgcngsIGsgfSA9IGZpbmFsaXplU2Nobm9yck5vbmNlKGF3YWl0IGV4cG9ydHMudXRpbHMudGFnZ2VkSGFzaChUQUdTLm5vbmNlLCB0LCBweCwgbSkpO1xuICAgIGNvbnN0IGUgPSBmaW5hbGl6ZVNjaG5vcnJDaGFsbGVuZ2UoYXdhaXQgZXhwb3J0cy51dGlscy50YWdnZWRIYXNoKFRBR1MuY2hhbGxlbmdlLCByeCwgcHgsIG0pKTtcbiAgICBjb25zdCBzaWcgPSBmaW5hbGl6ZVNjaG5vcnJTaWcoUiwgaywgZSwgZCk7XG4gICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCk7XG4gICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ246IEludmFsaWQgc2lnbmF0dXJlIHByb2R1Y2VkJyk7XG4gICAgcmV0dXJuIHNpZztcbn1cbmZ1bmN0aW9uIHNjaG5vcnJTaWduU3luYyhtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gZXhwb3J0cy51dGlscy5yYW5kb21CeXRlcygpKSB7XG4gICAgY29uc3QgeyBtLCBweCwgZCwgcmFuZCB9ID0gaW5pdFNjaG5vcnJTaWdBcmdzKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQpO1xuICAgIGNvbnN0IHQgPSBpbml0U2Nobm9yck5vbmNlKGQsIGV4cG9ydHMudXRpbHMudGFnZ2VkSGFzaFN5bmMoVEFHUy5hdXgsIHJhbmQpKTtcbiAgICBjb25zdCB7IFIsIHJ4LCBrIH0gPSBmaW5hbGl6ZVNjaG5vcnJOb25jZShleHBvcnRzLnV0aWxzLnRhZ2dlZEhhc2hTeW5jKFRBR1Mubm9uY2UsIHQsIHB4LCBtKSk7XG4gICAgY29uc3QgZSA9IGZpbmFsaXplU2Nobm9yckNoYWxsZW5nZShleHBvcnRzLnV0aWxzLnRhZ2dlZEhhc2hTeW5jKFRBR1MuY2hhbGxlbmdlLCByeCwgcHgsIG0pKTtcbiAgICBjb25zdCBzaWcgPSBmaW5hbGl6ZVNjaG5vcnJTaWcoUiwgaywgZSwgZCk7XG4gICAgY29uc3QgaXNWYWxpZCA9IHNjaG5vcnJWZXJpZnlTeW5jKHNpZywgbSwgcHgpO1xuICAgIGlmICghaXNWYWxpZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG5mdW5jdGlvbiBpbml0U2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHJhdyA9IHNpZ25hdHVyZSBpbnN0YW5jZW9mIFNjaG5vcnJTaWduYXR1cmU7XG4gICAgY29uc3Qgc2lnID0gcmF3ID8gc2lnbmF0dXJlIDogU2Nobm9yclNpZ25hdHVyZS5mcm9tSGV4KHNpZ25hdHVyZSk7XG4gICAgaWYgKHJhdylcbiAgICAgICAgc2lnLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc2lnLFxuICAgICAgICBtOiBlbnN1cmVCeXRlcyhtZXNzYWdlKSxcbiAgICAgICAgUDogbm9ybWFsaXplUHVibGljS2V5KHB1YmxpY0tleSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplU2Nobm9yclZlcmlmeShyLCBQLCBzLCBlKSB7XG4gICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgbm9ybWFsaXplUHJpdmF0ZUtleShzKSwgbW9kKC1lLCBDVVJWRS5uKSk7XG4gICAgaWYgKCFSIHx8ICFoYXNFdmVuWShSKSB8fCBSLnggIT09IHIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHIsIHMsIG0sIFAgfSA9IGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZSA9IGZpbmFsaXplU2Nobm9yckNoYWxsZW5nZShhd2FpdCBleHBvcnRzLnV0aWxzLnRhZ2dlZEhhc2goVEFHUy5jaGFsbGVuZ2UsIG51bVRvMzJiKHIpLCBQLnRvUmF3WCgpLCBtKSk7XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZVNjaG5vcnJWZXJpZnkociwgUCwgcywgZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nobm9yclZlcmlmeVN5bmMoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHIsIHMsIG0sIFAgfSA9IGluaXRTY2hub3JyVmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgZSA9IGZpbmFsaXplU2Nobm9yckNoYWxsZW5nZShleHBvcnRzLnV0aWxzLnRhZ2dlZEhhc2hTeW5jKFRBR1MuY2hhbGxlbmdlLCBudW1UbzMyYihyKSwgUC50b1Jhd1goKSwgbSkpO1xuICAgICAgICByZXR1cm4gZmluYWxpemVTY2hub3JyVmVyaWZ5KHIsIFAsIHMsIGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuc2Nobm9yciA9IHtcbiAgICBTaWduYXR1cmU6IFNjaG5vcnJTaWduYXR1cmUsXG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICBzaWduU3luYzogc2Nobm9yclNpZ25TeW5jLFxuICAgIHZlcmlmeVN5bmM6IHNjaG5vcnJWZXJpZnlTeW5jLFxufTtcblBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG5jb25zdCBjcnlwdG8gPSB7XG4gICAgbm9kZTogbm9kZUNyeXB0byxcbiAgICB3ZWI6IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBzZWxmID8gc2VsZi5jcnlwdG8gOiB1bmRlZmluZWQsXG59O1xuY29uc3QgVEFHUyA9IHtcbiAgICBjaGFsbGVuZ2U6ICdCSVAwMzQwL2NoYWxsZW5nZScsXG4gICAgYXV4OiAnQklQMDM0MC9hdXgnLFxuICAgIG5vbmNlOiAnQklQMDM0MC9ub25jZScsXG59O1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmV4cG9ydHMudXRpbHMgPSB7XG4gICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbm9ybWFsaXplUHJpdmF0ZUtleShwcml2YXRlS2V5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcml2YXRlQWRkOiAocHJpdmF0ZUtleSwgdHdlYWspID0+IHtcbiAgICAgICAgY29uc3QgcCA9IG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG4gICAgICAgIGNvbnN0IHQgPSBub3JtYWxpemVQcml2YXRlS2V5KHR3ZWFrKTtcbiAgICAgICAgcmV0dXJuIG51bVRvMzJiKG1vZChwICsgdCwgQ1VSVkUubikpO1xuICAgIH0sXG4gICAgcHJpdmF0ZU5lZ2F0ZTogKHByaXZhdGVLZXkpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IG5vcm1hbGl6ZVByaXZhdGVLZXkocHJpdmF0ZUtleSk7XG4gICAgICAgIHJldHVybiBudW1UbzMyYihDVVJWRS5uIC0gcCk7XG4gICAgfSxcbiAgICBwb2ludEFkZFNjYWxhcjogKHAsIHR3ZWFrLCBpc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21IZXgocCk7XG4gICAgICAgIGNvbnN0IHQgPSBub3JtYWxpemVQcml2YXRlS2V5KHR3ZWFrKTtcbiAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdCwgXzFuKTtcbiAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUd2Vha2VkIHBvaW50IGF0IGluZmluaXR5Jyk7XG4gICAgICAgIHJldHVybiBRLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9LFxuICAgIHBvaW50TXVsdGlwbHk6IChwLCB0d2VhaywgaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tSGV4KHApO1xuICAgICAgICBjb25zdCB0ID0gYnl0ZXNUb051bWJlcihlbnN1cmVCeXRlcyh0d2VhaykpO1xuICAgICAgICByZXR1cm4gUC5tdWx0aXBseSh0KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfSxcbiAgICBoYXNoVG9Qcml2YXRlS2V5OiAoaGFzaCkgPT4ge1xuICAgICAgICBoYXNoID0gZW5zdXJlQnl0ZXMoaGFzaCk7XG4gICAgICAgIGlmIChoYXNoLmxlbmd0aCA8IDQwIHx8IGhhc2gubGVuZ3RoID4gMTAyNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgNDAtMTAyNCBieXRlcyBvZiBwcml2YXRlIGtleSBhcyBwZXIgRklQUyAxODYnKTtcbiAgICAgICAgY29uc3QgbnVtID0gbW9kKGJ5dGVzVG9OdW1iZXIoaGFzaCksIENVUlZFLm4gLSBfMW4pICsgXzFuO1xuICAgICAgICByZXR1cm4gbnVtVG8zMmIobnVtKTtcbiAgICB9LFxuICAgIHJhbmRvbUJ5dGVzOiAoYnl0ZXNMZW5ndGggPSAzMikgPT4ge1xuICAgICAgICBpZiAoY3J5cHRvLndlYikge1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by53ZWIuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmFuZG9tQnl0ZXMgfSA9IGNyeXB0by5ub2RlO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShyYW5kb21CeXRlcyhieXRlc0xlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSByYW5kb21CeXRlcyBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy51dGlscy5oYXNoVG9Qcml2YXRlS2V5KGV4cG9ydHMudXRpbHMucmFuZG9tQnl0ZXMoNDApKTtcbiAgICB9LFxuICAgIGJ5dGVzVG9IZXgsXG4gICAgaGV4VG9CeXRlcyxcbiAgICBjb25jYXRCeXRlcyxcbiAgICBtb2QsXG4gICAgaW52ZXJ0LFxuICAgIHNoYTI1NjogYXN5bmMgKC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCBjcnlwdG8ud2ViLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBjb25jYXRCeXRlcyguLi5tZXNzYWdlcykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gY3JlYXRlSGFzaCgnc2hhMjU2Jyk7XG4gICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKChtKSA9PiBoYXNoLnVwZGF0ZShtKSk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGhhc2guZGlnZXN0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGVudmlyb25tZW50IGRvZXNuJ3QgaGF2ZSBzaGEyNTYgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhtYWNTaGEyNTY6IGFzeW5jIChrZXksIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmIChjcnlwdG8ud2ViKSB7XG4gICAgICAgICAgICBjb25zdCBja2V5ID0gYXdhaXQgY3J5cHRvLndlYi5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBrZXksIHsgbmFtZTogJ0hNQUMnLCBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9IH0sIGZhbHNlLCBbJ3NpZ24nXSk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gY29uY2F0Qnl0ZXMoLi4ubWVzc2FnZXMpO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYXdhaXQgY3J5cHRvLndlYi5zdWJ0bGUuc2lnbignSE1BQycsIGNrZXksIG1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3J5cHRvLm5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY3JlYXRlSG1hYyB9ID0gY3J5cHRvLm5vZGU7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goKG0pID0+IGhhc2gudXBkYXRlKG0pKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oaGFzaC5kaWdlc3QoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIGhtYWMtc2hhMjU2IGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzaGEyNTZTeW5jOiB1bmRlZmluZWQsXG4gICAgaG1hY1NoYTI1NlN5bmM6IHVuZGVmaW5lZCxcbiAgICB0YWdnZWRIYXNoOiBhc3luYyAodGFnLCAuLi5tZXNzYWdlcykgPT4ge1xuICAgICAgICBsZXQgdGFnUCA9IFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ107XG4gICAgICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ0ggPSBhd2FpdCBleHBvcnRzLnV0aWxzLnNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51dGlscy5zaGEyNTYodGFnUCwgLi4ubWVzc2FnZXMpO1xuICAgIH0sXG4gICAgdGFnZ2VkSGFzaFN5bmM6ICh0YWcsIC4uLm1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwb3J0cy51dGlscy5zaGEyNTZTeW5jICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1dGlscy5zaGEyNTZTeW5jIGlzIHVuZGVmaW5lZCwgeW91IG5lZWQgdG8gc2V0IGl0Jyk7XG4gICAgICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICAgICAgaWYgKHRhZ1AgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdGFnSCA9IGV4cG9ydHMudXRpbHMuc2hhMjU2U3luYyhVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwb3J0cy51dGlscy5zaGEyNTZTeW5jKHRhZ1AsIC4uLm1lc3NhZ2VzKTtcbiAgICB9LFxuICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICBjb25zdCBjYWNoZWQgPSBwb2ludCA9PT0gUG9pbnQuQkFTRSA/IHBvaW50IDogbmV3IFBvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBjYWNoZWQuX3NldFdpbmRvd1NpemUod2luZG93U2l6ZSk7XG4gICAgICAgIGNhY2hlZC5tdWx0aXBseShfM24pO1xuICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH0sXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhES2V5ID0gZXhwb3J0cy5IQVJERU5FRF9PRkZTRVQgPSB2b2lkIDA7XG5jb25zdCBobWFjXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9obWFjXCIpO1xuY29uc3QgcmlwZW1kMTYwXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9yaXBlbWQxNjBcIik7XG5jb25zdCBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbmNvbnN0IHNoYTUxMl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhNTEyXCIpO1xuY29uc3QgX2Fzc2VydF8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvX2Fzc2VydFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IHNlY3AgPSByZXF1aXJlKFwiQG5vYmxlL3NlY3AyNTZrMVwiKTtcbmNvbnN0IGJhc2VfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmFzZVwiKTtcbnNlY3AudXRpbHMuaG1hY1NoYTI1NlN5bmMgPSAoa2V5LCAuLi5tZXNzYWdlcykgPT4ge1xuICAgIGNvbnN0IGggPSBobWFjXzEuaG1hYy5jcmVhdGUoc2hhMjU2XzEuc2hhMjU2LCBrZXkpO1xuICAgIG1lc3NhZ2VzLmZvckVhY2goKG1zZykgPT4gaC51cGRhdGUobXNnKSk7XG4gICAgcmV0dXJuIGguZGlnZXN0KCk7XG59O1xuY29uc3QgYmFzZTU4YyA9ICgwLCBiYXNlXzEuYmFzZTU4Y2hlY2spKHNoYTI1Nl8xLnNoYTI1Nik7XG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyKGJ5dGVzKSB7XG4gICAgcmV0dXJuIEJpZ0ludChgMHgkeygwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKGJ5dGVzKX1gKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXMobnVtKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKG51bS50b1N0cmluZygxNikucGFkU3RhcnQoNjQsICcwJykpO1xufVxuY29uc3QgTUFTVEVSX1NFQ1JFVCA9ICgwLCB1dGlsc18xLnV0ZjhUb0J5dGVzKSgnQml0Y29pbiBzZWVkJyk7XG5jb25zdCBCSVRDT0lOX1ZFUlNJT05TID0geyBwcml2YXRlOiAweDA0ODhhZGU0LCBwdWJsaWM6IDB4MDQ4OGIyMWUgfTtcbmV4cG9ydHMuSEFSREVORURfT0ZGU0VUID0gMHg4MDAwMDAwMDtcbmNvbnN0IGhhc2gxNjAgPSAoZGF0YSkgPT4gKDAsIHJpcGVtZDE2MF8xLnJpcGVtZDE2MCkoKDAsIHNoYTI1Nl8xLnNoYTI1NikoZGF0YSkpO1xuY29uc3QgZnJvbVUzMiA9IChkYXRhKSA9PiAoMCwgdXRpbHNfMS5jcmVhdGVWaWV3KShkYXRhKS5nZXRVaW50MzIoMCwgZmFsc2UpO1xuY29uc3QgdG9VMzIgPSAobikgPT4ge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDAgfHwgbiA+IDIgKiogMzIgLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBudW1iZXI9JHtufS4gU2hvdWxkIGJlIGZyb20gMCB0byAyICoqIDMyIC0gMWApO1xuICAgIH1cbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICAoMCwgdXRpbHNfMS5jcmVhdGVWaWV3KShidWYpLnNldFVpbnQzMigwLCBuLCBmYWxzZSk7XG4gICAgcmV0dXJuIGJ1Zjtcbn07XG5jbGFzcyBIREtleSB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jaGFpbkNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMDtcbiAgICAgICAgaWYgKCFvcHQgfHwgdHlwZW9mIG9wdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXkuY29uc3RydWN0b3IgbXVzdCBub3QgYmUgY2FsbGVkIGRpcmVjdGx5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52ZXJzaW9ucyA9IG9wdC52ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TO1xuICAgICAgICB0aGlzLmRlcHRoID0gb3B0LmRlcHRoIHx8IDA7XG4gICAgICAgIHRoaXMuY2hhaW5Db2RlID0gb3B0LmNoYWluQ29kZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IG9wdC5pbmRleCB8fCAwO1xuICAgICAgICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gb3B0LnBhcmVudEZpbmdlcnByaW50IHx8IDA7XG4gICAgICAgIGlmICghdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50RmluZ2VycHJpbnQgfHwgdGhpcy5pbmRleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSERLZXk6IHplcm8gZGVwdGggd2l0aCBub24temVybyBpbmRleC9wYXJlbnQgZmluZ2VycHJpbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnB1YmxpY0tleSAmJiBvcHQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIREtleTogcHVibGljS2V5IGFuZCBwcml2YXRlS2V5IGF0IHNhbWUgdGltZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0LnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIGlmICghc2VjcC51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShvcHQucHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJpdktleSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdC5wcml2YXRlS2V5ID09PSAnYmlnaW50JyA/IG9wdC5wcml2YXRlS2V5IDogYnl0ZXNUb051bWJlcihvcHQucHJpdmF0ZUtleSk7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcyA9IG51bWJlclRvQnl0ZXModGhpcy5wcml2S2V5KTtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gc2VjcC5nZXRQdWJsaWNLZXkob3B0LnByaXZhdGVLZXksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdC5wdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRoaXMucHViS2V5ID0gc2VjcC5Qb2ludC5mcm9tSGV4KG9wdC5wdWJsaWNLZXkpLnRvUmF3Qnl0ZXModHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hES2V5OiBubyBwdWJsaWMgb3IgcHJpdmF0ZSBrZXkgcHJvdmlkZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1Ykhhc2ggPSBoYXNoMTYwKHRoaXMucHViS2V5KTtcbiAgICB9XG4gICAgZ2V0IGZpbmdlcnByaW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucHViSGFzaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWNLZXkgc2V0IScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcm9tVTMyKHRoaXMucHViSGFzaCk7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJIYXNoO1xuICAgIH1cbiAgICBnZXQgcHViS2V5SGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHViSGFzaDtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaXZLZXlCeXRlcyB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdWJLZXkgfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVFeHRlbmRlZEtleSgpIHtcbiAgICAgICAgY29uc3QgcHJpdiA9IHRoaXMucHJpdmF0ZUtleTtcbiAgICAgICAgaWYgKCFwcml2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U1OGMuZW5jb2RlKHRoaXMuc2VyaWFsaXplKHRoaXMudmVyc2lvbnMucHJpdmF0ZSwgKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKG5ldyBVaW50OEFycmF5KFswXSksIHByaXYpKSk7XG4gICAgfVxuICAgIGdldCBwdWJsaWNFeHRlbmRlZEtleSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnB1YktleSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWMga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U1OGMuZW5jb2RlKHRoaXMuc2VyaWFsaXplKHRoaXMudmVyc2lvbnMucHVibGljLCB0aGlzLnB1YktleSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU1hc3RlclNlZWQoc2VlZCwgdmVyc2lvbnMgPSBCSVRDT0lOX1ZFUlNJT05TKSB7XG4gICAgICAgIGlmICg4ICogc2VlZC5sZW5ndGggPCAxMjggfHwgOCAqIHNlZWQubGVuZ3RoID4gNTEyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhES2V5OiB3cm9uZyBzZWVkIGxlbmd0aD0ke3NlZWQubGVuZ3RofS4gU2hvdWxkIGJlIGJldHdlZW4gMTI4IGFuZCA1MTIgYml0czsgMjU2IGJpdHMgaXMgYWR2aXNlZClgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBJID0gKDAsIGhtYWNfMS5obWFjKShzaGE1MTJfMS5zaGE1MTIsIE1BU1RFUl9TRUNSRVQsIHNlZWQpO1xuICAgICAgICByZXR1cm4gbmV3IEhES2V5KHtcbiAgICAgICAgICAgIHZlcnNpb25zLFxuICAgICAgICAgICAgY2hhaW5Db2RlOiBJLnNsaWNlKDMyKSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IEkuc2xpY2UoMCwgMzIpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEtleShiYXNlNThrZXksIHZlcnNpb25zID0gQklUQ09JTl9WRVJTSU9OUykge1xuICAgICAgICBjb25zdCBrZXlCdWZmZXIgPSBiYXNlNThjLmRlY29kZShiYXNlNThrZXkpO1xuICAgICAgICBjb25zdCBrZXlWaWV3ID0gKDAsIHV0aWxzXzEuY3JlYXRlVmlldykoa2V5QnVmZmVyKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGtleVZpZXcuZ2V0VWludDMyKDAsIGZhbHNlKTtcbiAgICAgICAgY29uc3Qgb3B0ID0ge1xuICAgICAgICAgICAgdmVyc2lvbnMsXG4gICAgICAgICAgICBkZXB0aDoga2V5QnVmZmVyWzRdLFxuICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQ6IGtleVZpZXcuZ2V0VWludDMyKDUsIGZhbHNlKSxcbiAgICAgICAgICAgIGluZGV4OiBrZXlWaWV3LmdldFVpbnQzMig5LCBmYWxzZSksXG4gICAgICAgICAgICBjaGFpbkNvZGU6IGtleUJ1ZmZlci5zbGljZSgxMywgNDUpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlCdWZmZXIuc2xpY2UoNDUpO1xuICAgICAgICBjb25zdCBpc1ByaXYgPSBrZXlbMF0gPT09IDA7XG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSB2ZXJzaW9uc1tpc1ByaXYgPyAncHJpdmF0ZScgOiAncHVibGljJ10pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVyc2lvbiBtaXNtYXRjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByaXYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSERLZXkoeyAuLi5vcHQsIHByaXZhdGVLZXk6IGtleS5zbGljZSgxKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSERLZXkoeyAuLi5vcHQsIHB1YmxpY0tleToga2V5IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBIREtleS5mcm9tRXh0ZW5kZWRLZXkoanNvbi54cHJpdik7XG4gICAgfVxuICAgIGRlcml2ZShwYXRoKSB7XG4gICAgICAgIGlmICghL15bbU1dJz8vLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGF0aCBtdXN0IHN0YXJ0IHdpdGggXCJtXCIgb3IgXCJNXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoL15bbU1dJz8kLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IHBhdGgucmVwbGFjZSgvXlttTV0nP1xcLy8sICcnKS5zcGxpdCgnLycpO1xuICAgICAgICBsZXQgY2hpbGQgPSB0aGlzO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAvXihcXGQrKSgnPykkLy5leGVjKGMpO1xuICAgICAgICAgICAgaWYgKCFtIHx8IG0ubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoaWxkIGluZGV4OiAke2N9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaWR4ID0gK21bMV07XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGlkeCkgfHwgaWR4ID49IGV4cG9ydHMuSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobVsyXSA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICBpZHggKz0gZXhwb3J0cy5IQVJERU5FRF9PRkZTRVQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmRlcml2ZUNoaWxkKGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICBkZXJpdmVDaGlsZChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMucHViS2V5IHx8ICF0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwdWJsaWNLZXkgb3IgY2hhaW5Db2RlIHNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gdG9VMzIoaW5kZXgpO1xuICAgICAgICBpZiAoaW5kZXggPj0gZXhwb3J0cy5IQVJERU5FRF9PRkZTRVQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByaXYgPSB0aGlzLnByaXZhdGVLZXk7XG4gICAgICAgICAgICBpZiAoIXByaXYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXJpdmUgaGFyZGVuZWQgY2hpbGQga2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKG5ldyBVaW50OEFycmF5KFswXSksIHByaXYsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGF0YSA9ICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKSh0aGlzLnB1YktleSwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgSSA9ICgwLCBobWFjXzEuaG1hYykoc2hhNTEyXzEuc2hhNTEyLCB0aGlzLmNoYWluQ29kZSwgZGF0YSk7XG4gICAgICAgIGNvbnN0IGNoaWxkVHdlYWsgPSBieXRlc1RvTnVtYmVyKEkuc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgY29uc3QgY2hhaW5Db2RlID0gSS5zbGljZSgzMik7XG4gICAgICAgIGlmICghc2VjcC51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShjaGlsZFR3ZWFrKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUd2VhayBiaWdnZXIgdGhhbiBjdXJ2ZSBvcmRlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdCA9IHtcbiAgICAgICAgICAgIHZlcnNpb25zOiB0aGlzLnZlcnNpb25zLFxuICAgICAgICAgICAgY2hhaW5Db2RlLFxuICAgICAgICAgICAgZGVwdGg6IHRoaXMuZGVwdGggKyAxLFxuICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQ6IHRoaXMuZmluZ2VycHJpbnQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRlZCA9IHNlY3AudXRpbHMubW9kKHRoaXMucHJpdktleSArIGNoaWxkVHdlYWssIHNlY3AuQ1VSVkUubik7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWNwLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KGFkZGVkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB0d2VhayB3YXMgb3V0IG9mIHJhbmdlIG9yIHRoZSByZXN1bHRlZCBwcml2YXRlIGtleSBpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdC5wcml2YXRlS2V5ID0gYWRkZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHQucHVibGljS2V5ID0gc2VjcC5Qb2ludC5mcm9tSGV4KHRoaXMucHViS2V5KVxuICAgICAgICAgICAgICAgICAgICAuYWRkKHNlY3AuUG9pbnQuZnJvbVByaXZhdGVLZXkoY2hpbGRUd2VhaykpXG4gICAgICAgICAgICAgICAgICAgIC50b1Jhd0J5dGVzKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIREtleShvcHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlcml2ZUNoaWxkKGluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2lnbihoYXNoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHByaXZhdGVLZXkgc2V0IScpO1xuICAgICAgICB9XG4gICAgICAgICgwLCBfYXNzZXJ0XzEuYnl0ZXMpKGhhc2gsIDMyKTtcbiAgICAgICAgcmV0dXJuIHNlY3Auc2lnblN5bmMoaGFzaCwgdGhpcy5wcml2S2V5LCB7XG4gICAgICAgICAgICBjYW5vbmljYWw6IHRydWUsXG4gICAgICAgICAgICBkZXI6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmVyaWZ5KGhhc2gsIHNpZ25hdHVyZSkge1xuICAgICAgICAoMCwgX2Fzc2VydF8xLmJ5dGVzKShoYXNoLCAzMik7XG4gICAgICAgICgwLCBfYXNzZXJ0XzEuYnl0ZXMpKHNpZ25hdHVyZSwgNjQpO1xuICAgICAgICBpZiAoIXRoaXMucHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHB1YmxpY0tleSBzZXQhJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNpZyA9IHNlY3AuU2lnbmF0dXJlLmZyb21Db21wYWN0KHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlY3AudmVyaWZ5KHNpZywgaGFzaCwgdGhpcy5wdWJsaWNLZXkpO1xuICAgIH1cbiAgICB3aXBlUHJpdmF0ZURhdGEoKSB7XG4gICAgICAgIHRoaXMucHJpdktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMucHJpdktleUJ5dGVzKSB7XG4gICAgICAgICAgICB0aGlzLnByaXZLZXlCeXRlcy5maWxsKDApO1xuICAgICAgICAgICAgdGhpcy5wcml2S2V5Qnl0ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHhwcml2OiB0aGlzLnByaXZhdGVFeHRlbmRlZEtleSxcbiAgICAgICAgICAgIHhwdWI6IHRoaXMucHVibGljRXh0ZW5kZWRLZXksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHNlcmlhbGl6ZSh2ZXJzaW9uLCBrZXkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYWluQ29kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjaGFpbkNvZGUgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIF9hc3NlcnRfMS5ieXRlcykoa2V5LCAzMyk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykodG9VMzIodmVyc2lvbiksIG5ldyBVaW50OEFycmF5KFt0aGlzLmRlcHRoXSksIHRvVTMyKHRoaXMucGFyZW50RmluZ2VycHJpbnQpLCB0b1UzMih0aGlzLmluZGV4KSwgdGhpcy5jaGFpbkNvZGUsIGtleSk7XG4gICAgfVxufVxuZXhwb3J0cy5IREtleSA9IEhES2V5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhES2V5ID0gZXhwb3J0cy5IQVJERU5FRF9PRkZTRVQgPSB2b2lkIDA7XG52YXIgYmlwMzJfMSA9IHJlcXVpcmUoXCJAc2N1cmUvYmlwMzJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJIQVJERU5FRF9PRkZTRVRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpcDMyXzEuSEFSREVORURfT0ZGU0VUOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSERLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpcDMyXzEuSERLZXk7IH0gfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrNTEyID0gZXhwb3J0cy5rZWNjYWszODQgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrMjI0ID0gdm9pZCAwO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMua2VjY2FrMjI0ID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjI0KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gKCgpID0+IHtcbiAgICBjb25zdCBrID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjU2KTtcbiAgICBrLmNyZWF0ZSA9IHNoYTNfMS5rZWNjYWtfMjU2LmNyZWF0ZTtcbiAgICByZXR1cm4gaztcbn0pKCk7XG5leHBvcnRzLmtlY2NhazM4NCA9ICgwLCB1dGlsc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzM4NCk7XG5leHBvcnRzLmtlY2NhazUxMiA9ICgwLCB1dGlsc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzUxMik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3V0cHV0ID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5udW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy5vdXRwdXQgPSBvdXRwdXQ7XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGQgPSBleHBvcnRzLnRvQmlnID0gZXhwb3J0cy5zcGxpdCA9IGV4cG9ydHMuZnJvbUJpZyA9IHZvaWQgMDtcbmNvbnN0IFUzMl9NQVNLNjQgPSBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZXhwb3J0cy5mcm9tQmlnID0gZnJvbUJpZztcbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuZXhwb3J0cy5zcGxpdCA9IHNwbGl0O1xuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbmV4cG9ydHMudG9CaWcgPSB0b0JpZztcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBsLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChoLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBsKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuLy8gUmVtb3ZpbmcgXCJleHBvcnRcIiBoYXMgNSUgcGVyZiBwZW5hbHR5IC1fLVxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuZXhwb3J0cy5hZGQgPSBhZGQ7XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWc6IGV4cG9ydHMudG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdTY0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbmV4cG9ydHMuY3J5cHRvID0ge1xuICAgIG5vZGU6IHVuZGVmaW5lZCxcbiAgICB3ZWI6IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBzZWxmID8gc2VsZi5jcnlwdG8gOiB1bmRlZmluZWQsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZXhwb3J0cy5zaGFrZTEyOCA9IGV4cG9ydHMua2VjY2FrXzUxMiA9IGV4cG9ydHMua2VjY2FrXzM4NCA9IGV4cG9ydHMua2VjY2FrXzI1NiA9IGV4cG9ydHMua2VjY2FrXzIyNCA9IGV4cG9ydHMuc2hhM181MTIgPSBleHBvcnRzLnNoYTNfMzg0ID0gZXhwb3J0cy5zaGEzXzI1NiA9IGV4cG9ydHMuc2hhM18yMjQgPSBleHBvcnRzLktlY2NhayA9IGV4cG9ydHMua2VjY2FrUCA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCBfdTY0X2pzXzEgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgW1NIQTNfUEksIFNIQTNfUk9UTCwgX1NIQTNfSU9UQV0gPSBbW10sIFtdLCBbXV07XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfN24gPSBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gX3U2NF9qc18xLmRlZmF1bHQuc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IF91NjRfanNfMS5kZWZhdWx0LnJvdGxCSChoLCBsLCBzKSA6IF91NjRfanNfMS5kZWZhdWx0LnJvdGxTSChoLCBsLCBzKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IF91NjRfanNfMS5kZWZhdWx0LnJvdGxCTChoLCBsLCBzKSA6IF91NjRfanNfMS5kZWZhdWx0LnJvdGxTTChoLCBsLCBzKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0cy5rZWNjYWtQID0ga2VjY2FrUDtcbmNsYXNzIEtlY2NhayBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5udW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5ieXRlcyhvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQubnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuS2VjY2FrID0gS2VjY2FrO1xuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0cy5zaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhM18yNTYgPSBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMuc2hhM18zODQgPSBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydHMuc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMjI0ID0gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMua2VjY2FrXzI1NiA9IGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLmtlY2Nha181MTIgPSBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3JXaXRoT3B0cykoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnRzLnNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5jaGVja09wdHMgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0J5dGVzID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuYXN5bmNMb29wID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMucm90ciA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbi8vIFRoZSBpbXBvcnQgaGVyZSBpcyB2aWEgdGhlIHBhY2thZ2UgbmFtZS4gVGhpcyBpcyB0byBlbnN1cmVcbi8vIHRoYXQgZXhwb3J0cyBtYXBwaW5nL3Jlc29sdXRpb24gZG9lcyBmYWxsIGludG8gcGxhY2UuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmV4cG9ydHMudTMyID0gdTMyO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydHMucm90ciA9IHJvdHI7XG5leHBvcnRzLmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuLy8gVGhlcmUgaXMgYWxtb3N0IG5vIGJpZyBlbmRpYW4gaGFyZHdhcmUsIGJ1dCBqcyB0eXBlZCBhcnJheXMgdXNlcyBwbGF0Zm9ybSBzcGVjaWZpYyBlbmRpYW5uZXNzLlxuLy8gU28sIGp1c3QgdG8gYmUgc3VyZSBub3QgdG8gY29ycnVwdCBhbnl0aGluZy5cbmlmICghZXhwb3J0cy5pc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhkZSwgMHhhZCwgMHhiZSwgMHhlZl0pKVxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KHVpbnQ4YSkge1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGlmICghKHVpbnQ4YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW3VpbnQ4YVtpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdkZWFkYmVlZicpXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvQnl0ZXM6IGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleFRvQnl0ZXM6IHJlY2VpdmVkIGludmFsaWQgdW5wYWRkZWQgaGV4Jyk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuIEhvd2V2ZXIsIGNhbGwgdG8gYXN5bmMgZnVuY3Rpb24gd2lsbCByZXR1cm4gUHJvbWlzZVxuLy8gd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvbiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGlucHV0IHR5cGUgaXMgVWludDhBcnJheSAoZ290ICR7dHlwZW9mIGRhdGF9KWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29uY2F0cyBVaW50OEFycmF5LXMgaW50byBvbmU7IGxpa2UgYEJ1ZmZlci5jb25jYXQoW2J1ZjEsIGJ1ZjJdKWBcbiAqIEBleGFtcGxlIGNvbmNhdEJ5dGVzKGJ1ZjEsIGJ1ZjIpXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmICghYXJyYXlzLmV2ZXJ5KChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBsaXN0IGV4cGVjdGVkJyk7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5jbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vLyBDaGVjayBpZiBvYmplY3QgZG9lbnMndCBoYXZlIGN1c3RvbSBjb25zdHJ1Y3RvciAobGlrZSBVaW50OEFycmF5L0FycmF5KVxuY29uc3QgaXNQbGFpbk9iamVjdCA9IChvYmopID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCAhaXNQbGFpbk9iamVjdChvcHRzKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobWVzc2FnZSkgPT4gaGFzaENvbnN0cnVjdG9yKCkudXBkYXRlKHRvQnl0ZXMobWVzc2FnZSkpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSB3cmFwQ29uc3RydWN0b3I7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cztcbi8qKlxuICogU2VjdXJlIFBSTkdcbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8ud2ViKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8ud2ViLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjcnlwdG9fMS5jcnlwdG8ubm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvXzEuY3J5cHRvLm5vZGUucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpLmJ1ZmZlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHJhbmRvbUJ5dGVzIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSBleHBvcnRzLndyYXBIYXNoID0gZXhwb3J0cy5lcXVhbHNCeXRlcyA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5jcmVhdGVWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9IZXggPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmFzc2VydEJ5dGVzID0gZXhwb3J0cy5hc3NlcnRCb29sID0gdm9pZCAwO1xuLy8gYnVmLnRvU3RyaW5nKCdoZXgnKSAtPiB0b0hleChidWYpXG5jb25zdCBfYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBub2JsZS9oYXNoZXMvX2Fzc2VydFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBhc3NlcnRCb29sID0gX2Fzc2VydF8xLmRlZmF1bHQuYm9vbDtcbmV4cG9ydHMuYXNzZXJ0Qm9vbCA9IGFzc2VydEJvb2w7XG5jb25zdCBhc3NlcnRCeXRlcyA9IF9hc3NlcnRfMS5kZWZhdWx0LmJ5dGVzO1xuZXhwb3J0cy5hc3NlcnRCeXRlcyA9IGFzc2VydEJ5dGVzO1xudmFyIHV0aWxzXzIgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ5dGVzVG9IZXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuYnl0ZXNUb0hleDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvSGV4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmJ5dGVzVG9IZXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRCeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5jb25jYXRCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVZpZXdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuY3JlYXRlVmlldzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV0ZjhUb0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLnV0ZjhUb0J5dGVzOyB9IH0pO1xuLy8gYnVmLnRvU3RyaW5nKCd1dGY4JykgLT4gYnl0ZXNUb1V0ZjgoYnVmKVxuZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoZGF0YSkge1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBieXRlc1RvVXRmOCBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBieXRlc1RvVXRmODtcbmZ1bmN0aW9uIGhleFRvQnl0ZXMoZGF0YSkge1xuICAgIGNvbnN0IHNsaWNlZCA9IGRhdGEuc3RhcnRzV2l0aChcIjB4XCIpID8gZGF0YS5zdWJzdHJpbmcoMikgOiBkYXRhO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShzbGljZWQpO1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIGJ1Zi5lcXVhbHMoYnVmMikgLT4gZXF1YWxzQnl0ZXMoYnVmLCBidWYyKVxuZnVuY3Rpb24gZXF1YWxzQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZXF1YWxzQnl0ZXMgPSBlcXVhbHNCeXRlcztcbi8vIEludGVybmFsIHV0aWxzXG5mdW5jdGlvbiB3cmFwSGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIChtc2cpID0+IHtcbiAgICAgICAgX2Fzc2VydF8xLmRlZmF1bHQuYnl0ZXMobXNnKTtcbiAgICAgICAgcmV0dXJuIGhhc2gobXNnKTtcbiAgICB9O1xufVxuZXhwb3J0cy53cmFwSGFzaCA9IHdyYXBIYXNoO1xuZXhwb3J0cy5jcnlwdG8gPSAoKCkgPT4ge1xuICAgIGNvbnN0IHdlYkNyeXB0byA9IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiICYmIFwiY3J5cHRvXCIgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vZGVSZXF1aXJlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2YgbW9kdWxlLnJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBtb2R1bGUucmVxdWlyZS5iaW5kKG1vZHVsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogbm9kZVJlcXVpcmUgJiYgIXdlYkNyeXB0byA/IG5vZGVSZXF1aXJlKFwiY3J5cHRvXCIpIDogdW5kZWZpbmVkLFxuICAgICAgICB3ZWI6IHdlYkNyeXB0b1xuICAgIH07XG59KSgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUluZnVyYU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3Qgbm9kZV9mZXRjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlLWZldGNoXCIpKTtcbmNvbnN0IGZldGNoX2NvbmZpZ19mcm9tX3JlcV8xID0gcmVxdWlyZShcIi4vZmV0Y2gtY29uZmlnLWZyb20tcmVxXCIpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGxvZyA9ICgwLCBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKShsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ2NyZWF0ZS1pbmZ1cmEtbWlkZGxld2FyZScpO1xuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgICAvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuICAgICdHYXRld2F5IHRpbWVvdXQnLFxuICAgICdFVElNRURPVVQnLFxuICAgICdFQ09OTlJFU0VUJyxcbiAgICAvLyBpZ25vcmUgc2VydmVyIHNlbnQgaHRtbCBlcnJvciBwYWdlc1xuICAgIC8vIG9yIHRydW5jYXRlZCBqc29uIHJlc3BvbnNlc1xuICAgICdTeW50YXhFcnJvcicsXG5dO1xuLyoqXG4gKiBCdWlsZHMgW2Bqc29uLXJwYy1lbmdpbmVgXShodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svanNvbi1ycGMtZW5naW5lKS1jb21wYXRpYmxlIG1pZGRsZXdhcmUgZGVzaWduZWRcbiAqIGZvciBpbnRlcmZhY2luZyB3aXRoIEluZnVyYSdzIEpTT04tUlBDIGVuZHBvaW50cy5cbiAqXG4gKiBAcGFyYW0gb3B0cyAtIFRoZSBvcHRpb25zLlxuICogQHBhcmFtIG9wdHMubmV0d29yayAtIEEgbmV0d29yayB0aGF0IEluZnVyYSBzdXBwb3J0czsgcGx1Z3MgaW50b1xuICogYGh0dHBzOi8vJHtuZXR3b3JrfS5pbmZ1cmEuaW9gIChkZWZhdWx0OiAnbWFpbm5ldCcpLlxuICogQHBhcmFtIG9wdHMubWF4QXR0ZW1wdHMgLSBUaGUgbnVtYmVyIG9mIHRpbWVzIGEgcmVxdWVzdCB0byBJbmZ1cmEgc2hvdWxkIGJlXG4gKiByZXRyaWVkIGluIHRoZSBjYXNlIG9mIGZhaWx1cmUgKGRlZmF1bHQ6IDUpLlxuICogQHBhcmFtIG9wdHMuc291cmNlIC0gQSBkZXNjcmlwdG9yIGZvciB0aGUgZW50aXR5IG1ha2luZyB0aGUgcmVxdWVzdDsgdHJhY2tlZFxuICogYnkgSW5mdXJhIGZvciBhbmFseXRpY3MgcHVycG9zZXMuXG4gKiBAcGFyYW0gb3B0cy5wcm9qZWN0SWQgLSBUaGUgSW5mdXJhIHByb2plY3QgaWQuXG4gKiBAcGFyYW0gb3B0cy5oZWFkZXJzIC0gRXh0cmEgaGVhZGVycyB0aGF0IHdpbGwgYmUgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICogQHJldHVybnMgVGhlIGBqc29uLXJwYy1lbmdpbmVgLWNvbXBhdGlibGUgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5mdXJhTWlkZGxld2FyZSh7IG5ldHdvcmsgPSAnbWFpbm5ldCcsIG1heEF0dGVtcHRzID0gNSwgc291cmNlLCBwcm9qZWN0SWQsIGhlYWRlcnMgPSB7fSwgfSkge1xuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgICBpZiAoIXByb2plY3RJZCB8fCB0eXBlb2YgcHJvamVjdElkICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yICdwcm9qZWN0SWQnOiBcIiR7cHJvamVjdElkfVwiYCk7XG4gICAgfVxuICAgIGlmICghaGVhZGVycyB8fCB0eXBlb2YgaGVhZGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciAnaGVhZGVycyc6IFwiJHtoZWFkZXJzfVwiYCk7XG4gICAgfVxuICAgIGlmICghbWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciAnbWF4QXR0ZW1wdHMnOiBcIiR7bWF4QXR0ZW1wdHN9XCIgKCR7dHlwZW9mIG1heEF0dGVtcHRzfSlgKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICAgICAgICAvLyByZXRyeSBNQVhfQVRURU1QVFMgdGltZXMsIGlmIGVycm9yIG1hdGNoZXMgZmlsdGVyXG4gICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgbG9nKCdBdHRlbXB0aW5nIHJlcXVlc3QgdG8gSW5mdXJhLiBuZXR3b3JrID0gJW8sIHByb2plY3RJZCA9ICVzLCBoZWFkZXJzID0gJW8sIHJlcSA9ICVvJywgbmV0d29yaywgcHJvamVjdElkLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHBlcmZvcm1GZXRjaChuZXR3b3JrLCBwcm9qZWN0SWQsIGhlYWRlcnMsIHJlcSwgcmVzLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBhbiBlcnJvciB3YXMgY2F1Z2h0IHdoaWxlIHBlcmZvcm1pbmcgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgcmV0cmlhYmxlLCByZXNvbHZlIHdpdGggdGhlIGVuY291bnRlcmVkIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKCFpc1JldHJpYWJsZUVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWJvcnQgd2l0aCBlcnJvclxuICAgICAgICAgICAgICAgICAgICBsb2coJ05vbi1yZXRyaWFibGUgcmVxdWVzdCBlcnJvciBlbmNvdW50ZXJlZC4gcmVxID0gJW8sIHJlcyA9ICVvLCBlcnJvciA9ICVvJywgcmVxLCByZXMsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gbW9yZSBhdHRlbXB0cyByZW1haW5pbmcsIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nQXR0ZW1wdHMgPSBtYXhBdHRlbXB0cyAtIGF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW1haW5pbmdBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICBsb2coJ1JldHJpYWJsZSByZXF1ZXN0IGVycm9yIGVuY291bnRlcmVkLCBidXQgZXhjZWVkZWQgbWF4IGF0dGVtcHRzLiByZXEgPSAlbywgcmVzID0gJW8sIGVycm9yID0gJW8nLCByZXEsIHJlcywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gYEluZnVyYVByb3ZpZGVyIC0gY2Fubm90IGNvbXBsZXRlIHJlcXVlc3QuIEFsbCByZXRyaWVzIGV4aGF1c3RlZC5cXG5PcmlnaW5hbCBFcnJvcjpcXG4ke2Vyci50b1N0cmluZygpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJpZXNFeGhhdXN0ZWRFcnIgPSBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmV0cmllc0V4aGF1c3RlZEVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBpZ25vcmUgZXJyb3IgYW5kIHJldHJ5IGFnYWluIGFmdGVyIHRpbWVvdXRcbiAgICAgICAgICAgICAgICBsb2coJ1JldHJpYWJsZSByZXF1ZXN0IGVycm9yIGVuY291bnRlcmVkLiByZXEgPSAlbywgcmVzID0gJW8sIGVycm9yID0gJW8nLCByZXEsIHJlcywgZXJyKTtcbiAgICAgICAgICAgICAgICBsb2coJ1dhaXRpbmcgMSBzZWNvbmQgdG8gdHJ5IGFnYWluLi4uJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGltZW91dCgxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXF1ZXN0IHdhcyBoYW5kbGVkIGNvcnJlY3RseSwgZW5kXG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUluZnVyYU1pZGRsZXdhcmUgPSBjcmVhdGVJbmZ1cmFNaWRkbGV3YXJlO1xuLyoqXG4gKiBNYWtlcyBhIHJlcXVlc3QgdG8gSW5mdXJhLCB1cGRhdGluZyB0aGUgZ2l2ZW4gcmVzcG9uc2Ugb2JqZWN0IGlmIHRoZSByZXNwb25zZVxuICogaGFzIGEgXCJzdWNjZXNzZnVsXCIgc3RhdHVzIGNvZGUgb3IgdGhyb3dpbmcgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSBuZXR3b3JrIC0gQSBuZXR3b3JrIHRoYXQgSW5mdXJhIHN1cHBvcnRzOyBwbHVncyBpbnRvXG4gKiBgaHR0cHM6Ly8ke25ldHdvcmt9LmluZnVyYS5pb2AuXG4gKiBAcGFyYW0gcHJvamVjdElkIC0gVGhlIEluZnVyYSBwcm9qZWN0IGlkLlxuICogQHBhcmFtIGV4dHJhSGVhZGVycyAtIEV4dHJhIGhlYWRlcnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSByZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3Qgb2J0YWluZWQgdmlhIHRoZSBtaWRkbGV3YXJlIHN0YWNrLlxuICogQHBhcmFtIHJlcyAtIFRoZSBvcmlnaW5hbCByZXNwb25zZSBvYmplY3Qgb2J0YWluZWQgdmlhIHRoZSBtaWRkbGV3YXJlIHN0YWNrLlxuICogQHBhcmFtIHNvdXJjZSAtIEEgZGVzY3JpcHRvciBmb3IgdGhlIGVudGl0eSBtYWtpbmcgdGhlIHJlcXVlc3Q7XG4gKiB0cmFja2VkIGJ5IEluZnVyYSBmb3IgYW5hbHl0aWNzIHB1cnBvc2VzLlxuICogQHRocm93cyBhbiBlcnJvciB3aXRoIGEgZGV0YWlsZWQgbWVzc2FnZSBpZiB0aGUgSFRUUCBzdGF0dXMgY29kZSBpcyBhbnl3aGVyZVxuICogb3V0c2lkZSAyeHgsIGFuZCBlc3BlY2lhbGx5IGlmIGl0IGlzIDQwNSwgNDI5LCA1MDMsIG9yIDUwNC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGVyZm9ybUZldGNoKG5ldHdvcmssIHByb2plY3RJZCwgZXh0cmFIZWFkZXJzLCByZXEsIHJlcywgc291cmNlKSB7XG4gICAgY29uc3QgeyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfSA9ICgwLCBmZXRjaF9jb25maWdfZnJvbV9yZXFfMS5mZXRjaENvbmZpZ0Zyb21SZXEpKHtcbiAgICAgICAgbmV0d29yayxcbiAgICAgICAgcHJvamVjdElkLFxuICAgICAgICBleHRyYUhlYWRlcnMsXG4gICAgICAgIHJlcSxcbiAgICAgICAgc291cmNlLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKDAsIG5vZGVfZmV0Y2hfMS5kZWZhdWx0KShmZXRjaFVybCwgZmV0Y2hQYXJhbXMpO1xuICAgIGNvbnN0IHJhd0RhdGEgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgLy8gaGFuZGxlIGVycm9yc1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgNDA1OlxuICAgICAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RGb3VuZCgpO1xuICAgICAgICAgICAgY2FzZSA0Mjk6XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKTtcbiAgICAgICAgICAgIGNhc2UgNTAzOlxuICAgICAgICAgICAgY2FzZSA1MDQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlVGltZW91dEVycm9yKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludGVybmFsRXJyb3IocmF3RGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3BlY2lhbCBjYXNlIGZvciBub3dcbiAgICBpZiAocmVxLm1ldGhvZCA9PT0gJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyAmJiByYXdEYXRhID09PSAnTm90IEZvdW5kJykge1xuICAgICAgICByZXMucmVzdWx0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBwYXJzZSBKU09OXG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocmF3RGF0YSk7XG4gICAgLy8gZmluYWxseSByZXR1cm4gcmVzdWx0XG4gICAgcmVzLnJlc3VsdCA9IGRhdGEucmVzdWx0O1xuICAgIHJlcy5lcnJvciA9IGRhdGEuZXJyb3I7XG59XG4vKipcbiAqIEJ1aWxkcyBhIEpTT04tUlBDIDIuMCBpbnRlcm5hbCBlcnJvciBvYmplY3QgZGVzY3JpYmluZyBhIHJhdGUtbGltaXRpbmdcbiAqIGVycm9yLlxuICpcbiAqIEByZXR1cm5zIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJhdGVsaW1pdEVycm9yKCkge1xuICAgIGNvbnN0IG1zZyA9IGBSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5gO1xuICAgIHJldHVybiBjcmVhdGVJbnRlcm5hbEVycm9yKG1zZyk7XG59XG4vKipcbiAqIEJ1aWxkcyBhIEpTT04tUlBDIDIuMCBpbnRlcm5hbCBlcnJvciBvYmplY3QgZGVzY3JpYmluZyBhIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQHJldHVybnMgVGhlIGVycm9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGltZW91dEVycm9yKCkge1xuICAgIGxldCBtc2cgPSBgR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuIGA7XG4gICAgbXNnICs9IGBUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gO1xuICAgIHJldHVybiBjcmVhdGVJbnRlcm5hbEVycm9yKG1zZyk7XG59XG4vKipcbiAqIEJ1aWxkcyBhIEpTT04tUlBDIDIuMCBpbnRlcm5hbCBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIG1zZyAtIFRoZSBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGVycm9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxFcnJvcihtc2cpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKG1zZyk7XG59XG4vKipcbiAqIFVwb24gbWFraW5nIGEgcmVxdWVzdCwgd2UgbWF5IGdldCBhbiBlcnJvciB0aGF0IGlzIHRlbXBvcmFyeSBhbmRcbiAqIGludGVybWl0dGVudC4gSW4gdGhlc2UgY2FzZXMgd2UgY2FuIGF0dGVtcHQgdGhlIHJlcXVlc3QgYWdhaW4gd2l0aCB0aGVcbiAqIGFzc3VtcHRpb24gdGhhdCB0aGUgZXJyb3IgaXMgdW5saWtlbHkgdG8gb2NjdXIgYWdhaW4uIEhlcmUgd2UgZGV0ZXJtaW5lIGlmIHdlXG4gKiBoYXZlIHJlY2VpdmVkIHN1Y2ggYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIGVyciAtIFRoZSBlcnJvciBvYmplY3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSByZXF1ZXN0IHRoYXQgcHJvZHVjZWQgdGhlIGVycm9yIGNhbiBiZSByZXRyaWVkLlxuICovXG5mdW5jdGlvbiBpc1JldHJpYWJsZUVycm9yKGVycikge1xuICAgIGNvbnN0IGVyck1lc3NhZ2UgPSBlcnIudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gUkVUUklBQkxFX0VSUk9SUy5zb21lKChwaHJhc2UpID0+IGVyck1lc3NhZ2UuaW5jbHVkZXMocGhyYXNlKSk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IHByb21pc2lmaWVzIGBzZXRUaW1lb3V0YC5cbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdC5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBnaXZlbiB0aW1lIGhhcyBlbGFwc2VkLlxuICovXG5mdW5jdGlvbiB0aW1lb3V0KGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGxlbmd0aCk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtaW5mdXJhLW1pZGRsZXdhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgZXRoX2pzb25fcnBjX21pZGRsZXdhcmVfMSA9IHJlcXVpcmUoXCJldGgtanNvbi1ycGMtbWlkZGxld2FyZVwiKTtcbmNvbnN0IGNyZWF0ZV9pbmZ1cmFfbWlkZGxld2FyZV8xID0gcmVxdWlyZShcIi4vY3JlYXRlLWluZnVyYS1taWRkbGV3YXJlXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgcHJvdmlkZXIgKGFzIGRlZmluZWQgaW5cbiAqIFtgZXRoLWpzb24tcnBjLW1pZGRsZXdhcmVgXShodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUpXG4gKiB3aGljaCBpcyBwcmVsb2FkZWQgd2l0aCBtaWRkbGV3YXJlIHNwZWNpYWxpemVkIGZvciBpbnRlcmZhY2luZyB3aXRoIEluZnVyYVxuICogSlNPTi1SUEMgZW5kcG9pbnRzLlxuICpcbiAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyB0byB7QGxpbmsgY3JlYXRlSW5mdXJhTWlkZGxld2FyZX0uXG4gKiBAcmV0dXJucyBUaGUgcHJvdmlkZXIgYXMgcmV0dXJuZWQgYnkgYHByb3ZpZGVyRnJvbUVuZ2luZWAgKGEgcGFydCBvZlxuICogW2BldGgtanNvbi1ycGMtbWlkZGxld2FyZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZSkpLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm92aWRlcihvcHRzKSB7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IGpzb25fcnBjX2VuZ2luZV8xLkpzb25ScGNFbmdpbmUoKTtcbiAgICBlbmdpbmUucHVzaCgoMCwgY3JlYXRlX2luZnVyYV9taWRkbGV3YXJlXzEuY3JlYXRlSW5mdXJhTWlkZGxld2FyZSkob3B0cykpO1xuICAgIHJldHVybiAoMCwgZXRoX2pzb25fcnBjX21pZGRsZXdhcmVfMS5wcm92aWRlckZyb21FbmdpbmUpKGVuZ2luZSk7XG59XG5leHBvcnRzLmNyZWF0ZVByb3ZpZGVyID0gY3JlYXRlUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtcHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZldGNoQ29uZmlnRnJvbVJlcSA9IHZvaWQgMDtcbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYXJndW1lbnRzIHRvIGZlZWQgaW50byBgZmV0Y2hgIGluIG9yZGVyIHRvIG1ha2UgYSByZXF1ZXN0IHRvXG4gKiBJbmZ1cmEuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLm5ldHdvcmsgLSBBIG5ldHdvcmsgdGhhdCBJbmZ1cmEgc3VwcG9ydHM7IHBsdWdzIGludG9cbiAqIGBodHRwczovLyR7bmV0d29ya30uaW5mdXJhLmlvYC5cbiAqIEBwYXJhbSBvcHRpb25zLnByb2plY3RJZCAtIFRoZSBJbmZ1cmEgcHJvamVjdCBpZC5cbiAqIEBwYXJhbSBvcHRpb25zLmV4dHJhSGVhZGVycyAtIEV4dHJhIGhlYWRlcnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWFrZSB0aGVcbiAqIHJlcXVlc3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5yZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3Qgb2J0YWluZWQgdmlhIHRoZVxuICogbWlkZGxld2FyZSBzdGFjay5cbiAqIEBwYXJhbSBvcHRpb25zLnNvdXJjZSAtIEEgZGVzY3JpcHRvciBmb3IgdGhlIGVudGl0eSBtYWtpbmcgdGhlIHJlcXVlc3Q7XG4gKiB0cmFja2VkIGJ5IEluZnVyYSBmb3IgYW5hbHl0aWNzIHB1cnBvc2VzLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIFVSTCBhbmQgYSBiYWcgb2Ygb3B0aW9ucywgYm90aCBvZiB3aGljaFxuICogd2lsbCBiZSBwYXNzZWQgdG8gYGZldGNoYC5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hDb25maWdGcm9tUmVxKHsgbmV0d29yaywgcHJvamVjdElkLCBleHRyYUhlYWRlcnMgPSB7fSwgcmVxLCBzb3VyY2UsIH0pIHtcbiAgICBjb25zdCByZXF1ZXN0T3JpZ2luID0gcmVxLm9yaWdpbiB8fCAnaW50ZXJuYWwnO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBleHRyYUhlYWRlcnMsIHtcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSk7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBoZWFkZXJzWydJbmZ1cmEtU291cmNlJ10gPSBgJHtzb3VyY2V9LyR7cmVxdWVzdE9yaWdpbn1gO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmZXRjaFVybDogYGh0dHBzOi8vJHtuZXR3b3JrfS5pbmZ1cmEuaW8vdjMvJHtwcm9qZWN0SWR9YCxcbiAgICAgICAgZmV0Y2hQYXJhbXM6IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZVJlcShyZXEpKSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5mZXRjaENvbmZpZ0Zyb21SZXEgPSBmZXRjaENvbmZpZ0Zyb21SZXE7XG4vKipcbiAqIFN0cmlwcyBvdXQgZXh0cmEga2V5cyBmcm9tIGEgcmVxdWVzdCBvYmplY3QgdGhhdCBjb3VsZCBiZSByZWplY3RlZCBieSBzdHJpY3RcbiAqIG5vZGVzIGxpa2UgcGFyaXR5LlxuICpcbiAqIEBwYXJhbSByZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3Qgb2J0YWluZWQgdmlhIHRoZSBtaWRkbGV3YXJlIHN0YWNrLlxuICogQHJldHVybnMgQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgSlNPTi1SUEMgcmVxdWVzdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUmVxKHJlcSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiByZXEuaWQsXG4gICAgICAgIGpzb25ycGM6IHJlcS5qc29ucnBjLFxuICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgIHBhcmFtczogcmVxLnBhcmFtcyxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2gtY29uZmlnLWZyb20tcmVxLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY3JlYXRlLWluZnVyYS1taWRkbGV3YXJlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mZXRjaC1jb25maWctZnJvbS1yZXFcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NyZWF0ZS1wcm92aWRlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVNb2R1bGVMb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyOyB9IH0pO1xuZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gKDAsIHV0aWxzXzEuY3JlYXRlUHJvamVjdExvZ2dlcikoJ2V0aC1qc29uLXJwYy1pbmZ1cmEnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmctdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydEV4aGF1c3RpdmUgPSBleHBvcnRzLmFzc2VydFN0cnVjdCA9IGV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIG9iamVjdCB3aXRoIGFcbiAqIGBtZXNzYWdlYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBvciBmYWxzZSwgZGVwZW5kaW5nIG9uIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdtZXNzYWdlJyBpbiBlcnJvcjtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBpLmUuLCBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoXG4gKiB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0NvbnN0cnVjdGFibGUoZm4pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZW9mICgoX2IgPSAoX2EgPSBmbiA9PT0gbnVsbCB8fCBmbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm4ucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSA9PT0gJ3N0cmluZycpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGVycm9yIG1lc3NhZ2UgZnJvbSBhbiB1bmtub3duIGVycm9yIG9iamVjdC4gSWYgdGhlIGVycm9yIG9iamVjdCBoYXNcbiAqIGEgYG1lc3NhZ2VgIHByb3BlcnR5LCB0aGF0IHByb3BlcnR5IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBzdHJpbmdpZmllZFxuICogZXJyb3Igb2JqZWN0IGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBvYmplY3QgdG8gZ2V0IHRoZSBtZXNzYWdlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAvLyBJZiB0aGUgZXJyb3IgZW5kcyB3aXRoIGEgcGVyaW9kLCByZW1vdmUgaXQsIGFzIHdlJ2xsIGFkZCBvdXIgb3duIHBlcmlvZC5cbiAgICBpZiAobWVzc2FnZS5lbmRzV2l0aCgnLicpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vKipcbiAqIEluaXRpYWxpc2UgYW4ge0BsaW5rIEFzc2VydGlvbkVycm9yQ29uc3RydWN0b3J9IGVycm9yLlxuICpcbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdXNlLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmZ1bmN0aW9uIGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0NvbnN0cnVjdGFibGUoRXJyb3JXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yV3JhcHBlcih7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEVycm9yV3JhcHBlcih7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfSk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IGVycm9yIGNsYXNzIHRoYXQgaXMgdGhyb3duIGlmIGFuIGFzc2VydGlvbiBmYWlscy5cbiAqL1xuY2xhc3MgQXNzZXJ0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuLyoqXG4gKiBTYW1lIGFzIE5vZGUuanMgYXNzZXJ0LlxuICogSWYgdGhlIHZhbHVlIGlzIGZhbHN5LCB0aHJvd3MgYW4gZXJyb3IsIGRvZXMgbm90aGluZyBvdGhlcndpc2UuXG4gKlxuICogQHRocm93cyB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IElmIHZhbHVlIGlzIGZhbHN5LlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHRlc3QgdGhhdCBzaG91bGQgYmUgdHJ1dGh5IHRvIHBhc3MuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIE1lc3NhZ2UgdG8gYmUgcGFzc2VkIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0gb3IgYW5cbiAqIHtAbGluayBFcnJvcn0gaW5zdGFuY2UgdG8gdGhyb3cuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LiBJZiBhIGN1c3RvbSBlcnJvciBjbGFzcyBpcyBwcm92aWRlZCBmb3JcbiAqIHRoZSBgbWVzc2FnZWAgYXJndW1lbnQsIHRoaXMgYXJndW1lbnQgaXMgaWdub3JlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBtZXNzYWdlID0gJ0Fzc2VydGlvbiBmYWlsZWQuJywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIgPSBBc3NlcnRpb25FcnJvcikge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuLyoqXG4gKiBBc3NlcnQgYSB2YWx1ZSBhZ2FpbnN0IGEgU3VwZXJzdHJ1Y3Qgc3RydWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGFnYWluc3QuXG4gKiBAcGFyYW0gZXJyb3JQcmVmaXggLSBBIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIG1lc3NhZ2UuIERlZmF1bHRzIHRvXG4gKiBcIkFzc2VydGlvbiBmYWlsZWRcIi5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFN0cnVjdCh2YWx1ZSwgc3RydWN0LCBlcnJvclByZWZpeCA9ICdBc3NlcnRpb24gZmFpbGVkJywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIgPSBBc3NlcnRpb25FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICAgICgwLCBzdXBlcnN0cnVjdF8xLmFzc2VydCkodmFsdWUsIHN0cnVjdCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBnZXRFcnJvcihFcnJvcldyYXBwZXIsIGAke2Vycm9yUHJlZml4fTogJHtnZXRFcnJvck1lc3NhZ2UoZXJyb3IpfS5gKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFN0cnVjdCA9IGFzc2VydFN0cnVjdDtcbi8qKlxuICogVXNlIGluIHRoZSBkZWZhdWx0IGNhc2Ugb2YgYSBzd2l0Y2ggdGhhdCB5b3Ugd2FudCB0byBiZSBmdWxseSBleGhhdXN0aXZlLlxuICogVXNpbmcgdGhpcyBmdW5jdGlvbiBmb3JjZXMgdGhlIGNvbXBpbGVyIHRvIGVuZm9yY2UgZXhoYXVzdGl2aXR5IGR1cmluZ1xuICogY29tcGlsZS10aW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IG51bWJlciA9IDE7XG4gKiBzd2l0Y2ggKG51bWJlcikge1xuICogICBjYXNlIDA6XG4gKiAgICAgLi4uXG4gKiAgIGNhc2UgMTpcbiAqICAgICAuLi5cbiAqICAgZGVmYXVsdDpcbiAqICAgICBhc3NlcnRFeGhhdXN0aXZlKHNuYXBQcmVmaXgpO1xuICogfVxuICogYGBgXG4gKiBAcGFyYW0gX29iamVjdCAtIFRoZSBvYmplY3Qgb24gd2hpY2ggdGhlIHN3aXRjaCBpcyBiZWluZyBvcGVyYXRlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RXhoYXVzdGl2ZShfb2JqZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJyYW5jaCByZWFjaGVkLiBTaG91bGQgYmUgZGV0ZWN0ZWQgZHVyaW5nIGNvbXBpbGF0aW9uLicpO1xufVxuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gYXNzZXJ0RXhoYXVzdGl2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTY0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHByb3ZpZGVkIHN0cmluZy1iYXNlZCBzdHJ1Y3QgaXMgdmFsaWQgYmFzZTY0LlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RyaW5nIGJhc2VkIHN0cnVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgb3B0aW9ucyB0byBzcGVjaWFsaXplIGJhc2U2NCB2YWxpZGF0aW9uLiBTZWUge0BsaW5rIEJhc2U2NE9wdGlvbnN9IGRvY3VtZW50YXRpb24uXG4gKiBAcmV0dXJucyBBIHN1cGVyc3RydWN0IHZhbGlkYXRpbmcgYmFzZTY0LlxuICovXG5jb25zdCBiYXNlNjQgPSAoc3RydWN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHBhZGRpbmdSZXF1aXJlZCA9IChfYSA9IG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICBjb25zdCBjaGFyYWN0ZXJTZXQgPSAoX2IgPSBvcHRpb25zLmNoYXJhY3RlclNldCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Jhc2U2NCc7XG4gICAgbGV0IGxldHRlcnM7XG4gICAgaWYgKGNoYXJhY3RlclNldCA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgbGV0dGVycyA9IFN0cmluZy5yYXcgYFtBLVphLXowLTkrXFwvXWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjR1cmwnKTtcbiAgICAgICAgbGV0dGVycyA9IFN0cmluZy5yYXcgYFstX0EtWmEtejAtOV1gO1xuICAgIH1cbiAgICBsZXQgcmU7XG4gICAgaWYgKHBhZGRpbmdSZXF1aXJlZCkge1xuICAgICAgICByZSA9IG5ldyBSZWdFeHAoYF4oPzoke2xldHRlcnN9ezR9KSooPzoke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXsyLDN9fCR7bGV0dGVyc317M309fCR7bGV0dGVyc317Mn09PSk/JGAsICd1Jyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKShzdHJ1Y3QsIHJlKTtcbn07XG5leHBvcnRzLmJhc2U2NCA9IGJhc2U2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRGF0YVZpZXcgPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy52YWx1ZVRvQnl0ZXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBleHBvcnRzLm51bWJlclRvQnl0ZXMgPSBleHBvcnRzLnNpZ25lZEJpZ0ludFRvQnl0ZXMgPSBleHBvcnRzLmJpZ0ludFRvQnl0ZXMgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBleHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBleHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBleHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmFzc2VydElzQnl0ZXMgPSBleHBvcnRzLmlzQnl0ZXMgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuLy8gJzAnLmNoYXJDb2RlQXQoMCkgPT09IDQ4XG5jb25zdCBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNDg7XG4vLyAnOScuY2hhckNvZGVBdCgwKSA9PT0gNTdcbmNvbnN0IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVIgPSA1ODtcbmNvbnN0IEhFWF9DSEFSQUNURVJfT0ZGU0VUID0gODc7XG4vKipcbiAqIE1lbW9pemVkIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSB0byBiZSB1c2VkIGFzIGEgbG9va3VwIHRhYmxlIGZvclxuICogY29udmVydGluZyBieXRlcyB0byBoZXhhZGVjaW1hbCB2YWx1ZXMuXG4gKlxuICogVGhlIGFycmF5IGlzIGNyZWF0ZWQgbGF6aWx5IGFuZCB0aGVuIGNhY2hlZCBmb3IgZnV0dXJlIHVzZS4gVGhlIGJlbmVmaXQgb2ZcbiAqIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB0aGUgcGVyZm9ybWFuY2Ugb2YgY29udmVydGluZyBieXRlcyB0byBoZXggaXMgbXVjaFxuICogYmV0dGVyIHRoYW4gaWYgd2Ugd2VyZSB0byBjYWxsIGB0b1N0cmluZygxNilgIG9uIGVhY2ggYnl0ZS5cbiAqXG4gKiBUaGUgZG93bnNpZGUgaXMgdGhhdCB0aGUgYXJyYXkgaXMgY3JlYXRlZCBvbmNlIGFuZCB0aGVuIG5ldmVyIGdhcmJhZ2VcbiAqIGNvbGxlY3RlZC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGluIHByYWN0aWNlIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgMjU2XG4gKiBlbGVtZW50cyBsb25nLlxuICpcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBsb29rdXAgdGFibGUuXG4gKi9cbmZ1bmN0aW9uIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpIHtcbiAgICAvLyBUbyBhdm9pZCBpc3N1ZXMgd2l0aCB0cmVlIHNoYWtpbmcsIHdlIG5lZWQgdG8gdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZVxuICAgIC8vIGFycmF5LiBUaGlzIGlzIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgdXNlZCBpbiB0aGUgYGJ5dGVzVG9IZXhgIGZ1bmN0aW9uXG4gICAgLy8gYW5kIGlmIHdlIHdlcmUgdG8gdXNlIGEgZ2xvYmFsIHZhcmlhYmxlLCB0aGUgYXJyYXkgbWlnaHQgYmUgcmVtb3ZlZCBieSB0aGVcbiAgICAvLyB0cmVlIHNoYWtlci5cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IFtdO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZS5wdXNoKGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb29rdXBUYWJsZTtcbiAgICB9O1xufVxuLyoqXG4gKiBGdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcn1cbiAqIGZ1bmN0aW9uLlxuICovXG5jb25zdCBnZXRQcmVjb21wdXRlZEhleFZhbHVlcyA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNCeXRlcyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgVWludDhBcnJheS4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGFzc2VydElzQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlcygpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gbmV3IEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBoZXhhZGVjaW1hbFtpXSA9IGxvb2t1cFRhYmxlW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkoaGV4YWRlY2ltYWwuam9pbignJykpO1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9OdW1iZXJ9LlxuICogVG8gY29udmVydCBhIHR3bydzIGNvbXBsZW1lbnQgZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb1NpZ25lZEJpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gYnl0ZXNUb0hleChieXRlcyk7XG4gICAgcmV0dXJuIEJpZ0ludChoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBieXRlc1RvQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgc2lnbmVkIGBiaWdpbnRgLiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYnl0ZXMgYXJlXG4gKiBlbmNvZGVkIGluIHR3bydzIGNvbXBsZW1lbnQuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhbiB1bnNpZ25lZCBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzaWduZWQgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmVkIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU2lnbmVkQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBCaWdJbnQoOCkpICsgQmlnSW50KGJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50LmFzSW50TihieXRlcy5sZW5ndGggKiA4LCB2YWx1ZSk7XG59XG5leHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBieXRlc1RvU2lnbmVkQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBiaWdpbnQgPSBieXRlc1RvQmlnSW50KGJ5dGVzKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdpbnQgPD0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgJ051bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYnl0ZXNUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gTnVtYmVyKGJpZ2ludCk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBieXRlc1RvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuIFRoZSBzdHJpbmcgY2FuIG9wdGlvbmFsbHkgYmVcbiAqIHByZWZpeGVkIHdpdGggYDB4YC4gSXQgYWNjZXB0cyBldmVuIGFuZCBvZGQgbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIFwiMHhcIiwgYW4gZW1wdHkgYFVpbnQ4QXJyYXlgIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gXCIweFwiIGlzIG9mdGVuIHVzZWQgYXMgZW1wdHkgYnl0ZSBhcnJheS5cbiAgICBpZiAoKChfYSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS50b0xvd2VyQ2FzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodmFsdWUpKSA9PT0gJzB4Jykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gUmVtb3ZlIHRoZSBgMHhgIHByZWZpeCBpZiBpdCBleGlzdHMsIGFuZCBwYWQgdGhlIHN0cmluZyB0byBoYXZlIGFuIGV2ZW5cbiAgICAvLyBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICBjb25zdCBzdHJpcHBlZFZhbHVlID0gKDAsIGhleF8xLnJlbW92ZTB4KSh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBzdHJpcHBlZFZhbHVlLmxlbmd0aCAlIDIgPT09IDAgPyBzdHJpcHBlZFZhbHVlIDogYDAke3N0cmlwcGVkVmFsdWV9YDtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KG5vcm1hbGl6ZWRWYWx1ZS5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHRoaXMgaXMgbm90IHRoZSBwcmV0dGllc3Qgd2F5IHRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYVxuICAgICAgICAvLyBgVWludDhBcnJheWAsIGl0IGlzIGEgbG90IGZhc3RlciB0aGFuIHVzaW5nIGBwYXJzZUludGAgdG8gY29udmVydCBlYWNoXG4gICAgICAgIC8vIGNoYXJhY3Rlci5cbiAgICAgICAgY29uc3QgYzEgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMik7XG4gICAgICAgIGNvbnN0IGMyID0gbm9ybWFsaXplZFZhbHVlLmNoYXJDb2RlQXQoaSAqIDIgKyAxKTtcbiAgICAgICAgY29uc3QgbjEgPSBjMSAtXG4gICAgICAgICAgICAoYzEgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGNvbnN0IG4yID0gYzIgLVxuICAgICAgICAgICAgKGMyIDwgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgID8gSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgIDogSEVYX0NIQVJBQ1RFUl9PRkZTRVQpO1xuICAgICAgICBieXRlc1tpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBgYmlnaW50YCBpcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLiBUbyBjb252ZXJ0IGEgc2lnbmVkXG4gKiBgYmlnaW50YCBpbnN0ZWFkLCB1c2Uge0BsaW5rIHNpZ25lZEJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBiaWdpbnQgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludFRvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSBCaWdJbnQoMCksICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGJpZ2ludC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLmJpZ0ludFRvQnl0ZXMgPSBiaWdJbnRUb0J5dGVzO1xuLyoqXG4gKiBDaGVjayBpZiBhIGBiaWdpbnRgIGZpdHMgaW4gYSBjZXJ0YWluIG51bWJlciBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY2hlY2suXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgbnVtYmVyIG9mIGJ5dGVzLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgYGJpZ2ludGAgZml0cyBpbiB0aGUgbnVtYmVyIG9mIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBiaWdJbnRGaXRzKHZhbHVlLCBieXRlcykge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJ5dGVzID4gMCk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGNvbnN0IG1hc2sgPSB2YWx1ZSA+PiBCaWdJbnQoMzEpO1xuICAgIHJldHVybiAhKCgofnZhbHVlICYgbWFzaykgKyAodmFsdWUgJiB+bWFzaykpID4+IEJpZ0ludChieXRlcyAqIDggKyB+MCkpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGlzIHVzZXMgdHdvJ3MgY29tcGxlbWVudFxuICogZW5jb2RpbmcgdG8gcmVwcmVzZW50IG5lZ2F0aXZlIG51bWJlcnMuXG4gKlxuICogVG8gY29udmVydCBhbiB1bnNpZ25lZCBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0J5dGVzfS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHBhcmFtIGJ5dGVMZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgYFVpbnQ4QXJyYXlgLiBJZiB0aGUgbnVtYmVyXG4gKiBpcyBsYXJnZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gbGVuZ3RoLFxuICogYW4gZXJyb3IgaXMgdGhyb3duLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gc2lnbmVkQmlnSW50VG9CeXRlcyh2YWx1ZSwgYnl0ZUxlbmd0aCkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiBieXRlTGVuZ3RoID09PSAnbnVtYmVyJywgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZUxlbmd0aCA+IDAsICdCeXRlIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJpZ0ludEZpdHModmFsdWUsIGJ5dGVMZW5ndGgpLCAnQnl0ZSBsZW5ndGggaXMgdG9vIHNtYWxsIHRvIHJlcHJlc2VudCB0aGUgZ2l2ZW4gdmFsdWUuJyk7XG4gICAgLy8gRVNMaW50IGRvZXNuJ3QgbGlrZSBtdXRhdGluZyBmdW5jdGlvbiBwYXJhbWV0ZXJzLCBzbyB0byBhdm9pZCBoYXZpbmcgdG9cbiAgICAvLyBkaXNhYmxlIHRoZSBydWxlLCB3ZSBjcmVhdGUgYSBuZXcgdmFyaWFibGUuXG4gICAgbGV0IG51bWJlclZhbHVlID0gdmFsdWU7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gTnVtYmVyKEJpZ0ludC5hc1VpbnROKDgsIG51bWJlclZhbHVlKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIG51bWJlclZhbHVlID4+PSBCaWdJbnQoOCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5yZXZlcnNlKCk7XG59XG5leHBvcnRzLnNpZ25lZEJpZ0ludFRvQnl0ZXMgPSBzaWduZWRCaWdJbnRUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYG51bWJlcmAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqIEB0aHJvd3MgSWYgdGhlIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnVmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpLCAnVmFsdWUgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJpZ0ludFRvQnl0ZXNgIGluc3RlYWQuJyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gbnVtYmVyVG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBzdHJpbmdgIHRvIGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdWYWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xufVxuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gc3RyaW5nVG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGJ5dGUtbGlrZSB2YWx1ZSB0byBhIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlIGNhbiBiZSBhIGBVaW50OEFycmF5YCxcbiAqIGEgYGJpZ2ludGAsIGEgYG51bWJlcmAsIG9yIGEgYHN0cmluZ2AuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gZ3Vlc3MgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGJhc2VkIG9uIGl0cyB0eXBlIGFuZFxuICogY29udGVudHMuIEZvciBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgY29udmVyc2lvbiwgdXNlIHRoZSBtb3JlIHNwZWNpZmljXG4gKiBjb252ZXJzaW9uIGZ1bmN0aW9ucywgc3VjaCBhcyB7QGxpbmsgaGV4VG9CeXRlc30gb3Ige0BsaW5rIHN0cmluZ1RvQnl0ZXN9LlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBzdHJpbmdgLCBhbmQgaXQgaXMgcHJlZml4ZWQgd2l0aCBgMHhgLCBpdCB3aWxsIGJlXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFcbiAqIFVURi04IHN0cmluZy4gVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBieXRlcyB3aXRob3V0IGludGVycHJldGluZ1xuICogaXQgYXMgYSBVVEYtOCBzdHJpbmcsIHVzZSB7QGxpbmsgaGV4VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgYXNzdW1lZCB0byBiZSB1bnNpZ25lZC4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgdG8gYnl0ZXMsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiB2YWx1ZVRvQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gYmlnSW50VG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHZhbHVlIHR5cGU6IFwiJHt0eXBlb2YgdmFsdWV9XCIuYCk7XG59XG5leHBvcnRzLnZhbHVlVG9CeXRlcyA9IHZhbHVlVG9CeXRlcztcbi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYnl0ZS1saWtlIHZhbHVlcyBpbnRvIGEgc2luZ2xlIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlc1xuICogY2FuIGJlIGBVaW50OEFycmF5YCwgYGJpZ2ludGAsIGBudW1iZXJgLCBvciBgc3RyaW5nYC4gVGhpcyB1c2VzXG4gKiB7QGxpbmsgdmFsdWVUb0J5dGVzfSB1bmRlciB0aGUgaG9vZCB0byBjb252ZXJ0IGVhY2ggdmFsdWUgdG8gYnl0ZXMuIFJlZmVyIHRvXG4gKiB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGF0IGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKHZhbHVlcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVUb0J5dGVzKHZhbHVlc1tpXSk7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgYnl0ZUxlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCBub3JtYWxpemVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHdlIGNvdWxkIHNpbXBseSBzcHJlYWQgdGhlIHZhbHVlcyBpbnRvIGFuIGFycmF5IGFuZCB1c2VcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXkuZnJvbWAsIHRoYXQgaXMgYSBsb3Qgc2xvd2VyIHRoYW4gdXNpbmcgYFVpbnQ4QXJyYXkuc2V0YC5cbiAgICAgICAgYnl0ZXMuc2V0KG5vcm1hbGl6ZWRWYWx1ZXNbaV0sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBub3JtYWxpemVkVmFsdWVzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IGZyb20gYSB7QGxpbmsgVWludDhBcnJheX0uIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogZnVuY3Rpb24gdGhhdCBhdm9pZHMgaGF2aW5nIHRvIGNyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gbWFudWFsbHksIHdoaWNoXG4gKiByZXF1aXJlcyBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGV2ZXJ5IHRpbWUuXG4gKlxuICogTm90IHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgY2FuIHJlc3VsdCBpblxuICogdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSB7QGxpbmsgVWludDhBcnJheX0gaXMgYSB2aWV3IG9mIGEgbGFyZ2VyXG4gKiB7QGxpbmsgQXJyYXlCdWZmZXJ9LCBlLmcuLCB3aGVuIHVzaW5nIHtAbGluayBVaW50OEFycmF5LnN1YmFycmF5fS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gc3VwcG9ydHMgTm9kZS5qcyB7QGxpbmsgQnVmZmVyfXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKTtcbiAqXG4gKiAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICogY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldyhieXRlcyk7XG4gKiBgYGBcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjcmVhdGUgdGhlIHtAbGluayBEYXRhVmlld30gZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgRGF0YVZpZXd9LlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYXRhVmlldyhieXRlcykge1xuICAgIC8vIFRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBOb2RlLmpzLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBieXRlcyBhcmVcbiAgICAvLyBhIEJ1ZmZlci4gSWYgc28sIHdlIG5lZWQgdG8gc2xpY2UgdGhlIGJ1ZmZlciB0byBnZXQgdGhlIHVuZGVybHlpbmdcbiAgICAvLyBBcnJheUJ1ZmZlci5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ5dGVzLmJ1ZmZlci5zbGljZShieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlT2Zmc2V0ICsgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xufVxuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGJhc2U2NF8xID0gcmVxdWlyZShcIi4vYmFzZTY0XCIpO1xuZXhwb3J0cy5DaGVja3N1bVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnNpemUpKCgwLCBiYXNlNjRfMS5iYXNlNjQpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgeyBwYWRkaW5nUmVxdWlyZWQ6IHRydWUgfSksIDQ0LCA0NCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3N1bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSGV4ID0gZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGV4cG9ydHMuY3JlYXRlQmlnSW50ID0gZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbmNvbnN0IE51bWJlckxpa2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgKDAsIHN1cGVyc3RydWN0XzEuYmlnaW50KSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGhleF8xLlN0cmljdEhleFN0cnVjdF0pO1xuY29uc3QgTnVtYmVyQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCBOdW1iZXJMaWtlU3RydWN0LCBOdW1iZXIpO1xuY29uc3QgQmlnSW50Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuYmlnaW50KSgpLCBOdW1iZXJMaWtlU3RydWN0LCBCaWdJbnQpO1xuY29uc3QgQnl0ZXNMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtoZXhfMS5TdHJpY3RIZXhTdHJ1Y3QsICgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KV0pO1xuY29uc3QgQnl0ZXNDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0XSksIGJ5dGVzXzEuaGV4VG9CeXRlcyk7XG5jb25zdCBIZXhDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKShoZXhfMS5TdHJpY3RIZXhTdHJ1Y3QsICgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KSwgYnl0ZXNfMS5ieXRlc1RvSGV4KTtcbi8qKlxuICogQ3JlYXRlIGEgbnVtYmVyIGZyb20gYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlci5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXNcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICpcbiAqIFRoaXMgdmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmdcbiAqIG51bWJlciBpcyBub3QgYE5hTmAgb3IgYEluZmluaXR5YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVOdW1iZXIoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDY2MDUxXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZU51bWJlcigxMjNuKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyAxMjNcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgbnVtYmVyIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZSwgb3IgaWYgdGhlIHJlc3VsdGluZyBudW1iZXJcbiAqIGlzIGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU51bWJlcih2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIE51bWJlckNvZXJjZXIpO1xuICAgICAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNGaW5pdGUocmVzdWx0KSwgYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSBjcmVhdGVOdW1iZXI7XG4vKipcbiAqIENyZWF0ZSBhIGBiaWdpbnRgIGZyb20gYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQgaXMgY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBhIGRlY2ltYWwgbnVtYmVyIGFuZFxuICogY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlciBhbmQgY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQmlnSW50KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyAxNjkwOTA2MG5cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQmlnSW50KDEyMyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzblxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBiaWdpbnQgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGJpZ2ludC5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCaWdJbnQodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUaGUgYEJpZ0ludGAgY29uc3RydWN0b3IgdGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB2YWxpZGF0ZSB0aGUgdmFsdWUgbWFudWFsbHkuXG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBCaWdJbnRDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlQmlnSW50ID0gY3JlYXRlQmlnSW50O1xuLyoqXG4gKiBDcmVhdGUgYSBieXRlIGFycmF5IGZyb20gYSBieXRlcy1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYnl0ZSBhcnJheSwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzIGludGVycHJldGVkXG4gKiBhcyBhIGhleGFkZWNpbWFsIG51bWJlciBhbmQgY29udmVydGVkIHRvIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVCeXRlcygnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVCeXRlcygnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyBVaW50OEFycmF5IFsgMSwgMiwgMyBdXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGJ5dGUgYXJyYXkgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGJ5dGUgYXJyYXkuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBieXRlcy1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCeXRlcyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICcweCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBCeXRlc0NvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGJ5dGVzLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJ5dGVzID0gY3JlYXRlQnl0ZXM7XG4vKipcbiAqIENyZWF0ZSBhIGhleGFkZWNpbWFsIHN0cmluZyBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzIHJldHVybmVkXG4gKiBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBoZXggc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUhleChuZXcgVWludDhBcnJheShbMSwgMiwgM10pKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gJzB4MDEwMjAzJ1xuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVIZXgoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gJzB4MDEwMjAzJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBoZXggc3RyaW5nIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBoZXggc3RyaW5nLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGV4KHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEhleENvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGJ5dGVzLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUhleCA9IGNyZWF0ZUhleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZXJjZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9Gcm96ZW5NYXBfbWFwLCBfRnJvemVuU2V0X3NldDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnJvemVuU2V0ID0gZXhwb3J0cy5Gcm96ZW5NYXAgPSB2b2lkIDA7XG4vKipcbiAqIEEge0BsaW5rIFJlYWRvbmx5TWFwfSB0aGF0IGNhbm5vdCBiZSBtb2RpZmllZCBhZnRlciBpbnN0YW50aWF0aW9uLlxuICogVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgYW4gaW5uZXIgbWFwIGhpZGRlbiB2aWEgYSBwcml2YXRlIGZpZWxkLCBhbmQgdGhlXG4gKiBpbW11dGFiaWxpdHkgZ3VhcmFudGVlIHJlbGllcyBvbiBpdCBiZWluZyBpbXBvc3NpYmxlIHRvIGdldCBhIHJlZmVyZW5jZVxuICogdG8gdGhpcyBtYXAuXG4gKi9cbmNsYXNzIEZyb3plbk1hcCB7XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBfRnJvemVuTWFwX21hcC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgbmV3IE1hcChlbnRyaWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgICBbKF9Gcm96ZW5NYXBfbWFwID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIilbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIG1hcC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwga2V5LCBfbWFwKSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgdGhpcykpO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZ2V0KGtleSk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5oYXMoa2V5KTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS52YWx1ZXMoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgRnJvemVuTWFwKCR7dGhpcy5zaXplfSkgeyR7dGhpcy5zaXplID4gMFxuICAgICAgICAgICAgPyBgICR7Wy4uLnRoaXMuZW50cmllcygpXVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7U3RyaW5nKGtleSl9ID0+ICR7U3RyaW5nKHZhbHVlKX1gKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuTWFwID0gRnJvemVuTWFwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seVNldH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIHNldCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgc2V0LlxuICovXG5jbGFzcyBGcm96ZW5TZXQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICBfRnJvemVuU2V0X3NldC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgbmV3IFNldCh2YWx1ZXMpLCBcImZcIik7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnNpemU7XG4gICAgfVxuICAgIFsoX0Zyb3plblNldF9zZXQgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuZW50cmllcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW4gb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tXG4gICAgICAgIC8vIHJlY2VpdmluZyBhIHJlZmVyZW5jZSB0byB0aGUgaW5uZXIgc2V0LlxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmZvckVhY2goKHZhbHVlLCB2YWx1ZTIsIF9zZXQpID0+IGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgdmFsdWUyLCB0aGlzKSk7XG4gICAgfVxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmhhcyh2YWx1ZSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plblNldCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLnZhbHVlcygpXS5tYXAoKG1lbWJlcikgPT4gU3RyaW5nKG1lbWJlcikpLmpvaW4oJywgJyl9IGBcbiAgICAgICAgICAgIDogJyd9fWA7XG4gICAgfVxufVxuZXhwb3J0cy5Gcm96ZW5TZXQgPSBGcm96ZW5TZXQ7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcCk7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcC5wcm90b3R5cGUpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQucHJvdG90eXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxlY3Rpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZW1vdmUweCA9IGV4cG9ydHMuYWRkMHggPSBleHBvcnRzLmFzc2VydElzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSBleHBvcnRzLkhleFN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmV4cG9ydHMuSGV4U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAvXig/OjB4KT9bMC05YS1mXSskL2l1KTtcbmV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAvXjB4WzAtOWEtZl0rJC9pdSk7XG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5IZXhTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0hleFN0cmluZyA9IGlzSGV4U3RyaW5nO1xuLyoqXG4gKiBTdHJpY3RseSBjaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBzdHJpbmcuIEEgdmFsaWQgaGV4IHN0cmluZyBtdXN0XG4gKiBzdGFydCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLlN0cmljdEhleFN0cnVjdCk7XG59XG5leHBvcnRzLmlzU3RyaWN0SGV4U3RyaW5nID0gaXNTdHJpY3RIZXhTdHJpbmc7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNIZXhTdHJpbmcodmFsdWUpLCAnVmFsdWUgbXVzdCBiZSBhIGhleGFkZWNpbWFsIHN0cmluZy4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBhc3NlcnRJc0hleFN0cmluZztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuIEEgdmFsaWQgaGV4IHN0cmluZyBtdXN0IHN0YXJ0IHdpdGhcbiAqIHRoZSBcIjB4XCItcHJlZml4LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpLCAnVmFsdWUgbXVzdCBiZSBhIGhleGFkZWNpbWFsIHN0cmluZywgc3RhcnRpbmcgd2l0aCBcIjB4XCIuJyk7XG59XG5leHBvcnRzLmFzc2VydElzU3RyaWN0SGV4U3RyaW5nID0gYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmc7XG4vKipcbiAqIEFkZCB0aGUgYDB4YC1wcmVmaXggdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgYWxyZWFkeSBoYXMgdGhlXG4gKiBwcmVmaXgsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSBoZXhhZGVjaW1hbCAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYWRkIHRoZSBwcmVmaXggdG8uXG4gKiBAcmV0dXJucyBUaGUgcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhZGQweChoZXhhZGVjaW1hbCkge1xuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIHJldHVybiBoZXhhZGVjaW1hbDtcbiAgICB9XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzBYJykpIHtcbiAgICAgICAgcmV0dXJuIGAweCR7aGV4YWRlY2ltYWwuc3Vic3RyaW5nKDIpfWA7XG4gICAgfVxuICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsfWA7XG59XG5leHBvcnRzLmFkZDB4ID0gYWRkMHg7XG4vKipcbiAqIFJlbW92ZSB0aGUgYDB4YC1wcmVmaXggZnJvbSBhIGhleGFkZWNpbWFsIHN0cmluZy4gSWYgdGhlIHN0cmluZyBkb2Vzbid0IGhhdmVcbiAqIHRoZSBwcmVmaXgsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSBoZXhhZGVjaW1hbCAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gcmVtb3ZlIHRoZSBwcmVmaXggZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB1bi1wcmVmaXhlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZTB4KGhleGFkZWNpbWFsKSB7XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzB4JykgfHwgaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMFgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWwuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG59XG5leHBvcnRzLnJlbW92ZTB4ID0gcmVtb3ZlMHg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NlcnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2U2NFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnl0ZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NoZWNrc3VtXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2VyY2Vyc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29sbGVjdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hleFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vanNvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbG9nZ2luZ1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWlzY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbnVtYmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vcGFxdWVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RpbWVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZlcnNpb25zXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUpzb25BbmRHZXRTaXplID0gZXhwb3J0cy5nZXRKc29uUnBjSWRWYWxpZGF0b3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gZXhwb3J0cy5qc29ucnBjMiA9IGV4cG9ydHMuaXNWYWxpZEpzb24gPSBleHBvcnRzLkpzb25TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBtaXNjXzEgPSByZXF1aXJlKFwiLi9taXNjXCIpO1xuZXhwb3J0cy5Kc29uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuZGVmaW5lKSgnSnNvbicsICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IFtpc1ZhbGlkXSA9IHZhbGlkYXRlSnNvbkFuZEdldFNpemUodmFsdWUsIHRydWUpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gJ0V4cGVjdGVkIGEgdmFsaWQgSlNPTi1zZXJpYWxpemFibGUgdmFsdWUnO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvbn0gdmFsdWUsIGkuZS4sIGEgdmFsdWUgdGhhdCBpc1xuICogc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvbn0gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRKc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZEpzb24gPSBpc1ZhbGlkSnNvbjtcbi8qKlxuICogVGhlIHN0cmluZyAnMi4wJy5cbiAqL1xuZXhwb3J0cy5qc29ucnBjMiA9ICcyLjAnO1xuZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmxpdGVyYWwpKGV4cG9ydHMuanNvbnJwYzIpO1xuZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5udWxsYWJsZSkoKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKV0pKTtcbmV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgY29kZTogKDAsIHN1cGVyc3RydWN0XzEuaW50ZWdlcikoKSxcbiAgICBtZXNzYWdlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgZGF0YTogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKGV4cG9ydHMuSnNvblN0cnVjdCksXG4gICAgc3RhY2s6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCkpLFxufSk7XG5leHBvcnRzLkpzb25ScGNQYXJhbXNTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5yZWNvcmQpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgZXhwb3J0cy5Kc29uU3RydWN0KSwgKDAsIHN1cGVyc3RydWN0XzEuYXJyYXkpKGV4cG9ydHMuSnNvblN0cnVjdCldKSk7XG5leHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleHBvcnRzLkpzb25ScGNQYXJhbXNTdHJ1Y3QsXG59KTtcbmV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9taXQpKGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QsIFsnaWQnXSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjTm90aWZpY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gaXNKc29uUnBjTm90aWZpY2F0aW9uO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgbm90aWZpY2F0aW9uJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uID0gYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNSZXF1ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBpc0pzb25ScGNSZXF1ZXN0O1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdCBvciBub3RpZmljYXRpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1JlcXVlc3QodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHJlcXVlc3QnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXF1ZXN0ID0gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdDtcbmV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIHJlc3VsdDogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnVua25vd24pKCkpLFxuICAgIGVycm9yOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QpLFxufSk7XG5leHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiBleHBvcnRzLkpzb25TdHJ1Y3QsXG59KTtcbmV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICBlcnJvcjogZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QsXG59KTtcbmV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtcbiAgICBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0LFxuICAgIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsXG5dKTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayB3aGV0aGVyIHNwZWNpZmllZCBKU09OLVJQQyByZXNwb25zZSBpcyBhXG4gKiB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0uXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIHBlbmRpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzUGVuZGluZ0pzb25ScGNSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykocmVzcG9uc2UsIGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGlzUGVuZGluZ0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIFBlbmRpbmdKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIFBlbmRpbmdKc29uUnBjUmVzcG9uc2V9XG4gKiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZShyZXNwb25zZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBwZW5kaW5nIEpTT04tUlBDIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgYSB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgb2JqZWN0IGlzIGEgSnNvblJwY1Jlc3BvbnNlLlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykocmVzcG9uc2UsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVzcG9uc2UgPSBpc0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1Jlc3BvbnNlKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXNwb25zZSA9IGFzc2VydElzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNTdWNjZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY1N1Y2Nlc3MgPSBpc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1N1Y2Nlc3ModmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHN1Y2Nlc3MgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNTdWNjZXNzID0gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcztcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjRmFpbHVyZSh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNGYWlsdXJlID0gaXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNGYWlsdXJlKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBmYWlsdXJlIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGFzc2VydElzSnNvblJwY0ZhaWx1cmU7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjRXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0Vycm9yID0gaXNKc29uUnBjRXJyb3I7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNFcnJvcih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGVycm9yJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRXJyb3IgPSBhc3NlcnRJc0pzb25ScGNFcnJvcjtcbi8qKlxuICogR2V0cyBhIGZ1bmN0aW9uIGZvciB2YWxpZGF0aW5nIEpTT04tUlBDIHJlcXVlc3QgLyByZXNwb25zZSBgaWRgIHZhbHVlcy5cbiAqXG4gKiBCeSBtYW5pcHVsYXRpbmcgdGhlIG9wdGlvbnMgb2YgdGhpcyBmYWN0b3J5LCB5b3UgY2FuIGNvbnRyb2wgdGhlIGJlaGF2aW9yXG4gKiBvZiB0aGUgcmVzdWx0aW5nIHZhbGlkYXRvciBmb3Igc29tZSBlZGdlIGNhc2VzLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGUuZy5cbiAqIGBudWxsYCBzaG91bGQgc29tZXRpbWVzIGJ1dCBub3QgYWx3YXlzIGJlIHBlcm1pdHRlZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGVtcHR5IHN0cmluZyAoYCcnYCkgaXMgYWx3YXlzIHBlcm1pdHRlZCBieSB0aGUgSlNPTi1SUENcbiAqIHNwZWNpZmljYXRpb24sIGJ1dCB0aGF0IGtpbmQgb2Ygc3Vja3MgYW5kIHlvdSBtYXkgd2FudCB0byBmb3JiaWQgaXQgaW4gc29tZVxuICogaW5zdGFuY2VzIGFueXdheS5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlXG4gKiBbSlNPTi1SUEMgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuanNvbnJwYy5vcmcvc3BlY2lmaWNhdGlvbikuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdEVtcHR5U3RyaW5nIC0gV2hldGhlciB0aGUgZW1wdHkgc3RyaW5nIChpLmUuIGAnJ2ApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELiBEZWZhdWx0OiBgdHJ1ZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdEZyYWN0aW9ucyAtIFdoZXRoZXIgZnJhY3Rpb25hbCBudW1iZXJzIChlLmcuIGAxLjJgKVxuICogc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQgSURzLiBEZWZhdWx0OiBgZmFsc2VgXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXROdWxsIC0gV2hldGhlciBgbnVsbGAgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB2YWxpZCBJRC5cbiAqIERlZmF1bHQ6IGB0cnVlYFxuICogQHJldHVybnMgVGhlIEpTT04tUlBDIElEIHZhbGlkYXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0SnNvblJwY0lkVmFsaWRhdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHBlcm1pdEVtcHR5U3RyaW5nLCBwZXJtaXRGcmFjdGlvbnMsIHBlcm1pdE51bGwgfSA9IE9iamVjdC5hc3NpZ24oeyBwZXJtaXRFbXB0eVN0cmluZzogdHJ1ZSwgcGVybWl0RnJhY3Rpb25zOiBmYWxzZSwgcGVybWl0TnVsbDogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBUeXBlIGd1YXJkIGZvciB7QGxpbmsgSnNvblJwY0lkfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBKU09OLVJQQyBJRCB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiBJRCBpcyB2YWxpZCBwZXIgdGhlIG9wdGlvbnMgZ2l2ZW4gdG8gdGhlXG4gICAgICogZmFjdG9yeS5cbiAgICAgKi9cbiAgICBjb25zdCBpc1ZhbGlkSnNvblJwY0lkID0gKGlkKSA9PiB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCh0eXBlb2YgaWQgPT09ICdudW1iZXInICYmIChwZXJtaXRGcmFjdGlvbnMgfHwgTnVtYmVyLmlzSW50ZWdlcihpZCkpKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgJiYgKHBlcm1pdEVtcHR5U3RyaW5nIHx8IGlkLmxlbmd0aCA+IDApKSB8fFxuICAgICAgICAgICAgKHBlcm1pdE51bGwgJiYgaWQgPT09IG51bGwpKTtcbiAgICB9O1xuICAgIHJldHVybiBpc1ZhbGlkSnNvblJwY0lkO1xufVxuZXhwb3J0cy5nZXRKc29uUnBjSWRWYWxpZGF0b3IgPSBnZXRKc29uUnBjSWRWYWxpZGF0b3I7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgSlNPTiBzZXJpYWxpemFibGUgYW5kIGNvdW50cyB0aGUgdG90YWwgbnVtYmVyXG4gKiBvZiBieXRlcyBuZWVkZWQgdG8gc3RvcmUgdGhlIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGpzT2JqZWN0IC0gUG90ZW50aWFsIEpTT04gc2VyaWFsaXphYmxlIG9iamVjdC5cbiAqIEBwYXJhbSBza2lwU2l6aW5nUHJvY2VzcyAtIFNraXAgSlNPTiBzaXplIGNhbGN1bGF0aW9uIChkZWZhdWx0OiBmYWxzZSkuXG4gKiBAcmV0dXJucyBUdXBsZSBbaXNWYWxpZCwgcGxhaW5UZXh0U2l6ZUluQnl0ZXNdIGNvbnRhaW5pbmcgYSBib29sZWFuIHRoYXQgc2lnbmFscyB3aGV0aGVyXG4gKiB0aGUgdmFsdWUgd2FzIHNlcmlhbGl6YWJsZSBhbmQgYSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBpdCB3aWxsIHVzZSB3aGVuIHNlcmlhbGl6ZWQgdG8gSlNPTi5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVKc29uQW5kR2V0U2l6ZShqc09iamVjdCwgc2tpcFNpemluZ1Byb2Nlc3MgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlZW5PYmplY3RzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgSlNPTiBzZXJpYWxpemFibGUgYW5kIGNvdW50cyB0aGUgdG90YWwgbnVtYmVyXG4gICAgICogb2YgYnl0ZXMgbmVlZGVkIHRvIHN0b3JlIHRoZSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhlIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoZSBlbmNvZGluZyBvZiB0aGUgSlNPTiBpcyBkb25lIGluIFVURi04LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gUG90ZW50aWFsIEpTT04gc2VyaWFsaXphYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBza2lwU2l6aW5nIC0gU2tpcCBKU09OIHNpemUgY2FsY3VsYXRpb24gKGRlZmF1bHQ6IGZhbHNlKS5cbiAgICAgKiBAcmV0dXJucyBUdXBsZSBbaXNWYWxpZCwgcGxhaW5UZXh0U2l6ZUluQnl0ZXNdIGNvbnRhaW5pbmcgYSBib29sZWFuIHRoYXQgc2lnbmFscyB3aGV0aGVyXG4gICAgICogdGhlIHZhbHVlIHdhcyBzZXJpYWxpemFibGUgYW5kIGEgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaXQgd2lsbCB1c2Ugd2hlbiBzZXJpYWxpemVkIHRvIEpTT04uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SnNvblNlcmlhbGl6YWJsZUluZm8odmFsdWUsIHNraXBTaXppbmcpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYWxyZWFkeSBzcGVjaWZpZWQgY29uc3RhbnQgc2l6ZSBmb3IgbnVsbCAoc3BlY2lhbCBvYmplY3QpXG4gICAgICAgICAgICByZXR1cm4gW3RydWUsIHNraXBTaXppbmcgPyAwIDogbWlzY18xLkpzb25TaXplLk51bGxdO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGFuZCBjYWxjdWxhdGUgc2l6ZXMgZm9yIGJhc2ljIChhbmQgc29tZSBzcGVjaWFsKSB0eXBlc1xuICAgICAgICBjb25zdCB0eXBlT2ZWYWx1ZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZU9mVmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpemluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICgwLCBtaXNjXzEuY2FsY3VsYXRlU3RyaW5nU2l6ZSkodmFsdWUpICsgbWlzY18xLkpzb25TaXplLlF1b3RlICogMixcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZU9mVmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFNpemluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIDBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCB2YWx1ZSA9PSB0cnVlID8gbWlzY18xLkpzb25TaXplLlRydWUgOiBtaXNjXzEuSnNvblNpemUuRmFsc2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZU9mVmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAoMCwgbWlzY18xLmNhbGN1bGF0ZU51bWJlclNpemUpKHZhbHVlKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFNpemluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIDBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBJbnZhbGlkIGRhdGVzIHdpbGwgc2VyaWFsaXplIHRvIG51bGxcbiAgICAgICAgICAgICAgICAgICAgaXNOYU4odmFsdWUuZ2V0RGF0ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtaXNjXzEuSnNvblNpemUuTnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtaXNjXzEuSnNvblNpemUuRGF0ZSArIG1pc2NfMS5Kc29uU2l6ZS5RdW90ZSAqIDIsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgb2JqZWN0IGlzIG5vdCBwbGFpbiBhbmQgY2Fubm90IGJlIHNlcmlhbGl6ZWQgcHJvcGVybHksXG4gICAgICAgIC8vIHN0b3AgaGVyZSBhbmQgcmV0dXJuIGZhbHNlIGZvciBzZXJpYWxpemF0aW9uXG4gICAgICAgIGlmICghKDAsIG1pc2NfMS5pc1BsYWluT2JqZWN0KSh2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaXJjdWxhciBvYmplY3QgZGV0ZWN0aW9uIChoYW5kbGluZylcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNhbWUgb2JqZWN0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGlmIChzZWVuT2JqZWN0cy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgbmV3IG9iamVjdCB0byB0aGUgc2VlbiBvYmplY3RzIHNldFxuICAgICAgICAvLyBPbmx5IHRoZSBwbGFpbiBvYmplY3RzIHNob3VsZCBiZSBhZGRlZCAoUHJpbWl0aXZlIHR5cGVzIGFyZSBza2lwcGVkKVxuICAgICAgICBzZWVuT2JqZWN0cy5hZGQodmFsdWUpO1xuICAgICAgICAvLyBDb250aW51ZSBvYmplY3QgZGVjb21wb3NpdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5yZWR1Y2UoKHN1bSwgW2tleSwgbmVzdGVkVmFsdWVdLCBpZHgsIGFycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBwcm9jZXNzIG5leHQgbmVzdGVkIG9iamVjdCBvciBwcmltaXRpdmUgdHlwZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgICAgICAgICAgICAgICAgIGxldCBbdmFsaWQsIHNpemVdID0gZ2V0SnNvblNlcmlhbGl6YWJsZUluZm8obmVzdGVkVmFsdWUsIHNraXBTaXppbmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04gdmFsaWRhdGlvbiBkaWQgbm90IHBhc3MuIFZhbGlkYXRpb24gcHJvY2VzcyBzdG9wcGVkLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENpcmN1bGFyIG9iamVjdCBkZXRlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBhIGNoaWxkIG5vZGUgaXMgdmlzaXRlZCBhbmQgcHJvY2Vzc2VkIHJlbW92ZSBpdCBmcm9tIHRoZSBzZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlcyB3aXRoIHRoZSBzYW1lIGFkamFjZW50IG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgIHNlZW5PYmplY3RzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBPYmplY3RzIHdpbGwgaGF2ZSBiZSBzZXJpYWxpemVkIHdpdGggXCJrZXlcIjogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlZm9yZSB3ZSBpbmNsdWRlIHRoZSBrZXkgaW4gdGhlIGNhbGN1bGF0aW9uIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5U2l6ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDoga2V5Lmxlbmd0aCArIG1pc2NfMS5Kc29uU2l6ZS5Db21tYSArIG1pc2NfMS5Kc29uU2l6ZS5Db2xvbiAqIDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IGlkeCA8IGFyci5sZW5ndGggLSAxID8gbWlzY18xLkpzb25TaXplLkNvbW1hIDogMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIGtleVNpemUgKyBzaXplICsgc2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0cyBhdCAyIGJlY2F1c2UgdGhlIHNlcmlhbGl6ZWQgSlNPTiBzdHJpbmcgZGF0YSAocGxhaW4gdGV4dClcbiAgICAgICAgICAgICAgICAvLyB3aWxsIG1pbmltYWxseSBjb250YWluIHt9L1tdXG4gICAgICAgICAgICAgICAgc2tpcFNpemluZyA/IDAgOiBtaXNjXzEuSnNvblNpemUuV3JhcHBlciAqIDIpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdldEpzb25TZXJpYWxpemFibGVJbmZvKGpzT2JqZWN0LCBza2lwU2l6aW5nUHJvY2Vzcyk7XG59XG5leHBvcnRzLnZhbGlkYXRlSnNvbkFuZEdldFNpemUgPSB2YWxpZGF0ZUpzb25BbmRHZXRTaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZ2xvYmFsTG9nZ2VyID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ21ldGFtYXNrJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBsb2dnZXIgdmlhIHRoZSBgZGVidWdgIGxpYnJhcnkgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkXG4gKiB1c2luZyB0aGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIEJ5IGRlZmF1bHQsIHN1Y2ggbWVzc2FnZXMgd2lsbCBiZVxuICogc3VwcHJlc3NlZCwgYnV0IHlvdSBjYW4gcmV2ZWFsIHRoZW0gYnkgc2V0dGluZyB0aGUgYERFQlVHYCBlbnZpcm9ubWVudFxuICogdmFyaWFibGUgdG8gYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzIHRoYXRcbiAqIGFyZSBhbHNvIHVzaW5nIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZWlyIGxvZ2dlcnMuXG4gKlxuICogQHBhcmFtIHByb2plY3ROYW1lIC0gVGhlIG5hbWUgb2YgeW91ciBwcm9qZWN0LiBUaGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZlxuICogeW91ciBOUE0gcGFja2FnZSBpZiB5b3UncmUgZGV2ZWxvcGluZyBvbmUuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgZGVidWdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9qZWN0TG9nZ2VyKHByb2plY3ROYW1lKSB7XG4gICAgcmV0dXJuIGdsb2JhbExvZ2dlci5leHRlbmQocHJvamVjdE5hbWUpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gY3JlYXRlUHJvamVjdExvZ2dlcjtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aGljaCBpcyBkZXJpdmVkIGZyb20gdGhlIGxvZ2dlciBmb3JcbiAqIHRoZSB3aG9sZSBwcm9qZWN0IHdob3NlIGxvZyBtZXNzYWdlcyB3aWxsIGJlIHRhZ2dlZCB1c2luZyB0aGUgbmFtZSBvZiB5b3VyXG4gKiBtb2R1bGUuIEJ5IGRlZmF1bHQsIHN1Y2ggbWVzc2FnZXMgd2lsbCBiZSBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbVxuICogYnkgc2V0dGluZyB0aGUgYERFQlVHYCBlbnZpcm9ubWVudCB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT46PG1vZHVsZU5hbWU+YC4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gdGhlIHByb2plY3QsXG4gKiBvciBgbWV0YW1hc2s6KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIGFsbCBNZXRhTWFzayBwcm9qZWN0cy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdExvZ2dlciAtIFRoZSBsb2dnZXIgY3JlYXRlZCB2aWEge0BsaW5rIGNyZWF0ZVByb2plY3RMb2dnZXJ9LlxuICogQHBhcmFtIG1vZHVsZU5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIG1vZHVsZS4gWW91IGNvdWxkIHVzZSB0aGUgbmFtZSBvZiB0aGVcbiAqIGZpbGUgd2hlcmUgeW91J3JlIHVzaW5nIHRoaXMgbG9nZ2VyIG9yIHNvbWUgb3RoZXIgbmFtZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vZHVsZUxvZ2dlcihwcm9qZWN0TG9nZ2VyLCBtb2R1bGVOYW1lKSB7XG4gICAgcmV0dXJuIHByb2plY3RMb2dnZXIuZXh0ZW5kKG1vZHVsZU5hbWUpO1xufVxuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBjcmVhdGVNb2R1bGVMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy9cbi8vIFR5cGVzXG4vL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxjdWxhdGVOdW1iZXJTaXplID0gZXhwb3J0cy5jYWxjdWxhdGVTdHJpbmdTaXplID0gZXhwb3J0cy5pc0FTQ0lJID0gZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSBleHBvcnRzLkpzb25TaXplID0gZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGV4cG9ydHMuaXNPYmplY3QgPSBleHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSB2b2lkIDA7XG4vL1xuLy8gVHlwZSBHdWFyZHNcbi8vXG4vKipcbiAqIEEge0BsaW5rIE5vbkVtcHR5QXJyYXl9IHR5cGUgZ3VhcmQuXG4gKlxuICogQHRlbXBsYXRlIEVsZW1lbnQgLSBUaGUgbm9uLWVtcHR5IGFycmF5IG1lbWJlciB0eXBlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBub24tZW1wdHkgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSBpc05vbkVtcHR5QXJyYXk7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIFwibnVsbGlzaG5lc3NcIi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciB7QGxpbmsgUnVudGltZU9iamVjdH0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIHZhbHVlIGhhcyBhIHJ1bnRpbWUgdHlwZSBvZiBgb2JqZWN0YCBhbmQgaXNcbiAqIG5laXRoZXIgYG51bGxgIG5vciBhbiBgQXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vXG4vLyBPdGhlciB1dGlsaXR5IGZ1bmN0aW9uc1xuLy9cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciBlbnN1cmluZyBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIG9iamVjdFRvQ2hlY2sgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgcHJvcGVydHkgbmFtZSB0byBjaGVjayBmb3IuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkXG4gKiBuYW1lLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQgaXMgZW51bWVyYWJsZSBvciBub3QuXG4gKi9cbmNvbnN0IGhhc1Byb3BlcnR5ID0gKG9iamVjdFRvQ2hlY2ssIG5hbWUpID0+IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdFRvQ2hlY2ssIG5hbWUpO1xuZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGhhc1Byb3BlcnR5O1xuLyoqXG4gKiBQcmVkZWZpbmVkIHNpemVzIChpbiBCeXRlcykgb2Ygc3BlY2lmaWMgcGFydHMgb2YgSlNPTiBzdHJ1Y3R1cmUuXG4gKi9cbnZhciBKc29uU2l6ZTtcbihmdW5jdGlvbiAoSnNvblNpemUpIHtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIk51bGxcIl0gPSA0XSA9IFwiTnVsbFwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29tbWFcIl0gPSAxXSA9IFwiQ29tbWFcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIldyYXBwZXJcIl0gPSAxXSA9IFwiV3JhcHBlclwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiVHJ1ZVwiXSA9IDRdID0gXCJUcnVlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJGYWxzZVwiXSA9IDVdID0gXCJGYWxzZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiUXVvdGVcIl0gPSAxXSA9IFwiUXVvdGVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkNvbG9uXCJdID0gMV0gPSBcIkNvbG9uXCI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkRhdGVcIl0gPSAyNF0gPSBcIkRhdGVcIjtcbn0pKEpzb25TaXplID0gZXhwb3J0cy5Kc29uU2l6ZSB8fCAoZXhwb3J0cy5Kc29uU2l6ZSA9IHt9KSk7XG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB3aXRoIHBhdHRlcm4gbWF0Y2hpbmcgZm9yIChzcGVjaWFsKSBlc2NhcGVkIGNoYXJhY3RlcnMuXG4gKi9cbmV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gL1wifFxcXFx8XFxufFxccnxcXHQvZ3U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBwbGFpbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRydWUgaWYgYW4gb2JqZWN0IGlzIHRoZSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCxcbiAqIGZhbHNlIGlmIHRoZSBvYmplY3QgaXMgbm90IHBsYWluIChlLmcuIGZ1bmN0aW9uKS5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHByb3RvID0gdmFsdWU7XG4gICAgICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbi8qKlxuICogQ2hlY2sgaWYgY2hhcmFjdGVyIGlzIEFTQ0lJLlxuICpcbiAqIEBwYXJhbSBjaGFyYWN0ZXIgLSBDaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGEgY2hhcmFjdGVyIGNvZGUgaXMgQVNDSUksIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gaXNBU0NJSShjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMTI3O1xufVxuZXhwb3J0cy5pc0FTQ0lJID0gaXNBU0NJSTtcbi8qKlxuICogQ2FsY3VsYXRlIHN0cmluZyBzaXplLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFN0cmluZyB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIHN0cmluZyB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3RyaW5nU2l6ZSh2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzaXplID0gdmFsdWUuc3BsaXQoJycpLnJlZHVjZSgodG90YWwsIGNoYXJhY3RlcikgPT4ge1xuICAgICAgICBpZiAoaXNBU0NJSShjaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG90YWwgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbCArIDI7XG4gICAgfSwgMCk7XG4gICAgLy8gQWxzbyBkZXRlY3QgY2hhcmFjdGVycyB0aGF0IG5lZWQgYmFja3NsYXNoIGVzY2FwZVxuICAgIHJldHVybiBzaXplICsgKChfYSA9IHZhbHVlLm1hdGNoKGV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGNhbGN1bGF0ZVN0cmluZ1NpemU7XG4vKipcbiAqIENhbGN1bGF0ZSBzaXplIG9mIGEgbnVtYmVyIG9mdGVyIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBudW1iZXIgaW4gSlNPTi5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyU2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGNhbGN1bGF0ZU51bWJlclNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXNjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oZXhUb0JpZ0ludCA9IGV4cG9ydHMuaGV4VG9OdW1iZXIgPSBleHBvcnRzLmJpZ0ludFRvSGV4ID0gZXhwb3J0cy5udW1iZXJUb0hleCA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgbnVtYmVyIGlzIGFcbiAqIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKlxuICogVG8gY29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogbnVtYmVyVG9IZXgoMCk7IC8vICcweDAnXG4gKiBudW1iZXJUb0hleCgxKTsgLy8gJzB4MSdcbiAqIG51bWJlclRvSGV4KDE2KTsgLy8gJzB4MTAnXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBudW1iZXIgaXMgbm90IGEgbm9uLW5lZ2F0aXZlIHNhZmUgaW50ZWdlci5cbiAqL1xuY29uc3QgbnVtYmVyVG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnVmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpLCAnVmFsdWUgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJpZ0ludFRvSGV4YCBpbnN0ZWFkLicpO1xuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKHZhbHVlLnRvU3RyaW5nKDE2KSk7XG59O1xuZXhwb3J0cy5udW1iZXJUb0hleCA9IG51bWJlclRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgYGJpZ2ludGBcbiAqIGlzIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuXG4gKlxuICogVG8gY29udmVydCBhIG51bWJlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2Uge0BsaW5rIG51bWJlclRvSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogYmlnSW50VG9IZXgoMG4pOyAvLyAnMHgwJ1xuICogYmlnSW50VG9IZXgoMW4pOyAvLyAnMHgxJ1xuICogYmlnSW50VG9IZXgoMTZuKTsgLy8gJzB4MTAnXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZywgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqIEB0aHJvd3MgSWYgdGhlIGBiaWdpbnRgIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICovXG5jb25zdCBiaWdJbnRUb0hleCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGJpZ2ludC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMuYmlnSW50VG9IZXggPSBiaWdJbnRUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIG51bWJlci4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBzdHJpbmcgaXMgYVxuICogdmFsaWQgaGV4IHN0cmluZywgYW5kIHRoYXQgdGhlIHJlc3VsdGluZyBudW1iZXIgaXMgYSBzYWZlIGludGVnZXIuIEJvdGhcbiAqIFwiMHhcIi1wcmVmaXhlZCBhbmQgdW5wcmVmaXhlZCBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBiaWdpbnRgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGhleFRvQmlnSW50fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaGV4VG9OdW1iZXIoJzB4MCcpOyAvLyAwXG4gKiBoZXhUb051bWJlcignMHgxJyk7IC8vIDFcbiAqIGhleFRvTnVtYmVyKCcweDEwJyk7IC8vIDE2XG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcsIG9yIGlmIHRoZSByZXN1bHRpbmdcbiAqIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IGhleFRvTnVtYmVyID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gYHBhcnNlSW50YCBhY2NlcHRzIHZhbHVlcyB3aXRob3V0IHRoZSBcIjB4XCItcHJlZml4LCB3aGVyZWFzIGBOdW1iZXJgIGRvZXNcbiAgICAvLyBub3QuIFVzaW5nIHRoaXMgaXMgc2xpZ2h0bHkgZmFzdGVyIHRoYW4gYE51bWJlcihhZGQweCh2YWx1ZSkpYC5cbiAgICBjb25zdCBudW1iZXJWYWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyVmFsdWUpLCAnVmFsdWUgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGhleFRvQmlnSW50YCBpbnN0ZWFkLicpO1xuICAgIHJldHVybiBudW1iZXJWYWx1ZTtcbn07XG5leHBvcnRzLmhleFRvTnVtYmVyID0gaGV4VG9OdW1iZXI7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YC4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBzdHJpbmcgaXNcbiAqIGEgdmFsaWQgaGV4IHN0cmluZy4gQm90aCBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIgaW5zdGVhZCwgdXNlIHtAbGluayBoZXhUb051bWJlcn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvQmlnSW50KCcweDAnKTsgLy8gMG5cbiAqIGhleFRvQmlnSW50KCcweDEnKTsgLy8gMW5cbiAqIGhleFRvQmlnSW50KCcweDEwJyk7IC8vIDE2blxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YC5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuY29uc3QgaGV4VG9CaWdJbnQgPSAodmFsdWUpID0+IHtcbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBUaGUgYEJpZ0ludGAgY29uc3RydWN0b3IgcmVxdWlyZXMgdGhlIFwiMHhcIi1wcmVmaXggdG8gcGFyc2UgYSBoZXggc3RyaW5nLlxuICAgIHJldHVybiBCaWdJbnQoKDAsIGhleF8xLmFkZDB4KSh2YWx1ZSkpO1xufTtcbmV4cG9ydHMuaGV4VG9CaWdJbnQgPSBoZXhUb0JpZ0ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wYXF1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGltZVNpbmNlID0gZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGV4cG9ydHMuRHVyYXRpb24gPSB2b2lkIDA7XG4vKipcbiAqIENvbW1vbiBkdXJhdGlvbiBjb25zdGFudHMsIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xudmFyIER1cmF0aW9uO1xuKGZ1bmN0aW9uIChEdXJhdGlvbikge1xuICAgIC8qKlxuICAgICAqIEEgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaWxsaXNlY29uZFwiXSA9IDFdID0gXCJNaWxsaXNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgc2Vjb25kLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJTZWNvbmRcIl0gPSAxMDAwXSA9IFwiU2Vjb25kXCI7XG4gICAgLyoqXG4gICAgICogQSBtaW51dGUsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIk1pbnV0ZVwiXSA9IDYwMDAwXSA9IFwiTWludXRlXCI7XG4gICAgLyoqXG4gICAgICogQW4gaG91ciwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiSG91clwiXSA9IDM2MDAwMDBdID0gXCJIb3VyXCI7XG4gICAgLyoqXG4gICAgICogQSBkYXksIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkRheVwiXSA9IDg2NDAwMDAwXSA9IFwiRGF5XCI7XG4gICAgLyoqXG4gICAgICogQSB3ZWVrLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJXZWVrXCJdID0gNjA0ODAwMDAwXSA9IFwiV2Vla1wiO1xuICAgIC8qKlxuICAgICAqIEEgeWVhciwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiWWVhclwiXSA9IDMxNTM2MDAwMDAwXSA9IFwiWWVhclwiO1xufSkoRHVyYXRpb24gPSBleHBvcnRzLkR1cmF0aW9uIHx8IChleHBvcnRzLkR1cmF0aW9uID0ge30pKTtcbmNvbnN0IGlzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlcikgPT4gTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpICYmIG51bWJlciA+PSAwO1xuY29uc3QgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIgPSAobnVtYmVyLCBuYW1lKSA9PiB7XG4gICAgaWYgKCFpc05vbk5lZ2F0aXZlSW50ZWdlcihudW1iZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLiBSZWNlaXZlZDogXCIke251bWJlcn1cIi5gKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBtaWxsaXNlY29uZCB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB1bml0cyBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqIEBwYXJhbSBkdXJhdGlvbiAtIFRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gKiBAcmV0dXJucyBUaGUgY291bnQgbXVsdGlwbGllZCBieSB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxuICovXG5mdW5jdGlvbiBpbk1pbGxpc2Vjb25kcyhjb3VudCwgZHVyYXRpb24pIHtcbiAgICBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlcihjb3VudCwgJ2NvdW50Jyk7XG4gICAgcmV0dXJuIGNvdW50ICogZHVyYXRpb247XG59XG5leHBvcnRzLmluTWlsbGlzZWNvbmRzID0gaW5NaWxsaXNlY29uZHM7XG4vKipcbiAqIEdldHMgdGhlIG1pbGxpc2Vjb25kcyBzaW5jZSBhIHBhcnRpY3VsYXIgVW5peCBlcG9jaCB0aW1lc3RhbXAuXG4gKlxuICogQHBhcmFtIHRpbWVzdGFtcCAtIEEgVW5peCBtaWxsaXNlY29uZCB0aW1lc3RhbXAuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICovXG5mdW5jdGlvbiB0aW1lU2luY2UodGltZXN0YW1wKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIodGltZXN0YW1wLCAndGltZXN0YW1wJyk7XG4gICAgcmV0dXJuIERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG59XG5leHBvcnRzLnRpbWVTaW5jZSA9IHRpbWVTaW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNhdGlzZmllc1ZlcnNpb25SYW5nZSA9IGV4cG9ydHMuZ3RSYW5nZSA9IGV4cG9ydHMuZ3RWZXJzaW9uID0gZXhwb3J0cy5hc3NlcnRJc1NlbVZlclJhbmdlID0gZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBleHBvcnRzLmlzVmFsaWRTZW1WZXJSYW5nZSA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclZlcnNpb24gPSBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCA9IGV4cG9ydHMuVmVyc2lvblN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHNlbXZlcl8xID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbi8qKlxuICogQSBzdHJ1Y3QgZm9yIHZhbGlkYXRpbmcgYSB2ZXJzaW9uIHN0cmluZy5cbiAqL1xuZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZCkodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgU2VtVmVyIHZlcnNpb24sIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWZpbmUpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgJ1ZlcnNpb24gcmFuZ2UnLCAodmFsdWUpID0+IHtcbiAgICBpZiAoKDAsIHNlbXZlcl8xLnZhbGlkUmFuZ2UpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciByYW5nZSwgZ290IFwiJHt2YWx1ZX1cImA7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCB2ZXJzaW9uLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb24sIGV4cG9ydHMuVmVyc2lvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzVmFsaWRTZW1WZXJWZXJzaW9uID0gaXNWYWxpZFNlbVZlclZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gcmFuZ2UgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIEEgcG90ZW50aWFsIHZlcnNpb24gcmFuZ2UuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gcmFuZ2UgaXMgdmFsaWQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNlbVZlclJhbmdlKHZlcnNpb25SYW5nZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmVyc2lvblJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzVmFsaWRTZW1WZXJSYW5nZSA9IGlzVmFsaWRTZW1WZXJSYW5nZTtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBjb25jcmV0ZSBTZW1WZXIgdmVyc2lvbi5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEEgcG90ZW50aWFsIFNlbVZlciBjb25jcmV0ZSB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1NlbVZlclZlcnNpb24odmVyc2lvbikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZlcnNpb24sIGV4cG9ydHMuVmVyc2lvblN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGFzc2VydElzU2VtVmVyVmVyc2lvbjtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBTZW1WZXIgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHJhbmdlIC0gQSBwb3RlbnRpYWwgU2VtVmVyIHJhbmdlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1NlbVZlclJhbmdlKHJhbmdlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkocmFuZ2UsIGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0KTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJSYW5nZSA9IGFzc2VydElzU2VtVmVyUmFuZ2U7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHZlcnNpb24xIC0gVGhlIGxlZnQtaGFuZCB2ZXJzaW9uLlxuICogQHBhcmFtIHZlcnNpb24yIC0gVGhlIHJpZ2h0LWhhbmQgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB2ZXJzaW9uMSA+IHZlcnNpb24yYC5cbiAqL1xuZnVuY3Rpb24gZ3RWZXJzaW9uKHZlcnNpb24xLCB2ZXJzaW9uMikge1xuICAgIHJldHVybiAoMCwgc2VtdmVyXzEuZ3QpKHZlcnNpb24xLCB2ZXJzaW9uMik7XG59XG5leHBvcnRzLmd0VmVyc2lvbiA9IGd0VmVyc2lvbjtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHBvc3NpYmlsaXRpZXMgaW4gYSByYW5nZS5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEEgU2VtdlZlciB2ZXJzaW9uLlxuICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyBgdmVyc2lvbiA+IHJhbmdlYC5cbiAqL1xuZnVuY3Rpb24gZ3RSYW5nZSh2ZXJzaW9uLCByYW5nZSkge1xuICAgIHJldHVybiAoMCwgc2VtdmVyXzEuZ3RyKSh2ZXJzaW9uLCByYW5nZSk7XG59XG5leHBvcnRzLmd0UmFuZ2UgPSBndFJhbmdlO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBzYXRpc2ZpZXMgYSBTZW1WZXIgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgU2VtVmVyIHZlcnNpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0gdmVyc2lvblJhbmdlIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHJhbmdlIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2ZXJzaW9uIHNhdGlzZmllZCB0aGUgdmVyc2lvbiByYW5nZS5cbiAqL1xuZnVuY3Rpb24gc2F0aXNmaWVzVmVyc2lvblJhbmdlKHZlcnNpb24sIHZlcnNpb25SYW5nZSkge1xuICAgIHJldHVybiAoMCwgc2VtdmVyXzEuc2F0aXNmaWVzKSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UsIHtcbiAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnRzLnNhdGlzZmllc1ZlcnNpb25SYW5nZSA9IHNhdGlzZmllc1ZlcnNpb25SYW5nZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5jb25zdCBsb2cgPSBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAnYmxvY2stY2FjaGUnKTtcbi8vIGA8bmlsPmAgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzE2OTI1XG5jb25zdCBlbXB0eVZhbHVlcyA9IFt1bmRlZmluZWQsIG51bGwsICdcXHUwMDNjbmlsXFx1MDAzZSddO1xuLy9cbi8vIENhY2hlIFN0cmF0ZWdpZXNcbi8vXG5jbGFzcyBCbG9ja0NhY2hlU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNhY2hlID0ge307XG4gICAgfVxuICAgIGdldEJsb2NrQ2FjaGVGb3JQYXlsb2FkKF9wYXlsb2FkLCBibG9ja051bWJlckhleCkge1xuICAgICAgICBjb25zdCBibG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChibG9ja051bWJlckhleCwgMTYpO1xuICAgICAgICBsZXQgYmxvY2tDYWNoZSA9IHRoaXMuY2FjaGVbYmxvY2tOdW1iZXJdO1xuICAgICAgICAvLyBjcmVhdGUgbmV3IGNhY2hlIGlmIG5lY2VzYXJ5XG4gICAgICAgIGlmICghYmxvY2tDYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgbmV3Q2FjaGUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVbYmxvY2tOdW1iZXJdID0gbmV3Q2FjaGU7XG4gICAgICAgICAgICBibG9ja0NhY2hlID0gbmV3Q2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJsb2NrQ2FjaGU7XG4gICAgfVxuICAgIGFzeW5jIGdldChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcikge1xuICAgICAgICAvLyBsb29rdXAgYmxvY2sgY2FjaGVcbiAgICAgICAgY29uc3QgYmxvY2tDYWNoZSA9IHRoaXMuZ2V0QmxvY2tDYWNoZUZvclBheWxvYWQocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICAvLyBsb29rdXAgcGF5bG9hZCBpbiBibG9jayBjYWNoZVxuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gY2FjaGVfMS5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQsIHRydWUpO1xuICAgICAgICByZXR1cm4gaWRlbnRpZmllciA/IGJsb2NrQ2FjaGVbaWRlbnRpZmllcl0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFzeW5jIHNldChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgcmVzdWx0KSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiBjYWNoZWQgdGhpcyByZXN1bHRcbiAgICAgICAgY29uc3QgY2FuQ2FjaGVSZXN1bHQgPSB0aGlzLmNhbkNhY2hlUmVzdWx0KHBheWxvYWQsIHJlc3VsdCk7XG4gICAgICAgIGlmICghY2FuQ2FjaGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlIGluIHRoZSBjYWNoZVxuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gY2FjaGVfMS5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQsIHRydWUpO1xuICAgICAgICBpZiAoIWlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIGJsb2NrQ2FjaGVbaWRlbnRpZmllcl0gPSByZXN1bHQ7XG4gICAgfVxuICAgIGNhbkNhY2hlUmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIC8vIGNoZWNrIHJlcXVlc3QgbWV0aG9kXG4gICAgICAgIGlmICghY2FjaGVfMS5jYW5DYWNoZShwYXlsb2FkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGJsb2NrVGFnXG4gICAgICAgIGNvbnN0IGJsb2NrVGFnID0gY2FjaGVfMS5ibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FuIGJlIGNhY2hlZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2FuQ2FjaGVSZXN1bHQocGF5bG9hZCwgcmVzdWx0KSB7XG4gICAgICAgIC8vIG5ldmVyIGNhY2hlIGVtcHR5IHZhbHVlcyAoZS5nLiB1bmRlZmluZWQpXG4gICAgICAgIGlmIChlbXB0eVZhbHVlcy5pbmNsdWRlcyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgdHJhbnNhY3Rpb25zIGhhdmUgYmxvY2sgcmVmZXJlbmNlIGJlZm9yZSBjYWNoaW5nXG4gICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCAmJlxuICAgICAgICAgICAgWydldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLCAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCddLmluY2x1ZGVzKHBheWxvYWQubWV0aG9kKSkge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQgfHxcbiAgICAgICAgICAgICAgICAhcmVzdWx0LmJsb2NrSGFzaCB8fFxuICAgICAgICAgICAgICAgIHJlc3VsdC5ibG9ja0hhc2ggPT09XG4gICAgICAgICAgICAgICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSB0cnVlXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyByZW1vdmVzIGFsbCBibG9jayBjYWNoZXMgd2l0aCBibG9jayBudW1iZXIgbG93ZXIgdGhhbiBgb2xkQmxvY2tIZXhgXG4gICAgY2xlYXJCZWZvcmUob2xkQmxvY2tIZXgpIHtcbiAgICAgICAgY29uc3Qgb2xkQmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQob2xkQmxvY2tIZXgsIDE2KTtcbiAgICAgICAgLy8gY2xlYXIgb2xkIGNhY2hlc1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNhY2hlKVxuICAgICAgICAgICAgLm1hcChOdW1iZXIpXG4gICAgICAgICAgICAuZmlsdGVyKChudW0pID0+IG51bSA8IG9sZEJsb2NrTnVtYmVyKVxuICAgICAgICAgICAgLmZvckVhY2goKG51bSkgPT4gZGVsZXRlIHRoaXMuY2FjaGVbbnVtXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgICBpZiAoIWJsb2NrVHJhY2tlcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlIC0gTm8gUG9sbGluZ0Jsb2NrVHJhY2tlciBzcGVjaWZpZWQnKTtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGNhY2hpbmcgc3RyYXRlZ2llc1xuICAgIGNvbnN0IGJsb2NrQ2FjaGUgPSBuZXcgQmxvY2tDYWNoZVN0cmF0ZWd5KCk7XG4gICAgY29uc3Qgc3RyYXRlZ2llcyA9IHtcbiAgICAgICAgcGVybWE6IGJsb2NrQ2FjaGUsXG4gICAgICAgIGJsb2NrOiBibG9ja0NhY2hlLFxuICAgICAgICBmb3JrOiBibG9ja0NhY2hlLFxuICAgIH07XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgLy8gYWxsb3cgY2FjaCB0byBiZSBza2lwcGVkIGlmIHNvIHNwZWNpZmllZFxuICAgICAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB0eXBlIGFuZCBtYXRjaGluZyBzdHJhdGVneVxuICAgICAgICBjb25zdCB0eXBlID0gY2FjaGVfMS5jYWNoZVR5cGVGb3JQYXlsb2FkKHJlcSk7XG4gICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gc3RyYXRlZ2llc1t0eXBlXTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBzdHJhdGVneSBpbiBwbGFjZSwgcGFzcyBpdCBkb3duIHRoZSBjaGFpbi5cbiAgICAgICAgaWYgKCFzdHJhdGVneSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc3RyYXRlZ3kgY2FuJ3QgY2FjaGUgdGhpcyByZXF1ZXN0LCBpZ25vcmUgaXQuXG4gICAgICAgIGlmICghc3RyYXRlZ3kuY2FuQ2FjaGVSZXF1ZXN0KHJlcSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGJsb2NrIHJlZmVyZW5jZSAobnVtYmVyIG9yIGtleXdvcmQpXG4gICAgICAgIGxldCBibG9ja1RhZyA9IGNhY2hlXzEuYmxvY2tUYWdGb3JQYXlsb2FkKHJlcSk7XG4gICAgICAgIGlmICghYmxvY2tUYWcpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0gJ2xhdGVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgbG9nKCdibG9ja1RhZyA9ICVvLCByZXEgPSAlbycsIGJsb2NrVGFnLCByZXEpO1xuICAgICAgICAvLyBnZXQgZXhhY3QgYmxvY2sgbnVtYmVyXG4gICAgICAgIGxldCByZXF1ZXN0ZWRCbG9ja051bWJlcjtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSAnZWFybGllc3QnKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGp1c3QgZXhpc3RzIGZvciBzeW1tZXRyeSB3aXRoIFwibGF0ZXN0XCJcbiAgICAgICAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gJzB4MDAnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJsb2NrVGFnID09PSAnbGF0ZXN0Jykge1xuICAgICAgICAgICAgLy8gZmV0Y2ggbGF0ZXN0IGJsb2NrIG51bWJlclxuICAgICAgICAgICAgbG9nKCdGZXRjaGluZyBsYXRlc3QgYmxvY2sgbnVtYmVyIHRvIGRldGVybWluZSBjYWNoZSBrZXknKTtcbiAgICAgICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgICAgICAvLyBjbGVhciBhbGwgY2FjaGUgYmVmb3JlIGxhdGVzdCBibG9ja1xuICAgICAgICAgICAgbG9nKCdDbGVhcmluZyB2YWx1ZXMgc3RvcmVkIHVuZGVyIGJsb2NrIG51bWJlcnMgYmVmb3JlICVvJywgbGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgYmxvY2tDYWNoZS5jbGVhckJlZm9yZShsYXRlc3RCbG9ja051bWJlcik7XG4gICAgICAgICAgICByZXF1ZXN0ZWRCbG9ja051bWJlciA9IGxhdGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGhleCBudW1iZXJcbiAgICAgICAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5kIG9uIGEgaGl0LCBjb250aW51ZSBvbiBhIG1pc3NcbiAgICAgICAgY29uc3QgY2FjaGVSZXN1bHQgPSBhd2FpdCBzdHJhdGVneS5nZXQocmVxLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIGlmIChjYWNoZVJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBjYWNoZSBtaXNzXG4gICAgICAgICAgICAvLyB3YWl0IGZvciBvdGhlciBtaWRkbGV3YXJlIHRvIGhhbmRsZSByZXF1ZXN0XG4gICAgICAgICAgICBsb2coJ05vIGNhY2hlIHN0b3JlZCB1bmRlciBibG9jayBudW1iZXIgJW8sIGNhcnJ5aW5nIHJlcXVlc3QgZm9yd2FyZCcsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL2NhbGxiYWNrLXJldHVyblxuICAgICAgICAgICAgYXdhaXQgbmV4dCgpO1xuICAgICAgICAgICAgLy8gYWRkIHJlc3VsdCB0byBjYWNoZVxuICAgICAgICAgICAgLy8gaXQncyBzYWZlIHRvIGNhc3QgcmVzLnJlc3VsdCBhcyBCbG9jaywgZHVlIHRvIHJ1bnRpbWUgdHlwZSBjaGVja3NcbiAgICAgICAgICAgIC8vIHBlcmZvcm1lZCB3aGVuIHN0cmF0ZWd5LnNldCBpcyBjYWxsZWRcbiAgICAgICAgICAgIGxvZygnUG9wdWxhdGluZyBjYWNoZSB3aXRoJywgcmVzKTtcbiAgICAgICAgICAgIGF3YWl0IHN0cmF0ZWd5LnNldChyZXEsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCByZXMucmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZpbGwgaW4gcmVzdWx0IGZyb20gY2FjaGVcbiAgICAgICAgICAgIGxvZygnQ2FjaGUgaGl0LCByZXVzaW5nIGNhY2hlIHJlc3VsdCBzdG9yZWQgdW5kZXIgYmxvY2sgbnVtYmVyICVvJywgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgcmVzLnJlc3VsdCA9IGNhY2hlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1jYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwiYmxvY2tUcmFja2VyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgX3JlcywgbmV4dCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGJsb2NrUmVmSW5kZXggPSBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleChyZXEpO1xuICAgICAgICAvLyBza2lwIGlmIG1ldGhvZCBkb2VzIG5vdCBpbmNsdWRlIGJsb2NrUmVmXG4gICAgICAgIGlmIChibG9ja1JlZkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBub3QgXCJsYXRlc3RcIlxuICAgICAgICBsZXQgYmxvY2tSZWYgPSAoX2EgPSByZXEucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbYmxvY2tSZWZJbmRleF07XG4gICAgICAgIC8vIG9taXR0ZWQgYmxvY2tSZWYgaW1wbGllcyBcImxhdGVzdFwiXG4gICAgICAgIGlmIChibG9ja1JlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibG9ja1JlZiA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9ja1JlZiAhPT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmV3cml0ZSBibG9ja1JlZiB0byBibG9jay10cmFja2VyJ3MgYmxvY2sgbnVtYmVyXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgIGlmIChyZXEucGFyYW1zKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlc1xuICAgICAgICAgICAgcmVxLnBhcmFtc1tibG9ja1JlZkluZGV4XSA9IGxhdGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmxvY2stcmVmLXJld3JpdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrUmVmTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNsb25lXCIpKTtcbmNvbnN0IHBpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGlmeVwiKSk7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuY29uc3QgbG9nID0gbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcihsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ2Jsb2NrLXJlZicpO1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQmxvY2tSZWZNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwicHJvdmlkZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Jsb2NrUmVmTWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcImJsb2NrVHJhY2tlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBibG9ja1JlZkluZGV4ID0gY2FjaGVfMS5ibG9ja1RhZ1BhcmFtSW5kZXgocmVxKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJsb2NrUmVmID0gKF9iID0gKF9hID0gcmVxLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Jsb2NrUmVmSW5kZXhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnbGF0ZXN0JztcbiAgICAgICAgLy8gc2tpcCBpZiBub3QgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgIT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICBsb2coJ2Jsb2NrUmVmIGlzIG5vdCBcImxhdGVzdFwiLCBjYXJyeWluZyByZXF1ZXN0IGZvcndhcmQnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9va3VwIGxhdGVzdCBibG9ja1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICBsb2coYGJsb2NrUmVmIGlzIFwibGF0ZXN0XCIsIHNldHRpbmcgcGFyYW0gJHtibG9ja1JlZkluZGV4fSB0byBsYXRlc3QgYmxvY2sgJHtsYXRlc3RCbG9ja051bWJlcn1gKTtcbiAgICAgICAgLy8gY3JlYXRlIGNoaWxkIHJlcXVlc3Qgd2l0aCBzcGVjaWZpYyBibG9jay1yZWZcbiAgICAgICAgY29uc3QgY2hpbGRSZXF1ZXN0ID0gY2xvbmVfMS5kZWZhdWx0KHJlcSk7XG4gICAgICAgIGlmIChjaGlsZFJlcXVlc3QucGFyYW1zKSB7XG4gICAgICAgICAgICBjaGlsZFJlcXVlc3QucGFyYW1zW2Jsb2NrUmVmSW5kZXhdID0gbGF0ZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybSBjaGlsZCByZXF1ZXN0XG4gICAgICAgIGxvZygnUGVyZm9ybWluZyBhbm90aGVyIHJlcXVlc3QgJW8nLCBjaGlsZFJlcXVlc3QpO1xuICAgICAgICBjb25zdCBjaGlsZFJlcyA9IGF3YWl0IHBpZnlfMS5kZWZhdWx0KHByb3ZpZGVyLnNlbmRBc3luYykuY2FsbChwcm92aWRlciwgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgLy8gY29weSBjaGlsZCByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgIHJlcy5yZXN1bHQgPSBjaGlsZFJlcy5yZXN1bHQ7XG4gICAgICAgIHJlcy5lcnJvciA9IGNoaWxkUmVzLmVycm9yO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgbG9nID0gbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcihsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ2Jsb2NrLXRyYWNrZXItaW5zcGVjdG9yJyk7XG5jb25zdCBmdXR1cmVCbG9ja1JlZlJlcXVlc3RzID0gW1xuICAgICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0Jyxcbl07XG4vLyBpbnNwZWN0IGlmIHJlc3BvbnNlIGNvbnRhaW5zIGEgYmxvY2sgcmVmIGhpZ2hlciB0aGFuIG91ciBsYXRlc3QgYmxvY2tcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIH0pIHtcbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZnV0dXJlQmxvY2tSZWZSZXF1ZXN0cy5pbmNsdWRlcyhyZXEubWV0aG9kKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgYXdhaXQgbmV4dCgpO1xuICAgICAgICAvLyBhYm9ydCBpZiBubyByZXN1bHQgb3Igbm8gYmxvY2sgbnVtYmVyXG4gICAgICAgIGlmICghKChfYSA9IHJlcy5yZXN1bHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ibG9ja051bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbG9nKCdyZXMucmVzdWx0LmJsb2NrTnVtYmVyIGV4aXN0cywgcHJvY2VlZGluZy4gcmVzID0gJW8nLCByZXMpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcy5yZXN1bHQuYmxvY2tOdW1iZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBpZiBudW1iZXIgaXMgaGlnaGVyLCBzdWdnZXN0IGJsb2NrLXRyYWNrZXIgY2hlY2sgZm9yIGEgbmV3IGJsb2NrXG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChyZXMucmVzdWx0LmJsb2NrTnVtYmVyLCAxNik7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdDogSWYgZ2V0Q3VycmVudEJsb2NrIHJldHVybnMgbnVsbCwgY3VycmVudEJsb2NrTnVtYmVyIHdpbGwgYmUgTmFOLCB3aGljaCBpcyBmaW5lLlxuICAgICAgICAgICAgY29uc3QgY3VycmVudEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrVHJhY2tlci5nZXRDdXJyZW50QmxvY2soKSwgMTYpO1xuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gY3VycmVudEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgbG9nKCdibG9ja051bWJlciBmcm9tIHJlc3BvbnNlIGlzIGdyZWF0ZXIgdGhhbiBjdXJyZW50IGJsb2NrIG51bWJlciwgcmVmcmVzaGluZyBjdXJyZW50IGJsb2NrIG51bWJlcicpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGJsb2NrVHJhY2tlci5jaGVja0ZvckxhdGVzdEJsb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSA9IGNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay10cmFja2VyLWluc3BlY3Rvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxID0gZXhwb3J0cy5jcmVhdGVGZXRjaE1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93ICovXG5jb25zdCBmZXRjaCA9IGdsb2JhbC5mZXRjaCB8fCByZXF1aXJlKCdub2RlLWZldGNoJyk7XG5jb25zdCBidG9hID0gZ2xvYmFsLmJ0b2EgfHwgcmVxdWlyZSgnYnRvYScpO1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3cgKi9cbmNvbnN0IFJFVFJJQUJMRV9FUlJPUlMgPSBbXG4gICAgLy8gaWdub3JlIHNlcnZlciBvdmVybG9hZCBlcnJvcnNcbiAgICAnR2F0ZXdheSB0aW1lb3V0JyxcbiAgICAnRVRJTUVET1VUJyxcbiAgICAvLyBpZ25vcmUgc2VydmVyIHNlbnQgaHRtbCBlcnJvciBwYWdlc1xuICAgIC8vIG9yIHRydW5jYXRlZCBqc29uIHJlc3BvbnNlc1xuICAgICdmYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgYm9keScsXG4gICAgLy8gaWdub3JlIGVycm9ycyB3aGVyZSBodHRwIHJlcSBmYWlsZWQgdG8gZXN0YWJsaXNoXG4gICAgJ0ZhaWxlZCB0byBmZXRjaCcsXG5dO1xuZnVuY3Rpb24gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlKHsgcnBjVXJsLCBvcmlnaW5IdHRwSGVhZGVyS2V5LCB9KSB7XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIF9uZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZmV0Y2hVcmwsIGZldGNoUGFyYW1zIH0gPSBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEoe1xuICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgcnBjVXJsLFxuICAgICAgICAgICAgb3JpZ2luSHR0cEhlYWRlcktleSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGF0dGVtcHQgcmVxdWVzdCBtdWx0aXBsZSB0aW1lc1xuICAgICAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDU7XG4gICAgICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSAxMDAwO1xuICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IG1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmV0Y2hSZXMgPSBhd2FpdCBmZXRjaChmZXRjaFVybCwgZmV0Y2hQYXJhbXMpO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBodHRwIGVycnJvcnNcbiAgICAgICAgICAgICAgICBjaGVja0Zvckh0dHBFcnJvcnMoZmV0Y2hSZXMpO1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIHJlc3BvbnNlIGJvZHlcbiAgICAgICAgICAgICAgICBjb25zdCByYXdCb2R5ID0gYXdhaXQgZmV0Y2hSZXMudGV4dCgpO1xuICAgICAgICAgICAgICAgIGxldCBmZXRjaEJvZHk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hCb2R5ID0gSlNPTi5wYXJzZShyYXdCb2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGZXRjaE1pZGRsZXdhcmUgLSBmYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgYm9keTogXCIke3Jhd0JvZHl9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcGFyc2VSZXNwb25zZShmZXRjaFJlcywgZmV0Y2hCb2R5KTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgcmVzdWx0IGFuZCBleGl0IHJldHJ5IGxvb3BcbiAgICAgICAgICAgICAgICByZXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JldHJpYWJsZSA9IFJFVFJJQUJMRV9FUlJPUlMuc29tZSgocGhyYXNlKSA9PiBlcnJNc2cuaW5jbHVkZXMocGhyYXNlKSk7XG4gICAgICAgICAgICAgICAgLy8gcmUtdGhyb3cgZXJyb3IgaWYgbm90IHJldHJpYWJsZVxuICAgICAgICAgICAgICAgIGlmICghaXNSZXRyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlbGF5IGJlZm9yZSByZXRyeWluZ1xuICAgICAgICAgICAgYXdhaXQgdGltZW91dChyZXRyeUludGVydmFsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVGZXRjaE1pZGRsZXdhcmUgPSBjcmVhdGVGZXRjaE1pZGRsZXdhcmU7XG5mdW5jdGlvbiBjaGVja0Zvckh0dHBFcnJvcnMoZmV0Y2hSZXMpIHtcbiAgICAvLyBjaGVjayBmb3IgZXJyb3JzXG4gICAgc3dpdGNoIChmZXRjaFJlcy5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSA0MDU6XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90Rm91bmQoKTtcbiAgICAgICAgY2FzZSA0MTg6XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVSYXRlbGltaXRFcnJvcigpO1xuICAgICAgICBjYXNlIDUwMzpcbiAgICAgICAgY2FzZSA1MDQ6XG4gICAgICAgICAgICB0aHJvdyBjcmVhdGVUaW1lb3V0RXJyb3IoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGJvZHkpIHtcbiAgICAvLyBjaGVjayBmb3IgZXJyb3IgY29kZVxuICAgIGlmIChmZXRjaFJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xuICAgICAgICAgICAgbWVzc2FnZTogYE5vbi0yMDAgc3RhdHVzIGNvZGU6ICcke2ZldGNoUmVzLnN0YXR1c30nYCxcbiAgICAgICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBjaGVjayBmb3IgcnBjIGVycm9yXG4gICAgaWYgKGJvZHkuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICAgICAgICAgIGRhdGE6IGJvZHkuZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyByZXR1cm4gc3VjY2Vzc2Z1bCByZXN1bHRcbiAgICByZXR1cm4gYm9keS5yZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEoeyByZXEsIHJwY1VybCwgb3JpZ2luSHR0cEhlYWRlcktleSwgfSkge1xuICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwocnBjVXJsKTtcbiAgICBjb25zdCBmZXRjaFVybCA9IG5vcm1hbGl6ZVVybEZyb21QYXJzZWQocGFyc2VkVXJsKTtcbiAgICAvLyBwcmVwYXJlIHBheWxvYWRcbiAgICAvLyBjb3B5IG9ubHkgY2Fub25pY2FsIGpzb24gcnBjIHByb3BlcnRpZXNcbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICBpZDogcmVxLmlkLFxuICAgICAgICBqc29ucnBjOiByZXEuanNvbnJwYyxcbiAgICAgICAgbWV0aG9kOiByZXEubWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHJlcS5wYXJhbXMsXG4gICAgfTtcbiAgICAvLyBleHRyYWN0ICdvcmlnaW4nIHBhcmFtZXRlciBmcm9tIHJlcXVlc3RcbiAgICBjb25zdCBvcmlnaW5Eb21haW4gPSByZXEub3JpZ2luO1xuICAgIC8vIHNlcmlhbGl6ZSByZXF1ZXN0IGJvZHlcbiAgICBjb25zdCBzZXJpYWxpemVkUGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpO1xuICAgIC8vIGNvbmZpZ3VyZSBmZXRjaCBwYXJhbXNcbiAgICBjb25zdCBmZXRjaFBhcmFtcyA9IHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogc2VyaWFsaXplZFBheWxvYWQsXG4gICAgfTtcbiAgICAvLyBlbmNvZGVkIGF1dGggZGV0YWlscyBhcyBoZWFkZXIgKG5vdCBhbGxvd2VkIGluIGZldGNoIHVybClcbiAgICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lICYmIHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgICAgICBjb25zdCBhdXRoU3RyaW5nID0gYCR7cGFyc2VkVXJsLnVzZXJuYW1lfToke3BhcnNlZFVybC5wYXNzd29yZH1gO1xuICAgICAgICBjb25zdCBlbmNvZGVkQXV0aCA9IGJ0b2EoYXV0aFN0cmluZyk7XG4gICAgICAgIGZldGNoUGFyYW1zLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCYXNpYyAke2VuY29kZWRBdXRofWA7XG4gICAgfVxuICAgIC8vIG9wdGlvbmFsOiBhZGQgcmVxdWVzdCBvcmlnaW4gYXMgaGVhZGVyXG4gICAgaWYgKG9yaWdpbkh0dHBIZWFkZXJLZXkgJiYgb3JpZ2luRG9tYWluKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmhlYWRlcnNbb3JpZ2luSHR0cEhlYWRlcktleV0gPSBvcmlnaW5Eb21haW47XG4gICAgfVxuICAgIHJldHVybiB7IGZldGNoVXJsLCBmZXRjaFBhcmFtcyB9O1xufVxuZXhwb3J0cy5jcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEgPSBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXE7XG5mdW5jdGlvbiBub3JtYWxpemVVcmxGcm9tUGFyc2VkKHBhcnNlZFVybCkge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICByZXN1bHQgKz0gcGFyc2VkVXJsLnByb3RvY29sO1xuICAgIHJlc3VsdCArPSBgLy8ke3BhcnNlZFVybC5ob3N0bmFtZX1gO1xuICAgIGlmIChwYXJzZWRVcmwucG9ydCkge1xuICAgICAgICByZXN1bHQgKz0gYDoke3BhcnNlZFVybC5wb3J0fWA7XG4gICAgfVxuICAgIHJlc3VsdCArPSBgJHtwYXJzZWRVcmwucGF0aG5hbWV9YDtcbiAgICByZXN1bHQgKz0gYCR7cGFyc2VkVXJsLnNlYXJjaH1gO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVSYXRlbGltaXRFcnJvcigpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHsgbWVzc2FnZTogYFJlcXVlc3QgaXMgYmVpbmcgcmF0ZSBsaW1pdGVkLmAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUaW1lb3V0RXJyb3IoKSB7XG4gICAgbGV0IG1zZyA9IGBHYXRld2F5IHRpbWVvdXQuIFRoZSByZXF1ZXN0IHRvb2sgdG9vIGxvbmcgdG8gcHJvY2Vzcy4gYDtcbiAgICBtc2cgKz0gYFRoaXMgY2FuIGhhcHBlbiB3aGVuIHF1ZXJ5aW5nIGxvZ3Mgb3ZlciB0b28gd2lkZSBhIGJsb2NrIHJhbmdlLmA7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2U6IG1zZyB9KTtcbn1cbmZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stY2FjaGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLXJlZi1yZXdyaXRlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay1yZWZcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLXRyYWNrZXItaW5zcGVjdG9yXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mZXRjaFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW5mbGlnaHQtY2FjaGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb3ZpZGVyQXNNaWRkbGV3YXJlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm92aWRlckZyb21FbmdpbmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Byb3ZpZGVyRnJvbU1pZGRsZXdhcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JldHJ5T25FbXB0eVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2FsbGV0XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNsb25lXCIpKTtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5jb25zdCBsb2cgPSBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAnaW5mbGlnaHQtY2FjaGUnKTtcbmZ1bmN0aW9uIGNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlKCkge1xuICAgIGNvbnN0IGluZmxpZ2h0UmVxdWVzdHMgPSB7fTtcbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICAvLyBhbGxvdyBjYWNoIHRvIGJlIHNraXBwZWQgaWYgc28gc3BlY2lmaWVkXG4gICAgICAgIGlmIChyZXEuc2tpcENhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBjYWNoZUlkLCBpZiBjYWNoZWFibGVcbiAgICAgICAgY29uc3QgY2FjaGVJZCA9IGNhY2hlXzEuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZChyZXEpO1xuICAgICAgICAvLyBpZiBub3QgY2FjaGVhYmxlLCBza2lwXG4gICAgICAgIGlmICghY2FjaGVJZCkge1xuICAgICAgICAgICAgbG9nKCdSZXF1ZXN0IGlzIG5vdCBjYWNoZWFibGUsIHByb2NlZWRpbmcuIHJlcSA9ICVvJywgcmVxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1hdGNoaW5nIHJlcXVlc3RzXG4gICAgICAgIGxldCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMgPSBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdO1xuICAgICAgICAvLyBpZiBmb3VuZCwgd2FpdCBmb3IgdGhlIGFjdGl2ZSByZXF1ZXN0IHRvIGJlIGhhbmRsZWRcbiAgICAgICAgaWYgKGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgICAgICAgICAgLy8gc2V0dXAgdGhlIHJlc3BvbnNlIGxpc3RlbmVyIGFuZCB3YWl0IGZvciBpdCB0byBiZSBjYWxsZWRcbiAgICAgICAgICAgIC8vIGl0IHdpbGwgaGFuZGxlIGNvcHlpbmcgdGhlIHJlc3VsdCBhbmQgcmVxdWVzdCBmaWVsZHNcbiAgICAgICAgICAgIGxvZygnUnVubmluZyAlaSBoYW5kbGVyKHMpIGZvciByZXF1ZXN0ICVvJywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmxlbmd0aCwgcmVxKTtcbiAgICAgICAgICAgIGF3YWl0IGNyZWF0ZUFjdGl2ZVJlcXVlc3RIYW5kbGVyKHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0dXAgcmVzcG9uc2UgaGFuZGxlciBhcnJheSBmb3Igc3Vic2VxdWVudCByZXF1ZXN0c1xuICAgICAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMgPSBbXTtcbiAgICAgICAgaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXSA9IGFjdGl2ZVJlcXVlc3RIYW5kbGVycztcbiAgICAgICAgLy8gYWxsb3cgcmVxdWVzdCB0byBiZSBoYW5kbGVkIG5vcm1hbGx5XG4gICAgICAgIGxvZygnQ2Fycnlpbmcgb3JpZ2luYWwgcmVxdWVzdCBmb3J3YXJkICVvJywgcmVxKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgLy8gY2xlYXIgaW5mbGlnaHQgcmVxdWVzdHNcbiAgICAgICAgZGVsZXRlIGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF07XG4gICAgICAgIC8vIHNjaGVkdWxlIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyB0byBiZSBoYW5kbGVkXG4gICAgICAgIGxvZygnUnVubmluZyAlaSBjb2xsZWN0ZWQgaGFuZGxlcihzKSBmb3IgcmVxdWVzdCAlbycsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5sZW5ndGgsIHJlcSk7XG4gICAgICAgIGhhbmRsZUFjdGl2ZVJlcXVlc3QocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpO1xuICAgICAgICAvLyBjb21wbGV0ZVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdGl2ZVJlcXVlc3RIYW5kbGVyKHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZSwgcHJvbWlzZSB9ID0gZGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5wdXNoKChoYW5kbGVkUmVzKSA9PiB7XG4gICAgICAgICAgICAvLyBhcHBlbmQgYSBjb3B5IG9mIHRoZSByZXN1bHQgYW5kIGVycm9yIHRvIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgcmVzLnJlc3VsdCA9IGNsb25lXzEuZGVmYXVsdChoYW5kbGVkUmVzLnJlc3VsdCk7XG4gICAgICAgICAgICByZXMuZXJyb3IgPSBjbG9uZV8xLmRlZmF1bHQoaGFuZGxlZFJlcy5lcnJvcik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgICAgICAvLyB1c2Ugc2V0VGltZW91dCBzbyB3ZSBjYW4gcmVzb2x2ZSBvdXIgb3JpZ2luYWwgcmVxdWVzdCBmaXJzdFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoIGVycm9yIHNvIGFsbCByZXF1ZXN0cyBhcmUgaGFuZGxlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlID0gY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmU7XG5mdW5jdGlvbiBkZWZlcnJlZFByb21pc2UoKSB7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcmVzb2x2ZSwgcHJvbWlzZSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mbGlnaHQtY2FjaGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGV4cG9ydHMucHJvamVjdExvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTW9kdWxlTG9nZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcjsgfSB9KTtcbmV4cG9ydHMucHJvamVjdExvZ2dlciA9IHV0aWxzXzEuY3JlYXRlUHJvamVjdExvZ2dlcignZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmctdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlID0gZXhwb3J0cy5wcm92aWRlckFzTWlkZGxld2FyZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHByb3ZpZGVyQXNNaWRkbGV3YXJlKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIChyZXEsIHJlcywgX25leHQsIGVuZCkgPT4ge1xuICAgICAgICAvLyBzZW5kIHJlcXVlc3QgdG8gcHJvdmlkZXJcbiAgICAgICAgcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSwgKGVyciwgcHJvdmlkZXJSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGZvcndhcmQgYW55IGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3B5IHByb3ZpZGVyIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBwcm92aWRlclJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLnByb3ZpZGVyQXNNaWRkbGV3YXJlID0gcHJvdmlkZXJBc01pZGRsZXdhcmU7XG5mdW5jdGlvbiBldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikge1xuICAgIHJldHVybiAocmVxLCByZXMsIF9uZXh0LCBlbmQpID0+IHtcbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0IHRvIHByb3ZpZGVyXG4gICAgICAgIHByb3ZpZGVyLnNlbmQocmVxLCAoZXJyLCBwcm92aWRlclJlcykgPT4ge1xuICAgICAgICAgICAgLy8gZm9yd2FyZCBhbnkgZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3B5IHByb3ZpZGVyIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBwcm92aWRlclJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLmV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlID0gZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckFzTWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvdmlkZXJGcm9tRW5naW5lID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuZnVuY3Rpb24gcHJvdmlkZXJGcm9tRW5naW5lKGVuZ2luZSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQoKTtcbiAgICAvLyBoYW5kbGUgYm90aCBycGMgc2VuZCBtZXRob2RzXG4gICAgcHJvdmlkZXIuc2VuZEFzeW5jID0gKHJlcSwgY2IpID0+IHtcbiAgICAgICAgZW5naW5lLmhhbmRsZShyZXEsIGNiKTtcbiAgICB9O1xuICAgIHByb3ZpZGVyLnNlbmQgPSAocmVxLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBjYWxsYmFjayB0byBcInNlbmRcIiBtZXRob2QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZW5naW5lLmhhbmRsZShyZXEsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vIGZvcndhcmQgbm90aWZpY2F0aW9uc1xuICAgIGlmIChlbmdpbmUub24pIHtcbiAgICAgICAgZW5naW5lLm9uKCdub3RpZmljYXRpb24nLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCgnZGF0YScsIG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xufVxuZXhwb3J0cy5wcm92aWRlckZyb21FbmdpbmUgPSBwcm92aWRlckZyb21FbmdpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckZyb21FbmdpbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb3ZpZGVyRnJvbU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBwcm92aWRlckZyb21FbmdpbmVfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyRnJvbUVuZ2luZVwiKTtcbmZ1bmN0aW9uIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUobWlkZGxld2FyZSkge1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBqc29uX3JwY19lbmdpbmVfMS5Kc29uUnBjRW5naW5lKCk7XG4gICAgZW5naW5lLnB1c2gobWlkZGxld2FyZSk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBwcm92aWRlckZyb21FbmdpbmVfMS5wcm92aWRlckZyb21FbmdpbmUoZW5naW5lKTtcbiAgICByZXR1cm4gcHJvdmlkZXI7XG59XG5leHBvcnRzLnByb3ZpZGVyRnJvbU1pZGRsZXdhcmUgPSBwcm92aWRlckZyb21NaWRkbGV3YXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXJGcm9tTWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNsb25lXCIpKTtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IHBpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwicGlmeVwiKSk7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuLy9cbi8vIFJldHJ5T25FbXB0eU1pZGRsZXdhcmUgd2lsbCByZXRyeSBhbnkgcmVxdWVzdCB3aXRoIGFuIGVtcHR5IHJlc3BvbnNlIHRoYXQgaGFzXG4vLyBhIG51bWJlcmVkIGJsb2NrIHJlZmVyZW5jZSBhdCBvciBsb3dlciB0aGFuIHRoZSBibG9ja1RyYWNrZXIncyBsYXRlc3QgYmxvY2suXG4vLyBJdHMgdXNlZnVsIGZvciBkZWFsaW5nIHdpdGggbG9hZC1iYWxhbmNlZCBldGhlcmV1bSBKU09OIFJQQ1xuLy8gbm9kZXMgdGhhdCBhcmUgbm90IGFsd2F5cyBpbiBzeW5jIHdpdGggZWFjaCBvdGhlci5cbi8vXG5jb25zdCBsb2cgPSBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAncmV0cnktb24tZW1wdHknKTtcbi8vIGVtcHR5IHZhbHVlcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWRcbi8vIGA8bmlsPmAgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzE2OTI1XG5jb25zdCBlbXB0eVZhbHVlcyA9IFtcbiAgICB1bmRlZmluZWQsXG4gICAgbnVsbCxcbiAgICAnXFx1MDAzY25pbFxcdTAwM2UnLFxuXTtcbmZ1bmN0aW9uIGNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmUoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwicHJvdmlkZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1JldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJibG9ja1RyYWNrZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBibG9ja1JlZkluZGV4ID0gY2FjaGVfMS5ibG9ja1RhZ1BhcmFtSW5kZXgocmVxKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm90IGV4YWN0IGJsb2NrIHJlZmVyZW5jZXNcbiAgICAgICAgbGV0IGJsb2NrUmVmID0gKF9hID0gcmVxLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Jsb2NrUmVmSW5kZXhdO1xuICAgICAgICAvLyBvbWl0dGVkIGJsb2NrUmVmIGltcGxpZXMgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxvY2tSZWYgPSAnbGF0ZXN0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIG5vbi1udW1iZXIgYmxvY2sgcmVmZXJlbmNlXG4gICAgICAgIGlmIChbJ2xhdGVzdCcsICdwZW5kaW5nJ10uaW5jbHVkZXMoYmxvY2tSZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgYmxvY2sgcmVmZXJuY2UgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAgICAgIGNvbnN0IGJsb2NrUmVmTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrUmVmLnNsaWNlKDIpLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYmxvY2tSZWZOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2t1cCBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXJIZXggPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQobGF0ZXN0QmxvY2tOdW1iZXJIZXguc2xpY2UoMiksIDE2KTtcbiAgICAgICAgLy8gc2tpcCBpZiByZXF1ZXN0IGJsb2NrIG51bWJlciBpcyBoaWdoZXIgdGhhbiBjdXJyZW50XG4gICAgICAgIGlmIChibG9ja1JlZk51bWJlciA+IGxhdGVzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICBsb2coJ1JlcXVlc3RlZCBibG9jayBudW1iZXIgJW8gaXMgaGlnaGVyIHRoYW4gbGF0ZXN0IGJsb2NrIG51bWJlciAlbywgZmFsbGluZyB0aHJvdWdoIHRvIG9yaWdpbmFsIHJlcXVlc3QnLCBibG9ja1JlZk51bWJlciwgbGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2coJ1JlcXVlc3RlZCBibG9jayBudW1iZXIgJW8gaXMgbm90IGhpZ2hlciB0aGFuIGxhdGVzdCBibG9jayBudW1iZXIgJW8sIHRyeWluZyByZXF1ZXN0IHVudGlsIG5vbi1lbXB0eSByZXNwb25zZSBpcyByZWNlaXZlZCcsIGJsb2NrUmVmTnVtYmVyLCBsYXRlc3RCbG9ja051bWJlcik7XG4gICAgICAgIC8vIGNyZWF0ZSBjaGlsZCByZXF1ZXN0IHdpdGggc3BlY2lmaWMgYmxvY2stcmVmXG4gICAgICAgIGNvbnN0IGNoaWxkUmVxdWVzdCA9IGNsb25lXzEuZGVmYXVsdChyZXEpO1xuICAgICAgICAvLyBhdHRlbXB0IGNoaWxkIHJlcXVlc3QgdW50aWwgbm9uLWVtcHR5IHJlc3BvbnNlIGlzIHJlY2VpdmVkXG4gICAgICAgIGNvbnN0IGNoaWxkUmVzcG9uc2UgPSBhd2FpdCByZXRyeSgxMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9nKCdQZXJmb3JtaW5nIHJlcXVlc3QgJW8nLCBjaGlsZFJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdFJlc3BvbnNlID0gYXdhaXQgcGlmeV8xLmRlZmF1bHQocHJvdmlkZXIuc2VuZEFzeW5jKS5jYWxsKHByb3ZpZGVyLCBjaGlsZFJlcXVlc3QpO1xuICAgICAgICAgICAgbG9nKCdSZXNwb25zZSBpcyAlbycsIGF0dGVtcHRSZXNwb25zZSk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVzdWx0XG4gICAgICAgICAgICBpZiAoZW1wdHlWYWx1ZXMuaW5jbHVkZXMoYXR0ZW1wdFJlc3BvbnNlLnJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSBlbXB0eSByZXNwb25zZSBcIiR7SlNPTi5zdHJpbmdpZnkoYXR0ZW1wdFJlc3BvbnNlKX1cIiBmb3IgcmVxdWVzdCBcIiR7SlNPTi5zdHJpbmdpZnkoY2hpbGRSZXF1ZXN0KX1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHRSZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZygnQ29weWluZyByZXN1bHQgJW8gYW5kIGVycm9yICVvJywgY2hpbGRSZXNwb25zZS5yZXN1bHQsIGNoaWxkUmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAvLyBjb3B5IGNoaWxkIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgcmVzLnJlc3VsdCA9IGNoaWxkUmVzcG9uc2UucmVzdWx0O1xuICAgICAgICByZXMuZXJyb3IgPSBjaGlsZFJlc3BvbnNlLmVycm9yO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlID0gY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZTtcbmFzeW5jIGZ1bmN0aW9uIHJldHJ5KG1heFJldHJpZXMsIGFzeW5jRm4pIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWF4UmV0cmllczsgaW5kZXgrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFzeW5jRm4oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2coJyhjYWxsICVpKSBSZXF1ZXN0IGZhaWxlZCwgd2FpdGluZyAxcyB0byByZXRyeSBhZ2Fpbi4uLicsIGluZGV4ICsgMSk7XG4gICAgICAgICAgICBhd2FpdCB0aW1lb3V0KDEwMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvZygnUmV0cmllcyBleGhhdXN0ZWQnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSByZXRyaWVzIGV4aGF1c3RlZCcpO1xufVxuZnVuY3Rpb24gdGltZW91dChkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlPbkVtcHR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWNoZVR5cGVGb3JQYXlsb2FkID0gZXhwb3J0cy5ibG9ja1RhZ1BhcmFtSW5kZXggPSBleHBvcnRzLnBhcmFtc1dpdGhvdXRCbG9ja1RhZyA9IGV4cG9ydHMuYmxvY2tUYWdGb3JQYXlsb2FkID0gZXhwb3J0cy5jYW5DYWNoZSA9IGV4cG9ydHMuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZCA9IHZvaWQgMDtcbmNvbnN0IGpzb25fc3RhYmxlX3N0cmluZ2lmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJqc29uLXN0YWJsZS1zdHJpbmdpZnlcIikpO1xuZnVuY3Rpb24gY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZChwYXlsb2FkLCBza2lwQmxvY2tSZWYpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2ltcGxlUGFyYW1zID0gc2tpcEJsb2NrUmVmXG4gICAgICAgID8gcGFyYW1zV2l0aG91dEJsb2NrVGFnKHBheWxvYWQpXG4gICAgICAgIDogKF9hID0gcGF5bG9hZC5wYXJhbXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIGlmIChjYW5DYWNoZShwYXlsb2FkKSkge1xuICAgICAgICByZXR1cm4gYCR7cGF5bG9hZC5tZXRob2R9OiR7anNvbl9zdGFibGVfc3RyaW5naWZ5XzEuZGVmYXVsdChzaW1wbGVQYXJhbXMpfWA7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkID0gY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZDtcbmZ1bmN0aW9uIGNhbkNhY2hlKHBheWxvYWQpIHtcbiAgICByZXR1cm4gY2FjaGVUeXBlRm9yUGF5bG9hZChwYXlsb2FkKSAhPT0gJ25ldmVyJztcbn1cbmV4cG9ydHMuY2FuQ2FjaGUgPSBjYW5DYWNoZTtcbmZ1bmN0aW9uIGJsb2NrVGFnRm9yUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgaWYgKCFwYXlsb2FkLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGJsb2NrVGFnUGFyYW1JbmRleChwYXlsb2FkKTtcbiAgICAvLyBCbG9jayB0YWcgcGFyYW0gbm90IHBhc3NlZC5cbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA+PSBwYXlsb2FkLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucGFyYW1zW2luZGV4XTtcbn1cbmV4cG9ydHMuYmxvY2tUYWdGb3JQYXlsb2FkID0gYmxvY2tUYWdGb3JQYXlsb2FkO1xuZnVuY3Rpb24gcGFyYW1zV2l0aG91dEJsb2NrVGFnKHBheWxvYWQpIHtcbiAgICBpZiAoIXBheWxvYWQucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocGF5bG9hZCk7XG4gICAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPj0gcGF5bG9hZC5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcztcbiAgICB9XG4gICAgLy8gZXRoX2dldEJsb2NrQnlOdW1iZXIgaGFzIHRoZSBibG9jayB0YWcgZmlyc3QsIHRoZW4gdGhlIG9wdGlvbmFsIGluY2x1ZGVUeD8gcGFyYW1cbiAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfZ2V0QmxvY2tCeU51bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQucGFyYW1zLnNsaWNlKDEpO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZC5wYXJhbXMuc2xpY2UoMCwgaW5kZXgpO1xufVxuZXhwb3J0cy5wYXJhbXNXaXRob3V0QmxvY2tUYWcgPSBwYXJhbXNXaXRob3V0QmxvY2tUYWc7XG5mdW5jdGlvbiBibG9ja1RhZ1BhcmFtSW5kZXgocGF5bG9hZCkge1xuICAgIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMlxuICAgICAgICBjYXNlICdldGhfZ2V0U3RvcmFnZUF0JzpcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAvLyBibG9ja1RhZyBpcyBhdCBpbmRleCAxXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCYWxhbmNlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldENvZGUnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgICAgIGNhc2UgJ2V0aF9jYWxsJzpcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAvLyBibG9ja1RhZyBpcyBhdCBpbmRleCAwXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAvLyB0aGVyZSBpcyBubyBibG9ja1RhZ1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLmJsb2NrVGFnUGFyYW1JbmRleCA9IGJsb2NrVGFnUGFyYW1JbmRleDtcbmZ1bmN0aW9uIGNhY2hlVHlwZUZvclBheWxvYWQocGF5bG9hZCkge1xuICAgIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHtcbiAgICAgICAgLy8gY2FjaGUgcGVybWFuZW50bHlcbiAgICAgICAgY2FzZSAnd2ViM19jbGllbnRWZXJzaW9uJzpcbiAgICAgICAgY2FzZSAnd2ViM19zaGEzJzpcbiAgICAgICAgY2FzZSAnZXRoX3Byb3RvY29sVmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2gnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldENvZGUnOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tCeUhhc2gnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUJ5QmxvY2tIYXNoQW5kSW5kZXgnOlxuICAgICAgICBjYXNlICdldGhfZ2V0Q29tcGlsZXJzJzpcbiAgICAgICAgY2FzZSAnZXRoX2NvbXBpbGVMTEwnOlxuICAgICAgICBjYXNlICdldGhfY29tcGlsZVNvbGlkaXR5JzpcbiAgICAgICAgY2FzZSAnZXRoX2NvbXBpbGVTZXJwZW50JzpcbiAgICAgICAgY2FzZSAnc2hoX3ZlcnNpb24nOlxuICAgICAgICBjYXNlICd0ZXN0X3Blcm1hQ2FjaGUnOlxuICAgICAgICAgICAgcmV0dXJuICdwZXJtYSc7XG4gICAgICAgIC8vIGNhY2hlIHVudGlsIGZvcmtcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlOdW1iZXInOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlOdW1iZXInOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXInOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrTnVtYmVyQW5kSW5kZXgnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXgnOlxuICAgICAgICBjYXNlICd0ZXN0X2ZvcmtDYWNoZSc6XG4gICAgICAgICAgICByZXR1cm4gJ2ZvcmsnO1xuICAgICAgICAvLyBjYWNoZSBmb3IgYmxvY2tcbiAgICAgICAgY2FzZSAnZXRoX2dhc1ByaWNlJzpcbiAgICAgICAgY2FzZSAnZXRoX2Jsb2NrTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJhbGFuY2UnOlxuICAgICAgICBjYXNlICdldGhfZ2V0U3RvcmFnZUF0JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgICAgIGNhc2UgJ2V0aF9lc3RpbWF0ZUdhcyc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRGaWx0ZXJMb2dzJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldExvZ3MnOlxuICAgICAgICBjYXNlICd0ZXN0X2Jsb2NrQ2FjaGUnOlxuICAgICAgICAgICAgcmV0dXJuICdibG9jayc7XG4gICAgICAgIC8vIG5ldmVyIGNhY2hlXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ25ldmVyJztcbiAgICB9XG59XG5leHBvcnRzLmNhY2hlVHlwZUZvclBheWxvYWQgPSBjYWNoZVR5cGVGb3JQYXlsb2FkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlV2FsbGV0TWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IHNpZ1V0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIkBtZXRhbWFzay9ldGgtc2lnLXV0aWxcIikpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdhbGxldE1pZGRsZXdhcmUoeyBnZXRBY2NvdW50cywgcHJvY2Vzc0RlY3J5cHRNZXNzYWdlLCBwcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleSwgcHJvY2Vzc0V0aFNpZ25NZXNzYWdlLCBwcm9jZXNzUGVyc29uYWxNZXNzYWdlLCBwcm9jZXNzVHJhbnNhY3Rpb24sIHByb2Nlc3NTaWduVHJhbnNhY3Rpb24sIHByb2Nlc3NUeXBlZE1lc3NhZ2UsIHByb2Nlc3NUeXBlZE1lc3NhZ2VWMywgcHJvY2Vzc1R5cGVkTWVzc2FnZVY0LCB9KSB7XG4gICAgaWYgKCFnZXRBY2NvdW50cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdHMuZ2V0QWNjb3VudHMgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZVNjYWZmb2xkTWlkZGxld2FyZSh7XG4gICAgICAgIC8vIGFjY291bnQgbG9va3Vwc1xuICAgICAgICBldGhfYWNjb3VudHM6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShsb29rdXBBY2NvdW50cyksXG4gICAgICAgIGV0aF9jb2luYmFzZToganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGxvb2t1cERlZmF1bHRBY2NvdW50KSxcbiAgICAgICAgLy8gdHggc2lnbmF0dXJlc1xuICAgICAgICBldGhfc2VuZFRyYW5zYWN0aW9uOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoc2VuZFRyYW5zYWN0aW9uKSxcbiAgICAgICAgZXRoX3NpZ25UcmFuc2FjdGlvbjoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHNpZ25UcmFuc2FjdGlvbiksXG4gICAgICAgIC8vIG1lc3NhZ2Ugc2lnbmF0dXJlc1xuICAgICAgICBldGhfc2lnbjoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGV0aFNpZ24pLFxuICAgICAgICBldGhfc2lnblR5cGVkRGF0YToganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHNpZ25UeXBlZERhdGEpLFxuICAgICAgICBldGhfc2lnblR5cGVkRGF0YV92MzoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHNpZ25UeXBlZERhdGFWMyksXG4gICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3Y0OiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoc2lnblR5cGVkRGF0YVY0KSxcbiAgICAgICAgcGVyc29uYWxfc2lnbjoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHBlcnNvbmFsU2lnbiksXG4gICAgICAgIGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5OiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoZW5jcnlwdGlvblB1YmxpY0tleSksXG4gICAgICAgIGV0aF9kZWNyeXB0OiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoZGVjcnlwdE1lc3NhZ2UpLFxuICAgICAgICBwZXJzb25hbF9lY1JlY292ZXI6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShwZXJzb25hbFJlY292ZXIpLFxuICAgIH0pO1xuICAgIC8vXG4gICAgLy8gYWNjb3VudCBsb29rdXBzXG4gICAgLy9cbiAgICBhc3luYyBmdW5jdGlvbiBsb29rdXBBY2NvdW50cyhyZXEsIHJlcykge1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgZ2V0QWNjb3VudHMocmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gbG9va3VwRGVmYXVsdEFjY291bnQocmVxLCByZXMpIHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBnZXRBY2NvdW50cyhyZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYWNjb3VudHNbMF0gfHwgbnVsbDtcbiAgICB9XG4gICAgLy9cbiAgICAvLyB0cmFuc2FjdGlvbiBzaWduYXR1cmVzXG4gICAgLy9cbiAgICBhc3luYyBmdW5jdGlvbiBzZW5kVHJhbnNhY3Rpb24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eFBhcmFtcyA9IHJlcS5wYXJhbXNbMF0gfHwge307XG4gICAgICAgIHR4UGFyYW1zLmZyb20gPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcih0eFBhcmFtcy5mcm9tLCByZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1RyYW5zYWN0aW9uKHR4UGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzU2lnblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHhQYXJhbXMgPSByZXEucGFyYW1zWzBdIHx8IHt9O1xuICAgICAgICB0eFBhcmFtcy5mcm9tID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIodHhQYXJhbXMuZnJvbSwgcmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NTaWduVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gbWVzc2FnZSBzaWduYXR1cmVzXG4gICAgLy9cbiAgICBhc3luYyBmdW5jdGlvbiBldGhTaWduKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc0V0aFNpZ25NZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzFdO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IG1lc3NhZ2UgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzRXRoU2lnbk1lc3NhZ2UobXNnUGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHlwZWREYXRhKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc1R5cGVkTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1sxXSwgcmVxKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICdWMSc7XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogbWVzc2FnZSB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUeXBlZE1lc3NhZ2UobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHlwZWREYXRhVjMocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHlwZWRNZXNzYWdlVjMpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAnVjMnO1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSB7XG4gICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHlwZWRNZXNzYWdlVjMobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzaWduVHlwZWREYXRhVjQocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHlwZWRNZXNzYWdlVjQpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSAnVjQnO1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSB7XG4gICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHlwZWRNZXNzYWdlVjQobXNnUGFyYW1zLCByZXEsIHZlcnNpb24pO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBwZXJzb25hbFNpZ24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzUGVyc29uYWxNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvY2VzcyBub3JtYWxseVxuICAgICAgICBjb25zdCBmaXJzdFBhcmFtID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3Qgc2Vjb25kUGFyYW0gPSByZXEucGFyYW1zWzFdO1xuICAgICAgICAvLyBub24tc3RhbmRhcmQgXCJleHRyYVBhcmFtc1wiIHRvIGJlIGFwcGVuZGVkIHRvIG91ciBcIm1zZ1BhcmFtc1wiIG9ialxuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIC8vIFdlIGluaXRpYWxseSBpbmNvcnJlY3RseSBvcmRlcmVkIHRoZXNlIHBhcmFtZXRlcnMuXG4gICAgICAgIC8vIFRvIGdyYWNlZnVsbHkgcmVzcGVjdCB1c2VycyB3aG8gYWRvcHRlZCB0aGlzIEFQSSBlYXJseSxcbiAgICAgICAgLy8gd2UgYXJlIGN1cnJlbnRseSBncmFjZWZ1bGx5IHJlY292ZXJpbmcgZnJvbSB0aGUgd3JvbmcgcGFyYW0gb3JkZXJcbiAgICAgICAgLy8gd2hlbiBpdCBpcyBjbGVhcmx5IGlkZW50aWZpYWJsZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhhdCBtZWFucyB3aGVuIHRoZSBmaXJzdCBwYXJhbSBpcyBkZWZpbml0ZWx5IGFuIGFkZHJlc3MsXG4gICAgICAgIC8vIGFuZCB0aGUgc2Vjb25kIHBhcmFtIGlzIGRlZmluaXRlbHkgbm90LCBidXQgaXMgaGV4LlxuICAgICAgICBsZXQgYWRkcmVzcywgbWVzc2FnZTtcbiAgICAgICAgaWYgKHJlc2VtYmxlc0FkZHJlc3MoZmlyc3RQYXJhbSkgJiYgIXJlc2VtYmxlc0FkZHJlc3Moc2Vjb25kUGFyYW0pKSB7XG4gICAgICAgICAgICBsZXQgd2FybmluZyA9IGBUaGUgZXRoX3BlcnNvbmFsU2lnbiBtZXRob2QgcmVxdWlyZXMgcGFyYW1zIG9yZGVyZWQgYDtcbiAgICAgICAgICAgIHdhcm5pbmcgKz0gYFttZXNzYWdlLCBhZGRyZXNzXS4gVGhpcyB3YXMgcHJldmlvdXNseSBoYW5kbGVkIGluY29ycmVjdGx5LCBgO1xuICAgICAgICAgICAgd2FybmluZyArPSBgYW5kIGhhcyBiZWVuIGNvcnJlY3RlZCBhdXRvbWF0aWNhbGx5LiBgO1xuICAgICAgICAgICAgd2FybmluZyArPSBgUGxlYXNlIHN3aXRjaCB0aGlzIHBhcmFtIG9yZGVyIGZvciBzbW9vdGggYmVoYXZpb3IgaW4gdGhlIGZ1dHVyZS5gO1xuICAgICAgICAgICAgcmVzLndhcm5pbmcgPSB3YXJuaW5nO1xuICAgICAgICAgICAgYWRkcmVzcyA9IGZpcnN0UGFyYW07XG4gICAgICAgICAgICBtZXNzYWdlID0gc2Vjb25kUGFyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZmlyc3RQYXJhbTtcbiAgICAgICAgICAgIGFkZHJlc3MgPSBzZWNvbmRQYXJhbTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIoYWRkcmVzcywgcmVxKTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogbWVzc2FnZSB9KTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXNcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NQZXJzb25hbE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBwZXJzb25hbFJlY292ZXIocmVxLCByZXMpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IHNpZ25lckFkZHJlc3MgPSBzaWdVdGlsLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSh7XG4gICAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IHNpZ25lckFkZHJlc3M7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGVuY3J5cHRpb25QdWJsaWNLZXkocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXkoYWRkcmVzcywgcmVxKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZGVjcnlwdE1lc3NhZ2UocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzRGVjcnlwdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMV0sIHJlcSk7XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogY2lwaGVydGV4dCB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NEZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIC8vXG4gICAgLy8gdXRpbGl0eVxuICAgIC8vXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBrZXlob2xkZXIgYWRkcmVzcywgYW5kIHJldHVybnMgYSBub3JtYWxpemVkIChpLmUuIGxvd2VyY2FzZSlcbiAgICAgKiBjb3B5IG9mIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byB2YWxpZGF0ZSBhbmQgbm9ybWFsaXplLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXEgLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgbm9ybWFsaXplZCBhZGRyZXNzLCBpZiB2YWxpZC4gT3RoZXJ3aXNlLCB0aHJvd3NcbiAgICAgKiBhbiBlcnJvclxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKGFkZHJlc3MsIHJlcSkge1xuICAgICAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBhZGRyZXNzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHJlc2VtYmxlc0FkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBhZGRyZXNzIGlzIGluY2x1ZGVkIGluIHByb3ZpZGVkIGFjY291bnRzLiBgc3VwcHJlc3NVbmF1dGhvcml6ZWQ6IGZhbHNlYCBpcyBwYXNzZWQgdG8gYGdldEFjY291bnRzYFxuICAgICAgICAgICAgLy8gc28gdGhhdCBhbiBcInVuYXV0aG9yaXplZFwiIGVycm9yIGlzIHRocm93biBpZiB0aGUgcmVxdWVzdGVyIGRvZXMgbm90IGhhdmUgdGhlIGBldGhfYWNjb3VudHNgXG4gICAgICAgICAgICAvLyBwZXJtaXNzaW9uLlxuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBnZXRBY2NvdW50cyhyZXEsIHtcbiAgICAgICAgICAgICAgICBzdXBwcmVzc1VuYXV0aG9yaXplZDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBY2NvdW50cyA9IGFjY291bnRzLm1hcCgoX2FkZHJlc3MpID0+IF9hZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZEFjY291bnRzLmluY2x1ZGVzKG5vcm1hbGl6ZWRBZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIHBhcmFtZXRlcnM6IG11c3QgcHJvdmlkZSBhbiBFdGhlcmV1bSBhZGRyZXNzLmAsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlV2FsbGV0TWlkZGxld2FyZSA9IGNyZWF0ZVdhbGxldE1pZGRsZXdhcmU7XG5mdW5jdGlvbiByZXNlbWJsZXNBZGRyZXNzKHN0cikge1xuICAgIC8vIGhleCBwcmVmaXggMiArIDIwIGJ5dGVzXG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT09IDIgKyAyMCAqIDI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxsZXQuanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwcm9jZXNzRm4gPSAoZm4sIG9wdHMpID0+IGZ1bmN0aW9uICgpIHtcblx0Y29uc3QgUCA9IG9wdHMucHJvbWlzZU1vZHVsZTtcblx0Y29uc3QgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG5cdH1cblxuXHRyZXR1cm4gbmV3IFAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGlmIChvcHRzLmVycm9yRmlyc3QpIHtcblx0XHRcdGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdFx0cmVzdWx0cy51bnNoaWZ0KGVycik7XG5cdFx0XHRcdFx0XHRyZWplY3QocmVzdWx0cyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGVycikge1xuXHRcdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFyZ3MucHVzaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKG9iaiwgb3B0cykgPT4ge1xuXHRvcHRzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0ZXhjbHVkZTogWy8uKyhTeW5jfFN0cmVhbSkkL10sXG5cdFx0ZXJyb3JGaXJzdDogdHJ1ZSxcblx0XHRwcm9taXNlTW9kdWxlOiBQcm9taXNlXG5cdH0sIG9wdHMpO1xuXG5cdGNvbnN0IGZpbHRlciA9IGtleSA9PiB7XG5cdFx0Y29uc3QgbWF0Y2ggPSBwYXR0ZXJuID0+IHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyA/IGtleSA9PT0gcGF0dGVybiA6IHBhdHRlcm4udGVzdChrZXkpO1xuXHRcdHJldHVybiBvcHRzLmluY2x1ZGUgPyBvcHRzLmluY2x1ZGUuc29tZShtYXRjaCkgOiAhb3B0cy5leGNsdWRlLnNvbWUobWF0Y2gpO1xuXHR9O1xuXG5cdGxldCByZXQ7XG5cdGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKG9wdHMuZXhjbHVkZU1haW4pIHtcblx0XHRcdFx0cmV0dXJuIG9iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvY2Vzc0ZuKG9iaiwgb3B0cykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHJldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuXHR9XG5cblx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG5cdFx0Y29uc3QgeCA9IG9ialtrZXldO1xuXHRcdHJldFtrZXldID0gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgJiYgZmlsdGVyKGtleSkgPyBwcm9jZXNzRm4oeCwgb3B0cykgOiB4O1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBsb2dnaW5nX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nLXV0aWxzXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuY29uc3QgbG9nID0gbG9nZ2luZ191dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcihsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ2Jsb2NrLWNhY2hlJyk7XG4vLyBgPG5pbD5gIGNvbWVzIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8xNjkyNVxuY29uc3QgZW1wdHlWYWx1ZXMgPSBbdW5kZWZpbmVkLCBudWxsLCAnXFx1MDAzY25pbFxcdTAwM2UnXTtcbi8vXG4vLyBDYWNoZSBTdHJhdGVnaWVzXG4vL1xuY2xhc3MgQmxvY2tDYWNoZVN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWNoZSA9IHt9O1xuICAgIH1cbiAgICBnZXRCbG9ja0NhY2hlKGJsb2NrTnVtYmVySGV4KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrTnVtYmVySGV4LCAxNik7XG4gICAgICAgIGxldCBibG9ja0NhY2hlID0gdGhpcy5jYWNoZVtibG9ja051bWJlcl07XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgY2FjaGUgaWYgbmVjZXNhcnlcbiAgICAgICAgaWYgKCFibG9ja0NhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jYWNoZVtibG9ja051bWJlcl0gPSBuZXdDYWNoZTtcbiAgICAgICAgICAgIGJsb2NrQ2FjaGUgPSBuZXdDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tDYWNoZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KHJlcXVlc3QsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIGxvb2t1cCBibG9jayBjYWNoZVxuICAgICAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlKHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgLy8gbG9va3VwIHBheWxvYWQgaW4gYmxvY2sgY2FjaGVcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNhY2hlXzEuY2FjaGVJZGVudGlmaWVyRm9yUmVxdWVzdChyZXF1ZXN0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIgPyBibG9ja0NhY2hlW2lkZW50aWZpZXJdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBzZXQocmVxdWVzdCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIHJlc3VsdCkge1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gY2FjaGVkIHRoaXMgcmVzdWx0XG4gICAgICAgIGNvbnN0IGNhbkNhY2hlUmVzdWx0ID0gdGhpcy5jYW5DYWNoZVJlc3VsdChyZXF1ZXN0LCByZXN1bHQpO1xuICAgICAgICBpZiAoIWNhbkNhY2hlUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZSBpbiB0aGUgY2FjaGVcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGNhY2hlXzEuY2FjaGVJZGVudGlmaWVyRm9yUmVxdWVzdChyZXF1ZXN0LCB0cnVlKTtcbiAgICAgICAgaWYgKCFpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2tDYWNoZSA9IHRoaXMuZ2V0QmxvY2tDYWNoZShyZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIGJsb2NrQ2FjaGVbaWRlbnRpZmllcl0gPSByZXN1bHQ7XG4gICAgfVxuICAgIGNhbkNhY2hlUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIC8vIGNoZWNrIHJlcXVlc3QgbWV0aG9kXG4gICAgICAgIGlmICghY2FjaGVfMS5jYW5DYWNoZShyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBibG9ja1RhZ1xuICAgICAgICBjb25zdCBibG9ja1RhZyA9IGNhY2hlXzEuYmxvY2tUYWdGb3JSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbiBiZSBjYWNoZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhbkNhY2hlUmVzdWx0KHJlcXVlc3QsIHJlc3VsdCkge1xuICAgICAgICAvLyBuZXZlciBjYWNoZSBlbXB0eSB2YWx1ZXMgKGUuZy4gdW5kZWZpbmVkKVxuICAgICAgICBpZiAoZW1wdHlWYWx1ZXMuaW5jbHVkZXMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHRyYW5zYWN0aW9ucyBoYXZlIGJsb2NrIHJlZmVyZW5jZSBiZWZvcmUgY2FjaGluZ1xuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgJiZcbiAgICAgICAgICAgIFsnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJywgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnXS5pbmNsdWRlcyhyZXF1ZXN0Lm1ldGhvZCkpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0IHx8XG4gICAgICAgICAgICAgICAgIXJlc3VsdC5ibG9ja0hhc2ggfHxcbiAgICAgICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID09PVxuICAgICAgICAgICAgICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlcyBhbGwgYmxvY2sgY2FjaGVzIHdpdGggYmxvY2sgbnVtYmVyIGxvd2VyIHRoYW4gYG9sZEJsb2NrSGV4YFxuICAgIGNsZWFyQmVmb3JlKG9sZEJsb2NrSGV4KSB7XG4gICAgICAgIGNvbnN0IG9sZEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KG9sZEJsb2NrSGV4LCAxNik7XG4gICAgICAgIC8vIGNsZWFyIG9sZCBjYWNoZXNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jYWNoZSlcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgLmZpbHRlcigobnVtKSA9PiBudW0gPCBvbGRCbG9ja051bWJlcilcbiAgICAgICAgICAgIC5mb3JFYWNoKChudW0pID0+IGRlbGV0ZSB0aGlzLmNhY2hlW251bV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zXG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSAtIE5vIFBvbGxpbmdCbG9ja1RyYWNrZXIgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBjYWNoaW5nIHN0cmF0ZWdpZXNcbiAgICBjb25zdCBibG9ja0NhY2hlID0gbmV3IEJsb2NrQ2FjaGVTdHJhdGVneSgpO1xuICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSB7XG4gICAgICAgIFtjYWNoZV8xLkNhY2hlU3RyYXRlZ3kuUGVybWFuZW50XTogYmxvY2tDYWNoZSxcbiAgICAgICAgW2NhY2hlXzEuQ2FjaGVTdHJhdGVneS5CbG9ja106IGJsb2NrQ2FjaGUsXG4gICAgICAgIFtjYWNoZV8xLkNhY2hlU3RyYXRlZ3kuRm9ya106IGJsb2NrQ2FjaGUsXG4gICAgICAgIFtjYWNoZV8xLkNhY2hlU3RyYXRlZ3kuTmV2ZXJdOiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICAvLyBhbGxvdyBjYWNoIHRvIGJlIHNraXBwZWQgaWYgc28gc3BlY2lmaWVkXG4gICAgICAgIGlmIChyZXEuc2tpcENhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIHR5cGUgYW5kIG1hdGNoaW5nIHN0cmF0ZWd5XG4gICAgICAgIGNvbnN0IHR5cGUgPSBjYWNoZV8xLmNhY2hlVHlwZUZvck1ldGhvZChyZXEubWV0aG9kKTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBzdHJhdGVnaWVzW3R5cGVdO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHN0cmF0ZWd5IGluIHBsYWNlLCBwYXNzIGl0IGRvd24gdGhlIGNoYWluLlxuICAgICAgICBpZiAoIXN0cmF0ZWd5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzdHJhdGVneSBjYW4ndCBjYWNoZSB0aGlzIHJlcXVlc3QsIGlnbm9yZSBpdC5cbiAgICAgICAgaWYgKCFzdHJhdGVneS5jYW5DYWNoZVJlcXVlc3QocmVxKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgYmxvY2sgcmVmZXJlbmNlIChudW1iZXIgb3Iga2V5d29yZClcbiAgICAgICAgY29uc3QgcmVxdWVzdEJsb2NrVGFnID0gY2FjaGVfMS5ibG9ja1RhZ0ZvclJlcXVlc3QocmVxKTtcbiAgICAgICAgY29uc3QgYmxvY2tUYWcgPSByZXF1ZXN0QmxvY2tUYWcgJiYgdHlwZW9mIHJlcXVlc3RCbG9ja1RhZyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gcmVxdWVzdEJsb2NrVGFnXG4gICAgICAgICAgICA6ICdsYXRlc3QnO1xuICAgICAgICBsb2coJ2Jsb2NrVGFnID0gJW8sIHJlcSA9ICVvJywgYmxvY2tUYWcsIHJlcSk7XG4gICAgICAgIC8vIGdldCBleGFjdCBibG9jayBudW1iZXJcbiAgICAgICAgbGV0IHJlcXVlc3RlZEJsb2NrTnVtYmVyO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdlYXJsaWVzdCcpIHtcbiAgICAgICAgICAgIC8vIHRoaXMganVzdCBleGlzdHMgZm9yIHN5bW1ldHJ5IHdpdGggXCJsYXRlc3RcIlxuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSAnMHgwMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2tUYWcgPT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICAvLyBmZXRjaCBsYXRlc3QgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBsb2coJ0ZldGNoaW5nIGxhdGVzdCBibG9jayBudW1iZXIgdG8gZGV0ZXJtaW5lIGNhY2hlIGtleScpO1xuICAgICAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgICAgIC8vIGNsZWFyIGFsbCBjYWNoZSBiZWZvcmUgbGF0ZXN0IGJsb2NrXG4gICAgICAgICAgICBsb2coJ0NsZWFyaW5nIHZhbHVlcyBzdG9yZWQgdW5kZXIgYmxvY2sgbnVtYmVycyBiZWZvcmUgJW8nLCBsYXRlc3RCbG9ja051bWJlcik7XG4gICAgICAgICAgICBibG9ja0NhY2hlLmNsZWFyQmVmb3JlKGxhdGVzdEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gbGF0ZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGEgaGV4IG51bWJlclxuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBibG9ja1RhZztcbiAgICAgICAgfVxuICAgICAgICAvLyBlbmQgb24gYSBoaXQsIGNvbnRpbnVlIG9uIGEgbWlzc1xuICAgICAgICBjb25zdCBjYWNoZVJlc3VsdCA9IGF3YWl0IHN0cmF0ZWd5LmdldChyZXEsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKTtcbiAgICAgICAgaWYgKGNhY2hlUmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGNhY2hlIG1pc3NcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIG90aGVyIG1pZGRsZXdhcmUgdG8gaGFuZGxlIHJlcXVlc3RcbiAgICAgICAgICAgIGxvZygnTm8gY2FjaGUgc3RvcmVkIHVuZGVyIGJsb2NrIG51bWJlciAlbywgY2FycnlpbmcgcmVxdWVzdCBmb3J3YXJkJywgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgICAgICAvLyBhZGQgcmVzdWx0IHRvIGNhY2hlXG4gICAgICAgICAgICAvLyBpdCdzIHNhZmUgdG8gY2FzdCByZXMucmVzdWx0IGFzIEJsb2NrLCBkdWUgdG8gcnVudGltZSB0eXBlIGNoZWNrc1xuICAgICAgICAgICAgLy8gcGVyZm9ybWVkIHdoZW4gc3RyYXRlZ3kuc2V0IGlzIGNhbGxlZFxuICAgICAgICAgICAgbG9nKCdQb3B1bGF0aW5nIGNhY2hlIHdpdGgnLCByZXMpO1xuICAgICAgICAgICAgYXdhaXQgc3RyYXRlZ3kuc2V0KHJlcSwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIHJlcy5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmlsbCBpbiByZXN1bHQgZnJvbSBjYWNoZVxuICAgICAgICAgICAgbG9nKCdDYWNoZSBoaXQsIHJldXNpbmcgY2FjaGUgcmVzdWx0IHN0b3JlZCB1bmRlciBibG9jayBudW1iZXIgJW8nLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgICAgICByZXMucmVzdWx0ID0gY2FjaGVSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSh7IGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Jsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJibG9ja1RyYWNrZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCBfcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJsb2NrUmVmSW5kZXggPSBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleChyZXEubWV0aG9kKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm90IFwibGF0ZXN0XCJcbiAgICAgICAgbGV0IGJsb2NrUmVmID0gQXJyYXkuaXNBcnJheShyZXEucGFyYW1zKVxuICAgICAgICAgICAgPyByZXEucGFyYW1zW2Jsb2NrUmVmSW5kZXhdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gb21pdHRlZCBibG9ja1JlZiBpbXBsaWVzIFwibGF0ZXN0XCJcbiAgICAgICAgaWYgKGJsb2NrUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsb2NrUmVmID0gJ2xhdGVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrUmVmICE9PSAnbGF0ZXN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXdyaXRlIGJsb2NrUmVmIHRvIGJsb2NrLXRyYWNrZXIncyBibG9jayBudW1iZXJcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxLnBhcmFtcykpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLWF0b21pYy11cGRhdGVzXG4gICAgICAgICAgICByZXEucGFyYW1zW2Jsb2NrUmVmSW5kZXhdID0gbGF0ZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSA9IGNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1yZWYtcmV3cml0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xvbmVcIikpO1xuY29uc3QgcGlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwaWZ5XCIpKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5jb25zdCBsb2cgPSBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAnYmxvY2stcmVmJyk7XG5mdW5jdGlvbiBjcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdCbG9ja1JlZk1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJwcm92aWRlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICBpZiAoIWJsb2NrVHJhY2tlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQmxvY2tSZWZNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwiYmxvY2tUcmFja2VyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9IGNhY2hlXzEuYmxvY2tUYWdQYXJhbUluZGV4KHJlcS5tZXRob2QpO1xuICAgICAgICAvLyBza2lwIGlmIG1ldGhvZCBkb2VzIG5vdCBpbmNsdWRlIGJsb2NrUmVmXG4gICAgICAgIGlmIChibG9ja1JlZkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmxvY2tSZWYgPSBBcnJheS5pc0FycmF5KHJlcS5wYXJhbXMpXG4gICAgICAgICAgICA/IChfYSA9IHJlcS5wYXJhbXNbYmxvY2tSZWZJbmRleF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdsYXRlc3QnXG4gICAgICAgICAgICA6ICdsYXRlc3QnO1xuICAgICAgICAvLyBza2lwIGlmIG5vdCBcImxhdGVzdFwiXG4gICAgICAgIGlmIChibG9ja1JlZiAhPT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgICAgIGxvZygnYmxvY2tSZWYgaXMgbm90IFwibGF0ZXN0XCIsIGNhcnJ5aW5nIHJlcXVlc3QgZm9yd2FyZCcpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rdXAgbGF0ZXN0IGJsb2NrXG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKCk7XG4gICAgICAgIGxvZyhgYmxvY2tSZWYgaXMgXCJsYXRlc3RcIiwgc2V0dGluZyBwYXJhbSAke2Jsb2NrUmVmSW5kZXh9IHRvIGxhdGVzdCBibG9jayAke2xhdGVzdEJsb2NrTnVtYmVyfWApO1xuICAgICAgICAvLyBjcmVhdGUgY2hpbGQgcmVxdWVzdCB3aXRoIHNwZWNpZmljIGJsb2NrLXJlZlxuICAgICAgICBjb25zdCBjaGlsZFJlcXVlc3QgPSBjbG9uZV8xLmRlZmF1bHQocmVxKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRSZXF1ZXN0LnBhcmFtcykpIHtcbiAgICAgICAgICAgIGNoaWxkUmVxdWVzdC5wYXJhbXNbYmxvY2tSZWZJbmRleF0gPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJmb3JtIGNoaWxkIHJlcXVlc3RcbiAgICAgICAgbG9nKCdQZXJmb3JtaW5nIGFub3RoZXIgcmVxdWVzdCAlbycsIGNoaWxkUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGNoaWxkUmVzID0gYXdhaXQgcGlmeV8xLmRlZmF1bHQocHJvdmlkZXIuc2VuZEFzeW5jKS5jYWxsKHByb3ZpZGVyLCBjaGlsZFJlcXVlc3QpO1xuICAgICAgICAvLyBjb3B5IGNoaWxkIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgcmVzLnJlc3VsdCA9IGNoaWxkUmVzLnJlc3VsdDtcbiAgICAgICAgcmVzLmVycm9yID0gY2hpbGRSZXMuZXJyb3I7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrUmVmTWlkZGxld2FyZSA9IGNyZWF0ZUJsb2NrUmVmTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLXJlZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBsb2cgPSBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAnYmxvY2stdHJhY2tlci1pbnNwZWN0b3InKTtcbmNvbnN0IGZ1dHVyZUJsb2NrUmVmUmVxdWVzdHMgPSBbXG4gICAgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICAgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuXTtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaGFzIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0VG9DaGVjayAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcGFyYW0gcHJvcGVydHkgLSBUaGUgcHJvcGVydHkgdG8gbG9vayBmb3IuXG4gKiBAcmV0dXJucyAtIFdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmplY3RUb0NoZWNrLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3RUb0NoZWNrLCBwcm9wZXJ0eSk7XG59XG5mdW5jdGlvbiBnZXRSZXN1bHRCbG9ja051bWJlcihyZXNwb25zZSkge1xuICAgIGNvbnN0IHsgcmVzdWx0IH0gPSByZXNwb25zZTtcbiAgICBpZiAoIXJlc3VsdCB8fFxuICAgICAgICB0eXBlb2YgcmVzdWx0ICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAhaGFzUHJvcGVydHkocmVzdWx0LCAnYmxvY2tOdW1iZXInKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJlc3VsdC5ibG9ja051bWJlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ibG9ja051bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8vIGluc3BlY3QgaWYgcmVzcG9uc2UgY29udGFpbnMgYSBibG9jayByZWYgaGlnaGVyIHRoYW4gb3VyIGxhdGVzdCBibG9ja1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSh7IGJsb2NrVHJhY2tlciwgfSkge1xuICAgIHJldHVybiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIGlmICghZnV0dXJlQmxvY2tSZWZSZXF1ZXN0cy5pbmNsdWRlcyhyZXEubWV0aG9kKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgYXdhaXQgbmV4dCgpO1xuICAgICAgICAvLyBhYm9ydCBpZiBubyByZXN1bHQgb3Igbm8gYmxvY2sgbnVtYmVyXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlQmxvY2tOdW1iZXIgPSBnZXRSZXN1bHRCbG9ja051bWJlcihyZXMpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbG9nKCdyZXMucmVzdWx0LmJsb2NrTnVtYmVyIGV4aXN0cywgcHJvY2VlZGluZy4gcmVzID0gJW8nLCByZXMpO1xuICAgICAgICAvLyBpZiBudW1iZXIgaXMgaGlnaGVyLCBzdWdnZXN0IGJsb2NrLXRyYWNrZXIgY2hlY2sgZm9yIGEgbmV3IGJsb2NrXG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KHJlc3BvbnNlQmxvY2tOdW1iZXIsIDE2KTtcbiAgICAgICAgLy8gVHlwZWNhc3Q6IElmIGdldEN1cnJlbnRCbG9jayByZXR1cm5zIG51bGwsIGN1cnJlbnRCbG9ja051bWJlciB3aWxsIGJlIE5hTiwgd2hpY2ggaXMgZmluZS5cbiAgICAgICAgY29uc3QgY3VycmVudEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrVHJhY2tlci5nZXRDdXJyZW50QmxvY2soKSwgMTYpO1xuICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiBjdXJyZW50QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgIGxvZygnYmxvY2tOdW1iZXIgZnJvbSByZXNwb25zZSBpcyBncmVhdGVyIHRoYW4gY3VycmVudCBibG9jayBudW1iZXIsIHJlZnJlc2hpbmcgY3VycmVudCBibG9jayBudW1iZXInKTtcbiAgICAgICAgICAgIGF3YWl0IGJsb2NrVHJhY2tlci5jaGVja0ZvckxhdGVzdEJsb2NrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZSA9IGNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay10cmFja2VyLWluc3BlY3Rvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxID0gZXhwb3J0cy5jcmVhdGVGZXRjaE1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3QgdGltZW91dF8xID0gcmVxdWlyZShcIi4vdXRpbHMvdGltZW91dFwiKTtcbmNvbnN0IFJFVFJJQUJMRV9FUlJPUlMgPSBbXG4gICAgLy8gaWdub3JlIHNlcnZlciBvdmVybG9hZCBlcnJvcnNcbiAgICAnR2F0ZXdheSB0aW1lb3V0JyxcbiAgICAnRVRJTUVET1VUJyxcbiAgICAvLyBpZ25vcmUgc2VydmVyIHNlbnQgaHRtbCBlcnJvciBwYWdlc1xuICAgIC8vIG9yIHRydW5jYXRlZCBqc29uIHJlc3BvbnNlc1xuICAgICdmYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgYm9keScsXG4gICAgLy8gaWdub3JlIGVycm9ycyB3aGVyZSBodHRwIHJlcSBmYWlsZWQgdG8gZXN0YWJsaXNoXG4gICAgJ0ZhaWxlZCB0byBmZXRjaCcsXG5dO1xuLyoqXG4gKiBDcmVhdGUgbWlkZGxld2FyZSBmb3Igc2VuZGluZyBhIEpTT04tUlBDIHJlcXVlc3QgdG8gdGhlIGdpdmVuIFJQQyBVUkwuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucy5idG9hIC0gR2VuZXJhdGVzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nIGZyb20gYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIG9wdGlvbnMuZmV0Y2ggLSBUaGUgYGZldGNoYCBmdW5jdGlvbjsgZXhwZWN0ZWQgdG8gYmUgZXF1aXZhbGVudCB0byBgd2luZG93LmZldGNoYC5cbiAqIEBwYXJhbSBvcHRpb25zLnJwY1VybCAtIFRoZSBVUkwgdG8gc2VuZCB0aGUgcmVxdWVzdCB0by5cbiAqIEBwYXJhbSBvcHRpb25zLm9yaWdpbkh0dHBIZWFkZXJLZXkgLSBJZiBwcm92aWRlciwgdGhlIG9yaWdpbiBmaWVsZCBmb3IgZWFjaCBKU09OLVJQQyByZXF1ZXN0XG4gKiB3aWxsIGJlIGF0dGFjaGVkIHRvIGVhY2ggb3V0Z29pbmcgZmV0Y2ggcmVxdWVzdCB1bmRlciB0aGlzIGhlYWRlci5cbiAqIEByZXR1cm5zIFRoZSBmZXRjaCBtaWRkbGV3YXJlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGZXRjaE1pZGRsZXdhcmUoeyBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG5idG9hLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG5mZXRjaCwgcnBjVXJsLCBvcmlnaW5IdHRwSGVhZGVyS2V5LCB9KSB7XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIF9uZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZmV0Y2hVcmwsIGZldGNoUGFyYW1zIH0gPSBjcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEoe1xuICAgICAgICAgICAgYnRvYSxcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgIG9yaWdpbkh0dHBIZWFkZXJLZXksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhdHRlbXB0IHJlcXVlc3QgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA1O1xuICAgICAgICBjb25zdCByZXRyeUludGVydmFsID0gMTAwMDtcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoUmVzID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIGZldGNoUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgaHR0cCBlcnJyb3JzXG4gICAgICAgICAgICAgICAgY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKTtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSByZXNwb25zZSBib2R5XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3Qm9keSA9IGF3YWl0IGZldGNoUmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgZmV0Y2hCb2R5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoQm9keSA9IEpTT04ucGFyc2UocmF3Qm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmV0Y2hNaWRkbGV3YXJlIC0gZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHk6IFwiJHtyYXdCb2R5fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGZldGNoQm9keSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHJlc3VsdCBhbmQgZXhpdCByZXRyeSBsb29wXG4gICAgICAgICAgICAgICAgcmVzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZXRyaWFibGUgPSBSRVRSSUFCTEVfRVJST1JTLnNvbWUoKHBocmFzZSkgPT4gZXJyTXNnLmluY2x1ZGVzKHBocmFzZSkpO1xuICAgICAgICAgICAgICAgIC8vIHJlLXRocm93IGVycm9yIGlmIG5vdCByZXRyaWFibGVcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWxheSBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXRfMS50aW1lb3V0KHJldHJ5SW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUZldGNoTWlkZGxld2FyZSA9IGNyZWF0ZUZldGNoTWlkZGxld2FyZTtcbmZ1bmN0aW9uIGNoZWNrRm9ySHR0cEVycm9ycyhmZXRjaFJlcykge1xuICAgIC8vIGNoZWNrIGZvciBlcnJvcnNcbiAgICBzd2l0Y2ggKGZldGNoUmVzLnN0YXR1cykge1xuICAgICAgICBjYXNlIDQwNTpcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RGb3VuZCgpO1xuICAgICAgICBjYXNlIDQxODpcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZVJhdGVsaW1pdEVycm9yKCk7XG4gICAgICAgIGNhc2UgNTAzOlxuICAgICAgICBjYXNlIDUwNDpcbiAgICAgICAgICAgIHRocm93IGNyZWF0ZVRpbWVvdXRFcnJvcigpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VSZXNwb25zZShmZXRjaFJlcywgYm9keSkge1xuICAgIC8vIGNoZWNrIGZvciBlcnJvciBjb2RlXG4gICAgaWYgKGZldGNoUmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBgTm9uLTIwMCBzdGF0dXMgY29kZTogJyR7ZmV0Y2hSZXMuc3RhdHVzfSdgLFxuICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBycGMgZXJyb3JcbiAgICBpZiAoYm9keS5lcnJvcikge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xuICAgICAgICAgICAgZGF0YTogYm9keS5lcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHJldHVybiBzdWNjZXNzZnVsIHJlc3VsdFxuICAgIHJldHVybiBib2R5LnJlc3VsdDtcbn1cbi8qKlxuICogR2VuZXJhdGUgYGZldGNoYCBjb25maWd1cmF0aW9uIGZvciBzZW5kaW5nIHRoZSBnaXZlbiByZXF1ZXN0IHRvIGFuIFJQQyBBUEkuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucy5idG9hIC0gR2VuZXJhdGVzIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nIGZyb20gYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIG9wdGlvbnMucnBjVXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvLlxuICogQHBhcmFtIG9wdGlvbnMub3JpZ2luSHR0cEhlYWRlcktleSAtIElmIHByb3ZpZGVyLCB0aGUgb3JpZ2luIGZpZWxkIGZvciBlYWNoIEpTT04tUlBDIHJlcXVlc3RcbiAqIHdpbGwgYmUgYXR0YWNoZWQgdG8gZWFjaCBvdXRnb2luZyBmZXRjaCByZXF1ZXN0IHVuZGVyIHRoaXMgaGVhZGVyLlxuICogQHJldHVybnMgVGhlIGZldGNoIG1pZGRsZXdhcmUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbmJ0b2EsIHJlcSwgcnBjVXJsLCBvcmlnaW5IdHRwSGVhZGVyS2V5LCB9KSB7XG4gICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChycGNVcmwpO1xuICAgIGNvbnN0IGZldGNoVXJsID0gbm9ybWFsaXplVXJsRnJvbVBhcnNlZChwYXJzZWRVcmwpO1xuICAgIC8vIHByZXBhcmUgcGF5bG9hZFxuICAgIC8vIGNvcHkgb25seSBjYW5vbmljYWwganNvbiBycGMgcHJvcGVydGllc1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgIGlkOiByZXEuaWQsXG4gICAgICAgIGpzb25ycGM6IHJlcS5qc29ucnBjLFxuICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgIHBhcmFtczogcmVxLnBhcmFtcyxcbiAgICB9O1xuICAgIC8vIGV4dHJhY3QgJ29yaWdpbicgcGFyYW1ldGVyIGZyb20gcmVxdWVzdFxuICAgIGNvbnN0IG9yaWdpbkRvbWFpbiA9IHJlcS5vcmlnaW47XG4gICAgLy8gc2VyaWFsaXplIHJlcXVlc3QgYm9keVxuICAgIGNvbnN0IHNlcmlhbGl6ZWRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZCk7XG4gICAgLy8gY29uZmlndXJlIGZldGNoIHBhcmFtc1xuICAgIGNvbnN0IGZldGNoUGFyYW1zID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBzZXJpYWxpemVkUGF5bG9hZCxcbiAgICB9O1xuICAgIC8vIGVuY29kZWQgYXV0aCBkZXRhaWxzIGFzIGhlYWRlciAobm90IGFsbG93ZWQgaW4gZmV0Y2ggdXJsKVxuICAgIGlmIChwYXJzZWRVcmwudXNlcm5hbWUgJiYgcGFyc2VkVXJsLnBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IGF1dGhTdHJpbmcgPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gICAgICAgIGNvbnN0IGVuY29kZWRBdXRoID0gYnRvYShhdXRoU3RyaW5nKTtcbiAgICAgICAgZmV0Y2hQYXJhbXMuaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJhc2ljICR7ZW5jb2RlZEF1dGh9YDtcbiAgICB9XG4gICAgLy8gb3B0aW9uYWw6IGFkZCByZXF1ZXN0IG9yaWdpbiBhcyBoZWFkZXJcbiAgICBpZiAob3JpZ2luSHR0cEhlYWRlcktleSAmJiBvcmlnaW5Eb21haW4pIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuaGVhZGVyc1tvcmlnaW5IdHRwSGVhZGVyS2V5XSA9IG9yaWdpbkRvbWFpbjtcbiAgICB9XG4gICAgcmV0dXJuIHsgZmV0Y2hVcmwsIGZldGNoUGFyYW1zIH07XG59XG5leHBvcnRzLmNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSA9IGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVybEZyb21QYXJzZWQocGFyc2VkVXJsKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIHJlc3VsdCArPSBwYXJzZWRVcmwucHJvdG9jb2w7XG4gICAgcmVzdWx0ICs9IGAvLyR7cGFyc2VkVXJsLmhvc3RuYW1lfWA7XG4gICAgaWYgKHBhcnNlZFVybC5wb3J0KSB7XG4gICAgICAgIHJlc3VsdCArPSBgOiR7cGFyc2VkVXJsLnBvcnR9YDtcbiAgICB9XG4gICAgcmVzdWx0ICs9IGAke3BhcnNlZFVybC5wYXRobmFtZX1gO1xuICAgIHJlc3VsdCArPSBgJHtwYXJzZWRVcmwuc2VhcmNofWA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJhdGVsaW1pdEVycm9yKCkge1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoeyBtZXNzYWdlOiBgUmVxdWVzdCBpcyBiZWluZyByYXRlIGxpbWl0ZWQuYCB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVvdXRFcnJvcigpIHtcbiAgICBsZXQgbXNnID0gYEdhdGV3YXkgdGltZW91dC4gVGhlIHJlcXVlc3QgdG9vayB0b28gbG9uZyB0byBwcm9jZXNzLiBgO1xuICAgIG1zZyArPSBgVGhpcyBjYW4gaGFwcGVuIHdoZW4gcXVlcnlpbmcgbG9ncyBvdmVyIHRvbyB3aWRlIGEgYmxvY2sgcmFuZ2UuYDtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHsgbWVzc2FnZTogbXNnIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay1jYWNoZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stcmVmLXJld3JpdGVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLXJlZlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stdHJhY2tlci1pbnNwZWN0b3JcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2ZldGNoXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9pbmZsaWdodC1jYWNoZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJBc01pZGRsZXdhcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3JldHJ5T25FbXB0eVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2FsbGV0XCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGNsb25lXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNsb25lXCIpKTtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5jb25zdCBsb2cgPSBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAnaW5mbGlnaHQtY2FjaGUnKTtcbmZ1bmN0aW9uIGNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlKCkge1xuICAgIGNvbnN0IGluZmxpZ2h0UmVxdWVzdHMgPSB7fTtcbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICAvLyBhbGxvdyBjYWNoIHRvIGJlIHNraXBwZWQgaWYgc28gc3BlY2lmaWVkXG4gICAgICAgIGlmIChyZXEuc2tpcENhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBjYWNoZUlkLCBpZiBjYWNoZWFibGVcbiAgICAgICAgY29uc3QgY2FjaGVJZCA9IGNhY2hlXzEuY2FjaGVJZGVudGlmaWVyRm9yUmVxdWVzdChyZXEpO1xuICAgICAgICAvLyBpZiBub3QgY2FjaGVhYmxlLCBza2lwXG4gICAgICAgIGlmICghY2FjaGVJZCkge1xuICAgICAgICAgICAgbG9nKCdSZXF1ZXN0IGlzIG5vdCBjYWNoZWFibGUsIHByb2NlZWRpbmcuIHJlcSA9ICVvJywgcmVxKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1hdGNoaW5nIHJlcXVlc3RzXG4gICAgICAgIGxldCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMgPSBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdO1xuICAgICAgICAvLyBpZiBmb3VuZCwgd2FpdCBmb3IgdGhlIGFjdGl2ZSByZXF1ZXN0IHRvIGJlIGhhbmRsZWRcbiAgICAgICAgaWYgKGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgICAgICAgICAgLy8gc2V0dXAgdGhlIHJlc3BvbnNlIGxpc3RlbmVyIGFuZCB3YWl0IGZvciBpdCB0byBiZSBjYWxsZWRcbiAgICAgICAgICAgIC8vIGl0IHdpbGwgaGFuZGxlIGNvcHlpbmcgdGhlIHJlc3VsdCBhbmQgcmVxdWVzdCBmaWVsZHNcbiAgICAgICAgICAgIGxvZygnUnVubmluZyAlaSBoYW5kbGVyKHMpIGZvciByZXF1ZXN0ICVvJywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmxlbmd0aCwgcmVxKTtcbiAgICAgICAgICAgIGF3YWl0IGNyZWF0ZUFjdGl2ZVJlcXVlc3RIYW5kbGVyKHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0dXAgcmVzcG9uc2UgaGFuZGxlciBhcnJheSBmb3Igc3Vic2VxdWVudCByZXF1ZXN0c1xuICAgICAgICBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMgPSBbXTtcbiAgICAgICAgaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXSA9IGFjdGl2ZVJlcXVlc3RIYW5kbGVycztcbiAgICAgICAgLy8gYWxsb3cgcmVxdWVzdCB0byBiZSBoYW5kbGVkIG5vcm1hbGx5XG4gICAgICAgIGxvZygnQ2Fycnlpbmcgb3JpZ2luYWwgcmVxdWVzdCBmb3J3YXJkICVvJywgcmVxKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgIGF3YWl0IG5leHQoKTtcbiAgICAgICAgLy8gY2xlYXIgaW5mbGlnaHQgcmVxdWVzdHNcbiAgICAgICAgZGVsZXRlIGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF07XG4gICAgICAgIC8vIHNjaGVkdWxlIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyB0byBiZSBoYW5kbGVkXG4gICAgICAgIGxvZygnUnVubmluZyAlaSBjb2xsZWN0ZWQgaGFuZGxlcihzKSBmb3IgcmVxdWVzdCAlbycsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5sZW5ndGgsIHJlcSk7XG4gICAgICAgIGhhbmRsZUFjdGl2ZVJlcXVlc3QocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpO1xuICAgICAgICAvLyBjb21wbGV0ZVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdGl2ZVJlcXVlc3RIYW5kbGVyKHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZSwgcHJvbWlzZSB9ID0gZGVmZXJyZWRQcm9taXNlKCk7XG4gICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5wdXNoKChoYW5kbGVkUmVzKSA9PiB7XG4gICAgICAgICAgICAvLyBhcHBlbmQgYSBjb3B5IG9mIHRoZSByZXN1bHQgYW5kIGVycm9yIHRvIHRoZSByZXNwb25zZVxuICAgICAgICAgICAgcmVzLnJlc3VsdCA9IGNsb25lXzEuZGVmYXVsdChoYW5kbGVkUmVzLnJlc3VsdCk7XG4gICAgICAgICAgICByZXMuZXJyb3IgPSBjbG9uZV8xLmRlZmF1bHQoaGFuZGxlZFJlcy5lcnJvcik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgICAgICAvLyB1c2Ugc2V0VGltZW91dCBzbyB3ZSBjYW4gcmVzb2x2ZSBvdXIgb3JpZ2luYWwgcmVxdWVzdCBmaXJzdFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoIGVycm9yIHNvIGFsbCByZXF1ZXN0cyBhcmUgaGFuZGxlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlID0gY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmU7XG5mdW5jdGlvbiBkZWZlcnJlZFByb21pc2UoKSB7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcmVzb2x2ZSwgcHJvbWlzZSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mbGlnaHQtY2FjaGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZU1vZHVsZUxvZ2dlciA9IGV4cG9ydHMucHJvamVjdExvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlTW9kdWxlTG9nZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNyZWF0ZU1vZHVsZUxvZ2dlcjsgfSB9KTtcbmV4cG9ydHMucHJvamVjdExvZ2dlciA9IHV0aWxzXzEuY3JlYXRlUHJvamVjdExvZ2dlcignZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmctdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlID0gZXhwb3J0cy5wcm92aWRlckFzTWlkZGxld2FyZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHByb3ZpZGVyQXNNaWRkbGV3YXJlKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIChyZXEsIHJlcywgX25leHQsIGVuZCkgPT4ge1xuICAgICAgICAvLyBzZW5kIHJlcXVlc3QgdG8gcHJvdmlkZXJcbiAgICAgICAgcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSwgKGVyciwgcHJvdmlkZXJSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGZvcndhcmQgYW55IGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3B5IHByb3ZpZGVyIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBwcm92aWRlclJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLnByb3ZpZGVyQXNNaWRkbGV3YXJlID0gcHJvdmlkZXJBc01pZGRsZXdhcmU7XG5mdW5jdGlvbiBldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikge1xuICAgIHJldHVybiAocmVxLCByZXMsIF9uZXh0LCBlbmQpID0+IHtcbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0IHRvIHByb3ZpZGVyXG4gICAgICAgIHByb3ZpZGVyLnNlbmQocmVxLCAoZXJyLCBwcm92aWRlclJlcykgPT4ge1xuICAgICAgICAgICAgLy8gZm9yd2FyZCBhbnkgZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBjYXN0IHdoZW4gbmV4dCBtYWpvciBganNvbi1ycGMtZW5naW5lYCByZWxlYXNlIGlzIG91dFxuICAgICAgICAgICAgICAgIC8vIFRoZSBuZXh0IHJlbGVhc2UgY2hhbmdlcyBob3cgZXJyb3JzIGFyZSBwcm9wb2dhdGVkLlxuICAgICAgICAgICAgICAgIHJldHVybiBlbmQoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvcHkgcHJvdmlkZXIgcmVzcG9uc2Ugb250byBvcmlnaW5hbCByZXNwb25zZVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXMsIHByb3ZpZGVyUmVzKTtcbiAgICAgICAgICAgIHJldHVybiBlbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmUgPSBldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVyQXNNaWRkbGV3YXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xvbmVcIikpO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgcGlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwaWZ5XCIpKTtcbmNvbnN0IGxvZ2dpbmdfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmctdXRpbHNcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5jb25zdCB0aW1lb3V0XzEgPSByZXF1aXJlKFwiLi91dGlscy90aW1lb3V0XCIpO1xuLy9cbi8vIFJldHJ5T25FbXB0eU1pZGRsZXdhcmUgd2lsbCByZXRyeSBhbnkgcmVxdWVzdCB3aXRoIGFuIGVtcHR5IHJlc3BvbnNlIHRoYXQgaGFzXG4vLyBhIG51bWJlcmVkIGJsb2NrIHJlZmVyZW5jZSBhdCBvciBsb3dlciB0aGFuIHRoZSBibG9ja1RyYWNrZXIncyBsYXRlc3QgYmxvY2suXG4vLyBJdHMgdXNlZnVsIGZvciBkZWFsaW5nIHdpdGggbG9hZC1iYWxhbmNlZCBldGhlcmV1bSBKU09OIFJQQ1xuLy8gbm9kZXMgdGhhdCBhcmUgbm90IGFsd2F5cyBpbiBzeW5jIHdpdGggZWFjaCBvdGhlci5cbi8vXG5jb25zdCBsb2cgPSBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKGxvZ2dpbmdfdXRpbHNfMS5wcm9qZWN0TG9nZ2VyLCAncmV0cnktb24tZW1wdHknKTtcbi8vIGVtcHR5IHZhbHVlcyB1c2VkIHRvIGRldGVybWluZSBpZiBhIHJlcXVlc3Qgc2hvdWxkIGJlIHJldHJpZWRcbi8vIGA8bmlsPmAgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzE2OTI1XG5jb25zdCBlbXB0eVZhbHVlcyA9IFtcbiAgICB1bmRlZmluZWQsXG4gICAgbnVsbCxcbiAgICAnXFx1MDAzY25pbFxcdTAwM2UnLFxuXTtcbmZ1bmN0aW9uIGNyZWF0ZVJldHJ5T25FbXB0eU1pZGRsZXdhcmUoeyBwcm92aWRlciwgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICBpZiAoIXByb3ZpZGVyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwicHJvdmlkZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1JldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJibG9ja1RyYWNrZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9IGNhY2hlXzEuYmxvY2tUYWdQYXJhbUluZGV4KHJlcS5tZXRob2QpO1xuICAgICAgICAvLyBza2lwIGlmIG1ldGhvZCBkb2VzIG5vdCBpbmNsdWRlIGJsb2NrUmVmXG4gICAgICAgIGlmIChibG9ja1JlZkluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiBub3QgZXhhY3QgYmxvY2sgcmVmZXJlbmNlc1xuICAgICAgICBsZXQgYmxvY2tSZWYgPSBBcnJheS5pc0FycmF5KHJlcS5wYXJhbXMpXG4gICAgICAgICAgICA/IHJlcS5wYXJhbXNbYmxvY2tSZWZJbmRleF1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAvLyBvbWl0dGVkIGJsb2NrUmVmIGltcGxpZXMgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxvY2tSZWYgPSAnbGF0ZXN0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIG5vbi1udW1iZXIgYmxvY2sgcmVmZXJlbmNlXG4gICAgICAgIGlmIChbJ2xhdGVzdCcsICdwZW5kaW5nJ10uaW5jbHVkZXMoYmxvY2tSZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgYmxvY2sgcmVmZXJuY2UgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAgICAgIGNvbnN0IGJsb2NrUmVmTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrUmVmLnNsaWNlKDIpLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYmxvY2tSZWZOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2t1cCBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXJIZXggPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQobGF0ZXN0QmxvY2tOdW1iZXJIZXguc2xpY2UoMiksIDE2KTtcbiAgICAgICAgLy8gc2tpcCBpZiByZXF1ZXN0IGJsb2NrIG51bWJlciBpcyBoaWdoZXIgdGhhbiBjdXJyZW50XG4gICAgICAgIGlmIChibG9ja1JlZk51bWJlciA+IGxhdGVzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICBsb2coJ1JlcXVlc3RlZCBibG9jayBudW1iZXIgJW8gaXMgaGlnaGVyIHRoYW4gbGF0ZXN0IGJsb2NrIG51bWJlciAlbywgZmFsbGluZyB0aHJvdWdoIHRvIG9yaWdpbmFsIHJlcXVlc3QnLCBibG9ja1JlZk51bWJlciwgbGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBsb2coJ1JlcXVlc3RlZCBibG9jayBudW1iZXIgJW8gaXMgbm90IGhpZ2hlciB0aGFuIGxhdGVzdCBibG9jayBudW1iZXIgJW8sIHRyeWluZyByZXF1ZXN0IHVudGlsIG5vbi1lbXB0eSByZXNwb25zZSBpcyByZWNlaXZlZCcsIGJsb2NrUmVmTnVtYmVyLCBsYXRlc3RCbG9ja051bWJlcik7XG4gICAgICAgIC8vIGNyZWF0ZSBjaGlsZCByZXF1ZXN0IHdpdGggc3BlY2lmaWMgYmxvY2stcmVmXG4gICAgICAgIGNvbnN0IGNoaWxkUmVxdWVzdCA9IGNsb25lXzEuZGVmYXVsdChyZXEpO1xuICAgICAgICAvLyBhdHRlbXB0IGNoaWxkIHJlcXVlc3QgdW50aWwgbm9uLWVtcHR5IHJlc3BvbnNlIGlzIHJlY2VpdmVkXG4gICAgICAgIGNvbnN0IGNoaWxkUmVzcG9uc2UgPSBhd2FpdCByZXRyeSgxMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbG9nKCdQZXJmb3JtaW5nIHJlcXVlc3QgJW8nLCBjaGlsZFJlcXVlc3QpO1xuICAgICAgICAgICAgY29uc3QgYXR0ZW1wdFJlc3BvbnNlID0gYXdhaXQgcGlmeV8xLmRlZmF1bHQocHJvdmlkZXIuc2VuZEFzeW5jKS5jYWxsKHByb3ZpZGVyLCBjaGlsZFJlcXVlc3QpO1xuICAgICAgICAgICAgbG9nKCdSZXNwb25zZSBpcyAlbycsIGF0dGVtcHRSZXNwb25zZSk7XG4gICAgICAgICAgICAvLyB2ZXJpZnkgcmVzdWx0XG4gICAgICAgICAgICBpZiAoZW1wdHlWYWx1ZXMuaW5jbHVkZXMoYXR0ZW1wdFJlc3BvbnNlLnJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSBlbXB0eSByZXNwb25zZSBcIiR7SlNPTi5zdHJpbmdpZnkoYXR0ZW1wdFJlc3BvbnNlKX1cIiBmb3IgcmVxdWVzdCBcIiR7SlNPTi5zdHJpbmdpZnkoY2hpbGRSZXF1ZXN0KX1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0dGVtcHRSZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZygnQ29weWluZyByZXN1bHQgJW8gYW5kIGVycm9yICVvJywgY2hpbGRSZXNwb25zZS5yZXN1bHQsIGNoaWxkUmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICAvLyBjb3B5IGNoaWxkIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgcmVzLnJlc3VsdCA9IGNoaWxkUmVzcG9uc2UucmVzdWx0O1xuICAgICAgICByZXMuZXJyb3IgPSBjaGlsZFJlc3BvbnNlLmVycm9yO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlID0gY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZTtcbmFzeW5jIGZ1bmN0aW9uIHJldHJ5KG1heFJldHJpZXMsIGFzeW5jRm4pIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWF4UmV0cmllczsgaW5kZXgrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFzeW5jRm4oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2coJyhjYWxsICVpKSBSZXF1ZXN0IGZhaWxlZCwgd2FpdGluZyAxcyB0byByZXRyeSBhZ2Fpbi4uLicsIGluZGV4ICsgMSk7XG4gICAgICAgICAgICBhd2FpdCB0aW1lb3V0XzEudGltZW91dCgxMDAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2coJ1JldHJpZXMgZXhoYXVzdGVkJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gcmV0cmllcyBleGhhdXN0ZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5T25FbXB0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FjaGVUeXBlRm9yTWV0aG9kID0gZXhwb3J0cy5ibG9ja1RhZ1BhcmFtSW5kZXggPSBleHBvcnRzLmJsb2NrVGFnRm9yUmVxdWVzdCA9IGV4cG9ydHMuY2FuQ2FjaGUgPSBleHBvcnRzLmNhY2hlSWRlbnRpZmllckZvclJlcXVlc3QgPSBleHBvcnRzLkNhY2hlU3RyYXRlZ3kgPSB2b2lkIDA7XG5jb25zdCBzYWZlX3N0YWJsZV9zdHJpbmdpZnlfMSA9IHJlcXVpcmUoXCJzYWZlLXN0YWJsZS1zdHJpbmdpZnlcIik7XG5jb25zdCBzdHJpbmdpZnkgPSBzYWZlX3N0YWJsZV9zdHJpbmdpZnlfMS5jb25maWd1cmUoeyBiaWdpbnQ6IGZhbHNlLCBjaXJjdWxhclZhbHVlOiBFcnJvciB9KTtcbi8qKlxuICogVGhlIGNhY2hlIHN0cmF0ZWd5IHRvIHVzZSBmb3IgYSBnaXZlbiBtZXRob2QuXG4gKi9cbnZhciBDYWNoZVN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChDYWNoZVN0cmF0ZWd5KSB7XG4gICAgLyoqXG4gICAgICogQ2FjaGUgcGVyLWJsb2NrLlxuICAgICAqL1xuICAgIENhY2hlU3RyYXRlZ3lbXCJCbG9ja1wiXSA9IFwiYmxvY2tcIjtcbiAgICAvKipcbiAgICAgKiBDYWNoZSB1bnRpbCBhIGNoYWluIHJlb3JnYW5pemF0aW9uIG9jY3Vycy5cbiAgICAgKi9cbiAgICBDYWNoZVN0cmF0ZWd5W1wiRm9ya1wiXSA9IFwiZm9ya1wiO1xuICAgIC8qKlxuICAgICAqIE5ldmVyIGNhY2hlLlxuICAgICAqL1xuICAgIENhY2hlU3RyYXRlZ3lbXCJOZXZlclwiXSA9IFwibmV2ZXJcIjtcbiAgICAvKipcbiAgICAgKiBQZXJtYW5lbnRseSBjYWNoZS5cbiAgICAgKi9cbiAgICBDYWNoZVN0cmF0ZWd5W1wiUGVybWFuZW50XCJdID0gXCJwZXJtYVwiO1xufSkoQ2FjaGVTdHJhdGVneSA9IGV4cG9ydHMuQ2FjaGVTdHJhdGVneSB8fCAoZXhwb3J0cy5DYWNoZVN0cmF0ZWd5ID0ge30pKTtcbi8qXG4gKiBSZXR1cm4gYSBjYWNoZSBpZGVudGlmaWVyIGZvciB0aGUgZ2l2ZW4gcmVxdWVzdC5cbiAqXG4gKiBUaGlzIGlkZW50aWZpZXIgc2hvdWxkIGluY2x1ZGUgYW55IHJlcXVlc3QgZGV0YWlscyB0aGF0IG1pZ2h0IGltcGFjdCB0aGVcbiAqIHJlc3BvbnNlLCB3aXRoIHRoZSBleGNlcHRpb24gb2YgdGhlIGJsb2NrIHBhcmFtZXRlciBpZiB0aGUgYHNraXBCbG9ja1JlZmBcbiAqIG9wdGlvbiBpcyBzZXQsXG4gKlxuICogSWYgdGhlIHJlcXVlc3QgY2Fubm90IGJlIGNhY2hlZCwgdGhpcyB3aWxsIHJldHVybiBgbnVsbGAuXG4gKlxuICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdC5cbiAqIEBwYXJhbSBza2lwQmxvY2tSZWYgLSBTa2lwIHRoZSBibG9jayBwYXJhbWV0ZXIgd2hlbiBnZW5lcmF0aW5nIHRoZSBjYWNoZVxuICogaWRlbnRpZmllci5cbiAqIEByZXR1cm5zIFRoZSBjYWNoZSBpZGVudGlmaWVyIGZvciB0aGlzIHJlcXVlc3QsIG9yIGBudWxsYCBpZiBpdCBjYW4ndCBiZVxuICogY2FjaGVkLlxuICovXG5mdW5jdGlvbiBjYWNoZUlkZW50aWZpZXJGb3JSZXF1ZXN0KHJlcXVlc3QsIHNraXBCbG9ja1JlZikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzaW1wbGVQYXJhbXMgPSBza2lwQmxvY2tSZWZcbiAgICAgICAgPyBwYXJhbXNXaXRob3V0QmxvY2tUYWcocmVxdWVzdClcbiAgICAgICAgOiAoX2EgPSByZXF1ZXN0LnBhcmFtcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgaWYgKGNhbkNhY2hlKHJlcXVlc3QubWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gYCR7cmVxdWVzdC5tZXRob2R9OiR7c3RyaW5naWZ5KHNpbXBsZVBhcmFtcyl9YDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmNhY2hlSWRlbnRpZmllckZvclJlcXVlc3QgPSBjYWNoZUlkZW50aWZpZXJGb3JSZXF1ZXN0O1xuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG1ldGhvZCBjYW4gYmUgY2FjaGVkIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gbWV0aG9kIC0gVGhlIG1ldGhvZCB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG1ldGhvZCBjYW4gYmUgY2FjaGVkLlxuICovXG5mdW5jdGlvbiBjYW5DYWNoZShtZXRob2QpIHtcbiAgICByZXR1cm4gY2FjaGVUeXBlRm9yTWV0aG9kKG1ldGhvZCkgIT09IENhY2hlU3RyYXRlZ3kuTmV2ZXI7XG59XG5leHBvcnRzLmNhbkNhY2hlID0gY2FuQ2FjaGU7XG4vKipcbiAqIFJldHVybiB0aGUgYmxvY2sgcGFyYW1ldGVyIGZvciB0aGUgZ2l2ZW4gcmVxdWVzdCwgaWYgaXQgaGFzIG9uZS5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBKU09OLVJQQyByZXF1ZXN0LlxuICogQHJldHVybnMgVGhlIGJsb2NrIHBhcmFtZXRlciBpbiB0aGUgZ2l2ZW4gcmVxdWVzdCwgb3IgYHVuZGVmaW5lZGAgaWYgbm9uZSB3YXMgZm91bmQuXG4gKi9cbmZ1bmN0aW9uIGJsb2NrVGFnRm9yUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgaWYgKCFyZXF1ZXN0LnBhcmFtcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IGJsb2NrVGFnUGFyYW1JbmRleChyZXF1ZXN0Lm1ldGhvZCk7XG4gICAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgIUFycmF5LmlzQXJyYXkocmVxdWVzdC5wYXJhbXMpIHx8XG4gICAgICAgIGluZGV4ID49IHJlcXVlc3QucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gcmVxdWVzdC5wYXJhbXNbaW5kZXhdO1xufVxuZXhwb3J0cy5ibG9ja1RhZ0ZvclJlcXVlc3QgPSBibG9ja1RhZ0ZvclJlcXVlc3Q7XG4vKipcbiAqIFJldHVybiB0aGUgcmVxdWVzdCBwYXJhbWV0ZXJzIHdpdGhvdXQgdGhlIGJsb2NrIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBKU09OLVJQQyByZXF1ZXN0LlxuICogQHJldHVybnMgVGhlIHJlcXVlc3QgcGFyYW1ldGVycyB3aXRoIHRoZSBibG9jayBwYXJhbWV0ZXIgcmVtb3ZlZCwgaWYgb25lIHdhcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gcGFyYW1zV2l0aG91dEJsb2NrVGFnKHJlcXVlc3QpIHtcbiAgICBpZiAoIXJlcXVlc3QucGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocmVxdWVzdC5tZXRob2QpO1xuICAgIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICFBcnJheS5pc0FycmF5KHJlcXVlc3QucGFyYW1zKSB8fFxuICAgICAgICBpbmRleCA+PSByZXF1ZXN0LnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3QucGFyYW1zO1xuICAgIH1cbiAgICAvLyBldGhfZ2V0QmxvY2tCeU51bWJlciBoYXMgdGhlIGJsb2NrIHRhZyBmaXJzdCwgdGhlbiB0aGUgb3B0aW9uYWwgaW5jbHVkZVR4PyBwYXJhbVxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcmVxdWVzdC5wYXJhbXMuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiByZXF1ZXN0LnBhcmFtcy5zbGljZSgwLCBpbmRleCk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBibG9jayBwYXJhbWV0ZXIgZm9yIHRoZSBnaXZlbiBtZXRob2QuXG4gKlxuICogQHBhcmFtIG1ldGhvZCAtIEEgSlNPTi1SUEMgbWV0aG9kLlxuICogQHJldHVybnMgVGhlIGluZGV4IG9mIHRoZSBibG9jayBwYXJhbWV0ZXIgZm9yIHRoYXQgbWV0aG9kLCBvciBgdW5kZWZpbmVkYCBpZlxuICogdGhlcmUgaXMgbm8ga25vd24gYmxvY2sgcGFyYW1ldGVyLlxuICovXG5mdW5jdGlvbiBibG9ja1RhZ1BhcmFtSW5kZXgobWV0aG9kKSB7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMlxuICAgICAgICBjYXNlICdldGhfZ2V0U3RvcmFnZUF0JzpcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAvLyBibG9ja1RhZyBpcyBhdCBpbmRleCAxXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCYWxhbmNlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldENvZGUnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgICAgIGNhc2UgJ2V0aF9jYWxsJzpcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAvLyBibG9ja1RhZyBpcyBhdCBpbmRleCAwXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAvLyB0aGVyZSBpcyBubyBibG9ja1RhZ1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLmJsb2NrVGFnUGFyYW1JbmRleCA9IGJsb2NrVGFnUGFyYW1JbmRleDtcbi8qKlxuICogUmV0dXJuIHRoZSBjYWNoZSB0eXBlIHVzZWQgZm9yIHRoZSBnaXZlbiBtZXRob2QuXG4gKlxuICogQHBhcmFtIG1ldGhvZCAtIEEgSlNPTi1SUEMgbWV0aG9kLlxuICogQHJldHVybnMgVGhlIGNhY2hlIHR5cGUgdG8gdXNlIGZvciB0aGF0IG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVUeXBlRm9yTWV0aG9kKG1ldGhvZCkge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIC8vIGNhY2hlIHBlcm1hbmVudGx5XG4gICAgICAgIGNhc2UgJ3dlYjNfY2xpZW50VmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ3dlYjNfc2hhMyc6XG4gICAgICAgIGNhc2UgJ2V0aF9wcm90b2NvbFZlcnNpb24nOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldENvbXBpbGVycyc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlTExMJzpcbiAgICAgICAgY2FzZSAnZXRoX2NvbXBpbGVTb2xpZGl0eSc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlU2VycGVudCc6XG4gICAgICAgIGNhc2UgJ3NoaF92ZXJzaW9uJzpcbiAgICAgICAgY2FzZSAndGVzdF9wZXJtYUNhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiBDYWNoZVN0cmF0ZWd5LlBlcm1hbmVudDtcbiAgICAgICAgLy8gY2FjaGUgdW50aWwgZm9ya1xuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja051bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tOdW1iZXJBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUJ5QmxvY2tOdW1iZXJBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ3Rlc3RfZm9ya0NhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiBDYWNoZVN0cmF0ZWd5LkZvcms7XG4gICAgICAgIC8vIGNhY2hlIGZvciBibG9ja1xuICAgICAgICBjYXNlICdldGhfZ2FzUHJpY2UnOlxuICAgICAgICBjYXNlICdldGhfYmxvY2tOdW1iZXInOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgICAgIGNhc2UgJ2V0aF9jYWxsJzpcbiAgICAgICAgY2FzZSAnZXRoX2VzdGltYXRlR2FzJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEZpbHRlckxvZ3MnOlxuICAgICAgICBjYXNlICdldGhfZ2V0TG9ncyc6XG4gICAgICAgIGNhc2UgJ3Rlc3RfYmxvY2tDYWNoZSc6XG4gICAgICAgICAgICByZXR1cm4gQ2FjaGVTdHJhdGVneS5CbG9jaztcbiAgICAgICAgLy8gbmV2ZXIgY2FjaGVcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBDYWNoZVN0cmF0ZWd5Lk5ldmVyO1xuICAgIH1cbn1cbmV4cG9ydHMuY2FjaGVUeXBlRm9yTWV0aG9kID0gY2FjaGVUeXBlRm9yTWV0aG9kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRpbWVvdXQgPSB2b2lkIDA7XG4vKipcbiAqIFdhaXQgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSBkdXJhdGlvbiAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQuXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lLlxuICovXG5mdW5jdGlvbiB0aW1lb3V0KGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG59XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZW91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVXYWxsZXRNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3Qgc2lnVXRpbCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiQG1ldGFtYXNrL2V0aC1zaWctdXRpbFwiKSk7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuZnVuY3Rpb24gY3JlYXRlV2FsbGV0TWlkZGxld2FyZSh7IGdldEFjY291bnRzLCBwcm9jZXNzRGVjcnlwdE1lc3NhZ2UsIHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5LCBwcm9jZXNzRXRoU2lnbk1lc3NhZ2UsIHByb2Nlc3NQZXJzb25hbE1lc3NhZ2UsIHByb2Nlc3NUcmFuc2FjdGlvbiwgcHJvY2Vzc1NpZ25UcmFuc2FjdGlvbiwgcHJvY2Vzc1R5cGVkTWVzc2FnZSwgcHJvY2Vzc1R5cGVkTWVzc2FnZVYzLCBwcm9jZXNzVHlwZWRNZXNzYWdlVjQsIH0pIHtcbiAgICBpZiAoIWdldEFjY291bnRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0cy5nZXRBY2NvdW50cyBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICByZXR1cm4ganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlU2NhZmZvbGRNaWRkbGV3YXJlKHtcbiAgICAgICAgLy8gYWNjb3VudCBsb29rdXBzXG4gICAgICAgIGV0aF9hY2NvdW50czoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGxvb2t1cEFjY291bnRzKSxcbiAgICAgICAgZXRoX2NvaW5iYXNlOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUobG9va3VwRGVmYXVsdEFjY291bnQpLFxuICAgICAgICAvLyB0eCBzaWduYXR1cmVzXG4gICAgICAgIGV0aF9zZW5kVHJhbnNhY3Rpb246IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShzZW5kVHJhbnNhY3Rpb24pLFxuICAgICAgICBldGhfc2lnblRyYW5zYWN0aW9uOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoc2lnblRyYW5zYWN0aW9uKSxcbiAgICAgICAgLy8gbWVzc2FnZSBzaWduYXR1cmVzXG4gICAgICAgIGV0aF9zaWduOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoZXRoU2lnbiksXG4gICAgICAgIGV0aF9zaWduVHlwZWREYXRhOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoc2lnblR5cGVkRGF0YSksXG4gICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3YzOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUoc2lnblR5cGVkRGF0YVYzKSxcbiAgICAgICAgZXRoX3NpZ25UeXBlZERhdGFfdjQ6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShzaWduVHlwZWREYXRhVjQpLFxuICAgICAgICBwZXJzb25hbF9zaWduOiBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUocGVyc29uYWxTaWduKSxcbiAgICAgICAgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXk6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShlbmNyeXB0aW9uUHVibGljS2V5KSxcbiAgICAgICAgZXRoX2RlY3J5cHQ6IGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZShkZWNyeXB0TWVzc2FnZSksXG4gICAgICAgIHBlcnNvbmFsX2VjUmVjb3ZlcjoganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKHBlcnNvbmFsUmVjb3ZlciksXG4gICAgfSk7XG4gICAgLy9cbiAgICAvLyBhY2NvdW50IGxvb2t1cHNcbiAgICAvL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGxvb2t1cEFjY291bnRzKHJlcSwgcmVzKSB7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBnZXRBY2NvdW50cyhyZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBsb29rdXBEZWZhdWx0QWNjb3VudChyZXEsIHJlcykge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGdldEFjY291bnRzKHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhY2NvdW50c1swXSB8fCBudWxsO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIHRyYW5zYWN0aW9uIHNpZ25hdHVyZXNcbiAgICAvL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHNlbmRUcmFuc2FjdGlvbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UGFyYW1zID0gcmVxLnBhcmFtc1swXSB8fCB7fTtcbiAgICAgICAgdHhQYXJhbXMuZnJvbSA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHR4UGFyYW1zLmZyb20sIHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NTaWduVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eFBhcmFtcyA9IHJlcS5wYXJhbXNbMF0gfHwge307XG4gICAgICAgIHR4UGFyYW1zLmZyb20gPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcih0eFBhcmFtcy5mcm9tLCByZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1NpZ25UcmFuc2FjdGlvbih0eFBhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBtZXNzYWdlIHNpZ25hdHVyZXNcbiAgICAvL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGV0aFNpZ24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzRXRoU2lnbk1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogbWVzc2FnZSB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NFdGhTaWduTWVzc2FnZShtc2dQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UeXBlZERhdGEocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHlwZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzFdLCByZXEpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ1YxJztcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBtZXNzYWdlIH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1R5cGVkTWVzc2FnZShtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UeXBlZERhdGFWMyhyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUeXBlZE1lc3NhZ2VWMykge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICdWMyc7XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IHtcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUeXBlZE1lc3NhZ2VWMyhtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UeXBlZERhdGFWNChyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUeXBlZE1lc3NhZ2VWNCkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICdWNCc7XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IHtcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUeXBlZE1lc3NhZ2VWNChtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHBlcnNvbmFsU2lnbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NQZXJzb25hbE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9jZXNzIG5vcm1hbGx5XG4gICAgICAgIGNvbnN0IGZpcnN0UGFyYW0gPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBzZWNvbmRQYXJhbSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIC8vIG5vbi1zdGFuZGFyZCBcImV4dHJhUGFyYW1zXCIgdG8gYmUgYXBwZW5kZWQgdG8gb3VyIFwibXNnUGFyYW1zXCIgb2JqXG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgLy8gV2UgaW5pdGlhbGx5IGluY29ycmVjdGx5IG9yZGVyZWQgdGhlc2UgcGFyYW1ldGVycy5cbiAgICAgICAgLy8gVG8gZ3JhY2VmdWxseSByZXNwZWN0IHVzZXJzIHdobyBhZG9wdGVkIHRoaXMgQVBJIGVhcmx5LFxuICAgICAgICAvLyB3ZSBhcmUgY3VycmVudGx5IGdyYWNlZnVsbHkgcmVjb3ZlcmluZyBmcm9tIHRoZSB3cm9uZyBwYXJhbSBvcmRlclxuICAgICAgICAvLyB3aGVuIGl0IGlzIGNsZWFybHkgaWRlbnRpZmlhYmxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGF0IG1lYW5zIHdoZW4gdGhlIGZpcnN0IHBhcmFtIGlzIGRlZmluaXRlbHkgYW4gYWRkcmVzcyxcbiAgICAgICAgLy8gYW5kIHRoZSBzZWNvbmQgcGFyYW0gaXMgZGVmaW5pdGVseSBub3QsIGJ1dCBpcyBoZXguXG4gICAgICAgIGxldCBhZGRyZXNzLCBtZXNzYWdlO1xuICAgICAgICBpZiAocmVzZW1ibGVzQWRkcmVzcyhmaXJzdFBhcmFtKSAmJiAhcmVzZW1ibGVzQWRkcmVzcyhzZWNvbmRQYXJhbSkpIHtcbiAgICAgICAgICAgIGxldCB3YXJuaW5nID0gYFRoZSBldGhfcGVyc29uYWxTaWduIG1ldGhvZCByZXF1aXJlcyBwYXJhbXMgb3JkZXJlZCBgO1xuICAgICAgICAgICAgd2FybmluZyArPSBgW21lc3NhZ2UsIGFkZHJlc3NdLiBUaGlzIHdhcyBwcmV2aW91c2x5IGhhbmRsZWQgaW5jb3JyZWN0bHksIGA7XG4gICAgICAgICAgICB3YXJuaW5nICs9IGBhbmQgaGFzIGJlZW4gY29ycmVjdGVkIGF1dG9tYXRpY2FsbHkuIGA7XG4gICAgICAgICAgICB3YXJuaW5nICs9IGBQbGVhc2Ugc3dpdGNoIHRoaXMgcGFyYW0gb3JkZXIgZm9yIHNtb290aCBiZWhhdmlvciBpbiB0aGUgZnV0dXJlLmA7XG4gICAgICAgICAgICByZXMud2FybmluZyA9IHdhcm5pbmc7XG4gICAgICAgICAgICBhZGRyZXNzID0gZmlyc3RQYXJhbTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBzZWNvbmRQYXJhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBmaXJzdFBhcmFtO1xuICAgICAgICAgICAgYWRkcmVzcyA9IHNlY29uZFBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihhZGRyZXNzLCByZXEpO1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBtZXNzYWdlIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlc1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHBlcnNvbmFsUmVjb3ZlcihyZXEsIHJlcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IHNpZ1V0aWwucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlKHtcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gc2lnbmVyQWRkcmVzcztcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gZW5jcnlwdGlvblB1YmxpY0tleShyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHJlcS5wYXJhbXNbMF0sIHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleShhZGRyZXNzLCByZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBkZWNyeXB0TWVzc2FnZShyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NEZWNyeXB0TWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1sxXSwgcmVxKTtcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBjaXBoZXJ0ZXh0IH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc0RlY3J5cHRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyB1dGlsaXR5XG4gICAgLy9cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIGtleWhvbGRlciBhZGRyZXNzLCBhbmQgcmV0dXJucyBhIG5vcm1hbGl6ZWQgKGkuZS4gbG93ZXJjYXNlKVxuICAgICAqIGNvcHkgb2YgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIHZhbGlkYXRlIGFuZCBub3JtYWxpemUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcSAtIFRoZSByZXF1ZXN0IG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBub3JtYWxpemVkIGFkZHJlc3MsIGlmIHZhbGlkLiBPdGhlcndpc2UsIHRocm93c1xuICAgICAqIGFuIGVycm9yXG4gICAgICovXG4gICAgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIoYWRkcmVzcywgcmVxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYWRkcmVzcyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGFkZHJlc3MubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgcmVzZW1ibGVzQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHRoYXQgYW4gXCJ1bmF1dGhvcml6ZWRcIiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIHJlcXVlc3RlciBkb2VzIG5vdCBoYXZlIHRoZSBgZXRoX2FjY291bnRzYFxuICAgICAgICAgICAgLy8gcGVybWlzc2lvbi5cbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZ2V0QWNjb3VudHMocmVxKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBY2NvdW50cyA9IGFjY291bnRzLm1hcCgoX2FkZHJlc3MpID0+IF9hZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZEFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobm9ybWFsaXplZEFjY291bnRzLmluY2x1ZGVzKG5vcm1hbGl6ZWRBZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnByb3ZpZGVyLnVuYXV0aG9yaXplZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIHBhcmFtZXRlcnM6IG11c3QgcHJvdmlkZSBhbiBFdGhlcmV1bSBhZGRyZXNzLmAsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlV2FsbGV0TWlkZGxld2FyZSA9IGNyZWF0ZVdhbGxldE1pZGRsZXdhcmU7XG5mdW5jdGlvbiByZXNlbWJsZXNBZGRyZXNzKHN0cikge1xuICAgIC8vIGhleCBwcmVmaXggMiArIDIwIGJ5dGVzXG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT09IDIgKyAyMCAqIDI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13YWxsZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydEV4aGF1c3RpdmUgPSBleHBvcnRzLmFzc2VydFN0cnVjdCA9IGV4cG9ydHMuYXNzZXJ0ID0gZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGVycm9yIG9iamVjdCB3aXRoIGFcbiAqIGBtZXNzYWdlYCBwcm9wZXJ0eSwgc3VjaCBhcyBhbiBpbnN0YW5jZSBvZiBFcnJvci5cbiAqXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBvciBmYWxzZSwgZGVwZW5kaW5nIG9uIHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdtZXNzYWdlJyBpbiBlcnJvcjtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGNvbnN0cnVjdG9yLCBpLmUuLCBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB3aXRoXG4gKiB0aGUgYG5ld2Aga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gZm4gLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIG9yIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0NvbnN0cnVjdGFibGUoZm4pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZW9mICgoX2IgPSAoX2EgPSBmbiA9PT0gbnVsbCB8fCBmbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm4ucHJvdG90eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSA9PT0gJ3N0cmluZycpO1xufVxuLyoqXG4gKiBHZXQgdGhlIGVycm9yIG1lc3NhZ2UgZnJvbSBhbiB1bmtub3duIGVycm9yIG9iamVjdC4gSWYgdGhlIGVycm9yIG9iamVjdCBoYXNcbiAqIGEgYG1lc3NhZ2VgIHByb3BlcnR5LCB0aGF0IHByb3BlcnR5IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBzdHJpbmdpZmllZFxuICogZXJyb3Igb2JqZWN0IGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciBvYmplY3QgdG8gZ2V0IHRoZSBtZXNzYWdlIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAvLyBJZiB0aGUgZXJyb3IgZW5kcyB3aXRoIGEgcGVyaW9kLCByZW1vdmUgaXQsIGFzIHdlJ2xsIGFkZCBvdXIgb3duIHBlcmlvZC5cbiAgICBpZiAobWVzc2FnZS5lbmRzV2l0aCgnLicpKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG4vKipcbiAqIEluaXRpYWxpc2UgYW4ge0BsaW5rIEFzc2VydGlvbkVycm9yQ29uc3RydWN0b3J9IGVycm9yLlxuICpcbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdXNlLlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbmZ1bmN0aW9uIGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSkge1xuICAgIGlmIChpc0NvbnN0cnVjdGFibGUoRXJyb3JXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yV3JhcHBlcih7XG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEVycm9yV3JhcHBlcih7XG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfSk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IGVycm9yIGNsYXNzIHRoYXQgaXMgdGhyb3duIGlmIGFuIGFzc2VydGlvbiBmYWlscy5cbiAqL1xuY2xhc3MgQXNzZXJ0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSAnRVJSX0FTU0VSVElPTic7XG4gICAgfVxufVxuZXhwb3J0cy5Bc3NlcnRpb25FcnJvciA9IEFzc2VydGlvbkVycm9yO1xuLyoqXG4gKiBTYW1lIGFzIE5vZGUuanMgYXNzZXJ0LlxuICogSWYgdGhlIHZhbHVlIGlzIGZhbHN5LCB0aHJvd3MgYW4gZXJyb3IsIGRvZXMgbm90aGluZyBvdGhlcndpc2UuXG4gKlxuICogQHRocm93cyB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9IElmIHZhbHVlIGlzIGZhbHN5LlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHRlc3QgdGhhdCBzaG91bGQgYmUgdHJ1dGh5IHRvIHBhc3MuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIE1lc3NhZ2UgdG8gYmUgcGFzc2VkIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0gb3IgYW5cbiAqIHtAbGluayBFcnJvcn0gaW5zdGFuY2UgdG8gdGhyb3cuXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LiBJZiBhIGN1c3RvbSBlcnJvciBjbGFzcyBpcyBwcm92aWRlZCBmb3JcbiAqIHRoZSBgbWVzc2FnZWAgYXJndW1lbnQsIHRoaXMgYXJndW1lbnQgaXMgaWdub3JlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBtZXNzYWdlID0gJ0Fzc2VydGlvbiBmYWlsZWQuJywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIgPSBBc3NlcnRpb25FcnJvcikge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuLyoqXG4gKiBBc3NlcnQgYSB2YWx1ZSBhZ2FpbnN0IGEgU3VwZXJzdHJ1Y3Qgc3RydWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RydWN0IHRvIHZhbGlkYXRlIGFnYWluc3QuXG4gKiBAcGFyYW0gZXJyb3JQcmVmaXggLSBBIHByZWZpeCB0byBhZGQgdG8gdGhlIGVycm9yIG1lc3NhZ2UuIERlZmF1bHRzIHRvXG4gKiBcIkFzc2VydGlvbiBmYWlsZWRcIi5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFN0cnVjdCh2YWx1ZSwgc3RydWN0LCBlcnJvclByZWZpeCA9ICdBc3NlcnRpb24gZmFpbGVkJywgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIgPSBBc3NlcnRpb25FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICAgICgwLCBzdXBlcnN0cnVjdF8xLmFzc2VydCkodmFsdWUsIHN0cnVjdCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBnZXRFcnJvcihFcnJvcldyYXBwZXIsIGAke2Vycm9yUHJlZml4fTogJHtnZXRFcnJvck1lc3NhZ2UoZXJyb3IpfS5gKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFN0cnVjdCA9IGFzc2VydFN0cnVjdDtcbi8qKlxuICogVXNlIGluIHRoZSBkZWZhdWx0IGNhc2Ugb2YgYSBzd2l0Y2ggdGhhdCB5b3Ugd2FudCB0byBiZSBmdWxseSBleGhhdXN0aXZlLlxuICogVXNpbmcgdGhpcyBmdW5jdGlvbiBmb3JjZXMgdGhlIGNvbXBpbGVyIHRvIGVuZm9yY2UgZXhoYXVzdGl2aXR5IGR1cmluZ1xuICogY29tcGlsZS10aW1lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IG51bWJlciA9IDE7XG4gKiBzd2l0Y2ggKG51bWJlcikge1xuICogICBjYXNlIDA6XG4gKiAgICAgLi4uXG4gKiAgIGNhc2UgMTpcbiAqICAgICAuLi5cbiAqICAgZGVmYXVsdDpcbiAqICAgICBhc3NlcnRFeGhhdXN0aXZlKHNuYXBQcmVmaXgpO1xuICogfVxuICogYGBgXG4gKiBAcGFyYW0gX29iamVjdCAtIFRoZSBvYmplY3Qgb24gd2hpY2ggdGhlIHN3aXRjaCBpcyBiZWluZyBvcGVyYXRlZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0RXhoYXVzdGl2ZShfb2JqZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJyYW5jaCByZWFjaGVkLiBTaG91bGQgYmUgZGV0ZWN0ZWQgZHVyaW5nIGNvbXBpbGF0aW9uLicpO1xufVxuZXhwb3J0cy5hc3NlcnRFeGhhdXN0aXZlID0gYXNzZXJ0RXhoYXVzdGl2ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzc2VydC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmFzZTY0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHByb3ZpZGVkIHN0cmluZy1iYXNlZCBzdHJ1Y3QgaXMgdmFsaWQgYmFzZTY0LlxuICpcbiAqIEBwYXJhbSBzdHJ1Y3QgLSBUaGUgc3RyaW5nIGJhc2VkIHN0cnVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9uYWwgb3B0aW9ucyB0byBzcGVjaWFsaXplIGJhc2U2NCB2YWxpZGF0aW9uLiBTZWUge0BsaW5rIEJhc2U2NE9wdGlvbnN9IGRvY3VtZW50YXRpb24uXG4gKiBAcmV0dXJucyBBIHN1cGVyc3RydWN0IHZhbGlkYXRpbmcgYmFzZTY0LlxuICovXG5jb25zdCBiYXNlNjQgPSAoc3RydWN0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHBhZGRpbmdSZXF1aXJlZCA9IChfYSA9IG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICBjb25zdCBjaGFyYWN0ZXJTZXQgPSAoX2IgPSBvcHRpb25zLmNoYXJhY3RlclNldCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Jhc2U2NCc7XG4gICAgbGV0IGxldHRlcnM7XG4gICAgaWYgKGNoYXJhY3RlclNldCA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgbGV0dGVycyA9IFN0cmluZy5yYXcgYFtBLVphLXowLTkrXFwvXWA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjR1cmwnKTtcbiAgICAgICAgbGV0dGVycyA9IFN0cmluZy5yYXcgYFstX0EtWmEtejAtOV1gO1xuICAgIH1cbiAgICBsZXQgcmU7XG4gICAgaWYgKHBhZGRpbmdSZXF1aXJlZCkge1xuICAgICAgICByZSA9IG5ldyBSZWdFeHAoYF4oPzoke2xldHRlcnN9ezR9KSooPzoke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXsyLDN9fCR7bGV0dGVyc317M309fCR7bGV0dGVyc317Mn09PSk/JGAsICd1Jyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5wYXR0ZXJuKShzdHJ1Y3QsIHJlKTtcbn07XG5leHBvcnRzLmJhc2U2NCA9IGJhc2U2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRGF0YVZpZXcgPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy52YWx1ZVRvQnl0ZXMgPSBleHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBleHBvcnRzLm51bWJlclRvQnl0ZXMgPSBleHBvcnRzLnNpZ25lZEJpZ0ludFRvQnl0ZXMgPSBleHBvcnRzLmJpZ0ludFRvQnl0ZXMgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBleHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBleHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBleHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmFzc2VydElzQnl0ZXMgPSBleHBvcnRzLmlzQnl0ZXMgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmNvbnN0IGhleF8xID0gcmVxdWlyZShcIi4vaGV4XCIpO1xuLy8gJzAnLmNoYXJDb2RlQXQoMCkgPT09IDQ4XG5jb25zdCBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSID0gNDg7XG4vLyAnOScuY2hhckNvZGVBdCgwKSA9PT0gNTdcbmNvbnN0IEhFWF9NQVhJTVVNX05VTUJFUl9DSEFSQUNURVIgPSA1ODtcbmNvbnN0IEhFWF9DSEFSQUNURVJfT0ZGU0VUID0gODc7XG4vKipcbiAqIE1lbW9pemVkIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSB0byBiZSB1c2VkIGFzIGEgbG9va3VwIHRhYmxlIGZvclxuICogY29udmVydGluZyBieXRlcyB0byBoZXhhZGVjaW1hbCB2YWx1ZXMuXG4gKlxuICogVGhlIGFycmF5IGlzIGNyZWF0ZWQgbGF6aWx5IGFuZCB0aGVuIGNhY2hlZCBmb3IgZnV0dXJlIHVzZS4gVGhlIGJlbmVmaXQgb2ZcbiAqIHRoaXMgYXBwcm9hY2ggaXMgdGhhdCB0aGUgcGVyZm9ybWFuY2Ugb2YgY29udmVydGluZyBieXRlcyB0byBoZXggaXMgbXVjaFxuICogYmV0dGVyIHRoYW4gaWYgd2Ugd2VyZSB0byBjYWxsIGB0b1N0cmluZygxNilgIG9uIGVhY2ggYnl0ZS5cbiAqXG4gKiBUaGUgZG93bnNpZGUgaXMgdGhhdCB0aGUgYXJyYXkgaXMgY3JlYXRlZCBvbmNlIGFuZCB0aGVuIG5ldmVyIGdhcmJhZ2VcbiAqIGNvbGxlY3RlZC4gVGhpcyBpcyBub3QgYSBwcm9ibGVtIGluIHByYWN0aWNlIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgMjU2XG4gKiBlbGVtZW50cyBsb25nLlxuICpcbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBsb29rdXAgdGFibGUuXG4gKi9cbmZ1bmN0aW9uIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpIHtcbiAgICAvLyBUbyBhdm9pZCBpc3N1ZXMgd2l0aCB0cmVlIHNoYWtpbmcsIHdlIG5lZWQgdG8gdXNlIGEgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZVxuICAgIC8vIGFycmF5LiBUaGlzIGlzIGJlY2F1c2UgdGhlIGFycmF5IGlzIG9ubHkgdXNlZCBpbiB0aGUgYGJ5dGVzVG9IZXhgIGZ1bmN0aW9uXG4gICAgLy8gYW5kIGlmIHdlIHdlcmUgdG8gdXNlIGEgZ2xvYmFsIHZhcmlhYmxlLCB0aGUgYXJyYXkgbWlnaHQgYmUgcmVtb3ZlZCBieSB0aGVcbiAgICAvLyB0cmVlIHNoYWtlci5cbiAgICBjb25zdCBsb29rdXBUYWJsZSA9IFtdO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChsb29rdXBUYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZS5wdXNoKGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb29rdXBUYWJsZTtcbiAgICB9O1xufVxuLyoqXG4gKiBGdW5jdGlvbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUge0BsaW5rIGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcn1cbiAqIGZ1bmN0aW9uLlxuICovXG5jb25zdCBnZXRQcmVjb21wdXRlZEhleFZhbHVlcyA9IGdldFByZWNvbXB1dGVkSGV4VmFsdWVzQnVpbGRlcigpO1xuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc0J5dGVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheTtcbn1cbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0J5dGVzKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNCeXRlcyh2YWx1ZSksICdWYWx1ZSBtdXN0IGJlIGEgVWludDhBcnJheS4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNCeXRlcyA9IGFzc2VydElzQnl0ZXM7XG4vKipcbiAqIENvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgY29uc3QgbG9va3VwVGFibGUgPSBnZXRQcmVjb21wdXRlZEhleFZhbHVlcygpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gbmV3IEFycmF5KGJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBoZXhhZGVjaW1hbFtpXSA9IGxvb2t1cFRhYmxlW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBoZXhfMS5hZGQweCkoaGV4YWRlY2ltYWwuam9pbignJykpO1xufVxuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBgVWludDhBcnJheWAgdG8gYSBgbnVtYmVyYCBpbnN0ZWFkLCB1c2Uge0BsaW5rIGJ5dGVzVG9OdW1iZXJ9LlxuICogVG8gY29udmVydCBhIHR3bydzIGNvbXBsZW1lbnQgZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgYmlnaW50YCwgdXNlXG4gKiB7QGxpbmsgYnl0ZXNUb1NpZ25lZEJpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YC5cbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0JpZ0ludChieXRlcykge1xuICAgIGFzc2VydElzQnl0ZXMoYnl0ZXMpO1xuICAgIGNvbnN0IGhleGFkZWNpbWFsID0gYnl0ZXNUb0hleChieXRlcyk7XG4gICAgcmV0dXJuIEJpZ0ludChoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLmJ5dGVzVG9CaWdJbnQgPSBieXRlc1RvQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgc2lnbmVkIGBiaWdpbnRgLiBUaGlzIGFzc3VtZXMgdGhhdCB0aGUgYnl0ZXMgYXJlXG4gKiBlbmNvZGVkIGluIHR3bydzIGNvbXBsZW1lbnQuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhbiB1bnNpZ25lZCBgYmlnaW50YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBieXRlc1RvQmlnSW50fS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBzaWduZWQgYGJpZ2ludGAuXG4gKiBAcmV0dXJucyBUaGUgc2lnbmVkIGBiaWdpbnRgLlxuICovXG5mdW5jdGlvbiBieXRlc1RvU2lnbmVkQmlnSW50KGJ5dGVzKSB7XG4gICAgYXNzZXJ0SXNCeXRlcyhieXRlcyk7XG4gICAgbGV0IHZhbHVlID0gQmlnSW50KDApO1xuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBCaWdJbnQoOCkpICsgQmlnSW50KGJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gQmlnSW50LmFzSW50TihieXRlcy5sZW5ndGggKiA4LCB2YWx1ZSk7XG59XG5leHBvcnRzLmJ5dGVzVG9TaWduZWRCaWdJbnQgPSBieXRlc1RvU2lnbmVkQmlnSW50O1xuLyoqXG4gKiBDb252ZXJ0IGEgYFVpbnQ4QXJyYXlgIHRvIGEgYG51bWJlcmAuXG4gKlxuICogVG8gY29udmVydCBhIGBVaW50OEFycmF5YCB0byBhIGBiaWdpbnRgIGluc3RlYWQsIHVzZSB7QGxpbmsgYnl0ZXNUb0JpZ0ludH0uXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGJ5dGVzIHRvIGNvbnZlcnQgdG8gYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyLlxuICogQHRocm93cyBJZiB0aGUgcmVzdWx0aW5nIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXIoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICBjb25zdCBiaWdpbnQgPSBieXRlc1RvQmlnSW50KGJ5dGVzKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShiaWdpbnQgPD0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSwgJ051bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuIFVzZSBgYnl0ZXNUb0JpZ0ludGAgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gTnVtYmVyKGJpZ2ludCk7XG59XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXIgPSBieXRlc1RvTnVtYmVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAgdG8gYSBgc3RyaW5nYC5cbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgYnl0ZXMgdG8gY29udmVydCB0byBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICBhc3NlcnRJc0J5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgVWludDhBcnJheWAuIFRoZSBzdHJpbmcgY2FuIG9wdGlvbmFsbHkgYmVcbiAqIHByZWZpeGVkIHdpdGggYDB4YC4gSXQgYWNjZXB0cyBldmVuIGFuZCBvZGQgbGVuZ3RoIHN0cmluZ3MuXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIFwiMHhcIiwgYW4gZW1wdHkgYFVpbnQ4QXJyYXlgIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXModmFsdWUpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gXCIweFwiIGlzIG9mdGVuIHVzZWQgYXMgZW1wdHkgYnl0ZSBhcnJheS5cbiAgICBpZiAoKChfYSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS50b0xvd2VyQ2FzZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodmFsdWUpKSA9PT0gJzB4Jykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICB9XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gUmVtb3ZlIHRoZSBgMHhgIHByZWZpeCBpZiBpdCBleGlzdHMsIGFuZCBwYWQgdGhlIHN0cmluZyB0byBoYXZlIGFuIGV2ZW5cbiAgICAvLyBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICBjb25zdCBzdHJpcHBlZFZhbHVlID0gKDAsIGhleF8xLnJlbW92ZTB4KSh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSBzdHJpcHBlZFZhbHVlLmxlbmd0aCAlIDIgPT09IDAgPyBzdHJpcHBlZFZhbHVlIDogYDAke3N0cmlwcGVkVmFsdWV9YDtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KG5vcm1hbGl6ZWRWYWx1ZS5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHRoaXMgaXMgbm90IHRoZSBwcmV0dGllc3Qgd2F5IHRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYVxuICAgICAgICAvLyBgVWludDhBcnJheWAsIGl0IGlzIGEgbG90IGZhc3RlciB0aGFuIHVzaW5nIGBwYXJzZUludGAgdG8gY29udmVydCBlYWNoXG4gICAgICAgIC8vIGNoYXJhY3Rlci5cbiAgICAgICAgY29uc3QgYzEgPSBub3JtYWxpemVkVmFsdWUuY2hhckNvZGVBdChpICogMik7XG4gICAgICAgIGNvbnN0IGMyID0gbm9ybWFsaXplZFZhbHVlLmNoYXJDb2RlQXQoaSAqIDIgKyAxKTtcbiAgICAgICAgY29uc3QgbjEgPSBjMSAtXG4gICAgICAgICAgICAoYzEgPCBIRVhfTUFYSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgPyBIRVhfTUlOSU1VTV9OVU1CRVJfQ0hBUkFDVEVSXG4gICAgICAgICAgICAgICAgOiBIRVhfQ0hBUkFDVEVSX09GRlNFVCk7XG4gICAgICAgIGNvbnN0IG4yID0gYzIgLVxuICAgICAgICAgICAgKGMyIDwgSEVYX01BWElNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgID8gSEVYX01JTklNVU1fTlVNQkVSX0NIQVJBQ1RFUlxuICAgICAgICAgICAgICAgIDogSEVYX0NIQVJBQ1RFUl9PRkZTRVQpO1xuICAgICAgICBieXRlc1tpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgLlxuICpcbiAqIFRoaXMgYXNzdW1lcyB0aGF0IHRoZSBgYmlnaW50YCBpcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLiBUbyBjb252ZXJ0IGEgc2lnbmVkXG4gKiBgYmlnaW50YCBpbnN0ZWFkLCB1c2Uge0BsaW5rIHNpZ25lZEJpZ0ludFRvQnl0ZXN9LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBiaWdpbnQgdG8gY29udmVydCB0byBieXRlcy5cbiAqIEByZXR1cm5zIFRoZSBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJpZ0ludFRvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnLCAnVmFsdWUgbXVzdCBiZSBhIGJpZ2ludC4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSBCaWdJbnQoMCksICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGJpZ2ludC4nKTtcbiAgICBjb25zdCBoZXhhZGVjaW1hbCA9IHZhbHVlLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhoZXhhZGVjaW1hbCk7XG59XG5leHBvcnRzLmJpZ0ludFRvQnl0ZXMgPSBiaWdJbnRUb0J5dGVzO1xuLyoqXG4gKiBDaGVjayBpZiBhIGBiaWdpbnRgIGZpdHMgaW4gYSBjZXJ0YWluIG51bWJlciBvZiBieXRlcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgdG8gY2hlY2suXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUgbnVtYmVyIG9mIGJ5dGVzLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgYGJpZ2ludGAgZml0cyBpbiB0aGUgbnVtYmVyIG9mIGJ5dGVzLlxuICovXG5mdW5jdGlvbiBiaWdJbnRGaXRzKHZhbHVlLCBieXRlcykge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJ5dGVzID4gMCk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAgIGNvbnN0IG1hc2sgPSB2YWx1ZSA+PiBCaWdJbnQoMzEpO1xuICAgIHJldHVybiAhKCgofnZhbHVlICYgbWFzaykgKyAodmFsdWUgJiB+bWFzaykpID4+IEJpZ0ludChieXRlcyAqIDggKyB+MCkpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tYml0d2lzZSAqL1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmVkIGBiaWdpbnRgIHRvIGEgYFVpbnQ4QXJyYXlgLiBUaGlzIHVzZXMgdHdvJ3MgY29tcGxlbWVudFxuICogZW5jb2RpbmcgdG8gcmVwcmVzZW50IG5lZ2F0aXZlIG51bWJlcnMuXG4gKlxuICogVG8gY29udmVydCBhbiB1bnNpZ25lZCBgYmlnaW50YCB0byBhIGBVaW50OEFycmF5YCBpbnN0ZWFkLCB1c2VcbiAqIHtAbGluayBiaWdJbnRUb0J5dGVzfS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1R3byUyN3NfY29tcGxlbWVudFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHBhcmFtIGJ5dGVMZW5ndGggLSBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgYFVpbnQ4QXJyYXlgLiBJZiB0aGUgbnVtYmVyXG4gKiBpcyBsYXJnZXIgdGhhbiB0aGUgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gbGVuZ3RoLFxuICogYW4gZXJyb3IgaXMgdGhyb3duLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gc2lnbmVkQmlnSW50VG9CeXRlcyh2YWx1ZSwgYnl0ZUxlbmd0aCkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiBieXRlTGVuZ3RoID09PSAnbnVtYmVyJywgJ0J5dGUgbGVuZ3RoIG11c3QgYmUgYSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoYnl0ZUxlbmd0aCA+IDAsICdCeXRlIGxlbmd0aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwLicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKGJpZ0ludEZpdHModmFsdWUsIGJ5dGVMZW5ndGgpLCAnQnl0ZSBsZW5ndGggaXMgdG9vIHNtYWxsIHRvIHJlcHJlc2VudCB0aGUgZ2l2ZW4gdmFsdWUuJyk7XG4gICAgLy8gRVNMaW50IGRvZXNuJ3QgbGlrZSBtdXRhdGluZyBmdW5jdGlvbiBwYXJhbWV0ZXJzLCBzbyB0byBhdm9pZCBoYXZpbmcgdG9cbiAgICAvLyBkaXNhYmxlIHRoZSBydWxlLCB3ZSBjcmVhdGUgYSBuZXcgdmFyaWFibGUuXG4gICAgbGV0IG51bWJlclZhbHVlID0gdmFsdWU7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShieXRlTGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gTnVtYmVyKEJpZ0ludC5hc1VpbnROKDgsIG51bWJlclZhbHVlKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIG51bWJlclZhbHVlID4+PSBCaWdJbnQoOCk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcy5yZXZlcnNlKCk7XG59XG5leHBvcnRzLnNpZ25lZEJpZ0ludFRvQnl0ZXMgPSBzaWduZWRCaWdJbnRUb0J5dGVzO1xuLyoqXG4gKiBDb252ZXJ0IGEgYG51bWJlcmAgdG8gYSBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIG51bWJlciB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqIEB0aHJvd3MgSWYgdGhlIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXModmFsdWUpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnVmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpLCAnVmFsdWUgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJpZ0ludFRvQnl0ZXNgIGluc3RlYWQuJyk7XG4gICAgY29uc3QgaGV4YWRlY2ltYWwgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMoaGV4YWRlY2ltYWwpO1xufVxuZXhwb3J0cy5udW1iZXJUb0J5dGVzID0gbnVtYmVyVG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGBzdHJpbmdgIHRvIGEgVVRGLTggZW5jb2RlZCBgVWludDhBcnJheWAuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHN0cmluZyB0byBjb252ZXJ0IHRvIGJ5dGVzLlxuICogQHJldHVybnMgVGhlIGJ5dGVzIGFzIGBVaW50OEFycmF5YC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyh2YWx1ZSkge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsICdWYWx1ZSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xufVxuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gc3RyaW5nVG9CeXRlcztcbi8qKlxuICogQ29udmVydCBhIGJ5dGUtbGlrZSB2YWx1ZSB0byBhIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlIGNhbiBiZSBhIGBVaW50OEFycmF5YCxcbiAqIGEgYGJpZ2ludGAsIGEgYG51bWJlcmAsIG9yIGEgYHN0cmluZ2AuXG4gKlxuICogVGhpcyB3aWxsIGF0dGVtcHQgdG8gZ3Vlc3MgdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGJhc2VkIG9uIGl0cyB0eXBlIGFuZFxuICogY29udGVudHMuIEZvciBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgY29udmVyc2lvbiwgdXNlIHRoZSBtb3JlIHNwZWNpZmljXG4gKiBjb252ZXJzaW9uIGZ1bmN0aW9ucywgc3VjaCBhcyB7QGxpbmsgaGV4VG9CeXRlc30gb3Ige0BsaW5rIHN0cmluZ1RvQnl0ZXN9LlxuICpcbiAqIElmIHRoZSB2YWx1ZSBpcyBhIGBzdHJpbmdgLCBhbmQgaXQgaXMgcHJlZml4ZWQgd2l0aCBgMHhgLCBpdCB3aWxsIGJlXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGludGVycHJldGVkIGFzIGFcbiAqIFVURi04IHN0cmluZy4gVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBieXRlcyB3aXRob3V0IGludGVycHJldGluZ1xuICogaXQgYXMgYSBVVEYtOCBzdHJpbmcsIHVzZSB7QGxpbmsgaGV4VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgYmlnaW50YCwgaXQgaXMgYXNzdW1lZCB0byBiZSB1bnNpZ25lZC4gVG8gY29udmVydCBhIHNpZ25lZFxuICogYGJpZ2ludGAgdG8gYnl0ZXMsIHVzZSB7QGxpbmsgc2lnbmVkQmlnSW50VG9CeXRlc30gaW5zdGVhZC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgaXMgYSBgVWludDhBcnJheWAsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgYnl0ZXMgYXMgYFVpbnQ4QXJyYXlgLlxuICovXG5mdW5jdGlvbiB2YWx1ZVRvQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICByZXR1cm4gYmlnSW50VG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBudW1iZXJUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHZhbHVlIHR5cGU6IFwiJHt0eXBlb2YgdmFsdWV9XCIuYCk7XG59XG5leHBvcnRzLnZhbHVlVG9CeXRlcyA9IHZhbHVlVG9CeXRlcztcbi8qKlxuICogQ29uY2F0ZW5hdGUgbXVsdGlwbGUgYnl0ZS1saWtlIHZhbHVlcyBpbnRvIGEgc2luZ2xlIGBVaW50OEFycmF5YC4gVGhlIHZhbHVlc1xuICogY2FuIGJlIGBVaW50OEFycmF5YCwgYGJpZ2ludGAsIGBudW1iZXJgLCBvciBgc3RyaW5nYC4gVGhpcyB1c2VzXG4gKiB7QGxpbmsgdmFsdWVUb0J5dGVzfSB1bmRlciB0aGUgaG9vZCB0byBjb252ZXJ0IGVhY2ggdmFsdWUgdG8gYnl0ZXMuIFJlZmVyIHRvXG4gKiB0aGUgZG9jdW1lbnRhdGlvbiBvZiB0aGF0IGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBieXRlcyBhcyBgVWludDhBcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKHZhbHVlcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgbGV0IGJ5dGVMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVUb0J5dGVzKHZhbHVlc1tpXSk7XG4gICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgYnl0ZUxlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCBub3JtYWxpemVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFdoaWxlIHdlIGNvdWxkIHNpbXBseSBzcHJlYWQgdGhlIHZhbHVlcyBpbnRvIGFuIGFycmF5IGFuZCB1c2VcbiAgICAgICAgLy8gYFVpbnQ4QXJyYXkuZnJvbWAsIHRoYXQgaXMgYSBsb3Qgc2xvd2VyIHRoYW4gdXNpbmcgYFVpbnQ4QXJyYXkuc2V0YC5cbiAgICAgICAgYnl0ZXMuc2V0KG5vcm1hbGl6ZWRWYWx1ZXNbaV0sIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBub3JtYWxpemVkVmFsdWVzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuLyoqXG4gKiBDcmVhdGUgYSB7QGxpbmsgRGF0YVZpZXd9IGZyb20gYSB7QGxpbmsgVWludDhBcnJheX0uIFRoaXMgaXMgYSBjb252ZW5pZW5jZVxuICogZnVuY3Rpb24gdGhhdCBhdm9pZHMgaGF2aW5nIHRvIGNyZWF0ZSBhIHtAbGluayBEYXRhVmlld30gbWFudWFsbHksIHdoaWNoXG4gKiByZXF1aXJlcyBwYXNzaW5nIHRoZSBgYnl0ZU9mZnNldGAgYW5kIGBieXRlTGVuZ3RoYCBwYXJhbWV0ZXJzIGV2ZXJ5IHRpbWUuXG4gKlxuICogTm90IHBhc3NpbmcgdGhlIGBieXRlT2Zmc2V0YCBhbmQgYGJ5dGVMZW5ndGhgIHBhcmFtZXRlcnMgY2FuIHJlc3VsdCBpblxuICogdW5leHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSB7QGxpbmsgVWludDhBcnJheX0gaXMgYSB2aWV3IG9mIGEgbGFyZ2VyXG4gKiB7QGxpbmsgQXJyYXlCdWZmZXJ9LCBlLmcuLCB3aGVuIHVzaW5nIHtAbGluayBVaW50OEFycmF5LnN1YmFycmF5fS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFsc28gc3VwcG9ydHMgTm9kZS5qcyB7QGxpbmsgQnVmZmVyfXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKTtcbiAqXG4gKiAvLyBUaGlzIGlzIGVxdWl2YWxlbnQgdG86XG4gKiAvLyBjb25zdCBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xuICogY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVEYXRhVmlldyhieXRlcyk7XG4gKiBgYGBcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBieXRlcyB0byBjcmVhdGUgdGhlIHtAbGluayBEYXRhVmlld30gZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgRGF0YVZpZXd9LlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYXRhVmlldyhieXRlcykge1xuICAgIC8vIFRvIG1haW50YWluIGNvbXBhdGliaWxpdHkgd2l0aCBOb2RlLmpzLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBieXRlcyBhcmVcbiAgICAvLyBhIEJ1ZmZlci4gSWYgc28sIHdlIG5lZWQgdG8gc2xpY2UgdGhlIGJ1ZmZlciB0byBnZXQgdGhlIHVuZGVybHlpbmdcbiAgICAvLyBBcnJheUJ1ZmZlci5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIGJ5dGVzIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ5dGVzLmJ1ZmZlci5zbGljZShieXRlcy5ieXRlT2Zmc2V0LCBieXRlcy5ieXRlT2Zmc2V0ICsgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJldHVybiBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpO1xufVxuZXhwb3J0cy5jcmVhdGVEYXRhVmlldyA9IGNyZWF0ZURhdGFWaWV3O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoZWNrc3VtU3RydWN0ID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbmNvbnN0IGJhc2U2NF8xID0gcmVxdWlyZShcIi4vYmFzZTY0XCIpO1xuZXhwb3J0cy5DaGVja3N1bVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLnNpemUpKCgwLCBiYXNlNjRfMS5iYXNlNjQpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgeyBwYWRkaW5nUmVxdWlyZWQ6IHRydWUgfSksIDQ0LCA0NCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3N1bS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSGV4ID0gZXhwb3J0cy5jcmVhdGVCeXRlcyA9IGV4cG9ydHMuY3JlYXRlQmlnSW50ID0gZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIi4vYnl0ZXNcIik7XG5jb25zdCBoZXhfMSA9IHJlcXVpcmUoXCIuL2hleFwiKTtcbmNvbnN0IE51bWJlckxpa2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS51bmlvbikoWygwLCBzdXBlcnN0cnVjdF8xLm51bWJlcikoKSwgKDAsIHN1cGVyc3RydWN0XzEuYmlnaW50KSgpLCAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksIGhleF8xLlN0cmljdEhleFN0cnVjdF0pO1xuY29uc3QgTnVtYmVyQ29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEubnVtYmVyKSgpLCBOdW1iZXJMaWtlU3RydWN0LCBOdW1iZXIpO1xuY29uc3QgQmlnSW50Q29lcmNlciA9ICgwLCBzdXBlcnN0cnVjdF8xLmNvZXJjZSkoKDAsIHN1cGVyc3RydWN0XzEuYmlnaW50KSgpLCBOdW1iZXJMaWtlU3RydWN0LCBCaWdJbnQpO1xuY29uc3QgQnl0ZXNMaWtlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtoZXhfMS5TdHJpY3RIZXhTdHJ1Y3QsICgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KV0pO1xuY29uc3QgQnl0ZXNDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKSgoMCwgc3VwZXJzdHJ1Y3RfMS5pbnN0YW5jZSkoVWludDhBcnJheSksICgwLCBzdXBlcnN0cnVjdF8xLnVuaW9uKShbaGV4XzEuU3RyaWN0SGV4U3RydWN0XSksIGJ5dGVzXzEuaGV4VG9CeXRlcyk7XG5jb25zdCBIZXhDb2VyY2VyID0gKDAsIHN1cGVyc3RydWN0XzEuY29lcmNlKShoZXhfMS5TdHJpY3RIZXhTdHJ1Y3QsICgwLCBzdXBlcnN0cnVjdF8xLmluc3RhbmNlKShVaW50OEFycmF5KSwgYnl0ZXNfMS5ieXRlc1RvSGV4KTtcbi8qKlxuICogQ3JlYXRlIGEgbnVtYmVyIGZyb20gYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBudW1iZXIuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgaXQgaXMgaW50ZXJwcmV0ZWQgYXMgYSBkZWNpbWFsIG51bWJlci5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgaGV4IHN0cmluZyAoaS5lLiwgaXQgc3RhcnRzIHdpdGggXCIweFwiKSwgaXQgaXNcbiAqIGludGVycHJldGVkIGFzIGEgaGV4YWRlY2ltYWwgbnVtYmVyLlxuICpcbiAqIFRoaXMgdmFsaWRhdGVzIHRoYXQgdGhlIHZhbHVlIGlzIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGFuZCB0aGF0IHRoZSByZXN1bHRpbmdcbiAqIG51bWJlciBpcyBub3QgYE5hTmAgb3IgYEluZmluaXR5YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVOdW1iZXIoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIDY2MDUxXG4gKlxuICogY29uc3Qgb3RoZXJWYWx1ZSA9IGNyZWF0ZU51bWJlcigxMjNuKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyAxMjNcbiAqIGBgYFxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNyZWF0ZSB0aGUgbnVtYmVyIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZSwgb3IgaWYgdGhlIHJlc3VsdGluZyBudW1iZXJcbiAqIGlzIGBOYU5gIG9yIGBJbmZpbml0eWAuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU51bWJlcih2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIE51bWJlckNvZXJjZXIpO1xuICAgICAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KShOdW1iZXIuaXNGaW5pdGUocmVzdWx0KSwgYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBzdXBlcnN0cnVjdF8xLlN0cnVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbnVtYmVyLWxpa2UgdmFsdWUsIGdvdCBcIiR7dmFsdWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVOdW1iZXIgPSBjcmVhdGVOdW1iZXI7XG4vKipcbiAqIENyZWF0ZSBhIGBiaWdpbnRgIGZyb20gYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIG51bWJlciwgaXQgaXMgY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGBiaWdpbnRgLCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nLCBpdCBpcyBpbnRlcnByZXRlZCBhcyBhIGRlY2ltYWwgbnVtYmVyIGFuZFxuICogY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzXG4gKiBpbnRlcnByZXRlZCBhcyBhIGhleGFkZWNpbWFsIG51bWJlciBhbmQgY29udmVydGVkIHRvIGEgYGJpZ2ludGAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHZhbHVlID0gY3JlYXRlQmlnSW50KCcweDAxMDIwMycpO1xuICogY29uc29sZS5sb2codmFsdWUpOyAvLyAxNjkwOTA2MG5cbiAqXG4gKiBjb25zdCBvdGhlclZhbHVlID0gY3JlYXRlQmlnSW50KDEyMyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gMTIzblxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBiaWdpbnQgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGJpZ2ludC5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIG51bWJlci1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCaWdJbnQodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUaGUgYEJpZ0ludGAgY29uc3RydWN0b3IgdGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXItbGlrZSB2YWx1ZS5cbiAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byB2YWxpZGF0ZSB0aGUgdmFsdWUgbWFudWFsbHkuXG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBCaWdJbnRDb2VyY2VyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHN1cGVyc3RydWN0XzEuU3RydWN0RXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYSBudW1iZXItbGlrZSB2YWx1ZSwgZ290IFwiJHtTdHJpbmcoZXJyb3IudmFsdWUpfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlQmlnSW50ID0gY3JlYXRlQmlnSW50O1xuLyoqXG4gKiBDcmVhdGUgYSBieXRlIGFycmF5IGZyb20gYSBieXRlcy1saWtlIHZhbHVlLlxuICpcbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYnl0ZSBhcnJheSwgaXQgaXMgcmV0dXJuZWQgYXMtaXMuXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzIGludGVycHJldGVkXG4gKiBhcyBhIGhleGFkZWNpbWFsIG51bWJlciBhbmQgY29udmVydGVkIHRvIGEgYnl0ZSBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgdmFsdWUgPSBjcmVhdGVCeXRlcygnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVCeXRlcygnMHgwMTAyMDMnKTtcbiAqIGNvbnNvbGUubG9nKG90aGVyVmFsdWUpOyAvLyBVaW50OEFycmF5IFsgMSwgMiwgMyBdXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjcmVhdGUgdGhlIGJ5dGUgYXJyYXkgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGJ5dGUgYXJyYXkuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBieXRlcy1saWtlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCeXRlcyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICcweCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5jcmVhdGUpKHZhbHVlLCBCeXRlc0NvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGJ5dGVzLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUJ5dGVzID0gY3JlYXRlQnl0ZXM7XG4vKipcbiAqIENyZWF0ZSBhIGhleGFkZWNpbWFsIHN0cmluZyBmcm9tIGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqXG4gKiAtIElmIHRoZSB2YWx1ZSBpcyBhIGhleCBzdHJpbmcgKGkuZS4sIGl0IHN0YXJ0cyB3aXRoIFwiMHhcIiksIGl0IGlzIHJldHVybmVkXG4gKiBhcy1pcy5cbiAqIC0gSWYgdGhlIHZhbHVlIGlzIGEgYFVpbnQ4QXJyYXlgLCBpdCBpcyBjb252ZXJ0ZWQgdG8gYSBoZXggc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCB2YWx1ZSA9IGNyZWF0ZUhleChuZXcgVWludDhBcnJheShbMSwgMiwgM10pKTtcbiAqIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gJzB4MDEwMjAzJ1xuICpcbiAqIGNvbnN0IG90aGVyVmFsdWUgPSBjcmVhdGVIZXgoJzB4MDEwMjAzJyk7XG4gKiBjb25zb2xlLmxvZyhvdGhlclZhbHVlKTsgLy8gJzB4MDEwMjAzJ1xuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY3JlYXRlIHRoZSBoZXggc3RyaW5nIGZyb20uXG4gKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBoZXggc3RyaW5nLlxuICogQHRocm93cyBJZiB0aGUgdmFsdWUgaXMgbm90IGEgYnl0ZXMtbGlrZSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGV4KHZhbHVlKSB7XG4gICAgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnMHgnKSkge1xuICAgICAgICByZXR1cm4gJzB4JztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmNyZWF0ZSkodmFsdWUsIEhleENvZXJjZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2Ygc3VwZXJzdHJ1Y3RfMS5TdHJ1Y3RFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIGJ5dGVzLWxpa2UgdmFsdWUsIGdvdCBcIiR7U3RyaW5nKGVycm9yLnZhbHVlKX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUhleCA9IGNyZWF0ZUhleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvZXJjZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9Gcm96ZW5NYXBfbWFwLCBfRnJvemVuU2V0X3NldDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnJvemVuU2V0ID0gZXhwb3J0cy5Gcm96ZW5NYXAgPSB2b2lkIDA7XG4vKipcbiAqIEEge0BsaW5rIFJlYWRvbmx5TWFwfSB0aGF0IGNhbm5vdCBiZSBtb2RpZmllZCBhZnRlciBpbnN0YW50aWF0aW9uLlxuICogVGhlIGltcGxlbWVudGF0aW9uIHVzZXMgYW4gaW5uZXIgbWFwIGhpZGRlbiB2aWEgYSBwcml2YXRlIGZpZWxkLCBhbmQgdGhlXG4gKiBpbW11dGFiaWxpdHkgZ3VhcmFudGVlIHJlbGllcyBvbiBpdCBiZWluZyBpbXBvc3NpYmxlIHRvIGdldCBhIHJlZmVyZW5jZVxuICogdG8gdGhpcyBtYXAuXG4gKi9cbmNsYXNzIEZyb3plbk1hcCB7XG4gICAgY29uc3RydWN0b3IoZW50cmllcykge1xuICAgICAgICBfRnJvemVuTWFwX21hcC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgbmV3IE1hcChlbnRyaWVzKSwgXCJmXCIpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgICBbKF9Gcm96ZW5NYXBfbWFwID0gbmV3IFdlYWtNYXAoKSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIilbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIH1cbiAgICBlbnRyaWVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuTWFwX21hcCwgXCJmXCIpLmVudHJpZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFdlIGhhdmUgdG8gd3JhcCB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIGluIG9yZGVyIHRvIHByZXZlbnQgaXQgZnJvbVxuICAgICAgICAvLyByZWNlaXZpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGlubmVyIG1hcC5cbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5mb3JFYWNoKCh2YWx1ZSwga2V5LCBfbWFwKSA9PiBjYWxsYmFja2ZuLmNhbGwodGhpc0FyZywgdmFsdWUsIGtleSwgdGhpcykpO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5NYXBfbWFwLCBcImZcIikuZ2V0KGtleSk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5oYXMoa2V5KTtcbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plbk1hcF9tYXAsIFwiZlwiKS52YWx1ZXMoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgRnJvemVuTWFwKCR7dGhpcy5zaXplfSkgeyR7dGhpcy5zaXplID4gMFxuICAgICAgICAgICAgPyBgICR7Wy4uLnRoaXMuZW50cmllcygpXVxuICAgICAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7U3RyaW5nKGtleSl9ID0+ICR7U3RyaW5nKHZhbHVlKX1gKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfSBgXG4gICAgICAgICAgICA6ICcnfX1gO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJvemVuTWFwID0gRnJvemVuTWFwO1xuLyoqXG4gKiBBIHtAbGluayBSZWFkb25seVNldH0gdGhhdCBjYW5ub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgaW5zdGFudGlhdGlvbi5cbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIGFuIGlubmVyIHNldCBoaWRkZW4gdmlhIGEgcHJpdmF0ZSBmaWVsZCwgYW5kIHRoZVxuICogaW1tdXRhYmlsaXR5IGd1YXJhbnRlZSByZWxpZXMgb24gaXQgYmVpbmcgaW1wb3NzaWJsZSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIHRvIHRoaXMgc2V0LlxuICovXG5jbGFzcyBGcm96ZW5TZXQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlcykge1xuICAgICAgICBfRnJvemVuU2V0X3NldC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgbmV3IFNldCh2YWx1ZXMpLCBcImZcIik7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLnNpemU7XG4gICAgfVxuICAgIFsoX0Zyb3plblNldF9zZXQgPSBuZXcgV2Vha01hcCgpLCBTeW1ib2wuaXRlcmF0b3IpXSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0Zyb3plblNldF9zZXQsIFwiZlwiKVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikuZW50cmllcygpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW4gb3JkZXIgdG8gcHJldmVudCBpdCBmcm9tXG4gICAgICAgIC8vIHJlY2VpdmluZyBhIHJlZmVyZW5jZSB0byB0aGUgaW5uZXIgc2V0LlxuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmZvckVhY2goKHZhbHVlLCB2YWx1ZTIsIF9zZXQpID0+IGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwgdmFsdWUyLCB0aGlzKSk7XG4gICAgfVxuICAgIGhhcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfRnJvemVuU2V0X3NldCwgXCJmXCIpLmhhcyh2YWx1ZSk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Gcm96ZW5TZXRfc2V0LCBcImZcIikudmFsdWVzKCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYEZyb3plblNldCgke3RoaXMuc2l6ZX0pIHske3RoaXMuc2l6ZSA+IDBcbiAgICAgICAgICAgID8gYCAke1suLi50aGlzLnZhbHVlcygpXS5tYXAoKG1lbWJlcikgPT4gU3RyaW5nKG1lbWJlcikpLmpvaW4oJywgJyl9IGBcbiAgICAgICAgICAgIDogJyd9fWA7XG4gICAgfVxufVxuZXhwb3J0cy5Gcm96ZW5TZXQgPSBGcm96ZW5TZXQ7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcCk7XG5PYmplY3QuZnJlZXplKEZyb3plbk1hcC5wcm90b3R5cGUpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQpO1xuT2JqZWN0LmZyZWV6ZShGcm96ZW5TZXQucHJvdG90eXBlKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbGxlY3Rpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZW1vdmUweCA9IGV4cG9ydHMuYWRkMHggPSBleHBvcnRzLmFzc2VydElzU3RyaWN0SGV4U3RyaW5nID0gZXhwb3J0cy5hc3NlcnRJc0hleFN0cmluZyA9IGV4cG9ydHMuaXNTdHJpY3RIZXhTdHJpbmcgPSBleHBvcnRzLmlzSGV4U3RyaW5nID0gZXhwb3J0cy5TdHJpY3RIZXhTdHJ1Y3QgPSBleHBvcnRzLkhleFN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbmV4cG9ydHMuSGV4U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAvXig/OjB4KT9bMC05YS1mXSskL2l1KTtcbmV4cG9ydHMuU3RyaWN0SGV4U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoKDAsIHN1cGVyc3RydWN0XzEuc3RyaW5nKSgpLCAvXjB4WzAtOWEtZl0rJC9pdSk7XG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5IZXhTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0hleFN0cmluZyA9IGlzSGV4U3RyaW5nO1xuLyoqXG4gKiBTdHJpY3RseSBjaGVjayBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleCBzdHJpbmcuIEEgdmFsaWQgaGV4IHN0cmluZyBtdXN0XG4gKiBzdGFydCB3aXRoIHRoZSBcIjB4XCItcHJlZml4LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLlN0cmljdEhleFN0cnVjdCk7XG59XG5leHBvcnRzLmlzU3RyaWN0SGV4U3RyaW5nID0gaXNTdHJpY3RIZXhTdHJpbmc7XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNIZXhTdHJpbmcodmFsdWUpLCAnVmFsdWUgbXVzdCBiZSBhIGhleGFkZWNpbWFsIHN0cmluZy4nKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNIZXhTdHJpbmcgPSBhc3NlcnRJc0hleFN0cmluZztcbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGhleCBzdHJpbmcuIEEgdmFsaWQgaGV4IHN0cmluZyBtdXN0IHN0YXJ0IHdpdGhcbiAqIHRoZSBcIjB4XCItcHJlZml4LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzU3RyaWN0SGV4U3RyaW5nKHZhbHVlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoaXNTdHJpY3RIZXhTdHJpbmcodmFsdWUpLCAnVmFsdWUgbXVzdCBiZSBhIGhleGFkZWNpbWFsIHN0cmluZywgc3RhcnRpbmcgd2l0aCBcIjB4XCIuJyk7XG59XG5leHBvcnRzLmFzc2VydElzU3RyaWN0SGV4U3RyaW5nID0gYXNzZXJ0SXNTdHJpY3RIZXhTdHJpbmc7XG4vKipcbiAqIEFkZCB0aGUgYDB4YC1wcmVmaXggdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIElmIHRoZSBzdHJpbmcgYWxyZWFkeSBoYXMgdGhlXG4gKiBwcmVmaXgsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSBoZXhhZGVjaW1hbCAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYWRkIHRoZSBwcmVmaXggdG8uXG4gKiBAcmV0dXJucyBUaGUgcHJlZml4ZWQgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBhZGQweChoZXhhZGVjaW1hbCkge1xuICAgIGlmIChoZXhhZGVjaW1hbC5zdGFydHNXaXRoKCcweCcpKSB7XG4gICAgICAgIHJldHVybiBoZXhhZGVjaW1hbDtcbiAgICB9XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzBYJykpIHtcbiAgICAgICAgcmV0dXJuIGAweCR7aGV4YWRlY2ltYWwuc3Vic3RyaW5nKDIpfWA7XG4gICAgfVxuICAgIHJldHVybiBgMHgke2hleGFkZWNpbWFsfWA7XG59XG5leHBvcnRzLmFkZDB4ID0gYWRkMHg7XG4vKipcbiAqIFJlbW92ZSB0aGUgYDB4YC1wcmVmaXggZnJvbSBhIGhleGFkZWNpbWFsIHN0cmluZy4gSWYgdGhlIHN0cmluZyBkb2Vzbid0IGhhdmVcbiAqIHRoZSBwcmVmaXgsIGl0IGlzIHJldHVybmVkIGFzLWlzLlxuICpcbiAqIEBwYXJhbSBoZXhhZGVjaW1hbCAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gcmVtb3ZlIHRoZSBwcmVmaXggZnJvbS5cbiAqIEByZXR1cm5zIFRoZSB1bi1wcmVmaXhlZCBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZTB4KGhleGFkZWNpbWFsKSB7XG4gICAgaWYgKGhleGFkZWNpbWFsLnN0YXJ0c1dpdGgoJzB4JykgfHwgaGV4YWRlY2ltYWwuc3RhcnRzV2l0aCgnMFgnKSkge1xuICAgICAgICByZXR1cm4gaGV4YWRlY2ltYWwuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4YWRlY2ltYWw7XG59XG5leHBvcnRzLnJlbW92ZTB4ID0gcmVtb3ZlMHg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NlcnRcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jhc2U2NFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYnl0ZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NoZWNrc3VtXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb2VyY2Vyc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29sbGVjdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hleFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vanNvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbG9nZ2luZ1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWlzY1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbnVtYmVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9vcGFxdWVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RpbWVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3ZlcnNpb25zXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUpzb25BbmRHZXRTaXplID0gZXhwb3J0cy5nZXRKc29uUnBjSWRWYWxpZGF0b3IgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY0Vycm9yID0gZXhwb3J0cy5pc0pzb25ScGNFcnJvciA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuaXNKc29uUnBjRmFpbHVyZSA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuaXNKc29uUnBjU3VjY2VzcyA9IGV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzSnNvblJwY1Jlc3BvbnNlID0gZXhwb3J0cy5hc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UgPSBleHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjRmFpbHVyZVN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QgPSBleHBvcnRzLlBlbmRpbmdKc29uUnBjUmVzcG9uc2VTdHJ1Y3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBleHBvcnRzLmFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbiA9IGV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCA9IGV4cG9ydHMuSnNvblJwY1BhcmFtc1N0cnVjdCA9IGV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0ID0gZXhwb3J0cy5qc29ucnBjMiA9IGV4cG9ydHMuaXNWYWxpZEpzb24gPSBleHBvcnRzLkpzb25TdHJ1Y3QgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG5jb25zdCBtaXNjXzEgPSByZXF1aXJlKFwiLi9taXNjXCIpO1xuZXhwb3J0cy5Kc29uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEuZGVmaW5lKSgnSnNvbicsICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IFtpc1ZhbGlkXSA9IHZhbGlkYXRlSnNvbkFuZEdldFNpemUodmFsdWUsIHRydWUpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICByZXR1cm4gJ0V4cGVjdGVkIGEgdmFsaWQgSlNPTi1zZXJpYWxpemFibGUgdmFsdWUnO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvbn0gdmFsdWUsIGkuZS4sIGEgdmFsdWUgdGhhdCBpc1xuICogc2VyaWFsaXphYmxlIHRvIEpTT04uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvbn0gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRKc29uKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNWYWxpZEpzb24gPSBpc1ZhbGlkSnNvbjtcbi8qKlxuICogVGhlIHN0cmluZyAnMi4wJy5cbiAqL1xuZXhwb3J0cy5qc29ucnBjMiA9ICcyLjAnO1xuZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLmxpdGVyYWwpKGV4cG9ydHMuanNvbnJwYzIpO1xuZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5udWxsYWJsZSkoKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5udW1iZXIpKCksICgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKV0pKTtcbmV4cG9ydHMuSnNvblJwY0Vycm9yU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgY29kZTogKDAsIHN1cGVyc3RydWN0XzEuaW50ZWdlcikoKSxcbiAgICBtZXNzYWdlOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgZGF0YTogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKGV4cG9ydHMuSnNvblN0cnVjdCksXG4gICAgc3RhY2s6ICgwLCBzdXBlcnN0cnVjdF8xLm9wdGlvbmFsKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCkpLFxufSk7XG5leHBvcnRzLkpzb25ScGNQYXJhbXNTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFsoMCwgc3VwZXJzdHJ1Y3RfMS5yZWNvcmQpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgZXhwb3J0cy5Kc29uU3RydWN0KSwgKDAsIHN1cGVyc3RydWN0XzEuYXJyYXkpKGV4cG9ydHMuSnNvblN0cnVjdCldKSk7XG5leHBvcnRzLkpzb25ScGNSZXF1ZXN0U3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgbWV0aG9kOiAoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksXG4gICAgcGFyYW1zOiBleHBvcnRzLkpzb25ScGNQYXJhbXNTdHJ1Y3QsXG59KTtcbmV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9taXQpKGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QsIFsnaWQnXSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjTm90aWZpY2F0aW9ufSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn1cbiAqIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjTm90aWZpY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjTm90aWZpY2F0aW9uU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjTm90aWZpY2F0aW9uID0gaXNKc29uUnBjTm90aWZpY2F0aW9uO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY05vdGlmaWNhdGlvbn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgbm90aWZpY2F0aW9uJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uID0gYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjUmVxdWVzdH0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNSZXF1ZXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjUmVxdWVzdFN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY1JlcXVlc3QgPSBpc0pzb25ScGNSZXF1ZXN0O1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1JlcXVlc3R9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdCBvciBub3RpZmljYXRpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXF1ZXN0fSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1JlcXVlc3QodmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1JlcXVlc3RTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHJlcXVlc3QnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXF1ZXN0ID0gYXNzZXJ0SXNKc29uUnBjUmVxdWVzdDtcbmV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCA9ICgwLCBzdXBlcnN0cnVjdF8xLm9iamVjdCkoe1xuICAgIGlkOiBleHBvcnRzLkpzb25ScGNJZFN0cnVjdCxcbiAgICBqc29ucnBjOiBleHBvcnRzLkpzb25ScGNWZXJzaW9uU3RydWN0LFxuICAgIHJlc3VsdDogKDAsIHN1cGVyc3RydWN0XzEub3B0aW9uYWwpKCgwLCBzdXBlcnN0cnVjdF8xLnVua25vd24pKCkpLFxuICAgIGVycm9yOiAoMCwgc3VwZXJzdHJ1Y3RfMS5vcHRpb25hbCkoZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QpLFxufSk7XG5leHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEub2JqZWN0KSh7XG4gICAgaWQ6IGV4cG9ydHMuSnNvblJwY0lkU3RydWN0LFxuICAgIGpzb25ycGM6IGV4cG9ydHMuSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gICAgcmVzdWx0OiBleHBvcnRzLkpzb25TdHJ1Y3QsXG59KTtcbmV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5vYmplY3QpKHtcbiAgICBpZDogZXhwb3J0cy5Kc29uUnBjSWRTdHJ1Y3QsXG4gICAganNvbnJwYzogZXhwb3J0cy5Kc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgICBlcnJvcjogZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QsXG59KTtcbmV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEudW5pb24pKFtcbiAgICBleHBvcnRzLkpzb25ScGNTdWNjZXNzU3RydWN0LFxuICAgIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsXG5dKTtcbi8qKlxuICogVHlwZSBndWFyZCB0byBjaGVjayB3aGV0aGVyIHNwZWNpZmllZCBKU09OLVJQQyByZXNwb25zZSBpcyBhXG4gKiB7QGxpbmsgUGVuZGluZ0pzb25ScGNSZXNwb25zZX0uXG4gKlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIEpTT04tUlBDIHJlc3BvbnNlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIEpTT04tUlBDIHJlc3BvbnNlIGlzIHBlbmRpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzUGVuZGluZ0pzb25ScGNSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykocmVzcG9uc2UsIGV4cG9ydHMuUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzUGVuZGluZ0pzb25ScGNSZXNwb25zZSA9IGlzUGVuZGluZ0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIFBlbmRpbmdKc29uUnBjUmVzcG9uc2V9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgSlNPTi1SUEMgcmVzcG9uc2UgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIFBlbmRpbmdKc29uUnBjUmVzcG9uc2V9XG4gKiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzUGVuZGluZ0pzb25ScGNSZXNwb25zZShyZXNwb25zZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KShyZXNwb25zZSwgZXhwb3J0cy5QZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0LCAnSW52YWxpZCBwZW5kaW5nIEpTT04tUlBDIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlID0gYXNzZXJ0SXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgYSB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfS5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgb2JqZWN0IGlzIGEgSnNvblJwY1Jlc3BvbnNlLlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNSZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykocmVzcG9uc2UsIGV4cG9ydHMuSnNvblJwY1Jlc3BvbnNlU3RydWN0KTtcbn1cbmV4cG9ydHMuaXNKc29uUnBjUmVzcG9uc2UgPSBpc0pzb25ScGNSZXNwb25zZTtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNSZXNwb25zZX0gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uXG4gKiBAdGhyb3dzIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1Jlc3BvbnNlfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1Jlc3BvbnNlKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNSZXNwb25zZVN0cnVjdCwgJ0ludmFsaWQgSlNPTi1SUEMgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNSZXNwb25zZSA9IGFzc2VydElzSnNvblJwY1Jlc3BvbnNlO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjU3VjY2Vzc30gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc0pzb25ScGNTdWNjZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuICgwLCBzdXBlcnN0cnVjdF8xLmlzKSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjU3VjY2Vzc1N0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY1N1Y2Nlc3MgPSBpc0pzb25ScGNTdWNjZXNzO1xuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY1N1Y2Nlc3N9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNTdWNjZXNzfSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1N1Y2Nlc3ModmFsdWUsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuRXJyb3JXcmFwcGVyKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkodmFsdWUsIGV4cG9ydHMuSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIHN1Y2Nlc3MgcmVzcG9uc2UnLCBFcnJvcldyYXBwZXIpO1xufVxuZXhwb3J0cy5hc3NlcnRJc0pzb25ScGNTdWNjZXNzID0gYXNzZXJ0SXNKc29uUnBjU3VjY2Vzcztcbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB7QGxpbmsgSnNvblJwY0ZhaWx1cmV9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjRmFpbHVyZSh2YWx1ZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmFsdWUsIGV4cG9ydHMuSnNvblJwY0ZhaWx1cmVTdHJ1Y3QpO1xufVxuZXhwb3J0cy5pc0pzb25ScGNGYWlsdXJlID0gaXNKc29uUnBjRmFpbHVyZTtcbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIGdpdmVuIHZhbHVlIGlzIGEgdmFsaWQge0BsaW5rIEpzb25ScGNGYWlsdXJlfSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIHZhbGlkIHtAbGluayBKc29uUnBjRmFpbHVyZX0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNGYWlsdXJlKHZhbHVlLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlcikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNGYWlsdXJlU3RydWN0LCAnSW52YWxpZCBKU09OLVJQQyBmYWlsdXJlIHJlc3BvbnNlJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSA9IGFzc2VydElzSnNvblJwY0ZhaWx1cmU7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNKc29uUnBjRXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZhbHVlLCBleHBvcnRzLkpzb25ScGNFcnJvclN0cnVjdCk7XG59XG5leHBvcnRzLmlzSnNvblJwY0Vycm9yID0gaXNKc29uUnBjRXJyb3I7XG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBKc29uUnBjRXJyb3J9IG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gRXJyb3JXcmFwcGVyIC0gVGhlIGVycm9yIGNsYXNzIHRvIHRocm93IGlmIHRoZSBhc3NlcnRpb24gZmFpbHMuXG4gKiBEZWZhdWx0cyB0byB7QGxpbmsgQXNzZXJ0aW9uRXJyb3J9LlxuICogQHRocm93cyBJZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQge0BsaW5rIEpzb25ScGNFcnJvcn0gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNFcnJvcih2YWx1ZSwgXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5FcnJvcldyYXBwZXIpIHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0U3RydWN0KSh2YWx1ZSwgZXhwb3J0cy5Kc29uUnBjRXJyb3JTdHJ1Y3QsICdJbnZhbGlkIEpTT04tUlBDIGVycm9yJywgRXJyb3JXcmFwcGVyKTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNKc29uUnBjRXJyb3IgPSBhc3NlcnRJc0pzb25ScGNFcnJvcjtcbi8qKlxuICogR2V0cyBhIGZ1bmN0aW9uIGZvciB2YWxpZGF0aW5nIEpTT04tUlBDIHJlcXVlc3QgLyByZXNwb25zZSBgaWRgIHZhbHVlcy5cbiAqXG4gKiBCeSBtYW5pcHVsYXRpbmcgdGhlIG9wdGlvbnMgb2YgdGhpcyBmYWN0b3J5LCB5b3UgY2FuIGNvbnRyb2wgdGhlIGJlaGF2aW9yXG4gKiBvZiB0aGUgcmVzdWx0aW5nIHZhbGlkYXRvciBmb3Igc29tZSBlZGdlIGNhc2VzLiBUaGlzIGlzIHVzZWZ1bCBiZWNhdXNlIGUuZy5cbiAqIGBudWxsYCBzaG91bGQgc29tZXRpbWVzIGJ1dCBub3QgYWx3YXlzIGJlIHBlcm1pdHRlZC5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGVtcHR5IHN0cmluZyAoYCcnYCkgaXMgYWx3YXlzIHBlcm1pdHRlZCBieSB0aGUgSlNPTi1SUENcbiAqIHNwZWNpZmljYXRpb24sIGJ1dCB0aGF0IGtpbmQgb2Ygc3Vja3MgYW5kIHlvdSBtYXkgd2FudCB0byBmb3JiaWQgaXQgaW4gc29tZVxuICogaW5zdGFuY2VzIGFueXdheS5cbiAqXG4gKiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlXG4gKiBbSlNPTi1SUEMgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly93d3cuanNvbnJwYy5vcmcvc3BlY2lmaWNhdGlvbikuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdEVtcHR5U3RyaW5nIC0gV2hldGhlciB0aGUgZW1wdHkgc3RyaW5nIChpLmUuIGAnJ2ApXG4gKiBzaG91bGQgYmUgdHJlYXRlZCBhcyBhIHZhbGlkIElELiBEZWZhdWx0OiBgdHJ1ZWBcbiAqIEBwYXJhbSBvcHRpb25zLnBlcm1pdEZyYWN0aW9ucyAtIFdoZXRoZXIgZnJhY3Rpb25hbCBudW1iZXJzIChlLmcuIGAxLjJgKVxuICogc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQgSURzLiBEZWZhdWx0OiBgZmFsc2VgXG4gKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXROdWxsIC0gV2hldGhlciBgbnVsbGAgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSB2YWxpZCBJRC5cbiAqIERlZmF1bHQ6IGB0cnVlYFxuICogQHJldHVybnMgVGhlIEpTT04tUlBDIElEIHZhbGlkYXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0SnNvblJwY0lkVmFsaWRhdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IHBlcm1pdEVtcHR5U3RyaW5nLCBwZXJtaXRGcmFjdGlvbnMsIHBlcm1pdE51bGwgfSA9IE9iamVjdC5hc3NpZ24oeyBwZXJtaXRFbXB0eVN0cmluZzogdHJ1ZSwgcGVybWl0RnJhY3Rpb25zOiBmYWxzZSwgcGVybWl0TnVsbDogdHJ1ZSB9LCBvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBUeXBlIGd1YXJkIGZvciB7QGxpbmsgSnNvblJwY0lkfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBKU09OLVJQQyBJRCB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBnaXZlbiBJRCBpcyB2YWxpZCBwZXIgdGhlIG9wdGlvbnMgZ2l2ZW4gdG8gdGhlXG4gICAgICogZmFjdG9yeS5cbiAgICAgKi9cbiAgICBjb25zdCBpc1ZhbGlkSnNvblJwY0lkID0gKGlkKSA9PiB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCh0eXBlb2YgaWQgPT09ICdudW1iZXInICYmIChwZXJtaXRGcmFjdGlvbnMgfHwgTnVtYmVyLmlzSW50ZWdlcihpZCkpKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBpZCA9PT0gJ3N0cmluZycgJiYgKHBlcm1pdEVtcHR5U3RyaW5nIHx8IGlkLmxlbmd0aCA+IDApKSB8fFxuICAgICAgICAgICAgKHBlcm1pdE51bGwgJiYgaWQgPT09IG51bGwpKTtcbiAgICB9O1xuICAgIHJldHVybiBpc1ZhbGlkSnNvblJwY0lkO1xufVxuZXhwb3J0cy5nZXRKc29uUnBjSWRWYWxpZGF0b3IgPSBnZXRKc29uUnBjSWRWYWxpZGF0b3I7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgSlNPTiBzZXJpYWxpemFibGUgYW5kIGNvdW50cyB0aGUgdG90YWwgbnVtYmVyXG4gKiBvZiBieXRlcyBuZWVkZWQgdG8gc3RvcmUgdGhlIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGUgdmFsdWUuXG4gKlxuICogQHBhcmFtIGpzT2JqZWN0IC0gUG90ZW50aWFsIEpTT04gc2VyaWFsaXphYmxlIG9iamVjdC5cbiAqIEBwYXJhbSBza2lwU2l6aW5nUHJvY2VzcyAtIFNraXAgSlNPTiBzaXplIGNhbGN1bGF0aW9uIChkZWZhdWx0OiBmYWxzZSkuXG4gKiBAcmV0dXJucyBUdXBsZSBbaXNWYWxpZCwgcGxhaW5UZXh0U2l6ZUluQnl0ZXNdIGNvbnRhaW5pbmcgYSBib29sZWFuIHRoYXQgc2lnbmFscyB3aGV0aGVyXG4gKiB0aGUgdmFsdWUgd2FzIHNlcmlhbGl6YWJsZSBhbmQgYSBudW1iZXIgb2YgYnl0ZXMgdGhhdCBpdCB3aWxsIHVzZSB3aGVuIHNlcmlhbGl6ZWQgdG8gSlNPTi5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVKc29uQW5kR2V0U2l6ZShqc09iamVjdCwgc2tpcFNpemluZ1Byb2Nlc3MgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNlZW5PYmplY3RzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgSlNPTiBzZXJpYWxpemFibGUgYW5kIGNvdW50cyB0aGUgdG90YWwgbnVtYmVyXG4gICAgICogb2YgYnl0ZXMgbmVlZGVkIHRvIHN0b3JlIHRoZSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhlIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoZSBlbmNvZGluZyBvZiB0aGUgSlNPTiBpcyBkb25lIGluIFVURi04LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gUG90ZW50aWFsIEpTT04gc2VyaWFsaXphYmxlIHZhbHVlLlxuICAgICAqIEBwYXJhbSBza2lwU2l6aW5nIC0gU2tpcCBKU09OIHNpemUgY2FsY3VsYXRpb24gKGRlZmF1bHQ6IGZhbHNlKS5cbiAgICAgKiBAcmV0dXJucyBUdXBsZSBbaXNWYWxpZCwgcGxhaW5UZXh0U2l6ZUluQnl0ZXNdIGNvbnRhaW5pbmcgYSBib29sZWFuIHRoYXQgc2lnbmFscyB3aGV0aGVyXG4gICAgICogdGhlIHZhbHVlIHdhcyBzZXJpYWxpemFibGUgYW5kIGEgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgaXQgd2lsbCB1c2Ugd2hlbiBzZXJpYWxpemVkIHRvIEpTT04uXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SnNvblNlcmlhbGl6YWJsZUluZm8odmFsdWUsIHNraXBTaXppbmcpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYWxyZWFkeSBzcGVjaWZpZWQgY29uc3RhbnQgc2l6ZSBmb3IgbnVsbCAoc3BlY2lhbCBvYmplY3QpXG4gICAgICAgICAgICByZXR1cm4gW3RydWUsIHNraXBTaXppbmcgPyAwIDogbWlzY18xLkpzb25TaXplLk51bGxdO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGFuZCBjYWxjdWxhdGUgc2l6ZXMgZm9yIGJhc2ljIChhbmQgc29tZSBzcGVjaWFsKSB0eXBlc1xuICAgICAgICBjb25zdCB0eXBlT2ZWYWx1ZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlT2ZWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZU9mVmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgc2tpcFNpemluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICgwLCBtaXNjXzEuY2FsY3VsYXRlU3RyaW5nU2l6ZSkodmFsdWUpICsgbWlzY18xLkpzb25TaXplLlF1b3RlICogMixcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZU9mVmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJvb2xlYW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFNpemluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIDBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCB2YWx1ZSA9PSB0cnVlID8gbWlzY18xLkpzb25TaXplLlRydWUgOiBtaXNjXzEuSnNvblNpemUuRmFsc2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZU9mVmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBTaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAwXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0cnVlLCAoMCwgbWlzY18xLmNhbGN1bGF0ZU51bWJlclNpemUpKHZhbHVlKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcFNpemluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3RydWUsIDBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBJbnZhbGlkIGRhdGVzIHdpbGwgc2VyaWFsaXplIHRvIG51bGxcbiAgICAgICAgICAgICAgICAgICAgaXNOYU4odmFsdWUuZ2V0RGF0ZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtaXNjXzEuSnNvblNpemUuTnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBtaXNjXzEuSnNvblNpemUuRGF0ZSArIG1pc2NfMS5Kc29uU2l6ZS5RdW90ZSAqIDIsXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgb2JqZWN0IGlzIG5vdCBwbGFpbiBhbmQgY2Fubm90IGJlIHNlcmlhbGl6ZWQgcHJvcGVybHksXG4gICAgICAgIC8vIHN0b3AgaGVyZSBhbmQgcmV0dXJuIGZhbHNlIGZvciBzZXJpYWxpemF0aW9uXG4gICAgICAgIGlmICghKDAsIG1pc2NfMS5pc1BsYWluT2JqZWN0KSh2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaXJjdWxhciBvYmplY3QgZGV0ZWN0aW9uIChoYW5kbGluZylcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHNhbWUgb2JqZWN0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGlmIChzZWVuT2JqZWN0cy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW2ZhbHNlLCAwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgbmV3IG9iamVjdCB0byB0aGUgc2VlbiBvYmplY3RzIHNldFxuICAgICAgICAvLyBPbmx5IHRoZSBwbGFpbiBvYmplY3RzIHNob3VsZCBiZSBhZGRlZCAoUHJpbWl0aXZlIHR5cGVzIGFyZSBza2lwcGVkKVxuICAgICAgICBzZWVuT2JqZWN0cy5hZGQodmFsdWUpO1xuICAgICAgICAvLyBDb250aW51ZSBvYmplY3QgZGVjb21wb3NpdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5yZWR1Y2UoKHN1bSwgW2tleSwgbmVzdGVkVmFsdWVdLCBpZHgsIGFycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBwcm9jZXNzIG5leHQgbmVzdGVkIG9iamVjdCBvciBwcmltaXRpdmUgdHlwZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgICAgICAgICAgICAgICAgIGxldCBbdmFsaWQsIHNpemVdID0gZ2V0SnNvblNlcmlhbGl6YWJsZUluZm8obmVzdGVkVmFsdWUsIHNraXBTaXppbmcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04gdmFsaWRhdGlvbiBkaWQgbm90IHBhc3MuIFZhbGlkYXRpb24gcHJvY2VzcyBzdG9wcGVkLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENpcmN1bGFyIG9iamVjdCBkZXRlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBhIGNoaWxkIG5vZGUgaXMgdmlzaXRlZCBhbmQgcHJvY2Vzc2VkIHJlbW92ZSBpdCBmcm9tIHRoZSBzZXQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IGZhbHNlIHBvc2l0aXZlcyB3aXRoIHRoZSBzYW1lIGFkamFjZW50IG9iamVjdHMuXG4gICAgICAgICAgICAgICAgICAgIHNlZW5PYmplY3RzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwU2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBPYmplY3RzIHdpbGwgaGF2ZSBiZSBzZXJpYWxpemVkIHdpdGggXCJrZXlcIjogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlZm9yZSB3ZSBpbmNsdWRlIHRoZSBrZXkgaW4gdGhlIGNhbGN1bGF0aW9uIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5U2l6ZSA9IEFycmF5LmlzQXJyYXkodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIDoga2V5Lmxlbmd0aCArIG1pc2NfMS5Kc29uU2l6ZS5Db21tYSArIG1pc2NfMS5Kc29uU2l6ZS5Db2xvbiAqIDI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvciA9IGlkeCA8IGFyci5sZW5ndGggLSAxID8gbWlzY18xLkpzb25TaXplLkNvbW1hIDogMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIGtleVNpemUgKyBzaXplICsgc2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0cyBhdCAyIGJlY2F1c2UgdGhlIHNlcmlhbGl6ZWQgSlNPTiBzdHJpbmcgZGF0YSAocGxhaW4gdGV4dClcbiAgICAgICAgICAgICAgICAvLyB3aWxsIG1pbmltYWxseSBjb250YWluIHt9L1tdXG4gICAgICAgICAgICAgICAgc2tpcFNpemluZyA/IDAgOiBtaXNjXzEuSnNvblNpemUuV3JhcHBlciAqIDIpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcmV0dXJuIFtmYWxzZSwgMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGdldEpzb25TZXJpYWxpemFibGVJbmZvKGpzT2JqZWN0LCBza2lwU2l6aW5nUHJvY2Vzcyk7XG59XG5leHBvcnRzLnZhbGlkYXRlSnNvbkFuZEdldFNpemUgPSB2YWxpZGF0ZUpzb25BbmRHZXRTaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZ2xvYmFsTG9nZ2VyID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoJ21ldGFtYXNrJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBsb2dnZXIgdmlhIHRoZSBgZGVidWdgIGxpYnJhcnkgd2hvc2UgbG9nIG1lc3NhZ2VzIHdpbGwgYmUgdGFnZ2VkXG4gKiB1c2luZyB0aGUgbmFtZSBvZiB5b3VyIHByb2plY3QuIEJ5IGRlZmF1bHQsIHN1Y2ggbWVzc2FnZXMgd2lsbCBiZVxuICogc3VwcHJlc3NlZCwgYnV0IHlvdSBjYW4gcmV2ZWFsIHRoZW0gYnkgc2V0dGluZyB0aGUgYERFQlVHYCBlbnZpcm9ubWVudFxuICogdmFyaWFibGUgdG8gYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT5gLiBZb3UgY2FuIGFsc28gc2V0IHRoaXMgdmFyaWFibGUgdG9cbiAqIGBtZXRhbWFzazoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gYWxsIE1ldGFNYXNrIHByb2plY3RzIHRoYXRcbiAqIGFyZSBhbHNvIHVzaW5nIHRoaXMgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZWlyIGxvZ2dlcnMuXG4gKlxuICogQHBhcmFtIHByb2plY3ROYW1lIC0gVGhlIG5hbWUgb2YgeW91ciBwcm9qZWN0LiBUaGlzIHNob3VsZCBiZSB0aGUgbmFtZSBvZlxuICogeW91ciBOUE0gcGFja2FnZSBpZiB5b3UncmUgZGV2ZWxvcGluZyBvbmUuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBgZGVidWdgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm9qZWN0TG9nZ2VyKHByb2plY3ROYW1lKSB7XG4gICAgcmV0dXJuIGdsb2JhbExvZ2dlci5leHRlbmQocHJvamVjdE5hbWUpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm9qZWN0TG9nZ2VyID0gY3JlYXRlUHJvamVjdExvZ2dlcjtcbi8qKlxuICogQ3JlYXRlcyBhIGxvZ2dlciB2aWEgdGhlIGBkZWJ1Z2AgbGlicmFyeSB3aGljaCBpcyBkZXJpdmVkIGZyb20gdGhlIGxvZ2dlciBmb3JcbiAqIHRoZSB3aG9sZSBwcm9qZWN0IHdob3NlIGxvZyBtZXNzYWdlcyB3aWxsIGJlIHRhZ2dlZCB1c2luZyB0aGUgbmFtZSBvZiB5b3VyXG4gKiBtb2R1bGUuIEJ5IGRlZmF1bHQsIHN1Y2ggbWVzc2FnZXMgd2lsbCBiZSBzdXBwcmVzc2VkLCBidXQgeW91IGNhbiByZXZlYWwgdGhlbVxuICogYnkgc2V0dGluZyB0aGUgYERFQlVHYCBlbnZpcm9ubWVudCB2YXJpYWJsZSB0b1xuICogYG1ldGFtYXNrOjxwcm9qZWN0TmFtZT46PG1vZHVsZU5hbWU+YC4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHZhcmlhYmxlIHRvXG4gKiBgbWV0YW1hc2s6PHByb2plY3ROYW1lPjoqYCBpZiB5b3Ugd2FudCB0byBzZWUgbG9nIG1lc3NhZ2VzIGZyb20gdGhlIHByb2plY3QsXG4gKiBvciBgbWV0YW1hc2s6KmAgaWYgeW91IHdhbnQgdG8gc2VlIGxvZyBtZXNzYWdlcyBmcm9tIGFsbCBNZXRhTWFzayBwcm9qZWN0cy5cbiAqXG4gKiBAcGFyYW0gcHJvamVjdExvZ2dlciAtIFRoZSBsb2dnZXIgY3JlYXRlZCB2aWEge0BsaW5rIGNyZWF0ZVByb2plY3RMb2dnZXJ9LlxuICogQHBhcmFtIG1vZHVsZU5hbWUgLSBUaGUgbmFtZSBvZiB5b3VyIG1vZHVsZS4gWW91IGNvdWxkIHVzZSB0aGUgbmFtZSBvZiB0aGVcbiAqIGZpbGUgd2hlcmUgeW91J3JlIHVzaW5nIHRoaXMgbG9nZ2VyIG9yIHNvbWUgb3RoZXIgbmFtZS5cbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIGBkZWJ1Z2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vZHVsZUxvZ2dlcihwcm9qZWN0TG9nZ2VyLCBtb2R1bGVOYW1lKSB7XG4gICAgcmV0dXJuIHByb2plY3RMb2dnZXIuZXh0ZW5kKG1vZHVsZU5hbWUpO1xufVxuZXhwb3J0cy5jcmVhdGVNb2R1bGVMb2dnZXIgPSBjcmVhdGVNb2R1bGVMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy9cbi8vIFR5cGVzXG4vL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYWxjdWxhdGVOdW1iZXJTaXplID0gZXhwb3J0cy5jYWxjdWxhdGVTdHJpbmdTaXplID0gZXhwb3J0cy5pc0FTQ0lJID0gZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gZXhwb3J0cy5FU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSBleHBvcnRzLkpzb25TaXplID0gZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGV4cG9ydHMuaXNPYmplY3QgPSBleHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSB2b2lkIDA7XG4vL1xuLy8gVHlwZSBHdWFyZHNcbi8vXG4vKipcbiAqIEEge0BsaW5rIE5vbkVtcHR5QXJyYXl9IHR5cGUgZ3VhcmQuXG4gKlxuICogQHRlbXBsYXRlIEVsZW1lbnQgLSBUaGUgbm9uLWVtcHR5IGFycmF5IG1lbWJlciB0eXBlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSBub24tZW1wdHkgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGlzTm9uRW1wdHlBcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPiAwO1xufVxuZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSBpc05vbkVtcHR5QXJyYXk7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIFwibnVsbGlzaG5lc3NcIi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciB7QGxpbmsgUnVudGltZU9iamVjdH0uXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgc3BlY2lmaWVkIHZhbHVlIGhhcyBhIHJ1bnRpbWUgdHlwZSBvZiBgb2JqZWN0YCBhbmQgaXNcbiAqIG5laXRoZXIgYG51bGxgIG5vciBhbiBgQXJyYXlgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbHVlKTtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vXG4vLyBPdGhlciB1dGlsaXR5IGZ1bmN0aW9uc1xuLy9cbi8qKlxuICogQSB0eXBlIGd1YXJkIGZvciBlbnN1cmluZyBhbiBvYmplY3QgaGFzIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIG9iamVjdFRvQ2hlY2sgLSBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgcHJvcGVydHkgbmFtZSB0byBjaGVjayBmb3IuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkXG4gKiBuYW1lLCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgaXQgaXMgZW51bWVyYWJsZSBvciBub3QuXG4gKi9cbmNvbnN0IGhhc1Byb3BlcnR5ID0gKG9iamVjdFRvQ2hlY2ssIG5hbWUpID0+IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdFRvQ2hlY2ssIG5hbWUpO1xuZXhwb3J0cy5oYXNQcm9wZXJ0eSA9IGhhc1Byb3BlcnR5O1xuLyoqXG4gKiBQcmVkZWZpbmVkIHNpemVzIChpbiBCeXRlcykgb2Ygc3BlY2lmaWMgcGFydHMgb2YgSlNPTiBzdHJ1Y3R1cmUuXG4gKi9cbnZhciBKc29uU2l6ZTtcbihmdW5jdGlvbiAoSnNvblNpemUpIHtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIk51bGxcIl0gPSA0XSA9IFwiTnVsbFwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiQ29tbWFcIl0gPSAxXSA9IFwiQ29tbWFcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIldyYXBwZXJcIl0gPSAxXSA9IFwiV3JhcHBlclwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiVHJ1ZVwiXSA9IDRdID0gXCJUcnVlXCI7XG4gICAgSnNvblNpemVbSnNvblNpemVbXCJGYWxzZVwiXSA9IDVdID0gXCJGYWxzZVwiO1xuICAgIEpzb25TaXplW0pzb25TaXplW1wiUXVvdGVcIl0gPSAxXSA9IFwiUXVvdGVcIjtcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkNvbG9uXCJdID0gMV0gPSBcIkNvbG9uXCI7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1zaGFkb3dcbiAgICBKc29uU2l6ZVtKc29uU2l6ZVtcIkRhdGVcIl0gPSAyNF0gPSBcIkRhdGVcIjtcbn0pKEpzb25TaXplID0gZXhwb3J0cy5Kc29uU2l6ZSB8fCAoZXhwb3J0cy5Kc29uU2l6ZSA9IHt9KSk7XG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB3aXRoIHBhdHRlcm4gbWF0Y2hpbmcgZm9yIChzcGVjaWFsKSBlc2NhcGVkIGNoYXJhY3RlcnMuXG4gKi9cbmV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQID0gL1wifFxcXFx8XFxufFxccnxcXHQvZ3U7XG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBwbGFpbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRydWUgaWYgYW4gb2JqZWN0IGlzIHRoZSBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdCxcbiAqIGZhbHNlIGlmIHRoZSBvYmplY3QgaXMgbm90IHBsYWluIChlLmcuIGZ1bmN0aW9uKS5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHByb3RvID0gdmFsdWU7XG4gICAgICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbi8qKlxuICogQ2hlY2sgaWYgY2hhcmFjdGVyIGlzIEFTQ0lJLlxuICpcbiAqIEBwYXJhbSBjaGFyYWN0ZXIgLSBDaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyBUcnVlIGlmIGEgY2hhcmFjdGVyIGNvZGUgaXMgQVNDSUksIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gaXNBU0NJSShjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMTI3O1xufVxuZXhwb3J0cy5pc0FTQ0lJID0gaXNBU0NJSTtcbi8qKlxuICogQ2FsY3VsYXRlIHN0cmluZyBzaXplLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFN0cmluZyB2YWx1ZSB0byBjYWxjdWxhdGUgc2l6ZS5cbiAqIEByZXR1cm5zIE51bWJlciBvZiBieXRlcyB1c2VkIHRvIHN0b3JlIHdob2xlIHN0cmluZyB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlU3RyaW5nU2l6ZSh2YWx1ZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzaXplID0gdmFsdWUuc3BsaXQoJycpLnJlZHVjZSgodG90YWwsIGNoYXJhY3RlcikgPT4ge1xuICAgICAgICBpZiAoaXNBU0NJSShjaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG90YWwgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbCArIDI7XG4gICAgfSwgMCk7XG4gICAgLy8gQWxzbyBkZXRlY3QgY2hhcmFjdGVycyB0aGF0IG5lZWQgYmFja3NsYXNoIGVzY2FwZVxuICAgIHJldHVybiBzaXplICsgKChfYSA9IHZhbHVlLm1hdGNoKGV4cG9ydHMuRVNDQVBFX0NIQVJBQ1RFUlNfUkVHRVhQKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlU3RyaW5nU2l6ZSA9IGNhbGN1bGF0ZVN0cmluZ1NpemU7XG4vKipcbiAqIENhbGN1bGF0ZSBzaXplIG9mIGEgbnVtYmVyIG9mdGVyIEpTT04gc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gY2FsY3VsYXRlIHNpemUuXG4gKiBAcmV0dXJucyBOdW1iZXIgb2YgYnl0ZXMgdXNlZCB0byBzdG9yZSB3aG9sZSBudW1iZXIgaW4gSlNPTi5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTnVtYmVyU2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlTnVtYmVyU2l6ZSA9IGNhbGN1bGF0ZU51bWJlclNpemU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taXNjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oZXhUb0JpZ0ludCA9IGV4cG9ydHMuaGV4VG9OdW1iZXIgPSBleHBvcnRzLmJpZ0ludFRvSGV4ID0gZXhwb3J0cy5udW1iZXJUb0hleCA9IHZvaWQgMDtcbmNvbnN0IGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xuY29uc3QgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG4vKipcbiAqIENvbnZlcnQgYSBudW1iZXIgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgbnVtYmVyIGlzIGFcbiAqIG5vbi1uZWdhdGl2ZSBzYWZlIGludGVnZXIuXG4gKlxuICogVG8gY29udmVydCBhIGBiaWdpbnRgIHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGJpZ0ludFRvSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogbnVtYmVyVG9IZXgoMCk7IC8vICcweDAnXG4gKiBudW1iZXJUb0hleCgxKTsgLy8gJzB4MSdcbiAqIG51bWJlclRvSGV4KDE2KTsgLy8gJzB4MTAnXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBhIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcsIHdpdGggdGhlIFwiMHhcIi1wcmVmaXguXG4gKiBAdGhyb3dzIElmIHRoZSBudW1iZXIgaXMgbm90IGEgbm9uLW5lZ2F0aXZlIHNhZmUgaW50ZWdlci5cbiAqL1xuY29uc3QgbnVtYmVyVG9IZXggPSAodmFsdWUpID0+IHtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLCAnVmFsdWUgbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAoMCwgYXNzZXJ0XzEuYXNzZXJ0KSh2YWx1ZSA+PSAwLCAnVmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpLCAnVmFsdWUgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGJpZ0ludFRvSGV4YCBpbnN0ZWFkLicpO1xuICAgIHJldHVybiAoMCwgaGV4XzEuYWRkMHgpKHZhbHVlLnRvU3RyaW5nKDE2KSk7XG59O1xuZXhwb3J0cy5udW1iZXJUb0hleCA9IG51bWJlclRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0IGEgYGJpZ2ludGAgdG8gYSBoZXhhZGVjaW1hbCBzdHJpbmcuIFRoaXMgdmVyaWZpZXMgdGhhdCB0aGUgYGJpZ2ludGBcbiAqIGlzIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIuXG4gKlxuICogVG8gY29udmVydCBhIG51bWJlciB0byBhIGhleGFkZWNpbWFsIHN0cmluZyBpbnN0ZWFkLCB1c2Uge0BsaW5rIG51bWJlclRvSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogYmlnSW50VG9IZXgoMG4pOyAvLyAnMHgwJ1xuICogYmlnSW50VG9IZXgoMW4pOyAvLyAnMHgxJ1xuICogYmlnSW50VG9IZXgoMTZuKTsgLy8gJzB4MTAnXG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBgYmlnaW50YCB0byBjb252ZXJ0IHRvIGEgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIGhleGFkZWNpbWFsIHN0cmluZywgd2l0aCB0aGUgXCIweFwiLXByZWZpeC5cbiAqIEB0aHJvd3MgSWYgdGhlIGBiaWdpbnRgIGlzIG5vdCBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICovXG5jb25zdCBiaWdJbnRUb0hleCA9ICh2YWx1ZSkgPT4ge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcsICdWYWx1ZSBtdXN0IGJlIGEgYmlnaW50LicpO1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnQpKHZhbHVlID49IDAsICdWYWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGJpZ2ludC4nKTtcbiAgICByZXR1cm4gKDAsIGhleF8xLmFkZDB4KSh2YWx1ZS50b1N0cmluZygxNikpO1xufTtcbmV4cG9ydHMuYmlnSW50VG9IZXggPSBiaWdJbnRUb0hleDtcbi8qKlxuICogQ29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIG51bWJlci4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBzdHJpbmcgaXMgYVxuICogdmFsaWQgaGV4IHN0cmluZywgYW5kIHRoYXQgdGhlIHJlc3VsdGluZyBudW1iZXIgaXMgYSBzYWZlIGludGVnZXIuIEJvdGhcbiAqIFwiMHhcIi1wcmVmaXhlZCBhbmQgdW5wcmVmaXhlZCBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuXG4gKlxuICogVG8gY29udmVydCBhIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIGBiaWdpbnRgIGluc3RlYWQsIHVzZVxuICoge0BsaW5rIGhleFRvQmlnSW50fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogaGV4VG9OdW1iZXIoJzB4MCcpOyAvLyAwXG4gKiBoZXhUb051bWJlcignMHgxJyk7IC8vIDFcbiAqIGhleFRvTnVtYmVyKCcweDEwJyk7IC8vIDE2XG4gKiBgYGBcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydCB0byBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIuXG4gKiBAdGhyb3dzIElmIHRoZSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmcsIG9yIGlmIHRoZSByZXN1bHRpbmdcbiAqIG51bWJlciBpcyBub3QgYSBzYWZlIGludGVnZXIuXG4gKi9cbmNvbnN0IGhleFRvTnVtYmVyID0gKHZhbHVlKSA9PiB7XG4gICAgKDAsIGhleF8xLmFzc2VydElzSGV4U3RyaW5nKSh2YWx1ZSk7XG4gICAgLy8gYHBhcnNlSW50YCBhY2NlcHRzIHZhbHVlcyB3aXRob3V0IHRoZSBcIjB4XCItcHJlZml4LCB3aGVyZWFzIGBOdW1iZXJgIGRvZXNcbiAgICAvLyBub3QuIFVzaW5nIHRoaXMgaXMgc2xpZ2h0bHkgZmFzdGVyIHRoYW4gYE51bWJlcihhZGQweCh2YWx1ZSkpYC5cbiAgICBjb25zdCBudW1iZXJWYWx1ZSA9IHBhcnNlSW50KHZhbHVlLCAxNik7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydCkoTnVtYmVyLmlzU2FmZUludGVnZXIobnVtYmVyVmFsdWUpLCAnVmFsdWUgaXMgbm90IGEgc2FmZSBpbnRlZ2VyLiBVc2UgYGhleFRvQmlnSW50YCBpbnN0ZWFkLicpO1xuICAgIHJldHVybiBudW1iZXJWYWx1ZTtcbn07XG5leHBvcnRzLmhleFRvTnVtYmVyID0gaGV4VG9OdW1iZXI7XG4vKipcbiAqIENvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBgYmlnaW50YC4gVGhpcyB2ZXJpZmllcyB0aGF0IHRoZSBzdHJpbmcgaXNcbiAqIGEgdmFsaWQgaGV4IHN0cmluZy4gQm90aCBcIjB4XCItcHJlZml4ZWQgYW5kIHVucHJlZml4ZWQgc3RyaW5ncyBhcmUgc3VwcG9ydGVkLlxuICpcbiAqIFRvIGNvbnZlcnQgYSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gYSBudW1iZXIgaW5zdGVhZCwgdXNlIHtAbGluayBoZXhUb051bWJlcn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhleFRvQmlnSW50KCcweDAnKTsgLy8gMG5cbiAqIGhleFRvQmlnSW50KCcweDEnKTsgLy8gMW5cbiAqIGhleFRvQmlnSW50KCcweDEwJyk7IC8vIDE2blxuICogYGBgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaGV4YWRlY2ltYWwgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSBgYmlnaW50YC5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YC5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuY29uc3QgaGV4VG9CaWdJbnQgPSAodmFsdWUpID0+IHtcbiAgICAoMCwgaGV4XzEuYXNzZXJ0SXNIZXhTdHJpbmcpKHZhbHVlKTtcbiAgICAvLyBUaGUgYEJpZ0ludGAgY29uc3RydWN0b3IgcmVxdWlyZXMgdGhlIFwiMHhcIi1wcmVmaXggdG8gcGFyc2UgYSBoZXggc3RyaW5nLlxuICAgIHJldHVybiBCaWdJbnQoKDAsIGhleF8xLmFkZDB4KSh2YWx1ZSkpO1xufTtcbmV4cG9ydHMuaGV4VG9CaWdJbnQgPSBoZXhUb0JpZ0ludDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW51bWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wYXF1ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudGltZVNpbmNlID0gZXhwb3J0cy5pbk1pbGxpc2Vjb25kcyA9IGV4cG9ydHMuRHVyYXRpb24gPSB2b2lkIDA7XG4vKipcbiAqIENvbW1vbiBkdXJhdGlvbiBjb25zdGFudHMsIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xudmFyIER1cmF0aW9uO1xuKGZ1bmN0aW9uIChEdXJhdGlvbikge1xuICAgIC8qKlxuICAgICAqIEEgbWlsbGlzZWNvbmQuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJNaWxsaXNlY29uZFwiXSA9IDFdID0gXCJNaWxsaXNlY29uZFwiO1xuICAgIC8qKlxuICAgICAqIEEgc2Vjb25kLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJTZWNvbmRcIl0gPSAxMDAwXSA9IFwiU2Vjb25kXCI7XG4gICAgLyoqXG4gICAgICogQSBtaW51dGUsIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIk1pbnV0ZVwiXSA9IDYwMDAwXSA9IFwiTWludXRlXCI7XG4gICAgLyoqXG4gICAgICogQW4gaG91ciwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiSG91clwiXSA9IDM2MDAwMDBdID0gXCJIb3VyXCI7XG4gICAgLyoqXG4gICAgICogQSBkYXksIGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKi9cbiAgICBEdXJhdGlvbltEdXJhdGlvbltcIkRheVwiXSA9IDg2NDAwMDAwXSA9IFwiRGF5XCI7XG4gICAgLyoqXG4gICAgICogQSB3ZWVrLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgRHVyYXRpb25bRHVyYXRpb25bXCJXZWVrXCJdID0gNjA0ODAwMDAwXSA9IFwiV2Vla1wiO1xuICAgIC8qKlxuICAgICAqIEEgeWVhciwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIER1cmF0aW9uW0R1cmF0aW9uW1wiWWVhclwiXSA9IDMxNTM2MDAwMDAwXSA9IFwiWWVhclwiO1xufSkoRHVyYXRpb24gPSBleHBvcnRzLkR1cmF0aW9uIHx8IChleHBvcnRzLkR1cmF0aW9uID0ge30pKTtcbmNvbnN0IGlzTm9uTmVnYXRpdmVJbnRlZ2VyID0gKG51bWJlcikgPT4gTnVtYmVyLmlzSW50ZWdlcihudW1iZXIpICYmIG51bWJlciA+PSAwO1xuY29uc3QgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIgPSAobnVtYmVyLCBuYW1lKSA9PiB7XG4gICAgaWYgKCFpc05vbk5lZ2F0aXZlSW50ZWdlcihudW1iZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLiBSZWNlaXZlZDogXCIke251bWJlcn1cIi5gKTtcbiAgICB9XG59O1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBtaWxsaXNlY29uZCB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB1bml0cyBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdW5pdHMgb2YgdGltZS5cbiAqIEBwYXJhbSBkdXJhdGlvbiAtIFRoZSB1bml0IG9mIHRpbWUgdG8gY291bnQuXG4gKiBAcmV0dXJucyBUaGUgY291bnQgbXVsdGlwbGllZCBieSB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxuICovXG5mdW5jdGlvbiBpbk1pbGxpc2Vjb25kcyhjb3VudCwgZHVyYXRpb24pIHtcbiAgICBhc3NlcnRJc05vbk5lZ2F0aXZlSW50ZWdlcihjb3VudCwgJ2NvdW50Jyk7XG4gICAgcmV0dXJuIGNvdW50ICogZHVyYXRpb247XG59XG5leHBvcnRzLmluTWlsbGlzZWNvbmRzID0gaW5NaWxsaXNlY29uZHM7XG4vKipcbiAqIEdldHMgdGhlIG1pbGxpc2Vjb25kcyBzaW5jZSBhIHBhcnRpY3VsYXIgVW5peCBlcG9jaCB0aW1lc3RhbXAuXG4gKlxuICogQHBhcmFtIHRpbWVzdGFtcCAtIEEgVW5peCBtaWxsaXNlY29uZCB0aW1lc3RhbXAuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHNpbmNlIHRoZSBzcGVjaWZpZWQgdGltZXN0YW1wLlxuICovXG5mdW5jdGlvbiB0aW1lU2luY2UodGltZXN0YW1wKSB7XG4gICAgYXNzZXJ0SXNOb25OZWdhdGl2ZUludGVnZXIodGltZXN0YW1wLCAndGltZXN0YW1wJyk7XG4gICAgcmV0dXJuIERhdGUubm93KCkgLSB0aW1lc3RhbXA7XG59XG5leHBvcnRzLnRpbWVTaW5jZSA9IHRpbWVTaW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNhdGlzZmllc1ZlcnNpb25SYW5nZSA9IGV4cG9ydHMuZ3RSYW5nZSA9IGV4cG9ydHMuZ3RWZXJzaW9uID0gZXhwb3J0cy5hc3NlcnRJc1NlbVZlclJhbmdlID0gZXhwb3J0cy5hc3NlcnRJc1NlbVZlclZlcnNpb24gPSBleHBvcnRzLmlzVmFsaWRTZW1WZXJSYW5nZSA9IGV4cG9ydHMuaXNWYWxpZFNlbVZlclZlcnNpb24gPSBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCA9IGV4cG9ydHMuVmVyc2lvblN0cnVjdCA9IHZvaWQgMDtcbmNvbnN0IHNlbXZlcl8xID0gcmVxdWlyZShcInNlbXZlclwiKTtcbmNvbnN0IHN1cGVyc3RydWN0XzEgPSByZXF1aXJlKFwic3VwZXJzdHJ1Y3RcIik7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCIuL2Fzc2VydFwiKTtcbi8qKlxuICogQSBzdHJ1Y3QgZm9yIHZhbGlkYXRpbmcgYSB2ZXJzaW9uIHN0cmluZy5cbiAqL1xuZXhwb3J0cy5WZXJzaW9uU3RydWN0ID0gKDAsIHN1cGVyc3RydWN0XzEucmVmaW5lKSgoMCwgc3VwZXJzdHJ1Y3RfMS5zdHJpbmcpKCksICdWZXJzaW9uJywgKHZhbHVlKSA9PiB7XG4gICAgaWYgKCgwLCBzZW12ZXJfMS52YWxpZCkodmFsdWUpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0ZWQgU2VtVmVyIHZlcnNpb24sIGdvdCBcIiR7dmFsdWV9XCJgO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0pO1xuZXhwb3J0cy5WZXJzaW9uUmFuZ2VTdHJ1Y3QgPSAoMCwgc3VwZXJzdHJ1Y3RfMS5yZWZpbmUpKCgwLCBzdXBlcnN0cnVjdF8xLnN0cmluZykoKSwgJ1ZlcnNpb24gcmFuZ2UnLCAodmFsdWUpID0+IHtcbiAgICBpZiAoKDAsIHNlbXZlcl8xLnZhbGlkUmFuZ2UpKHZhbHVlKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gYEV4cGVjdGVkIFNlbVZlciByYW5nZSwgZ290IFwiJHt2YWx1ZX1cImA7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBBIHBvdGVudGlhbCB2ZXJzaW9uLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2ZXJzaW9uIGlzIHZhbGlkLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTZW1WZXJWZXJzaW9uKHZlcnNpb24pIHtcbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEuaXMpKHZlcnNpb24sIGV4cG9ydHMuVmVyc2lvblN0cnVjdCk7XG59XG5leHBvcnRzLmlzVmFsaWRTZW1WZXJWZXJzaW9uID0gaXNWYWxpZFNlbVZlclZlcnNpb247XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gcmFuZ2UgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHZlcnNpb25SYW5nZSAtIEEgcG90ZW50aWFsIHZlcnNpb24gcmFuZ2UuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZlcnNpb24gcmFuZ2UgaXMgdmFsaWQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNlbVZlclJhbmdlKHZlcnNpb25SYW5nZSkge1xuICAgIHJldHVybiAoMCwgc3VwZXJzdHJ1Y3RfMS5pcykodmVyc2lvblJhbmdlLCBleHBvcnRzLlZlcnNpb25SYW5nZVN0cnVjdCk7XG59XG5leHBvcnRzLmlzVmFsaWRTZW1WZXJSYW5nZSA9IGlzVmFsaWRTZW1WZXJSYW5nZTtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBjb25jcmV0ZSBTZW1WZXIgdmVyc2lvbi5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEEgcG90ZW50aWFsIFNlbVZlciBjb25jcmV0ZSB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1NlbVZlclZlcnNpb24odmVyc2lvbikge1xuICAgICgwLCBhc3NlcnRfMS5hc3NlcnRTdHJ1Y3QpKHZlcnNpb24sIGV4cG9ydHMuVmVyc2lvblN0cnVjdCk7XG59XG5leHBvcnRzLmFzc2VydElzU2VtVmVyVmVyc2lvbiA9IGFzc2VydElzU2VtVmVyVmVyc2lvbjtcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBTZW1WZXIgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHJhbmdlIC0gQSBwb3RlbnRpYWwgU2VtVmVyIHJhbmdlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRJc1NlbVZlclJhbmdlKHJhbmdlKSB7XG4gICAgKDAsIGFzc2VydF8xLmFzc2VydFN0cnVjdCkocmFuZ2UsIGV4cG9ydHMuVmVyc2lvblJhbmdlU3RydWN0KTtcbn1cbmV4cG9ydHMuYXNzZXJ0SXNTZW1WZXJSYW5nZSA9IGFzc2VydElzU2VtVmVyUmFuZ2U7XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgU2VtVmVyIHZlcnNpb24gaXMgZ3JlYXRlciB0aGFuIGFub3RoZXIuXG4gKlxuICogQHBhcmFtIHZlcnNpb24xIC0gVGhlIGxlZnQtaGFuZCB2ZXJzaW9uLlxuICogQHBhcmFtIHZlcnNpb24yIC0gVGhlIHJpZ2h0LWhhbmQgdmVyc2lvbi5cbiAqIEByZXR1cm5zIGB2ZXJzaW9uMSA+IHZlcnNpb24yYC5cbiAqL1xuZnVuY3Rpb24gZ3RWZXJzaW9uKHZlcnNpb24xLCB2ZXJzaW9uMikge1xuICAgIHJldHVybiAoMCwgc2VtdmVyXzEuZ3QpKHZlcnNpb24xLCB2ZXJzaW9uMik7XG59XG5leHBvcnRzLmd0VmVyc2lvbiA9IGd0VmVyc2lvbjtcbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHBvc3NpYmlsaXRpZXMgaW4gYSByYW5nZS5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIEEgU2VtdlZlciB2ZXJzaW9uLlxuICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyBgdmVyc2lvbiA+IHJhbmdlYC5cbiAqL1xuZnVuY3Rpb24gZ3RSYW5nZSh2ZXJzaW9uLCByYW5nZSkge1xuICAgIHJldHVybiAoMCwgc2VtdmVyXzEuZ3RyKSh2ZXJzaW9uLCByYW5nZSk7XG59XG5leHBvcnRzLmd0UmFuZ2UgPSBndFJhbmdlO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgYSBTZW1WZXIgdmVyc2lvbiBzYXRpc2ZpZXMgYSBTZW1WZXIgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgU2VtVmVyIHZlcnNpb24gdG8gY2hlY2suXG4gKiBAcGFyYW0gdmVyc2lvblJhbmdlIC0gVGhlIFNlbVZlciB2ZXJzaW9uIHJhbmdlIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2ZXJzaW9uIHNhdGlzZmllZCB0aGUgdmVyc2lvbiByYW5nZS5cbiAqL1xuZnVuY3Rpb24gc2F0aXNmaWVzVmVyc2lvblJhbmdlKHZlcnNpb24sIHZlcnNpb25SYW5nZSkge1xuICAgIHJldHVybiAoMCwgc2VtdmVyXzEuc2F0aXNmaWVzKSh2ZXJzaW9uLCB2ZXJzaW9uUmFuZ2UsIHtcbiAgICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnRzLnNhdGlzZmllc1ZlcnNpb25SYW5nZSA9IHNhdGlzZmllc1ZlcnNpb25SYW5nZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb25zLmpzLm1hcCIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJvY2Vzc0ZuID0gKGZuLCBvcHRzKSA9PiBmdW5jdGlvbiAoKSB7XG5cdGNvbnN0IFAgPSBvcHRzLnByb21pc2VNb2R1bGU7XG5cdGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBQKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAob3B0cy5lcnJvckZpcnN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMudW5zaGlmdChlcnIpO1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3VsdHMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChvYmosIG9wdHMpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGV4Y2x1ZGU6IFsvLisoU3luY3xTdHJlYW0pJC9dLFxuXHRcdGVycm9yRmlyc3Q6IHRydWUsXG5cdFx0cHJvbWlzZU1vZHVsZTogUHJvbWlzZVxuXHR9LCBvcHRzKTtcblxuXHRjb25zdCBmaWx0ZXIgPSBrZXkgPT4ge1xuXHRcdGNvbnN0IG1hdGNoID0gcGF0dGVybiA9PiB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHRyZXR1cm4gb3B0cy5pbmNsdWRlID8gb3B0cy5pbmNsdWRlLnNvbWUobWF0Y2gpIDogIW9wdHMuZXhjbHVkZS5zb21lKG1hdGNoKTtcblx0fTtcblxuXHRsZXQgcmV0O1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChvcHRzLmV4Y2x1ZGVNYWluKSB7XG5cdFx0XHRcdHJldHVybiBvYmouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2Nlc3NGbihvYmosIG9wdHMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuXHRcdGNvbnN0IHggPSBvYmpba2V5XTtcblx0XHRyZXRba2V5XSA9IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihrZXkpID8gcHJvY2Vzc0ZuKHgsIG9wdHMpIDogeDtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm92aWRlci1mcm9tLWVuZ2luZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXItZnJvbS1taWRkbGV3YXJlXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcm92aWRlckZyb21FbmdpbmUgPSB2b2lkIDA7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfcHJvdmlkZXJfMSA9IHJlcXVpcmUoXCIuL3NhZmUtZXZlbnQtZW1pdHRlci1wcm92aWRlclwiKTtcbi8qKlxuICogQ29uc3RydWN0IGFuIEV0aGVyZXVtIHByb3ZpZGVyIGZyb20gdGhlIGdpdmVuIEpTT04tUlBDIGVuZ2luZS5cbiAqXG4gKiBAcGFyYW0gZW5naW5lIC0gVGhlIEpTT04tUlBDIGVuZ2luZSB0byBjb25zdHJ1Y3QgYSBwcm92aWRlciBmcm9tLlxuICogQHJldHVybnMgQW4gRXRoZXJldW0gcHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIHByb3ZpZGVyRnJvbUVuZ2luZShlbmdpbmUpIHtcbiAgICByZXR1cm4gbmV3IHNhZmVfZXZlbnRfZW1pdHRlcl9wcm92aWRlcl8xLlNhZmVFdmVudEVtaXR0ZXJQcm92aWRlcih7IGVuZ2luZSB9KTtcbn1cbmV4cG9ydHMucHJvdmlkZXJGcm9tRW5naW5lID0gcHJvdmlkZXJGcm9tRW5naW5lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvdmlkZXItZnJvbS1lbmdpbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb3ZpZGVyRnJvbU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBwcm92aWRlcl9mcm9tX2VuZ2luZV8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXItZnJvbS1lbmdpbmVcIik7XG4vKipcbiAqIENvbnN0cnVjdCBhbiBFdGhlcmV1bSBwcm92aWRlciBmcm9tIHRoZSBnaXZlbiBtaWRkbGV3YXJlLlxuICpcbiAqIEBwYXJhbSBtaWRkbGV3YXJlIC0gVGhlIG1pZGRsZXdhcmUgdG8gY29uc3RydWN0IGEgcHJvdmlkZXIgZnJvbS5cbiAqIEByZXR1cm5zIEFuIEV0aGVyZXVtIHByb3ZpZGVyLlxuICovXG5mdW5jdGlvbiBwcm92aWRlckZyb21NaWRkbGV3YXJlKG1pZGRsZXdhcmUpIHtcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcganNvbl9ycGNfZW5naW5lXzEuSnNvblJwY0VuZ2luZSgpO1xuICAgIGVuZ2luZS5wdXNoKG1pZGRsZXdhcmUpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gKDAsIHByb3ZpZGVyX2Zyb21fZW5naW5lXzEucHJvdmlkZXJGcm9tRW5naW5lKShlbmdpbmUpO1xuICAgIHJldHVybiBwcm92aWRlcjtcbn1cbmV4cG9ydHMucHJvdmlkZXJGcm9tTWlkZGxld2FyZSA9IHByb3ZpZGVyRnJvbU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1mcm9tLW1pZGRsZXdhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX1NhZmVFdmVudEVtaXR0ZXJQcm92aWRlcl9lbmdpbmU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNhZmVFdmVudEVtaXR0ZXJQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbi8qKlxuICogQW4gRXRoZXJldW0gcHJvdmlkZXIuXG4gKlxuICogVGhpcyBwcm92aWRlciBsb29zZWx5IGZvbGxvd3MgY29udmVudGlvbnMgdGhhdCBwcmUtZGF0ZSBFSVAtMTE5My5cbiAqIEl0IGlzIG5vdCBjb21wbGlhbnQgd2l0aCBhbnkgRXRoZXJldW0gcHJvdmlkZXIgc3RhbmRhcmQuXG4gKi9cbmNsYXNzIFNhZmVFdmVudEVtaXR0ZXJQcm92aWRlciBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhIFNhZmVFdmVudEVtaXR0ZXJQcm92aWRlciBmcm9tIGEgSlNPTi1SUEMgZW5naW5lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmVuZ2luZSAtIFRoZSBKU09OLVJQQyBlbmdpbmUgdXNlZCB0byBwcm9jZXNzIHJlcXVlc3RzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgZW5naW5lIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgX1NhZmVFdmVudEVtaXR0ZXJQcm92aWRlcl9lbmdpbmUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kIGEgcHJvdmlkZXIgcmVxdWVzdCBhc3luY2hyb25vdXNseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHJlcSAtIFRoZSByZXF1ZXN0IHRvIHNlbmQuXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdXBvbiB0aGUgc3VjY2VzcyBvciBmYWlsdXJlIG9mIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kQXN5bmMgPSAocmVxLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2FmZUV2ZW50RW1pdHRlclByb3ZpZGVyX2VuZ2luZSwgXCJmXCIpLmhhbmRsZShyZXEsIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgYSBwcm92aWRlciByZXF1ZXN0IGFzeW5jaHJvbm91c2x5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBzZXJ2ZXMgdGhlIHNhbWUgcHVycG9zZSBhcyBgc2VuZEFzeW5jYC4gSXQgb25seSBleGlzdHMgZm9yXG4gICAgICAgICAqIGxlZ2FjeSByZWFzb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHNlbmRBc3luY2AgaW5zdGVhZC5cbiAgICAgICAgICogQHBhcmFtIHJlcSAtIFRoZSByZXF1ZXN0IHRvIHNlbmQuXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdXBvbiB0aGUgc3VjY2VzcyBvciBmYWlsdXJlIG9mIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kID0gKHJlcSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBjYWxsYmFjayB0byBcInNlbmRcIiBtZXRob2QuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXJfZW5naW5lLCBcImZcIikuaGFuZGxlKHJlcSwgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXJfZW5naW5lLCBlbmdpbmUsIFwiZlwiKTtcbiAgICAgICAgaWYgKGVuZ2luZS5vbikge1xuICAgICAgICAgICAgZW5naW5lLm9uKCdub3RpZmljYXRpb24nLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNhZmVFdmVudEVtaXR0ZXJQcm92aWRlciA9IFNhZmVFdmVudEVtaXR0ZXJQcm92aWRlcjtcbl9TYWZlRXZlbnRFbWl0dGVyUHJvdmlkZXJfZW5naW5lID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNhZmUtZXZlbnQtZW1pdHRlci1wcm92aWRlci5qcy5tYXAiLCJjb25zdCBlbmNyeXB0b3IgPSByZXF1aXJlKCdAbWV0YW1hc2svYnJvd3Nlci1wYXNzd29yZGVyJyk7XG5jb25zdCBIZEtleXJpbmcgPSByZXF1aXJlKCdAbWV0YW1hc2svZXRoLWhkLWtleXJpbmcnKTtcbmNvbnN0IHsgbm9ybWFsaXplOiBub3JtYWxpemVBZGRyZXNzIH0gPSByZXF1aXJlKCdAbWV0YW1hc2svZXRoLXNpZy11dGlsJyk7XG5jb25zdCBTaW1wbGVLZXlyaW5nID0gcmVxdWlyZSgnQG1ldGFtYXNrL2V0aC1zaW1wbGUta2V5cmluZycpO1xuLy8gVE9ETzogU3RvcCB1c2luZyBgZXZlbnRzYCwgYW5kIHJlbW92ZSB0aGUgbm90aWNlIGFib3V0IHRoaXMgZnJvbSB0aGUgUkVBRE1FXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLW5vZGVqcy1tb2R1bGVzXG5jb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmUgPSByZXF1aXJlKCdvYnMtc3RvcmUnKTtcblxuY29uc3QgZGVmYXVsdEtleXJpbmdCdWlsZGVycyA9IFtcbiAga2V5cmluZ0J1aWxkZXJGYWN0b3J5KFNpbXBsZUtleXJpbmcpLFxuICBrZXlyaW5nQnVpbGRlckZhY3RvcnkoSGRLZXlyaW5nKSxcbl07XG5cbmNvbnN0IEtFWVJJTkdTX1RZUEVfTUFQID0ge1xuICBIRF9LRVlSSU5HOiAnSEQgS2V5IFRyZWUnLFxuICBTSU1QTEVfS0VZUklORzogJ1NpbXBsZSBLZXkgUGFpcicsXG59O1xuXG4vKipcbiAqIFN0cmlwIHRoZSBoZXggcHJlZml4IGZyb20gYW4gYWRkcmVzcywgaWYgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRoYXQgbWlnaHQgYmUgaGV4IHByZWZpeGVkLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGFkZHJlc3Mgd2l0aG91dCBhIGhleCBwcmVmaXguXG4gKi9cbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KGFkZHJlc3MpIHtcbiAgaWYgKGFkZHJlc3Muc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgIHJldHVybiBhZGRyZXNzLnNsaWNlKDIpO1xuICB9XG4gIHJldHVybiBhZGRyZXNzO1xufVxuXG5jbGFzcyBLZXlyaW5nQ29udHJvbGxlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8vXG4gIC8vIFBVQkxJQyBNRVRIT0RTXG4gIC8vXG5cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3QgaW5pdFN0YXRlID0gb3B0cy5pbml0U3RhdGUgfHwge307XG4gICAgdGhpcy5rZXlyaW5nQnVpbGRlcnMgPSBvcHRzLmtleXJpbmdCdWlsZGVyc1xuICAgICAgPyBkZWZhdWx0S2V5cmluZ0J1aWxkZXJzLmNvbmNhdChvcHRzLmtleXJpbmdCdWlsZGVycylcbiAgICAgIDogZGVmYXVsdEtleXJpbmdCdWlsZGVycztcbiAgICB0aGlzLnN0b3JlID0gbmV3IE9ic2VydmFibGVTdG9yZShpbml0U3RhdGUpO1xuICAgIHRoaXMubWVtU3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIGlzVW5sb2NrZWQ6IGZhbHNlLFxuICAgICAga2V5cmluZ1R5cGVzOiB0aGlzLmtleXJpbmdCdWlsZGVycy5tYXAoXG4gICAgICAgIChrZXlyaW5nQnVpbGRlcikgPT4ga2V5cmluZ0J1aWxkZXIudHlwZSxcbiAgICAgICksXG4gICAgICBrZXlyaW5nczogW10sXG4gICAgICBlbmNyeXB0aW9uS2V5OiBudWxsLFxuICAgIH0pO1xuXG4gICAgdGhpcy5lbmNyeXB0b3IgPSBvcHRzLmVuY3J5cHRvciB8fCBlbmNyeXB0b3I7XG4gICAgdGhpcy5rZXlyaW5ncyA9IFtdO1xuICAgIHRoaXMuX3Vuc3VwcG9ydGVkS2V5cmluZ3MgPSBbXTtcblxuICAgIC8vIFRoaXMgb3B0aW9uIGFsbG93cyB0aGUgY29udHJvbGxlciB0byBjYWNoZSBhbiBleHBvcnRlZCBrZXlcbiAgICAvLyBmb3IgdXNlIGluIGRlY3J5cHRpbmcgYW5kIGVuY3J5cHRpbmcgZGF0YSB3aXRob3V0IHBhc3N3b3JkXG4gICAgdGhpcy5jYWNoZUVuY3J5cHRpb25LZXkgPSBCb29sZWFuKG9wdHMuY2FjaGVFbmNyeXB0aW9uS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdWxsIFVwZGF0ZVxuICAgKlxuICAgKiBFbWl0cyB0aGUgYHVwZGF0ZWAgZXZlbnQgYW5kIEByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvXG4gICAqIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKlxuICAgKiBGcmVxdWVudGx5IHVzZWQgdG8gZW5kIGFzeW5jaHJvbm91cyBjaGFpbnMgaW4gdGhpcyBjbGFzcyxcbiAgICogaW5kaWNhdGluZyBjb25zdW1lcnMgY2FuIG9mdGVuIGVpdGhlciBsaXN0ZW4gZm9yIHVwZGF0ZXMsXG4gICAqIG9yIGFjY2VwdCBhIHN0YXRlLXJlc29sdmluZyBwcm9taXNlIHRvIGNvbnN1bWUgdGhlaXIgcmVzdWx0cy5cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gVGhlIGNvbnRyb2xsZXIgc3RhdGUuXG4gICAqL1xuICBmdWxsVXBkYXRlKCkge1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5tZW1TdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICByZXR1cm4gdGhpcy5tZW1TdG9yZS5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBOZXcgVmF1bHQgQW5kIEtleWNoYWluXG4gICAqXG4gICAqIERlc3Ryb3lzIGFueSBvbGQgZW5jcnlwdGVkIHN0b3JhZ2UsXG4gICAqIGNyZWF0ZXMgYSBuZXcgZW5jcnlwdGVkIHN0b3JlIHdpdGggdGhlIGdpdmVuIHBhc3N3b3JkLFxuICAgKiByYW5kb21seSBjcmVhdGVzIGEgbmV3IEhEIHdhbGxldCB3aXRoIDEgYWNjb3VudCxcbiAgICogZmF1Y2V0cyB0aGF0IGFjY291bnQgb24gdGhlIHRlc3RuZXQuXG4gICAqXG4gICAqIEBmaXJlcyBLZXlyaW5nQ29udHJvbGxlciN1bmxvY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVGhlIHBhc3N3b3JkIHRvIGVuY3J5cHQgdGhlIHZhdWx0IHdpdGguXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzdGF0ZS5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZU5ld1ZhdWx0QW5kS2V5Y2hhaW4ocGFzc3dvcmQpIHtcbiAgICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG5cbiAgICBhd2FpdCB0aGlzLmNyZWF0ZUZpcnN0S2V5VHJlZSgpO1xuICAgIHRoaXMuc2V0VW5sb2NrZWQoKTtcbiAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlXG4gICAqXG4gICAqIERlc3Ryb3lzIGFueSBvbGQgZW5jcnlwdGVkIHN0b3JhZ2UsXG4gICAqIGNyZWF0ZXMgYSBuZXcgZW5jcnlwdGVkIHN0b3JlIHdpdGggdGhlIGdpdmVuIHBhc3N3b3JkLFxuICAgKiBjcmVhdGVzIGEgbmV3IEhEIHdhbGxldCBmcm9tIHRoZSBnaXZlbiBzZWVkIHdpdGggMSBhY2NvdW50LlxuICAgKlxuICAgKiBAZmlyZXMgS2V5cmluZ0NvbnRyb2xsZXIjdW5sb2NrXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSBwYXNzd29yZCB0byBlbmNyeXB0IHRoZSB2YXVsdCB3aXRoLlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXkgfCBzdHJpbmd9IHNlZWRQaHJhc2UgLSBUaGUgQklQMzktY29tcGxpYW50IHNlZWQgcGhyYXNlLFxuICAgKiBlaXRoZXIgYXMgYSBzdHJpbmcgb3IgVWludDhBcnJheS5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHN0YXRlLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKHBhc3N3b3JkLCBzZWVkUGhyYXNlKSB7XG4gICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc3dvcmQgbXVzdCBiZSB0ZXh0LicpO1xuICAgIH1cbiAgICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG5cbiAgICBhd2FpdCB0aGlzLmNsZWFyS2V5cmluZ3MoKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5hZGROZXdLZXlyaW5nKEtFWVJJTkdTX1RZUEVfTUFQLkhEX0tFWVJJTkcsIHtcbiAgICAgIG1uZW1vbmljOiBzZWVkUGhyYXNlLFxuICAgICAgbnVtYmVyT2ZBY2NvdW50czogMSxcbiAgICB9KTtcbiAgICBjb25zdCBbZmlyc3RBY2NvdW50XSA9IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcblxuICAgIGlmICghZmlyc3RBY2NvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tleXJpbmdDb250cm9sbGVyIC0gRmlyc3QgQWNjb3VudCBub3QgZm91bmQuJyk7XG4gICAgfVxuICAgIHRoaXMuc2V0VW5sb2NrZWQoKTtcbiAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IExvY2tlZFxuICAgKiBUaGlzIG1ldGhvZCBkZWFsbG9jYXRlcyBhbGwgc2VjcmV0cywgYW5kIGVmZmVjdGl2ZWx5IGxvY2tzIE1ldGFNYXNrLlxuICAgKlxuICAgKiBAZmlyZXMgS2V5cmluZ0NvbnRyb2xsZXIjbG9ja1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc3RhdGUuXG4gICAqL1xuICBhc3luYyBzZXRMb2NrZWQoKSB7XG4gICAgZGVsZXRlIHRoaXMucGFzc3dvcmQ7XG5cbiAgICAvLyBzZXQgbG9ja2VkXG4gICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICBpc1VubG9ja2VkOiBmYWxzZSxcbiAgICAgIGVuY3J5cHRpb25LZXk6IG51bGwsXG4gICAgICBlbmNyeXB0aW9uU2FsdDogbnVsbCxcbiAgICB9KTtcblxuICAgIC8vIHJlbW92ZSBrZXlyaW5nc1xuICAgIHRoaXMua2V5cmluZ3MgPSBbXTtcbiAgICBhd2FpdCB0aGlzLl91cGRhdGVNZW1TdG9yZUtleXJpbmdzKCk7XG4gICAgdGhpcy5lbWl0KCdsb2NrJyk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdCBwYXNzd29yZC5cbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gZGVjcnlwdCB0aGUgY3VycmVudCB2YXVsdCBhbmQgbG9hZCBpdHMga2V5cmluZ3NcbiAgICogaW50byBtZW1vcnkuXG4gICAqXG4gICAqIFRlbXBvcmFyaWx5IGFsc28gbWlncmF0ZXMgYW55IG9sZC1zdHlsZSB2YXVsdHMgZmlyc3QsIGFzIHdlbGxcbiAgICogKFByZSBNZXRhTWFzayAzLjAuMCkuXG4gICAqXG4gICAqIEBmaXJlcyBLZXlyaW5nQ29udHJvbGxlciN1bmxvY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVGhlIGtleXJpbmcgY29udHJvbGxlciBwYXNzd29yZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHN0YXRlLlxuICAgKi9cbiAgYXN5bmMgc3VibWl0UGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICB0aGlzLmtleXJpbmdzID0gYXdhaXQgdGhpcy51bmxvY2tLZXlyaW5ncyhwYXNzd29yZCk7XG5cbiAgICB0aGlzLnNldFVubG9ja2VkKCk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1Ym1pdCBFbmNyeXB0aW9uIEtleS5cbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gZGVjcnlwdCB0aGUgY3VycmVudCB2YXVsdCBhbmQgbG9hZCBpdHMga2V5cmluZ3NcbiAgICogaW50byBtZW1vcnkgYmFzZWQgb24gdGhlIHZhdWx0IGFuZCBDcnlwdG9LZXkgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEBmaXJlcyBLZXlyaW5nQ29udHJvbGxlciN1bmxvY2tcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuY3J5cHRpb25LZXkgLSBUaGUgZW5jcnlwdGVkIGtleSBpbmZvcm1hdGlvbiB1c2VkIHRvIGRlY3J5cHQgdGhlIHZhdWx0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5jcnlwdGlvblNhbHQgLSBUaGUgc2FsdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBsYXN0IGtleS5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHN0YXRlLlxuICAgKi9cbiAgYXN5bmMgc3VibWl0RW5jcnlwdGlvbktleShlbmNyeXB0aW9uS2V5LCBlbmNyeXB0aW9uU2FsdCkge1xuICAgIHRoaXMua2V5cmluZ3MgPSBhd2FpdCB0aGlzLnVubG9ja0tleXJpbmdzKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgZW5jcnlwdGlvbktleSxcbiAgICAgIGVuY3J5cHRpb25TYWx0LFxuICAgICk7XG4gICAgdGhpcy5zZXRVbmxvY2tlZCgpO1xuICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgUGFzc3dvcmRcbiAgICpcbiAgICogQXR0ZW1wdHMgdG8gZGVjcnlwdCB0aGUgY3VycmVudCB2YXVsdCB3aXRoIGEgZ2l2ZW4gcGFzc3dvcmRcbiAgICogdG8gdmVyaWZ5IGl0cyB2YWxpZGl0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVGhlIHZhdWx0IHBhc3N3b3JkLlxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICBjb25zdCBlbmNyeXB0ZWRWYXVsdCA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS52YXVsdDtcbiAgICBpZiAoIWVuY3J5cHRlZFZhdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bmxvY2sgd2l0aG91dCBhIHByZXZpb3VzIHZhdWx0LicpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLmVuY3J5cHRvci5kZWNyeXB0KHBhc3N3b3JkLCBlbmNyeXB0ZWRWYXVsdCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIE5ldyBLZXlyaW5nXG4gICAqXG4gICAqIEFkZHMgYSBuZXcgS2V5cmluZyBvZiB0aGUgZ2l2ZW4gYHR5cGVgIHRvIHRoZSB2YXVsdFxuICAgKiBhbmQgdGhlIGN1cnJlbnQgZGVjcnlwdGVkIEtleXJpbmdzIGFycmF5LlxuICAgKlxuICAgKiBBbGwgS2V5cmluZyBjbGFzc2VzIGltcGxlbWVudCBhIHVuaXF1ZSBgdHlwZWAgc3RyaW5nLFxuICAgKiBhbmQgdGhpcyBpcyB1c2VkIHRvIHJldHJpZXZlIHRoZW0gZnJvbSB0aGUga2V5cmluZ0J1aWxkZXJzIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGtleXJpbmcgdG8gYWRkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIFRoZSBjb25zdHJ1Y3RvciBvcHRpb25zIGZvciB0aGUga2V5cmluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8S2V5cmluZz59IFRoZSBuZXcga2V5cmluZy5cbiAgICovXG4gIGFzeW5jIGFkZE5ld0tleXJpbmcodHlwZSwgb3B0cykge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLl9uZXdLZXlyaW5nKHR5cGUsIG9wdHMpO1xuXG4gICAgaWYgKCghb3B0cyB8fCAhb3B0cy5tbmVtb25pYykgJiYgdHlwZSA9PT0gS0VZUklOR1NfVFlQRV9NQVAuSERfS0VZUklORykge1xuICAgICAga2V5cmluZy5nZW5lcmF0ZVJhbmRvbU1uZW1vbmljKCk7XG4gICAgICBhd2FpdCBrZXlyaW5nLmFkZEFjY291bnRzKCk7XG4gICAgfVxuXG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgYXdhaXQgdGhpcy5jaGVja0ZvckR1cGxpY2F0ZSh0eXBlLCBhY2NvdW50cyk7XG5cbiAgICB0aGlzLmtleXJpbmdzLnB1c2goa2V5cmluZyk7XG4gICAgYXdhaXQgdGhpcy5wZXJzaXN0QWxsS2V5cmluZ3MoKTtcblxuICAgIHRoaXMuZnVsbFVwZGF0ZSgpO1xuXG4gICAgcmV0dXJuIGtleXJpbmc7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIEVtcHR5IEtleXJpbmdzLlxuICAgKlxuICAgKiBMb29wcyB0aHJvdWdoIHRoZSBrZXlyaW5ncyBhbmQgcmVtb3ZlcyB0aGUgb25lcyB3aXRoIGVtcHR5IGFjY291bnRzXG4gICAqICh1c3VhbGx5IGFmdGVyIHJlbW92aW5nIHRoZSBsYXN0IC8gb25seSBhY2NvdW50KSBmcm9tIGEga2V5cmluZy5cbiAgICovXG4gIGFzeW5jIHJlbW92ZUVtcHR5S2V5cmluZ3MoKSB7XG4gICAgY29uc3QgdmFsaWRLZXlyaW5ncyA9IFtdO1xuXG4gICAgLy8gU2luY2UgZ2V0QWNjb3VudHMgcmV0dXJucyBhIFByb21pc2VcbiAgICAvLyBXZSBuZWVkIHRvIHdhaXQgdG8gaGVhciBiYWNrIGZvcm0gZWFjaCBrZXlyaW5nXG4gICAgLy8gaW4gb3JkZXIgdG8gZGVjaWRlIHdoaWNoIG9uZXMgYXJlIG5vdyB2YWxpZCAoYWNjb3VudHMubGVuZ3RoID4gMClcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5rZXlyaW5ncy5tYXAoYXN5bmMgKGtleXJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFsaWRLZXlyaW5ncy5wdXNoKGtleXJpbmcpO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICApO1xuICAgIHRoaXMua2V5cmluZ3MgPSB2YWxpZEtleXJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBmb3IgZHVwbGljYXRlIGtleXBhaXJzLCB1c2luZyB0aGUgdGhlIGZpcnN0IGFjY291bnQgaW4gdGhlIGdpdmVuXG4gICAqIGFycmF5LiBSZWplY3RzIGlmIGEgZHVwbGljYXRlIGlzIGZvdW5kLlxuICAgKlxuICAgKiBPbmx5IHN1cHBvcnRzICdTaW1wbGUgS2V5IFBhaXInLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBrZXkgcGFpciB0eXBlIHRvIGNoZWNrIGZvci5cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBuZXdBY2NvdW50QXJyYXkgLSBBcnJheSBvZiBuZXcgYWNjb3VudHMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5PHN0cmluZz4+fSBUaGUgYWNjb3VudCwgaWYgbm8gZHVwbGljYXRlIGlzIGZvdW5kLlxuICAgKi9cbiAgYXN5bmMgY2hlY2tGb3JEdXBsaWNhdGUodHlwZSwgbmV3QWNjb3VudEFycmF5KSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEFjY291bnRzKCk7XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgS0VZUklOR1NfVFlQRV9NQVAuU0lNUExFX0tFWVJJTkc6IHtcbiAgICAgICAgY29uc3QgaXNJbmNsdWRlZCA9IEJvb2xlYW4oXG4gICAgICAgICAgYWNjb3VudHMuZmluZChcbiAgICAgICAgICAgIChrZXkpID0+XG4gICAgICAgICAgICAgIGtleSA9PT0gbmV3QWNjb3VudEFycmF5WzBdIHx8XG4gICAgICAgICAgICAgIGtleSA9PT0gc3RyaXBIZXhQcmVmaXgobmV3QWNjb3VudEFycmF5WzBdKSxcbiAgICAgICAgICApLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0luY2x1ZGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBhY2NvdW50IHlvdSBhcmUgdHJ5aW5nIHRvIGltcG9ydCBpcyBhIGR1cGxpY2F0ZScsXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3QWNjb3VudEFycmF5O1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHJldHVybiBuZXdBY2NvdW50QXJyYXk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBOZXcgQWNjb3VudC5cbiAgICpcbiAgICogQ2FsbHMgdGhlIGBhZGRBY2NvdW50c2AgbWV0aG9kIG9uIHRoZSBnaXZlbiBrZXlyaW5nLFxuICAgKiBhbmQgdGhlbiBzYXZlcyB0aG9zZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0tleXJpbmd9IHNlbGVjdGVkS2V5cmluZyAtIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQga2V5cmluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHN0YXRlLlxuICAgKi9cbiAgYXN5bmMgYWRkTmV3QWNjb3VudChzZWxlY3RlZEtleXJpbmcpIHtcbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHNlbGVjdGVkS2V5cmluZy5hZGRBY2NvdW50cygxKTtcbiAgICBhY2NvdW50cy5mb3JFYWNoKChoZXhBY2NvdW50KSA9PiB7XG4gICAgICB0aGlzLmVtaXQoJ25ld0FjY291bnQnLCBoZXhBY2NvdW50KTtcbiAgICB9KTtcblxuICAgIGF3YWl0IHRoaXMucGVyc2lzdEFsbEtleXJpbmdzKCk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydCBBY2NvdW50XG4gICAqXG4gICAqIFJlcXVlc3RzIHRoZSBwcml2YXRlIGtleSBmcm9tIHRoZSBrZXlyaW5nIGNvbnRyb2xsaW5nXG4gICAqIHRoZSBzcGVjaWZpZWQgYWRkcmVzcy5cbiAgICpcbiAgICogUmV0dXJucyBhIFByb21pc2UgdGhhdCBtYXkgcmVzb2x2ZSB3aXRoIHRoZSBwcml2YXRlIGtleSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gZXhwb3J0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBUaGUgcHJpdmF0ZSBrZXkgb2YgdGhlIGFjY291bnQuXG4gICAqL1xuICBhc3luYyBleHBvcnRBY2NvdW50KGFkZHJlc3MpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICByZXR1cm4gYXdhaXQga2V5cmluZy5leHBvcnRBY2NvdW50KG5vcm1hbGl6ZUFkZHJlc3MoYWRkcmVzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBBY2NvdW50LlxuICAgKlxuICAgKiBSZW1vdmVzIGEgc3BlY2lmaWMgYWNjb3VudCBmcm9tIGEga2V5cmluZ1xuICAgKiBJZiB0aGUgYWNjb3VudCBpcyB0aGUgbGFzdC9vbmx5IG9uZSB0aGVuIGl0IGFsc28gcmVtb3ZlcyB0aGUga2V5cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyBpZiB0aGUgb3BlcmF0aW9uIHdhcyBzdWNjZXNzZnVsLlxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG5cbiAgICAvLyBOb3QgYWxsIHRoZSBrZXlyaW5ncyBzdXBwb3J0IHRoaXMsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICBpZiAodHlwZW9mIGtleXJpbmcucmVtb3ZlQWNjb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAga2V5cmluZy5yZW1vdmVBY2NvdW50KGFkZHJlc3MpO1xuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVkQWNjb3VudCcsIGFkZHJlc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBLZXlyaW5nICR7a2V5cmluZy50eXBlfSBkb2Vzbid0IHN1cHBvcnQgYWNjb3VudCByZW1vdmFsIG9wZXJhdGlvbnNgLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAvLyBDaGVjayBpZiB0aGlzIHdhcyB0aGUgbGFzdC9vbmx5IGFjY291bnRcbiAgICBpZiAoYWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBhd2FpdCB0aGlzLnJlbW92ZUVtcHR5S2V5cmluZ3MoKTtcbiAgICB9XG5cbiAgICBhd2FpdCB0aGlzLnBlcnNpc3RBbGxLZXlyaW5ncygpO1xuICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFNJR05JTkcgTUVUSE9EU1xuICAvL1xuXG4gIC8qKlxuICAgKiBTaWduIEV0aGVyZXVtIFRyYW5zYWN0aW9uXG4gICAqXG4gICAqIFNpZ25zIGFuIEV0aGVyZXVtIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV0aFR4IC0gVGhlIHRyYW5zYWN0aW9uIHRvIHNpZ24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZnJvbUFkZHJlc3MgLSBUaGUgdHJhbnNhY3Rpb24gJ2Zyb20nIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gU2lnbmluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICovXG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihldGhUeCwgX2Zyb21BZGRyZXNzLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBmcm9tQWRkcmVzcyA9IG5vcm1hbGl6ZUFkZHJlc3MoX2Zyb21BZGRyZXNzKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yQWNjb3VudChmcm9tQWRkcmVzcyk7XG4gICAgcmV0dXJuIGF3YWl0IGtleXJpbmcuc2lnblRyYW5zYWN0aW9uKGZyb21BZGRyZXNzLCBldGhUeCwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBNZXNzYWdlXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIHNpZ24gdGhlIHByb3ZpZGVkIG1lc3NhZ2UgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBtZXNzYWdlIHBhcmFtZXRlcnMgdG8gc2lnbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIHNpZ25pbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn0gVGhlIHJhdyBzaWduYXR1cmUuXG4gICAqL1xuICBhc3luYyBzaWduTWVzc2FnZShtc2dQYXJhbXMsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemVBZGRyZXNzKG1zZ1BhcmFtcy5mcm9tKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICByZXR1cm4gYXdhaXQga2V5cmluZy5zaWduTWVzc2FnZShhZGRyZXNzLCBtc2dQYXJhbXMuZGF0YSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBQZXJzb25hbCBNZXNzYWdlXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIHNpZ24gdGhlIHByb3ZpZGVkIG1lc3NhZ2UgcGFyYW1ldGVycy5cbiAgICogUHJlZml4ZXMgdGhlIGhhc2ggYmVmb3JlIHNpZ25pbmcgcGVyIHRoZSBwZXJzb25hbCBzaWduIGV4cGVjdGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbXNnUGFyYW1zIC0gVGhlIG1lc3NhZ2UgcGFyYW1ldGVycyB0byBzaWduLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0cyAtIEFkZGl0aW9uYWwgc2lnbmluZyBvcHRpb25zLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxCdWZmZXI+fSBUaGUgcmF3IHNpZ25hdHVyZS5cbiAgICovXG4gIGFzeW5jIHNpZ25QZXJzb25hbE1lc3NhZ2UobXNnUGFyYW1zLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplQWRkcmVzcyhtc2dQYXJhbXMuZnJvbSk7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGF3YWl0IGtleXJpbmcuc2lnblBlcnNvbmFsTWVzc2FnZShhZGRyZXNzLCBtc2dQYXJhbXMuZGF0YSwgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGVuY3J5cHRpb24gcHVibGljIGtleVxuICAgKlxuICAgKiBHZXQgZW5jcnlwdGlvbiBwdWJsaWMga2V5IGZvciB1c2luZyBpbiBlbmNyeXB0L2RlY3J5cHQgcHJvY2Vzcy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byBnZXQgdGhlIGVuY3J5cHRpb24gcHVibGljIGtleSBmb3IuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzIC0gQWRkaXRpb25hbCBlbmNyeXB0aW9uIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEJ1ZmZlcj59IFRoZSBwdWJsaWMga2V5LlxuICAgKi9cbiAgYXN5bmMgZ2V0RW5jcnlwdGlvblB1YmxpY0tleShhZGRyZXNzLCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBub3JtYWxpemVkQWRkcmVzcyA9IG5vcm1hbGl6ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGF3YWl0IGtleXJpbmcuZ2V0RW5jcnlwdGlvblB1YmxpY0tleShub3JtYWxpemVkQWRkcmVzcywgb3B0cyk7XG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdCBNZXNzYWdlXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIGRlY3J5cHQgdGhlIHByb3ZpZGVkIG1lc3NhZ2UgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBkZWNyeXB0aW9uIG1lc3NhZ2UgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIGRlY3J5cHRpb24gb3B0aW9ucy5cbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn0gVGhlIHJhdyBkZWNyeXB0aW9uIHJlc3VsdC5cbiAgICovXG4gIGFzeW5jIGRlY3J5cHRNZXNzYWdlKG1zZ1BhcmFtcywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IG5vcm1hbGl6ZUFkZHJlc3MobXNnUGFyYW1zLmZyb20pO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuICAgIHJldHVybiBrZXlyaW5nLmRlY3J5cHRNZXNzYWdlKGFkZHJlc3MsIG1zZ1BhcmFtcy5kYXRhLCBvcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduIFR5cGVkIERhdGEuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9FSVBzL3B1bGwvNzEyI2lzc3VlY29tbWVudC0zMjk5ODg0NTR8RUlQNzEyfS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBtZXNzYWdlIHBhcmFtZXRlcnMgdG8gc2lnbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdHMgLSBBZGRpdGlvbmFsIHNpZ25pbmcgb3B0aW9ucy5cbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyPn0gVGhlIHJhdyBzaWduYXR1cmUuXG4gICAqL1xuICBhc3luYyBzaWduVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgb3B0cyA9IHsgdmVyc2lvbjogJ1YxJyB9KSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IG5vcm1hbGl6ZUFkZHJlc3MobXNnUGFyYW1zLmZyb20pO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuICAgIHJldHVybiBrZXlyaW5nLnNpZ25UeXBlZERhdGEoYWRkcmVzcywgbXNnUGFyYW1zLmRhdGEsIG9wdHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGFwcCBrZXkgYWRkcmVzcyBmb3IgdGhlIGdpdmVuIEV0aGVyZXVtIGFkZHJlc3MgYW5kIG9yaWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IF9hZGRyZXNzIC0gVGhlIEV0aGVyZXVtIGFkZHJlc3MgZm9yIHRoZSBhcHAga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiBmb3IgdGhlIGFwcCBrZXkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBhcHAga2V5IGFkZHJlc3MuXG4gICAqL1xuICBhc3luYyBnZXRBcHBLZXlBZGRyZXNzKF9hZGRyZXNzLCBvcmlnaW4pIHtcbiAgICBjb25zdCBhZGRyZXNzID0gbm9ybWFsaXplQWRkcmVzcyhfYWRkcmVzcyk7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG4gICAgcmV0dXJuIGtleXJpbmcuZ2V0QXBwS2V5QWRkcmVzcyhhZGRyZXNzLCBvcmlnaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydHMgYW4gYXBwIGtleSBwcml2YXRlIGtleSBmb3IgdGhlIGdpdmVuIEV0aGVyZXVtIGFkZHJlc3MgYW5kIG9yaWdpbi5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IF9hZGRyZXNzIC0gVGhlIEV0aGVyZXVtIGFkZHJlc3MgZm9yIHRoZSBhcHAga2V5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiBmb3IgdGhlIGFwcCBrZXkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBhcHAga2V5IHByaXZhdGUga2V5LlxuICAgKi9cbiAgYXN5bmMgZXhwb3J0QXBwS2V5Rm9yQWRkcmVzcyhfYWRkcmVzcywgb3JpZ2luKSB7XG4gICAgY29uc3QgYWRkcmVzcyA9IG5vcm1hbGl6ZUFkZHJlc3MoX2FkZHJlc3MpO1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuICAgIC8vIFRoZSBcImluXCIgb3BlcmF0b3IgaXMgdHlwaWNhbGx5IHJlc3RyaWN0ZWQgYmVjYXVzZSBpdCBhbHNvIGNoZWNrcyBpbmhlcml0ZWQgcHJvcGVydGllcyxcbiAgICAvLyB3aGljaCBjYW4gYmUgdW5leHBlY3RlZCBmb3IgcGxhaW4gb2JqZWN0cy4gV2UncmUgYWxsb3dpbmcgaXQgaGVyZSBiZWNhdXNlIGBrZXlyaW5nYCBpcyBub3RcbiAgICAvLyBhIHBsYWluIG9iamVjdCwgYW5kIHdlIGV4cGxpY2l0bHkgd2FudCB0byBpbmNsdWRlIGluaGVyaXRlZCBtZXRob2RzIGluIHRoaXMgY2hlY2suXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgaWYgKCEoJ2V4cG9ydEFjY291bnQnIGluIGtleXJpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUga2V5cmluZyBmb3IgYWRkcmVzcyAke19hZGRyZXNzfSBkb2VzIG5vdCBzdXBwb3J0IGV4cG9ydGluZy5gLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXJpbmcuZXhwb3J0QWNjb3VudChhZGRyZXNzLCB7IHdpdGhBcHBLZXlPcmlnaW46IG9yaWdpbiB9KTtcbiAgfVxuXG4gIC8vXG4gIC8vIFBSSVZBVEUgTUVUSE9EU1xuICAvL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgRmlyc3QgS2V5IFRyZWUuXG4gICAqXG4gICAqIC0gQ2xlYXJzIHRoZSBleGlzdGluZyB2YXVsdC5cbiAgICogLSBDcmVhdGVzIGEgbmV3IHZhdWx0LlxuICAgKiAtIENyZWF0ZXMgYSByYW5kb20gbmV3IEhEIEtleXJpbmcgd2l0aCAxIGFjY291bnQuXG4gICAqIC0gTWFrZXMgdGhhdCBhY2NvdW50IHRoZSBzZWxlY3RlZCBhY2NvdW50LlxuICAgKiAtIEZhdWNldHMgdGhhdCBhY2NvdW50IG9uIHRlc3RuZXQuXG4gICAqIC0gUHV0cyB0aGUgY3VycmVudCBzZWVkIHdvcmRzIGludG8gdGhlIHN0YXRlIHRyZWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBpZiB0aGUgb3BlcmF0aW9uIHdhcyBzdWNjZXNzZnVsLlxuICAgKi9cbiAgYXN5bmMgY3JlYXRlRmlyc3RLZXlUcmVlKCkge1xuICAgIHRoaXMuY2xlYXJLZXlyaW5ncygpO1xuXG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuYWRkTmV3S2V5cmluZyhLRVlSSU5HU19UWVBFX01BUC5IRF9LRVlSSU5HKTtcbiAgICBjb25zdCBbZmlyc3RBY2NvdW50XSA9IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICBpZiAoIWZpcnN0QWNjb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlyaW5nQ29udHJvbGxlciAtIE5vIGFjY291bnQgZm91bmQgb24ga2V5Y2hhaW4uJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaGV4QWNjb3VudCA9IG5vcm1hbGl6ZUFkZHJlc3MoZmlyc3RBY2NvdW50KTtcbiAgICB0aGlzLmVtaXQoJ25ld1ZhdWx0JywgaGV4QWNjb3VudCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUGVyc2lzdCBBbGwgS2V5cmluZ3NcbiAgICpcbiAgICogSXRlcmF0ZXMgdGhlIGN1cnJlbnQgYGtleXJpbmdzYCBhcnJheSxcbiAgICogc2VyaWFsaXplcyBlYWNoIG9uZSBpbnRvIGEgc2VyaWFsaXplZCBhcnJheSxcbiAgICogZW5jcnlwdHMgdGhhdCBhcnJheSB3aXRoIHRoZSBwcm92aWRlZCBgcGFzc3dvcmRgLFxuICAgKiBhbmQgcGVyc2lzdHMgdGhhdCBlbmNyeXB0ZWQgc3RyaW5nIHRvIHN0b3JhZ2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBSZXNvbHZlcyB0byB0cnVlIG9uY2Uga2V5cmluZ3MgYXJlIHBlcnNpc3RlZC5cbiAgICovXG4gIGFzeW5jIHBlcnNpc3RBbGxLZXlyaW5ncygpIHtcbiAgICBjb25zdCB7IGVuY3J5cHRpb25LZXksIGVuY3J5cHRpb25TYWx0IH0gPSB0aGlzLm1lbVN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBpZiAoIXRoaXMucGFzc3dvcmQgJiYgIWVuY3J5cHRpb25LZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBwZXJzaXN0IHZhdWx0IHdpdGhvdXQgcGFzc3dvcmQgYW5kIGVuY3J5cHRpb24ga2V5JyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VyaWFsaXplZEtleXJpbmdzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICB0aGlzLmtleXJpbmdzLm1hcChhc3luYyAoa2V5cmluZykgPT4ge1xuICAgICAgICBjb25zdCBbdHlwZSwgZGF0YV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAga2V5cmluZy50eXBlLFxuICAgICAgICAgIGtleXJpbmcuc2VyaWFsaXplKCksXG4gICAgICAgIF0pO1xuICAgICAgICByZXR1cm4geyB0eXBlLCBkYXRhIH07XG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgc2VyaWFsaXplZEtleXJpbmdzLnB1c2goLi4udGhpcy5fdW5zdXBwb3J0ZWRLZXlyaW5ncyk7XG5cbiAgICBsZXQgdmF1bHQ7XG4gICAgbGV0IG5ld0VuY3J5cHRpb25LZXk7XG5cbiAgICBpZiAodGhpcy5jYWNoZUVuY3J5cHRpb25LZXkpIHtcbiAgICAgIGlmICh0aGlzLnBhc3N3b3JkKSB7XG4gICAgICAgIGNvbnN0IHsgdmF1bHQ6IG5ld1ZhdWx0LCBleHBvcnRlZEtleVN0cmluZyB9ID1cbiAgICAgICAgICBhd2FpdCB0aGlzLmVuY3J5cHRvci5lbmNyeXB0V2l0aERldGFpbChcbiAgICAgICAgICAgIHRoaXMucGFzc3dvcmQsXG4gICAgICAgICAgICBzZXJpYWxpemVkS2V5cmluZ3MsXG4gICAgICAgICAgKTtcblxuICAgICAgICB2YXVsdCA9IG5ld1ZhdWx0O1xuICAgICAgICBuZXdFbmNyeXB0aW9uS2V5ID0gZXhwb3J0ZWRLZXlTdHJpbmc7XG4gICAgICB9IGVsc2UgaWYgKGVuY3J5cHRpb25LZXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgdGhpcy5lbmNyeXB0b3IuaW1wb3J0S2V5KGVuY3J5cHRpb25LZXkpO1xuICAgICAgICBjb25zdCB2YXVsdEpTT04gPSBhd2FpdCB0aGlzLmVuY3J5cHRvci5lbmNyeXB0V2l0aEtleShcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgc2VyaWFsaXplZEtleXJpbmdzLFxuICAgICAgICApO1xuICAgICAgICB2YXVsdEpTT04uc2FsdCA9IGVuY3J5cHRpb25TYWx0O1xuICAgICAgICB2YXVsdCA9IEpTT04uc3RyaW5naWZ5KHZhdWx0SlNPTik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhdWx0ID0gYXdhaXQgdGhpcy5lbmNyeXB0b3IuZW5jcnlwdCh0aGlzLnBhc3N3b3JkLCBzZXJpYWxpemVkS2V5cmluZ3MpO1xuICAgIH1cblxuICAgIGlmICghdmF1bHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBlcnNpc3QgdmF1bHQgd2l0aG91dCB2YXVsdCBpbmZvcm1hdGlvbicpO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcmUudXBkYXRlU3RhdGUoeyB2YXVsdCB9KTtcblxuICAgIC8vIFRoZSBrZXlyaW5nIHVwZGF0ZXMgbmVlZCB0byBiZSBhbm5vdW5jZWQgYmVmb3JlIHVwZGF0aW5nIHRoZSBlbmNyeXB0aW9uS2V5XG4gICAgLy8gc28gdGhhdCB0aGUgdXBkYXRlZCBrZXlyaW5nIGdldHMgcHJvcGFnYXRlZCB0byB0aGUgZXh0ZW5zaW9uIGZpcnN0LlxuICAgIC8vIE5vdCBjYWxsaW5nIF91cGRhdGVNZW1TdG9yZUtleXJpbmdzIHJlc3VsdHMgaW4gdGhlIHdyb25nIGFjY291bnQgYmVpbmcgc2VsZWN0ZWRcbiAgICAvLyBpbiB0aGUgZXh0ZW5zaW9uLlxuICAgIGF3YWl0IHRoaXMuX3VwZGF0ZU1lbVN0b3JlS2V5cmluZ3MoKTtcblxuICAgIGlmIChuZXdFbmNyeXB0aW9uS2V5KSB7XG4gICAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgZW5jcnlwdGlvbktleTogbmV3RW5jcnlwdGlvbktleSxcbiAgICAgICAgZW5jcnlwdGlvblNhbHQ6IEpTT04ucGFyc2UodmF1bHQpLnNhbHQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmxvY2sgS2V5cmluZ3MuXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIHVubG9jayB0aGUgcGVyc2lzdGVkIGVuY3J5cHRlZCBzdG9yYWdlLFxuICAgKiBpbml0aWFsaXppbmcgdGhlIHBlcnNpc3RlZCBrZXlyaW5ncyB0byBSQU0uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSBrZXlyaW5nIGNvbnRyb2xsZXIgcGFzc3dvcmQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNyeXB0aW9uS2V5IC0gQW4gZXhwb3J0ZWQga2V5IHN0cmluZyB0byB1bmxvY2sga2V5cmluZ3Mgd2l0aC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuY3J5cHRpb25TYWx0IC0gVGhlIHNhbHQgdXNlZCB0byBlbmNyeXB0IHRoZSB2YXVsdC5cbiAgICogQHJldHVybnMge1Byb21pc2U8QXJyYXk8S2V5cmluZz4+fSBUaGUga2V5cmluZ3MuXG4gICAqL1xuICBhc3luYyB1bmxvY2tLZXlyaW5ncyhwYXNzd29yZCwgZW5jcnlwdGlvbktleSwgZW5jcnlwdGlvblNhbHQpIHtcbiAgICBjb25zdCBlbmNyeXB0ZWRWYXVsdCA9IHRoaXMuc3RvcmUuZ2V0U3RhdGUoKS52YXVsdDtcbiAgICBpZiAoIWVuY3J5cHRlZFZhdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1bmxvY2sgd2l0aG91dCBhIHByZXZpb3VzIHZhdWx0LicpO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMuY2xlYXJLZXlyaW5ncygpO1xuXG4gICAgbGV0IHZhdWx0O1xuXG4gICAgaWYgKHRoaXMuY2FjaGVFbmNyeXB0aW9uS2V5KSB7XG4gICAgICBpZiAocGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5lbmNyeXB0b3IuZGVjcnlwdFdpdGhEZXRhaWwoXG4gICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgZW5jcnlwdGVkVmF1bHQsXG4gICAgICAgICk7XG4gICAgICAgIHZhdWx0ID0gcmVzdWx0LnZhdWx0O1xuICAgICAgICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG5cbiAgICAgICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgZW5jcnlwdGlvbktleTogcmVzdWx0LmV4cG9ydGVkS2V5U3RyaW5nLFxuICAgICAgICAgIGVuY3J5cHRpb25TYWx0OiByZXN1bHQuc2FsdCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwYXJzZWRFbmNyeXB0ZWRWYXVsdCA9IEpTT04ucGFyc2UoZW5jcnlwdGVkVmF1bHQpO1xuXG4gICAgICAgIGlmIChlbmNyeXB0aW9uU2FsdCAhPT0gcGFyc2VkRW5jcnlwdGVkVmF1bHQuc2FsdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBrZXkgYW5kIHNhbHQgcHJvdmlkZWQgYXJlIGV4cGlyZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHRoaXMuZW5jcnlwdG9yLmltcG9ydEtleShlbmNyeXB0aW9uS2V5KTtcbiAgICAgICAgdmF1bHQgPSBhd2FpdCB0aGlzLmVuY3J5cHRvci5kZWNyeXB0V2l0aEtleShrZXksIHBhcnNlZEVuY3J5cHRlZFZhdWx0KTtcblxuICAgICAgICAvLyBUaGlzIGNhbGwgaXMgcmVxdWlyZWQgb24gdGhlIGZpcnN0IGNhbGwgYmVjYXVzZSBlbmNyeXB0aW9uS2V5XG4gICAgICAgIC8vIGlzIG5vdCB5ZXQgaW5zaWRlIHRoZSBtZW1TdG9yZVxuICAgICAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICBlbmNyeXB0aW9uS2V5LFxuICAgICAgICAgIGVuY3J5cHRpb25TYWx0LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmF1bHQgPSBhd2FpdCB0aGlzLmVuY3J5cHRvci5kZWNyeXB0KHBhc3N3b3JkLCBlbmNyeXB0ZWRWYXVsdCk7XG4gICAgICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodmF1bHQubWFwKHRoaXMuX3Jlc3RvcmVLZXlyaW5nLmJpbmQodGhpcykpKTtcbiAgICBhd2FpdCB0aGlzLl91cGRhdGVNZW1TdG9yZUtleXJpbmdzKCk7XG4gICAgcmV0dXJuIHRoaXMua2V5cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSBLZXlyaW5nXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIGluaXRpYWxpemUgYSBuZXcga2V5cmluZyBmcm9tIHRoZSBwcm92aWRlZCBzZXJpYWxpemVkIHBheWxvYWQuXG4gICAqIE9uIHN1Y2Nlc3MsIHVwZGF0ZXMgdGhlIG1lbVN0b3JlIGtleXJpbmdzIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmdcbiAgICoga2V5cmluZyBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNlcmlhbGl6ZWQgLSBUaGUgc2VyaWFsaXplZCBrZXlyaW5nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxLZXlyaW5nPn0gVGhlIGRlc2VyaWFsaXplZCBrZXlyaW5nLlxuICAgKi9cbiAgYXN5bmMgcmVzdG9yZUtleXJpbmcoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLl9yZXN0b3JlS2V5cmluZyhzZXJpYWxpemVkKTtcbiAgICBpZiAoa2V5cmluZykge1xuICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlTWVtU3RvcmVLZXlyaW5ncygpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXN0b3JlIEtleXJpbmcgSGVscGVyXG4gICAqXG4gICAqIEF0dGVtcHRzIHRvIGluaXRpYWxpemUgYSBuZXcga2V5cmluZyBmcm9tIHRoZSBwcm92aWRlZCBzZXJpYWxpemVkIHBheWxvYWQuXG4gICAqIE9uIHN1Y2Nlc3MsIHJldHVybnMgdGhlIHJlc3VsdGluZyBrZXlyaW5nIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIGtleXJpbmcuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPEtleXJpbmd8dW5kZWZpbmVkPn0gVGhlIGRlc2VyaWFsaXplZCBrZXlyaW5nIG9yIHVuZGVmaW5lZCBpZiB0aGUga2V5cmluZyB0eXBlIGlzIHVuc3VwcG9ydGVkLlxuICAgKi9cbiAgYXN5bmMgX3Jlc3RvcmVLZXlyaW5nKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7IHR5cGUsIGRhdGEgfSA9IHNlcmlhbGl6ZWQ7XG5cbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5fbmV3S2V5cmluZyh0eXBlLCBkYXRhKTtcbiAgICBpZiAoIWtleXJpbmcpIHtcbiAgICAgIHRoaXMuX3Vuc3VwcG9ydGVkS2V5cmluZ3MucHVzaChzZXJpYWxpemVkKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gZ2V0QWNjb3VudHMgYWxzbyB2YWxpZGF0ZXMgdGhlIGFjY291bnRzIGZvciBzb21lIGtleXJpbmdzXG4gICAgYXdhaXQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgIHRoaXMua2V5cmluZ3MucHVzaChrZXlyaW5nKTtcbiAgICByZXR1cm4ga2V5cmluZztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgS2V5cmluZyBDbGFzcyBGb3IgVHlwZVxuICAgKlxuICAgKiBTZWFyY2hlcyB0aGUgY3VycmVudCBga2V5cmluZ0J1aWxkZXJzYCBhcnJheVxuICAgKiBmb3IgYSBLZXlyaW5nIGJ1aWxkZXIgd2hvc2UgdW5pcXVlIGB0eXBlYCBwcm9wZXJ0eVxuICAgKiBtYXRjaGVzIHRoZSBwcm92aWRlZCBgdHlwZWAsXG4gICAqIHJldHVybmluZyBpdCBpZiBpdCBleGlzdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgd2hvc2UgY2xhc3MgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7S2V5cmluZ3x1bmRlZmluZWR9IFRoZSBjbGFzcywgaWYgaXQgZXhpc3RzLlxuICAgKi9cbiAgZ2V0S2V5cmluZ0J1aWxkZXJGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlyaW5nQnVpbGRlcnMuZmluZChcbiAgICAgIChrZXlyaW5nQnVpbGRlcikgPT4ga2V5cmluZ0J1aWxkZXIudHlwZSA9PT0gdHlwZSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBLZXlyaW5ncyBieSBUeXBlXG4gICAqXG4gICAqIEdldHMgYWxsIGtleXJpbmdzIG9mIHRoZSBnaXZlbiB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBrZXlyaW5nIHR5cGVzIHRvIHJldHJpZXZlLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8S2V5cmluZz59IFRoZSBrZXlyaW5ncy5cbiAgICovXG4gIGdldEtleXJpbmdzQnlUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5rZXlyaW5ncy5maWx0ZXIoKGtleXJpbmcpID0+IGtleXJpbmcudHlwZSA9PT0gdHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IEFjY291bnRzXG4gICAqXG4gICAqIFJldHVybnMgdGhlIHB1YmxpYyBhZGRyZXNzZXMgb2YgYWxsIGN1cnJlbnQgYWNjb3VudHNcbiAgICogbWFuYWdlZCBieSBhbGwgY3VycmVudGx5IHVubG9ja2VkIGtleXJpbmdzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheTxzdHJpbmc+Pn0gVGhlIGFycmF5IG9mIGFjY291bnRzLlxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgY29uc3Qga2V5cmluZ3MgPSB0aGlzLmtleXJpbmdzIHx8IFtdO1xuXG4gICAgY29uc3Qga2V5cmluZ0FycmF5cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAga2V5cmluZ3MubWFwKChrZXlyaW5nKSA9PiBrZXlyaW5nLmdldEFjY291bnRzKCkpLFxuICAgICk7XG4gICAgY29uc3QgYWRkcmVzc2VzID0ga2V5cmluZ0FycmF5cy5yZWR1Y2UoKHJlcywgYXJyKSA9PiB7XG4gICAgICByZXR1cm4gcmVzLmNvbmNhdChhcnIpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBhZGRyZXNzZXMubWFwKG5vcm1hbGl6ZUFkZHJlc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBLZXlyaW5nIEZvciBBY2NvdW50XG4gICAqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBpbml0aWFsaXplZCBrZXlyaW5nIHRoYXQgbWFuYWdlc1xuICAgKiB0aGUgc3BlY2lmaWVkIGBhZGRyZXNzYCBpZiBvbmUgZXhpc3RzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEFuIGFjY291bnQgYWRkcmVzcy5cbiAgICogQHJldHVybnMge1Byb21pc2U8S2V5cmluZz59IFRoZSBrZXlyaW5nIG9mIHRoZSBhY2NvdW50LCBpZiBpdCBleGlzdHMuXG4gICAqL1xuICBhc3luYyBnZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKSB7XG4gICAgY29uc3QgaGV4ZWQgPSBub3JtYWxpemVBZGRyZXNzKGFkZHJlc3MpO1xuXG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5rZXlyaW5ncy5tYXAoKGtleXJpbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtrZXlyaW5nLCBrZXlyaW5nLmdldEFjY291bnRzKCldKTtcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBjb25zdCB3aW5uZXJzID0gY2FuZGlkYXRlcy5maWx0ZXIoKGNhbmRpZGF0ZSkgPT4ge1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBjYW5kaWRhdGVbMV0ubWFwKG5vcm1hbGl6ZUFkZHJlc3MpO1xuICAgICAgcmV0dXJuIGFjY291bnRzLmluY2x1ZGVzKGhleGVkKTtcbiAgICB9KTtcbiAgICBpZiAod2lubmVycyAmJiB3aW5uZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB3aW5uZXJzWzBdWzBdO1xuICAgIH1cblxuICAgIC8vIEFkZGluZyBtb3JlIGluZm8gdG8gdGhlIGVycm9yXG4gICAgbGV0IGVycm9ySW5mbyA9ICcnO1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgZXJyb3JJbmZvID0gJ1RoZSBhZGRyZXNzIHBhc3NlZCBpbiBpcyBpbnZhbGlkL2VtcHR5JztcbiAgICB9IGVsc2UgaWYgKCFjYW5kaWRhdGVzIHx8ICFjYW5kaWRhdGVzLmxlbmd0aCkge1xuICAgICAgZXJyb3JJbmZvID0gJ1RoZXJlIGFyZSBubyBrZXlyaW5ncyc7XG4gICAgfSBlbHNlIGlmICghd2lubmVycyB8fCAhd2lubmVycy5sZW5ndGgpIHtcbiAgICAgIGVycm9ySW5mbyA9ICdUaGVyZSBhcmUga2V5cmluZ3MsIGJ1dCBub25lIG1hdGNoIHRoZSBhZGRyZXNzJztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYE5vIGtleXJpbmcgZm91bmQgZm9yIHRoZSByZXF1ZXN0ZWQgYWNjb3VudC4gRXJyb3IgaW5mbzogJHtlcnJvckluZm99YCxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgRm9yIEtleXJpbmdcbiAgICpcbiAgICogSXMgdXNlZCBmb3IgYWRkaW5nIHRoZSBjdXJyZW50IGtleXJpbmdzIHRvIHRoZSBzdGF0ZSBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5cmluZ30ga2V5cmluZyAtIFRoZSBrZXlyaW5nIHRvIGRpc3BsYXkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IEEga2V5cmluZyBkaXNwbGF5IG9iamVjdCwgd2l0aCB0eXBlIGFuZCBhY2NvdW50cyBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgYXN5bmMgZGlzcGxheUZvcktleXJpbmcoa2V5cmluZykge1xuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGtleXJpbmcudHlwZSxcbiAgICAgIGFjY291bnRzOiBhY2NvdW50cy5tYXAobm9ybWFsaXplQWRkcmVzcyksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBLZXlyaW5nc1xuICAgKlxuICAgKiBEZWFsbG9jYXRlcyBhbGwgY3VycmVudGx5IG1hbmFnZWQga2V5cmluZ3MgYW5kIGFjY291bnRzLlxuICAgKiBVc2VkIGJlZm9yZSBpbml0aWFsaXppbmcgYSBuZXcgdmF1bHQuXG4gICAqL1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgYXN5bmMgY2xlYXJLZXlyaW5ncygpIHtcbiAgICAvLyBjbGVhciBrZXlyaW5ncyBmcm9tIG1lbW9yeVxuICAgIHRoaXMua2V5cmluZ3MgPSBbXTtcbiAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgIGtleXJpbmdzOiBbXSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgbWVtU3RvcmUgS2V5cmluZ3NcbiAgICpcbiAgICogVXBkYXRlcyB0aGUgaW4tbWVtb3J5IGtleXJpbmdzLCB3aXRob3V0IHBlcnNpc3RpbmcuXG4gICAqL1xuICBhc3luYyBfdXBkYXRlTWVtU3RvcmVLZXlyaW5ncygpIHtcbiAgICBjb25zdCBrZXlyaW5ncyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgdGhpcy5rZXlyaW5ncy5tYXAodGhpcy5kaXNwbGF5Rm9yS2V5cmluZyksXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7IGtleXJpbmdzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFVubG9jayBLZXlyaW5nc1xuICAgKlxuICAgKiBVbmxvY2tzIHRoZSBrZXlyaW5ncy5cbiAgICpcbiAgICogQGZpcmVzIEtleXJpbmdDb250cm9sbGVyI3VubG9ja1xuICAgKi9cbiAgc2V0VW5sb2NrZWQoKSB7XG4gICAgdGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7IGlzVW5sb2NrZWQ6IHRydWUgfSk7XG4gICAgdGhpcy5lbWl0KCd1bmxvY2snKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JnZXQgaGFyZHdhcmUga2V5cmluZy5cbiAgICpcbiAgICogRm9yZ2V0IGhhcmR3YXJlIGFuZCB1cGRhdGUgbWVtb3JpemVkIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge0tleXJpbmd9IGtleXJpbmcgLSBUaGUga2V5cmluZyB0byBmb3JnZXQuXG4gICAqL1xuICBmb3JnZXRLZXlyaW5nKGtleXJpbmcpIHtcbiAgICBpZiAoa2V5cmluZy5mb3JnZXREZXZpY2UpIHtcbiAgICAgIGtleXJpbmcuZm9yZ2V0RGV2aWNlKCk7XG4gICAgICB0aGlzLnBlcnNpc3RBbGxLZXlyaW5ncygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBLZXlyaW5nQ29udHJvbGxlciAtIGtleXJpbmcgZG9lcyBub3QgaGF2ZSBtZXRob2QgXCJmb3JnZXREZXZpY2VcIiwga2V5cmluZyB0eXBlOiAke2tleXJpbmcudHlwZX1gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGUsIGluaXRpYWxpemUgYW5kIHJldHVybiBhIG5ldyBrZXlyaW5nXG4gICAqXG4gICAqIFRoZSBrZXlyaW5nIGluc3RhbnRpYXRlZCBpcyBvZiB0aGUgZ2l2ZW4gYHR5cGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGtleXJpbmcgdG8gYWRkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YSAtIFRoZSBkYXRhIHRvIHJlc3RvcmUgYSBwcmV2aW91c2x5IHNlcmlhbGl6ZWQga2V5cmluZy5cbiAgICogQHJldHVybnMge1Byb21pc2U8S2V5cmluZz59IFRoZSBuZXcga2V5cmluZy5cbiAgICovXG4gIGFzeW5jIF9uZXdLZXlyaW5nKHR5cGUsIGRhdGEpIHtcbiAgICBjb25zdCBrZXlyaW5nQnVpbGRlciA9IHRoaXMuZ2V0S2V5cmluZ0J1aWxkZXJGb3JUeXBlKHR5cGUpO1xuXG4gICAgaWYgKCFrZXlyaW5nQnVpbGRlcikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBrZXlyaW5nID0ga2V5cmluZ0J1aWxkZXIoKTtcblxuICAgIGF3YWl0IGtleXJpbmcuZGVzZXJpYWxpemUoZGF0YSk7XG5cbiAgICBpZiAoa2V5cmluZy5pbml0KSB7XG4gICAgICBhd2FpdCBrZXlyaW5nLmluaXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5cmluZztcbiAgfVxufVxuXG4vKipcbiAqIEdldCBidWlsZGVyIGZ1bmN0aW9uIGZvciBgS2V5cmluZ2BcbiAqXG4gKiBSZXR1cm5zIGEgYnVpbGRlciBmdW5jdGlvbiBmb3IgYEtleXJpbmdgIHdpdGggYSBgdHlwZWAgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtLZXlyaW5nfSBLZXlyaW5nIC0gVGhlIEtleXJpbmcgY2xhc3MgZm9yIHRoZSBidWlsZGVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGJ1aWxkZXIgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBLZXlyaW5nLlxuICovXG5mdW5jdGlvbiBrZXlyaW5nQnVpbGRlckZhY3RvcnkoS2V5cmluZykge1xuICBjb25zdCBidWlsZGVyID0gKCkgPT4gbmV3IEtleXJpbmcoKTtcblxuICBidWlsZGVyLnR5cGUgPSBLZXlyaW5nLnR5cGU7XG5cbiAgcmV0dXJuIGJ1aWxkZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBLZXlyaW5nQ29udHJvbGxlcixcbiAga2V5cmluZ0J1aWxkZXJGYWN0b3J5LFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVuY3J5cHRpb25QdWJsaWNLZXkgPSBleHBvcnRzLmRlY3J5cHRTYWZlbHkgPSBleHBvcnRzLmRlY3J5cHQgPSBleHBvcnRzLmVuY3J5cHRTYWZlbHkgPSBleHBvcnRzLmVuY3J5cHQgPSB2b2lkIDA7XG5jb25zdCBuYWNsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ0d2VldG5hY2xcIikpO1xuY29uc3QgbmFjbFV0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInR3ZWV0bmFjbC11dGlsXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogRW5jcnlwdCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZW5jcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2UgcmVjaXBpZW50LlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBtZXNzYWdlIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHR5cGUgb2YgZW5jcnlwdGlvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHQoeyBwdWJsaWNLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwdWJsaWNLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkodmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICBjYXNlICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGRhdGEgbXVzdCBiZSBnaXZlbiBhcyBhIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgZXBoZW1lcmFsIGtleXBhaXJcbiAgICAgICAgICAgIGNvbnN0IGVwaGVtZXJhbEtleVBhaXIgPSBuYWNsLmJveC5rZXlQYWlyKCk7XG4gICAgICAgICAgICAvLyBhc3NlbWJsZSBlbmNyeXB0aW9uIHBhcmFtZXRlcnMgLSBmcm9tIHN0cmluZyB0byBVSW50OFxuICAgICAgICAgICAgbGV0IHB1YktleVVJbnQ4QXJyYXk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHB1YktleVVJbnQ4QXJyYXkgPSBuYWNsVXRpbC5kZWNvZGVCYXNlNjQocHVibGljS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBwdWJsaWMga2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtc2dQYXJhbXNVSW50OEFycmF5ID0gbmFjbFV0aWwuZGVjb2RlVVRGOChkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gbmFjbC5yYW5kb21CeXRlcyhuYWNsLmJveC5ub25jZUxlbmd0aCk7XG4gICAgICAgICAgICAvLyBlbmNyeXB0XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWRNZXNzYWdlID0gbmFjbC5ib3gobXNnUGFyYW1zVUludDhBcnJheSwgbm9uY2UsIHB1YktleVVJbnQ4QXJyYXksIGVwaGVtZXJhbEtleVBhaXIuc2VjcmV0S2V5KTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBlbmNyeXB0ZWQgZGF0YVxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246ICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBuYWNsVXRpbC5lbmNvZGVCYXNlNjQobm9uY2UpLFxuICAgICAgICAgICAgICAgIGVwaGVtUHVibGljS2V5OiBuYWNsVXRpbC5lbmNvZGVCYXNlNjQoZXBoZW1lcmFsS2V5UGFpci5wdWJsaWNLZXkpLFxuICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChlbmNyeXB0ZWRNZXNzYWdlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyByZXR1cm4gZW5jcnlwdGVkIG1zZyBkYXRhXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gdHlwZS92ZXJzaW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG59XG5leHBvcnRzLmVuY3J5cHQgPSBlbmNyeXB0O1xuLyoqXG4gKiBFbmNyeXB0IGEgbWVzc2FnZSBpbiBhIHdheSB0aGF0IG9ic2N1cmVzIHRoZSBtZXNzYWdlIGxlbmd0aC5cbiAqXG4gKiBUaGUgbWVzc2FnZSBpcyBwYWRkZWQgdG8gYSBtdWx0aXBsZSBvZiAyMDQ4IGJlZm9yZSBiZWluZyBlbmNyeXB0ZWQgc28gdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZVxuICogcmVzdWx0aW5nIGVuY3J5cHRlZCBtZXNzYWdlIGNhbid0IGJlIHVzZWQgdG8gZ3Vlc3MgdGhlIGV4YWN0IGxlbmd0aCBvZiB0aGUgb3JpZ2luYWwgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBlbmNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvZiB0aGUgbWVzc2FnZSByZWNpcGllbnQuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIG1lc3NhZ2UgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zLnZlcnNpb24gLSBUaGUgdHlwZSBvZiBlbmNyeXB0aW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNyeXB0ZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZW5jcnlwdFNhZmVseSh7IHB1YmxpY0tleSwgZGF0YSwgdmVyc2lvbiwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHB1YmxpY0tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHB1YmxpY0tleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKSh2ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmVyc2lvbiBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgREVGQVVMVF9QQURESU5HX0xFTkdUSCA9IDIgKiogMTE7XG4gICAgY29uc3QgTkFDTF9FWFRSQV9CWVRFUyA9IDE2O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgJ3RvSlNPTicgaW4gZGF0YSkge1xuICAgICAgICAvLyByZW1vdmUgdG9KU09OIGF0dGFjayB2ZWN0b3JcbiAgICAgICAgLy8gVE9ETywgY2hlY2sgYWxsIHBvc3NpYmxlIGNoaWxkcmVuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgd2l0aCB0b0pTT04gcHJvcGVydHkuICBQbGVhc2UgcmVtb3ZlIHRvSlNPTiBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICAvLyBhZGQgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IHtcbiAgICAgICAgZGF0YSxcbiAgICAgICAgcGFkZGluZzogJycsXG4gICAgfTtcbiAgICAvLyBjYWxjdWxhdGUgcGFkZGluZ1xuICAgIGNvbnN0IGRhdGFMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpLCAndXRmLTgnKTtcbiAgICBjb25zdCBtb2RWYWwgPSBkYXRhTGVuZ3RoICUgREVGQVVMVF9QQURESU5HX0xFTkdUSDtcbiAgICBsZXQgcGFkTGVuZ3RoID0gMDtcbiAgICAvLyBPbmx5IHBhZCBpZiBuZWNlc3NhcnlcbiAgICBpZiAobW9kVmFsID4gMCkge1xuICAgICAgICBwYWRMZW5ndGggPSBERUZBVUxUX1BBRERJTkdfTEVOR1RIIC0gbW9kVmFsIC0gTkFDTF9FWFRSQV9CWVRFUzsgLy8gbmFjbCBleHRyYSBieXRlc1xuICAgIH1cbiAgICBkYXRhV2l0aFBhZGRpbmcucGFkZGluZyA9ICcwJy5yZXBlYXQocGFkTGVuZ3RoKTtcbiAgICBjb25zdCBwYWRkZWRNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZGF0YVdpdGhQYWRkaW5nKTtcbiAgICByZXR1cm4gZW5jcnlwdCh7IHB1YmxpY0tleSwgZGF0YTogcGFkZGVkTWVzc2FnZSwgdmVyc2lvbiB9KTtcbn1cbmV4cG9ydHMuZW5jcnlwdFNhZmVseSA9IGVuY3J5cHRTYWZlbHk7XG4vKipcbiAqIERlY3J5cHQgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGRlY3J5cHRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmVuY3J5cHRlZERhdGEgLSBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIGRlY3J5cHQgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBkZWNyeXB0ZWQgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gZGVjcnlwdCh7IGVuY3J5cHRlZERhdGEsIHByaXZhdGVLZXksIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShlbmNyeXB0ZWREYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZW5jcnlwdGVkRGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwcml2YXRlS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZUtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgc3dpdGNoIChlbmNyeXB0ZWREYXRhLnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1Jzoge1xuICAgICAgICAgICAgLy8gc3RyaW5nIHRvIGJ1ZmZlciB0byBVSW50OEFycmF5XG4gICAgICAgICAgICBjb25zdCByZWNpZXZlclByaXZhdGVLZXlVaW50OEFycmF5ID0gbmFjbF9kZWNvZGVIZXgocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBjb25zdCByZWNpZXZlckVuY3J5cHRpb25Qcml2YXRlS2V5ID0gbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5KHJlY2lldmVyUHJpdmF0ZUtleVVpbnQ4QXJyYXkpLnNlY3JldEtleTtcbiAgICAgICAgICAgIC8vIGFzc2VtYmxlIGRlY3J5cHRpb24gcGFyYW1ldGVyc1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsVXRpbC5kZWNvZGVCYXNlNjQoZW5jcnlwdGVkRGF0YS5ub25jZSk7XG4gICAgICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCBlcGhlbVB1YmxpY0tleSA9IG5hY2xVdGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLmVwaGVtUHVibGljS2V5KTtcbiAgICAgICAgICAgIC8vIGRlY3J5cHRcbiAgICAgICAgICAgIGNvbnN0IGRlY3J5cHRlZE1lc3NhZ2UgPSBuYWNsLmJveC5vcGVuKGNpcGhlcnRleHQsIG5vbmNlLCBlcGhlbVB1YmxpY0tleSwgcmVjaWV2ZXJFbmNyeXB0aW9uUHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAvLyByZXR1cm4gZGVjcnlwdGVkIG1zZyBkYXRhXG4gICAgICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBuYWNsVXRpbC5lbmNvZGVVVEY4KGRlY3J5cHRlZE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjcnlwdGlvbiBmYWlsZWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVjcnlwdGlvbiBmYWlsZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG59XG5leHBvcnRzLmRlY3J5cHQgPSBkZWNyeXB0O1xuLyoqXG4gKiBEZWNyeXB0IGEgbWVzc2FnZSB0aGF0IGhhcyBiZWVuIGVuY3J5cHRlZCB1c2luZyBgZW5jcnlwdFNhZmVseWAuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZGVjcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZW5jcnlwdGVkRGF0YSAtIFRoZSBlbmNyeXB0ZWQgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gZGVjcnlwdCB3aXRoLlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBkZWNyeXB0U2FmZWx5KHsgZW5jcnlwdGVkRGF0YSwgcHJpdmF0ZUtleSwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKGVuY3J5cHRlZERhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlbmNyeXB0ZWREYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlS2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhV2l0aFBhZGRpbmcgPSBKU09OLnBhcnNlKGRlY3J5cHQoeyBlbmNyeXB0ZWREYXRhLCBwcml2YXRlS2V5IH0pKTtcbiAgICByZXR1cm4gZGF0YVdpdGhQYWRkaW5nLmRhdGE7XG59XG5leHBvcnRzLmRlY3J5cHRTYWZlbHkgPSBkZWNyeXB0U2FmZWx5O1xuLyoqXG4gKiBHZXQgdGhlIGVuY3J5cHRpb24gcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0gcHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBnZW5lcmF0ZSB0aGUgZW5jcnlwdGlvbiBwdWJsaWMga2V5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGlvbiBwdWJsaWMga2V5LlxuICovXG5mdW5jdGlvbiBnZXRFbmNyeXB0aW9uUHVibGljS2V5KHByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5VWludDhBcnJheSA9IG5hY2xfZGVjb2RlSGV4KHByaXZhdGVLZXkpO1xuICAgIGNvbnN0IGVuY3J5cHRpb25QdWJsaWNLZXkgPSBuYWNsLmJveC5rZXlQYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleVVpbnQ4QXJyYXkpLnB1YmxpY0tleTtcbiAgICByZXR1cm4gbmFjbFV0aWwuZW5jb2RlQmFzZTY0KGVuY3J5cHRpb25QdWJsaWNLZXkpO1xufVxuZXhwb3J0cy5nZXRFbmNyeXB0aW9uUHVibGljS2V5ID0gZ2V0RW5jcnlwdGlvblB1YmxpY0tleTtcbi8qKlxuICogQ29udmVydCBhIGhleCBzdHJpbmcgdG8gdGhlIFVJbnQ4QXJyYXkgZm9ybWF0IHVzZWQgYnkgbmFjbC5cbiAqXG4gKiBAcGFyYW0gbXNnSGV4IC0gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG5hY2xfZGVjb2RlSGV4KG1zZ0hleCkge1xuICAgIGNvbnN0IG1zZ0Jhc2U2NCA9IEJ1ZmZlci5mcm9tKG1zZ0hleCwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXR1cm4gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KG1zZ0Jhc2U2NCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNyeXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50IGpzZG9jL3JlcXVpcmUtZGVzY3JpcHRpb246IDAgKi9cbi8qIGVzbGludCBqc2RvYy9yZXF1aXJlLXJldHVybnM6IDAgKi9cbi8qIGVzbGludCBqc2RvYy9tYXRjaC1kZXNjcmlwdGlvbjogMCAqL1xuLyogZXNsaW50IGpzZG9jL3JlcXVpcmUtcGFyYW0tZGVzY3JpcHRpb246IDAgKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmF3RW5jb2RlID0gZXhwb3J0cy5wYXJzZU51bWJlciA9IGV4cG9ydHMuc29saWRpdHlQYWNrID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIik7XG5jb25zdCBldGhqc191dGlsXzEgPSByZXF1aXJlKFwiZXRoanMtdXRpbFwiKTtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8vXG4vLyBNZXRob2RzIGJvcnJvd2VkIGFuZCBzb21ld2hhdCBhZGFwdGVkIGZyb20gZXRoZXJldW1qcy1hYmlAMC42Ljg6XG4vLyBodHRwczovL25wbWZzLmNvbS9wYWNrYWdlL2V0aGVyZXVtanMtYWJpLzAuNi44L2xpYi9pbmRleC5qc1xuLy9cbi8qKlxuICogUGFja3Mgbm9uLXN0YW5kYXJkIGVuY29kZWQgdmFsdWVzIHBhY2tlZCBhY2NvcmRpbmcgdG8gdGhlaXIgcmVzcGVjdGl2ZSB0eXBlIGluIHR5cGVzIGluIGEgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB0eXBlcyAtIEFycmF5IG9mIHR5cGVzIG9mIGVhY2ggdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIHZhbHVlcyAtIEFycmF5IG9mIHZhbHVlcyB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBBIGJ1ZmZlciBjb250YWluaW5nIHRoZSBwYWNrZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzb2xpZGl0eVBhY2sodHlwZXMsIHZhbHVlcykge1xuICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgdHlwZXMgYXJlIG5vdCBtYXRjaGluZyB0aGUgdmFsdWVzJyk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGVsZW1lbnRhcnlOYW1lKHR5cGVzW2ldKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIHJldC5wdXNoKHNvbGlkaXR5SGV4VmFsdWUodHlwZSwgdmFsdWUsIG51bGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KTtcbn1cbmV4cG9ydHMuc29saWRpdHlQYWNrID0gc29saWRpdHlQYWNrO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhbiBhcnJheSAocmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcpLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHZhbHVlIHRvIGNoZWNrIHdoZXRoZXIgaXQgaXMgYW4gYXJyYXkuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodHlwZSkge1xuICAgIHJldHVybiB0eXBlLmxhc3RJbmRleE9mKCddJykgPT09IHR5cGUubGVuZ3RoIC0gMTtcbn1cbi8qKlxuICogUGFyc2UgYXJyYXkgdHlwZSBmb3IgcGFja2luZyBzb2xpZGl0eSB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHR5cGUgLSBBIHN0cmluZyB0aGF0IG1heSBiZSBhbiBhcnJheSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIEEgcGFyc2VkIHZhbHVlIGZyb20gdGhlIGFycmF5LlxuICovXG5mdW5jdGlvbiBwYXJzZVR5cGVBcnJheSh0eXBlKSB7XG4gICAgY29uc3QgdG1wID0gdHlwZS5tYXRjaCgvKC4qKVxcWyguKj8pXFxdJC91KTtcbiAgICBpZiAodG1wKSB7XG4gICAgICAgIHJldHVybiB0bXBbMl0gPT09ICcnID8gJ2R5bmFtaWMnIDogcGFyc2VJbnQodG1wWzJdLCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBQYXJzZSBOIGZyb20gdHlwZTxOPi5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFZhbHVlIHRvIHBhcnNlLlxuICogQHJldHVybnMgUGFyc2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJzZVR5cGVOKHR5cGUpIHtcbiAgICByZXR1cm4gcGFyc2VJbnQoL15cXEQrKFxcZCspJC91LmV4ZWModHlwZSlbMV0sIDEwKTtcbn1cbi8qKlxuICogUGFyc2UgYSBudW1iZXIgZm9yIGRldGVybWluaW5nIGEgc29saWRpdHkgaGV4dmFsdWUuXG4gKlxuICogQHBhcmFtIGFyZyAtIE51bWJlciB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFBhcnNlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VOdW1iZXIoYXJnKSB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmlzSGV4UHJlZml4ZWQpKGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KCgwLCBldGhqc191dGlsXzEuc3RyaXBIZXhQcmVmaXgpKGFyZyksIDE2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChhcmcsIDEwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoYXJnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJnLnRvQXJyYXkpIHtcbiAgICAgICAgLy8gYXNzdW1lIHRoaXMgaXMgYSBCTiBmb3IgdGhlIG1vbWVudCwgcmVwbGFjZSB3aXRoIEJOLmlzQk4gc29vblxuICAgICAgICByZXR1cm4gYXJnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIG51bWJlcicpO1xufVxuZXhwb3J0cy5wYXJzZU51bWJlciA9IHBhcnNlTnVtYmVyO1xuLyoqXG4gKiBHZXQgc29saWRpdHkgaGV4IHZhbHVlIGZyb20gdHlwZSwgdmFsdWUgYW5kIGJpdHNpemUgaW5wdXRzIGZvciBwYWNraW5nIHRoZXNlIHZhbHVlcyBpbiBhIGJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIGJpdHNpemUgLSBUaGUgYml0c2l6ZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQgc29sZGl0eSBoZXggdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNvbGlkaXR5SGV4VmFsdWUodHlwZSwgdmFsdWUsIGJpdHNpemUpIHtcbiAgICAvLyBwYXNzIGluIGJpdHNpemUgPSBudWxsIGlmIHVzZSBkZWZhdWx0IGJpdHNpemVcbiAgICBsZXQgc2l6ZSwgbnVtO1xuICAgIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHN1YlR5cGUgPSB0eXBlLnJlcGxhY2UoL1xcWy4qP1xcXS91LCAnJyk7XG4gICAgICAgIGlmICghaXNBcnJheShzdWJUeXBlKSkge1xuICAgICAgICAgICAgY29uc3QgYXJyYXlTaXplID0gcGFyc2VUeXBlQXJyYXkodHlwZSk7XG4gICAgICAgICAgICBpZiAoYXJyYXlTaXplICE9PSAnZHluYW1pYycgJiZcbiAgICAgICAgICAgICAgICBhcnJheVNpemUgIT09IDAgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZS5sZW5ndGggPiBhcnJheVNpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVsZW1lbnRzIGV4Y2VlZCBhcnJheSBzaXplOiAke2FycmF5U2l6ZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheVZhbHVlcyA9IHZhbHVlLm1hcChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgcmV0dXJuIHNvbGlkaXR5SGV4VmFsdWUoc3ViVHlwZSwgdiwgMjU2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGFycmF5VmFsdWVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIGJpdHNpemUgPSBiaXRzaXplIHx8IDg7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBBcnJheShiaXRzaXplIC8gNCkuam9pbignMCcpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUgPyBgJHtwYWRkaW5nfTFgIDogYCR7cGFkZGluZ30wYCwgJ2hleCcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgbGV0IGJ5dGVzaXplID0gMjA7XG4gICAgICAgIGlmIChiaXRzaXplKSB7XG4gICAgICAgICAgICBieXRlc2l6ZSA9IGJpdHNpemUgLyA4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnNldExlbmd0aExlZnQpKCgwLCB1dGlsXzEudG9CdWZmZXIpKHZhbHVlKSwgYnl0ZXNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSk7XG4gICAgICAgIGlmIChzaXplIDwgMSB8fCBzaXplID4gMzIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBieXRlczxOPiB3aWR0aDogJHtzaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgwLCB1dGlsc18xLm5vcm1hbGl6ZSkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnNldExlbmd0aFJpZ2h0KSgoMCwgdXRpbF8xLnRvQnVmZmVyKSh2YWx1ZSksIHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKTtcbiAgICAgICAgaWYgKHNpemUgJSA4IHx8IHNpemUgPCA4IHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB1aW50PE4+IHdpZHRoOiAke3NpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtID0gcGFyc2VOdW1iZXIodmFsdWUpO1xuICAgICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdXBwbGllZCB1aW50IGV4Y2VlZHMgd2lkdGg6ICR7c2l6ZX0gdnMgJHtudW0uYml0TGVuZ3RoKCl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgYml0c2l6ZSA9IGJpdHNpemUgfHwgc2l6ZTtcbiAgICAgICAgcmV0dXJuIG51bS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIGJpdHNpemUgLyA4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKTtcbiAgICAgICAgaWYgKHNpemUgJSA4IHx8IHNpemUgPCA4IHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnQ8Tj4gd2lkdGg6ICR7c2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gPSBwYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1cHBsaWVkIGludCBleGNlZWRzIHdpZHRoOiAke3NpemV9IHZzICR7bnVtLmJpdExlbmd0aCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGJpdHNpemUgPSBiaXRzaXplIHx8IHNpemU7XG4gICAgICAgIHJldHVybiBudW0udG9Ud29zKHNpemUpLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgYml0c2l6ZSAvIDgpO1xuICAgIH1cbiAgICAvLyBGSVhNRTogc3VwcG9ydCBhbGwgb3RoZXIgdHlwZXNcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJHt0eXBlfWApO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBjb3JyZWN0IHNvbGlkaXR5IHR5cGUgbmFtZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSB0eXBlIG5hbWUgZm9yIHdoaWNoIHdlIHdhbnQgdGhlIGNvcnJlc3BvbmRpbmcgc29saWRpdHkgdHlwZSBuYW1lLlxuICogQHJldHVybnMgVGhlIHNvbGlkaXR5IHR5cGUgbmFtZSBmb3IgdGhlIGlucHV0IHZhbHVlLlxuICovXG5mdW5jdGlvbiBlbGVtZW50YXJ5TmFtZShuYW1lKSB7XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaW50WycpKSB7XG4gICAgICAgIHJldHVybiBgaW50MjU2JHtuYW1lLnNsaWNlKDMpfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpbnQnKSB7XG4gICAgICAgIHJldHVybiAnaW50MjU2JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1aW50WycpKSB7XG4gICAgICAgIHJldHVybiBgdWludDI1NiR7bmFtZS5zbGljZSg0KX1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAndWludCcpIHtcbiAgICAgICAgcmV0dXJuICd1aW50MjU2JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdmaXhlZFsnKSkge1xuICAgICAgICByZXR1cm4gYGZpeGVkMTI4eDEyOCR7bmFtZS5zbGljZSg1KX1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAnZml4ZWQnKSB7XG4gICAgICAgIHJldHVybiAnZml4ZWQxMjh4MTI4JztcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCd1Zml4ZWRbJykpIHtcbiAgICAgICAgcmV0dXJuIGB1Zml4ZWQxMjh4MTI4JHtuYW1lLnNsaWNlKDYpfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICd1Zml4ZWQnKSB7XG4gICAgICAgIHJldHVybiAndWZpeGVkMTI4eDEyOCc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuLyoqXG4gKiBAcGFyYW0gdHlwZXNcbiAqIEBwYXJhbSB2YWx1ZXNcbiAqL1xuZnVuY3Rpb24gcmF3RW5jb2RlKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgbGV0IGhlYWRMZW5ndGggPSAwO1xuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZVR5cGVBcnJheSh0eXBlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZWdhdGVkLWNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKHNpemUgIT09ICdkeW5hbWljJykge1xuICAgICAgICAgICAgICAgIGhlYWRMZW5ndGggKz0gMzIgKiBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZExlbmd0aCArPSAzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRMZW5ndGggKz0gMzI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBlbGVtZW50YXJ5TmFtZSh0eXBlc1tpXSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBjb25zdCBjdXIgPSBlbmNvZGVTaW5nbGUodHlwZSwgdmFsdWUpO1xuICAgICAgICAvLyBVc2UgdGhlIGhlYWQvdGFpbCBtZXRob2QgZm9yIHN0b3JpbmcgZHluYW1pYyBkYXRhXG4gICAgICAgIGlmIChpc0R5bmFtaWModHlwZSkpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGVuY29kZVNpbmdsZSgndWludDI1NicsIGhlYWRMZW5ndGgpKTtcbiAgICAgICAgICAgIGRhdGEucHVzaChjdXIpO1xuICAgICAgICAgICAgaGVhZExlbmd0aCArPSBjdXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goY3VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChvdXRwdXQuY29uY2F0KGRhdGEpKTtcbn1cbmV4cG9ydHMucmF3RW5jb2RlID0gcmF3RW5jb2RlO1xuLy8gRW5jb2RlcyBhIHNpbmdsZSBpdGVtIChjYW4gYmUgZHluYW1pYyBhcnJheSlcbi8vIEByZXR1cm5zOiBCdWZmZXJcbi8qKlxuICogQHBhcmFtIHR5cGVcbiAqIEBwYXJhbSBhcmdcbiAqL1xuZnVuY3Rpb24gZW5jb2RlU2luZ2xlKHR5cGUsIGFyZykge1xuICAgIGxldCBzaXplLCBudW0sIHJldCwgaTtcbiAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQxNjAnLCBwYXJzZU51bWJlcihhcmcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQ4JywgYXJnID8gMSA6IDApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCdieXRlcycsIEJ1ZmZlci5mcm9tKGFyZywgJ3V0ZjgnKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgLy8gdGhpcyBwYXJ0IGhhbmRsZXMgZml4ZWQtbGVuZ3RoIChbMl0pIGFuZCB2YXJpYWJsZSBsZW5ndGggKFtdKSBhcnJheXNcbiAgICAgICAgLy8gTk9URTogd2UgY2F0Y2ggaGVyZSBhbGwgY2FsbHMgdG8gYXJyYXlzLCB0aGF0IHNpbXBsaWZpZXMgdGhlIHJlc3RcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcubGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYW4gYXJyYXk/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZSA9IHBhcnNlVHlwZUFycmF5KHR5cGUpO1xuICAgICAgICBpZiAoc2l6ZSAhPT0gJ2R5bmFtaWMnICYmIHNpemUgIT09IDAgJiYgYXJnLmxlbmd0aCA+IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRWxlbWVudHMgZXhjZWVkIGFycmF5IHNpemU6ICR7c2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgdHlwZS5sYXN0SW5kZXhPZignWycpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBhcmcgPSBKU09OLnBhcnNlKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpIGluIGFyZykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmcsIGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0LnB1c2goZW5jb2RlU2luZ2xlKHR5cGUsIGFyZ1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaXplID09PSAnZHluYW1pYycpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGVuY29kZVNpbmdsZSgndWludDI1NicsIGFyZy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0LnVuc2hpZnQobGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChyZXQpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgIGFyZyA9IEJ1ZmZlci5mcm9tKGFyZyk7XG4gICAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQoW2VuY29kZVNpbmdsZSgndWludDI1NicsIGFyZy5sZW5ndGgpLCBhcmddKTtcbiAgICAgICAgaWYgKGFyZy5sZW5ndGggJSAzMiAhPT0gMCkge1xuICAgICAgICAgICAgcmV0ID0gQnVmZmVyLmNvbmNhdChbcmV0LCAoMCwgdXRpbF8xLnplcm9zKSgzMiAtIChhcmcubGVuZ3RoICUgMzIpKV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xuICAgICAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKTtcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ5dGVzPE4+IHdpZHRoOiAke3NpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBhcmcgPSAoMCwgdXRpbHNfMS5ub3JtYWxpemUpKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuc2V0TGVuZ3RoUmlnaHQpKCgwLCB1dGlsXzEudG9CdWZmZXIpKGFyZyksIDMyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCd1aW50JykpIHtcbiAgICAgICAgc2l6ZSA9IHBhcnNlVHlwZU4odHlwZSk7XG4gICAgICAgIGlmIChzaXplICUgOCB8fCBzaXplIDwgOCB8fCBzaXplID4gMjU2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdWludDxOPiB3aWR0aDogJHtzaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIG51bSA9IHBhcnNlTnVtYmVyKGFyZyk7XG4gICAgICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1cHBsaWVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJHtzaXplfSB2cyAke251bS5iaXRMZW5ndGgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50IGlzIG5lZ2F0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICBzaXplID0gcGFyc2VUeXBlTih0eXBlKTtcbiAgICAgICAgaWYgKHNpemUgJSA4IHx8IHNpemUgPCA4IHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnQ8Tj4gd2lkdGg6ICR7c2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBudW0gPSBwYXJzZU51bWJlcihhcmcpO1xuICAgICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdXBwbGllZCBpbnQgZXhjZWVkcyB3aWR0aDogJHtzaXplfSB2cyAke251bS5iaXRMZW5ndGgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtLnRvVHdvcygyNTYpLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VmaXhlZCcpKSB7XG4gICAgICAgIHNpemUgPSBwYXJzZVR5cGVOeE0odHlwZSk7XG4gICAgICAgIG51bSA9IHBhcnNlTnVtYmVyKGFyZyk7XG4gICAgICAgIGlmIChudW0gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBsaWVkIHVmaXhlZCBpcyBuZWdhdGl2ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBudW0ubXVsKG5ldyBibl9qc18xLmRlZmF1bHQoMikucG93KG5ldyBibl9qc18xLmRlZmF1bHQoc2l6ZVsxXSkpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnZml4ZWQnKSkge1xuICAgICAgICBzaXplID0gcGFyc2VUeXBlTnhNKHR5cGUpO1xuICAgICAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCdpbnQyNTYnLCBwYXJzZU51bWJlcihhcmcpLm11bChuZXcgYm5fanNfMS5kZWZhdWx0KDIpLnBvdyhuZXcgYm5fanNfMS5kZWZhdWx0KHNpemVbMV0pKSkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG9yIGludmFsaWQgdHlwZTogJHt0eXBlfWApO1xufVxuLy8gSXMgYSB0eXBlIGR5bmFtaWM/XG4vKipcbiAqIEBwYXJhbSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGlzRHluYW1pYyh0eXBlKSB7XG4gICAgLy8gRklYTUU6IGhhbmRsZSBhbGwgdHlwZXM/IEkgZG9uJ3QgdGhpbmsgYW55dGhpbmcgaXMgbWlzc2luZyBub3dcbiAgICByZXR1cm4gKHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdieXRlcycgfHwgcGFyc2VUeXBlQXJyYXkodHlwZSkgPT09ICdkeW5hbWljJyk7XG59XG4vLyBQYXJzZSBOLE0gZnJvbSB0eXBlPE4+eDxNPlxuLyoqXG4gKiBAcGFyYW0gdHlwZVxuICovXG5mdW5jdGlvbiBwYXJzZVR5cGVOeE0odHlwZSkge1xuICAgIGNvbnN0IHRtcCA9IC9eXFxEKyhcXGQrKXgoXFxkKykkL3UuZXhlYyh0eXBlKTtcbiAgICByZXR1cm4gW3BhcnNlSW50KHRtcFsxXSwgMTApLCBwYXJzZUludCh0bXBbMl0sIDEwKV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldGhlcmV1bWpzLWFiaS11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3JtYWxpemUgPSBleHBvcnRzLmNvbmNhdFNpZyA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wZXJzb25hbC1zaWduXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zaWduLXR5cGVkLWRhdGFcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VuY3J5cHRpb25cIiksIGV4cG9ydHMpO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbmNhdFNpZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5jb25jYXRTaWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJub3JtYWxpemVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEubm9ybWFsaXplOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dHJhY3RQdWJsaWNLZXkgPSBleHBvcnRzLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSA9IGV4cG9ydHMucGVyc29uYWxTaWduID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKipcbiAqIENyZWF0ZSBhbiBFdGhlcmV1bS1zcGVjaWZpYyBzaWduYXR1cmUgZm9yIGEgbWVzc2FnZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gdGhlIGBldGhfc2lnbmAgRXRoZXJldW0gSlNPTi1SUEMgbWV0aG9kIGFzIHNwZWNpZmllZCBpbiBFSVAtMTQxNyxcbiAqIGFzIHdlbGwgYXMgdGhlIE1ldGFNYXNrJ3MgYHBlcnNvbmFsX3NpZ25gIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwZXJzb25hbCBzaWduIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5wcml2YXRlS2V5IC0gVGhlIGtleSB0byBzaWduIHdpdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIGhleCBkYXRhIHRvIHNpZ24uXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHBlcnNvbmFsU2lnbih7IHByaXZhdGVLZXksIGRhdGEsIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwcml2YXRlS2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcHJpdmF0ZUtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9ICgwLCB1dGlsc18xLmxlZ2FjeVRvQnVmZmVyKShkYXRhKTtcbiAgICBjb25zdCBtc2dIYXNoID0gKDAsIHV0aWxfMS5oYXNoUGVyc29uYWxNZXNzYWdlKShtZXNzYWdlKTtcbiAgICBjb25zdCBzaWcgPSAoMCwgdXRpbF8xLmVjc2lnbikobXNnSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9ICgwLCB1dGlsc18xLmNvbmNhdFNpZykoKDAsIHV0aWxfMS50b0J1ZmZlcikoc2lnLnYpLCBzaWcuciwgc2lnLnMpO1xuICAgIHJldHVybiBzZXJpYWxpemVkO1xufVxuZXhwb3J0cy5wZXJzb25hbFNpZ24gPSBwZXJzb25hbFNpZ247XG4vKipcbiAqIFJlY292ZXIgdGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdXNlZCB0byBjcmVhdGUgdGhlIGdpdmVuIEV0aGVyZXVtIHNpZ25hdHVyZS4gVGhlIG1lc3NhZ2VcbiAqIG11c3QgaGF2ZSBiZWVuIHNpZ25lZCB1c2luZyB0aGUgYHBlcnNvbmFsU2lnbmAgZnVuY3Rpb24sIG9yIGFuIGVxdWl2YWxlbnQgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmF0dXJlIHJlY292ZXJ5IG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIGhleCBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBvcHRpb25zLnNpZ25hdHVyZSAtIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIG1lc3NhZ2Ugc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgYWRkcmVzcyBvZiB0aGUgbWVzc2FnZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSh7IGRhdGEsIHNpZ25hdHVyZSwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHNpZ25hdHVyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHNpZ25hdHVyZSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKGRhdGEsIHNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2VuZGVyID0gKDAsIHV0aWxfMS5wdWJsaWNUb0FkZHJlc3MpKHB1YmxpY0tleSk7XG4gICAgY29uc3Qgc2VuZGVySGV4ID0gKDAsIHV0aWxfMS5idWZmZXJUb0hleCkoc2VuZGVyKTtcbiAgICByZXR1cm4gc2VuZGVySGV4O1xufVxuZXhwb3J0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUgPSByZWNvdmVyUGVyc29uYWxTaWduYXR1cmU7XG4vKipcbiAqIFJlY292ZXIgdGhlIHB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgdXNlZCB0byBjcmVhdGUgdGhlIGdpdmVuIEV0aGVyZXVtIHNpZ25hdHVyZS4gVGhlIG1lc3NhZ2VcbiAqIG11c3QgaGF2ZSBiZWVuIHNpZ25lZCB1c2luZyB0aGUgYHBlcnNvbmFsU2lnbmAgZnVuY3Rpb24sIG9yIGFuIGVxdWl2YWxlbnQgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgcHVibGljIGtleSByZWNvdmVyeSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBoZXggZGF0YSB0aGF0IHdhcyBzaWduZWQuXG4gKiBAcGFyYW0gb3B0aW9ucy5zaWduYXR1cmUgLSBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2Ugc2lnbmVyLlxuICovXG5mdW5jdGlvbiBleHRyYWN0UHVibGljS2V5KHsgZGF0YSwgc2lnbmF0dXJlLCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IoZGF0YSwgc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gYDB4JHtwdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpfWA7XG59XG5leHBvcnRzLmV4dHJhY3RQdWJsaWNLZXkgPSBleHRyYWN0UHVibGljS2V5O1xuLyoqXG4gKiBHZXQgdGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBnaXZlbiBzaWduYXR1cmUgYW5kIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0aGF0IHdhcyBzaWduZWQuXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgbWVzc2FnZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgcHVibGljIGtleSBvZiB0aGUgc2lnbmVyLlxuICovXG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlGb3IobWVzc2FnZSwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSAoMCwgdXRpbF8xLmhhc2hQZXJzb25hbE1lc3NhZ2UpKCgwLCB1dGlsc18xLmxlZ2FjeVRvQnVmZmVyKShtZXNzYWdlKSk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLnJlY292ZXJQdWJsaWNLZXkpKG1lc3NhZ2VIYXNoLCBzaWduYXR1cmUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVyc29uYWwtc2lnbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlID0gZXhwb3J0cy5zaWduVHlwZWREYXRhID0gZXhwb3J0cy50eXBlZFNpZ25hdHVyZUhhc2ggPSBleHBvcnRzLlR5cGVkRGF0YVV0aWxzID0gZXhwb3J0cy5UWVBFRF9NRVNTQUdFX1NDSEVNQSA9IGV4cG9ydHMuU2lnblR5cGVkRGF0YVZlcnNpb24gPSB2b2lkIDA7XG5jb25zdCBldGhqc191dGlsXzEgPSByZXF1aXJlKFwiZXRoanMtdXRpbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IGV0aGVyZXVtanNfYWJpX3V0aWxzXzEgPSByZXF1aXJlKFwiLi9ldGhlcmV1bWpzLWFiaS11dGlsc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdmVyc2lvbiBvZiBgc2lnblR5cGVkRGF0YWAgYmVpbmcgdXNlZC5cbiAqXG4gKiBWMSBpcyBiYXNlZCB1cG9uIFthbiBlYXJseSB2ZXJzaW9uIG9mIEVJUC03MTJdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9FSVBzL3B1bGwvNzEyL2NvbW1pdHMvMjFhYmUyNTRmZTA0NTJkODU4M2Q1YjEzMmIxZDdiZTg3YzA0MzljYSlcbiAqIHRoYXQgbGFja2VkIHNvbWUgbGF0ZXIgc2VjdXJpdHkgaW1wcm92ZW1lbnRzLCBhbmQgc2hvdWxkIGdlbmVyYWxseSBiZSBuZWdsZWN0ZWQgaW4gZmF2b3Igb2ZcbiAqIGxhdGVyIHZlcnNpb25zLlxuICpcbiAqIFYzIGlzIGJhc2VkIG9uIEVJUC03MTIsIGV4Y2VwdCB0aGF0IGFycmF5cyBhbmQgcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBWNCBpcyBiYXNlZCBvbiBFSVAtNzEyLCBhbmQgaW5jbHVkZXMgZnVsbCBzdXBwb3J0IG9mIGFycmF5cyBhbmQgcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcy5cbiAqL1xudmFyIFNpZ25UeXBlZERhdGFWZXJzaW9uO1xuKGZ1bmN0aW9uIChTaWduVHlwZWREYXRhVmVyc2lvbikge1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjFcIl0gPSBcIlYxXCI7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWM1wiXSA9IFwiVjNcIjtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlY0XCJdID0gXCJWNFwiO1xufSkoU2lnblR5cGVkRGF0YVZlcnNpb24gPSBleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uIHx8IChleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uID0ge30pKTtcbmV4cG9ydHMuVFlQRURfTUVTU0FHRV9TQ0hFTUEgPSB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ10sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgICAgIGRvbWFpbjogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICAgICAgICBtZXNzYWdlOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgfSxcbiAgICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufTtcbi8qKlxuICogVmFsaWRhdGUgdGhhdCB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCB2ZXJzaW9uIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSB2ZXJzaW9uIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIGFsbG93ZWRWZXJzaW9ucyAtIEEgbGlzdCBvZiBhbGxvd2VkIHZlcnNpb25zLiBJZiBvbWl0dGVkLCBhbGwgdmVyc2lvbnMgYXJlIGFzc3VtZWQgdG8gYmVcbiAqIGFsbG93ZWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBhbGxvd2VkVmVyc2lvbnMpIHtcbiAgICBpZiAoIU9iamVjdC5rZXlzKFNpZ25UeXBlZERhdGFWZXJzaW9uKS5pbmNsdWRlcyh2ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmVyc2lvbjogJyR7dmVyc2lvbn0nYCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsbG93ZWRWZXJzaW9ucyAmJiAhYWxsb3dlZFZlcnNpb25zLmluY2x1ZGVzKHZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2lnblR5cGVkRGF0YVZlcnNpb24gbm90IGFsbG93ZWQ6ICcke3ZlcnNpb259Jy4gQWxsb3dlZCB2ZXJzaW9ucyBhcmU6ICR7YWxsb3dlZFZlcnNpb25zLmpvaW4oJywgJyl9YCk7XG4gICAgfVxufVxuLyoqXG4gKiBFbmNvZGUgYSBzaW5nbGUgZmllbGQuXG4gKlxuICogQHBhcmFtIHR5cGVzIC0gQWxsIHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBmaWVsZCBiZWluZyBlbmNvZGVkLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUZpZWxkKHR5cGVzLCBuYW1lLCB0eXBlLCB2YWx1ZSwgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgaWYgKHR5cGVzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdieXRlczMyJyxcbiAgICAgICAgICAgIHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0ICYmIHZhbHVlID09IG51bGwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsXG4gICAgICAgICAgICAgICAgPyAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICAgICAgICAgICAgICAgIDogKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikoZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSwgdHlwZXMsIHZlcnNpb24pKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgZmllbGQgJHtuYW1lfSBvZiB0eXBlICR7dHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzEubnVtYmVyVG9CdWZmZXIpKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgZXRoanNfdXRpbF8xLmlzSGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBlbmQgPSB2YWx1ZS5sZW5ndGggJSAyID8gJzAnIDogJyc7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHByZXBlbmQgKyB2YWx1ZS5zbGljZSgyKSwgJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydieXRlczMyJywgKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikodmFsdWUpKV07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgdXRpbHNfMS5udW1iZXJUb0J1ZmZlcikodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiAnJywgJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydieXRlczMyJywgKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikodmFsdWUpKV07XG4gICAgfVxuICAgIGlmICh0eXBlLmxhc3RJbmRleE9mKCddJykgPT09IHR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gU2lnblR5cGVkRGF0YVZlcnNpb24uVjMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXlzIGFyZSB1bmltcGxlbWVudGVkIGluIGVuY29kZURhdGE7IHVzZSBWNCBleHRlbnNpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpO1xuICAgICAgICBjb25zdCB0eXBlVmFsdWVQYWlycyA9IHZhbHVlLm1hcCgoaXRlbSkgPT4gZW5jb2RlRmllbGQodHlwZXMsIG5hbWUsIHBhcnNlZFR5cGUsIGl0ZW0sIHZlcnNpb24pKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICdieXRlczMyJyxcbiAgICAgICAgICAgICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKCgwLCBldGhlcmV1bWpzX2FiaV91dGlsc18xLnJhd0VuY29kZSkodHlwZVZhbHVlUGFpcnMubWFwKChbdF0pID0+IHQpLCB0eXBlVmFsdWVQYWlycy5tYXAoKFssIHZdKSA9PiB2KSkpKSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFt0eXBlLCB2YWx1ZV07XG59XG4vKipcbiAqIEVuY29kZXMgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGFuZCBjb25jYXRlbmF0aW5nIGVhY2ggb2YgaXRzIG1lbWJlcnMuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIG9iamVjdCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zIGZvciBhbGwgdHlwZXMgaW5jbHVkZWQgaW4gdGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBFSVAtNzEyIHZlcnNpb24gdGhlIGVuY29kaW5nIHNob3VsZCBjb21wbHkgd2l0aC5cbiAqIEByZXR1cm5zIEFuIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgYW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBlbmNvZGVEYXRhKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ107XG4gICAgY29uc3QgZW5jb2RlZFZhbHVlcyA9IFtoYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gU2lnblR5cGVkRGF0YVZlcnNpb24uVjMgJiYgZGF0YVtmaWVsZC5uYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gZW5jb2RlRmllbGQodHlwZXMsIGZpZWxkLm5hbWUsIGZpZWxkLnR5cGUsIGRhdGFbZmllbGQubmFtZV0sIHZlcnNpb24pO1xuICAgICAgICBlbmNvZGVkVHlwZXMucHVzaCh0eXBlKTtcbiAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBldGhlcmV1bWpzX2FiaV91dGlsc18xLnJhd0VuY29kZSkoZW5jb2RlZFR5cGVzLCBlbmNvZGVkVmFsdWVzKTtcbn1cbi8qKlxuICogRW5jb2RlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QgYnkgZW5jb2RpbmcgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBpdHMgbWVtYmVycy5cbiAqXG4gKiBAcGFyYW0gcHJpbWFyeVR5cGUgLSBUaGUgcm9vdCB0eXBlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEByZXR1cm5zIEFuIGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHByaW1hcnkgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgY29uc3QgdW5zb3J0ZWREZXBzID0gZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzKTtcbiAgICB1bnNvcnRlZERlcHMuZGVsZXRlKHByaW1hcnlUeXBlKTtcbiAgICBjb25zdCBkZXBzID0gW3ByaW1hcnlUeXBlLCAuLi5BcnJheS5mcm9tKHVuc29ydGVkRGVwcykuc29ydCgpXTtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgZGVwcykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHR5cGUgZGVmaW5pdGlvbiBzcGVjaWZpZWQ6ICR7dHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gYCR7dHlwZX0oJHt0eXBlc1t0eXBlXVxuICAgICAgICAgICAgLm1hcCgoeyBuYW1lLCB0eXBlOiB0IH0pID0+IGAke3R9ICR7bmFtZX1gKVxuICAgICAgICAgICAgLmpvaW4oJywnKX0pYDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogRmluZHMgYWxsIHR5cGVzIHdpdGhpbiBhIHR5cGUgZGVmaW5pdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZS5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSByZXN1bHRzIC0gVGhlIGN1cnJlbnQgc2V0IG9mIGFjY3VtdWxhdGVkIHR5cGVzLlxuICogQHJldHVybnMgVGhlIHNldCBvZiBhbGwgdHlwZXMgZm91bmQgaW4gdGhlIHR5cGUgZGVmaW5pdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzLCByZXN1bHRzID0gbmV3IFNldCgpKSB7XG4gICAgW3ByaW1hcnlUeXBlXSA9IHByaW1hcnlUeXBlLm1hdGNoKC9eXFx3Ki91KTtcbiAgICBpZiAocmVzdWx0cy5oYXMocHJpbWFyeVR5cGUpIHx8IHR5cGVzW3ByaW1hcnlUeXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICByZXN1bHRzLmFkZChwcmltYXJ5VHlwZSk7XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgZmluZFR5cGVEZXBlbmRlbmNpZXMoZmllbGQudHlwZSwgdHlwZXMsIHJlc3VsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbi8qKlxuICogSGFzaGVzIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gcHJpbWFyeVR5cGUgLSBUaGUgcm9vdCB0eXBlLlxuICogQHBhcmFtIGRhdGEgLSBUaGUgb2JqZWN0IHRvIGhhc2guXG4gKiBAcGFyYW0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zIGZvciBhbGwgdHlwZXMgaW5jbHVkZWQgaW4gdGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBFSVAtNzEyIHZlcnNpb24gdGhlIGVuY29kaW5nIHNob3VsZCBjb21wbHkgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTdHJ1Y3QocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB2ZXJzaW9uKSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIFtTaWduVHlwZWREYXRhVmVyc2lvbi5WMywgU2lnblR5cGVkRGF0YVZlcnNpb24uVjRdKTtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikoZW5jb2RlRGF0YShwcmltYXJ5VHlwZSwgZGF0YSwgdHlwZXMsIHZlcnNpb24pKSk7XG59XG4vKipcbiAqIEhhc2hlcyB0aGUgdHlwZSBvZiBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZSB0byBoYXNoLlxuICogQHBhcmFtIHR5cGVzIC0gVHlwZSBkZWZpbml0aW9ucyBmb3IgYWxsIHR5cGVzIGluY2x1ZGVkIGluIHRoZSBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIG9iamVjdCB0eXBlLlxuICovXG5mdW5jdGlvbiBoYXNoVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBjb25zdCBlbmNvZGVkSGFzaFR5cGUgPSBCdWZmZXIuZnJvbShlbmNvZGVUeXBlKHByaW1hcnlUeXBlLCB0eXBlcyksICd1dGYtOCcpO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShlbmNvZGVkSGFzaFR5cGUpKTtcbn1cbi8qKlxuICogUmVtb3ZlcyBwcm9wZXJ0aWVzIGZyb20gYSBtZXNzYWdlIG9iamVjdCB0aGF0IGFyZSBub3QgZGVmaW5lZCBwZXIgRUlQLTcxMi5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSB0eXBlZCBtZXNzYWdlIG9iamVjdC5cbiAqIEByZXR1cm5zIFRoZSB0eXBlZCBtZXNzYWdlIG9iamVjdCB3aXRoIG9ubHkgYWxsb3dlZCBmaWVsZHMuXG4gKi9cbmZ1bmN0aW9uIHNhbml0aXplRGF0YShkYXRhKSB7XG4gICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGV4cG9ydHMuVFlQRURfTUVTU0FHRV9TQ0hFTUEucHJvcGVydGllcykge1xuICAgICAgICBpZiAoZGF0YVtrZXldKSB7XG4gICAgICAgICAgICBzYW5pdGl6ZWREYXRhW2tleV0gPSBkYXRhW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCd0eXBlcycgaW4gc2FuaXRpemVkRGF0YSkge1xuICAgICAgICBzYW5pdGl6ZWREYXRhLnR5cGVzID0gT2JqZWN0LmFzc2lnbih7IEVJUDcxMkRvbWFpbjogW10gfSwgc2FuaXRpemVkRGF0YS50eXBlcyk7XG4gICAgfVxuICAgIHJldHVybiBzYW5pdGl6ZWREYXRhO1xufVxuLyoqXG4gKiBIYXNoIGEgdHlwZWQgbWVzc2FnZSBhY2NvcmRpbmcgdG8gRUlQLTcxMi4gVGhlIHJldHVybmVkIG1lc3NhZ2Ugc3RhcnRzIHdpdGggdGhlIEVJUC03MTIgcHJlZml4LFxuICogd2hpY2ggaXMgXCIxOTAxXCIsIGZvbGxvd2VkIGJ5IHRoZSBoYXNoIG9mIHRoZSBkb21haW4gc2VwYXJhdG9yLCB0aGVuIHRoZSBkYXRhIChpZiBhbnkpLlxuICogVGhlIHJlc3VsdCBpcyBoYXNoZWQgYWdhaW4gYW5kIHJldHVybmVkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc2lnbiB0aGUgbWVzc2FnZS4gVGhlIHJlc3VsdGluZyBoYXNoIG11c3Qgc3RpbGwgYmUgc2lnbmVkIHRvIGNyZWF0ZSBhblxuICogRUlQLTcxMiBzaWduYXR1cmUuXG4gKlxuICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0gdmVyc2lvbiAtIFRoZSBFSVAtNzEyIHZlcnNpb24gdGhlIGVuY29kaW5nIHNob3VsZCBjb21wbHkgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0eXBlZCBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBlaXA3MTJIYXNoKHR5cGVkRGF0YSwgdmVyc2lvbikge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uLCBbU2lnblR5cGVkRGF0YVZlcnNpb24uVjMsIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0XSk7XG4gICAgY29uc3Qgc2FuaXRpemVkRGF0YSA9IHNhbml0aXplRGF0YSh0eXBlZERhdGEpO1xuICAgIGNvbnN0IHBhcnRzID0gW0J1ZmZlci5mcm9tKCcxOTAxJywgJ2hleCcpXTtcbiAgICBwYXJ0cy5wdXNoKGhhc2hTdHJ1Y3QoJ0VJUDcxMkRvbWFpbicsIHNhbml0aXplZERhdGEuZG9tYWluLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB2ZXJzaW9uKSk7XG4gICAgaWYgKHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUgIT09ICdFSVA3MTJEb21haW4nKSB7XG4gICAgICAgIHBhcnRzLnB1c2goaGFzaFN0cnVjdChcbiAgICAgICAgLy8gVE9ETzogVmFsaWRhdGUgdGhhdCB0aGlzIGlzIGEgc3RyaW5nLCBzbyB0aGlzIHR5cGUgY2FzdCBjYW4gYmUgcmVtb3ZlZC5cbiAgICAgICAgc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSwgc2FuaXRpemVkRGF0YS5tZXNzYWdlLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB2ZXJzaW9uKSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KShCdWZmZXIuY29uY2F0KHBhcnRzKSkpO1xufVxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBmb3Igc2lnbmluZyB0eXBlZCBkYXRhLlxuICovXG5leHBvcnRzLlR5cGVkRGF0YVV0aWxzID0ge1xuICAgIGVuY29kZURhdGEsXG4gICAgZW5jb2RlVHlwZSxcbiAgICBmaW5kVHlwZURlcGVuZGVuY2llcyxcbiAgICBoYXNoU3RydWN0LFxuICAgIGhhc2hUeXBlLFxuICAgIHNhbml0aXplRGF0YSxcbiAgICBlaXA3MTJIYXNoLFxufTtcbi8qKlxuICogR2VuZXJhdGUgdGhlIFwiVjFcIiBoYXNoIGZvciB0aGUgcHJvdmlkZWQgdHlwZWQgbWVzc2FnZS5cbiAqXG4gKiBUaGUgaGFzaCB3aWxsIGJlIGdlbmVyYXRlZCBpbiBhY2NvcmRhbmNlIHdpdGggYW4gZWFybGllciB2ZXJzaW9uIG9mIHRoZSBFSVAtNzEyXG4gKiBzcGVjaWZpY2F0aW9uLiBUaGlzIGhhc2ggaXMgdXNlZCBpbiBgc2lnblR5cGVkRGF0YV92MWAuXG4gKlxuICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgaGFzaCByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgdGhlIHByb3ZpZGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBoYXNoQnVmZmVyID0gX3R5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmJ1ZmZlclRvSGV4KShoYXNoQnVmZmVyKTtcbn1cbmV4cG9ydHMudHlwZWRTaWduYXR1cmVIYXNoID0gdHlwZWRTaWduYXR1cmVIYXNoO1xuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgXCJWMVwiIGhhc2ggZm9yIHRoZSBwcm92aWRlZCB0eXBlZCBtZXNzYWdlLlxuICpcbiAqIFRoZSBoYXNoIHdpbGwgYmUgZ2VuZXJhdGVkIGluIGFjY29yZGFuY2Ugd2l0aCBhbiBlYXJsaWVyIHZlcnNpb24gb2YgdGhlIEVJUC03MTJcbiAqIHNwZWNpZmljYXRpb24uIFRoaXMgaGFzaCBpcyB1c2VkIGluIGBzaWduVHlwZWREYXRhX3YxYC5cbiAqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gVGhlIHR5cGVkIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBUaGUgaGFzaCByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgdGhlIHByb3ZpZGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIF90eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4cGVjdCBhcmd1bWVudCB0byBiZSBub24tZW1wdHkgYXJyYXknKTtcbiAgICBpZiAodHlwZW9mIHR5cGVkRGF0YSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgISgnbGVuZ3RoJyBpbiB0eXBlZERhdGEpIHx8XG4gICAgICAgICF0eXBlZERhdGEubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS50eXBlICE9PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICByZXR1cm4gZS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEubGVnYWN5VG9CdWZmZXIpKGUudmFsdWUpO1xuICAgIH0pO1xuICAgIGNvbnN0IHR5cGVzID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gZS50eXBlO1xuICAgIH0pO1xuICAgIGNvbnN0IHNjaGVtYSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKCFlLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtlLnR5cGV9ICR7ZS5uYW1lfWA7XG4gICAgfSk7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKCgwLCBldGhlcmV1bWpzX2FiaV91dGlsc18xLnNvbGlkaXR5UGFjaykoWydieXRlczMyJywgJ2J5dGVzMzInXSwgW1xuICAgICAgICAoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgZXRoZXJldW1qc19hYmlfdXRpbHNfMS5zb2xpZGl0eVBhY2spKG5ldyBBcnJheSh0eXBlZERhdGEubGVuZ3RoKS5maWxsKCdzdHJpbmcnKSwgc2NoZW1hKSksXG4gICAgICAgICgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKCgwLCBldGhlcmV1bWpzX2FiaV91dGlsc18xLnNvbGlkaXR5UGFjaykodHlwZXMsIGRhdGEpKSxcbiAgICBdKSkpO1xufVxuLyoqXG4gKiBTaWduIHR5cGVkIGRhdGEgYWNjb3JkaW5nIHRvIEVJUC03MTIuIFRoZSBzaWduaW5nIGRpZmZlcnMgYmFzZWQgdXBvbiB0aGUgYHZlcnNpb25gLlxuICpcbiAqIFYxIGlzIGJhc2VkIHVwb24gW2FuIGVhcmx5IHZlcnNpb24gb2YgRUlQLTcxMl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvcHVsbC83MTIvY29tbWl0cy8yMWFiZTI1NGZlMDQ1MmQ4NTgzZDViMTMyYjFkN2JlODdjMDQzOWNhKVxuICogdGhhdCBsYWNrZWQgc29tZSBsYXRlciBzZWN1cml0eSBpbXByb3ZlbWVudHMsIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGJlIG5lZ2xlY3RlZCBpbiBmYXZvciBvZlxuICogbGF0ZXIgdmVyc2lvbnMuXG4gKlxuICogVjMgaXMgYmFzZWQgb24gW0VJUC03MTJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKSwgZXhjZXB0IHRoYXQgYXJyYXlzIGFuZFxuICogcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBWNCBpcyBiYXNlZCBvbiBbRUlQLTcxMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03MTIpLCBhbmQgaW5jbHVkZXMgZnVsbCBzdXBwb3J0IG9mXG4gKiBhcnJheXMgYW5kIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXMuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmluZyBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBzaWduIHdpdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIHR5cGVkIGRhdGEgdG8gc2lnbi5cbiAqIEBwYXJhbSBvcHRpb25zLnZlcnNpb24gLSBUaGUgc2lnbmluZyB2ZXJzaW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZnVuY3Rpb24gc2lnblR5cGVkRGF0YSh7IHByaXZhdGVLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGUga2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxXG4gICAgICAgID8gX3R5cGVkU2lnbmF0dXJlSGFzaChkYXRhKVxuICAgICAgICA6IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMuZWlwNzEySGFzaChkYXRhLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBzaWcgPSAoMCwgdXRpbF8xLmVjc2lnbikobWVzc2FnZUhhc2gsIHByaXZhdGVLZXkpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRTaWcpKCgwLCB1dGlsXzEudG9CdWZmZXIpKHNpZy52KSwgc2lnLnIsIHNpZy5zKTtcbn1cbmV4cG9ydHMuc2lnblR5cGVkRGF0YSA9IHNpZ25UeXBlZERhdGE7XG4vKipcbiAqIFJlY292ZXIgdGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdGhhdCBjcmVhdGVkIHRoZSBnaXZlbiBFSVAtNzEyXG4gKiBzaWduYXR1cmUuIFRoZSB2ZXJzaW9uIHByb3ZpZGVkIG11c3QgbWF0Y2ggdGhlIHZlcnNpb24gdXNlZCB0b1xuICogY3JlYXRlIHRoZSBzaWduYXR1cmUuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgc2lnbmF0dXJlIHJlY292ZXJ5IG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIHR5cGVkIGRhdGEgdGhhdCB3YXMgc2lnbmVkLlxuICogQHBhcmFtIG9wdGlvbnMuc2lnbmF0dXJlIC0gVGhlICcweC1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBvcHRpb25zLnZlcnNpb24gLSBUaGUgc2lnbmluZyB2ZXJzaW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBhZGRyZXNzIG9mIHRoZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIHJlY292ZXJUeXBlZFNpZ25hdHVyZSh7IGRhdGEsIHNpZ25hdHVyZSwgdmVyc2lvbiwgfSkge1xuICAgIHZhbGlkYXRlVmVyc2lvbih2ZXJzaW9uKTtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShzaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzaWduYXR1cmUgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VIYXNoID0gdmVyc2lvbiA9PT0gU2lnblR5cGVkRGF0YVZlcnNpb24uVjFcbiAgICAgICAgPyBfdHlwZWRTaWduYXR1cmVIYXNoKGRhdGEpXG4gICAgICAgIDogZXhwb3J0cy5UeXBlZERhdGFVdGlscy5laXA3MTJIYXNoKGRhdGEsIHZlcnNpb24pO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9ICgwLCB1dGlsc18xLnJlY292ZXJQdWJsaWNLZXkpKG1lc3NhZ2VIYXNoLCBzaWduYXR1cmUpO1xuICAgIGNvbnN0IHNlbmRlciA9ICgwLCB1dGlsXzEucHVibGljVG9BZGRyZXNzKShwdWJsaWNLZXkpO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmJ1ZmZlclRvSGV4KShzZW5kZXIpO1xufVxuZXhwb3J0cy5yZWNvdmVyVHlwZWRTaWduYXR1cmUgPSByZWNvdmVyVHlwZWRTaWduYXR1cmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduLXR5cGVkLWRhdGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm51bWJlclRvQnVmZmVyID0gZXhwb3J0cy5ub3JtYWxpemUgPSBleHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSBleHBvcnRzLmNvbmNhdFNpZyA9IGV4cG9ydHMubGVnYWN5VG9CdWZmZXIgPSBleHBvcnRzLmlzTnVsbGlzaCA9IGV4cG9ydHMucGFkV2l0aFplcm9lcyA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3QgZXRoanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGpzLXV0aWxcIik7XG4vKipcbiAqIFBhZHMgdGhlIGZyb250IG9mIHRoZSBnaXZlbiBoZXggc3RyaW5nIHdpdGggemVyb2VzIHVudGlsIGl0IHJlYWNoZXMgdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLiBJZiB0aGUgaW5wdXQgc3RyaW5nIGlzIGFscmVhZHkgbG9uZ2VyIHRoYW4gb3IgZXF1YWwgdG8gdGhlXG4gKiB0YXJnZXQgbGVuZ3RoLCBpdCBpcyByZXR1cm5lZCB1bm1vZGlmaWVkLlxuICpcbiAqIElmIHRoZSBpbnB1dCBzdHJpbmcgaXMgXCIweFwiLXByZWZpeGVkIG9yIG5vdCBhIGhleCBzdHJpbmcsIGFuIGVycm9yIHdpbGwgYmVcbiAqIHRocm93bi5cbiAqXG4gKiBAcGFyYW0gaGV4U3RyaW5nIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBwYWQgd2l0aCB6ZXJvZXMuXG4gKiBAcGFyYW0gdGFyZ2V0TGVuZ3RoIC0gVGhlIHRhcmdldCBsZW5ndGggb2YgdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBpbnB1dCBzdHJpbmcgZnJvbnQtcGFkZGVkIHdpdGggemVyb2VzLCBvciB0aGUgb3JpZ2luYWwgc3RyaW5nXG4gKiBpZiBpdCB3YXMgYWxyZWFkeSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdG8gdGhlIHRhcmdldCBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMoaGV4U3RyaW5nLCB0YXJnZXRMZW5ndGgpIHtcbiAgICBpZiAoaGV4U3RyaW5nICE9PSAnJyAmJiAhL15bYS1mMC05XSskL2l1LnRlc3QoaGV4U3RyaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGFuIHVucHJlZml4ZWQgaGV4IHN0cmluZy4gUmVjZWl2ZWQ6ICR7aGV4U3RyaW5nfWApO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0TGVuZ3RoIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgdGFyZ2V0IGxlbmd0aC4gUmVjZWl2ZWQ6ICR7dGFyZ2V0TGVuZ3RofWApO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydC5jYWxsKGhleFN0cmluZywgdGFyZ2V0TGVuZ3RoLCAnMCcpO1xufVxuZXhwb3J0cy5wYWRXaXRoWmVyb2VzID0gcGFkV2l0aFplcm9lcztcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG51bGxpc2guXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIGJlaW5nIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBudWxsaXNoLlxuICovXG5mdW5jdGlvbiBpc051bGxpc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNOdWxsaXNoID0gaXNOdWxsaXNoO1xuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgdG8gYSBCdWZmZXIuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGVxdWl2YWxlbnQgdG8gdGhlIGB0b0J1ZmZlcmAgZnVuY3Rpb24gaW5cbiAqIGBldGhlcmV1bWpzLXV0aWxANS4yLjFgLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgQnVmZmVyLlxuICogQHJldHVybnMgVGhlIGdpdmVuIHZhbHVlIGFzIGEgQnVmZmVyLlxuICovXG5mdW5jdGlvbiBsZWdhY3lUb0J1ZmZlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICEoMCwgZXRoanNfdXRpbF8xLmlzSGV4U3RyaW5nKSh2YWx1ZSlcbiAgICAgICAgPyBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICAgICAgOiAoMCwgdXRpbF8xLnRvQnVmZmVyKSh2YWx1ZSk7XG59XG5leHBvcnRzLmxlZ2FjeVRvQnVmZmVyID0gbGVnYWN5VG9CdWZmZXI7XG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGV4dGVuZGVkIEVDRFNBIHNpZ25hdHVyZSBpbnRvIGEgc2luZ2xlICcweCctcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gdiAtIFRoZSAndicgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIHIgLSBUaGUgJ3InIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBzIC0gVGhlICdzJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIEVDRFNBIHNpZ25hdHVyZSBhcyBhICcweCctcHJlZml4ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBjb25jYXRTaWcodiwgciwgcykge1xuICAgIGNvbnN0IHJTaWcgPSAoMCwgdXRpbF8xLmZyb21TaWduZWQpKHIpO1xuICAgIGNvbnN0IHNTaWcgPSAoMCwgdXRpbF8xLmZyb21TaWduZWQpKHMpO1xuICAgIGNvbnN0IHZTaWcgPSAoMCwgdXRpbF8xLmJ1ZmZlclRvSW50KSh2KTtcbiAgICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcygoMCwgdXRpbF8xLnRvVW5zaWduZWQpKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpO1xuICAgIGNvbnN0IHNTdHIgPSBwYWRXaXRoWmVyb2VzKCgwLCB1dGlsXzEudG9VbnNpZ25lZCkoc1NpZykudG9TdHJpbmcoJ2hleCcpLCA2NCk7XG4gICAgY29uc3QgdlN0ciA9ICgwLCBldGhqc191dGlsXzEuc3RyaXBIZXhQcmVmaXgpKCgwLCBldGhqc191dGlsXzEuaW50VG9IZXgpKHZTaWcpKTtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5hZGRIZXhQcmVmaXgpKHJTdHIuY29uY2F0KHNTdHIsIHZTdHIpKTtcbn1cbmV4cG9ydHMuY29uY2F0U2lnID0gY29uY2F0U2lnO1xuLyoqXG4gKiBSZWNvdmVyIHRoZSBwdWJsaWMga2V5IGZyb20gdGhlIGdpdmVuIHNpZ25hdHVyZSBhbmQgbWVzc2FnZSBoYXNoLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlSGFzaCAtIFRoZSBoYXNoIG9mIHRoZSBzaWduZWQgbWVzc2FnZS5cbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlIHB1YmxpYyBrZXkgb2YgdGhlIHNpZ25lci5cbiAqL1xuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShtZXNzYWdlSGFzaCwgc2lnbmF0dXJlKSB7XG4gICAgY29uc3Qgc2lnUGFyYW1zID0gKDAsIHV0aWxfMS5mcm9tUnBjU2lnKShzaWduYXR1cmUpO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmVjcmVjb3ZlcikobWVzc2FnZUhhc2gsIHNpZ1BhcmFtcy52LCBzaWdQYXJhbXMuciwgc2lnUGFyYW1zLnMpO1xufVxuZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleTtcbi8qKlxuICogTm9ybWFsaXplIHRoZSBpbnB1dCB0byBhIGxvd2VyLWNhc2VkICcweCctcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgdmFsdWUgdG8gbm9ybWFsaXplLlxuICogQHJldHVybnMgVGhlIG5vcm1hbGl6ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGlucHV0IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuICcweCc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gKDAsIHV0aWxfMS50b0J1ZmZlcikoaW5wdXQpO1xuICAgICAgICBpbnB1dCA9ICgwLCB1dGlsXzEuYnVmZmVyVG9IZXgpKGJ1ZmZlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxldCBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nO1xuICAgICAgICBtc2cgKz0gYCByZWNlaXZlZCAke3R5cGVvZiBpbnB1dH06ICR7aW5wdXR9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgdXRpbF8xLmFkZEhleFByZWZpeCkoaW5wdXQudG9Mb3dlckNhc2UoKSk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbi8qKlxuICogTm9kZSdzIEJ1ZmZlci5mcm9tKCkgbWV0aG9kIGRvZXMgbm90IHNlZW0gdG8gYnVmZmVyIG51bWJlcnMgY29ycmVjdGx5IG91dCBvZiB0aGUgYm94LlxuICogVGhpcyBoZWxwZXIgbWV0aG9kIGZvcm1hdHMgdGhlIG51bWJlciBjb3JyZWN0IGZvciBCdWZmZXIuZnJvbSB0byByZXR1cm4gY29ycmVjdCBidWZmZXIuXG4gKlxuICogQHBhcmFtIG51bSAtIFRoZSBudW1iZXIgdG8gY29udmVydCB0byBidWZmZXIuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIGluIGJ1ZmZlciBmb3JtLlxuICovXG5mdW5jdGlvbiBudW1iZXJUb0J1ZmZlcihudW0pIHtcbiAgICBjb25zdCBoZXhWYWwgPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIGNvbnN0IHByZXBlbmQgPSBoZXhWYWwubGVuZ3RoICUgMiA/ICcwJyA6ICcnO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShwcmVwZW5kICsgaGV4VmFsLCAnaGV4Jyk7XG59XG5leHBvcnRzLm51bWJlclRvQnVmZmVyID0gbnVtYmVyVG9CdWZmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrNTEyID0gZXhwb3J0cy5rZWNjYWszODQgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrMjI0ID0gdm9pZCAwO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMua2VjY2FrMjI0ID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjI0KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gKCgpID0+IHtcbiAgICBjb25zdCBrID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjU2KTtcbiAgICBrLmNyZWF0ZSA9IHNoYTNfMS5rZWNjYWtfMjU2LmNyZWF0ZTtcbiAgICByZXR1cm4gaztcbn0pKCk7XG5leHBvcnRzLmtlY2NhazM4NCA9ICgwLCB1dGlsc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzM4NCk7XG5leHBvcnRzLmtlY2NhazUxMiA9ICgwLCB1dGlsc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzUxMik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3V0cHV0ID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5udW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy5vdXRwdXQgPSBvdXRwdXQ7XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGQgPSBleHBvcnRzLnRvQmlnID0gZXhwb3J0cy5zcGxpdCA9IGV4cG9ydHMuZnJvbUJpZyA9IHZvaWQgMDtcbmNvbnN0IFUzMl9NQVNLNjQgPSBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZXhwb3J0cy5mcm9tQmlnID0gZnJvbUJpZztcbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuZXhwb3J0cy5zcGxpdCA9IHNwbGl0O1xuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbmV4cG9ydHMudG9CaWcgPSB0b0JpZztcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBsLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChoLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBsKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuLy8gUmVtb3ZpbmcgXCJleHBvcnRcIiBoYXMgNSUgcGVyZiBwZW5hbHR5IC1fLVxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuZXhwb3J0cy5hZGQgPSBhZGQ7XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWc6IGV4cG9ydHMudG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdTY0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbmV4cG9ydHMuY3J5cHRvID0ge1xuICAgIG5vZGU6IHVuZGVmaW5lZCxcbiAgICB3ZWI6IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBzZWxmID8gc2VsZi5jcnlwdG8gOiB1bmRlZmluZWQsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZXhwb3J0cy5zaGFrZTEyOCA9IGV4cG9ydHMua2VjY2FrXzUxMiA9IGV4cG9ydHMua2VjY2FrXzM4NCA9IGV4cG9ydHMua2VjY2FrXzI1NiA9IGV4cG9ydHMua2VjY2FrXzIyNCA9IGV4cG9ydHMuc2hhM181MTIgPSBleHBvcnRzLnNoYTNfMzg0ID0gZXhwb3J0cy5zaGEzXzI1NiA9IGV4cG9ydHMuc2hhM18yMjQgPSBleHBvcnRzLktlY2NhayA9IGV4cG9ydHMua2VjY2FrUCA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCBfdTY0X2pzXzEgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgW1NIQTNfUEksIFNIQTNfUk9UTCwgX1NIQTNfSU9UQV0gPSBbW10sIFtdLCBbXV07XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfN24gPSBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gX3U2NF9qc18xLmRlZmF1bHQuc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IF91NjRfanNfMS5kZWZhdWx0LnJvdGxCSChoLCBsLCBzKSA6IF91NjRfanNfMS5kZWZhdWx0LnJvdGxTSChoLCBsLCBzKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IF91NjRfanNfMS5kZWZhdWx0LnJvdGxCTChoLCBsLCBzKSA6IF91NjRfanNfMS5kZWZhdWx0LnJvdGxTTChoLCBsLCBzKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0cy5rZWNjYWtQID0ga2VjY2FrUDtcbmNsYXNzIEtlY2NhayBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5udW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5ieXRlcyhvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQubnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuS2VjY2FrID0gS2VjY2FrO1xuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0cy5zaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhM18yNTYgPSBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMuc2hhM18zODQgPSBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydHMuc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMjI0ID0gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMua2VjY2FrXzI1NiA9IGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLmtlY2Nha181MTIgPSBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3JXaXRoT3B0cykoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnRzLnNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5jaGVja09wdHMgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0J5dGVzID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuYXN5bmNMb29wID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMucm90ciA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbi8vIFRoZSBpbXBvcnQgaGVyZSBpcyB2aWEgdGhlIHBhY2thZ2UgbmFtZS4gVGhpcyBpcyB0byBlbnN1cmVcbi8vIHRoYXQgZXhwb3J0cyBtYXBwaW5nL3Jlc29sdXRpb24gZG9lcyBmYWxsIGludG8gcGxhY2UuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmV4cG9ydHMudTMyID0gdTMyO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydHMucm90ciA9IHJvdHI7XG5leHBvcnRzLmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuLy8gVGhlcmUgaXMgYWxtb3N0IG5vIGJpZyBlbmRpYW4gaGFyZHdhcmUsIGJ1dCBqcyB0eXBlZCBhcnJheXMgdXNlcyBwbGF0Zm9ybSBzcGVjaWZpYyBlbmRpYW5uZXNzLlxuLy8gU28sIGp1c3QgdG8gYmUgc3VyZSBub3QgdG8gY29ycnVwdCBhbnl0aGluZy5cbmlmICghZXhwb3J0cy5pc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhkZSwgMHhhZCwgMHhiZSwgMHhlZl0pKVxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KHVpbnQ4YSkge1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGlmICghKHVpbnQ4YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW3VpbnQ4YVtpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdkZWFkYmVlZicpXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvQnl0ZXM6IGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleFRvQnl0ZXM6IHJlY2VpdmVkIGludmFsaWQgdW5wYWRkZWQgaGV4Jyk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuIEhvd2V2ZXIsIGNhbGwgdG8gYXN5bmMgZnVuY3Rpb24gd2lsbCByZXR1cm4gUHJvbWlzZVxuLy8gd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvbiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGlucHV0IHR5cGUgaXMgVWludDhBcnJheSAoZ290ICR7dHlwZW9mIGRhdGF9KWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29uY2F0cyBVaW50OEFycmF5LXMgaW50byBvbmU7IGxpa2UgYEJ1ZmZlci5jb25jYXQoW2J1ZjEsIGJ1ZjJdKWBcbiAqIEBleGFtcGxlIGNvbmNhdEJ5dGVzKGJ1ZjEsIGJ1ZjIpXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmICghYXJyYXlzLmV2ZXJ5KChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBsaXN0IGV4cGVjdGVkJyk7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5jbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vLyBDaGVjayBpZiBvYmplY3QgZG9lbnMndCBoYXZlIGN1c3RvbSBjb25zdHJ1Y3RvciAobGlrZSBVaW50OEFycmF5L0FycmF5KVxuY29uc3QgaXNQbGFpbk9iamVjdCA9IChvYmopID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCAhaXNQbGFpbk9iamVjdChvcHRzKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobWVzc2FnZSkgPT4gaGFzaENvbnN0cnVjdG9yKCkudXBkYXRlKHRvQnl0ZXMobWVzc2FnZSkpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSB3cmFwQ29uc3RydWN0b3I7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cztcbi8qKlxuICogU2VjdXJlIFBSTkdcbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8ud2ViKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8ud2ViLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjcnlwdG9fMS5jcnlwdG8ubm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvXzEuY3J5cHRvLm5vZGUucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpLmJ1ZmZlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHJhbmRvbUJ5dGVzIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSBleHBvcnRzLndyYXBIYXNoID0gZXhwb3J0cy5lcXVhbHNCeXRlcyA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5jcmVhdGVWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9IZXggPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmFzc2VydEJ5dGVzID0gZXhwb3J0cy5hc3NlcnRCb29sID0gdm9pZCAwO1xuLy8gYnVmLnRvU3RyaW5nKCdoZXgnKSAtPiB0b0hleChidWYpXG5jb25zdCBfYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBub2JsZS9oYXNoZXMvX2Fzc2VydFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBhc3NlcnRCb29sID0gX2Fzc2VydF8xLmRlZmF1bHQuYm9vbDtcbmV4cG9ydHMuYXNzZXJ0Qm9vbCA9IGFzc2VydEJvb2w7XG5jb25zdCBhc3NlcnRCeXRlcyA9IF9hc3NlcnRfMS5kZWZhdWx0LmJ5dGVzO1xuZXhwb3J0cy5hc3NlcnRCeXRlcyA9IGFzc2VydEJ5dGVzO1xudmFyIHV0aWxzXzIgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ5dGVzVG9IZXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuYnl0ZXNUb0hleDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvSGV4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmJ5dGVzVG9IZXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRCeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5jb25jYXRCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVZpZXdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuY3JlYXRlVmlldzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV0ZjhUb0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLnV0ZjhUb0J5dGVzOyB9IH0pO1xuLy8gYnVmLnRvU3RyaW5nKCd1dGY4JykgLT4gYnl0ZXNUb1V0ZjgoYnVmKVxuZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoZGF0YSkge1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBieXRlc1RvVXRmOCBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBieXRlc1RvVXRmODtcbmZ1bmN0aW9uIGhleFRvQnl0ZXMoZGF0YSkge1xuICAgIGNvbnN0IHNsaWNlZCA9IGRhdGEuc3RhcnRzV2l0aChcIjB4XCIpID8gZGF0YS5zdWJzdHJpbmcoMikgOiBkYXRhO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShzbGljZWQpO1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIGJ1Zi5lcXVhbHMoYnVmMikgLT4gZXF1YWxzQnl0ZXMoYnVmLCBidWYyKVxuZnVuY3Rpb24gZXF1YWxzQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZXF1YWxzQnl0ZXMgPSBlcXVhbHNCeXRlcztcbi8vIEludGVybmFsIHV0aWxzXG5mdW5jdGlvbiB3cmFwSGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIChtc2cpID0+IHtcbiAgICAgICAgX2Fzc2VydF8xLmRlZmF1bHQuYnl0ZXMobXNnKTtcbiAgICAgICAgcmV0dXJuIGhhc2gobXNnKTtcbiAgICB9O1xufVxuZXhwb3J0cy53cmFwSGFzaCA9IHdyYXBIYXNoO1xuZXhwb3J0cy5jcnlwdG8gPSAoKCkgPT4ge1xuICAgIGNvbnN0IHdlYkNyeXB0byA9IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiICYmIFwiY3J5cHRvXCIgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vZGVSZXF1aXJlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2YgbW9kdWxlLnJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBtb2R1bGUucmVxdWlyZS5iaW5kKG1vZHVsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogbm9kZVJlcXVpcmUgJiYgIXdlYkNyeXB0byA/IG5vZGVSZXF1aXJlKFwiY3J5cHRvXCIpIDogdW5kZWZpbmVkLFxuICAgICAgICB3ZWI6IHdlYkNyeXB0b1xuICAgIH07XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xudmFyIHN0cmlwSGV4UHJlZml4ID0gcmVxdWlyZSgnc3RyaXAtaGV4LXByZWZpeCcpO1xuXG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICB2YXIgYSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIHBhZGRpbmcgdG8gZXZlbiwgdmFsdWUgbXVzdCBiZSBzdHJpbmcsIGlzIGN1cnJlbnRseSAnICsgdHlwZW9mIGEgKyAnLCB3aGlsZSBwYWRUb0V2ZW4uJyk7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggJSAyKSB7XG4gICAgYSA9ICcwJyArIGE7XG4gIH1cblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcbiAgdmFyIGhleCA9IGkudG9TdHJpbmcoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaW50VG9CdWZmZXIoaSkge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaSk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkVG9FdmVuKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIGdldHRpbmcgYmluYXJ5IHNpemUsIG1ldGhvZCBnZXRCaW5hcnlTaXplIHJlcXVpcmVzIGlucHV0IFxcJ3N0clxcJyB0byBiZSB0eXBlIFN0cmluZywgZ290IFxcJycgKyB0eXBlb2Ygc3RyICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHthcnJheX0gc3VwZXJzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHN1YnNldFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1cGVyc2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3VwZXJzZXQgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3Vic2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3Vic2V0ICsgJ1xcJycpO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNldFtCb29sZWFuKHNvbWUpICYmICdzb21lJyB8fCAnZXZlcnknXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOChoZXgpIHtcbiAgdmFyIGJ1ZmZlclZhbHVlID0gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgoaGV4KS5yZXBsYWNlKC9eMCt8MCskL2csICcnKSksICdoZXgnKTtcblxuICByZXR1cm4gYnVmZmVyVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICB2YXIgc3RyID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGkgPSAwLFxuICAgICAgbCA9IGhleC5sZW5ndGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgIGkgPSAyO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICB2YXIgc3RyID0gbmV3IEJ1ZmZlcihzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcblxuICByZXR1cm4gJzB4JyArIHBhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBoZXggPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgfVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIGdldEtleXMoW3thOiAxLCBiOiAyfSwge2E6IDMsIGI6IDR9XSwgJ2EnKSA9PiBbMSwgM11cbiAqXG4gKiBAbWV0aG9kIGdldEtleXMgZ2V0IHNwZWNpZmljIGtleSBmcm9tIGlubmVyIG9iamVjdCBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIHtBcnJheX0gb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIEFycmF5IGFzIFxcJ3BhcmFtc1xcJyBpbnB1dCwgZ290IFxcJycgKyB0eXBlb2YgcGFyYW1zICsgJ1xcJycpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIFN0cmluZyBmb3IgaW5wdXQgXFwna2V5XFwnIGdvdCBcXCcnICsgdHlwZW9mIGtleSArICdcXCcuJyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhYmknKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrIGlmIHN0cmluZyBpcyBoZXggc3RyaW5nIG9mIHNwZWNpZmljIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5Q29udGFpbnNBcnJheTogYXJyYXlDb250YWluc0FycmF5LFxuICBpbnRUb0J1ZmZlcjogaW50VG9CdWZmZXIsXG4gIGdldEJpbmFyeVNpemU6IGdldEJpbmFyeVNpemUsXG4gIGlzSGV4UHJlZml4ZWQ6IGlzSGV4UHJlZml4ZWQsXG4gIHN0cmlwSGV4UHJlZml4OiBzdHJpcEhleFByZWZpeCxcbiAgcGFkVG9FdmVuOiBwYWRUb0V2ZW4sXG4gIGludFRvSGV4OiBpbnRUb0hleCxcbiAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gIGZyb21VdGY4OiBmcm9tVXRmOCxcbiAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgdG9VdGY4OiB0b1V0ZjgsXG4gIGdldEtleXM6IGdldEtleXMsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZ1xufTsiLCJjb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IEhES2V5ID0gcmVxdWlyZSgnaGRrZXknKVxuY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBzaWdVdGlsID0gcmVxdWlyZSgnZXRoLXNpZy11dGlsJylcbmNvbnN0IHsgVHJhbnNhY3Rpb25GYWN0b3J5IH0gPSByZXF1aXJlKCdAZXRoZXJldW1qcy90eCcpXG5cbmNvbnN0IHBhdGhCYXNlID0gJ20nXG5jb25zdCBoZFBhdGhTdHJpbmcgPSBgJHtwYXRoQmFzZX0vNDQnLzYwJy8wJ2BcbmNvbnN0IHR5cGUgPSAnTGVkZ2VyIEhhcmR3YXJlJ1xuXG5jb25zdCBCUklER0VfVVJMID0gJ2h0dHBzOi8vbWV0YW1hc2suZ2l0aHViLmlvL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcnXG5cbmNvbnN0IE1BWF9JTkRFWCA9IDEwMDBcbmNvbnN0IE5FVFdPUktfQVBJX1VSTFMgPSB7XG4gIHJvcHN0ZW46ICdodHRwOi8vYXBpLXJvcHN0ZW4uZXRoZXJzY2FuLmlvJyxcbiAga292YW46ICdodHRwOi8vYXBpLWtvdmFuLmV0aGVyc2Nhbi5pbycsXG4gIHJpbmtlYnk6ICdodHRwczovL2FwaS1yaW5rZWJ5LmV0aGVyc2Nhbi5pbycsXG4gIG1haW5uZXQ6ICdodHRwczovL2FwaS5ldGhlcnNjYW4uaW8nLFxufVxuXG5jb25zdCBDT05ORUNUSU9OX0VWRU5UID0gJ2xlZGdlci1jb25uZWN0aW9uLWNoYW5nZSdcblxuY2xhc3MgTGVkZ2VyQnJpZGdlS2V5cmluZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5hY2NvdW50RGV0YWlscyA9IHt9XG4gICAgdGhpcy5icmlkZ2VVcmwgPSBudWxsXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMucGFnZSA9IDBcbiAgICB0aGlzLnBlclBhZ2UgPSA1XG4gICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSAwXG4gICAgdGhpcy5oZGsgPSBuZXcgSERLZXkoKVxuICAgIHRoaXMucGF0aHMgPSB7fVxuICAgIHRoaXMuaWZyYW1lID0gbnVsbFxuICAgIHRoaXMubmV0d29yayA9ICdtYWlubmV0J1xuICAgIHRoaXMuaW1wbGVtZW50RnVsbEJJUDQ0ID0gZmFsc2VcbiAgICB0aGlzLmRlc2VyaWFsaXplKG9wdHMpXG5cbiAgICB0aGlzLmlmcmFtZUxvYWRlZCA9IGZhbHNlXG4gICAgdGhpcy5fc2V0dXBJZnJhbWUoKVxuXG4gICAgdGhpcy5jdXJyZW50TWVzc2FnZUlkID0gMFxuICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcyA9IHt9XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcigpXG4gIH1cblxuICBzZXJpYWxpemUgKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgaGRQYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgIGFjY291bnRzOiB0aGlzLmFjY291bnRzLFxuICAgICAgYWNjb3VudERldGFpbHM6IHRoaXMuYWNjb3VudERldGFpbHMsXG4gICAgICBicmlkZ2VVcmw6IHRoaXMuYnJpZGdlVXJsLFxuICAgICAgaW1wbGVtZW50RnVsbEJJUDQ0OiBmYWxzZSxcbiAgICB9KVxuICB9XG5cbiAgZGVzZXJpYWxpemUgKG9wdHMgPSB7fSkge1xuICAgIHRoaXMuaGRQYXRoID0gb3B0cy5oZFBhdGggfHwgaGRQYXRoU3RyaW5nXG4gICAgdGhpcy5icmlkZ2VVcmwgPSBvcHRzLmJyaWRnZVVybCB8fCBCUklER0VfVVJMXG4gICAgdGhpcy5hY2NvdW50cyA9IG9wdHMuYWNjb3VudHMgfHwgW11cbiAgICB0aGlzLmFjY291bnREZXRhaWxzID0gb3B0cy5hY2NvdW50RGV0YWlscyB8fCB7fVxuICAgIGlmICghb3B0cy5hY2NvdW50RGV0YWlscykge1xuICAgICAgdGhpcy5fbWlncmF0ZUFjY291bnREZXRhaWxzKG9wdHMpXG4gICAgfVxuXG4gICAgdGhpcy5pbXBsZW1lbnRGdWxsQklQNDQgPSBvcHRzLmltcGxlbWVudEZ1bGxCSVA0NCB8fCBmYWxzZVxuXG4gICAgLy8gUmVtb3ZlIGFjY291bnRzIHRoYXQgZG9uJ3QgaGF2ZSBjb3JyZXNwb25kaW5nIGFjY291bnQgZGV0YWlsc1xuICAgIHRoaXMuYWNjb3VudHMgPSB0aGlzLmFjY291bnRzXG4gICAgICAuZmlsdGVyKChhY2NvdW50KSA9PiBPYmplY3Qua2V5cyh0aGlzLmFjY291bnREZXRhaWxzKS5pbmNsdWRlcyhldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFjY291bnQpKSlcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgX21pZ3JhdGVBY2NvdW50RGV0YWlscyAob3B0cykge1xuICAgIGlmICh0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSAmJiBvcHRzLmFjY291bnRJbmRleGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgT2JqZWN0LmtleXMob3B0cy5hY2NvdW50SW5kZXhlcykpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50RGV0YWlsc1thY2NvdW50XSA9IHtcbiAgICAgICAgICBiaXA0NDogdHJ1ZSxcbiAgICAgICAgICBoZFBhdGg6IHRoaXMuX2dldFBhdGhGb3JJbmRleChvcHRzLmFjY291bnRJbmRleGVzW2FjY291bnRdKSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRyeSB0byBtaWdyYXRlIG5vbi1MZWRnZXJMaXZlIGFjY291bnRzIHRvb1xuICAgIGlmICghdGhpcy5faXNMZWRnZXJMaXZlSGRQYXRoKCkpIHtcbiAgICAgIHRoaXMuYWNjb3VudHNcbiAgICAgICAgLmZpbHRlcigoYWNjb3VudCkgPT4gIU9iamVjdC5rZXlzKHRoaXMuYWNjb3VudERldGFpbHMpLmluY2x1ZGVzKGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWNjb3VudCkpKVxuICAgICAgICAuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWNjb3VudCldID0ge1xuICAgICAgICAgICAgICBiaXA0NDogZmFsc2UsXG4gICAgICAgICAgICAgIGhkUGF0aDogdGhpcy5fcGF0aEZyb21BZGRyZXNzKGFjY291bnQpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBmYWlsZWQgdG8gbWlncmF0ZSBhY2NvdW50ICR7YWNjb3VudH1gKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpc1VubG9ja2VkICgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhkayAmJiB0aGlzLmhkay5wdWJsaWNLZXkpXG4gIH1cblxuICBpc0Nvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZXZpY2VDb25uZWN0ZWRcbiAgfVxuXG4gIHNldEFjY291bnRUb1VubG9jayAoaW5kZXgpIHtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IHBhcnNlSW50KGluZGV4LCAxMClcbiAgfVxuXG4gIHNldEhkUGF0aCAoaGRQYXRoKSB7XG4gICAgLy8gUmVzZXQgSERLZXkgaWYgdGhlIHBhdGggY2hhbmdlc1xuICAgIGlmICh0aGlzLmhkUGF0aCAhPT0gaGRQYXRoKSB7XG4gICAgICB0aGlzLmhkayA9IG5ldyBIREtleSgpXG4gICAgfVxuICAgIHRoaXMuaGRQYXRoID0gaGRQYXRoXG4gIH1cblxuICB1bmxvY2sgKGhkUGF0aCwgdXBkYXRlSGRrID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmlzVW5sb2NrZWQoKSAmJiAhaGRQYXRoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdhbHJlYWR5IHVubG9ja2VkJylcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGhkUGF0aCA/IHRoaXMuX3RvTGVkZ2VyUGF0aChoZFBhdGgpIDogdGhpcy5oZFBhdGhcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItdW5sb2NrJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgaGRQYXRoOiBwYXRoLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgICh7IHN1Y2Nlc3MsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIGlmICh1cGRhdGVIZGspIHtcbiAgICAgICAgICAgIHRoaXMuaGRrLnB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucHVibGljS2V5LCAnaGV4JylcbiAgICAgICAgICAgIHRoaXMuaGRrLmNoYWluQ29kZSA9IEJ1ZmZlci5mcm9tKHBheWxvYWQuY2hhaW5Db2RlLCAnaGV4JylcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShwYXlsb2FkLmFkZHJlc3MpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdVbmtub3duIGVycm9yJykpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFkZEFjY291bnRzIChuID0gMSkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oYXN5bmMgKF8pID0+IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gdGhpcy51bmxvY2tlZEFjY291bnRcbiAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGF0aEZvckluZGV4KGkpXG4gICAgICAgICAgICBsZXQgYWRkcmVzc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICAgICAgICAgIGFkZHJlc3MgPSBhd2FpdCB0aGlzLnVubG9jayhwYXRoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldID0ge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciByZW5hbWluZyB0aGlzIHByb3BlcnR5LCBhcyB0aGUgY3VycmVudCBuYW1lIGlzIG1pc2xlYWRpbmdcbiAgICAgICAgICAgICAgLy8gSXQncyBjdXJyZW50bHkgdXNlZCB0byByZXByZXNlbnQgd2hldGhlciBhbiBhY2NvdW50IHVzZXMgdGhlIExlZGdlciBMaXZlIHBhdGguXG4gICAgICAgICAgICAgIGJpcDQ0OiB0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSxcbiAgICAgICAgICAgICAgaGRQYXRoOiBwYXRoLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY2NvdW50cy5wdXNoKGFkZHJlc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhZ2UgPSAwXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUodGhpcy5hY2NvdW50cylcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgZ2V0Rmlyc3RQYWdlICgpIHtcbiAgICB0aGlzLnBhZ2UgPSAwXG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpXG4gIH1cblxuICBnZXROZXh0UGFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpXG4gIH1cblxuICBnZXRQcmV2aW91c1BhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgtMSlcbiAgfVxuXG4gIGdldEFjY291bnRzICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjb3VudHMuc2xpY2UoKSlcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQgKGFkZHJlc3MpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudHMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKVxuICAgIH1cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoKGEpID0+IGEudG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKVxuICAgIGRlbGV0ZSB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldXG4gIH1cblxuICBhdHRlbXB0TWFrZUFwcCAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLW1ha2UtYXBwJyxcbiAgICAgIH0sICh7IHN1Y2Nlc3MsIGVycm9yIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGVUcmFuc3BvcnRNZXRob2QgKHRyYW5zcG9ydFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gSWYgdGhlIGlmcmFtZSBpc24ndCBsb2FkZWQgeWV0LCBsZXQncyBzdG9yZSB0aGUgZGVzaXJlZCB0cmFuc3BvcnRUeXBlIHZhbHVlIGFuZFxuICAgICAgLy8gb3B0aW1pc3RpY2FsbHkgcmV0dXJuIGEgc3VjY2Vzc2Z1bCBwcm9taXNlXG4gICAgICBpZiAoIXRoaXMuaWZyYW1lTG9hZGVkKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UgPSB7XG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgdHJhbnNwb3J0VHlwZSxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItdXBkYXRlLXRyYW5zcG9ydCcsXG4gICAgICAgIHBhcmFtczogeyB0cmFuc3BvcnRUeXBlIH0sXG4gICAgICB9LCAoeyBzdWNjZXNzIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTGVkZ2VyIHRyYW5zcG9ydCBjb3VsZCBub3QgYmUgdXBkYXRlZCcpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyB0eCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZXRoZXJldW1qcy10cmFuc2FjdGlvbiBjbGFzcy5cbiAgc2lnblRyYW5zYWN0aW9uIChhZGRyZXNzLCB0eCkge1xuICAgIGxldCByYXdUeEhleFxuICAgIC8vIHRyYW5zYWN0aW9ucyBidWlsdCB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIGV0aGVyZXVtanMtdHggaGF2ZSBhXG4gICAgLy8gZ2V0Q2hhaW5JZCBtZXRob2QgdGhhdCBuZXdlciB2ZXJzaW9ucyBkbyBub3QuIE9sZGVyIHZlcnNpb25zIGFyZSBtdXRhYmxlXG4gICAgLy8gd2hpbGUgbmV3ZXIgdmVyc2lvbnMgZGVmYXVsdCB0byBiZWluZyBpbW11dGFibGUuIEV4cGVjdGVkIHNoYXBlIGFuZCB0eXBlXG4gICAgLy8gb2YgZGF0YSBmb3IgdiwgciBhbmQgcyBkaWZmZXIgKEJ1ZmZlciAob2xkKSB2cyBCTiAobmV3KSlcbiAgICBpZiAodHlwZW9mIHR4LmdldENoYWluSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEluIHRoaXMgdmVyc2lvbiBvZiBldGhlcmV1bWpzLXR4IHdlIG11c3QgYWRkIHRoZSBjaGFpbklkIGluIGhleCBmb3JtYXRcbiAgICAgIC8vIHRvIHRoZSBpbml0aWFsIHYgdmFsdWUuIFRoZSBjaGFpbklkIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIHNlcmlhbGl6ZWRcbiAgICAgIC8vIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG9ubHkgY29tbXVuaWNhdGVkIHRvIGV0aGVyZXVtanMtdHggaW4gdGhpc1xuICAgICAgLy8gdmFsdWUuIEluIG5ld2VyIHZlcnNpb25zIHRoZSBjaGFpbklkIGlzIGNvbW11bmljYXRlZCB2aWEgdGhlICdDb21tb24nXG4gICAgICAvLyBvYmplY3QuXG4gICAgICB0eC52ID0gZXRoVXRpbC5idWZmZXJUb0hleCh0eC5nZXRDaGFpbklkKCkpXG4gICAgICB0eC5yID0gJzB4MDAnXG4gICAgICB0eC5zID0gJzB4MDAnXG5cbiAgICAgIHJhd1R4SGV4ID0gdHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpXG5cbiAgICAgIHJldHVybiB0aGlzLl9zaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgcmF3VHhIZXgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHR4LnYgPSBCdWZmZXIuZnJvbShwYXlsb2FkLnYsICdoZXgnKVxuICAgICAgICB0eC5yID0gQnVmZmVyLmZyb20ocGF5bG9hZC5yLCAnaGV4JylcbiAgICAgICAgdHgucyA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucywgJ2hleCcpXG4gICAgICAgIHJldHVybiB0eFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBUaGUgYmVsb3cgYGVuY29kZWAgY2FsbCBpcyBvbmx5IG5lY2Vzc2FyeSBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucywgYXMgYGdldE1lc3NhZ2VUb1NpZ25gXG4gICAgLy8gY2FsbHMgYHJscC5lbmNvZGVgIGludGVybmFsbHkgZm9yIG5vbi1sZWdhY3kgdHJhbnNhY3Rpb25zLiBBcyBwZXIgdGhlIFwiVHJhbnNhY3Rpb24gRXhlY3V0aW9uXCJcbiAgICAvLyBzZWN0aW9uIG9mIHRoZSBldGhlcmV1bSB5ZWxsb3cgcGFwZXIsIHRyYW5zYWN0aW9ucyBuZWVkIHRvIGJlIFwid2VsbC1mb3JtZWQgUkxQLCB3aXRoIG5vIGFkZGl0aW9uYWxcbiAgICAvLyB0cmFpbGluZyBieXRlc1wiLlxuXG4gICAgLy8gTm90ZSBhbHNvIHRoYXQgYGdldE1lc3NhZ2VUb1NpZ25gIHdpbGwgcmV0dXJuIHZhbGlkIFJMUCBmb3IgYWxsIHRyYW5zYWN0aW9uIHR5cGVzLCB3aGVyZWFzIHRoZVxuICAgIC8vIGBzZXJpYWxpemVgIG1ldGhvZCB3aWxsIG5vdCBmb3IgYW55IHRyYW5zYWN0aW9uIHR5cGUgZXhjZXB0IGxlZ2FjeS4gVGhpcyBpcyBiZWNhdXNlIGBzZXJpYWxpemVgIGluY2x1ZGVzXG4gICAgLy8gZW1wdHkgciwgcyBhbmQgdiB2YWx1ZXMgaW4gdGhlIGVuY29kZWQgcmxwLiBUaGlzIGlzIHdoeSB3ZSB1c2UgYGdldE1lc3NhZ2VUb1NpZ25gIGhlcmUgaW5zdGVhZCBvZiBgc2VyaWFsaXplYC5cbiAgICBjb25zdCBtZXNzYWdlVG9TaWduID0gdHguZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSlcblxuICAgIHJhd1R4SGV4ID0gQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2VUb1NpZ24pXG4gICAgICA/IG1lc3NhZ2VUb1NpZ24udG9TdHJpbmcoJ2hleCcpXG4gICAgICA6IGV0aFV0aWwucmxwLmVuY29kZShtZXNzYWdlVG9TaWduKS50b1N0cmluZygnaGV4JylcblxuICAgIHJldHVybiB0aGlzLl9zaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgcmF3VHhIZXgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAvLyBCZWNhdXNlIHR4IHdpbGwgYmUgaW1tdXRhYmxlLCBmaXJzdCBnZXQgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB0aGF0XG4gICAgICAvLyByZXByZXNlbnRzIHRoZSB0cmFuc2FjdGlvbi4gVXNpbmcgdHhEYXRhIGhlcmUgYXMgaXQgYWxpZ25zIHdpdGggdGhlXG4gICAgICAvLyBub21lbmNsYXR1cmUgb2YgZXRoZXJldW1qcy90eC5cbiAgICAgIGNvbnN0IHR4RGF0YSA9IHR4LnRvSlNPTigpXG4gICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgYSB0eXBlIHRvIHN1cHBvcnQgdHJhbnNhY3Rpb25zIHdpdGggYSB0eXBlIG90aGVyIHRoYW4gMFxuICAgICAgdHhEYXRhLnR5cGUgPSB0eC50eXBlXG4gICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgdixyIGFuZCBzIHRvIGJlIGhleCBwcmVmaXhlZFxuICAgICAgdHhEYXRhLnYgPSBldGhVdGlsLmFkZEhleFByZWZpeChwYXlsb2FkLnYpXG4gICAgICB0eERhdGEuciA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHBheWxvYWQucilcbiAgICAgIHR4RGF0YS5zID0gZXRoVXRpbC5hZGRIZXhQcmVmaXgocGF5bG9hZC5zKVxuICAgICAgLy8gQWRvcHQgdGhlICdjb21tb24nIG9wdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCB0cmFuc2FjdGlvbiBhbmQgc2V0IHRoZVxuICAgICAgLy8gcmV0dXJuZWQgb2JqZWN0IHRvIGJlIGZyb3plbiBpZiB0aGUgb3JpZ2luYWwgaXMgZnJvemVuLlxuICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4RGF0YSwgeyBjb21tb246IHR4LmNvbW1vbiwgZnJlZXplOiBPYmplY3QuaXNGcm96ZW4odHgpIH0pXG4gICAgfSlcbiAgfVxuXG4gIF9zaWduVHJhbnNhY3Rpb24gKGFkZHJlc3MsIHJhd1R4SGV4LCBoYW5kbGVTaWduaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyhhZGRyZXNzKVxuICAgICAgICAudGhlbigoaGRQYXRoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLXNpZ24tdHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIHR4OiByYXdUeEhleCxcbiAgICAgICAgICAgICAgaGRQYXRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgICh7IHN1Y2Nlc3MsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcblxuICAgICAgICAgICAgICBjb25zdCBuZXdPck11dGF0ZWRUeCA9IGhhbmRsZVNpZ25pbmcocGF5bG9hZClcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBuZXdPck11dGF0ZWRUeC52ZXJpZnlTaWduYXR1cmUoKVxuICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ld09yTXV0YXRlZFR4KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0xlZGdlcjogVGhlIHRyYW5zYWN0aW9uIHNpZ25hdHVyZSBpcyBub3QgdmFsaWQnKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyB0cmFuc2FjdGlvbicpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfVxuXG4gIHNpZ25NZXNzYWdlICh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpXG4gIH1cblxuICAvLyBGb3IgcGVyc29uYWxfc2lnbiwgd2UgbmVlZCB0byBwcmVmaXggdGhlIG1lc3NhZ2U6XG4gIHNpZ25QZXJzb25hbE1lc3NhZ2UgKHdpdGhBY2NvdW50LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyh3aXRoQWNjb3VudClcbiAgICAgICAgLnRoZW4oKGhkUGF0aCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2xlZGdlci1zaWduLXBlcnNvbmFsLW1lc3NhZ2UnLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIGhkUGF0aCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXRoVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoeyBzdWNjZXNzLCBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGxldCB2ID0gcGFyc2VJbnQocGF5bG9hZC52LCAxMClcbiAgICAgICAgICAgICAgdiA9IHYudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB2ID0gYDAke3Z9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGAweCR7cGF5bG9hZC5yfSR7cGF5bG9hZC5zfSR7dn1gXG4gICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gc2lnVXRpbC5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUoeyBkYXRhOiBtZXNzYWdlLCBzaWc6IHNpZ25hdHVyZSB9KVxuICAgICAgICAgICAgICBpZiAoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzU2lnbmVkV2l0aCkgIT09IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTGVkZ2VyOiBUaGUgc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoc2lnbmF0dXJlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyBtZXNzYWdlJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgdW5sb2NrQWNjb3VudEJ5QWRkcmVzcyAoYWRkcmVzcykge1xuICAgIGNvbnN0IGNoZWNrc3VtbWVkQWRkcmVzcyA9IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcylcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuYWNjb3VudERldGFpbHMpLmluY2x1ZGVzKGNoZWNrc3VtbWVkQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGVkZ2VyOiBBY2NvdW50IGZvciBhZGRyZXNzICcke2NoZWNrc3VtbWVkQWRkcmVzc30nIG5vdCBmb3VuZGApXG4gICAgfVxuICAgIGNvbnN0IHsgaGRQYXRoIH0gPSB0aGlzLmFjY291bnREZXRhaWxzW2NoZWNrc3VtbWVkQWRkcmVzc11cbiAgICBjb25zdCB1bmxvY2tlZEFkZHJlc3MgPSBhd2FpdCB0aGlzLnVubG9jayhoZFBhdGgsIGZhbHNlKVxuXG4gICAgLy8gdW5sb2NrIHJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciB0aGUgZ2l2ZW4gaGRQYXRoIGFzIHJlcG9ydGVkIGJ5IHRoZSBsZWRnZXIgZGV2aWNlXG4gICAgLy8gaWYgdGhhdCBhZGRyZXNzIGlzIG5vdCB0aGUgcmVxdWVzdGVkIGFkZHJlc3MsIHRoZW4gdGhpcyBhY2NvdW50IGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgZGV2aWNlIG9yIHNlZWRcbiAgICBpZiAodW5sb2NrZWRBZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZWRnZXI6IEFjY291bnQgJHthZGRyZXNzfSBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIGNvbm5lY3RlZCBkZXZpY2VgKVxuICAgIH1cbiAgICByZXR1cm4gaGRQYXRoXG4gIH1cblxuICBhc3luYyBzaWduVHlwZWREYXRhICh3aXRoQWNjb3VudCwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaXNWNCA9IG9wdGlvbnMudmVyc2lvbiA9PT0gJ1Y0J1xuICAgIGlmICghaXNWNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWRnZXI6IE9ubHkgdmVyc2lvbiA0IG9mIHR5cGVkIGRhdGEgc2lnbmluZyBpcyBzdXBwb3J0ZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGRvbWFpbixcbiAgICAgIHR5cGVzLFxuICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICBtZXNzYWdlLFxuICAgIH0gPSBzaWdVdGlsLlR5cGVkRGF0YVV0aWxzLnNhbml0aXplRGF0YShkYXRhKVxuICAgIGNvbnN0IGRvbWFpblNlcGFyYXRvckhleCA9IHNpZ1V0aWwuVHlwZWREYXRhVXRpbHMuaGFzaFN0cnVjdCgnRUlQNzEyRG9tYWluJywgZG9tYWluLCB0eXBlcywgaXNWNCkudG9TdHJpbmcoJ2hleCcpXG4gICAgY29uc3QgaGFzaFN0cnVjdE1lc3NhZ2VIZXggPSBzaWdVdGlsLlR5cGVkRGF0YVV0aWxzLmhhc2hTdHJ1Y3QocHJpbWFyeVR5cGUsIG1lc3NhZ2UsIHR5cGVzLCBpc1Y0KS50b1N0cmluZygnaGV4JylcblxuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyh3aXRoQWNjb3VudClcbiAgICBjb25zdCB7IHN1Y2Nlc3MsIHBheWxvYWQgfSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIGFjdGlvbjogJ2xlZGdlci1zaWduLXR5cGVkLWRhdGEnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBoZFBhdGgsXG4gICAgICAgICAgZG9tYWluU2VwYXJhdG9ySGV4LFxuICAgICAgICAgIGhhc2hTdHJ1Y3RNZXNzYWdlSGV4LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIChyZXN1bHQpID0+IHJlc29sdmUocmVzdWx0KSlcbiAgICB9KVxuXG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIGxldCB2ID0gcGFyc2VJbnQocGF5bG9hZC52LCAxMClcbiAgICAgIHYgPSB2LnRvU3RyaW5nKDE2KVxuICAgICAgaWYgKHYubGVuZ3RoIDwgMikge1xuICAgICAgICB2ID0gYDAke3Z9YFxuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYDB4JHtwYXlsb2FkLnJ9JHtwYXlsb2FkLnN9JHt2fWBcbiAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gc2lnVXRpbC5yZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBzaWc6IHNpZ25hdHVyZSxcbiAgICAgIH0pXG4gICAgICBpZiAoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzU2lnbmVkV2l0aCkgIT09IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVkZ2VyOiBUaGUgc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpXG4gICAgICB9XG4gICAgICByZXR1cm4gc2lnbmF0dXJlXG4gICAgfVxuICAgIHRocm93IHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyBtZXNzYWdlJylcbiAgfVxuXG4gIGV4cG9ydEFjY291bnQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpXG4gIH1cblxuICBmb3JnZXREZXZpY2UgKCkge1xuICAgIHRoaXMuYWNjb3VudHMgPSBbXVxuICAgIHRoaXMucGFnZSA9IDBcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IDBcbiAgICB0aGlzLnBhdGhzID0ge31cbiAgICB0aGlzLmFjY291bnREZXRhaWxzID0ge31cbiAgICB0aGlzLmhkayA9IG5ldyBIREtleSgpXG4gIH1cblxuICAvKiBQUklWQVRFIE1FVEhPRFMgKi9cblxuICBfc2V0dXBJZnJhbWUgKCkge1xuICAgIHRoaXMuaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgICB0aGlzLmlmcmFtZS5zcmMgPSB0aGlzLmJyaWRnZVVybFxuICAgIHRoaXMuaWZyYW1lLmFsbG93ID0gYGhpZCAnc3JjJ2BcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBJZiB0aGUgbGVkZ2VyIGxpdmUgcHJlZmVyZW5jZSB3YXMgc2V0IGJlZm9yZSB0aGUgaWZyYW1lIGlzIGxvYWRlZCxcbiAgICAgIC8vIHNldCBpdCBhZnRlciB0aGUgaWZyYW1lIGhhcyBsb2FkZWRcbiAgICAgIHRoaXMuaWZyYW1lTG9hZGVkID0gdHJ1ZVxuICAgICAgaWYgKHRoaXMuZGVsYXllZFByb21pc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnVwZGF0ZVRyYW5zcG9ydE1ldGhvZChcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UudHJhbnNwb3J0VHlwZSxcbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5kZWxheWVkUHJvbWlzZS5yZXNvbHZlKHJlc3VsdClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UucmVqZWN0KGUpXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuZGVsYXllZFByb21pc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuaWZyYW1lKVxuICB9XG5cbiAgX2dldE9yaWdpbiAoKSB7XG4gICAgY29uc3QgdG1wID0gdGhpcy5icmlkZ2VVcmwuc3BsaXQoJy8nKVxuICAgIHRtcC5zcGxpY2UoLTEsIDEpXG4gICAgcmV0dXJuIHRtcC5qb2luKCcvJylcbiAgfVxuXG4gIF9zZW5kTWVzc2FnZSAobXNnLCBjYikge1xuICAgIG1zZy50YXJnZXQgPSAnTEVER0VSLUlGUkFNRSdcblxuICAgIHRoaXMuY3VycmVudE1lc3NhZ2VJZCArPSAxXG4gICAgbXNnLm1lc3NhZ2VJZCA9IHRoaXMuY3VycmVudE1lc3NhZ2VJZFxuXG4gICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzW3RoaXMuY3VycmVudE1lc3NhZ2VJZF0gPSBjYlxuICAgIHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCAnKicpXG4gIH1cblxuICBfc2V0dXBMaXN0ZW5lciAoKSB7XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lciA9ICh7IG9yaWdpbiwgZGF0YSB9KSA9PiB7XG4gICAgICBpZiAob3JpZ2luICE9PSB0aGlzLl9nZXRPcmlnaW4oKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZUNhbGxiYWNrc1tkYXRhLm1lc3NhZ2VJZF0pIHtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3NbZGF0YS5tZXNzYWdlSWRdKGRhdGEpXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24gPT09IENPTk5FQ1RJT05fRVZFTlQpIHtcbiAgICAgICAgICB0aGlzLmlzRGV2aWNlQ29ubmVjdGVkID0gZGF0YS5wYXlsb2FkLmNvbm5lY3RlZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9ldmVudExpc3RlbmVyKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9ldmVudExpc3RlbmVyKVxuICB9XG5cbiAgYXN5bmMgX19nZXRQYWdlIChpbmNyZW1lbnQpIHtcblxuICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnRcblxuICAgIGlmICh0aGlzLnBhZ2UgPD0gMCkge1xuICAgICAgdGhpcy5wYWdlID0gMVxuICAgIH1cbiAgICBjb25zdCBmcm9tID0gKHRoaXMucGFnZSAtIDEpICogdGhpcy5wZXJQYWdlXG4gICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlXG5cbiAgICBhd2FpdCB0aGlzLnVubG9jaygpXG4gICAgbGV0IGFjY291bnRzXG4gICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICBhY2NvdW50cyA9IGF3YWl0IHRoaXMuX2dldEFjY291bnRzQklQNDQoZnJvbSwgdG8pXG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY291bnRzID0gdGhpcy5fZ2V0QWNjb3VudHNMZWdhY3koZnJvbSwgdG8pXG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgYXN5bmMgX2dldEFjY291bnRzQklQNDQgKGZyb20sIHRvKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGF0aEZvckluZGV4KGkpXG4gICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy51bmxvY2socGF0aClcbiAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5pbXBsZW1lbnRGdWxsQklQNDQgPyBhd2FpdCB0aGlzLl9oYXNQcmV2aW91c1RyYW5zYWN0aW9ucyhhZGRyZXNzKSA6IHRydWVcbiAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBiYWxhbmNlOiBudWxsLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgIH0pXG4gICAgICAvLyBQRVIgQklQNDRcbiAgICAgIC8vIFwiU29mdHdhcmUgc2hvdWxkIHByZXZlbnQgYSBjcmVhdGlvbiBvZiBhbiBhY2NvdW50IGlmXG4gICAgICAvLyBhIHByZXZpb3VzIGFjY291bnQgZG9lcyBub3QgaGF2ZSBhIHRyYW5zYWN0aW9uIGhpc3RvcnlcbiAgICAgIC8vIChtZWFuaW5nIG5vbmUgb2YgaXRzIGFkZHJlc3NlcyBoYXZlIGJlZW4gdXNlZCBiZWZvcmUpLlwiXG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgX2dldEFjY291bnRzTGVnYWN5IChmcm9tLCB0bykge1xuICAgIGNvbnN0IGFjY291bnRzID0gW11cblxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpXG4gICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICB9KVxuICAgICAgdGhpcy5wYXRoc1tldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IGlcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnRzXG4gIH1cblxuICBfcGFkTGVmdEV2ZW4gKGhleCkge1xuICAgIHJldHVybiBoZXgubGVuZ3RoICUgMiA9PT0gMCA/IGhleCA6IGAwJHtoZXh9YFxuICB9XG5cbiAgX25vcm1hbGl6ZSAoYnVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZExlZnRFdmVuKGV0aFV0aWwuYnVmZmVyVG9IZXgoYnVmKS50b0xvd2VyQ2FzZSgpKVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBfYWRkcmVzc0Zyb21JbmRleCAocGF0aEJhc2UsIGkpIHtcbiAgICBjb25zdCBka2V5ID0gdGhpcy5oZGsuZGVyaXZlKGAke3BhdGhCYXNlfS8ke2l9YClcbiAgICBjb25zdCBhZGRyZXNzID0gZXRoVXRpbFxuICAgICAgLnB1YmxpY1RvQWRkcmVzcyhka2V5LnB1YmxpY0tleSwgdHJ1ZSlcbiAgICAgIC50b1N0cmluZygnaGV4JylcbiAgICByZXR1cm4gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhgMHgke2FkZHJlc3N9YClcbiAgfVxuXG4gIF9wYXRoRnJvbUFkZHJlc3MgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXG4gICAgbGV0IGluZGV4ID0gdGhpcy5wYXRoc1tjaGVja3N1bW1lZEFkZHJlc3NdXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lOREVYOyBpKyspIHtcbiAgICAgICAgaWYgKGNoZWNrc3VtbWVkQWRkcmVzcyA9PT0gdGhpcy5fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkpIHtcbiAgICAgICAgICBpbmRleCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhZGRyZXNzJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhdGhGb3JJbmRleChpbmRleClcbiAgfVxuXG4gIF90b0FzY2lpIChoZXgpIHtcbiAgICBsZXQgc3RyID0gJydcbiAgICBsZXQgaSA9IDBcbiAgICBjb25zdCBsID0gaGV4Lmxlbmd0aFxuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICBpID0gMlxuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KVxuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICBfZ2V0UGF0aEZvckluZGV4IChpbmRleCkge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwYXRoIGlzIEJJUCA0NCAoTGVkZ2VyIExpdmUpXG4gICAgcmV0dXJuIHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpID8gYG0vNDQnLzYwJy8ke2luZGV4fScvMC8wYCA6IGAke3RoaXMuaGRQYXRofS8ke2luZGV4fWBcbiAgfVxuXG4gIF9pc0xlZGdlckxpdmVIZFBhdGggKCkge1xuICAgIHJldHVybiB0aGlzLmhkUGF0aCA9PT0gYG0vNDQnLzYwJy8wJy8wLzBgXG4gIH1cblxuICBfdG9MZWRnZXJQYXRoIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5yZXBsYWNlKCdtLycsICcnKVxuICB9XG5cbiAgYXN5bmMgX2hhc1ByZXZpb3VzVHJhbnNhY3Rpb25zIChhZGRyZXNzKSB7XG4gICAgY29uc3QgYXBpVXJsID0gdGhpcy5fZ2V0QXBpVXJsKClcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5mZXRjaChgJHthcGlVcmx9L2FwaT9tb2R1bGU9YWNjb3VudCZhY3Rpb249dHhsaXN0JmFkZHJlc3M9JHthZGRyZXNzfSZ0YWc9bGF0ZXN0JnBhZ2U9MSZvZmZzZXQ9MWApXG4gICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBpZiAocGFyc2VkUmVzcG9uc2Uuc3RhdHVzICE9PSAnMCcgJiYgcGFyc2VkUmVzcG9uc2UucmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgX2dldEFwaVVybCAoKSB7XG4gICAgcmV0dXJuIE5FVFdPUktfQVBJX1VSTFNbdGhpcy5uZXR3b3JrXSB8fCBORVRXT1JLX0FQSV9VUkxTLm1haW5uZXRcbiAgfVxuXG59XG5cbkxlZGdlckJyaWRnZUtleXJpbmcudHlwZSA9IHR5cGVcbm1vZHVsZS5leHBvcnRzID0gTGVkZ2VyQnJpZGdlS2V5cmluZ1xuIiwiY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcbmNvbnN0IGV0aEFiaSA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtYWJpJylcbmNvbnN0IG5hY2wgPSByZXF1aXJlKCd0d2VldG5hY2wnKVxubmFjbC51dGlsID0gcmVxdWlyZSgndHdlZXRuYWNsLXV0aWwnKVxuXG5jb25zdCBUWVBFRF9NRVNTQUdFX1NDSEVNQSA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlczoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIHR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlcXVpcmVkOiBbJ25hbWUnLCAndHlwZSddLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgZG9tYWluOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgbWVzc2FnZTogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICB9LFxuICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGZvciBzaWduaW5nIHR5cGVkIGRhdGFcbiAqL1xuY29uc3QgVHlwZWREYXRhVXRpbHMgPSB7XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGFuZCBjb25jYXRlbmF0aW5nIGVhY2ggb2YgaXRzIG1lbWJlcnNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gT2JqZWN0IHRvIGVuY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3RcbiAgICovXG4gIGVuY29kZURhdGEgKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQgPSB0cnVlKSB7XG4gICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ11cbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW3RoaXMuaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKV1cblxuICAgIGlmICh1c2VWNCkge1xuICAgICAgY29uc3QgZW5jb2RlRmllbGQgPSAobmFtZSwgdHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyA6XG4gICAgICAgICAgICBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEodHlwZSwgdmFsdWUsIHR5cGVzLCB1c2VWNCkpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGZpZWxkICR7bmFtZX0gb2YgdHlwZSAke3R5cGV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIGV0aFV0aWwua2VjY2FrKHZhbHVlKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlciAtIHByZXZlbnRzIGV0aFV0aWwgZnJvbSBpbnRlcnByZXRpbmcgc3RyaW5ncyBsaWtlICcweGFiY2QnIGFzIGhleFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhVdGlsLmtlY2Nhayh2YWx1ZSldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5sYXN0SW5kZXhPZignXScpID09PSB0eXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpXG4gICAgICAgICAgY29uc3QgdHlwZVZhbHVlUGFpcnMgPSB2YWx1ZS5tYXAoKGl0ZW0pID0+IGVuY29kZUZpZWxkKG5hbWUsIHBhcnNlZFR5cGUsIGl0ZW0pKVxuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhVdGlsLmtlY2NhayhldGhBYmkucmF3RW5jb2RlKFxuICAgICAgICAgICAgdHlwZVZhbHVlUGFpcnMubWFwKChbX3R5cGVdKSA9PiBfdHlwZSksXG4gICAgICAgICAgICB0eXBlVmFsdWVQYWlycy5tYXAoKFssIF92YWx1ZV0pID0+IF92YWx1ZSksXG4gICAgICAgICAgKSldXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3R5cGUsIHZhbHVlXVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gZW5jb2RlRmllbGQoZmllbGQubmFtZSwgZmllbGQudHlwZSwgZGF0YVtmaWVsZC5uYW1lXSlcbiAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2godHlwZSlcbiAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW2ZpZWxkLm5hbWVdXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIHZhbHVlID0gZXRoVXRpbC5rZWNjYWsodmFsdWUpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2goJ2J5dGVzMzInKVxuICAgICAgICAgICAgLy8gY29udmVydCBzdHJpbmcgdG8gYnVmZmVyIC0gcHJldmVudHMgZXRoVXRpbCBmcm9tIGludGVycHJldGluZyBzdHJpbmdzIGxpa2UgJzB4YWJjZCcgYXMgaGV4XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGV0aFV0aWwua2VjY2FrKHZhbHVlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZXNbZmllbGQudHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2goJ2J5dGVzMzInKVxuICAgICAgICAgICAgdmFsdWUgPSBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEoZmllbGQudHlwZSwgdmFsdWUsIHR5cGVzLCB1c2VWNCkpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC50eXBlLmxhc3RJbmRleE9mKCddJykgPT09IGZpZWxkLnR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgY3VycmVudGx5IHVuaW1wbGVtZW50ZWQgaW4gZW5jb2RlRGF0YScpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKGZpZWxkLnR5cGUpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV0aEFiaS5yYXdFbmNvZGUoZW5jb2RlZFR5cGVzLCBlbmNvZGVkVmFsdWVzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbmNvZGVzIHRoZSB0eXBlIG9mIGFuIG9iamVjdCBieSBlbmNvZGluZyBhIGNvbW1hIGRlbGltaXRlZCBsaXN0IG9mIGl0cyBtZW1iZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZSB0byBlbmNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR5cGUgb2YgYW4gb2JqZWN0XG4gICAqL1xuICBlbmNvZGVUeXBlIChwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gJydcbiAgICBsZXQgZGVwcyA9IHRoaXMuZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzKS5maWx0ZXIoKGRlcCkgPT4gZGVwICE9PSBwcmltYXJ5VHlwZSlcbiAgICBkZXBzID0gW3ByaW1hcnlUeXBlXS5jb25jYXQoZGVwcy5zb3J0KCkpXG4gICAgZm9yIChjb25zdCB0eXBlIG9mIGRlcHMpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHlwZXNbdHlwZV1cbiAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0eXBlIGRlZmluaXRpb24gc3BlY2lmaWVkOiAke3R5cGV9YClcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBgJHt0eXBlfSgke3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlOiBfdHlwZSB9KSA9PiBgJHtfdHlwZX0gJHtuYW1lfWApLmpvaW4oJywnKX0pYFxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCB0eXBlcyB3aXRoaW4gYSB0eXBlIGRlZmludGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzdWx0cyAtIGN1cnJlbnQgc2V0IG9mIGFjY3VtdWxhdGVkIHR5cGVzXG4gICAqIEByZXR1cm5zIHtBcnJheX0gLSBTZXQgb2YgYWxsIHR5cGVzIGZvdW5kIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbiAgICovXG4gIGZpbmRUeXBlRGVwZW5kZW5jaWVzIChwcmltYXJ5VHlwZSwgdHlwZXMsIHJlc3VsdHMgPSBbXSkge1xuICAgIGNvbnN0IFtmaXJzdFdvcmRdID0gcHJpbWFyeVR5cGUubWF0Y2goL15cXHcqL3UpXG4gICAgcHJpbWFyeVR5cGUgPSBmaXJzdFdvcmRcbiAgICBpZiAocmVzdWx0cy5pbmNsdWRlcyhwcmltYXJ5VHlwZSkgfHwgdHlwZXNbcHJpbWFyeVR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHRzXG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChwcmltYXJ5VHlwZSlcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgZm9yIChjb25zdCBkZXAgb2YgdGhpcy5maW5kVHlwZURlcGVuZGVuY2llcyhmaWVsZC50eXBlLCB0eXBlcywgcmVzdWx0cykpIHtcbiAgICAgICAgIXJlc3VsdHMuaW5jbHVkZXMoZGVwKSAmJiByZXN1bHRzLnB1c2goZGVwKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYXNoZXMgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCB0byBoYXNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBIYXNoIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgaGFzaFN0cnVjdCAocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB1c2VWNCA9IHRydWUpIHtcbiAgICByZXR1cm4gZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVEYXRhKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQpKVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYXNoZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZSB0byBoYXNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBIYXNoIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgaGFzaFR5cGUgKHByaW1hcnlUeXBlLCB0eXBlcykge1xuICAgIHJldHVybiBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZVR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSlcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBwcm9wZXJ0aWVzIGZyb20gYSBtZXNzYWdlIG9iamVjdCB0aGF0IGFyZSBub3QgZGVmaW5lZCBwZXIgRUlQLTcxMlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIHR5cGVkIG1lc3NhZ2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0gdHlwZWQgbWVzc2FnZSBvYmplY3Qgd2l0aCBvbmx5IGFsbG93ZWQgZmllbGRzXG4gICAqL1xuICBzYW5pdGl6ZURhdGEgKGRhdGEpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0ge31cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhUWVBFRF9NRVNTQUdFX1NDSEVNQS5wcm9wZXJ0aWVzKSkge1xuICAgICAgZGF0YVtrZXldICYmIChzYW5pdGl6ZWREYXRhW2tleV0gPSBkYXRhW2tleV0pXG4gICAgfVxuICAgIGlmIChzYW5pdGl6ZWREYXRhLnR5cGVzKSB7XG4gICAgICBzYW5pdGl6ZWREYXRhLnR5cGVzID0geyBFSVA3MTJEb21haW46IFtdLCAuLi5zYW5pdGl6ZWREYXRhLnR5cGVzIH1cbiAgICB9XG4gICAgcmV0dXJuIHNhbml0aXplZERhdGFcbiAgfSxcblxuICAvKipcbiAgICogU2lnbnMgYSB0eXBlZCBtZXNzYWdlIGFzIHBlciBFSVAtNzEyIGFuZCByZXR1cm5zIGl0cyBrZWNjYWsgaGFzaFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWREYXRhIC0gVHlwZXMgbWVzc2FnZSBkYXRhIHRvIHNpZ25cbiAgICogQHJldHVybnMge3N0cmluZ30gLSBrZWNjYWsgaGFzaCBvZiB0aGUgcmVzdWx0aW5nIHNpZ25lZCBtZXNzYWdlXG4gICAqL1xuICBzaWduICh0eXBlZERhdGEsIHVzZVY0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSB0aGlzLnNhbml0aXplRGF0YSh0eXBlZERhdGEpXG4gICAgY29uc3QgcGFydHMgPSBbQnVmZmVyLmZyb20oJzE5MDEnLCAnaGV4JyldXG4gICAgcGFydHMucHVzaCh0aGlzLmhhc2hTdHJ1Y3QoJ0VJUDcxMkRvbWFpbicsIHNhbml0aXplZERhdGEuZG9tYWluLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB1c2VWNCkpXG4gICAgaWYgKHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUgIT09ICdFSVA3MTJEb21haW4nKSB7XG4gICAgICBwYXJ0cy5wdXNoKHRoaXMuaGFzaFN0cnVjdChzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlLCBzYW5pdGl6ZWREYXRhLm1lc3NhZ2UsIHNhbml0aXplZERhdGEudHlwZXMsIHVzZVY0KSlcbiAgICB9XG4gICAgcmV0dXJuIGV0aFV0aWwua2VjY2FrKEJ1ZmZlci5jb25jYXQocGFydHMpKVxuICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVFlQRURfTUVTU0FHRV9TQ0hFTUEsXG4gIFR5cGVkRGF0YVV0aWxzLFxuXG4gIGNvbmNhdFNpZyAodiwgciwgcykge1xuICAgIGNvbnN0IHJTaWcgPSBldGhVdGlsLmZyb21TaWduZWQocilcbiAgICBjb25zdCBzU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHMpXG4gICAgY29uc3QgdlNpZyA9IGV0aFV0aWwuYnVmZmVyVG9JbnQodilcbiAgICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcyhldGhVdGlsLnRvVW5zaWduZWQoclNpZykudG9TdHJpbmcoJ2hleCcpLCA2NClcbiAgICBjb25zdCBzU3RyID0gcGFkV2l0aFplcm9lcyhldGhVdGlsLnRvVW5zaWduZWQoc1NpZykudG9TdHJpbmcoJ2hleCcpLCA2NClcbiAgICBjb25zdCB2U3RyID0gZXRoVXRpbC5zdHJpcEhleFByZWZpeChldGhVdGlsLmludFRvSGV4KHZTaWcpKVxuICAgIHJldHVybiBldGhVdGlsLmFkZEhleFByZWZpeChyU3RyLmNvbmNhdChzU3RyLCB2U3RyKSkudG9TdHJpbmcoJ2hleCcpXG4gIH0sXG5cbiAgbm9ybWFsaXplIChpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZXRoVXRpbC50b0J1ZmZlcihpbnB1dClcbiAgICAgIGlucHV0ID0gZXRoVXRpbC5idWZmZXJUb0hleChidWZmZXIpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nXG4gICAgICBtc2cgKz0gYCByZWNlaXZlZCAke3R5cGVvZiBpbnB1dH06ICR7aW5wdXR9YFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZylcbiAgICB9XG5cbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoaW5wdXQudG9Mb3dlckNhc2UoKSlcbiAgfSxcblxuICBwZXJzb25hbFNpZ24gKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IG1zZ0hhc2ggPSBldGhVdGlsLmhhc2hQZXJzb25hbE1lc3NhZ2UobWVzc2FnZSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICAgIHJldHVybiBzZXJpYWxpemVkXG4gIH0sXG5cbiAgcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IobXNnUGFyYW1zKVxuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICBjb25zdCBzZW5kZXJIZXggPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgICByZXR1cm4gc2VuZGVySGV4XG4gIH0sXG5cbiAgZXh0cmFjdFB1YmxpY0tleSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICByZXR1cm4gYDB4JHtwdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpfWBcbiAgfSxcblxuICB0eXBlZFNpZ25hdHVyZUhhc2ggKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KGhhc2hCdWZmZXIpXG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YUxlZ2FjeSAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpXG4gICAgY29uc3Qgc2VuZGVyID0gZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgfSxcblxuICBlbmNyeXB0IChyZWNlaXZlclB1YmxpY0tleSwgbXNnUGFyYW1zLCB2ZXJzaW9uKSB7XG5cbiAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtc2dQYXJhbXMuZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZXRlY3Qgc2VjcmV0IG1lc3NhZ2UsIG1lc3NhZ2UgcGFyYW1zIHNob3VsZCBiZSBvZiB0aGUgZm9ybSB7ZGF0YTogXCJzZWNyZXQgbWVzc2FnZVwifSAnKVxuICAgICAgICB9XG4gICAgICAgIC8vIGdlbmVyYXRlIGVwaGVtZXJhbCBrZXlwYWlyXG4gICAgICAgIGNvbnN0IGVwaGVtZXJhbEtleVBhaXIgPSBuYWNsLmJveC5rZXlQYWlyKClcblxuICAgICAgICAvLyBhc3NlbWJsZSBlbmNyeXB0aW9uIHBhcmFtZXRlcnMgLSBmcm9tIHN0cmluZyB0byBVSW50OFxuICAgICAgICBsZXQgcHViS2V5VUludDhBcnJheVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHB1YktleVVJbnQ4QXJyYXkgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KHJlY2VpdmVyUHVibGljS2V5KVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBwdWJsaWMga2V5JylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtc1VJbnQ4QXJyYXkgPSBuYWNsLnV0aWwuZGVjb2RlVVRGOChtc2dQYXJhbXMuZGF0YSlcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnJhbmRvbUJ5dGVzKG5hY2wuYm94Lm5vbmNlTGVuZ3RoKVxuXG4gICAgICAgIC8vIGVuY3J5cHRcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94KG1zZ1BhcmFtc1VJbnQ4QXJyYXksIG5vbmNlLCBwdWJLZXlVSW50OEFycmF5LCBlcGhlbWVyYWxLZXlQYWlyLnNlY3JldEtleSlcblxuICAgICAgICAvLyBoYW5kbGUgZW5jcnlwdGVkIGRhdGFcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgIHZlcnNpb246ICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnLFxuICAgICAgICAgIG5vbmNlOiBuYWNsLnV0aWwuZW5jb2RlQmFzZTY0KG5vbmNlKSxcbiAgICAgICAgICBlcGhlbVB1YmxpY0tleTogbmFjbC51dGlsLmVuY29kZUJhc2U2NChlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgY2lwaGVydGV4dDogbmFjbC51dGlsLmVuY29kZUJhc2U2NChlbmNyeXB0ZWRNZXNzYWdlKSxcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gZW5jcnlwdGVkIG1zZyBkYXRhXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZCcpXG5cbiAgICB9XG4gIH0sXG5cbiAgZW5jcnlwdFNhZmVseSAocmVjZWl2ZXJQdWJsaWNLZXksIG1zZ1BhcmFtcywgdmVyc2lvbikge1xuXG4gICAgY29uc3QgREVGQVVMVF9QQURESU5HX0xFTkdUSCA9ICgyICoqIDExKVxuICAgIGNvbnN0IE5BQ0xfRVhUUkFfQllURVMgPSAxNlxuXG4gICAgY29uc3QgeyBkYXRhIH0gPSBtc2dQYXJhbXNcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgZW1wdHkgbXNnLmRhdGEnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YS50b0pTT04pIHtcbiAgICAgIC8vIHJlbW92ZSB0b0pTT04gYXR0YWNrIHZlY3RvclxuICAgICAgLy8gVE9ETywgY2hlY2sgYWxsIHBvc3NpYmxlIGNoaWxkcmVuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHdpdGggdG9KU09OIHByb3BlcnR5LiAgUGxlYXNlIHJlbW92ZSB0b0pTT04gcHJvcGVydHknKVxuICAgIH1cblxuICAgIC8vIGFkZCBwYWRkaW5nXG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0ge1xuICAgICAgZGF0YSxcbiAgICAgIHBhZGRpbmc6ICcnLFxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KGRhdGFXaXRoUGFkZGluZyksICd1dGYtOCcpXG4gICAgY29uc3QgbW9kVmFsID0gKGRhdGFMZW5ndGggJSBERUZBVUxUX1BBRERJTkdfTEVOR1RIKVxuICAgIGxldCBwYWRMZW5ndGggPSAwXG4gICAgLy8gT25seSBwYWQgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKG1vZFZhbCA+IDApIHtcbiAgICAgIHBhZExlbmd0aCA9IChERUZBVUxUX1BBRERJTkdfTEVOR1RIIC0gbW9kVmFsKSAtIE5BQ0xfRVhUUkFfQllURVMgLy8gbmFjbCBleHRyYSBieXRlc1xuICAgIH1cbiAgICBkYXRhV2l0aFBhZGRpbmcucGFkZGluZyA9ICcwJy5yZXBlYXQocGFkTGVuZ3RoKVxuXG4gICAgY29uc3QgcGFkZGVkTXNnUGFyYW1zID0geyBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpIH1cbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0KHJlY2VpdmVyUHVibGljS2V5LCBwYWRkZWRNc2dQYXJhbXMsIHZlcnNpb24pXG4gIH0sXG5cbiAgZGVjcnlwdCAoZW5jcnlwdGVkRGF0YSwgcmVjZWl2ZXJQcml2YXRlS2V5KSB7XG5cbiAgICBzd2l0Y2ggKGVuY3J5cHRlZERhdGEudmVyc2lvbikge1xuICAgICAgY2FzZSAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1Jzoge1xuICAgICAgICAvLyBzdHJpbmcgdG8gYnVmZmVyIHRvIFVJbnQ4QXJyYXlcbiAgICAgICAgY29uc3QgcmVjaWV2ZXJQcml2YXRlS2V5VWludDhBcnJheSA9IG5hY2xfZGVjb2RlSGV4KHJlY2VpdmVyUHJpdmF0ZUtleSlcbiAgICAgICAgY29uc3QgcmVjaWV2ZXJFbmNyeXB0aW9uUHJpdmF0ZUtleSA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleShyZWNpZXZlclByaXZhdGVLZXlVaW50OEFycmF5KS5zZWNyZXRLZXlcblxuICAgICAgICAvLyBhc3NlbWJsZSBkZWNyeXB0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEubm9uY2UpXG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuY2lwaGVydGV4dClcbiAgICAgICAgY29uc3QgZXBoZW1QdWJsaWNLZXkgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuZXBoZW1QdWJsaWNLZXkpXG5cbiAgICAgICAgLy8gZGVjcnlwdFxuICAgICAgICBjb25zdCBkZWNyeXB0ZWRNZXNzYWdlID0gbmFjbC5ib3gub3BlbihjaXBoZXJ0ZXh0LCBub25jZSwgZXBoZW1QdWJsaWNLZXksIHJlY2lldmVyRW5jcnlwdGlvblByaXZhdGVLZXkpXG5cbiAgICAgICAgLy8gcmV0dXJuIGRlY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICBsZXQgb3V0cHV0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0cHV0ID0gbmFjbC51dGlsLmVuY29kZVVURjgoZGVjcnlwdGVkTWVzc2FnZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZC4nKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY3J5cHRpb24gZmFpbGVkLicpXG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZC4nKVxuICAgIH1cbiAgfSxcblxuICBkZWNyeXB0U2FmZWx5IChlbmNyeXB0ZWREYXRhLCByZWNlaXZlclByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBkYXRhV2l0aFBhZGRpbmcgPSBKU09OLnBhcnNlKHRoaXMuZGVjcnlwdChlbmNyeXB0ZWREYXRhLCByZWNlaXZlclByaXZhdGVLZXkpKVxuICAgIHJldHVybiBkYXRhV2l0aFBhZGRpbmcuZGF0YVxuICB9LFxuXG5cbiAgZ2V0RW5jcnlwdGlvblB1YmxpY0tleSAocHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IHByaXZhdGVLZXlVaW50OEFycmF5ID0gbmFjbF9kZWNvZGVIZXgocHJpdmF0ZUtleSlcbiAgICBjb25zdCBlbmNyeXB0aW9uUHVibGljS2V5ID0gbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXlVaW50OEFycmF5KS5wdWJsaWNLZXlcbiAgICByZXR1cm4gbmFjbC51dGlsLmVuY29kZUJhc2U2NChlbmNyeXB0aW9uUHVibGljS2V5KVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEEgZ2VuZXJpYyBlbnRyeSBwb2ludCBmb3IgYWxsIHR5cGVkIGRhdGEgbWV0aG9kcyB0byBiZSBwYXNzZWQsIGluY2x1ZGVzIGEgdmVyc2lvbiBwYXJhbWV0ZXIuXG4gICAqL1xuICBzaWduVHlwZWRNZXNzYWdlIChwcml2YXRlS2V5LCBtc2dQYXJhbXMsIHZlcnNpb24gPSAnVjQnKSB7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlICdWMSc6XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeXBlZERhdGFMZWdhY3kocHJpdmF0ZUtleSwgbXNnUGFyYW1zKVxuICAgICAgY2FzZSAnVjMnOlxuICAgICAgICByZXR1cm4gdGhpcy5zaWduVHlwZWREYXRhKHByaXZhdGVLZXksIG1zZ1BhcmFtcylcbiAgICAgIGNhc2UgJ1Y0JzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeXBlZERhdGFfdjQocHJpdmF0ZUtleSwgbXNnUGFyYW1zKVxuICAgIH1cbiAgfSxcblxuICByZWNvdmVyVHlwZWRNZXNzYWdlIChtc2dQYXJhbXMsIHZlcnNpb24gPSAnVjQnKSB7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlICdWMSc6XG4gICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeShtc2dQYXJhbXMpXG4gICAgICBjYXNlICdWMyc6XG4gICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJUeXBlZFNpZ25hdHVyZShtc2dQYXJhbXMpXG4gICAgICBjYXNlICdWNCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQobXNnUGFyYW1zKVxuICAgIH1cbiAgfSxcblxuICBzaWduVHlwZWREYXRhIChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSwgZmFsc2UpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICBzaWduVHlwZWREYXRhX3Y0IChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEsIGZhbHNlKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXkobWVzc2FnZSwgbXNnUGFyYW1zLnNpZylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZV92NCAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3QgcHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleShtZXNzYWdlLCBtc2dQYXJhbXMuc2lnKVxuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gIH0sXG5cbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCAodHlwZWREYXRhKSB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdFeHBlY3QgYXJndW1lbnQgdG8gYmUgbm9uLWVtcHR5IGFycmF5JylcbiAgaWYgKHR5cGVvZiB0eXBlZERhdGEgIT09ICdvYmplY3QnIHx8ICF0eXBlZERhdGEubGVuZ3RoKSB7XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUudHlwZSA9PT0gJ2J5dGVzJyA/IGV0aFV0aWwudG9CdWZmZXIoZS52YWx1ZSkgOiBlLnZhbHVlXG4gIH0pXG4gIGNvbnN0IHR5cGVzID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlLnR5cGVcbiAgfSlcbiAgY29uc3Qgc2NoZW1hID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5uYW1lKSB7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICByZXR1cm4gYCR7ZS50eXBlfSAke2UubmFtZX1gXG4gIH0pXG5cbiAgcmV0dXJuIGV0aEFiaS5zb2xpZGl0eVNIQTMoXG4gICAgWydieXRlczMyJywgJ2J5dGVzMzInXSxcbiAgICBbXG4gICAgICBldGhBYmkuc29saWRpdHlTSEEzKG5ldyBBcnJheSh0eXBlZERhdGEubGVuZ3RoKS5maWxsKCdzdHJpbmcnKSwgc2NoZW1hKSxcbiAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTModHlwZXMsIGRhdGEpLFxuICAgIF0sXG4gIClcbn1cblxuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleSAoaGFzaCwgc2lnKSB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGV0aFV0aWwudG9CdWZmZXIoc2lnKVxuICBjb25zdCBzaWdQYXJhbXMgPSBldGhVdGlsLmZyb21ScGNTaWcoc2lnbmF0dXJlKVxuICByZXR1cm4gZXRoVXRpbC5lY3JlY292ZXIoaGFzaCwgc2lnUGFyYW1zLnYsIHNpZ1BhcmFtcy5yLCBzaWdQYXJhbXMucylcbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljS2V5Rm9yIChtc2dQYXJhbXMpIHtcbiAgY29uc3QgbWVzc2FnZSA9IGV0aFV0aWwudG9CdWZmZXIobXNnUGFyYW1zLmRhdGEpXG4gIGNvbnN0IG1zZ0hhc2ggPSBldGhVdGlsLmhhc2hQZXJzb25hbE1lc3NhZ2UobWVzc2FnZSlcbiAgcmV0dXJuIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgbXNnUGFyYW1zLnNpZylcbn1cblxuXG5mdW5jdGlvbiBwYWRXaXRoWmVyb2VzIChudW1iZXIsIGxlbmd0aCkge1xuICBsZXQgbXlTdHJpbmcgPSBgJHtudW1iZXJ9YFxuICB3aGlsZSAobXlTdHJpbmcubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgbXlTdHJpbmcgPSBgMCR7bXlTdHJpbmd9YFxuICB9XG4gIHJldHVybiBteVN0cmluZ1xufVxuXG4vLyBjb252ZXJ0cyBoZXggc3RyaW5ncyB0byB0aGUgVWludDhBcnJheSBmb3JtYXQgdXNlZCBieSBuYWNsXG5mdW5jdGlvbiBuYWNsX2RlY29kZUhleCAobXNnSGV4KSB7XG4gIGNvbnN0IG1zZ0Jhc2U2NCA9IChCdWZmZXIuZnJvbShtc2dIZXgsICdoZXgnKSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIHJldHVybiBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KG1zZ0Jhc2U2NClcbn1cblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2NhaycpLFxuICAgIGtlY2NhazIyNCA9IF9yZXF1aXJlLmtlY2NhazIyNCxcbiAgICBrZWNjYWszODQgPSBfcmVxdWlyZS5rZWNjYWszODQsXG4gICAgazI1NiA9IF9yZXF1aXJlLmtlY2NhazI1NixcbiAgICBrZWNjYWs1MTIgPSBfcmVxdWlyZS5rZWNjYWs1MTI7XG5cbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCcuL3NlY3AyNTZrMS1hZGFwdGVyJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgcmxwID0gcmVxdWlyZSgncmxwJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCByZXF1aXJlKCdldGhqcy11dGlsJykpO1xuXG4vKipcbiAqIHRoZSBtYXggaW50ZWdlciB0aGF0IHRoaXMgVk0gY2FuIGhhbmRsZSAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBNQVhfSU5URUdFUlxuICovXG5leHBvcnRzLk1BWF9JTlRFR0VSID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xuXG4vKipcbiAqIDJeMjU2IChhIGBgYEJOYGBgKVxuICogQHZhciB7Qk59IFRXT19QT1cyNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IEJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDE2KTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9OVUxMX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gJ2M1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xuZXhwb3J0cy5TSEEzX05VTExfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9OVUxMXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTDtcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfQVJSQVlfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3JztcbmV4cG9ydHMuU0hBM19STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5IChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUF9BUlJBWVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUF9BUlJBWSA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsICAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbmV4cG9ydHMuU0hBM19STFBfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfUkxQXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQO1xuXG4vKipcbiAqIFtgQk5gXShodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcylcbiAqIEB2YXIge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLkJOID0gQk47XG5cbi8qKlxuICogW2BybHBgXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHApXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5ybHAgPSBybHA7XG5cbi8qKlxuICogW2BzZWNwMjU2azFgXShodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlLylcbiAqIEB2YXIge09iamVjdH1cbiAqL1xuZXhwb3J0cy5zZWNwMjU2azEgPSBzZWNwMjU2azE7XG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwc1xuICogQG1ldGhvZCB6ZXJvc1xuICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVzICB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcykuZmlsbCgwKTtcbn07XG5cbi8qKlxuICAqIFJldHVybnMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIHplcm9BZGRyZXNzXG4gICogQHJldHVybiB7U3RyaW5nfVxuICAqL1xuZXhwb3J0cy56ZXJvQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFkZHJlc3NMZW5ndGggPSAyMDtcbiAgdmFyIHplcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvcyhhZGRyZXNzTGVuZ3RoKTtcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoemVyb0FkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBMZWZ0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQG1ldGhvZCBsc2V0TGVuZ3RoXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHBhcmFtIHtCb29sZWFufSBbcmlnaHQ9ZmFsc2VdIHdoZXRoZXIgdG8gc3RhcnQgcGFkZGluZyBmb3JtIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IGV4cG9ydHMuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICB2YXIgYnVmID0gZXhwb3J0cy56ZXJvcyhsZW5ndGgpO1xuICBtc2cgPSBleHBvcnRzLnRvQnVmZmVyKG1zZyk7XG4gIGlmIChyaWdodCkge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSaWdodCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBtc2cgdGhlIHZhbHVlIHRvIHBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG5cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAgb3IgYW4gYEFycmF5YFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfSBhXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfVxuICovXG5leHBvcnRzLnVucGFkID0gZXhwb3J0cy5zdHJpcFplcm9zID0gZnVuY3Rpb24gKGEpIHtcbiAgYSA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYSk7XG4gIHZhciBmaXJzdCA9IGFbMF07XG4gIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgZmlyc3QgPSBhWzBdO1xuICB9XG4gIHJldHVybiBhO1xufTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC4gQXMgaW5wdXQgaXQgc3VwcG9ydHMgYEJ1ZmZlcmAsIGBTdHJpbmdgLCBgTnVtYmVyYCwgbnVsbC91bmRlZmluZWQsIGBCTmAgYW5kIG90aGVyIG9iamVjdHMgd2l0aCBhIGB0b0FycmF5KClgIG1ldGhvZC5cbiAqIEBwYXJhbSB7Kn0gdiB0aGUgdmFsdWVcbiAqL1xuZXhwb3J0cy50b0J1ZmZlciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGV4cG9ydHMuaXNIZXhTdHJpbmcodikpIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMucGFkVG9FdmVuKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHYgPSBleHBvcnRzLmludFRvQnVmZmVyKHYpO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgfSBlbHNlIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICB2ID0gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIH0gZWxzZSBpZiAodi50b0FycmF5KSB7XG4gICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICB2ID0gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gbmV3IEJOKGV4cG9ydHMudG9CdWZmZXIoYnVmKSkudG9OdW1iZXIoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGJ1ZiA9IGV4cG9ydHMudG9CdWZmZXIoYnVmKTtcbiAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGEgYEJ1ZmZlcmAgYXMgYSBzaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBhIGBCTmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCdWZmZXJ9IG51bVxuICogQHJldHVybiB7Qk59XG4gKi9cbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIG5ldyBCTihudW0pLmZyb21Ud29zKDI1Nik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCTn0gbnVtXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRzPTI1Nl0gdGhlIEtlY2NhayB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICBpZiAoIWJpdHMpIGJpdHMgPSAyNTY7XG5cbiAgc3dpdGNoIChiaXRzKSB7XG4gICAgY2FzZSAyMjQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyMjQoYSk7XG4gICAgICB9XG4gICAgY2FzZSAyNTY6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrMjU2KGEpO1xuICAgICAgfVxuICAgIGNhc2UgMzg0OlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrMzg0KGEpO1xuICAgICAgfVxuICAgIGNhc2UgNTEyOlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrNTEyKGEpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxkIGFsZ29yaXRobToga2VjY2FrJyArIGJpdHMpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBpbnB1dCwgYWxpYXMgZm9yIGtlY2NhayhhLCAyNTYpXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMua2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKGEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIChLZWNjYWspIGhhc2ggb2YgdGhlIGlucHV0IFtPQlNPTEVURV1cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBTSEEtMyB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTMgPSBleHBvcnRzLmtlY2NhaztcblxuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtCb29sZWFufSBwYWRkZWQgd2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIHZhciBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKGEpLmRpZ2VzdCgpO1xuICBpZiAocGFkZGVkID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKGhhc2gsIDMyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIGhhc2ggb2YgdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucmxwaGFzaCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhybHAuZW5jb2RlKGEpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW5pdGl6ZT1mYWxzZV0gQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplKSB7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgIC8vIENvbnZlcnQgdG8gU0VDMSBmb3Igc2VjcDI1NmsxXG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICB9XG5cbiAgaWYgKCFzYW5pdGl6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwdWJsaWMga2V5LlxuICogQWNjZXB0cyBcIkV0aGVyZXVtIHB1YmxpYyBrZXlzXCIgYW5kIFNFQzEgZW5jb2RlZCBrZXlzLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHViVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSkge1xuICBwdWJLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YktleSk7XG4gIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YktleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIGFzc2VydChwdWJLZXkubGVuZ3RoID09PSA2NCk7XG4gIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocHViS2V5KS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlVG9QdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHByaXZhdGVLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHByaXZhdGVLZXkpO1xuICAvLyBza2lwIHRoZSB0eXBlIGZsYWcgYW5kIHVzZSB0aGUgWCwgWSBwb2ludHNcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gdGhlIEV0aGVyZXVtIGZvcm1hdC5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gIHB1YmxpY0tleSA9IGV4cG9ydHMudG9CdWZmZXIocHVibGljS2V5KTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDY0KSB7XG4gICAgcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG5cbi8qKlxuICogRUNEU0Egc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZWNzaWduID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHByaXZhdGVLZXkpIHtcbiAgdmFyIHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuXG4gIHZhciByZXQgPSB7fTtcbiAgcmV0LnIgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgcmV0LnMgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCk7XG4gIHJldC52ID0gc2lnLnJlY292ZXJ5ICsgMjc7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtlY2Nhay0yNTYgaGFzaCBvZiBgbWVzc2FnZWAsIHByZWZpeGVkIHdpdGggdGhlIGhlYWRlciB1c2VkIGJ5IHRoZSBgZXRoX3NpZ25gIFJQQyBjYWxsLlxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxuICogY2FsbCBmb3IgYSBnaXZlbiBgbWVzc2FnZWAsIG9yIGZlZCB0byBgZWNyZWNvdmVyYCBhbG9uZyB3aXRoIGEgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAqIHVzZWQgdG8gcHJvZHVjZSB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IGhhc2hcbiAqL1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgdmFyIHByZWZpeCA9IGV4cG9ydHMudG9CdWZmZXIoJ1xceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJyArIG1lc3NhZ2UubGVuZ3RoLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpO1xufTtcblxuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXNnSGFzaFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqL1xuZXhwb3J0cy5lY3JlY292ZXIgPSBmdW5jdGlvbiAobXNnSGFzaCwgdiwgciwgcykge1xuICB2YXIgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGgociwgMzIpLCBleHBvcnRzLnNldExlbmd0aChzLCAzMildLCA2NCk7XG4gIHZhciByZWNvdmVyeSA9IHYgLSAyNztcbiAgaWYgKHJlY292ZXJ5ICE9PSAwICYmIHJlY292ZXJ5ICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gIH1cbiAgdmFyIHNlbmRlclB1YktleSA9IHNlY3AyNTZrMS5yZWNvdmVyKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpO1xuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoc2VuZGVyUHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7U3RyaW5nfSBzaWdcbiAqL1xuZXhwb3J0cy50b1JwY1NpZyA9IGZ1bmN0aW9uICh2LCByLCBzKSB7XG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWNvdmVyeSBpZCcpO1xuICB9XG5cbiAgLy8gZ2V0aCAoYW5kIHRoZSBSUEMgZXRoX3NpZ24gbWV0aG9kKSB1c2VzIHRoZSA2NSBieXRlIGZvcm1hdCB1c2VkIGJ5IEJpdGNvaW5cbiAgLy8gRklYTUU6IHRoaXMgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUgLSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHMsIDMyKSwgZXhwb3J0cy50b0J1ZmZlcih2IC0gMjcpXSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBmb3JtYXQgb2YgdGhlIGBldGhfc2lnbmAgUlBDIG1ldGhvZCB0byBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICogTk9URTogYWxsIGJlY2F1c2Ugb2YgYSBidWcgaW4gZ2V0aDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZnJvbVJwY1NpZyA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgc2lnID0gZXhwb3J0cy50b0J1ZmZlcihzaWcpO1xuXG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmIChzaWcubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gIH1cblxuICB2YXIgdiA9IHNpZ1s2NF07XG4gIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICBpZiAodiA8IDI3KSB7XG4gICAgdiArPSAyNztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdjogdixcbiAgICByOiBzaWcuc2xpY2UoMCwgMzIpLFxuICAgIHM6IHNpZy5zbGljZSgzMiwgNjQpXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwcml2YXRlIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKHByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b29cbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuICgvXjB4WzAtOWEtZkEtRl17NDB9JC8udGVzdChhZGRyZXNzKVxuICApO1xufTtcblxuLyoqXG4gICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyBhIHplcm8gYWRkcmVzc1xuICAqIEBtZXRob2QgaXNaZXJvQWRkcmVzc1xuICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKi9cbmV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MoKTtcbiAgcmV0dXJuIHplcm9BZGRyZXNzID09PSBleHBvcnRzLmFkZEhleFByZWZpeChhZGRyZXNzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICBhZGRyZXNzID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeChhZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaGFzaCA9IGV4cG9ydHMua2VjY2FrKGFkZHJlc3MpLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIHJldCA9ICcweCc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnNlSW50KGhhc2hbaV0sIDE2KSA+PSA4KSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykgJiYgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gZnJvbSB0aGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbm9uY2UgdGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgZnJvbSA9IGV4cG9ydHMudG9CdWZmZXIoZnJvbSk7XG4gIG5vbmNlID0gbmV3IEJOKG5vbmNlKTtcblxuICBpZiAobm9uY2UuaXNaZXJvKCkpIHtcbiAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxuICAgIG5vbmNlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub25jZSA9IEJ1ZmZlci5mcm9tKG5vbmNlLnRvQXJyYXkoKSk7XG4gIH1cblxuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMucmxwaGFzaChbZnJvbSwgbm9uY2VdKS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN1cHBsaWVkIGFkZHJlc3MgYmVsb25ncyB0byBhIHByZWNvbXBpbGVkIGFjY291bnQgKEJ5emFudGl1bSlcbiAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ByZWNvbXBpbGVkID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgdmFyIGEgPSBleHBvcnRzLnVucGFkKGFkZHJlc3MpO1xuICByZXR1cm4gYS5sZW5ndGggPT09IDEgJiYgYVswXSA+PSAxICYmIGFbMF0gPD0gODtcbn07XG5cbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyIDogJzB4JyArIHN0cjtcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgRUNEU0Egc2lnbmF0dXJlXG4gKiBAbWV0aG9kIGlzVmFsaWRTaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2hvbWVzdGVhZD10cnVlXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkKSB7XG4gIHZhciBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBCTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgdmFyIFNFQ1AyNTZLMV9OID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgMTYpO1xuXG4gIGlmIChyLmxlbmd0aCAhPT0gMzIgfHwgcy5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHYgIT09IDI3ICYmIHYgIT09IDI4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgciA9IG5ldyBCTihyKTtcbiAgcyA9IG5ldyBCTihzKTtcblxuICBpZiAoci5pc1plcm8oKSB8fCByLmd0KFNFQ1AyNTZLMV9OKSB8fCBzLmlzWmVybygpIHx8IHMuZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGhvbWVzdGVhZCA9PT0gZmFsc2UgJiYgbmV3IEJOKHMpLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT05cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBiYVxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfG51bGx9XG4gKi9cbmV4cG9ydHMuYmFUb0pTT04gPSBmdW5jdGlvbiAoYmEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICByZXR1cm4gJzB4JyArIGJhLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSBlbHNlIGlmIChiYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXkucHVzaChleHBvcnRzLmJhVG9KU09OKGJhW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWZpbmVzIHByb3BlcnRpZXMgb24gYSBgT2JqZWN0YC4gSXQgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IHVuZGVybHlpbmcgZGF0YSBpcyBiaW5hcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiB0aGUgYE9iamVjdGAgdG8gZGVmaW5lIHByb3BlcnRpZXMgb25cbiAqIEBwYXJhbSB7QXJyYXl9IGZpZWxkcyBhbiBhcnJheSBmaWVsZHMgdG8gZGVmaW5lLiBGaWVsZHMgY2FuIGNvbnRhaW46XG4gKiAqIGBuYW1lYCAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0aWVzXG4gKiAqIGBsZW5ndGhgIC0gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZmllbGQgY2FuIGhhdmVcbiAqICogYGFsbG93TGVzc2AgLSBpZiB0aGUgZmllbGQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gKiAqIGBhbGxvd0VtcHR5YFxuICogQHBhcmFtIHsqfSBkYXRhIGRhdGEgdG8gYmUgdmFsaWRhdGVkIGFnYWluc3QgdGhlIGRlZmluaXRpb25zXG4gKi9cbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzZWxmLCBmaWVsZHMsIGRhdGEpIHtcbiAgc2VsZi5yYXcgPSBbXTtcbiAgc2VsZi5fZmllbGRzID0gW107XG5cbiAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxuICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgc2VsZi5fZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIG9ialtmaWVsZF0gPSAnMHgnICsgc2VsZltmaWVsZF0udG9TdHJpbmcoJ2hleCcpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5iYVRvSlNPTih0aGlzLnJhdyk7XG4gIH07XG5cbiAgc2VsZi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHJscC5lbmNvZGUoc2VsZi5yYXcpO1xuICB9O1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaSkge1xuICAgIHNlbGYuX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dGVyKHYpIHtcbiAgICAgIHYgPSBleHBvcnRzLnRvQnVmZmVyKHYpO1xuXG4gICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xuICAgICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICB2ID0gZXhwb3J0cy5zdHJpcFplcm9zKHYpO1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID49IHYubGVuZ3RoLCAnVGhlIGZpZWxkICcgKyBmaWVsZC5uYW1lICsgJyBtdXN0IG5vdCBoYXZlIG1vcmUgJyArIGZpZWxkLmxlbmd0aCArICcgYnl0ZXMnKTtcbiAgICAgIH0gZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID09PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBoYXZlIGJ5dGUgbGVuZ3RoIG9mICcgKyBmaWVsZC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnJhd1tpXSA9IHY7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGdldHRlcixcbiAgICAgIHNldDogc2V0dGVyXG4gICAgfSk7XG5cbiAgICBpZiAoZmllbGQuZGVmYXVsdCkge1xuICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIGFsaWFzXG4gICAgaWYgKGZpZWxkLmFsaWFzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgIGdldDogZ2V0dGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGlmIHRoZSBjb25zdHVjdG9yIGlzIHBhc3NlZCBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoZGF0YSksICdoZXgnKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBkYXRhID0gcmxwLmRlY29kZShkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gc2VsZi5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBmaWVsZHMgaW4gZGF0YScpO1xuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBpdGVtcyBhcmUgYnVmZmVyc1xuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9IGV4cG9ydHMudG9CdWZmZXIoZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLm5hbWUpICE9PSAtMSkgc2VsZltmaWVsZC5uYW1lXSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQuYWxpYXMpICE9PSAtMSkgc2VsZltmaWVsZC5hbGlhc10gPSBkYXRhW2ZpZWxkLmFsaWFzXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YScpO1xuICAgIH1cbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxJyk7XG5cbmZ1bmN0aW9uIGdldFNlY3AyNTZrMSAoKSB7IHJldHVybiByZXF1aXJlKCcuL3NlY3AyNTZrMS1saWIvaW5kZXgnKTsgfVxudmFyIGRlciA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWxpYi9kZXInKTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHJpdmF0ZUtleVxuICogQG1ldGhvZCBwcml2YXRlS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHByaXZhdGVLZXlWZXJpZnkgPSBmdW5jdGlvbiBwcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpIHtcbiAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHJpdmF0ZUtleSBsZW5ndGggaXMgbm90IDMyXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKTtcbn07XG5cbi8qKlxuICogRXhwb3J0IGEgcHJpdmF0ZUtleSBpbiBERVIgZm9ybWF0XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlFeHBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciBwcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gcHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBzZWNwMjU2azF2MyA9IGdldFNlY3AyNTZrMSgpO1xuICAvLyBwcml2YXRlS2V5RXhwb3J0IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHZhciBwdWJsaWNLZXkgPSBzZWNwMjU2azF2My5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIGNvbXByZXNzZWQpO1xuXG4gIHJldHVybiBkZXIucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpO1xufTtcblxuLyoqXG4gKiBJbXBvcnQgYSBwcml2YXRlS2V5IGluIERFUiBmb3JtYXRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleUltcG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuXG52YXIgcHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIHByaXZhdGVLZXlJbXBvcnQocHJpdmF0ZUtleSkge1xuICAvLyBwcml2YXRlS2V5SW1wb3J0IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIHByaXZhdGVLZXkgPSBkZXIucHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KTtcbiAgaWYgKHByaXZhdGVLZXkgIT09IG51bGwgJiYgcHJpdmF0ZUtleS5sZW5ndGggPT09IDMyICYmIHByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSkpIHtcbiAgICByZXR1cm4gcHJpdmF0ZUtleTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IGltcG9ydCBmcm9tIERFUiBmb3JtYXRcIik7XG59O1xuXG4vKipcbiAqIE5lZ2F0ZSBhIHByaXZhdGVLZXkgYnkgc3VidHJhY3RpbmcgaXQgZnJvbSB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludFxuICogQG1ldGhvZCBwcml2YXRlS2V5TmVnYXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleU5lZ2F0ZSA9IGZ1bmN0aW9uIHByaXZhdGVLZXlOZWdhdGUocHJpdmF0ZUtleSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnByaXZhdGVLZXlOZWdhdGUoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGludmVyc2Ugb2YgYSBwcml2YXRlS2V5IChtb2R1bG8gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZSdzIGJhc2UgcG9pbnQpLlxuICogQG1ldGhvZCBwcml2YXRlS2V5TW9kSW52ZXJzZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gcHJpdmF0ZUtleU1vZEludmVyc2UocHJpdmF0ZUtleSkge1xuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG4gIHZhciBzZWNwMjU2azF2MyA9IGdldFNlY3AyNTZrMSgpO1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxdjMucHJpdmF0ZUtleU1vZEludmVyc2UoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHJpdmF0ZUtleSBieSBhZGRpbmcgdHdlYWsgdG8gaXQuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gcHJpdmF0ZUtleVR3ZWFrQWRkKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgdHdlYWspKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleVR3ZWFrTXVsID0gZnVuY3Rpb24gcHJpdmF0ZUtleVR3ZWFrTXVsKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBwdWJsaWMga2V5IGZvciBhIHByaXZhdGVLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNyZWF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5Q3JlYXRlID0gZnVuY3Rpb24gcHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwdWJsaWNLZXkgdG8gY29tcHJlc3NlZCBvciB1bmNvbXByZXNzZWQgZm9ybS5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29udmVydFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gcHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBwdWJsaWNLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleVZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHB1YmxpY0tleVZlcmlmeSA9IGZ1bmN0aW9uIHB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpIHtcbiAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHVibGljS2V5IGxlbmd0aCBpcyBub3QgMzMgb3IgNjVcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBhZGRpbmcgdHdlYWsgdGltZXMgdGhlIGdlbmVyYXRvciB0byBpdC5cbiAqIEBtZXRob2QgcHVibGljS2V5VHdlYWtBZGRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIHB1YmxpY0tleVR3ZWFrQWRkKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBtdWx0aXBseWluZyBpdCBieSBhIHR3ZWFrIHZhbHVlXG4gKiBAbWV0aG9kIHB1YmxpY0tleVR3ZWFrTXVsXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiBwdWJsaWNLZXlUd2Vha011bChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5VHdlYWtNdWwoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhayksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQWRkIGEgZ2l2ZW4gcHVibGljS2V5cyB0b2dldGhlci5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29tYmluZVxuICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBwdWJsaWNLZXlzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleUNvbWJpbmUgPSBmdW5jdGlvbiBwdWJsaWNLZXlDb21iaW5lKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgcHVibGljS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICBrZXlzLnB1c2goVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xuICB9KTtcblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbWJpbmUoa2V5cywgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmF0dXJlIHRvIGEgbm9ybWFsaXplZCBsb3dlci1TIGZvcm0uXG4gKiBAbWV0aG9kIHNpZ25hdHVyZU5vcm1hbGl6ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gc2lnbmF0dXJlTm9ybWFsaXplKHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYW4gRUNEU0Egc2lnbmF0dXJlIGluIERFUiBmb3JtYXQuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlRXhwb3J0ID0gZnVuY3Rpb24gc2lnbmF0dXJlRXhwb3J0KHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gc2lnbmF0dXJlSW1wb3J0KHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKG5vdCBmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRMYXhcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIHNpZ25hdHVyZUltcG9ydExheChzaWduYXR1cmUpIHtcbiAgLy8gc2lnbmF0dXJlSW1wb3J0TGF4IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIC8vIGVuc3VyZSB0aGF0IHNpZ25hdHVyZSBpcyBncmVhdGVyIHRoYW4gMFxuICBpZiAoc2lnbmF0dXJlLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaWduYXR1cmUgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuICB2YXIgc2VjcDI1NmsxdjMgPSBnZXRTZWNwMjU2azEoKTtcblxuICB2YXIgc2lnT2JqID0gZGVyLnNpZ25hdHVyZUltcG9ydExheChzaWduYXR1cmUpO1xuICBpZiAoc2lnT2JqID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgcGFyc2UgREVSIHNpZ25hdHVyZVwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azF2My5zaWduYXR1cmVJbXBvcnQoc2lnT2JqKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVDRFNBIHNpZ25hdHVyZS4gQWx3YXlzIHJldHVybiBsb3ctUyBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHNpZ25cbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIHNob3VsZCBiZSBhbiBPYmplY3QnKTtcbiAgfVxuXG4gIHZhciBzaWduT3B0aW9ucyA9IHZvaWQgMDtcblxuICBpZiAob3B0aW9ucykge1xuICAgIHNpZ25PcHRpb25zID0ge307XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmRhdGEgc2hvdWxkIGJlIGEgQnVmZmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgLy8gdmFsaWRhdGUgb3B0aW9uLmRhdGEgbGVuZ3RoXG4gICAgICBpZiAob3B0aW9ucy5kYXRhLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29wdGlvbnMuZGF0YSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgICAgfVxuXG4gICAgICBzaWduT3B0aW9ucy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkob3B0aW9ucy5kYXRhKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ub25jZWZuID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm5vbmNlZm4gc2hvdWxkIGJlIGEgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ub25jZWZuKSB7XG4gICAgICAvLyAgY29udmVydCBvcHRpb24ubm9uY2VmbiBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICAgIHNpZ25PcHRpb25zLm5vbmNlZm4gPSBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgYWxnbywgZGF0YSwgYXR0ZW1wdCkge1xuICAgICAgICB2YXIgYnVmZmVyQWxnbyA9IGFsZ28gIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGFsZ28pIDogbnVsbDtcbiAgICAgICAgdmFyIGJ1ZmZlckRhdGEgPSBkYXRhICE9IG51bGwgPyBCdWZmZXIuZnJvbShkYXRhKSA6IG51bGw7XG5cbiAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKCcnKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5ub25jZWZuKSB7XG4gICAgICAgICAgYnVmZmVyID0gb3B0aW9ucy5ub25jZWZuKEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLCBCdWZmZXIuZnJvbShwcml2YXRlS2V5KSwgYnVmZmVyQWxnbywgYnVmZmVyRGF0YSwgYXR0ZW1wdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ1ZmZlcik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBzaWcgPSBzZWNwMjU2azEuZWNkc2FTaWduKFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBzaWduT3B0aW9ucyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKHNpZy5zaWduYXR1cmUpLFxuICAgIHJlY292ZXJ5OiBzaWcucmVjaWRcbiAgfTtcbn07XG5cbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHNpZ25hdHVyZS5cbiAqIEBtZXRob2QgdmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAvLyBub3RlOiBzZWNwMjU2azEgdjQgdmVyaWZ5IG1ldGhvZCBoYXMgYSBkaWZmZXJlbnQgYXJndW1lbnQgb3JkZXJcbiAgcmV0dXJuIHNlY3AyNTZrMS5lY2RzYVZlcmlmeShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBwdWJsaWNLZXkpO1xufTtcblxuLyoqXG4gKiBSZWNvdmVyIGFuIEVDRFNBIHB1YmxpYyBrZXkgZnJvbSBhIHNpZ25hdHVyZS5cbiAqIEBtZXRob2QgcmVjb3ZlclxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7TnVtYmVyfSByZWNpZFxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciByZWNvdmVyID0gZnVuY3Rpb24gcmVjb3ZlcihtZXNzYWdlLCBzaWduYXR1cmUsIHJlY2lkLCBjb21wcmVzc2VkKSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2NCByZWNvdmVyIG1ldGhvZCBoYXMgYSBkaWZmZXJlbnQgYXJndW1lbnQgb3JkZXJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5lY2RzYVJlY292ZXIoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSksIHJlY2lkLCBVaW50OEFycmF5LmZyb20obWVzc2FnZSksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBhbiBFQyBEaWZmaWUtSGVsbG1hbiBzZWNyZXQgYW5kIGFwcGxpZWQgc2hhMjU2IHRvIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAqIEBtZXRob2QgZWNkaFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIGVjZGggPSBmdW5jdGlvbiBlY2RoKHB1YmxpY0tleSwgcHJpdmF0ZUtleSkge1xuICAvLyBub3RlOiBzZWNwMjU2azEgdjMgZG9lc24ndCBhbGxvdyBvcHRpb25hbCBwYXJhbWV0ZXJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5lY2RoKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHt9KSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgYW4gRUMgRGlmZmllLUhlbGxtYW4gc2VjcmV0IGFuZCByZXR1cm4gcHVibGljIGtleSBhcyByZXN1bHRcbiAqIEBtZXRob2QgZWNkaFVuc2FmZVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIGVjZGhVbnNhZmUocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIC8vIGVjZGhVbnNhZmUgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgLy8gZW5zdXJlIHZhbGlkIHB1YmxpY0tleSBsZW5ndGhcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3B1YmxpYyBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSB2YWxpZCBwcml2YXRlS2V5IGxlbmd0aFxuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cbiAgdmFyIHNlY3AyNTZrMXYzID0gZ2V0U2VjcDI1NmsxKCk7XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMXYzLmVjZGhVbnNhZmUoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHByaXZhdGVLZXlWZXJpZnk6IHByaXZhdGVLZXlWZXJpZnksXG4gIHByaXZhdGVLZXlFeHBvcnQ6IHByaXZhdGVLZXlFeHBvcnQsXG4gIHByaXZhdGVLZXlJbXBvcnQ6IHByaXZhdGVLZXlJbXBvcnQsXG4gIHByaXZhdGVLZXlOZWdhdGU6IHByaXZhdGVLZXlOZWdhdGUsXG4gIHByaXZhdGVLZXlNb2RJbnZlcnNlOiBwcml2YXRlS2V5TW9kSW52ZXJzZSxcbiAgcHJpdmF0ZUtleVR3ZWFrQWRkOiBwcml2YXRlS2V5VHdlYWtBZGQsXG4gIHByaXZhdGVLZXlUd2Vha011bDogcHJpdmF0ZUtleVR3ZWFrTXVsLFxuXG4gIHB1YmxpY0tleUNyZWF0ZTogcHVibGljS2V5Q3JlYXRlLFxuICBwdWJsaWNLZXlDb252ZXJ0OiBwdWJsaWNLZXlDb252ZXJ0LFxuICBwdWJsaWNLZXlWZXJpZnk6IHB1YmxpY0tleVZlcmlmeSxcbiAgcHVibGljS2V5VHdlYWtBZGQ6IHB1YmxpY0tleVR3ZWFrQWRkLFxuICBwdWJsaWNLZXlUd2Vha011bDogcHVibGljS2V5VHdlYWtNdWwsXG4gIHB1YmxpY0tleUNvbWJpbmU6IHB1YmxpY0tleUNvbWJpbmUsXG5cbiAgc2lnbmF0dXJlTm9ybWFsaXplOiBzaWduYXR1cmVOb3JtYWxpemUsXG4gIHNpZ25hdHVyZUV4cG9ydDogc2lnbmF0dXJlRXhwb3J0LFxuICBzaWduYXR1cmVJbXBvcnQ6IHNpZ25hdHVyZUltcG9ydCxcbiAgc2lnbmF0dXJlSW1wb3J0TGF4OiBzaWduYXR1cmVJbXBvcnRMYXgsXG5cbiAgc2lnbjogc2lnbixcbiAgdmVyaWZ5OiB2ZXJpZnksXG4gIHJlY292ZXI6IHJlY292ZXIsXG5cbiAgZWNkaDogZWNkaCxcbiAgZWNkaFVuc2FmZTogZWNkaFVuc2FmZVxufTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGZyb20gc2VjcDI1NmsxIHYzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxudmFyIEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuLy8gYmVnaW5cbjB4MzAsIDB4ODEsIDB4ZDMsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDQsIDB4MjAsXG4vLyBwcml2YXRlIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbi8vIG1pZGRsZVxuMHhhMCwgMHg4MSwgMHg4NSwgMHgzMCwgMHg4MSwgMHg4MiwgMHgwMiwgMHgwMSwgMHgwMSwgMHgzMCwgMHgyYywgMHgwNiwgMHgwNywgMHgyYSwgMHg4NiwgMHg0OCwgMHhjZSwgMHgzZCwgMHgwMSwgMHgwMSwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhmZiwgMHhmZiwgMHhmYywgMHgyZiwgMHgzMCwgMHgwNiwgMHgwNCwgMHgwMSwgMHgwMCwgMHgwNCwgMHgwMSwgMHgwNywgMHgwNCwgMHgyMSwgMHgwMiwgMHg3OSwgMHhiZSwgMHg2NiwgMHg3ZSwgMHhmOSwgMHhkYywgMHhiYiwgMHhhYywgMHg1NSwgMHhhMCwgMHg2MiwgMHg5NSwgMHhjZSwgMHg4NywgMHgwYiwgMHgwNywgMHgwMiwgMHg5YiwgMHhmYywgMHhkYiwgMHgyZCwgMHhjZSwgMHgyOCwgMHhkOSwgMHg1OSwgMHhmMiwgMHg4MSwgMHg1YiwgMHgxNiwgMHhmOCwgMHgxNywgMHg5OCwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhiYSwgMHhhZSwgMHhkYywgMHhlNiwgMHhhZiwgMHg0OCwgMHhhMCwgMHgzYiwgMHhiZiwgMHhkMiwgMHg1ZSwgMHg4YywgMHhkMCwgMHgzNiwgMHg0MSwgMHg0MSwgMHgwMiwgMHgwMSwgMHgwMSwgMHhhMSwgMHgyNCwgMHgwMywgMHgyMiwgMHgwMCxcbi8vIHB1YmxpYyBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdKTtcblxudmFyIEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQgPSBCdWZmZXIuZnJvbShbXG4vLyBiZWdpblxuMHgzMCwgMHg4MiwgMHgwMSwgMHgxMywgMHgwMiwgMHgwMSwgMHgwMSwgMHgwNCwgMHgyMCxcbi8vIHByaXZhdGUga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuLy8gbWlkZGxlXG4weGEwLCAweDgxLCAweGE1LCAweDMwLCAweDgxLCAweGEyLCAweDAyLCAweDAxLCAweDAxLCAweDMwLCAweDJjLCAweDA2LCAweDA3LCAweDJhLCAweDg2LCAweDQ4LCAweGNlLCAweDNkLCAweDAxLCAweDAxLCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZlLCAweGZmLCAweGZmLCAweGZjLCAweDJmLCAweDMwLCAweDA2LCAweDA0LCAweDAxLCAweDAwLCAweDA0LCAweDAxLCAweDA3LCAweDA0LCAweDQxLCAweDA0LCAweDc5LCAweGJlLCAweDY2LCAweDdlLCAweGY5LCAweGRjLCAweGJiLCAweGFjLCAweDU1LCAweGEwLCAweDYyLCAweDk1LCAweGNlLCAweDg3LCAweDBiLCAweDA3LCAweDAyLCAweDliLCAweGZjLCAweGRiLCAweDJkLCAweGNlLCAweDI4LCAweGQ5LCAweDU5LCAweGYyLCAweDgxLCAweDViLCAweDE2LCAweGY4LCAweDE3LCAweDk4LCAweDQ4LCAweDNhLCAweGRhLCAweDc3LCAweDI2LCAweGEzLCAweGM0LCAweDY1LCAweDVkLCAweGE0LCAweGZiLCAweGZjLCAweDBlLCAweDExLCAweDA4LCAweGE4LCAweGZkLCAweDE3LCAweGI0LCAweDQ4LCAweGE2LCAweDg1LCAweDU0LCAweDE5LCAweDljLCAweDQ3LCAweGQwLCAweDhmLCAweGZiLCAweDEwLCAweGQ0LCAweGI4LCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZlLCAweGJhLCAweGFlLCAweGRjLCAweGU2LCAweGFmLCAweDQ4LCAweGEwLCAweDNiLCAweGJmLCAweGQyLCAweDVlLCAweDhjLCAweGQwLCAweDM2LCAweDQxLCAweDQxLCAweDAyLCAweDAxLCAweDAxLCAweGExLCAweDQ0LCAweDAzLCAweDQyLCAweDAwLFxuLy8gcHVibGljIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF0pO1xuXG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgcHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciByZXN1bHQgPSBCdWZmZXIuZnJvbShjb21wcmVzc2VkID8gRUNfUFJJVktFWV9FWFBPUlRfREVSX0NPTVBSRVNTRUQgOiBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEKTtcbiAgcHJpdmF0ZUtleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDggOiA5KTtcbiAgcHVibGljS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gMTgxIDogMjE0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBsZW5ndGggPSBwcml2YXRlS2V5Lmxlbmd0aDtcblxuICAvLyBzZXF1ZW5jZSBoZWFkZXJcbiAgdmFyIGluZGV4ID0gMDtcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgzMCkgcmV0dXJuIG51bGw7XG4gIGluZGV4ICs9IDE7XG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGNvbnN0cnVjdG9yXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgIShwcml2YXRlS2V5W2luZGV4XSAmIDB4ODApKSByZXR1cm4gbnVsbDtcblxuICB2YXIgbGVuYiA9IHByaXZhdGVLZXlbaW5kZXhdICYgMHg3ZjtcbiAgaW5kZXggKz0gMTtcbiAgaWYgKGxlbmIgPCAxIHx8IGxlbmIgPiAyKSByZXR1cm4gbnVsbDtcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuYikgcmV0dXJuIG51bGw7XG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoXG4gIHZhciBsZW4gPSBwcml2YXRlS2V5W2luZGV4ICsgbGVuYiAtIDFdIHwgKGxlbmIgPiAxID8gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAyXSA8PCA4IDogMCk7XG4gIGluZGV4ICs9IGxlbmI7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIGxlbikgcmV0dXJuIG51bGw7XG5cbiAgLy8gc2VxdWVuY2UgZWxlbWVudCAwOiB2ZXJzaW9uIG51bWJlciAoPTEpXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDMgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MDIgfHwgcHJpdmF0ZUtleVtpbmRleCArIDFdICE9PSAweDAxIHx8IHByaXZhdGVLZXlbaW5kZXggKyAyXSAhPT0gMHgwMSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGluZGV4ICs9IDM7XG5cbiAgLy8gc2VxdWVuY2UgZWxlbWVudCAxOiBvY3RldCBzdHJpbmcsIHVwIHRvIDMyIGJ5dGVzXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDIgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MDQgfHwgcHJpdmF0ZUtleVtpbmRleCArIDFdID4gMHgyMCB8fCBsZW5ndGggPCBpbmRleCArIDIgKyBwcml2YXRlS2V5W2luZGV4ICsgMV0pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwcml2YXRlS2V5LnNsaWNlKGluZGV4ICsgMiwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKTtcbn07XG5cbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0TGF4ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICB2YXIgciA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG4gIHZhciBzID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcblxuICB2YXIgbGVuZ3RoID0gc2lnbmF0dXJlLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZVxuICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDMwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBzZXF1ZW5jZSBsZW5ndGggYnl0ZVxuICB2YXIgbGVuYnl0ZSA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgaWYgKGxlbmJ5dGUgJiAweDgwKSB7XG4gICAgaW5kZXggKz0gbGVuYnl0ZSAtIDB4ODA7XG4gICAgaWYgKGluZGV4ID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3IgclxuICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsZW5ndGggZm9yIHJcbiAgdmFyIHJsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChybGVuICYgMHg4MCkge1xuICAgIGxlbmJ5dGUgPSBybGVuIC0gMHg4MDtcbiAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge31cbiAgICBmb3IgKHJsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7XG4gICAgICBybGVuID0gKHJsZW4gPDwgOCkgKyBzaWduYXR1cmVbaW5kZXhdO1xuICAgIH1cbiAgfVxuICBpZiAocmxlbiA+IGxlbmd0aCAtIGluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJpbmRleCA9IGluZGV4O1xuICBpbmRleCArPSBybGVuO1xuXG4gIC8vIHNlcXVlbmNlIHRhZyBieXRlIGZvciBzXG4gIGlmIChzaWduYXR1cmVbaW5kZXgrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGxlbmd0aCBmb3Igc1xuICB2YXIgc2xlbiA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgaWYgKHNsZW4gJiAweDgwKSB7XG4gICAgbGVuYnl0ZSA9IHNsZW4gLSAweDgwO1xuICAgIGlmIChpbmRleCArIGxlbmJ5dGUgPiBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnbmF0dXJlW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7fVxuICAgIGZvciAoc2xlbiA9IDA7IGxlbmJ5dGUgPiAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHtcbiAgICAgIHNsZW4gPSAoc2xlbiA8PCA4KSArIHNpZ25hdHVyZVtpbmRleF07XG4gICAgfVxuICB9XG4gIGlmIChzbGVuID4gbGVuZ3RoIC0gaW5kZXgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc2luZGV4ID0gaW5kZXg7XG4gIGluZGV4ICs9IHNsZW47XG5cbiAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gclxuICBmb3IgKDsgcmxlbiA+IDAgJiYgc2lnbmF0dXJlW3JpbmRleF0gPT09IDB4MDA7IHJsZW4gLT0gMSwgcmluZGV4ICs9IDEpIHt9XG4gIC8vIGNvcHkgciB2YWx1ZVxuICBpZiAocmxlbiA+IDMyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHJ2YWx1ZSA9IHNpZ25hdHVyZS5zbGljZShyaW5kZXgsIHJpbmRleCArIHJsZW4pO1xuICBydmFsdWUuY29weShyLCAzMiAtIHJ2YWx1ZS5sZW5ndGgpO1xuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHNcbiAgZm9yICg7IHNsZW4gPiAwICYmIHNpZ25hdHVyZVtzaW5kZXhdID09PSAweDAwOyBzbGVuIC09IDEsIHNpbmRleCArPSAxKSB7fVxuICAvLyBjb3B5IHMgdmFsdWVcbiAgaWYgKHNsZW4gPiAzMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBzdmFsdWUgPSBzaWduYXR1cmUuc2xpY2Uoc2luZGV4LCBzaW5kZXggKyBzbGVuKTtcbiAgc3ZhbHVlLmNvcHkocywgMzIgLSBzdmFsdWUubGVuZ3RoKTtcblxuICByZXR1cm4geyByOiByLCBzOiBzIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGlzIGltcG9ydGVkIGZyb20gc2VjcDI1NmsxIHYzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcblxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWM7XG5cbnZhciBlYyA9IG5ldyBFQygnc2VjcDI1NmsxJyk7XG52YXIgZWNwYXJhbXMgPSBlYy5jdXJ2ZTtcblxuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIGQgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gIGlmIChkLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY291bGRuXFwndCBleHBvcnQgdG8gREVSIGZvcm1hdCcpO1xuICB9XG5cbiAgdmFyIHBvaW50ID0gZWMuZy5tdWwoZCk7XG4gIHJldHVybiB0b1B1YmxpY0tleShwb2ludC5nZXRYKCksIHBvaW50LmdldFkoKSwgY29tcHJlc3NlZCk7XG59O1xuXG5leHBvcnRzLnByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICBpZiAoYm4udWNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGJuLmlzWmVybygpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlIGtleSByYW5nZSBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gYm4uaW52bShlY3BhcmFtcy5uKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKTtcbn07XG5cbmV4cG9ydHMuc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gKHNpZ09iaikge1xuICB2YXIgciA9IG5ldyBCTihzaWdPYmoucik7XG4gIGlmIChyLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgIHIgPSBuZXcgQk4oMCk7XG4gIH1cblxuICB2YXIgcyA9IG5ldyBCTihzaWdPYmoucyk7XG4gIGlmIChzLnVjbXAoZWNwYXJhbXMubikgPj0gMCkge1xuICAgIHMgPSBuZXcgQk4oMCk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbci50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKSwgcy50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKV0pO1xufTtcblxuZXhwb3J0cy5lY2RoVW5zYWZlID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcG9pbnQgPSBlYy5rZXlGcm9tUHVibGljKHB1YmxpY0tleSk7XG5cbiAgdmFyIHNjYWxhciA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgaWYgKHNjYWxhci51Y21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2NhbGFyLmlzWmVybygpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzY2FsYXIgd2FzIGludmFsaWQgKHplcm8gb3Igb3ZlcmZsb3cpJyk7XG4gIH1cblxuICB2YXIgc2hhcmVkID0gcG9pbnQucHViLm11bChzY2FsYXIpO1xuICByZXR1cm4gdG9QdWJsaWNLZXkoc2hhcmVkLmdldFgoKSwgc2hhcmVkLmdldFkoKSwgY29tcHJlc3NlZCk7XG59O1xuXG52YXIgdG9QdWJsaWNLZXkgPSBmdW5jdGlvbiB0b1B1YmxpY0tleSh4LCB5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBwdWJsaWNLZXkgPSB2b2lkIDA7XG5cbiAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICBwdWJsaWNLZXkgPSBCdWZmZXIuYWxsb2MoMzMpO1xuICAgIHB1YmxpY0tleVswXSA9IHkuaXNPZGQoKSA/IDB4MDMgOiAweDAyO1xuICAgIHgudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDEpO1xuICB9IGVsc2Uge1xuICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5hbGxvYyg2NSk7XG4gICAgcHVibGljS2V5WzBdID0gMHgwNDtcbiAgICB4LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAxKTtcbiAgICB5LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAzMyk7XG4gIH1cblxuICByZXR1cm4gcHVibGljS2V5O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0hleFByZWZpeGVkID0gcmVxdWlyZSgnaXMtaGV4LXByZWZpeGVkJyk7XG52YXIgc3RyaXBIZXhQcmVmaXggPSByZXF1aXJlKCdzdHJpcC1oZXgtcHJlZml4Jyk7XG5cbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gIHZhciBhID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgcGFkZGluZyB0byBldmVuLCB2YWx1ZSBtdXN0IGJlIHN0cmluZywgaXMgY3VycmVudGx5ICcgKyB0eXBlb2YgYSArICcsIHdoaWxlIHBhZFRvRXZlbi4nKTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAlIDIpIHtcbiAgICBhID0gJzAnICsgYTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICB2YXIgaGV4ID0gaS50b1N0cmluZygxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpKSB7XG4gIHZhciBoZXggPSBpbnRUb0hleChpKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgZ2V0dGluZyBiaW5hcnkgc2l6ZSwgbWV0aG9kIGdldEJpbmFyeVNpemUgcmVxdWlyZXMgaW5wdXQgXFwnc3RyXFwnIHRvIGJlIHR5cGUgU3RyaW5nLCBnb3QgXFwnJyArIHR5cGVvZiBzdHIgKyAnXFwnLicpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBzdXBlcnNldFxuICogQHBhcmFtIHthcnJheX0gc3Vic2V0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3VwZXJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdXBlcnNldCArICdcXCcnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdWJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdWJzZXQgKyAnXFwnJyk7XG4gIH1cblxuICByZXR1cm4gc3Vic2V0W0Jvb2xlYW4oc29tZSkgJiYgJ3NvbWUnIHx8ICdldmVyeSddKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9VdGY4KGhleCkge1xuICB2YXIgYnVmZmVyVmFsdWUgPSBuZXcgQnVmZmVyKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChoZXgpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpKSwgJ2hleCcpO1xuXG4gIHJldHVybiBidWZmZXJWYWx1ZS50b1N0cmluZygndXRmOCcpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gIHZhciBzdHIgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaSA9IDAsXG4gICAgICBsID0gaGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgaSA9IDI7XG4gIH1cblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbVV0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBzdHIgPSBuZXcgQnVmZmVyKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuXG4gIHJldHVybiAnMHgnICsgcGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIGhleCA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICB9XG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuICpcbiAqIEBtZXRob2QgZ2V0S2V5cyBnZXQgc3BlY2lmaWMga2V5IGZyb20gaW5uZXIgb2JqZWN0IGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dFbXB0eVxuICogQHJldHVybnMge0FycmF5fSBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgQXJyYXkgYXMgXFwncGFyYW1zXFwnIGlucHV0LCBnb3QgXFwnJyArIHR5cGVvZiBwYXJhbXMgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgU3RyaW5nIGZvciBpbnB1dCBcXCdrZXlcXCcgZ290IFxcJycgKyB0eXBlb2Yga2V5ICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFiaScpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgY2hlY2sgaWYgc3RyaW5nIGlzIGhleCBzdHJpbmcgb2Ygc3BlY2lmaWMgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJyYXlDb250YWluc0FycmF5OiBhcnJheUNvbnRhaW5zQXJyYXksXG4gIGludFRvQnVmZmVyOiBpbnRUb0J1ZmZlcixcbiAgZ2V0QmluYXJ5U2l6ZTogZ2V0QmluYXJ5U2l6ZSxcbiAgaXNIZXhQcmVmaXhlZDogaXNIZXhQcmVmaXhlZCxcbiAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICBwYWRUb0V2ZW46IHBhZFRvRXZlbixcbiAgaW50VG9IZXg6IGludFRvSGV4LFxuICBmcm9tQXNjaWk6IGZyb21Bc2NpaSxcbiAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICB0b0FzY2lpOiB0b0FzY2lpLFxuICB0b1V0Zjg6IHRvVXRmOCxcbiAgZ2V0S2V5czogZ2V0S2V5cyxcbiAgaXNIZXhTdHJpbmc6IGlzSGV4U3RyaW5nXG59OyIsInZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbnZhciBjcyA9IHJlcXVpcmUoJ2NvaW5zdHJpbmcnKVxudmFyIHNlY3AyNTZrMSA9IHJlcXVpcmUoJ3NlY3AyNTZrMScpXG5cbnZhciBNQVNURVJfU0VDUkVUID0gQnVmZmVyLmZyb20oJ0JpdGNvaW4gc2VlZCcsICd1dGY4JylcbnZhciBIQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwXG52YXIgTEVOID0gNzhcblxuLy8gQml0Y29pbiBoYXJkY29kZWQgYnkgZGVmYXVsdCwgY2FuIHVzZSBwYWNrYWdlIGBjb2luaW5mb2AgZm9yIG90aGVyc1xudmFyIEJJVENPSU5fVkVSU0lPTlMgPSB7cHJpdmF0ZTogMHgwNDg4QURFNCwgcHVibGljOiAweDA0ODhCMjFFfVxuXG5mdW5jdGlvbiBIREtleSAodmVyc2lvbnMpIHtcbiAgdGhpcy52ZXJzaW9ucyA9IHZlcnNpb25zIHx8IEJJVENPSU5fVkVSU0lPTlNcbiAgdGhpcy5kZXB0aCA9IDBcbiAgdGhpcy5pbmRleCA9IDBcbiAgdGhpcy5fcHJpdmF0ZUtleSA9IG51bGxcbiAgdGhpcy5fcHVibGljS2V5ID0gbnVsbFxuICB0aGlzLmNoYWluQ29kZSA9IG51bGxcbiAgdGhpcy5fZmluZ2VycHJpbnQgPSAwXG4gIHRoaXMucGFyZW50RmluZ2VycHJpbnQgPSAwXG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdmaW5nZXJwcmludCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9maW5nZXJwcmludCB9IH0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAnaWRlbnRpZmllcicsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9pZGVudGlmaWVyIH0gfSlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwdWJLZXlIYXNoJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaWRlbnRpZmllciB9IH0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwcml2YXRlS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZUtleVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzc2VydC5lcXVhbCh2YWx1ZS5sZW5ndGgsIDMyLCAnUHJpdmF0ZSBrZXkgbXVzdCBiZSAzMiBieXRlcy4nKVxuICAgIGFzc2VydChzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeSh2YWx1ZSkgPT09IHRydWUsICdJbnZhbGlkIHByaXZhdGUga2V5JylcblxuICAgIHRoaXMuX3ByaXZhdGVLZXkgPSB2YWx1ZVxuICAgIHRoaXMuX3B1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUodmFsdWUsIHRydWUpXG4gICAgdGhpcy5faWRlbnRpZmllciA9IGhhc2gxNjAodGhpcy5wdWJsaWNLZXkpXG4gICAgdGhpcy5fZmluZ2VycHJpbnQgPSB0aGlzLl9pZGVudGlmaWVyLnNsaWNlKDAsIDQpLnJlYWRVSW50MzJCRSgwKVxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHVibGljS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVibGljS2V5XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgYXNzZXJ0KHZhbHVlLmxlbmd0aCA9PT0gMzMgfHwgdmFsdWUubGVuZ3RoID09PSA2NSwgJ1B1YmxpYyBrZXkgbXVzdCBiZSAzMyBvciA2NSBieXRlcy4nKVxuICAgIGFzc2VydChzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KHZhbHVlKSA9PT0gdHJ1ZSwgJ0ludmFsaWQgcHVibGljIGtleScpXG5cbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydCh2YWx1ZSwgdHJ1ZSkgLy8gZm9yY2UgY29tcHJlc3NlZCBwb2ludFxuICAgIHRoaXMuX2lkZW50aWZpZXIgPSBoYXNoMTYwKHRoaXMucHVibGljS2V5KVxuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gdGhpcy5faWRlbnRpZmllci5zbGljZSgwLCA0KS5yZWFkVUludDMyQkUoMClcbiAgICB0aGlzLl9wcml2YXRlS2V5ID0gbnVsbFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHJpdmF0ZUV4dGVuZGVkS2V5Jywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcHJpdmF0ZUtleSkgcmV0dXJuIGNzLmVuY29kZShzZXJpYWxpemUodGhpcywgdGhpcy52ZXJzaW9ucy5wcml2YXRlLCBCdWZmZXIuY29uY2F0KFtCdWZmZXIuYWxsb2MoMSwgMCksIHRoaXMucHJpdmF0ZUtleV0pKSlcbiAgICBlbHNlIHJldHVybiBudWxsXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShIREtleS5wcm90b3R5cGUsICdwdWJsaWNFeHRlbmRlZEtleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNzLmVuY29kZShzZXJpYWxpemUodGhpcywgdGhpcy52ZXJzaW9ucy5wdWJsaWMsIHRoaXMucHVibGljS2V5KSlcbiAgfVxufSlcblxuSERLZXkucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmIChwYXRoID09PSAnbScgfHwgcGF0aCA9PT0gJ00nIHx8IHBhdGggPT09IFwibSdcIiB8fCBwYXRoID09PSBcIk0nXCIpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIGVudHJpZXMgPSBwYXRoLnNwbGl0KCcvJylcbiAgdmFyIGhka2V5ID0gdGhpc1xuICBlbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHtcbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgYXNzZXJ0KGMsICdtJywgJ0ludmFsaWQgcGF0aCcpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaGFyZGVuZWQgPSAoYy5sZW5ndGggPiAxKSAmJiAoY1tjLmxlbmd0aCAtIDFdID09PSBcIidcIilcbiAgICB2YXIgY2hpbGRJbmRleCA9IHBhcnNlSW50KGMsIDEwKSAvLyAmIChIQVJERU5FRF9PRkZTRVQgLSAxKVxuICAgIGFzc2VydChjaGlsZEluZGV4IDwgSEFSREVORURfT0ZGU0VULCAnSW52YWxpZCBpbmRleCcpXG4gICAgaWYgKGhhcmRlbmVkKSBjaGlsZEluZGV4ICs9IEhBUkRFTkVEX09GRlNFVFxuXG4gICAgaGRrZXkgPSBoZGtleS5kZXJpdmVDaGlsZChjaGlsZEluZGV4KVxuICB9KVxuXG4gIHJldHVybiBoZGtleVxufVxuXG5IREtleS5wcm90b3R5cGUuZGVyaXZlQ2hpbGQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgdmFyIGlzSGFyZGVuZWQgPSBpbmRleCA+PSBIQVJERU5FRF9PRkZTRVRcbiAgdmFyIGluZGV4QnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDQpXG4gIGluZGV4QnVmZmVyLndyaXRlVUludDMyQkUoaW5kZXgsIDApXG5cbiAgdmFyIGRhdGFcblxuICBpZiAoaXNIYXJkZW5lZCkgeyAvLyBIYXJkZW5lZCBjaGlsZFxuICAgIGFzc2VydCh0aGlzLnByaXZhdGVLZXksICdDb3VsZCBub3QgZGVyaXZlIGhhcmRlbmVkIGNoaWxkIGtleScpXG5cbiAgICB2YXIgcGsgPSB0aGlzLnByaXZhdGVLZXlcbiAgICB2YXIgemIgPSBCdWZmZXIuYWxsb2MoMSwgMClcbiAgICBwayA9IEJ1ZmZlci5jb25jYXQoW3piLCBwa10pXG5cbiAgICAvLyBkYXRhID0gMHgwMCB8fCBzZXIyNTYoa3BhcikgfHwgc2VyMzIoaW5kZXgpXG4gICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW3BrLCBpbmRleEJ1ZmZlcl0pXG4gIH0gZWxzZSB7IC8vIE5vcm1hbCBjaGlsZFxuICAgIC8vIGRhdGEgPSBzZXJQKHBvaW50KGtwYXIpKSB8fCBzZXIzMihpbmRleClcbiAgICAvLyAgICAgID0gc2VyUChLcGFyKSB8fCBzZXIzMihpbmRleClcbiAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbdGhpcy5wdWJsaWNLZXksIGluZGV4QnVmZmVyXSlcbiAgfVxuXG4gIHZhciBJID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTUxMicsIHRoaXMuY2hhaW5Db2RlKS51cGRhdGUoZGF0YSkuZGlnZXN0KClcbiAgdmFyIElMID0gSS5zbGljZSgwLCAzMilcbiAgdmFyIElSID0gSS5zbGljZSgzMilcblxuICB2YXIgaGQgPSBuZXcgSERLZXkodGhpcy52ZXJzaW9ucylcblxuICAvLyBQcml2YXRlIHBhcmVudCBrZXkgLT4gcHJpdmF0ZSBjaGlsZCBrZXlcbiAgaWYgKHRoaXMucHJpdmF0ZUtleSkge1xuICAgIC8vIGtpID0gcGFyc2UyNTYoSUwpICsga3BhciAobW9kIG4pXG4gICAgdHJ5IHtcbiAgICAgIGhkLnByaXZhdGVLZXkgPSBzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKHRoaXMucHJpdmF0ZUtleSwgSUwpXG4gICAgICAvLyB0aHJvdyBpZiBJTCA+PSBuIHx8IChwcml2YXRlS2V5ICsgSUwpID09PSAwXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJbiBjYXNlIHBhcnNlMjU2KElMKSA+PSBuIG9yIGtpID09IDAsIG9uZSBzaG91bGQgcHJvY2VlZCB3aXRoIHRoZSBuZXh0IHZhbHVlIGZvciBpXG4gICAgICByZXR1cm4gdGhpcy5kZXJpdmUoaW5kZXggKyAxKVxuICAgIH1cbiAgLy8gUHVibGljIHBhcmVudCBrZXkgLT4gcHVibGljIGNoaWxkIGtleVxuICB9IGVsc2Uge1xuICAgIC8vIEtpID0gcG9pbnQocGFyc2UyNTYoSUwpKSArIEtwYXJcbiAgICAvLyAgICA9IEcqSUwgKyBLcGFyXG4gICAgdHJ5IHtcbiAgICAgIGhkLnB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZCh0aGlzLnB1YmxpY0tleSwgSUwsIHRydWUpXG4gICAgICAvLyB0aHJvdyBpZiBJTCA+PSBuIHx8IChnKipJTCArIHB1YmxpY0tleSkgaXMgaW5maW5pdHlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIEluIGNhc2UgcGFyc2UyNTYoSUwpID49IG4gb3IgS2kgaXMgdGhlIHBvaW50IGF0IGluZmluaXR5LCBvbmUgc2hvdWxkIHByb2NlZWQgd2l0aCB0aGUgbmV4dCB2YWx1ZSBmb3IgaVxuICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgMSwgaXNIYXJkZW5lZClcbiAgICB9XG4gIH1cblxuICBoZC5jaGFpbkNvZGUgPSBJUlxuICBoZC5kZXB0aCA9IHRoaXMuZGVwdGggKyAxXG4gIGhkLnBhcmVudEZpbmdlcnByaW50ID0gdGhpcy5maW5nZXJwcmludC8vIC5yZWFkVUludDMyQkUoMClcbiAgaGQuaW5kZXggPSBpbmRleFxuXG4gIHJldHVybiBoZFxufVxuXG5IREtleS5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIChoYXNoKSB7XG4gIHJldHVybiBzZWNwMjU2azEuc2lnbihoYXNoLCB0aGlzLnByaXZhdGVLZXkpLnNpZ25hdHVyZVxufVxuXG5IREtleS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gKGhhc2gsIHNpZ25hdHVyZSkge1xuICByZXR1cm4gc2VjcDI1NmsxLnZlcmlmeShoYXNoLCBzaWduYXR1cmUsIHRoaXMucHVibGljS2V5KVxufVxuXG5IREtleS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHhwcml2OiB0aGlzLnByaXZhdGVFeHRlbmRlZEtleSxcbiAgICB4cHViOiB0aGlzLnB1YmxpY0V4dGVuZGVkS2V5XG4gIH1cbn1cblxuSERLZXkuZnJvbU1hc3RlclNlZWQgPSBmdW5jdGlvbiAoc2VlZEJ1ZmZlciwgdmVyc2lvbnMpIHtcbiAgdmFyIEkgPSBjcnlwdG8uY3JlYXRlSG1hYygnc2hhNTEyJywgTUFTVEVSX1NFQ1JFVCkudXBkYXRlKHNlZWRCdWZmZXIpLmRpZ2VzdCgpXG4gIHZhciBJTCA9IEkuc2xpY2UoMCwgMzIpXG4gIHZhciBJUiA9IEkuc2xpY2UoMzIpXG5cbiAgdmFyIGhka2V5ID0gbmV3IEhES2V5KHZlcnNpb25zKVxuICBoZGtleS5jaGFpbkNvZGUgPSBJUlxuICBoZGtleS5wcml2YXRlS2V5ID0gSUxcblxuICByZXR1cm4gaGRrZXlcbn1cblxuSERLZXkuZnJvbUV4dGVuZGVkS2V5ID0gZnVuY3Rpb24gKGJhc2U1OGtleSwgdmVyc2lvbnMpIHtcbiAgLy8gPT4gdmVyc2lvbig0KSB8fCBkZXB0aCgxKSB8fCBmaW5nZXJwcmludCg0KSB8fCBpbmRleCg0KSB8fCBjaGFpbigzMikgfHwga2V5KDMzKVxuICB2ZXJzaW9ucyA9IHZlcnNpb25zIHx8IEJJVENPSU5fVkVSU0lPTlNcbiAgdmFyIGhka2V5ID0gbmV3IEhES2V5KHZlcnNpb25zKVxuXG4gIHZhciBrZXlCdWZmZXIgPSBjcy5kZWNvZGUoYmFzZTU4a2V5KVxuXG4gIHZhciB2ZXJzaW9uID0ga2V5QnVmZmVyLnJlYWRVSW50MzJCRSgwKVxuICBhc3NlcnQodmVyc2lvbiA9PT0gdmVyc2lvbnMucHJpdmF0ZSB8fCB2ZXJzaW9uID09PSB2ZXJzaW9ucy5wdWJsaWMsICdWZXJzaW9uIG1pc21hdGNoOiBkb2VzIG5vdCBtYXRjaCBwcml2YXRlIG9yIHB1YmxpYycpXG5cbiAgaGRrZXkuZGVwdGggPSBrZXlCdWZmZXIucmVhZFVJbnQ4KDQpXG4gIGhka2V5LnBhcmVudEZpbmdlcnByaW50ID0ga2V5QnVmZmVyLnJlYWRVSW50MzJCRSg1KVxuICBoZGtleS5pbmRleCA9IGtleUJ1ZmZlci5yZWFkVUludDMyQkUoOSlcbiAgaGRrZXkuY2hhaW5Db2RlID0ga2V5QnVmZmVyLnNsaWNlKDEzLCA0NSlcblxuICB2YXIga2V5ID0ga2V5QnVmZmVyLnNsaWNlKDQ1KVxuICBpZiAoa2V5LnJlYWRVSW50OCgwKSA9PT0gMCkgeyAvLyBwcml2YXRlXG4gICAgYXNzZXJ0KHZlcnNpb24gPT09IHZlcnNpb25zLnByaXZhdGUsICdWZXJzaW9uIG1pc21hdGNoOiB2ZXJzaW9uIGRvZXMgbm90IG1hdGNoIHByaXZhdGUnKVxuICAgIGhka2V5LnByaXZhdGVLZXkgPSBrZXkuc2xpY2UoMSkgLy8gY3V0IG9mZiBmaXJzdCAweDAgYnl0ZVxuICB9IGVsc2Uge1xuICAgIGFzc2VydCh2ZXJzaW9uID09PSB2ZXJzaW9ucy5wdWJsaWMsICdWZXJzaW9uIG1pc21hdGNoOiB2ZXJzaW9uIGRvZXMgbm90IG1hdGNoIHB1YmxpYycpXG4gICAgaGRrZXkucHVibGljS2V5ID0ga2V5XG4gIH1cblxuICByZXR1cm4gaGRrZXlcbn1cblxuSERLZXkuZnJvbUpTT04gPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBIREtleS5mcm9tRXh0ZW5kZWRLZXkob2JqLnhwcml2KVxufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUgKGhka2V5LCB2ZXJzaW9uLCBrZXkpIHtcbiAgLy8gPT4gdmVyc2lvbig0KSB8fCBkZXB0aCgxKSB8fCBmaW5nZXJwcmludCg0KSB8fCBpbmRleCg0KSB8fCBjaGFpbigzMikgfHwga2V5KDMzKVxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKExFTilcblxuICBidWZmZXIud3JpdGVVSW50MzJCRSh2ZXJzaW9uLCAwKVxuICBidWZmZXIud3JpdGVVSW50OChoZGtleS5kZXB0aCwgNClcblxuICB2YXIgZmluZ2VycHJpbnQgPSBoZGtleS5kZXB0aCA/IGhka2V5LnBhcmVudEZpbmdlcnByaW50IDogMHgwMDAwMDAwMFxuICBidWZmZXIud3JpdGVVSW50MzJCRShmaW5nZXJwcmludCwgNSlcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoaGRrZXkuaW5kZXgsIDkpXG5cbiAgaGRrZXkuY2hhaW5Db2RlLmNvcHkoYnVmZmVyLCAxMylcbiAga2V5LmNvcHkoYnVmZmVyLCA0NSlcblxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGhhc2gxNjAgKGJ1Zikge1xuICB2YXIgc2hhID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShidWYpLmRpZ2VzdCgpXG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKHNoYSkuZGlnZXN0KClcbn1cblxuSERLZXkuSEFSREVORURfT0ZGU0VUID0gSEFSREVORURfT0ZGU0VUXG5tb2R1bGUuZXhwb3J0cyA9IEhES2V5XG4iLCIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKShyZXF1aXJlKCcuL2xpYi9lbGxpcHRpYycpKVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbi8vIFR5cGVFcnJvclxuZXhwb3J0cy5pc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IEJvb2xlYW5dJykgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB0aHJvdyBUeXBlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgRnVuY3Rpb25dJykgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBOdW1iZXJdJykgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBPYmplY3RdJykgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbi8vIFJhbmdlRXJyb3JcbmV4cG9ydHMuaXNCdWZmZXJMZW5ndGggPSBmdW5jdGlvbiAoYnVmZmVyLCBsZW5ndGgsIG1lc3NhZ2UpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IGxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzQnVmZmVyTGVuZ3RoMiA9IGZ1bmN0aW9uIChidWZmZXIsIGxlbmd0aDEsIGxlbmd0aDIsIG1lc3NhZ2UpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggIT09IGxlbmd0aDEgJiYgYnVmZmVyLmxlbmd0aCAhPT0gbGVuZ3RoMikgdGhyb3cgUmFuZ2VFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzTGVuZ3RoR1RaZXJvID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc051bWJlckluSW50ZXJ2YWwgPSBmdW5jdGlvbiAobnVtYmVyLCB4LCB5LCBtZXNzYWdlKSB7XG4gIGlmIChudW1iZXIgPD0geCB8fCBudW1iZXIgPj0geSkgdGhyb3cgUmFuZ2VFcnJvcihtZXNzYWdlKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBiaXA2NiA9IHJlcXVpcmUoJ2JpcDY2JylcblxudmFyIEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuICAvLyBiZWdpblxuICAweDMwLCAweDgxLCAweGQzLCAweDAyLCAweDAxLCAweDAxLCAweDA0LCAweDIwLFxuICAvLyBwcml2YXRlIGtleVxuICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAvLyBtaWRkbGVcbiAgMHhhMCwgMHg4MSwgMHg4NSwgMHgzMCwgMHg4MSwgMHg4MiwgMHgwMiwgMHgwMSwgMHgwMSwgMHgzMCwgMHgyYywgMHgwNiwgMHgwNywgMHgyYSwgMHg4NiwgMHg0OCxcbiAgMHhjRSwgMHgzZCwgMHgwMSwgMHgwMSwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgMHhmZiwgMHhmZiwgMHhmRSwgMHhmZiwgMHhmZiwgMHhmYywgMHgyZiwgMHgzMCwgMHgwNiwgMHgwNCwgMHgwMSwgMHgwMCwgMHgwNCwgMHgwMSwgMHgwNywgMHgwNCxcbiAgMHgyMSwgMHgwMiwgMHg3OSwgMHhiRSwgMHg2NiwgMHg3RSwgMHhmOSwgMHhkYywgMHhiYiwgMHhhYywgMHg1NSwgMHhhMCwgMHg2MiwgMHg5NSwgMHhjRSwgMHg4NyxcbiAgMHgwYiwgMHgwNywgMHgwMiwgMHg5YiwgMHhmYywgMHhkYiwgMHgyZCwgMHhjRSwgMHgyOCwgMHhkOSwgMHg1OSwgMHhmMiwgMHg4MSwgMHg1YiwgMHgxNiwgMHhmOCxcbiAgMHgxNywgMHg5OCwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZixcbiAgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmRSwgMHhiYSwgMHhhRSwgMHhkYywgMHhFNiwgMHhhZiwgMHg0OCwgMHhhMCwgMHgzYiwgMHhiZiwgMHhkMiwgMHg1RSxcbiAgMHg4YywgMHhkMCwgMHgzNiwgMHg0MSwgMHg0MSwgMHgwMiwgMHgwMSwgMHgwMSwgMHhhMSwgMHgyNCwgMHgwMywgMHgyMiwgMHgwMCxcbiAgLy8gcHVibGljIGtleVxuICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuICAweDAwXG5dKVxuXG52YXIgRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbiAgLy8gYmVnaW5cbiAgMHgzMCwgMHg4MiwgMHgwMSwgMHgxMywgMHgwMiwgMHgwMSwgMHgwMSwgMHgwNCwgMHgyMCxcbiAgLy8gcHJpdmF0ZSBrZXlcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgLy8gbWlkZGxlXG4gIDB4YTAsIDB4ODEsIDB4YTUsIDB4MzAsIDB4ODEsIDB4YTIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsXG4gIDB4Y0UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZkUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsXG4gIDB4NDEsIDB4MDQsIDB4NzksIDB4YkUsIDB4NjYsIDB4N0UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y0UsIDB4ODcsXG4gIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y0UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsXG4gIDB4MTcsIDB4OTgsIDB4NDgsIDB4M2EsIDB4ZGEsIDB4NzcsIDB4MjYsIDB4YTMsIDB4YzQsIDB4NjUsIDB4NWQsIDB4YTQsIDB4ZmIsIDB4ZmMsIDB4MEUsIDB4MTEsXG4gIDB4MDgsIDB4YTgsIDB4ZmQsIDB4MTcsIDB4YjQsIDB4NDgsIDB4YTYsIDB4ODUsIDB4NTQsIDB4MTksIDB4OWMsIDB4NDcsIDB4ZDAsIDB4OGYsIDB4ZmIsIDB4MTAsXG4gIDB4ZDQsIDB4YjgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZkUsIDB4YmEsIDB4YUUsIDB4ZGMsIDB4RTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NUUsXG4gIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4NDQsIDB4MDMsIDB4NDIsIDB4MDAsXG4gIC8vIHB1YmxpYyBrZXlcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMFxuXSlcblxuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oY29tcHJlc3NlZCA/IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEIDogRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRClcbiAgcHJpdmF0ZUtleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDggOiA5KVxuICBwdWJsaWNLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyAxODEgOiAyMTQpXG4gIHJldHVybiByZXN1bHRcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5SW1wb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGxlbmd0aCA9IHByaXZhdGVLZXkubGVuZ3RoXG5cbiAgLy8gc2VxdWVuY2UgaGVhZGVyXG4gIHZhciBpbmRleCA9IDBcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgzMCkgcmV0dXJuXG4gIGluZGV4ICs9IDFcblxuICAvLyBzZXF1ZW5jZSBsZW5ndGggY29uc3RydWN0b3JcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCAhKHByaXZhdGVLZXlbaW5kZXhdICYgMHg4MCkpIHJldHVyblxuXG4gIHZhciBsZW5iID0gcHJpdmF0ZUtleVtpbmRleF0gJiAweDdmXG4gIGluZGV4ICs9IDFcbiAgaWYgKGxlbmIgPCAxIHx8IGxlbmIgPiAyKSByZXR1cm5cbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuYikgcmV0dXJuXG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoXG4gIHZhciBsZW4gPSBwcml2YXRlS2V5W2luZGV4ICsgbGVuYiAtIDFdIHwgKGxlbmIgPiAxID8gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAyXSA8PCA4IDogMClcbiAgaW5kZXggKz0gbGVuYlxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW4pIHJldHVyblxuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMDogdmVyc2lvbiBudW1iZXIgKD0xKVxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAzIHx8XG4gICAgICBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwMiB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDFdICE9PSAweDAxIHx8XG4gICAgICBwcml2YXRlS2V5W2luZGV4ICsgMl0gIT09IDB4MDEpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpbmRleCArPSAzXG5cbiAgLy8gc2VxdWVuY2UgZWxlbWVudCAxOiBvY3RldCBzdHJpbmcsIHVwIHRvIDMyIGJ5dGVzXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDIgfHxcbiAgICAgIHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDA0IHx8XG4gICAgICBwcml2YXRlS2V5W2luZGV4ICsgMV0gPiAweDIwIHx8XG4gICAgICBsZW5ndGggPCBpbmRleCArIDIgKyBwcml2YXRlS2V5W2luZGV4ICsgMV0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHJldHVybiBwcml2YXRlS2V5LnNsaWNlKGluZGV4ICsgMiwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIChzaWdPYmopIHtcbiAgdmFyIHIgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMF0pLCBzaWdPYmoucl0pXG4gIGZvciAodmFyIGxlblIgPSAzMywgcG9zUiA9IDA7IGxlblIgPiAxICYmIHJbcG9zUl0gPT09IDB4MDAgJiYgIShyW3Bvc1IgKyAxXSAmIDB4ODApOyAtLWxlblIsICsrcG9zUik7XG5cbiAgdmFyIHMgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbShbMF0pLCBzaWdPYmouc10pXG4gIGZvciAodmFyIGxlblMgPSAzMywgcG9zUyA9IDA7IGxlblMgPiAxICYmIHNbcG9zU10gPT09IDB4MDAgJiYgIShzW3Bvc1MgKyAxXSAmIDB4ODApOyAtLWxlblMsICsrcG9zUyk7XG5cbiAgcmV0dXJuIGJpcDY2LmVuY29kZShyLnNsaWNlKHBvc1IpLCBzLnNsaWNlKHBvc1MpKVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApXG4gIHZhciBzID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuXG4gIHRyeSB7XG4gICAgdmFyIHNpZ09iaiA9IGJpcDY2LmRlY29kZShzaWcpXG4gICAgaWYgKHNpZ09iai5yLmxlbmd0aCA9PT0gMzMgJiYgc2lnT2JqLnJbMF0gPT09IDB4MDApIHNpZ09iai5yID0gc2lnT2JqLnIuc2xpY2UoMSlcbiAgICBpZiAoc2lnT2JqLnIubGVuZ3RoID4gMzIpIHRocm93IG5ldyBFcnJvcignUiBsZW5ndGggaXMgdG9vIGxvbmcnKVxuICAgIGlmIChzaWdPYmoucy5sZW5ndGggPT09IDMzICYmIHNpZ09iai5zWzBdID09PSAweDAwKSBzaWdPYmoucyA9IHNpZ09iai5zLnNsaWNlKDEpXG4gICAgaWYgKHNpZ09iai5zLmxlbmd0aCA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoJ1MgbGVuZ3RoIGlzIHRvbyBsb25nJylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBzaWdPYmouci5jb3B5KHIsIDMyIC0gc2lnT2JqLnIubGVuZ3RoKVxuICBzaWdPYmoucy5jb3B5KHMsIDMyIC0gc2lnT2JqLnMubGVuZ3RoKVxuXG4gIHJldHVybiB7IHI6IHIsIHM6IHMgfVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApXG4gIHZhciBzID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuXG4gIHZhciBsZW5ndGggPSBzaWcubGVuZ3RoXG4gIHZhciBpbmRleCA9IDBcblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZVxuICBpZiAoc2lnW2luZGV4KytdICE9PSAweDMwKSByZXR1cm5cblxuICAvLyBzZXF1ZW5jZSBsZW5ndGggYnl0ZVxuICB2YXIgbGVuYnl0ZSA9IHNpZ1tpbmRleCsrXVxuICBpZiAobGVuYnl0ZSAmIDB4ODApIHtcbiAgICBpbmRleCArPSBsZW5ieXRlIC0gMHg4MFxuICAgIGlmIChpbmRleCA+IGxlbmd0aCkgcmV0dXJuXG4gIH1cblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3IgclxuICBpZiAoc2lnW2luZGV4KytdICE9PSAweDAyKSByZXR1cm5cblxuICAvLyBsZW5ndGggZm9yIHJcbiAgdmFyIHJsZW4gPSBzaWdbaW5kZXgrK11cbiAgaWYgKHJsZW4gJiAweDgwKSB7XG4gICAgbGVuYnl0ZSA9IHJsZW4gLSAweDgwXG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkgcmV0dXJuXG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ1tpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSk7XG4gICAgZm9yIChybGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkgcmxlbiA9IChybGVuIDw8IDgpICsgc2lnW2luZGV4XVxuICB9XG4gIGlmIChybGVuID4gbGVuZ3RoIC0gaW5kZXgpIHJldHVyblxuICB2YXIgcmluZGV4ID0gaW5kZXhcbiAgaW5kZXggKz0gcmxlblxuXG4gIC8vIHNlcXVlbmNlIHRhZyBieXRlIGZvciBzXG4gIGlmIChzaWdbaW5kZXgrK10gIT09IDB4MDIpIHJldHVyblxuXG4gIC8vIGxlbmd0aCBmb3Igc1xuICB2YXIgc2xlbiA9IHNpZ1tpbmRleCsrXVxuICBpZiAoc2xlbiAmIDB4ODApIHtcbiAgICBsZW5ieXRlID0gc2xlbiAtIDB4ODBcbiAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSByZXR1cm5cbiAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKTtcbiAgICBmb3IgKHNsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSBzbGVuID0gKHNsZW4gPDwgOCkgKyBzaWdbaW5kZXhdXG4gIH1cbiAgaWYgKHNsZW4gPiBsZW5ndGggLSBpbmRleCkgcmV0dXJuXG4gIHZhciBzaW5kZXggPSBpbmRleFxuICBpbmRleCArPSBzbGVuXG5cbiAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gclxuICBmb3IgKDsgcmxlbiA+IDAgJiYgc2lnW3JpbmRleF0gPT09IDB4MDA7IHJsZW4gLT0gMSwgcmluZGV4ICs9IDEpO1xuICAvLyBjb3B5IHIgdmFsdWVcbiAgaWYgKHJsZW4gPiAzMikgcmV0dXJuXG4gIHZhciBydmFsdWUgPSBzaWcuc2xpY2UocmluZGV4LCByaW5kZXggKyBybGVuKVxuICBydmFsdWUuY29weShyLCAzMiAtIHJ2YWx1ZS5sZW5ndGgpXG5cbiAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gc1xuICBmb3IgKDsgc2xlbiA+IDAgJiYgc2lnW3NpbmRleF0gPT09IDB4MDA7IHNsZW4gLT0gMSwgc2luZGV4ICs9IDEpO1xuICAvLyBjb3B5IHMgdmFsdWVcbiAgaWYgKHNsZW4gPiAzMikgcmV0dXJuXG4gIHZhciBzdmFsdWUgPSBzaWcuc2xpY2Uoc2luZGV4LCBzaW5kZXggKyBzbGVuKVxuICBzdmFsdWUuY29weShzLCAzMiAtIHN2YWx1ZS5sZW5ndGgpXG5cbiAgcmV0dXJuIHsgcjogciwgczogcyB9XG59XG4iLCIndXNlIHN0cmljdCdcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpXG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjXG5cbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoJy4uL21lc3NhZ2VzLmpzb24nKVxuXG52YXIgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpXG52YXIgZWNwYXJhbXMgPSBlYy5jdXJ2ZVxuXG5mdW5jdGlvbiBsb2FkQ29tcHJlc3NlZFB1YmxpY0tleSAoZmlyc3QsIHhCdWZmZXIpIHtcbiAgdmFyIHggPSBuZXcgQk4oeEJ1ZmZlcilcblxuICAvLyBvdmVyZmxvd1xuICBpZiAoeC5jbXAoZWNwYXJhbXMucCkgPj0gMCkgcmV0dXJuIG51bGxcbiAgeCA9IHgudG9SZWQoZWNwYXJhbXMucmVkKVxuXG4gIC8vIGNvbXB1dGUgY29ycmVzcG9uZGluZyBZXG4gIHZhciB5ID0geC5yZWRTcXIoKS5yZWRJTXVsKHgpLnJlZElBZGQoZWNwYXJhbXMuYikucmVkU3FydCgpXG4gIGlmICgoZmlyc3QgPT09IDB4MDMpICE9PSB5LmlzT2RkKCkpIHkgPSB5LnJlZE5lZygpXG5cbiAgcmV0dXJuIGVjLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pXG59XG5cbmZ1bmN0aW9uIGxvYWRVbmNvbXByZXNzZWRQdWJsaWNLZXkgKGZpcnN0LCB4QnVmZmVyLCB5QnVmZmVyKSB7XG4gIHZhciB4ID0gbmV3IEJOKHhCdWZmZXIpXG4gIHZhciB5ID0gbmV3IEJOKHlCdWZmZXIpXG5cbiAgLy8gb3ZlcmZsb3dcbiAgaWYgKHguY21wKGVjcGFyYW1zLnApID49IDAgfHwgeS5jbXAoZWNwYXJhbXMucCkgPj0gMCkgcmV0dXJuIG51bGxcblxuICB4ID0geC50b1JlZChlY3BhcmFtcy5yZWQpXG4gIHkgPSB5LnRvUmVkKGVjcGFyYW1zLnJlZClcblxuICAvLyBpcyBvZGQgZmxhZ1xuICBpZiAoKGZpcnN0ID09PSAweDA2IHx8IGZpcnN0ID09PSAweDA3KSAmJiB5LmlzT2RkKCkgIT09IChmaXJzdCA9PT0gMHgwNykpIHJldHVybiBudWxsXG5cbiAgLy8geCp4KnggKyBiID0geSp5XG4gIHZhciB4MyA9IHgucmVkU3FyKCkucmVkSU11bCh4KVxuICBpZiAoIXkucmVkU3FyKCkucmVkSVN1Yih4My5yZWRJQWRkKGVjcGFyYW1zLmIpKS5pc1plcm8oKSkgcmV0dXJuIG51bGxcblxuICByZXR1cm4gZWMua2V5UGFpcih7IHB1YjogeyB4OiB4LCB5OiB5IH0gfSlcbn1cblxuZnVuY3Rpb24gbG9hZFB1YmxpY0tleSAocHVibGljS2V5KSB7XG4gIHZhciBmaXJzdCA9IHB1YmxpY0tleVswXVxuICBzd2l0Y2ggKGZpcnN0KSB7XG4gICAgY2FzZSAweDAyOlxuICAgIGNhc2UgMHgwMzpcbiAgICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMykgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2FkQ29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVibGljS2V5LnNsaWNlKDEsIDMzKSlcbiAgICBjYXNlIDB4MDQ6XG4gICAgY2FzZSAweDA2OlxuICAgIGNhc2UgMHgwNzpcbiAgICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkgcmV0dXJuIG51bGxcbiAgICAgIHJldHVybiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5KGZpcnN0LCBwdWJsaWNLZXkuc2xpY2UoMSwgMzMpLCBwdWJsaWNLZXkuc2xpY2UoMzMsIDY1KSlcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlWZXJpZnkgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgYm4gPSBuZXcgQk4ocHJpdmF0ZUtleSlcbiAgcmV0dXJuIGJuLmNtcChlY3BhcmFtcy5uKSA8IDAgJiYgIWJuLmlzWmVybygpXG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIGlmIChkLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGQuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9FWFBPUlRfREVSX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXkpLmdldFB1YmxpYyhjb21wcmVzc2VkLCB0cnVlKSlcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5TmVnYXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIHJldHVybiBibi5pc1plcm8oKSA/IEJ1ZmZlci5hbGxvYygzMikgOiBlY3BhcmFtcy5uLnN1YihibikudW1vZChlY3BhcmFtcy5uKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1JBTkdFX0lOVkFMSUQpXG5cbiAgcmV0dXJuIGJuLmludm0oZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgdmFyIGJuID0gbmV3IEJOKHR3ZWFrKVxuICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UV0VBS19BRERfRkFJTClcblxuICBibi5pYWRkKG5ldyBCTihwcml2YXRlS2V5KSlcbiAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBibi5pc3ViKGVjcGFyYW1zLm4pXG4gIGlmIChibi5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RXRUFLX0FERF9GQUlMKVxuXG4gIHJldHVybiBibi50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlUd2Vha011bCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICB2YXIgYm4gPSBuZXcgQk4odHdlYWspXG4gIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RXRUFLX01VTF9GQUlMKVxuXG4gIGJuLmltdWwobmV3IEJOKHByaXZhdGVLZXkpKVxuICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pKSBibiA9IGJuLnVtb2QoZWNwYXJhbXMubilcblxuICByZXR1cm4gYm4udG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlDcmVhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgZCA9IG5ldyBCTihwcml2YXRlS2V5KVxuICBpZiAoZC5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBkLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9DUkVBVEVfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20oZWMua2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSkuZ2V0UHVibGljKGNvbXByZXNzZWQsIHRydWUpKVxufVxuXG5leHBvcnRzLnB1YmxpY0tleUNvbnZlcnQgPSBmdW5jdGlvbiAocHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwYWlyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShwYWlyLmdldFB1YmxpYyhjb21wcmVzc2VkLCB0cnVlKSlcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlWZXJpZnkgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gIHJldHVybiBsb2FkUHVibGljS2V5KHB1YmxpY0tleSkgIT09IG51bGxcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIHZhciBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwYWlyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHR3ZWFrID0gbmV3IEJOKHR3ZWFrKVxuICBpZiAodHdlYWsuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RXRUFLX0FERF9GQUlMKVxuXG4gIHZhciBwb2ludCA9IGVjcGFyYW1zLmcubXVsKHR3ZWFrKS5hZGQocGFpci5wdWIpXG4gIGlmIChwb2ludC5pc0luZmluaXR5KCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RXRUFLX0FERF9GQUlMKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShwb2ludC5lbmNvZGUodHJ1ZSwgY29tcHJlc3NlZCkpXG59XG5cbmV4cG9ydHMucHVibGljS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVibGljS2V5KVxuICBpZiAocGFpciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICB0d2VhayA9IG5ldyBCTih0d2VhaylcbiAgaWYgKHR3ZWFrLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHR3ZWFrLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UV0VBS19NVUxfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocGFpci5wdWIubXVsKHR3ZWFrKS5lbmNvZGUodHJ1ZSwgY29tcHJlc3NlZCkpXG59XG5cbmV4cG9ydHMucHVibGljS2V5Q29tYmluZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXlzLCBjb21wcmVzc2VkKSB7XG4gIHZhciBwYWlycyA9IG5ldyBBcnJheShwdWJsaWNLZXlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdWJsaWNLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgcGFpcnNbaV0gPSBsb2FkUHVibGljS2V5KHB1YmxpY0tleXNbaV0pXG4gICAgaWYgKHBhaXJzW2ldID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuICB9XG5cbiAgdmFyIHBvaW50ID0gcGFpcnNbMF0ucHViXG4gIGZvciAodmFyIGogPSAxOyBqIDwgcGFpcnMubGVuZ3RoOyArK2opIHBvaW50ID0gcG9pbnQuYWRkKHBhaXJzW2pdLnB1YilcbiAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfQ09NQklORV9GQUlMKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShwb2ludC5lbmNvZGUodHJ1ZSwgY29tcHJlc3NlZCkpXG59XG5cbmV4cG9ydHMuc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICB2YXIgciA9IG5ldyBCTihzaWduYXR1cmUuc2xpY2UoMCwgMzIpKVxuICB2YXIgcyA9IG5ldyBCTihzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSlcbiAgaWYgKHIuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgcy5jbXAoZWNwYXJhbXMubikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMKVxuXG4gIHZhciByZXN1bHQgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUpXG4gIGlmIChzLmNtcChlYy5uaCkgPT09IDEpIGVjcGFyYW1zLm4uc3ViKHMpLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocmVzdWx0LCAzMilcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydHMuc2lnbmF0dXJlRXhwb3J0ID0gZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICB2YXIgciA9IHNpZ25hdHVyZS5zbGljZSgwLCAzMilcbiAgdmFyIHMgPSBzaWduYXR1cmUuc2xpY2UoMzIsIDY0KVxuICBpZiAobmV3IEJOKHIpLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IG5ldyBCTihzKS5jbXAoZWNwYXJhbXMubikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMKVxuXG4gIHJldHVybiB7IHI6IHIsIHM6IHMgfVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWdPYmopIHtcbiAgdmFyIHIgPSBuZXcgQk4oc2lnT2JqLnIpXG4gIGlmIChyLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByID0gbmV3IEJOKDApXG5cbiAgdmFyIHMgPSBuZXcgQk4oc2lnT2JqLnMpXG4gIGlmIChzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSBzID0gbmV3IEJOKDApXG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW1xuICAgIHIudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksXG4gICAgcy50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxuICBdKVxufVxuXG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgbm9uY2VmbiwgZGF0YSkge1xuICBpZiAodHlwZW9mIG5vbmNlZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZ2V0Tm9uY2UgPSBub25jZWZuXG4gICAgbm9uY2VmbiA9IGZ1bmN0aW9uIChjb3VudGVyKSB7XG4gICAgICB2YXIgbm9uY2UgPSBnZXROb25jZShtZXNzYWdlLCBwcml2YXRlS2V5LCBudWxsLCBkYXRhLCBjb3VudGVyKVxuICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIobm9uY2UpIHx8IG5vbmNlLmxlbmd0aCAhPT0gMzIpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOX0ZBSUwpXG5cbiAgICAgIHJldHVybiBuZXcgQk4obm9uY2UpXG4gICAgfVxuICB9XG5cbiAgdmFyIGQgPSBuZXcgQk4ocHJpdmF0ZUtleSlcbiAgaWYgKGQuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgZC5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05fRkFJTClcblxuICB2YXIgcmVzdWx0ID0gZWMuc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCB7IGNhbm9uaWNhbDogdHJ1ZSwgazogbm9uY2VmbiwgcGVyczogZGF0YSB9KVxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogQnVmZmVyLmNvbmNhdChbXG4gICAgICByZXN1bHQuci50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKSxcbiAgICAgIHJlc3VsdC5zLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXG4gICAgXSksXG4gICAgcmVjb3Zlcnk6IHJlc3VsdC5yZWNvdmVyeVBhcmFtXG4gIH1cbn1cblxuZXhwb3J0cy52ZXJpZnkgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgdmFyIHNpZ09iaiA9IHsgcjogc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSwgczogc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkgfVxuXG4gIHZhciBzaWdyID0gbmV3IEJOKHNpZ09iai5yKVxuICB2YXIgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgaWYgKHNpZ3IuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2lncy5jbXAoZWNwYXJhbXMubikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMKVxuICBpZiAoc2lncy5jbXAoZWMubmgpID09PSAxIHx8IHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSkgcmV0dXJuIGZhbHNlXG5cbiAgdmFyIHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmxpY0tleSlcbiAgaWYgKHBhaXIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1BBUlNFX0ZBSUwpXG5cbiAgcmV0dXJuIGVjLnZlcmlmeShtZXNzYWdlLCBzaWdPYmosIHsgeDogcGFpci5wdWIueCwgeTogcGFpci5wdWIueSB9KVxufVxuXG5leHBvcnRzLnJlY292ZXIgPSBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCByZWNvdmVyeSwgY29tcHJlc3NlZCkge1xuICB2YXIgc2lnT2JqID0geyByOiBzaWduYXR1cmUuc2xpY2UoMCwgMzIpLCBzOiBzaWduYXR1cmUuc2xpY2UoMzIsIDY0KSB9XG5cbiAgdmFyIHNpZ3IgPSBuZXcgQk4oc2lnT2JqLnIpXG4gIHZhciBzaWdzID0gbmV3IEJOKHNpZ09iai5zKVxuICBpZiAoc2lnci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzaWdzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0ZBSUwpXG5cbiAgdHJ5IHtcbiAgICBpZiAoc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IoKVxuXG4gICAgdmFyIHBvaW50ID0gZWMucmVjb3ZlclB1YktleShtZXNzYWdlLCBzaWdPYmosIHJlY292ZXJ5KVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShwb2ludC5lbmNvZGUodHJ1ZSwgY29tcHJlc3NlZCkpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9SRUNPVkVSX0ZBSUwpXG4gIH1cbn1cblxuZXhwb3J0cy5lY2RoID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgcHJpdmF0ZUtleSkge1xuICB2YXIgc2hhcmVkID0gZXhwb3J0cy5lY2RoVW5zYWZlKHB1YmxpY0tleSwgcHJpdmF0ZUtleSwgdHJ1ZSlcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShzaGFyZWQpLmRpZ2VzdCgpXG59XG5cbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmxpY0tleSlcbiAgaWYgKHBhaXIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1BBUlNFX0ZBSUwpXG5cbiAgdmFyIHNjYWxhciA9IG5ldyBCTihwcml2YXRlS2V5KVxuICBpZiAoc2NhbGFyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDREhfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocGFpci5wdWIubXVsKHNjYWxhcikuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi9hc3NlcnQnKVxudmFyIGRlciA9IHJlcXVpcmUoJy4vZGVyJylcbnZhciBtZXNzYWdlcyA9IHJlcXVpcmUoJy4vbWVzc2FnZXMuanNvbicpXG5cbmZ1bmN0aW9uIGluaXRDb21wcmVzc2VkVmFsdWUgKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBkZWZhdWx0VmFsdWVcblxuICBhc3NlcnQuaXNCb29sZWFuKHZhbHVlLCBtZXNzYWdlcy5DT01QUkVTU0VEX1RZUEVfSU5WQUxJRClcbiAgcmV0dXJuIHZhbHVlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNlY3AyNTZrMSkge1xuICByZXR1cm4ge1xuICAgIHByaXZhdGVLZXlWZXJpZnk6IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgcmV0dXJuIHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiAmJiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5RXhwb3J0OiBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG4gICAgICB2YXIgcHVibGljS2V5ID0gc2VjcDI1NmsxLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgY29tcHJlc3NlZClcblxuICAgICAgcmV0dXJuIGRlci5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZClcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleUltcG9ydDogZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG5cbiAgICAgIHByaXZhdGVLZXkgPSBkZXIucHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KVxuICAgICAgaWYgKHByaXZhdGVLZXkgJiYgcHJpdmF0ZUtleS5sZW5ndGggPT09IDMyICYmIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpKSByZXR1cm4gcHJpdmF0ZUtleVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfSU1QT1JUX0RFUl9GQUlMKVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5TmVnYXRlOiBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShwcml2YXRlS2V5KVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5TW9kSW52ZXJzZTogZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlNb2RJbnZlcnNlKHByaXZhdGVLZXkpXG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlUd2Vha0FkZDogZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHByaXZhdGVLZXksIDMyLCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHR3ZWFrLCBtZXNzYWdlcy5UV0VBS19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgodHdlYWssIDMyLCBtZXNzYWdlcy5UV0VBS19MRU5HVEhfSU5WQUxJRClcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtBZGQocHJpdmF0ZUtleSwgdHdlYWspXG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlUd2Vha011bDogZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHByaXZhdGVLZXksIDMyLCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHR3ZWFrLCBtZXNzYWdlcy5UV0VBS19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgodHdlYWssIDMyLCBtZXNzYWdlcy5UV0VBS19MRU5HVEhfSU5WQUxJRClcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtNdWwocHJpdmF0ZUtleSwgdHdlYWspXG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNyZWF0ZTogZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDb252ZXJ0OiBmdW5jdGlvbiAocHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHVibGljS2V5LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aDIocHVibGljS2V5LCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHB1YmxpY0tleVZlcmlmeTogZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpXG4gICAgfSxcblxuICAgIHB1YmxpY0tleVR3ZWFrQWRkOiBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleSwgMzMsIDY1LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBhc3NlcnQuaXNCdWZmZXIodHdlYWssIG1lc3NhZ2VzLlRXRUFLX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aCh0d2VhaywgMzIsIG1lc3NhZ2VzLlRXRUFLX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrQWRkKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHB1YmxpY0tleVR3ZWFrTXVsOiBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleSwgMzMsIDY1LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBhc3NlcnQuaXNCdWZmZXIodHdlYWssIG1lc3NhZ2VzLlRXRUFLX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aCh0d2VhaywgMzIsIG1lc3NhZ2VzLlRXRUFLX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNvbWJpbmU6IGZ1bmN0aW9uIChwdWJsaWNLZXlzLCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNBcnJheShwdWJsaWNLZXlzLCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZU19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNMZW5ndGhHVFplcm8ocHVibGljS2V5cywgbWVzc2FnZXMuRUNfUFVCTElDX0tFWVNfTEVOR1RIX0lOVkFMSUQpXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB1YmxpY0tleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleXNbaV0sIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleXNbaV0sIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcbiAgICAgIH1cblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHNpZ25hdHVyZU5vcm1hbGl6ZTogZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEuc2lnbmF0dXJlTm9ybWFsaXplKHNpZ25hdHVyZSlcbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlRXhwb3J0OiBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnbmF0dXJlLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHNpZ25hdHVyZSwgNjQsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgdmFyIHNpZ09iaiA9IHNlY3AyNTZrMS5zaWduYXR1cmVFeHBvcnQoc2lnbmF0dXJlKVxuICAgICAgcmV0dXJuIGRlci5zaWduYXR1cmVFeHBvcnQoc2lnT2JqKVxuICAgIH0sXG5cbiAgICBzaWduYXR1cmVJbXBvcnQ6IGZ1bmN0aW9uIChzaWcpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihzaWcsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNMZW5ndGhHVFplcm8oc2lnLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHZhciBzaWdPYmogPSBkZXIuc2lnbmF0dXJlSW1wb3J0KHNpZylcbiAgICAgIGlmIChzaWdPYmopIHJldHVybiBzZWNwMjU2azEuc2lnbmF0dXJlSW1wb3J0KHNpZ09iailcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9ERVJfRkFJTClcbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlSW1wb3J0TGF4OiBmdW5jdGlvbiAoc2lnKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTGVuZ3RoR1RaZXJvKHNpZywgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICB2YXIgc2lnT2JqID0gZGVyLnNpZ25hdHVyZUltcG9ydExheChzaWcpXG4gICAgICBpZiAoc2lnT2JqKSByZXR1cm4gc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChzaWdPYmopXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfREVSX0ZBSUwpXG4gICAgfSxcblxuICAgIHNpZ246IGZ1bmN0aW9uIChtZXNzYWdlLCBwcml2YXRlS2V5LCBvcHRpb25zKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIobWVzc2FnZSwgbWVzc2FnZXMuTVNHMzJfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKG1lc3NhZ2UsIDMyLCBtZXNzYWdlcy5NU0czMl9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHZhciBkYXRhID0gbnVsbFxuICAgICAgdmFyIG5vbmNlZm4gPSBudWxsXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFzc2VydC5pc09iamVjdChvcHRpb25zLCBtZXNzYWdlcy5PUFRJT05TX1RZUEVfSU5WQUxJRClcblxuICAgICAgICBpZiAob3B0aW9ucy5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhc3NlcnQuaXNCdWZmZXIob3B0aW9ucy5kYXRhLCBtZXNzYWdlcy5PUFRJT05TX0RBVEFfVFlQRV9JTlZBTElEKVxuICAgICAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChvcHRpb25zLmRhdGEsIDMyLCBtZXNzYWdlcy5PUFRJT05TX0RBVEFfTEVOR1RIX0lOVkFMSUQpXG4gICAgICAgICAgZGF0YSA9IG9wdGlvbnMuZGF0YVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9uY2VmbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXNzZXJ0LmlzRnVuY3Rpb24ob3B0aW9ucy5ub25jZWZuLCBtZXNzYWdlcy5PUFRJT05TX05PTkNFRk5fVFlQRV9JTlZBTElEKVxuICAgICAgICAgIG5vbmNlZm4gPSBvcHRpb25zLm5vbmNlZm5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgbm9uY2VmbiwgZGF0YSlcbiAgICB9LFxuXG4gICAgdmVyaWZ5OiBmdW5jdGlvbiAobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihtZXNzYWdlLCBtZXNzYWdlcy5NU0czMl9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgobWVzc2FnZSwgMzIsIG1lc3NhZ2VzLk1TRzMyX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnbmF0dXJlLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHNpZ25hdHVyZSwgNjQsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleSwgMzMsIDY1LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUsIHB1YmxpY0tleSlcbiAgICB9LFxuXG4gICAgcmVjb3ZlcjogZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihtZXNzYWdlLCBtZXNzYWdlcy5NU0czMl9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgobWVzc2FnZSwgMzIsIG1lc3NhZ2VzLk1TRzMyX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnbmF0dXJlLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHNpZ25hdHVyZSwgNjQsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzTnVtYmVyKHJlY292ZXJ5LCBtZXNzYWdlcy5SRUNPVkVSWV9JRF9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNOdW1iZXJJbkludGVydmFsKHJlY292ZXJ5LCAtMSwgNCwgbWVzc2FnZXMuUkVDT1ZFUllfSURfVkFMVUVfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5yZWNvdmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIGVjZGg6IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEuZWNkaChwdWJsaWNLZXksIHByaXZhdGVLZXkpXG4gICAgfSxcblxuICAgIGVjZGhVbnNhZmU6IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEuZWNkaFVuc2FmZShwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpXG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiQ09NUFJFU1NFRF9UWVBFX0lOVkFMSURcIjogXCJjb21wcmVzc2VkIHNob3VsZCBiZSBhIGJvb2xlYW5cIixcbiAgXCJFQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSURcIjogXCJwcml2YXRlIGtleSBzaG91bGQgYmUgYSBCdWZmZXJcIixcbiAgXCJFQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRFwiOiBcInByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfUkFOR0VfSU5WQUxJRFwiOiBcInByaXZhdGUga2V5IHJhbmdlIGlzIGludmFsaWRcIixcbiAgXCJFQ19QUklWQVRFX0tFWV9UV0VBS19BRERfRkFJTFwiOiBcInR3ZWFrIG91dCBvZiByYW5nZSBvciByZXN1bHRpbmcgcHJpdmF0ZSBrZXkgaXMgaW52YWxpZFwiLFxuICBcIkVDX1BSSVZBVEVfS0VZX1RXRUFLX01VTF9GQUlMXCI6IFwidHdlYWsgb3V0IG9mIHJhbmdlXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfRVhQT1JUX0RFUl9GQUlMXCI6IFwiY291bGRuJ3QgZXhwb3J0IHRvIERFUiBmb3JtYXRcIixcbiAgXCJFQ19QUklWQVRFX0tFWV9JTVBPUlRfREVSX0ZBSUxcIjogXCJjb3VsZG4ndCBpbXBvcnQgZnJvbSBERVIgZm9ybWF0XCIsXG4gIFwiRUNfUFVCTElDX0tFWVNfVFlQRV9JTlZBTElEXCI6IFwicHVibGljIGtleXMgc2hvdWxkIGJlIGFuIEFycmF5XCIsXG4gIFwiRUNfUFVCTElDX0tFWVNfTEVOR1RIX0lOVkFMSURcIjogXCJwdWJsaWMga2V5cyBBcnJheSBzaG91bGQgaGF2ZSBhdCBsZWFzdCAxIGVsZW1lbnRcIixcbiAgXCJFQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRFwiOiBcInB1YmxpYyBrZXkgc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRFwiOiBcInB1YmxpYyBrZXkgbGVuZ3RoIGlzIGludmFsaWRcIixcbiAgXCJFQ19QVUJMSUNfS0VZX1BBUlNFX0ZBSUxcIjogXCJ0aGUgcHVibGljIGtleSBjb3VsZCBub3QgYmUgcGFyc2VkIG9yIGlzIGludmFsaWRcIixcbiAgXCJFQ19QVUJMSUNfS0VZX0NSRUFURV9GQUlMXCI6IFwicHJpdmF0ZSB3YXMgaW52YWxpZCwgdHJ5IGFnYWluXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9UV0VBS19BRERfRkFJTFwiOiBcInR3ZWFrIG91dCBvZiByYW5nZSBvciByZXN1bHRpbmcgcHVibGljIGtleSBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9UV0VBS19NVUxfRkFJTFwiOiBcInR3ZWFrIG91dCBvZiByYW5nZVwiLFxuICBcIkVDX1BVQkxJQ19LRVlfQ09NQklORV9GQUlMXCI6IFwidGhlIHN1bSBvZiB0aGUgcHVibGljIGtleXMgaXMgbm90IHZhbGlkXCIsXG4gIFwiRUNESF9GQUlMXCI6IFwic2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KVwiLFxuICBcIkVDRFNBX1NJR05BVFVSRV9UWVBFX0lOVkFMSURcIjogXCJzaWduYXR1cmUgc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiRUNEU0FfU0lHTkFUVVJFX0xFTkdUSF9JTlZBTElEXCI6IFwic2lnbmF0dXJlIGxlbmd0aCBpcyBpbnZhbGlkXCIsXG4gIFwiRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0ZBSUxcIjogXCJjb3VsZG4ndCBwYXJzZSBzaWduYXR1cmVcIixcbiAgXCJFQ0RTQV9TSUdOQVRVUkVfUEFSU0VfREVSX0ZBSUxcIjogXCJjb3VsZG4ndCBwYXJzZSBERVIgc2lnbmF0dXJlXCIsXG4gIFwiRUNEU0FfU0lHTkFUVVJFX1NFUklBTElaRV9ERVJfRkFJTFwiOiBcImNvdWxkbid0IHNlcmlhbGl6ZSBzaWduYXR1cmUgdG8gREVSIGZvcm1hdFwiLFxuICBcIkVDRFNBX1NJR05fRkFJTFwiOiBcIm5vbmNlIGdlbmVyYXRpb24gZnVuY3Rpb24gZmFpbGVkIG9yIHByaXZhdGUga2V5IGlzIGludmFsaWRcIixcbiAgXCJFQ0RTQV9SRUNPVkVSX0ZBSUxcIjogXCJjb3VsZG4ndCByZWNvdmVyIHB1YmxpYyBrZXkgZnJvbSBzaWduYXR1cmVcIixcbiAgXCJNU0czMl9UWVBFX0lOVkFMSURcIjogXCJtZXNzYWdlIHNob3VsZCBiZSBhIEJ1ZmZlclwiLFxuICBcIk1TRzMyX0xFTkdUSF9JTlZBTElEXCI6IFwibWVzc2FnZSBsZW5ndGggaXMgaW52YWxpZFwiLFxuICBcIk9QVElPTlNfVFlQRV9JTlZBTElEXCI6IFwib3B0aW9ucyBzaG91bGQgYmUgYW4gT2JqZWN0XCIsXG4gIFwiT1BUSU9OU19EQVRBX1RZUEVfSU5WQUxJRFwiOiBcIm9wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBCdWZmZXJcIixcbiAgXCJPUFRJT05TX0RBVEFfTEVOR1RIX0lOVkFMSURcIjogXCJvcHRpb25zLmRhdGEgbGVuZ3RoIGlzIGludmFsaWRcIixcbiAgXCJPUFRJT05TX05PTkNFRk5fVFlQRV9JTlZBTElEXCI6IFwib3B0aW9ucy5ub25jZWZuIHNob3VsZCBiZSBhIEZ1bmN0aW9uXCIsXG4gIFwiUkVDT1ZFUllfSURfVFlQRV9JTlZBTElEXCI6IFwicmVjb3Zlcnkgc2hvdWxkIGJlIGEgTnVtYmVyXCIsXG4gIFwiUkVDT1ZFUllfSURfVkFMVUVfSU5WQUxJRFwiOiBcInJlY292ZXJ5IHNob3VsZCBoYXZlIHZhbHVlIGJldHdlZW4gLTEgYW5kIDRcIixcbiAgXCJUV0VBS19UWVBFX0lOVkFMSURcIjogXCJ0d2VhayBzaG91bGQgYmUgYSBCdWZmZXJcIixcbiAgXCJUV0VBS19MRU5HVEhfSU5WQUxJRFwiOiBcInR3ZWFrIGxlbmd0aCBpcyBpbnZhbGlkXCJcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVuY3J5cHRpb25QdWJsaWNLZXkgPSBleHBvcnRzLmRlY3J5cHRTYWZlbHkgPSBleHBvcnRzLmRlY3J5cHQgPSBleHBvcnRzLmVuY3J5cHRTYWZlbHkgPSBleHBvcnRzLmVuY3J5cHQgPSB2b2lkIDA7XG5jb25zdCBuYWNsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ0d2VldG5hY2xcIikpO1xuY29uc3QgbmFjbFV0aWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInR3ZWV0bmFjbC11dGlsXCIpKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogRW5jcnlwdCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZW5jcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgb2YgdGhlIG1lc3NhZ2UgcmVjaXBpZW50LlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSBtZXNzYWdlIGRhdGEuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHR5cGUgb2YgZW5jcnlwdGlvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgZW5jcnlwdGVkIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGVuY3J5cHQoeyBwdWJsaWNLZXksIGRhdGEsIHZlcnNpb24sIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShwdWJsaWNLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwdWJsaWNLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkodmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHZlcnNpb24gcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICBjYXNlICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXNzYWdlIGRhdGEgbXVzdCBiZSBnaXZlbiBhcyBhIHN0cmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2VuZXJhdGUgZXBoZW1lcmFsIGtleXBhaXJcbiAgICAgICAgICAgIGNvbnN0IGVwaGVtZXJhbEtleVBhaXIgPSBuYWNsLmJveC5rZXlQYWlyKCk7XG4gICAgICAgICAgICAvLyBhc3NlbWJsZSBlbmNyeXB0aW9uIHBhcmFtZXRlcnMgLSBmcm9tIHN0cmluZyB0byBVSW50OFxuICAgICAgICAgICAgbGV0IHB1YktleVVJbnQ4QXJyYXk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHB1YktleVVJbnQ4QXJyYXkgPSBuYWNsVXRpbC5kZWNvZGVCYXNlNjQocHVibGljS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBwdWJsaWMga2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtc2dQYXJhbXNVSW50OEFycmF5ID0gbmFjbFV0aWwuZGVjb2RlVVRGOChkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gbmFjbC5yYW5kb21CeXRlcyhuYWNsLmJveC5ub25jZUxlbmd0aCk7XG4gICAgICAgICAgICAvLyBlbmNyeXB0XG4gICAgICAgICAgICBjb25zdCBlbmNyeXB0ZWRNZXNzYWdlID0gbmFjbC5ib3gobXNnUGFyYW1zVUludDhBcnJheSwgbm9uY2UsIHB1YktleVVJbnQ4QXJyYXksIGVwaGVtZXJhbEtleVBhaXIuc2VjcmV0S2V5KTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBlbmNyeXB0ZWQgZGF0YVxuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246ICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnLFxuICAgICAgICAgICAgICAgIG5vbmNlOiBuYWNsVXRpbC5lbmNvZGVCYXNlNjQobm9uY2UpLFxuICAgICAgICAgICAgICAgIGVwaGVtUHVibGljS2V5OiBuYWNsVXRpbC5lbmNvZGVCYXNlNjQoZXBoZW1lcmFsS2V5UGFpci5wdWJsaWNLZXkpLFxuICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IG5hY2xVdGlsLmVuY29kZUJhc2U2NChlbmNyeXB0ZWRNZXNzYWdlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyByZXR1cm4gZW5jcnlwdGVkIG1zZyBkYXRhXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gdHlwZS92ZXJzaW9uIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG59XG5leHBvcnRzLmVuY3J5cHQgPSBlbmNyeXB0O1xuLyoqXG4gKiBFbmNyeXB0IGEgbWVzc2FnZSBpbiBhIHdheSB0aGF0IG9ic2N1cmVzIHRoZSBtZXNzYWdlIGxlbmd0aC5cbiAqXG4gKiBUaGUgbWVzc2FnZSBpcyBwYWRkZWQgdG8gYSBtdWx0aXBsZSBvZiAyMDQ4IGJlZm9yZSBiZWluZyBlbmNyeXB0ZWQgc28gdGhhdCB0aGUgbGVuZ3RoIG9mIHRoZVxuICogcmVzdWx0aW5nIGVuY3J5cHRlZCBtZXNzYWdlIGNhbid0IGJlIHVzZWQgdG8gZ3Vlc3MgdGhlIGV4YWN0IGxlbmd0aCBvZiB0aGUgb3JpZ2luYWwgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBlbmNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvZiB0aGUgbWVzc2FnZSByZWNpcGllbnQuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIG1lc3NhZ2UgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zLnZlcnNpb24gLSBUaGUgdHlwZSBvZiBlbmNyeXB0aW9uIHRvIHVzZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNyeXB0ZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZW5jcnlwdFNhZmVseSh7IHB1YmxpY0tleSwgZGF0YSwgdmVyc2lvbiwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHB1YmxpY0tleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHB1YmxpY0tleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKSh2ZXJzaW9uKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmVyc2lvbiBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgREVGQVVMVF9QQURESU5HX0xFTkdUSCA9IDIgKiogMTE7XG4gICAgY29uc3QgTkFDTF9FWFRSQV9CWVRFUyA9IDE2O1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YSAmJiAndG9KU09OJyBpbiBkYXRhKSB7XG4gICAgICAgIC8vIHJlbW92ZSB0b0pTT04gYXR0YWNrIHZlY3RvclxuICAgICAgICAvLyBUT0RPLCBjaGVjayBhbGwgcG9zc2libGUgY2hpbGRyZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZW5jcnlwdCB3aXRoIHRvSlNPTiBwcm9wZXJ0eS4gIFBsZWFzZSByZW1vdmUgdG9KU09OIHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIC8vIGFkZCBwYWRkaW5nXG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0ge1xuICAgICAgICBkYXRhLFxuICAgICAgICBwYWRkaW5nOiAnJyxcbiAgICB9O1xuICAgIC8vIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KGRhdGFXaXRoUGFkZGluZyksICd1dGYtOCcpO1xuICAgIGNvbnN0IG1vZFZhbCA9IGRhdGFMZW5ndGggJSBERUZBVUxUX1BBRERJTkdfTEVOR1RIO1xuICAgIGxldCBwYWRMZW5ndGggPSAwO1xuICAgIC8vIE9ubHkgcGFkIGlmIG5lY2Vzc2FyeVxuICAgIGlmIChtb2RWYWwgPiAwKSB7XG4gICAgICAgIHBhZExlbmd0aCA9IERFRkFVTFRfUEFERElOR19MRU5HVEggLSBtb2RWYWwgLSBOQUNMX0VYVFJBX0JZVEVTOyAvLyBuYWNsIGV4dHJhIGJ5dGVzXG4gICAgfVxuICAgIGRhdGFXaXRoUGFkZGluZy5wYWRkaW5nID0gJzAnLnJlcGVhdChwYWRMZW5ndGgpO1xuICAgIGNvbnN0IHBhZGRlZE1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpO1xuICAgIHJldHVybiBlbmNyeXB0KHsgcHVibGljS2V5LCBkYXRhOiBwYWRkZWRNZXNzYWdlLCB2ZXJzaW9uIH0pO1xufVxuZXhwb3J0cy5lbmNyeXB0U2FmZWx5ID0gZW5jcnlwdFNhZmVseTtcbi8qKlxuICogRGVjcnlwdCBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZGVjcnlwdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZW5jcnlwdGVkRGF0YSAtIFRoZSBlbmNyeXB0ZWQgZGF0YS5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gZGVjcnlwdCB3aXRoLlxuICogQHJldHVybnMgVGhlIGRlY3J5cHRlZCBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBkZWNyeXB0KHsgZW5jcnlwdGVkRGF0YSwgcHJpdmF0ZUtleSwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKGVuY3J5cHRlZERhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBlbmNyeXB0ZWREYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlS2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGVuY3J5cHRlZERhdGEudmVyc2lvbikge1xuICAgICAgICBjYXNlICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnOiB7XG4gICAgICAgICAgICAvLyBzdHJpbmcgdG8gYnVmZmVyIHRvIFVJbnQ4QXJyYXlcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVyUHJpdmF0ZUtleVVpbnQ4QXJyYXkgPSBuYWNsRGVjb2RlSGV4KHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgY29uc3QgcmVjZWl2ZXJFbmNyeXB0aW9uUHJpdmF0ZUtleSA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleShyZWNlaXZlclByaXZhdGVLZXlVaW50OEFycmF5KS5zZWNyZXRLZXk7XG4gICAgICAgICAgICAvLyBhc3NlbWJsZSBkZWNyeXB0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEubm9uY2UpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG5hY2xVdGlsLmRlY29kZUJhc2U2NChlbmNyeXB0ZWREYXRhLmNpcGhlcnRleHQpO1xuICAgICAgICAgICAgY29uc3QgZXBoZW1QdWJsaWNLZXkgPSBuYWNsVXRpbC5kZWNvZGVCYXNlNjQoZW5jcnlwdGVkRGF0YS5lcGhlbVB1YmxpY0tleSk7XG4gICAgICAgICAgICAvLyBkZWNyeXB0XG4gICAgICAgICAgICBjb25zdCBkZWNyeXB0ZWRNZXNzYWdlID0gbmFjbC5ib3gub3BlbihjaXBoZXJ0ZXh0LCBub25jZSwgZXBoZW1QdWJsaWNLZXksIHJlY2VpdmVyRW5jcnlwdGlvblByaXZhdGVLZXkpO1xuICAgICAgICAgICAgLy8gcmV0dXJuIGRlY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIWRlY3J5cHRlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IG5hY2xVdGlsLmVuY29kZVVURjgoZGVjcnlwdGVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBwcm9iYWJseSBleHRyYW5lb3VzIGJ1dCB3YXMga2VwdCB0byBtaW5pbWl6ZSBjaGFuZ2VzIGR1cmluZyByZWZhY3RvclxuICAgICAgICAgICAgICAgIGlmICghb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJyAmJiBlcnIubWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNyeXB0aW9uIGZhaWxlZDogJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEZWNyeXB0aW9uIGZhaWxlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIHR5cGUvdmVyc2lvbiBub3Qgc3VwcG9ydGVkLicpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjcnlwdCA9IGRlY3J5cHQ7XG4vKipcbiAqIERlY3J5cHQgYSBtZXNzYWdlIHRoYXQgaGFzIGJlZW4gZW5jcnlwdGVkIHVzaW5nIGBlbmNyeXB0U2FmZWx5YC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBkZWNyeXB0aW9uIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5lbmNyeXB0ZWREYXRhIC0gVGhlIGVuY3J5cHRlZCBkYXRhLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSB0byBkZWNyeXB0IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgZGVjcnlwdGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHRTYWZlbHkoeyBlbmNyeXB0ZWREYXRhLCBwcml2YXRlS2V5LCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZW5jcnlwdGVkRGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGVuY3J5cHRlZERhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHByaXZhdGVLZXkgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFXaXRoUGFkZGluZyA9IEpTT04ucGFyc2UoZGVjcnlwdCh7IGVuY3J5cHRlZERhdGEsIHByaXZhdGVLZXkgfSkpO1xuICAgIHJldHVybiBkYXRhV2l0aFBhZGRpbmcuZGF0YTtcbn1cbmV4cG9ydHMuZGVjcnlwdFNhZmVseSA9IGRlY3J5cHRTYWZlbHk7XG4vKipcbiAqIEdldCB0aGUgZW5jcnlwdGlvbiBwdWJsaWMga2V5IGZvciB0aGUgZ2l2ZW4ga2V5LlxuICpcbiAqIEBwYXJhbSBwcml2YXRlS2V5IC0gVGhlIHByaXZhdGUga2V5IHRvIGdlbmVyYXRlIHRoZSBlbmNyeXB0aW9uIHB1YmxpYyBrZXkgd2l0aC5cbiAqIEByZXR1cm5zIFRoZSBlbmNyeXB0aW9uIHB1YmxpYyBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldEVuY3J5cHRpb25QdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IHByaXZhdGVLZXlVaW50OEFycmF5ID0gbmFjbERlY29kZUhleChwcml2YXRlS2V5KTtcbiAgICBjb25zdCBlbmNyeXB0aW9uUHVibGljS2V5ID0gbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXlVaW50OEFycmF5KS5wdWJsaWNLZXk7XG4gICAgcmV0dXJuIG5hY2xVdGlsLmVuY29kZUJhc2U2NChlbmNyeXB0aW9uUHVibGljS2V5KTtcbn1cbmV4cG9ydHMuZ2V0RW5jcnlwdGlvblB1YmxpY0tleSA9IGdldEVuY3J5cHRpb25QdWJsaWNLZXk7XG4vKipcbiAqIENvbnZlcnQgYSBoZXggc3RyaW5nIHRvIHRoZSBVSW50OEFycmF5IGZvcm1hdCB1c2VkIGJ5IG5hY2wuXG4gKlxuICogQHBhcmFtIG1zZ0hleCAtIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBuYWNsRGVjb2RlSGV4KG1zZ0hleCkge1xuICAgIGNvbnN0IG1zZ0Jhc2U2NCA9IEJ1ZmZlci5mcm9tKG1zZ0hleCwgJ2hleCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXR1cm4gbmFjbFV0aWwuZGVjb2RlQmFzZTY0KG1zZ0Jhc2U2NCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmNyeXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyogZXNsaW50IGpzZG9jL3JlcXVpcmUtZGVzY3JpcHRpb246IDAgKi9cbi8qIGVzbGludCBqc2RvYy9yZXF1aXJlLXJldHVybnM6IDAgKi9cbi8qIGVzbGludCBqc2RvYy9tYXRjaC1kZXNjcmlwdGlvbjogMCAqL1xuLyogZXNsaW50IGpzZG9jL3JlcXVpcmUtcGFyYW0tZGVzY3JpcHRpb246IDAgKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmF3RW5jb2RlID0gZXhwb3J0cy5wYXJzZU51bWJlciA9IGV4cG9ydHMuc29saWRpdHlQYWNrID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3V0aWxcIik7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCBldGhqc191dGlsXzEgPSByZXF1aXJlKFwiZXRoanMtdXRpbFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8vXG4vLyBNZXRob2RzIGJvcnJvd2VkIGFuZCBzb21ld2hhdCBhZGFwdGVkIGZyb20gZXRoZXJldW1qcy1hYmlAMC42Ljg6XG4vLyBodHRwczovL25wbWZzLmNvbS9wYWNrYWdlL2V0aGVyZXVtanMtYWJpLzAuNi44L2xpYi9pbmRleC5qc1xuLy9cbi8qKlxuICogUGFja3Mgbm9uLXN0YW5kYXJkIGVuY29kZWQgdmFsdWVzIHBhY2tlZCBhY2NvcmRpbmcgdG8gdGhlaXIgcmVzcGVjdGl2ZSB0eXBlIGluIHR5cGVzIGluIGEgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB0eXBlcyAtIEFycmF5IG9mIHR5cGVzIG9mIGVhY2ggdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIHZhbHVlcyAtIEFycmF5IG9mIHZhbHVlcyB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBBIGJ1ZmZlciBjb250YWluaW5nIHRoZSBwYWNrZWQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzb2xpZGl0eVBhY2sodHlwZXMsIHZhbHVlcykge1xuICAgIGlmICh0eXBlcy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgb2YgdHlwZXMgYXJlIG5vdCBtYXRjaGluZyB0aGUgdmFsdWVzJyk7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGVsZW1lbnRhcnlOYW1lKHR5cGVzW2ldKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgIHJldC5wdXNoKHNvbGlkaXR5SGV4VmFsdWUodHlwZSwgdmFsdWUsIG51bGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KTtcbn1cbmV4cG9ydHMuc29saWRpdHlQYWNrID0gc29saWRpdHlQYWNrO1xuLyoqXG4gKiBDaGVja3MgaWYgYSB2YWx1ZSBpcyBhbiBhcnJheSAocmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcpLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHZhbHVlIHRvIGNoZWNrIHdoZXRoZXIgaXQgaXMgYW4gYXJyYXkuXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXNzZWQgdmFsdWUgaXMgYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodHlwZSkge1xuICAgIHJldHVybiB0eXBlLmVuZHNXaXRoKCddJyk7XG59XG4vKipcbiAqIFBhcnNlIGFycmF5IHR5cGUgZm9yIHBhY2tpbmcgc29saWRpdHkgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gQSBzdHJpbmcgdGhhdCBtYXkgYmUgYW4gYXJyYXkgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBBIHBhcnNlZCB2YWx1ZSBmcm9tIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VUeXBlQXJyYXkodHlwZSkge1xuICAgIGNvbnN0IHRtcCA9IHR5cGUubWF0Y2goLyguKilcXFsoLio/KVxcXSQvdSk7XG4gICAgaWYgKHRtcCkge1xuICAgICAgICByZXR1cm4gdG1wWzJdID09PSAnJyA/ICdkeW5hbWljJyA6IHBhcnNlSW50KHRtcFsyXSwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogUGFyc2UgTiBmcm9tIHR5cGU8Tj4uXG4gKlxuICogQHBhcmFtIHR5cGUgLSBWYWx1ZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFBhcnNlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VUeXBlTih0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSAvXlxcRCsoXFxkKykkL3UuZXhlYyh0eXBlKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcnNlVHlwZU4gaW5wdXQgXCIke3R5cGV9XCIuYCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSwgMTApO1xufVxuLyoqXG4gKiBQYXJzZSBhIG51bWJlciBmb3IgZGV0ZXJtaW5pbmcgYSBzb2xpZGl0eSBoZXh2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gYXJnIC0gTnVtYmVyIHRvIHBhcnNlLlxuICogQHJldHVybnMgUGFyc2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJzZU51bWJlcihhcmcpIHtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGFyZztcbiAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCgwLCB1dGlsXzEuaXNIZXhQcmVmaXhlZCkoYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoKDAsIGV0aGpzX3V0aWxfMS5zdHJpcEhleFByZWZpeCkoYXJnKSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGFyZywgMTApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChhcmcpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoYXJnICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmcsICd0b0FycmF5JykpIHx8XG4gICAgICAgIGJuX2pzXzEuZGVmYXVsdC5pc0JOKGFyZykpIHtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBudW1iZXInKTtcbn1cbmV4cG9ydHMucGFyc2VOdW1iZXIgPSBwYXJzZU51bWJlcjtcbi8qKlxuICogR2V0IHNvbGlkaXR5IGhleCB2YWx1ZSBmcm9tIHR5cGUsIHZhbHVlIGFuZCBiaXRzaXplIGlucHV0cyBmb3IgcGFja2luZyB0aGVzZSB2YWx1ZXMgaW4gYSBidWZmZXIuXG4gKlxuICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBiaXRzaXplIC0gVGhlIGJpdHNpemUgb2YgdGhlIHZhbHVlIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHNvbGRpdHkgaGV4IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzb2xpZGl0eUhleFZhbHVlKHR5cGUsIHZhbHVlLCBiaXRzaXplKSB7XG4gICAgLy8gcGFzcyBpbiBiaXRzaXplID0gbnVsbCBpZiB1c2UgZGVmYXVsdCBiaXRzaXplXG4gICAgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgY29uc3Qgc3ViVHlwZSA9IHR5cGUucmVwbGFjZSgvXFxbLio/XFxdL3UsICcnKTtcbiAgICAgICAgaWYgKCFpc0FycmF5KHN1YlR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJheVNpemUgPSBwYXJzZVR5cGVBcnJheSh0eXBlKTtcbiAgICAgICAgICAgIGlmIChhcnJheVNpemUgIT09ICdkeW5hbWljJyAmJlxuICAgICAgICAgICAgICAgIGFycmF5U2l6ZSAhPT0gMCAmJlxuICAgICAgICAgICAgICAgIGFycmF5U2l6ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHZhbHVlLmxlbmd0aCA+IGFycmF5U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRWxlbWVudHMgZXhjZWVkIGFycmF5IHNpemU6ICR7YXJyYXlTaXplfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFycmF5VmFsdWVzID0gdmFsdWUubWFwKCh2KSA9PiBzb2xpZGl0eUhleFZhbHVlKHN1YlR5cGUsIHYsIDI1NikpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChhcnJheVZhbHVlcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICd1dGY4Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgYml0c2l6ZSA9IGJpdHNpemUgfHwgODtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IEFycmF5KGJpdHNpemUgLyA0KS5qb2luKCcwJyk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSA/IGAke3BhZGRpbmd9MWAgOiBgJHtwYWRkaW5nfTBgLCAnaGV4Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICBsZXQgYnl0ZXNpemUgPSAyMDtcbiAgICAgICAgaWYgKGJpdHNpemUpIHtcbiAgICAgICAgICAgIGJ5dGVzaXplID0gYml0c2l6ZSAvIDg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuc2V0TGVuZ3RoTGVmdCkoKDAsIHV0aWxfMS50b0J1ZmZlcikodmFsdWUpLCBieXRlc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSkge1xuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VUeXBlTih0eXBlKTtcbiAgICAgICAgaWYgKHNpemUgPCAxIHx8IHNpemUgPiAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ5dGVzPE4+IHdpZHRoOiAke3NpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzEubm9ybWFsaXplKSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuc2V0TGVuZ3RoUmlnaHQpKCgwLCB1dGlsXzEudG9CdWZmZXIpKHZhbHVlKSwgc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUuc3RhcnRzV2l0aCgndWludCcpKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpO1xuICAgICAgICBpZiAoc2l6ZSAlIDggfHwgc2l6ZSA8IDggfHwgc2l6ZSA+IDI1Nikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHVpbnQ8Tj4gd2lkdGg6ICR7c2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSBwYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1cHBsaWVkIHVpbnQgZXhjZWVkcyB3aWR0aDogJHtzaXplfSB2cyAke251bS5iaXRMZW5ndGgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgYml0c2l6ZSA9IGJpdHNpemUgfHwgc2l6ZTtcbiAgICAgICAgcmV0dXJuIG51bS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIGJpdHNpemUgLyA4KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VUeXBlTih0eXBlKTtcbiAgICAgICAgaWYgKHNpemUgJSA4IHx8IHNpemUgPCA4IHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnQ8Tj4gd2lkdGg6ICR7c2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSBwYXJzZU51bWJlcih2YWx1ZSk7XG4gICAgICAgIGlmIChudW0uYml0TGVuZ3RoKCkgPiBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1cHBsaWVkIGludCBleGNlZWRzIHdpZHRoOiAke3NpemV9IHZzICR7bnVtLmJpdExlbmd0aCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLW51bGxpc2gtY29hbGVzY2luZ1xuICAgICAgICBiaXRzaXplID0gYml0c2l6ZSB8fCBzaXplO1xuICAgICAgICByZXR1cm4gbnVtLnRvVHdvcyhzaXplKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIGJpdHNpemUgLyA4KTtcbiAgICB9XG4gICAgLy8gRklYTUU6IHN1cHBvcnQgYWxsIG90aGVyIHR5cGVzXG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9YCk7XG59XG4vKipcbiAqIEdldHMgdGhlIGNvcnJlY3Qgc29saWRpdHkgdHlwZSBuYW1lLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIHR5cGUgbmFtZSBmb3Igd2hpY2ggd2Ugd2FudCB0aGUgY29ycmVzcG9uZGluZyBzb2xpZGl0eSB0eXBlIG5hbWUuXG4gKiBAcmV0dXJucyBUaGUgc29saWRpdHkgdHlwZSBuYW1lIGZvciB0aGUgaW5wdXQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGVsZW1lbnRhcnlOYW1lKG5hbWUpIHtcbiAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdpbnRbJykpIHtcbiAgICAgICAgcmV0dXJuIGBpbnQyNTYke25hbWUuc2xpY2UoMyl9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2ludCcpIHtcbiAgICAgICAgcmV0dXJuICdpbnQyNTYnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VpbnRbJykpIHtcbiAgICAgICAgcmV0dXJuIGB1aW50MjU2JHtuYW1lLnNsaWNlKDQpfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICd1aW50Jykge1xuICAgICAgICByZXR1cm4gJ3VpbnQyNTYnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2ZpeGVkWycpKSB7XG4gICAgICAgIHJldHVybiBgZml4ZWQxMjh4MTI4JHtuYW1lLnNsaWNlKDUpfWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hbWUgPT09ICdmaXhlZCcpIHtcbiAgICAgICAgcmV0dXJuICdmaXhlZDEyOHgxMjgnO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ3VmaXhlZFsnKSkge1xuICAgICAgICByZXR1cm4gYHVmaXhlZDEyOHgxMjgke25hbWUuc2xpY2UoNil9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3VmaXhlZCcpIHtcbiAgICAgICAgcmV0dXJuICd1Zml4ZWQxMjh4MTI4JztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vKipcbiAqIEBwYXJhbSB0eXBlc1xuICogQHBhcmFtIHZhbHVlc1xuICovXG5mdW5jdGlvbiByYXdFbmNvZGUodHlwZXMsIHZhbHVlcykge1xuICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICBsZXQgaGVhZExlbmd0aCA9IDA7XG4gICAgdHlwZXMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlVHlwZUFycmF5KHR5cGUpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lZ2F0ZWQtY29uZGl0aW9uXG4gICAgICAgICAgICBpZiAoc2l6ZSAhPT0gJ2R5bmFtaWMnICYmIHNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBoZWFkTGVuZ3RoICs9IDMyICogc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlYWRMZW5ndGggKz0gMzI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkTGVuZ3RoICs9IDMyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0eXBlID0gZWxlbWVudGFyeU5hbWUodHlwZXNbaV0pO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgY29uc3QgY3VyID0gZW5jb2RlU2luZ2xlKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgLy8gVXNlIHRoZSBoZWFkL3RhaWwgbWV0aG9kIGZvciBzdG9yaW5nIGR5bmFtaWMgZGF0YVxuICAgICAgICBpZiAoaXNEeW5hbWljKHR5cGUpKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBoZWFkTGVuZ3RoKSk7XG4gICAgICAgICAgICBkYXRhLnB1c2goY3VyKTtcbiAgICAgICAgICAgIGhlYWRMZW5ndGggKz0gY3VyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGN1cik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQob3V0cHV0LmNvbmNhdChkYXRhKSk7XG59XG5leHBvcnRzLnJhd0VuY29kZSA9IHJhd0VuY29kZTtcbi8vIEVuY29kZXMgYSBzaW5nbGUgaXRlbSAoY2FuIGJlIGR5bmFtaWMgYXJyYXkpXG4vLyBAcmV0dXJuczogQnVmZmVyXG4vKipcbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gYXJnXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVNpbmdsZSh0eXBlLCBhcmcpIHtcbiAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQxNjAnLCBwYXJzZU51bWJlcihhcmcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVTaW5nbGUoJ3VpbnQ4JywgYXJnID8gMSA6IDApO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCdieXRlcycsIEJ1ZmZlci5mcm9tKGFyZywgJ3V0ZjgnKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgLy8gdGhpcyBwYXJ0IGhhbmRsZXMgZml4ZWQtbGVuZ3RoIChbMl0pIGFuZCB2YXJpYWJsZSBsZW5ndGggKFtdKSBhcnJheXNcbiAgICAgICAgLy8gTk9URTogd2UgY2F0Y2ggaGVyZSBhbGwgY2FsbHMgdG8gYXJyYXlzLCB0aGF0IHNpbXBsaWZpZXMgdGhlIHJlc3RcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcubGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgYW4gYXJyYXk/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlVHlwZUFycmF5KHR5cGUpO1xuICAgICAgICBpZiAoc2l6ZSAhPT0gJ2R5bmFtaWMnICYmXG4gICAgICAgICAgICBzaXplICE9PSAwICYmXG4gICAgICAgICAgICBzaXplICE9PSBudWxsICYmXG4gICAgICAgICAgICBhcmcubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbGVtZW50cyBleGNlZWQgYXJyYXkgc2l6ZTogJHtzaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IFtdO1xuICAgICAgICB0eXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpO1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFyZyA9IEpTT04ucGFyc2UoYXJnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBpZiB0aGlzIGlzIGFycmF5LCBzaG91bGQgZG8gZm9yLW9mXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiBhcmcpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJnLCBpKSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKGVuY29kZVNpbmdsZSh0eXBlLCBhcmdbaV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l6ZSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGVTaW5nbGUoJ3VpbnQyNTYnLCBhcmcubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldC51bnNoaWZ0KGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQocmV0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICBhcmcgPSBCdWZmZXIuZnJvbShhcmcpO1xuICAgICAgICBsZXQgcmV0ID0gQnVmZmVyLmNvbmNhdChbZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgYXJnLmxlbmd0aCksIGFyZ10pO1xuICAgICAgICBpZiAoYXJnLmxlbmd0aCAlIDMyICE9PSAwKSB7XG4gICAgICAgICAgICByZXQgPSBCdWZmZXIuY29uY2F0KFtyZXQsICgwLCB1dGlsXzEuemVyb3MpKDMyIC0gKGFyZy5sZW5ndGggJSAzMikpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdieXRlcycpKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZVR5cGVOKHR5cGUpO1xuICAgICAgICBpZiAoc2l6ZSA8IDEgfHwgc2l6ZSA+IDMyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnl0ZXM8Tj4gd2lkdGg6ICR7c2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBmaXggdHlwZXMgaGVyZVxuICAgICAgICBjb25zdCBuQXJnID0gdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgPyAoMCwgdXRpbHNfMS5ub3JtYWxpemUpKGFyZykgOiBhcmc7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbF8xLnNldExlbmd0aFJpZ2h0KSgoMCwgdXRpbF8xLnRvQnVmZmVyKShuQXJnKSwgMzIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VUeXBlTih0eXBlKTtcbiAgICAgICAgaWYgKHNpemUgJSA4IHx8IHNpemUgPCA4IHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB1aW50PE4+IHdpZHRoOiAke3NpemV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVtID0gcGFyc2VOdW1iZXIoYXJnKTtcbiAgICAgICAgaWYgKG51bS5iaXRMZW5ndGgoKSA+IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3VwcGxpZWQgdWludCBleGNlZWRzIHdpZHRoOiAke3NpemV9IHZzICR7bnVtLmJpdExlbmd0aCgpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChudW0uaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50IGlzIG5lZ2F0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICBjb25zdCBzaXplID0gcGFyc2VUeXBlTih0eXBlKTtcbiAgICAgICAgaWYgKHNpemUgJSA4IHx8IHNpemUgPCA4IHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBpbnQ8Tj4gd2lkdGg6ICR7c2l6ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW0gPSBwYXJzZU51bWJlcihhcmcpO1xuICAgICAgICBpZiAobnVtLmJpdExlbmd0aCgpID4gc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdXBwbGllZCBpbnQgZXhjZWVkcyB3aWR0aDogJHtzaXplfSB2cyAke251bS5iaXRMZW5ndGgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtLnRvVHdvcygyNTYpLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VmaXhlZCcpKSB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZVR5cGVOeE0odHlwZSk7XG4gICAgICAgIGNvbnN0IG51bSA9IHBhcnNlTnVtYmVyKGFyZyk7XG4gICAgICAgIGlmIChudW0uaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1Zml4ZWQgaXMgbmVnYXRpdmUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlU2luZ2xlKCd1aW50MjU2JywgbnVtLm11bChuZXcgYm5fanNfMS5kZWZhdWx0KDIpLnBvdyhuZXcgYm5fanNfMS5kZWZhdWx0KHNpemVbMV0pKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ2ZpeGVkJykpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlVHlwZU54TSh0eXBlKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZVNpbmdsZSgnaW50MjU2JywgcGFyc2VOdW1iZXIoYXJnKS5tdWwobmV3IGJuX2pzXzEuZGVmYXVsdCgyKS5wb3cobmV3IGJuX2pzXzEuZGVmYXVsdChzaXplWzFdKSkpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvciBpbnZhbGlkIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9YCk7XG59XG4vLyBJcyBhIHR5cGUgZHluYW1pYz9cbi8qKlxuICogQHBhcmFtIHR5cGVcbiAqL1xuZnVuY3Rpb24gaXNEeW5hbWljKHR5cGUpIHtcbiAgICAvLyBGSVhNRTogaGFuZGxlIGFsbCB0eXBlcz8gSSBkb24ndCB0aGluayBhbnl0aGluZyBpcyBtaXNzaW5nIG5vd1xuICAgIHJldHVybiAodHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZSA9PT0gJ2J5dGVzJyB8fCBwYXJzZVR5cGVBcnJheSh0eXBlKSA9PT0gJ2R5bmFtaWMnKTtcbn1cbi8vIFBhcnNlIE4sTSBmcm9tIHR5cGU8Tj54PE0+XG4vKipcbiAqIEBwYXJhbSB0eXBlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVHlwZU54TSh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2ggPSAvXlxcRCsoXFxkKyl4KFxcZCspJC91LmV4ZWModHlwZSk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcnNlVHlwZU54TSBpbnB1dCBcIiR7dHlwZX1cIi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFtwYXJzZUludChtYXRjaFsxXSwgMTApLCBwYXJzZUludChtYXRjaFsyXSwgMTApXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0aGVyZXVtanMtYWJpLXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IGV4cG9ydHMuY29uY2F0U2lnID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3BlcnNvbmFsLXNpZ25cIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3NpZ24tdHlwZWQtZGF0YVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZW5jcnlwdGlvblwiKSwgZXhwb3J0cyk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0U2lnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmNvbmNhdFNpZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vcm1hbGl6ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5ub3JtYWxpemU7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4cG9ydHMucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlID0gZXhwb3J0cy5wZXJzb25hbFNpZ24gPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8qKlxuICogQ3JlYXRlIGFuIEV0aGVyZXVtLXNwZWNpZmljIHNpZ25hdHVyZSBmb3IgYSBtZXNzYWdlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXF1aXZhbGVudCB0byB0aGUgYGV0aF9zaWduYCBFdGhlcmV1bSBKU09OLVJQQyBtZXRob2QgYXMgc3BlY2lmaWVkIGluIEVJUC0xNDE3LFxuICogYXMgd2VsbCBhcyB0aGUgTWV0YU1hc2sncyBgcGVyc29uYWxfc2lnbmAgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHBlcnNvbmFsIHNpZ24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUga2V5IHRvIHNpZ24gd2l0aC5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgaGV4IGRhdGEgdG8gc2lnbi5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZnVuY3Rpb24gcGVyc29uYWxTaWduKHsgcHJpdmF0ZUtleSwgZGF0YSwgfSkge1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlS2V5IHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gKDAsIHV0aWxzXzEubGVnYWN5VG9CdWZmZXIpKGRhdGEpO1xuICAgIGNvbnN0IG1zZ0hhc2ggPSAoMCwgdXRpbF8xLmhhc2hQZXJzb25hbE1lc3NhZ2UpKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHNpZyA9ICgwLCB1dGlsXzEuZWNzaWduKShtc2dIYXNoLCBwcml2YXRlS2V5KTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gKDAsIHV0aWxzXzEuY29uY2F0U2lnKSgoMCwgdXRpbF8xLnRvQnVmZmVyKShzaWcudiksIHNpZy5yLCBzaWcucyk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5leHBvcnRzLnBlcnNvbmFsU2lnbiA9IHBlcnNvbmFsU2lnbjtcbi8qKlxuICogUmVjb3ZlciB0aGUgYWRkcmVzcyBvZiB0aGUgYWNjb3VudCB1c2VkIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gRXRoZXJldW0gc2lnbmF0dXJlLiBUaGUgbWVzc2FnZVxuICogbXVzdCBoYXZlIGJlZW4gc2lnbmVkIHVzaW5nIHRoZSBgcGVyc29uYWxTaWduYCBmdW5jdGlvbiwgb3IgYW4gZXF1aXZhbGVudCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBzaWduYXR1cmUgcmVjb3Zlcnkgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLmRhdGEgLSBUaGUgaGV4IGRhdGEgdGhhdCB3YXMgc2lnbmVkLlxuICogQHBhcmFtIG9wdGlvbnMuc2lnbmF0dXJlIC0gVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgbWVzc2FnZSBzaWduYXR1cmUuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBhZGRyZXNzIG9mIHRoZSBtZXNzYWdlIHNpZ25lci5cbiAqL1xuZnVuY3Rpb24gcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlKHsgZGF0YSwgc2lnbmF0dXJlLCB9KSB7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IoZGF0YSwgc2lnbmF0dXJlKTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykocHVibGljS2V5KTtcbiAgICBjb25zdCBzZW5kZXJIZXggPSAoMCwgdXRpbF8xLmJ1ZmZlclRvSGV4KShzZW5kZXIpO1xuICAgIHJldHVybiBzZW5kZXJIZXg7XG59XG5leHBvcnRzLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZSA9IHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZTtcbi8qKlxuICogUmVjb3ZlciB0aGUgcHVibGljIGtleSBvZiB0aGUgYWNjb3VudCB1c2VkIHRvIGNyZWF0ZSB0aGUgZ2l2ZW4gRXRoZXJldW0gc2lnbmF0dXJlLiBUaGUgbWVzc2FnZVxuICogbXVzdCBoYXZlIGJlZW4gc2lnbmVkIHVzaW5nIHRoZSBgcGVyc29uYWxTaWduYCBmdW5jdGlvbiwgb3IgYW4gZXF1aXZhbGVudCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwdWJsaWMga2V5IHJlY292ZXJ5IG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy5kYXRhIC0gVGhlIGhleCBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBvcHRpb25zLnNpZ25hdHVyZSAtIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIG1lc3NhZ2Ugc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlICcweCctcHJlZml4ZWQgaGV4IGVuY29kZWQgcHVibGljIGtleSBvZiB0aGUgbWVzc2FnZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQdWJsaWNLZXkoeyBkYXRhLCBzaWduYXR1cmUsIH0pIHtcbiAgICBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShkYXRhKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZGF0YSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIHV0aWxzXzEuaXNOdWxsaXNoKShzaWduYXR1cmUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBzaWduYXR1cmUgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleUZvcihkYXRhLCBzaWduYXR1cmUpO1xuICAgIHJldHVybiBgMHgke3B1YmxpY0tleS50b1N0cmluZygnaGV4Jyl9YDtcbn1cbmV4cG9ydHMuZXh0cmFjdFB1YmxpY0tleSA9IGV4dHJhY3RQdWJsaWNLZXk7XG4vKipcbiAqIEdldCB0aGUgcHVibGljIGtleSBmb3IgdGhlIGdpdmVuIHNpZ25hdHVyZSBhbmQgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBtZXNzYWdlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFB1YmxpY0tleUZvcihtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9ICgwLCB1dGlsXzEuaGFzaFBlcnNvbmFsTWVzc2FnZSkoKDAsIHV0aWxzXzEubGVnYWN5VG9CdWZmZXIpKG1lc3NhZ2UpKTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEucmVjb3ZlclB1YmxpY0tleSkobWVzc2FnZUhhc2gsIHNpZ25hdHVyZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJzb25hbC1zaWduLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvdmVyVHlwZWRTaWduYXR1cmUgPSBleHBvcnRzLnNpZ25UeXBlZERhdGEgPSBleHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMgPSBleHBvcnRzLlRZUEVEX01FU1NBR0VfU0NIRU1BID0gZXhwb3J0cy5TaWduVHlwZWREYXRhVmVyc2lvbiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJAZXRoZXJldW1qcy91dGlsXCIpO1xuY29uc3Qga2VjY2FrXzEgPSByZXF1aXJlKFwiZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2Nha1wiKTtcbmNvbnN0IGV0aGpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhqcy11dGlsXCIpO1xuY29uc3QgZXRoZXJldW1qc19hYmlfdXRpbHNfMSA9IHJlcXVpcmUoXCIuL2V0aGVyZXVtanMtYWJpLXV0aWxzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSB2ZXJzaW9uIG9mIGBzaWduVHlwZWREYXRhYCBiZWluZyB1c2VkLlxuICpcbiAqIFYxIGlzIGJhc2VkIHVwb24gW2FuIGVhcmx5IHZlcnNpb24gb2YgRUlQLTcxMl0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvcHVsbC83MTIvY29tbWl0cy8yMWFiZTI1NGZlMDQ1MmQ4NTgzZDViMTMyYjFkN2JlODdjMDQzOWNhKVxuICogdGhhdCBsYWNrZWQgc29tZSBsYXRlciBzZWN1cml0eSBpbXByb3ZlbWVudHMsIGFuZCBzaG91bGQgZ2VuZXJhbGx5IGJlIG5lZ2xlY3RlZCBpbiBmYXZvciBvZlxuICogbGF0ZXIgdmVyc2lvbnMuXG4gKlxuICogVjMgaXMgYmFzZWQgb24gRUlQLTcxMiwgZXhjZXB0IHRoYXQgYXJyYXlzIGFuZCByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmVzIGFyZSBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIFY0IGlzIGJhc2VkIG9uIEVJUC03MTIsIGFuZCBpbmNsdWRlcyBmdWxsIHN1cHBvcnQgb2YgYXJyYXlzIGFuZCByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmVzLlxuICovXG52YXIgU2lnblR5cGVkRGF0YVZlcnNpb247XG4oZnVuY3Rpb24gKFNpZ25UeXBlZERhdGFWZXJzaW9uKSB7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWMVwiXSA9IFwiVjFcIjtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlYzXCJdID0gXCJWM1wiO1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjRcIl0gPSBcIlY0XCI7XG59KShTaWduVHlwZWREYXRhVmVyc2lvbiA9IGV4cG9ydHMuU2lnblR5cGVkRGF0YVZlcnNpb24gfHwgKGV4cG9ydHMuU2lnblR5cGVkRGF0YVZlcnNpb24gPSB7fSkpO1xuZXhwb3J0cy5UWVBFRF9NRVNTQUdFX1NDSEVNQSA9IHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogeyB0eXBlOiAnc3RyaW5nJyB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogWyduYW1lJywgJ3R5cGUnXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcHJpbWFyeVR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgZG9tYWluOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgICAgIG1lc3NhZ2U6IHsgdHlwZTogJ29iamVjdCcgfSxcbiAgICB9LFxuICAgIHJlcXVpcmVkOiBbJ3R5cGVzJywgJ3ByaW1hcnlUeXBlJywgJ2RvbWFpbicsICdtZXNzYWdlJ10sXG59O1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHZlcnNpb24gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIHZlcnNpb24gdmFsdWUgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gYWxsb3dlZFZlcnNpb25zIC0gQSBsaXN0IG9mIGFsbG93ZWQgdmVyc2lvbnMuIElmIG9taXR0ZWQsIGFsbCB2ZXJzaW9ucyBhcmUgYXNzdW1lZCB0byBiZVxuICogYWxsb3dlZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIGFsbG93ZWRWZXJzaW9ucykge1xuICAgIGlmICghT2JqZWN0LmtleXMoU2lnblR5cGVkRGF0YVZlcnNpb24pLmluY2x1ZGVzKHZlcnNpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2ZXJzaW9uOiAnJHt2ZXJzaW9ufSdgKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWxsb3dlZFZlcnNpb25zICYmICFhbGxvd2VkVmVyc2lvbnMuaW5jbHVkZXModmVyc2lvbikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTaWduVHlwZWREYXRhVmVyc2lvbiBub3QgYWxsb3dlZDogJyR7dmVyc2lvbn0nLiBBbGxvd2VkIHZlcnNpb25zIGFyZTogJHthbGxvd2VkVmVyc2lvbnMuam9pbignLCAnKX1gKTtcbiAgICB9XG59XG4vKipcbiAqIEVuY29kZSBhIHNpbmdsZSBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gdHlwZXMgLSBBbGwgdHlwZSBkZWZpbml0aW9ucy5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRvIGVuY29kZS5cbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGZpZWxkIGJlaW5nIGVuY29kZWQuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBFbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmaWVsZC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlRmllbGQodHlwZXMsIG5hbWUsIHR5cGUsIFxuLy8gVE9ETzogY29uc3RyYWluIHR5cGUgb24gYHZhbHVlYFxudmFsdWUsIHZlcnNpb24pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbiwgW1NpZ25UeXBlZERhdGFWZXJzaW9uLlYzLCBTaWduVHlwZWREYXRhVmVyc2lvbi5WNF0pO1xuICAgIGlmICh0eXBlc1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnYnl0ZXMzMicsXG4gICAgICAgICAgICAvLyBUT0RPOiByZXR1cm4gQnVmZmVyLCByZW1vdmUgc3RyaW5nIGZyb20gcmV0dXJuIHR5cGVcbiAgICAgICAgICAgIHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0ICYmIHZhbHVlID09IG51bGwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lcS1udWxsXG4gICAgICAgICAgICAgICAgPyAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICAgICAgICAgICAgICAgIDogKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikoZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSwgdHlwZXMsIHZlcnNpb24pKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWlzc2luZyB2YWx1ZSBmb3IgZmllbGQgJHtuYW1lfSBvZiB0eXBlICR7dHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKDAsIHV0aWxzXzEubnVtYmVyVG9CdWZmZXIpKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgZXRoanNfdXRpbF8xLmlzSGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBlbmQgPSB2YWx1ZS5sZW5ndGggJSAyID8gJzAnIDogJyc7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHByZXBlbmQgKyB2YWx1ZS5zbGljZSgyKSwgJ2hleCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydieXRlczMyJywgKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikodmFsdWUpKV07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdmFsdWUgPSAoMCwgdXRpbHNfMS5udW1iZXJUb0J1ZmZlcikodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiAnJywgJ3V0ZjgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWydieXRlczMyJywgKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikodmFsdWUpKV07XG4gICAgfVxuICAgIGlmICh0eXBlLmVuZHNXaXRoKCddJykpIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5cyBhcmUgdW5pbXBsZW1lbnRlZCBpbiBlbmNvZGVEYXRhOyB1c2UgVjQgZXh0ZW5zaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHR5cGUuc2xpY2UoMCwgdHlwZS5sYXN0SW5kZXhPZignWycpKTtcbiAgICAgICAgY29uc3QgdHlwZVZhbHVlUGFpcnMgPSB2YWx1ZS5tYXAoKGl0ZW0pID0+IGVuY29kZUZpZWxkKHR5cGVzLCBuYW1lLCBwYXJzZWRUeXBlLCBpdGVtLCB2ZXJzaW9uKSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnYnl0ZXMzMicsXG4gICAgICAgICAgICAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgZXRoZXJldW1qc19hYmlfdXRpbHNfMS5yYXdFbmNvZGUpKHR5cGVWYWx1ZVBhaXJzLm1hcCgoW3RdKSA9PiB0KSwgdHlwZVZhbHVlUGFpcnMubWFwKChbLCB2XSkgPT4gdikpKSksXG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbdHlwZSwgdmFsdWVdO1xufVxuLyoqXG4gKiBFbmNvZGVzIGFuIG9iamVjdCBieSBlbmNvZGluZyBhbmQgY29uY2F0ZW5hdGluZyBlYWNoIG9mIGl0cyBtZW1iZXJzLlxuICpcbiAqIEBwYXJhbSBwcmltYXJ5VHlwZSAtIFRoZSByb290IHR5cGUuXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBvYmplY3QgdG8gZW5jb2RlLlxuICogQHBhcmFtIHR5cGVzIC0gVHlwZSBkZWZpbml0aW9ucyBmb3IgYWxsIHR5cGVzIGluY2x1ZGVkIGluIHRoZSBtZXNzYWdlLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBBbiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZW5jb2RlRGF0YShwcmltYXJ5VHlwZSwgZGF0YSwgdHlwZXMsIHZlcnNpb24pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbiwgW1NpZ25UeXBlZERhdGFWZXJzaW9uLlYzLCBTaWduVHlwZWREYXRhVmVyc2lvbi5WNF0pO1xuICAgIGNvbnN0IGVuY29kZWRUeXBlcyA9IFsnYnl0ZXMzMiddO1xuICAgIGNvbnN0IGVuY29kZWRWYWx1ZXMgPSBbaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKV07XG4gICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlc1twcmltYXJ5VHlwZV0pIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYzICYmIGRhdGFbZmllbGQubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3R5cGUsIHZhbHVlXSA9IGVuY29kZUZpZWxkKHR5cGVzLCBmaWVsZC5uYW1lLCBmaWVsZC50eXBlLCBkYXRhW2ZpZWxkLm5hbWVdLCB2ZXJzaW9uKTtcbiAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2godHlwZSk7XG4gICAgICAgIGVuY29kZWRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZXRoZXJldW1qc19hYmlfdXRpbHNfMS5yYXdFbmNvZGUpKGVuY29kZWRUeXBlcywgZW5jb2RlZFZhbHVlcyk7XG59XG4vKipcbiAqIEVuY29kZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGEgY29tbWEgZGVsaW1pdGVkIGxpc3Qgb2YgaXRzIG1lbWJlcnMuXG4gKlxuICogQHBhcmFtIHByaW1hcnlUeXBlIC0gVGhlIHJvb3QgdHlwZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zIGZvciBhbGwgdHlwZXMgaW5jbHVkZWQgaW4gdGhlIG1lc3NhZ2UuXG4gKiBAcmV0dXJucyBBbiBlbmNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwcmltYXJ5IHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGNvbnN0IHVuc29ydGVkRGVwcyA9IGZpbmRUeXBlRGVwZW5kZW5jaWVzKHByaW1hcnlUeXBlLCB0eXBlcyk7XG4gICAgdW5zb3J0ZWREZXBzLmRlbGV0ZShwcmltYXJ5VHlwZSk7XG4gICAgY29uc3QgZGVwcyA9IFtwcmltYXJ5VHlwZSwgLi4uQXJyYXkuZnJvbSh1bnNvcnRlZERlcHMpLnNvcnQoKV07XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIGRlcHMpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0eXBlIGRlZmluaXRpb24gc3BlY2lmaWVkOiAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGAke3R5cGV9KCR7dHlwZXNbdHlwZV1cbiAgICAgICAgICAgIC5tYXAoKHsgbmFtZSwgdHlwZTogdCB9KSA9PiBgJHt0fSAke25hbWV9YClcbiAgICAgICAgICAgIC5qb2luKCcsJyl9KWA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEZpbmRzIGFsbCB0eXBlcyB3aXRoaW4gYSB0eXBlIGRlZmluaXRpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBwcmltYXJ5VHlwZSAtIFRoZSByb290IHR5cGUuXG4gKiBAcGFyYW0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zIGZvciBhbGwgdHlwZXMgaW5jbHVkZWQgaW4gdGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0gcmVzdWx0cyAtIFRoZSBjdXJyZW50IHNldCBvZiBhY2N1bXVsYXRlZCB0eXBlcy5cbiAqIEByZXR1cm5zIFRoZSBzZXQgb2YgYWxsIHR5cGVzIGZvdW5kIGluIHRoZSB0eXBlIGRlZmluaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGZpbmRUeXBlRGVwZW5kZW5jaWVzKHByaW1hcnlUeXBlLCB0eXBlcywgcmVzdWx0cyA9IG5ldyBTZXQoKSkge1xuICAgIGlmICh0eXBlb2YgcHJpbWFyeVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaW5kVHlwZURlcGVuZGVuY2llcyBpbnB1dCAke0pTT04uc3RyaW5naWZ5KHByaW1hcnlUeXBlKX1gKTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBwcmltYXJ5VHlwZS5tYXRjaCgvXlxcdyovdSk7XG4gICAgW3ByaW1hcnlUeXBlXSA9IG1hdGNoO1xuICAgIGlmIChyZXN1bHRzLmhhcyhwcmltYXJ5VHlwZSkgfHwgdHlwZXNbcHJpbWFyeVR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIHJlc3VsdHMuYWRkKHByaW1hcnlUeXBlKTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBmaW5kVHlwZURlcGVuZGVuY2llcyhmaWVsZC50eXBlLCB0eXBlcywgcmVzdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufVxuLyoqXG4gKiBIYXNoZXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBwcmltYXJ5VHlwZSAtIFRoZSByb290IHR5cGUuXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBvYmplY3QgdG8gaGFzaC5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaGFzaFN0cnVjdChwcmltYXJ5VHlwZSwgZGF0YSwgdHlwZXMsIHZlcnNpb24pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbiwgW1NpZ25UeXBlZERhdGFWZXJzaW9uLlYzLCBTaWduVHlwZWREYXRhVmVyc2lvbi5WNF0pO1xuICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVEYXRhKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdmVyc2lvbik7XG4gICAgY29uc3QgaGFzaGVkID0gKDAsIGtlY2Nha18xLmtlY2NhazI1NikoZW5jb2RlZCk7XG4gICAgY29uc3QgYnVmID0gKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoaGFzaGVkKTtcbiAgICByZXR1cm4gYnVmO1xufVxuLyoqXG4gKiBIYXNoZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBwcmltYXJ5VHlwZSAtIFRoZSByb290IHR5cGUgdG8gaGFzaC5cbiAqIEBwYXJhbSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnMgZm9yIGFsbCB0eXBlcyBpbmNsdWRlZCBpbiB0aGUgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSBvYmplY3QgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSB7XG4gICAgY29uc3QgZW5jb2RlZEhhc2hUeXBlID0gQnVmZmVyLmZyb20oZW5jb2RlVHlwZShwcmltYXJ5VHlwZSwgdHlwZXMpLCAndXRmLTgnKTtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5hcnJUb0J1ZkFycikoKDAsIGtlY2Nha18xLmtlY2NhazI1NikoZW5jb2RlZEhhc2hUeXBlKSk7XG59XG4vKipcbiAqIFJlbW92ZXMgcHJvcGVydGllcyBmcm9tIGEgbWVzc2FnZSBvYmplY3QgdGhhdCBhcmUgbm90IGRlZmluZWQgcGVyIEVJUC03MTIuXG4gKlxuICogQHBhcmFtIGRhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZSBvYmplY3QuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgbWVzc2FnZSBvYmplY3Qgd2l0aCBvbmx5IGFsbG93ZWQgZmllbGRzLlxuICovXG5mdW5jdGlvbiBzYW5pdGl6ZURhdGEoZGF0YSkge1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBleHBvcnRzLlRZUEVEX01FU1NBR0VfU0NIRU1BLnByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKGRhdGFba2V5XSkge1xuICAgICAgICAgICAgc2FuaXRpemVkRGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgndHlwZXMnIGluIHNhbml0aXplZERhdGEpIHtcbiAgICAgICAgLy8gVE9ETzogRml4IHR5cGVzXG4gICAgICAgIHNhbml0aXplZERhdGEudHlwZXMgPSBPYmplY3QuYXNzaWduKHsgRUlQNzEyRG9tYWluOiBbXSB9LCBzYW5pdGl6ZWREYXRhLnR5cGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHNhbml0aXplZERhdGE7XG59XG4vKipcbiAqIENyZWF0ZSBhIEVJUC03MTIgRG9tYWluIEhhc2guXG4gKiBUaGlzIGhhc2ggaXMgdXNlZCBhdCB0aGUgdG9wIG9mIHRoZSBFSVAtNzEyIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHZlcnNpb24gLSBUaGUgRUlQLTcxMiB2ZXJzaW9uIHRoZSBlbmNvZGluZyBzaG91bGQgY29tcGx5IHdpdGguXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgZG9tYWluIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZWlwNzEyRG9tYWluSGFzaCh0eXBlZERhdGEsIHZlcnNpb24pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbiwgW1NpZ25UeXBlZERhdGFWZXJzaW9uLlYzLCBTaWduVHlwZWREYXRhVmVyc2lvbi5WNF0pO1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSBzYW5pdGl6ZURhdGEodHlwZWREYXRhKTtcbiAgICBjb25zdCB7IGRvbWFpbiB9ID0gc2FuaXRpemVkRGF0YTtcbiAgICBjb25zdCBkb21haW5UeXBlID0geyBFSVA3MTJEb21haW46IHNhbml0aXplZERhdGEudHlwZXMuRUlQNzEyRG9tYWluIH07XG4gICAgcmV0dXJuIGhhc2hTdHJ1Y3QoJ0VJUDcxMkRvbWFpbicsIGRvbWFpbiwgZG9tYWluVHlwZSwgdmVyc2lvbik7XG59XG4vKipcbiAqIEhhc2ggYSB0eXBlZCBtZXNzYWdlIGFjY29yZGluZyB0byBFSVAtNzEyLiBUaGUgcmV0dXJuZWQgbWVzc2FnZSBzdGFydHMgd2l0aCB0aGUgRUlQLTcxMiBwcmVmaXgsXG4gKiB3aGljaCBpcyBcIjE5MDFcIiwgZm9sbG93ZWQgYnkgdGhlIGhhc2ggb2YgdGhlIGRvbWFpbiBzZXBhcmF0b3IsIHRoZW4gdGhlIGRhdGEgKGlmIGFueSkuXG4gKiBUaGUgcmVzdWx0IGlzIGhhc2hlZCBhZ2FpbiBhbmQgcmV0dXJuZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzaWduIHRoZSBtZXNzYWdlLiBUaGUgcmVzdWx0aW5nIGhhc2ggbXVzdCBzdGlsbCBiZSBzaWduZWQgdG8gY3JlYXRlIGFuXG4gKiBFSVAtNzEyIHNpZ25hdHVyZS5cbiAqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gVGhlIHR5cGVkIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB2ZXJzaW9uIC0gVGhlIEVJUC03MTIgdmVyc2lvbiB0aGUgZW5jb2Rpbmcgc2hvdWxkIGNvbXBseSB3aXRoLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIHR5cGVkIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGVpcDcxMkhhc2godHlwZWREYXRhLCB2ZXJzaW9uKSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24sIFtTaWduVHlwZWREYXRhVmVyc2lvbi5WMywgU2lnblR5cGVkRGF0YVZlcnNpb24uVjRdKTtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0gc2FuaXRpemVEYXRhKHR5cGVkRGF0YSk7XG4gICAgY29uc3QgcGFydHMgPSBbQnVmZmVyLmZyb20oJzE5MDEnLCAnaGV4JyldO1xuICAgIHBhcnRzLnB1c2goZWlwNzEyRG9tYWluSGFzaCh0eXBlZERhdGEsIHZlcnNpb24pKTtcbiAgICBpZiAoc2FuaXRpemVkRGF0YS5wcmltYXJ5VHlwZSAhPT0gJ0VJUDcxMkRvbWFpbicpIHtcbiAgICAgICAgcGFydHMucHVzaChoYXNoU3RydWN0KFxuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRoaXMgaXMgYSBzdHJpbmcsIHNvIHRoaXMgdHlwZSBjYXN0IGNhbiBiZSByZW1vdmVkLlxuICAgICAgICBzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlLCBzYW5pdGl6ZWREYXRhLm1lc3NhZ2UsIHNhbml0aXplZERhdGEudHlwZXMsIHZlcnNpb24pKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCB1dGlsXzEuYXJyVG9CdWZBcnIpKCgwLCBrZWNjYWtfMS5rZWNjYWsyNTYpKEJ1ZmZlci5jb25jYXQocGFydHMpKSk7XG59XG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGZvciBzaWduaW5nIHR5cGVkIGRhdGEuXG4gKi9cbmV4cG9ydHMuVHlwZWREYXRhVXRpbHMgPSB7XG4gICAgZW5jb2RlRGF0YSxcbiAgICBlbmNvZGVUeXBlLFxuICAgIGZpbmRUeXBlRGVwZW5kZW5jaWVzLFxuICAgIGhhc2hTdHJ1Y3QsXG4gICAgaGFzaFR5cGUsXG4gICAgc2FuaXRpemVEYXRhLFxuICAgIGVpcDcxMkhhc2gsXG4gICAgZWlwNzEyRG9tYWluSGFzaCxcbn07XG4vKipcbiAqIEdlbmVyYXRlIHRoZSBcIlYxXCIgaGFzaCBmb3IgdGhlIHByb3ZpZGVkIHR5cGVkIG1lc3NhZ2UuXG4gKlxuICogVGhlIGhhc2ggd2lsbCBiZSBnZW5lcmF0ZWQgaW4gYWNjb3JkYW5jZSB3aXRoIGFuIGVhcmxpZXIgdmVyc2lvbiBvZiB0aGUgRUlQLTcxMlxuICogc3BlY2lmaWNhdGlvbi4gVGhpcyBoYXNoIGlzIHVzZWQgaW4gYHNpZ25UeXBlZERhdGFfdjFgLlxuICpcbiAqIEBwYXJhbSB0eXBlZERhdGEgLSBUaGUgdHlwZWQgbWVzc2FnZS5cbiAqIEByZXR1cm5zIFRoZSAnMHgnLXByZWZpeGVkIGhleCBlbmNvZGVkIGhhc2ggcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRoZSBwcm92aWRlZCBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKSB7XG4gICAgY29uc3QgaGFzaEJ1ZmZlciA9IF90eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKTtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5idWZmZXJUb0hleCkoaGFzaEJ1ZmZlcik7XG59XG5leHBvcnRzLnR5cGVkU2lnbmF0dXJlSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaDtcbi8qKlxuICogR2VuZXJhdGUgdGhlIFwiVjFcIiBoYXNoIGZvciB0aGUgcHJvdmlkZWQgdHlwZWQgbWVzc2FnZS5cbiAqXG4gKiBUaGUgaGFzaCB3aWxsIGJlIGdlbmVyYXRlZCBpbiBhY2NvcmRhbmNlIHdpdGggYW4gZWFybGllciB2ZXJzaW9uIG9mIHRoZSBFSVAtNzEyXG4gKiBzcGVjaWZpY2F0aW9uLiBUaGlzIGhhc2ggaXMgdXNlZCBpbiBgc2lnblR5cGVkRGF0YV92MWAuXG4gKlxuICogQHBhcmFtIHR5cGVkRGF0YSAtIFRoZSB0eXBlZCBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGhhc2ggcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIHRoZSBwcm92aWRlZCBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBfdHlwZWRTaWduYXR1cmVIYXNoKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdFeHBlY3QgYXJndW1lbnQgdG8gYmUgbm9uLWVtcHR5IGFycmF5Jyk7XG4gICAgaWYgKHR5cGVvZiB0eXBlZERhdGEgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICEoJ2xlbmd0aCcgaW4gdHlwZWREYXRhKSB8fFxuICAgICAgICAhdHlwZWREYXRhLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudHlwZSAhPT0gJ2J5dGVzJykge1xuICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmxlZ2FjeVRvQnVmZmVyKShlLnZhbHVlKTtcbiAgICB9KTtcbiAgICBjb25zdCB0eXBlcyA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUudHlwZTtcbiAgICB9KTtcbiAgICBjb25zdCBzY2hlbWEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICghZS5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7ZS50eXBlfSAke2UubmFtZX1gO1xuICAgIH0pO1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmFyclRvQnVmQXJyKSgoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgZXRoZXJldW1qc19hYmlfdXRpbHNfMS5zb2xpZGl0eVBhY2spKFsnYnl0ZXMzMicsICdieXRlczMyJ10sIFtcbiAgICAgICAgKDAsIGtlY2Nha18xLmtlY2NhazI1NikoKDAsIGV0aGVyZXVtanNfYWJpX3V0aWxzXzEuc29saWRpdHlQYWNrKShuZXcgQXJyYXkodHlwZWREYXRhLmxlbmd0aCkuZmlsbCgnc3RyaW5nJyksIHNjaGVtYSkpLFxuICAgICAgICAoMCwga2VjY2FrXzEua2VjY2FrMjU2KSgoMCwgZXRoZXJldW1qc19hYmlfdXRpbHNfMS5zb2xpZGl0eVBhY2spKHR5cGVzLCBkYXRhKSksXG4gICAgXSkpKTtcbn1cbi8qKlxuICogU2lnbiB0eXBlZCBkYXRhIGFjY29yZGluZyB0byBFSVAtNzEyLiBUaGUgc2lnbmluZyBkaWZmZXJzIGJhc2VkIHVwb24gdGhlIGB2ZXJzaW9uYC5cbiAqXG4gKiBWMSBpcyBiYXNlZCB1cG9uIFthbiBlYXJseSB2ZXJzaW9uIG9mIEVJUC03MTJdKGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9FSVBzL3B1bGwvNzEyL2NvbW1pdHMvMjFhYmUyNTRmZTA0NTJkODU4M2Q1YjEzMmIxZDdiZTg3YzA0MzljYSlcbiAqIHRoYXQgbGFja2VkIHNvbWUgbGF0ZXIgc2VjdXJpdHkgaW1wcm92ZW1lbnRzLCBhbmQgc2hvdWxkIGdlbmVyYWxseSBiZSBuZWdsZWN0ZWQgaW4gZmF2b3Igb2ZcbiAqIGxhdGVyIHZlcnNpb25zLlxuICpcbiAqIFYzIGlzIGJhc2VkIG9uIFtFSVAtNzEyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTcxMiksIGV4Y2VwdCB0aGF0IGFycmF5cyBhbmRcbiAqIHJlY3Vyc2l2ZSBkYXRhIHN0cnVjdHVyZXMgYXJlIG5vdCBzdXBwb3J0ZWQuXG4gKlxuICogVjQgaXMgYmFzZWQgb24gW0VJUC03MTJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzEyKSwgYW5kIGluY2x1ZGVzIGZ1bGwgc3VwcG9ydCBvZlxuICogYXJyYXlzIGFuZCByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmVzLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25pbmcgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gc2lnbiB3aXRoLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSB0eXBlZCBkYXRhIHRvIHNpZ24uXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHNpZ25pbmcgdmVyc2lvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmZ1bmN0aW9uIHNpZ25UeXBlZERhdGEoeyBwcml2YXRlS2V5LCBkYXRhLCB2ZXJzaW9uLCB9KSB7XG4gICAgdmFsaWRhdGVWZXJzaW9uKHZlcnNpb24pO1xuICAgIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKGRhdGEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBkYXRhIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgdXRpbHNfMS5pc051bGxpc2gpKHByaXZhdGVLZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBwcml2YXRlIGtleSBwYXJhbWV0ZXInKTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZUhhc2ggPSB2ZXJzaW9uID09PSBTaWduVHlwZWREYXRhVmVyc2lvbi5WMVxuICAgICAgICA/IF90eXBlZFNpZ25hdHVyZUhhc2goZGF0YSlcbiAgICAgICAgOiBleHBvcnRzLlR5cGVkRGF0YVV0aWxzLmVpcDcxMkhhc2goZGF0YSwgdmVyc2lvbik7XG4gICAgY29uc3Qgc2lnID0gKDAsIHV0aWxfMS5lY3NpZ24pKG1lc3NhZ2VIYXNoLCBwcml2YXRlS2V5KTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29uY2F0U2lnKSgoMCwgdXRpbF8xLnRvQnVmZmVyKShzaWcudiksIHNpZy5yLCBzaWcucyk7XG59XG5leHBvcnRzLnNpZ25UeXBlZERhdGEgPSBzaWduVHlwZWREYXRhO1xuLyoqXG4gKiBSZWNvdmVyIHRoZSBhZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRoYXQgY3JlYXRlZCB0aGUgZ2l2ZW4gRUlQLTcxMlxuICogc2lnbmF0dXJlLiBUaGUgdmVyc2lvbiBwcm92aWRlZCBtdXN0IG1hdGNoIHRoZSB2ZXJzaW9uIHVzZWQgdG9cbiAqIGNyZWF0ZSB0aGUgc2lnbmF0dXJlLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNpZ25hdHVyZSByZWNvdmVyeSBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuZGF0YSAtIFRoZSB0eXBlZCBkYXRhIHRoYXQgd2FzIHNpZ25lZC5cbiAqIEBwYXJhbSBvcHRpb25zLnNpZ25hdHVyZSAtIFRoZSAnMHgtcHJlZml4ZWQgaGV4IGVuY29kZWQgbWVzc2FnZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gb3B0aW9ucy52ZXJzaW9uIC0gVGhlIHNpZ25pbmcgdmVyc2lvbiB0byB1c2UuXG4gKiBAcmV0dXJucyBUaGUgJzB4Jy1wcmVmaXhlZCBoZXggYWRkcmVzcyBvZiB0aGUgc2lnbmVyLlxuICovXG5mdW5jdGlvbiByZWNvdmVyVHlwZWRTaWduYXR1cmUoeyBkYXRhLCBzaWduYXR1cmUsIHZlcnNpb24sIH0pIHtcbiAgICB2YWxpZGF0ZVZlcnNpb24odmVyc2lvbik7XG4gICAgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGRhdGEgcGFyYW1ldGVyJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc18xLmlzTnVsbGlzaCkoc2lnbmF0dXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc2lnbmF0dXJlIHBhcmFtZXRlcicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlSGFzaCA9IHZlcnNpb24gPT09IFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxXG4gICAgICAgID8gX3R5cGVkU2lnbmF0dXJlSGFzaChkYXRhKVxuICAgICAgICA6IGV4cG9ydHMuVHlwZWREYXRhVXRpbHMuZWlwNzEySGFzaChkYXRhLCB2ZXJzaW9uKTtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfMS5yZWNvdmVyUHVibGljS2V5KShtZXNzYWdlSGFzaCwgc2lnbmF0dXJlKTtcbiAgICBjb25zdCBzZW5kZXIgPSAoMCwgdXRpbF8xLnB1YmxpY1RvQWRkcmVzcykocHVibGljS2V5KTtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5idWZmZXJUb0hleCkoc2VuZGVyKTtcbn1cbmV4cG9ydHMucmVjb3ZlclR5cGVkU2lnbmF0dXJlID0gcmVjb3ZlclR5cGVkU2lnbmF0dXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbi10eXBlZC1kYXRhLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5udW1iZXJUb0J1ZmZlciA9IGV4cG9ydHMubm9ybWFsaXplID0gZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gZXhwb3J0cy5jb25jYXRTaWcgPSBleHBvcnRzLmxlZ2FjeVRvQnVmZmVyID0gZXhwb3J0cy5pc051bGxpc2ggPSBleHBvcnRzLnBhZFdpdGhaZXJvZXMgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKTtcbmNvbnN0IGV0aGpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhqcy11dGlsXCIpO1xuLyoqXG4gKiBQYWRzIHRoZSBmcm9udCBvZiB0aGUgZ2l2ZW4gaGV4IHN0cmluZyB3aXRoIHplcm9lcyB1bnRpbCBpdCByZWFjaGVzIHRoZVxuICogdGFyZ2V0IGxlbmd0aC4gSWYgdGhlIGlucHV0IHN0cmluZyBpcyBhbHJlYWR5IGxvbmdlciB0aGFuIG9yIGVxdWFsIHRvIHRoZVxuICogdGFyZ2V0IGxlbmd0aCwgaXQgaXMgcmV0dXJuZWQgdW5tb2RpZmllZC5cbiAqXG4gKiBJZiB0aGUgaW5wdXQgc3RyaW5nIGlzIFwiMHhcIi1wcmVmaXhlZCBvciBub3QgYSBoZXggc3RyaW5nLCBhbiBlcnJvciB3aWxsIGJlXG4gKiB0aHJvd24uXG4gKlxuICogQHBhcmFtIGhleFN0cmluZyAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gcGFkIHdpdGggemVyb2VzLlxuICogQHBhcmFtIHRhcmdldExlbmd0aCAtIFRoZSB0YXJnZXQgbGVuZ3RoIG9mIHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgaW5wdXQgc3RyaW5nIGZyb250LXBhZGRlZCB3aXRoIHplcm9lcywgb3IgdGhlIG9yaWdpbmFsIHN0cmluZ1xuICogaWYgaXQgd2FzIGFscmVhZHkgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRvIHRoZSB0YXJnZXQgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBwYWRXaXRoWmVyb2VzKGhleFN0cmluZywgdGFyZ2V0TGVuZ3RoKSB7XG4gICAgaWYgKGhleFN0cmluZyAhPT0gJycgJiYgIS9eW2EtZjAtOV0rJC9pdS50ZXN0KGhleFN0cmluZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhbiB1bnByZWZpeGVkIGhleCBzdHJpbmcuIFJlY2VpdmVkOiAke2hleFN0cmluZ31gKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldExlbmd0aCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIHRhcmdldCBsZW5ndGguIFJlY2VpdmVkOiAke3RhcmdldExlbmd0aH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUucGFkU3RhcnQuY2FsbChoZXhTdHJpbmcsIHRhcmdldExlbmd0aCwgJzAnKTtcbn1cbmV4cG9ydHMucGFkV2l0aFplcm9lcyA9IHBhZFdpdGhaZXJvZXM7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBudWxsaXNoLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSBiZWluZyBjaGVja2VkLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgbnVsbGlzaC5cbiAqL1xuZnVuY3Rpb24gaXNOdWxsaXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmlzTnVsbGlzaCA9IGlzTnVsbGlzaDtcbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgQnVmZmVyLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBlcXVpdmFsZW50IHRvIHRoZSBgdG9CdWZmZXJgIGZ1bmN0aW9uIGluXG4gKiBgZXRoZXJldW1qcy11dGlsQDUuMi4xYC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIEJ1ZmZlci5cbiAqIEByZXR1cm5zIFRoZSBnaXZlbiB2YWx1ZSBhcyBhIEJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gbGVnYWN5VG9CdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhKDAsIGV0aGpzX3V0aWxfMS5pc0hleFN0cmluZykodmFsdWUpXG4gICAgICAgID8gQnVmZmVyLmZyb20odmFsdWUpXG4gICAgICAgIDogKDAsIHV0aWxfMS50b0J1ZmZlcikodmFsdWUpO1xufVxuZXhwb3J0cy5sZWdhY3lUb0J1ZmZlciA9IGxlZ2FjeVRvQnVmZmVyO1xuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbiBleHRlbmRlZCBFQ0RTQSBzaWduYXR1cmUgaW50byBhIHNpbmdsZSAnMHgnLXByZWZpeGVkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHYgLSBUaGUgJ3YnIHBvcnRpb24gb2YgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSByIC0gVGhlICdyJyBwb3J0aW9uIG9mIHRoZSBzaWduYXR1cmUuXG4gKiBAcGFyYW0gcyAtIFRoZSAncycgcG9ydGlvbiBvZiB0aGUgc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBFQ0RTQSBzaWduYXR1cmUgYXMgYSAnMHgnLXByZWZpeGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY29uY2F0U2lnKHYsIHIsIHMpIHtcbiAgICBjb25zdCByU2lnID0gKDAsIHV0aWxfMS5mcm9tU2lnbmVkKShyKTtcbiAgICBjb25zdCBzU2lnID0gKDAsIHV0aWxfMS5mcm9tU2lnbmVkKShzKTtcbiAgICBjb25zdCB2U2lnID0gKDAsIHV0aWxfMS5idWZmZXJUb0ludCkodik7XG4gICAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoKDAsIHV0aWxfMS50b1Vuc2lnbmVkKShyU2lnKS50b1N0cmluZygnaGV4JyksIDY0KTtcbiAgICBjb25zdCBzU3RyID0gcGFkV2l0aFplcm9lcygoMCwgdXRpbF8xLnRvVW5zaWduZWQpKHNTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpO1xuICAgIGNvbnN0IHZTdHIgPSAoMCwgZXRoanNfdXRpbF8xLnN0cmlwSGV4UHJlZml4KSgoMCwgZXRoanNfdXRpbF8xLmludFRvSGV4KSh2U2lnKSk7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEuYWRkSGV4UHJlZml4KShyU3RyLmNvbmNhdChzU3RyLCB2U3RyKSk7XG59XG5leHBvcnRzLmNvbmNhdFNpZyA9IGNvbmNhdFNpZztcbi8qKlxuICogUmVjb3ZlciB0aGUgcHVibGljIGtleSBmcm9tIHRoZSBnaXZlbiBzaWduYXR1cmUgYW5kIG1lc3NhZ2UgaGFzaC5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZUhhc2ggLSBUaGUgaGFzaCBvZiB0aGUgc2lnbmVkIG1lc3NhZ2UuXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZS5cbiAqIEByZXR1cm5zIFRoZSBwdWJsaWMga2V5IG9mIHRoZSBzaWduZXIuXG4gKi9cbmZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkobWVzc2FnZUhhc2gsIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZ1BhcmFtcyA9ICgwLCB1dGlsXzEuZnJvbVJwY1NpZykoc2lnbmF0dXJlKTtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5lY3JlY292ZXIpKG1lc3NhZ2VIYXNoLCBzaWdQYXJhbXMudiwgc2lnUGFyYW1zLnIsIHNpZ1BhcmFtcy5zKTtcbn1cbmV4cG9ydHMucmVjb3ZlclB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXk7XG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgaW5wdXQgdG8gYSBsb3dlci1jYXNlZCAnMHgnLXByZWZpeGVkIGhleCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGlucHV0IC0gVGhlIHZhbHVlIHRvIG5vcm1hbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoaW5wdXQpIHtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpbnB1dCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnMHgnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9ICgwLCB1dGlsXzEudG9CdWZmZXIpKGlucHV0KTtcbiAgICAgICAgaW5wdXQgPSAoMCwgdXRpbF8xLmJ1ZmZlclRvSGV4KShidWZmZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBsZXQgbXNnID0gJ2V0aC1zaWctdXRpbC5ub3JtYWxpemUoKSByZXF1aXJlcyBoZXggc3RyaW5nIG9yIGludGVnZXIgaW5wdXQuJztcbiAgICAgICAgbXNnICs9IGAgcmVjZWl2ZWQgJHt0eXBlb2YgaW5wdXR9OiAke2lucHV0fWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHV0aWxfMS5hZGRIZXhQcmVmaXgpKGlucHV0LnRvTG93ZXJDYXNlKCkpO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG4vKipcbiAqIE5vZGUncyBCdWZmZXIuZnJvbSgpIG1ldGhvZCBkb2VzIG5vdCBzZWVtIHRvIGJ1ZmZlciBudW1iZXJzIGNvcnJlY3RseSBvdXQgb2YgdGhlIGJveC5cbiAqIFRoaXMgaGVscGVyIG1ldGhvZCBmb3JtYXRzIHRoZSBudW1iZXIgY29ycmVjdCBmb3IgQnVmZmVyLmZyb20gdG8gcmV0dXJuIGNvcnJlY3QgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSBudW0gLSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQgdG8gYnVmZmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlciBpbiBidWZmZXIgZm9ybS5cbiAqL1xuZnVuY3Rpb24gbnVtYmVyVG9CdWZmZXIobnVtKSB7XG4gICAgY29uc3QgaGV4VmFsID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBwcmVwZW5kID0gaGV4VmFsLmxlbmd0aCAlIDIgPyAnMCcgOiAnJztcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocHJlcGVuZCArIGhleFZhbCwgJ2hleCcpO1xufVxuZXhwb3J0cy5udW1iZXJUb0J1ZmZlciA9IG51bWJlclRvQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm91dHB1dCA9IGV4cG9ydHMuZXhpc3RzID0gZXhwb3J0cy5oYXNoID0gZXhwb3J0cy5ieXRlcyA9IGV4cG9ydHMuYm9vbCA9IGV4cG9ydHMubnVtYmVyID0gdm9pZCAwO1xuZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHBvc2l0aXZlIGludGVnZXI6ICR7bn1gKTtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiwgbm90ICR7Yn1gKTtcbn1cbmV4cG9ydHMuYm9vbCA9IGJvb2w7XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCEoYiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFVpbnQ4QXJyYXkgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmV4cG9ydHMuYnl0ZXMgPSBieXRlcztcbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydHMuZXhpc3RzID0gZXhpc3RzO1xuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmV4cG9ydHMub3V0cHV0ID0gb3V0cHV0O1xuY29uc3QgYXNzZXJ0ID0ge1xuICAgIG51bWJlcixcbiAgICBib29sLFxuICAgIGJ5dGVzLFxuICAgIGhhc2gsXG4gICAgZXhpc3RzLFxuICAgIG91dHB1dCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGQgPSBleHBvcnRzLnRvQmlnID0gZXhwb3J0cy5zcGxpdCA9IGV4cG9ydHMuZnJvbUJpZyA9IHZvaWQgMDtcbmNvbnN0IFUzMl9NQVNLNjQgPSBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZXhwb3J0cy5mcm9tQmlnID0gZnJvbUJpZztcbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuZXhwb3J0cy5zcGxpdCA9IHNwbGl0O1xuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbmV4cG9ydHMudG9CaWcgPSB0b0JpZztcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBsLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChoLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBsKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuLy8gUmVtb3ZpbmcgXCJleHBvcnRcIiBoYXMgNSUgcGVyZiBwZW5hbHR5IC1fLVxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuZXhwb3J0cy5hZGQgPSBhZGQ7XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWc6IGV4cG9ydHMudG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3J5cHRvID0gdm9pZCAwO1xuZXhwb3J0cy5jcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGFrZTI1NiA9IGV4cG9ydHMuc2hha2UxMjggPSBleHBvcnRzLmtlY2Nha181MTIgPSBleHBvcnRzLmtlY2Nha18zODQgPSBleHBvcnRzLmtlY2Nha18yNTYgPSBleHBvcnRzLmtlY2Nha18yMjQgPSBleHBvcnRzLnNoYTNfNTEyID0gZXhwb3J0cy5zaGEzXzM4NCA9IGV4cG9ydHMuc2hhM18yNTYgPSBleHBvcnRzLnNoYTNfMjI0ID0gZXhwb3J0cy5LZWNjYWsgPSBleHBvcnRzLmtlY2Nha1AgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgX3U2NF9qc18xID0gcmVxdWlyZShcIi4vX3U2NC5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFtTSEEzX1BJLCBTSEEzX1JPVEwsIF9TSEEzX0lPVEFdID0gW1tdLCBbXSwgW11dO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgXzduID0gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBbU0hBM19JT1RBX0gsIFNIQTNfSU9UQV9MXSA9IF91NjRfanNfMS5kZWZhdWx0LnNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuLy8gTGVmdCByb3RhdGlvbiAod2l0aG91dCAwLCAzMiwgNjQpXG5jb25zdCByb3RsSCA9IChoLCBsLCBzKSA9PiBzID4gMzIgPyBfdTY0X2pzXzEuZGVmYXVsdC5yb3RsQkgoaCwgbCwgcykgOiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RsU0goaCwgbCwgcyk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiBzID4gMzIgPyBfdTY0X2pzXzEuZGVmYXVsdC5yb3RsQkwoaCwgbCwgcykgOiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RsU0woaCwgbCwgcyk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgIEIuZmlsbCgwKTtcbn1cbmV4cG9ydHMua2VjY2FrUCA9IGtlY2Nha1A7XG5jbGFzcyBLZWNjYWsgZXh0ZW5kcyB1dGlsc19qc18xLkhhc2gge1xuICAgIC8vIE5PVEU6IHdlIGFjY2VwdCBhcmd1bWVudHMgaW4gYnl0ZXMgaW5zdGVhZCBvZiBiaXRzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YgPSBmYWxzZSwgcm91bmRzID0gMjQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0aGlzLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQ2FuIGJlIHBhc3NlZCBmcm9tIHVzZXIgYXMgZGtMZW5cbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQubnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gKDAsIHV0aWxzX2pzXzEudTMyKSh0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRha2U7IGkrKylcbiAgICAgICAgICAgICAgICBzdGF0ZVt0aGlzLnBvcysrXSBePSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUsIHN1ZmZpeCwgcG9zLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgLy8gRG8gdGhlIHBhZGRpbmdcbiAgICAgICAgc3RhdGVbcG9zXSBePSBzdWZmaXg7XG4gICAgICAgIGlmICgoc3VmZml4ICYgMHg4MCkgIT09IDAgJiYgcG9zID09PSBibG9ja0xlbiAtIDEpXG4gICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICBzdGF0ZVtibG9ja0xlbiAtIDFdIF49IDB4ODA7XG4gICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgfVxuICAgIHdyaXRlSW50byhvdXQpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQuYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIF9hc3NlcnRfanNfMS5kZWZhdWx0Lm51bWJlcihieXRlcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnhvZkludG8obmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQub3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLktlY2NhayA9IEtlY2NhaztcbmNvbnN0IGdlbiA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+ICgwLCB1dGlsc19qc18xLndyYXBDb25zdHJ1Y3RvcikoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydHMuc2hhM18yMjQgPSBnZW4oMHgwNiwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICogU0hBMy0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLnNoYTNfMjU2ID0gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnRzLnNoYTNfMzg0ID0gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLnNoYTNfNTEyID0gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzIyNCA9IGdlbigweDAxLCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBrZWNjYWstMjU2IGhhc2ggZnVuY3Rpb24uIERpZmZlcmVudCBmcm9tIFNIQTMtMjU2LlxuICogQHBhcmFtIG1lc3NhZ2UgLSB0aGF0IHdvdWxkIGJlIGhhc2hlZFxuICovXG5leHBvcnRzLmtlY2Nha18yNTYgPSBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMua2VjY2FrXzM4NCA9IGdlbigweDAxLCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfNTEyID0gZ2VuKDB4MDEsIDcyLCA1MTIgLyA4KTtcbmNvbnN0IGdlblNoYWtlID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMpKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0cy5zaGFrZTEyOCA9IGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5jaGVja09wdHMgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0J5dGVzID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuYXN5bmNMb29wID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMucm90ciA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbi8vIFdlIHVzZSBgZ2xvYmFsVGhpcy5jcnlwdG9gLCBidXQgbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0XG4vLyBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS4gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmdcbi8vIHJld3JpdGVzIGltcG9ydCBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9jcnlwdG9cIik7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5jb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLnU4ID0gdTg7XG5jb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG5leHBvcnRzLnUzMiA9IHUzMjtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy5jcmVhdGVWaWV3ID0gY3JlYXRlVmlldztcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5leHBvcnRzLnJvdHIgPSByb3RyO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0cy5pc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghZXhwb3J0cy5pc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhkZSwgMHhhZCwgMHhiZSwgMHhlZl0pKSAvLyAnZGVhZGJlZWYnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9IZXgodWludDhhKSB7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgaWYgKCEodWludDhhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVpbnQ4YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbdWludDhhW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2RlYWRiZWVmJykgLy8gVWludDhBcnJheS5mcm9tKFsweGRlLCAweGFkLCAweGJlLCAweGVmXSlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGV4VG9CeXRlczogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4VG9CeXRlczogcmVjZWl2ZWQgaW52YWxpZCB1bnBhZGRlZCBoZXgnKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgY29uc3QgaGV4Qnl0ZSA9IGhleC5zbGljZShqLCBqICsgMik7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGJ5dGUpIHx8IGJ5dGUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgc2VxdWVuY2UnKTtcbiAgICAgICAgYXJyYXlbaV0gPSBieXRlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG5leHBvcnRzLm5leHRUaWNrID0gbmV4dFRpY2s7XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5hc3luYyBmdW5jdGlvbiBhc3luY0xvb3AoaXRlcnMsIHRpY2ssIGNiKSB7XG4gICAgbGV0IHRzID0gRGF0ZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJzOyBpKyspIHtcbiAgICAgICAgY2IoaSk7XG4gICAgICAgIC8vIERhdGUubm93KCkgaXMgbm90IG1vbm90b25pYywgc28gaW4gY2FzZSBpZiBjbG9jayBnb2VzIGJhY2t3YXJkcyB3ZSByZXR1cm4gcmV0dXJuIGNvbnRyb2wgdG9vXG4gICAgICAgIGNvbnN0IGRpZmYgPSBEYXRlLm5vdygpIC0gdHM7XG4gICAgICAgIGlmIChkaWZmID49IDAgJiYgZGlmZiA8IHRpY2spXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgYXdhaXQgKDAsIGV4cG9ydHMubmV4dFRpY2spKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cik7XG59XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG5mdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBpbnB1dCB0eXBlIGlzIFVpbnQ4QXJyYXkgKGdvdCAke3R5cGVvZiBkYXRhfSlgKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG4vKipcbiAqIENvbmNhdHMgVWludDhBcnJheS1zIGludG8gb25lOyBsaWtlIGBCdWZmZXIuY29uY2F0KFtidWYxLCBidWYyXSlgXG4gKiBAZXhhbXBsZSBjb25jYXRCeXRlcyhidWYxLCBidWYyKVxuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBpZiAoIWFycmF5cy5ldmVyeSgoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgbGlzdCBleHBlY3RlZCcpO1xuICAgIGlmIChhcnJheXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gYXJyYXlzWzBdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGEsIGFycikgPT4gYSArIGFyci5sZW5ndGgsIDApO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJyID0gYXJyYXlzW2ldO1xuICAgICAgICByZXN1bHQuc2V0KGFyciwgcGFkKTtcbiAgICAgICAgcGFkICs9IGFyci5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuLy8gQ2hlY2sgaWYgb2JqZWN0IGRvZW5zJ3QgaGF2ZSBjdXN0b20gY29uc3RydWN0b3IgKGxpa2UgVWludDhBcnJheS9BcnJheSlcbmNvbnN0IGlzUGxhaW5PYmplY3QgPSAob2JqKSA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG5mdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgIWlzUGxhaW5PYmplY3Qob3B0cykpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydHMuY2hlY2tPcHRzID0gY2hlY2tPcHRzO1xuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yKGhhc2hDb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGhhc2hDID0gKG1lc3NhZ2UpID0+IGhhc2hDb25zdHJ1Y3RvcigpLnVwZGF0ZSh0b0J5dGVzKG1lc3NhZ2UpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29uc3RydWN0b3IoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gd3JhcENvbnN0cnVjdG9yO1xuZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHM7XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBnbG9iYWxUaGlzLmNyeXB0b2Agb3Igbm9kZS5qcyBjcnlwdG8gbW9kdWxlLlxuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrNTEyID0gZXhwb3J0cy5rZWNjYWszODQgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrMjI0ID0gdm9pZCAwO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMua2VjY2FrMjI0ID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjI0KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gKCgpID0+IHtcbiAgICBjb25zdCBrID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjU2KTtcbiAgICBrLmNyZWF0ZSA9IHNoYTNfMS5rZWNjYWtfMjU2LmNyZWF0ZTtcbiAgICByZXR1cm4gaztcbn0pKCk7XG5leHBvcnRzLmtlY2NhazM4NCA9ICgwLCB1dGlsc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzM4NCk7XG5leHBvcnRzLmtlY2NhazUxMiA9ICgwLCB1dGlsc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzUxMik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3J5cHRvID0gZXhwb3J0cy53cmFwSGFzaCA9IGV4cG9ydHMuZXF1YWxzQnl0ZXMgPSBleHBvcnRzLmhleFRvQnl0ZXMgPSBleHBvcnRzLmJ5dGVzVG9VdGY4ID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBleHBvcnRzLnRvSGV4ID0gZXhwb3J0cy5ieXRlc1RvSGV4ID0gZXhwb3J0cy5hc3NlcnRCeXRlcyA9IGV4cG9ydHMuYXNzZXJ0Qm9vbCA9IHZvaWQgMDtcbi8vIGJ1Zi50b1N0cmluZygnaGV4JykgLT4gdG9IZXgoYnVmKVxuY29uc3QgX2Fzc2VydF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL19hc3NlcnRcIikpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCIpO1xuY29uc3QgYXNzZXJ0Qm9vbCA9IF9hc3NlcnRfMS5kZWZhdWx0LmJvb2w7XG5leHBvcnRzLmFzc2VydEJvb2wgPSBhc3NlcnRCb29sO1xuY29uc3QgYXNzZXJ0Qnl0ZXMgPSBfYXNzZXJ0XzEuZGVmYXVsdC5ieXRlcztcbmV4cG9ydHMuYXNzZXJ0Qnl0ZXMgPSBhc3NlcnRCeXRlcztcbnZhciB1dGlsc18yID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJieXRlc1RvSGV4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmJ5dGVzVG9IZXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b0hleFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5ieXRlc1RvSGV4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuY29uY2F0Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVWaWV3XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmNyZWF0ZVZpZXc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1dGY4VG9CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi51dGY4VG9CeXRlczsgfSB9KTtcbi8vIGJ1Zi50b1N0cmluZygndXRmOCcpIC0+IGJ5dGVzVG9VdGY4KGJ1ZilcbmZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGRhdGEpIHtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgYnl0ZXNUb1V0ZjggZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZGF0YSk7XG59XG5leHBvcnRzLmJ5dGVzVG9VdGY4ID0gYnl0ZXNUb1V0Zjg7XG5mdW5jdGlvbiBoZXhUb0J5dGVzKGRhdGEpIHtcbiAgICBjb25zdCBzbGljZWQgPSBkYXRhLnN0YXJ0c1dpdGgoXCIweFwiKSA/IGRhdGEuc3Vic3RyaW5nKDIpIDogZGF0YTtcbiAgICByZXR1cm4gKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykoc2xpY2VkKTtcbn1cbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG4vLyBidWYuZXF1YWxzKGJ1ZjIpIC0+IGVxdWFsc0J5dGVzKGJ1ZiwgYnVmMilcbmZ1bmN0aW9uIGVxdWFsc0J5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmVxdWFsc0J5dGVzID0gZXF1YWxzQnl0ZXM7XG4vLyBJbnRlcm5hbCB1dGlsc1xuZnVuY3Rpb24gd3JhcEhhc2goaGFzaCkge1xuICAgIHJldHVybiAobXNnKSA9PiB7XG4gICAgICAgIF9hc3NlcnRfMS5kZWZhdWx0LmJ5dGVzKG1zZyk7XG4gICAgICAgIHJldHVybiBoYXNoKG1zZyk7XG4gICAgfTtcbn1cbmV4cG9ydHMud3JhcEhhc2ggPSB3cmFwSGFzaDtcbmV4cG9ydHMuY3J5cHRvID0gKCgpID0+IHtcbiAgICBjb25zdCB3ZWJDcnlwdG8gPSB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiAmJiBcImNyeXB0b1wiIGluIHNlbGYgPyBzZWxmLmNyeXB0byA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBub2RlUmVxdWlyZSA9IHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG1vZHVsZS5yZXF1aXJlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgbW9kdWxlLnJlcXVpcmUuYmluZChtb2R1bGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5vZGU6IG5vZGVSZXF1aXJlICYmICF3ZWJDcnlwdG8gPyBub2RlUmVxdWlyZShcImNyeXB0b1wiKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgd2ViOiB3ZWJDcnlwdG9cbiAgICB9O1xufSkoKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcbnZhciBzdHJpcEhleFByZWZpeCA9IHJlcXVpcmUoJ3N0cmlwLWhleC1wcmVmaXgnKTtcblxuLyoqXG4gKiBQYWRzIGEgYFN0cmluZ2AgdG8gaGF2ZSBhbiBldmVuIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG91dHB1dFxuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcbiAgdmFyIGEgPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBwYWRkaW5nIHRvIGV2ZW4sIHZhbHVlIG11c3QgYmUgc3RyaW5nLCBpcyBjdXJyZW50bHkgJyArIHR5cGVvZiBhICsgJywgd2hpbGUgcGFkVG9FdmVuLicpO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoICUgMikge1xuICAgIGEgPSAnMCcgKyBhO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBpbnRUb0hleChpKSB7XG4gIHZhciBoZXggPSBpLnRvU3RyaW5nKDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGBOdW1iZXJgIHRvIGEgYEJ1ZmZlcmBcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGludFRvQnVmZmVyKGkpIHtcbiAgdmFyIGhleCA9IGludFRvSGV4KGkpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHBhZFRvRXZlbihoZXguc2xpY2UoMikpLCAnaGV4Jyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBiaW5hcnkgc2l6ZSBvZiBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRCaW5hcnlTaXplKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBnZXR0aW5nIGJpbmFyeSBzaXplLCBtZXRob2QgZ2V0QmluYXJ5U2l6ZSByZXF1aXJlcyBpbnB1dCBcXCdzdHJcXCcgdG8gYmUgdHlwZSBTdHJpbmcsIGdvdCBcXCcnICsgdHlwZW9mIHN0ciArICdcXCcuJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyLCAndXRmOCcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgVFJVRSBpZiB0aGUgZmlyc3Qgc3BlY2lmaWVkIGFycmF5IGNvbnRhaW5zIGFsbCBlbGVtZW50c1xuICogZnJvbSB0aGUgc2Vjb25kIG9uZS4gRkFMU0Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHN1cGVyc2V0XG4gKiBAcGFyYW0ge2FycmF5fSBzdWJzZXRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYXJyYXlDb250YWluc0FycmF5KHN1cGVyc2V0LCBzdWJzZXQsIHNvbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VwZXJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdXBlcnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1cGVyc2V0ICsgJ1xcJycpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1YnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1YnNldCArICdcXCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdWJzZXRbQm9vbGVhbihzb21lKSAmJiAnc29tZScgfHwgJ2V2ZXJ5J10oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDA7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b1V0ZjgoaGV4KSB7XG4gIHZhciBidWZmZXJWYWx1ZSA9IG5ldyBCdWZmZXIocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KGhleCkucmVwbGFjZSgvXjArfDArJC9nLCAnJykpLCAnaGV4Jyk7XG5cbiAgcmV0dXJuIGJ1ZmZlclZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9Bc2NpaShoZXgpIHtcbiAgdmFyIHN0ciA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBpID0gMCxcbiAgICAgIGwgPSBoZXgubGVuZ3RoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICBpID0gMjtcbiAgfVxuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbVV0Zjgoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIHN0ciA9IG5ldyBCdWZmZXIoc3RyaW5nVmFsdWUsICd1dGY4Jyk7XG5cbiAgcmV0dXJuICcweCcgKyBwYWRUb0V2ZW4oc3RyLnRvU3RyaW5nKCdoZXgnKSkucmVwbGFjZSgvXjArfDArJC9nLCAnJyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xuICB2YXIgaGV4ID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgY29kZSA9IHN0cmluZ1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gIH1cblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBnZXRLZXlzKFt7YTogMSwgYjogMn0sIHthOiAzLCBiOiA0fV0sICdhJykgPT4gWzEsIDNdXG4gKlxuICogQG1ldGhvZCBnZXRLZXlzIGdldCBzcGVjaWZpYyBrZXkgZnJvbSBpbm5lciBvYmplY3QgYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0VtcHR5XG4gKiBAcmV0dXJucyB7QXJyYXl9IG91dHB1dCBqdXN0IGEgc2ltcGxlIGFycmF5IG9mIG91dHB1dCBrZXlzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBBcnJheSBhcyBcXCdwYXJhbXNcXCcgaW5wdXQsIGdvdCBcXCcnICsgdHlwZW9mIHBhcmFtcyArICdcXCcnKTtcbiAgfVxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBTdHJpbmcgZm9yIGlucHV0IFxcJ2tleVxcJyBnb3QgXFwnJyArIHR5cGVvZiBrZXkgKyAnXFwnLicpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHZhbHVlID0gcGFyYW1zW2ldW2tleV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiAhdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWJpJyk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSXMgdGhlIHN0cmluZyBhIGhleCBzdHJpbmcuXG4gKlxuICogQG1ldGhvZCBjaGVjayBpZiBzdHJpbmcgaXMgaGV4IHN0cmluZyBvZiBzcGVjaWZpYyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge0Jvb2xlYW59IG91dHB1dCB0aGUgc3RyaW5nIGlzIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheUNvbnRhaW5zQXJyYXk6IGFycmF5Q29udGFpbnNBcnJheSxcbiAgaW50VG9CdWZmZXI6IGludFRvQnVmZmVyLFxuICBnZXRCaW5hcnlTaXplOiBnZXRCaW5hcnlTaXplLFxuICBpc0hleFByZWZpeGVkOiBpc0hleFByZWZpeGVkLFxuICBzdHJpcEhleFByZWZpeDogc3RyaXBIZXhQcmVmaXgsXG4gIHBhZFRvRXZlbjogcGFkVG9FdmVuLFxuICBpbnRUb0hleDogaW50VG9IZXgsXG4gIGZyb21Bc2NpaTogZnJvbUFzY2lpLFxuICBmcm9tVXRmODogZnJvbVV0ZjgsXG4gIHRvQXNjaWk6IHRvQXNjaWksXG4gIHRvVXRmODogdG9VdGY4LFxuICBnZXRLZXlzOiBnZXRLZXlzLFxuICBpc0hleFN0cmluZzogaXNIZXhTdHJpbmdcbn07IiwiY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3Qge1xuICBpc1ZhbGlkUHJpdmF0ZSxcbiAgc3RyaXBIZXhQcmVmaXgsXG4gIHByaXZhdGVUb1B1YmxpYyxcbiAgYnVmZmVyVG9IZXgsXG4gIHB1YmxpY1RvQWRkcmVzcyxcbiAgZWNzaWduLFxuICBhcnJUb0J1ZkFycixcbn0gPSByZXF1aXJlKCdAZXRoZXJldW1qcy91dGlsJyk7XG5jb25zdCByYW5kb21CeXRlcyA9IHJlcXVpcmUoJ3JhbmRvbWJ5dGVzJyk7XG5jb25zdCB7IGtlY2NhazI1NiB9ID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2NhaycpO1xuXG5jb25zdCB0eXBlID0gJ1NpbXBsZSBLZXkgUGFpcic7XG5jb25zdCB7XG4gIGNvbmNhdFNpZyxcbiAgZGVjcnlwdCxcbiAgZ2V0RW5jcnlwdGlvblB1YmxpY0tleSxcbiAgbm9ybWFsaXplLFxuICBwZXJzb25hbFNpZ24sXG4gIHNpZ25UeXBlZERhdGEsXG4gIFNpZ25UeXBlZERhdGFWZXJzaW9uLFxufSA9IHJlcXVpcmUoJ0BtZXRhbWFzay9ldGgtc2lnLXV0aWwnKTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVLZXkoKSB7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSByYW5kb21CeXRlcygzMik7XG4gIC8vIEkgZG9uJ3QgdGhpbmsgdGhpcyBpcyBwb3NzaWJsZSwgYnV0IHRoaXMgdmFsaWRhdGlvbiB3YXMgaGVyZSBwcmV2aW91c2x5LFxuICAvLyBzbyBpdCBoYXMgYmVlbiBwcmVzZXJ2ZWQganVzdCBpbiBjYXNlLlxuICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICBpZiAoIWlzVmFsaWRQcml2YXRlKHByaXZhdGVLZXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1ByaXZhdGUga2V5IGRvZXMgbm90IHNhdGlzZnkgdGhlIGN1cnZlIHJlcXVpcmVtZW50cyAoaWUuIGl0IGlzIGludmFsaWQpJyxcbiAgICApO1xuICB9XG4gIHJldHVybiBwcml2YXRlS2V5O1xufVxuXG5jbGFzcyBTaW1wbGVLZXlyaW5nIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLl93YWxsZXRzID0gW107XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKTtcbiAgfVxuXG4gIGFzeW5jIHNlcmlhbGl6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2FsbGV0cy5tYXAoKHsgcHJpdmF0ZUtleSB9KSA9PiBwcml2YXRlS2V5LnRvU3RyaW5nKCdoZXgnKSk7XG4gIH1cblxuICBhc3luYyBkZXNlcmlhbGl6ZShwcml2YXRlS2V5cyA9IFtdKSB7XG4gICAgdGhpcy5fd2FsbGV0cyA9IHByaXZhdGVLZXlzLm1hcCgoaGV4UHJpdmF0ZUtleSkgPT4ge1xuICAgICAgY29uc3Qgc3RyaXBwZWRIZXhQcml2YXRlS2V5ID0gc3RyaXBIZXhQcmVmaXgoaGV4UHJpdmF0ZUtleSk7XG4gICAgICBjb25zdCBwcml2YXRlS2V5ID0gQnVmZmVyLmZyb20oc3RyaXBwZWRIZXhQcml2YXRlS2V5LCAnaGV4Jyk7XG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBwcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSk7XG4gICAgICByZXR1cm4geyBwcml2YXRlS2V5LCBwdWJsaWNLZXkgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGFkZEFjY291bnRzKG4gPSAxKSB7XG4gICAgY29uc3QgbmV3V2FsbGV0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBjb25zdCBwcml2YXRlS2V5ID0gZ2VuZXJhdGVLZXkoKTtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KTtcbiAgICAgIG5ld1dhbGxldHMucHVzaCh7IHByaXZhdGVLZXksIHB1YmxpY0tleSB9KTtcbiAgICB9XG4gICAgdGhpcy5fd2FsbGV0cyA9IHRoaXMuX3dhbGxldHMuY29uY2F0KG5ld1dhbGxldHMpO1xuICAgIGNvbnN0IGhleFdhbGxldHMgPSBuZXdXYWxsZXRzLm1hcCgoeyBwdWJsaWNLZXkgfSkgPT5cbiAgICAgIGJ1ZmZlclRvSGV4KHB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpKSxcbiAgICApO1xuICAgIHJldHVybiBoZXhXYWxsZXRzO1xuICB9XG5cbiAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dhbGxldHMubWFwKCh7IHB1YmxpY0tleSB9KSA9PlxuICAgICAgYnVmZmVyVG9IZXgocHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSkpLFxuICAgICk7XG4gIH1cblxuICAvLyB0eCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZXRoZXJldW1qcy10cmFuc2FjdGlvbiBjbGFzcy5cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHR4LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcihhZGRyZXNzLCBvcHRzKTtcbiAgICBjb25zdCBzaWduZWRUeCA9IHR4LnNpZ24ocHJpdktleSk7XG4gICAgLy8gTmV3ZXIgdmVyc2lvbnMgb2YgRXRoZXJldW1qcy10eCBhcmUgaW1tdXRhYmxlIGFuZCByZXR1cm4gYSBuZXcgdHggb2JqZWN0XG4gICAgcmV0dXJuIHNpZ25lZFR4ID09PSB1bmRlZmluZWQgPyB0eCA6IHNpZ25lZFR4O1xuICB9XG5cbiAgLy8gRm9yIGV0aF9zaWduLCB3ZSBuZWVkIHRvIHNpZ24gYXJiaXRyYXJ5IGRhdGE6XG4gIGFzeW5jIHNpZ25NZXNzYWdlKGFkZHJlc3MsIGRhdGEsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBzdHJpcEhleFByZWZpeChkYXRhKTtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcihhZGRyZXNzLCBvcHRzKTtcbiAgICBjb25zdCBtc2dTaWcgPSBlY3NpZ24oQnVmZmVyLmZyb20obWVzc2FnZSwgJ2hleCcpLCBwcml2S2V5KTtcbiAgICBjb25zdCByYXdNc2dTaWcgPSBjb25jYXRTaWcobXNnU2lnLnYsIG1zZ1NpZy5yLCBtc2dTaWcucyk7XG4gICAgcmV0dXJuIHJhd01zZ1NpZztcbiAgfVxuXG4gIC8vIEZvciBwZXJzb25hbF9zaWduLCB3ZSBuZWVkIHRvIHByZWZpeCB0aGUgbWVzc2FnZTpcbiAgYXN5bmMgc2lnblBlcnNvbmFsTWVzc2FnZShhZGRyZXNzLCBtc2dIZXgsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHByaXZLZXkgPSB0aGlzLl9nZXRQcml2YXRlS2V5Rm9yKGFkZHJlc3MsIG9wdHMpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBCdWZmZXIuZnJvbShwcml2S2V5LCAnaGV4Jyk7XG4gICAgY29uc3Qgc2lnID0gcGVyc29uYWxTaWduKHsgcHJpdmF0ZUtleSwgZGF0YTogbXNnSGV4IH0pO1xuICAgIHJldHVybiBzaWc7XG4gIH1cblxuICAvLyBGb3IgZXRoX2RlY3J5cHRNZXNzYWdlOlxuICBhc3luYyBkZWNyeXB0TWVzc2FnZSh3aXRoQWNjb3VudCwgZW5jcnlwdGVkRGF0YSkge1xuICAgIGNvbnN0IHdhbGxldCA9IHRoaXMuX2dldFdhbGxldEZvckFjY291bnQod2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHsgcHJpdmF0ZUtleSB9ID0gd2FsbGV0O1xuICAgIGNvbnN0IHNpZyA9IGRlY3J5cHQoeyBwcml2YXRlS2V5LCBlbmNyeXB0ZWREYXRhIH0pO1xuICAgIHJldHVybiBzaWc7XG4gIH1cblxuICAvLyBwZXJzb25hbF9zaWduVHlwZWREYXRhLCBzaWducyBkYXRhIGFsb25nIHdpdGggdGhlIHNjaGVtYVxuICBhc3luYyBzaWduVHlwZWREYXRhKFxuICAgIHdpdGhBY2NvdW50LFxuICAgIHR5cGVkRGF0YSxcbiAgICBvcHRzID0geyB2ZXJzaW9uOiBTaWduVHlwZWREYXRhVmVyc2lvbi5WMSB9LFxuICApIHtcbiAgICAvLyBUcmVhdCBpbnZhbGlkIHZlcnNpb25zIGFzIFwiVjFcIlxuICAgIGNvbnN0IHZlcnNpb24gPSBPYmplY3Qua2V5cyhTaWduVHlwZWREYXRhVmVyc2lvbikuaW5jbHVkZXMob3B0cy52ZXJzaW9uKVxuICAgICAgPyBvcHRzLnZlcnNpb25cbiAgICAgIDogU2lnblR5cGVkRGF0YVZlcnNpb24uVjE7XG5cbiAgICBjb25zdCBwcml2YXRlS2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcih3aXRoQWNjb3VudCwgb3B0cyk7XG4gICAgcmV0dXJuIHNpZ25UeXBlZERhdGEoeyBwcml2YXRlS2V5LCBkYXRhOiB0eXBlZERhdGEsIHZlcnNpb24gfSk7XG4gIH1cblxuICAvLyBnZXQgcHVibGljIGtleSBmb3IgbmFjbFxuICBhc3luYyBnZXRFbmNyeXB0aW9uUHVibGljS2V5KHdpdGhBY2NvdW50LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBwcml2S2V5ID0gdGhpcy5fZ2V0UHJpdmF0ZUtleUZvcih3aXRoQWNjb3VudCwgb3B0cyk7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0RW5jcnlwdGlvblB1YmxpY0tleShwcml2S2V5KTtcbiAgICByZXR1cm4gcHVibGljS2V5O1xuICB9XG5cbiAgX2dldFByaXZhdGVLZXlGb3IoYWRkcmVzcywgb3B0cyA9IHt9KSB7XG4gICAgaWYgKCFhZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBhZGRyZXNzLicpO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXQgPSB0aGlzLl9nZXRXYWxsZXRGb3JBY2NvdW50KGFkZHJlc3MsIG9wdHMpO1xuICAgIHJldHVybiB3YWxsZXQucHJpdmF0ZUtleTtcbiAgfVxuXG4gIC8vIHJldHVybnMgYW4gYWRkcmVzcyBzcGVjaWZpYyB0byBhbiBhcHBcbiAgYXN5bmMgZ2V0QXBwS2V5QWRkcmVzcyhhZGRyZXNzLCBvcmlnaW4pIHtcbiAgICBpZiAoIW9yaWdpbiB8fCB0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAnb3JpZ2luJyBtdXN0IGJlIGEgbm9uLWVtcHR5IHN0cmluZ2ApO1xuICAgIH1cbiAgICBjb25zdCB3YWxsZXQgPSB0aGlzLl9nZXRXYWxsZXRGb3JBY2NvdW50KGFkZHJlc3MsIHtcbiAgICAgIHdpdGhBcHBLZXlPcmlnaW46IG9yaWdpbixcbiAgICB9KTtcbiAgICBjb25zdCBhcHBLZXlBZGRyZXNzID0gbm9ybWFsaXplKFxuICAgICAgcHVibGljVG9BZGRyZXNzKHdhbGxldC5wdWJsaWNLZXkpLnRvU3RyaW5nKCdoZXgnKSxcbiAgICApO1xuICAgIHJldHVybiBhcHBLZXlBZGRyZXNzO1xuICB9XG5cbiAgLy8gZXhwb3J0QWNjb3VudCBzaG91bGQgcmV0dXJuIGEgaGV4LWVuY29kZWQgcHJpdmF0ZSBrZXk6XG4gIGFzeW5jIGV4cG9ydEFjY291bnQoYWRkcmVzcywgb3B0cyA9IHt9KSB7XG4gICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fZ2V0V2FsbGV0Rm9yQWNjb3VudChhZGRyZXNzLCBvcHRzKTtcbiAgICByZXR1cm4gd2FsbGV0LnByaXZhdGVLZXkudG9TdHJpbmcoJ2hleCcpO1xuICB9XG5cbiAgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgaWYgKFxuICAgICAgIXRoaXMuX3dhbGxldHNcbiAgICAgICAgLm1hcCgoeyBwdWJsaWNLZXkgfSkgPT5cbiAgICAgICAgICBidWZmZXJUb0hleChwdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KSkudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgKVxuICAgICAgICAuaW5jbHVkZXMoYWRkcmVzcy50b0xvd2VyQ2FzZSgpKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7YWRkcmVzc30gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO1xuICAgIH1cblxuICAgIHRoaXMuX3dhbGxldHMgPSB0aGlzLl93YWxsZXRzLmZpbHRlcihcbiAgICAgICh7IHB1YmxpY0tleSB9KSA9PlxuICAgICAgICBidWZmZXJUb0hleChwdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KSkudG9Mb3dlckNhc2UoKSAhPT1cbiAgICAgICAgYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRXYWxsZXRGb3JBY2NvdW50KGFjY291bnQsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBub3JtYWxpemUoYWNjb3VudCk7XG4gICAgbGV0IHdhbGxldCA9IHRoaXMuX3dhbGxldHMuZmluZChcbiAgICAgICh7IHB1YmxpY0tleSB9KSA9PiBidWZmZXJUb0hleChwdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KSkgPT09IGFkZHJlc3MsXG4gICAgKTtcbiAgICBpZiAoIXdhbGxldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaW1wbGUgS2V5cmluZyAtIFVuYWJsZSB0byBmaW5kIG1hdGNoaW5nIGFkZHJlc3MuJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMud2l0aEFwcEtleU9yaWdpbikge1xuICAgICAgY29uc3QgeyBwcml2YXRlS2V5IH0gPSB3YWxsZXQ7XG4gICAgICBjb25zdCBhcHBLZXlPcmlnaW5CdWZmZXIgPSBCdWZmZXIuZnJvbShvcHRzLndpdGhBcHBLZXlPcmlnaW4sICd1dGY4Jyk7XG4gICAgICBjb25zdCBhcHBLZXlCdWZmZXIgPSBCdWZmZXIuY29uY2F0KFtwcml2YXRlS2V5LCBhcHBLZXlPcmlnaW5CdWZmZXJdKTtcbiAgICAgIGNvbnN0IGFwcEtleVByaXZhdGVLZXkgPSBhcnJUb0J1ZkFycihrZWNjYWsyNTYoYXBwS2V5QnVmZmVyLCAyNTYpKTtcbiAgICAgIGNvbnN0IGFwcEtleVB1YmxpY0tleSA9IHByaXZhdGVUb1B1YmxpYyhhcHBLZXlQcml2YXRlS2V5KTtcbiAgICAgIHdhbGxldCA9IHsgcHJpdmF0ZUtleTogYXBwS2V5UHJpdmF0ZUtleSwgcHVibGljS2V5OiBhcHBLZXlQdWJsaWNLZXkgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2FsbGV0O1xuICB9XG59XG5cblNpbXBsZUtleXJpbmcudHlwZSA9IHR5cGU7XG5tb2R1bGUuZXhwb3J0cyA9IFNpbXBsZUtleXJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrNTEyID0gZXhwb3J0cy5rZWNjYWszODQgPSBleHBvcnRzLmtlY2NhazI1NiA9IGV4cG9ydHMua2VjY2FrMjI0ID0gdm9pZCAwO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmV4cG9ydHMua2VjY2FrMjI0ID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjI0KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0gKCgpID0+IHtcbiAgICBjb25zdCBrID0gKDAsIHV0aWxzXzEud3JhcEhhc2gpKHNoYTNfMS5rZWNjYWtfMjU2KTtcbiAgICBrLmNyZWF0ZSA9IHNoYTNfMS5rZWNjYWtfMjU2LmNyZWF0ZTtcbiAgICByZXR1cm4gaztcbn0pKCk7XG5leHBvcnRzLmtlY2NhazM4NCA9ICgwLCB1dGlsc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzM4NCk7XG5leHBvcnRzLmtlY2NhazUxMiA9ICgwLCB1dGlsc18xLndyYXBIYXNoKShzaGEzXzEua2VjY2FrXzUxMik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3V0cHV0ID0gZXhwb3J0cy5leGlzdHMgPSBleHBvcnRzLmhhc2ggPSBleHBvcnRzLmJ5dGVzID0gZXhwb3J0cy5ib29sID0gZXhwb3J0cy5udW1iZXIgPSB2b2lkIDA7XG5mdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0cy5udW1iZXIgPSBudW1iZXI7XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBub3QgJHtifWApO1xufVxuZXhwb3J0cy5ib29sID0gYm9vbDtcbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0cy5ieXRlcyA9IGJ5dGVzO1xuZnVuY3Rpb24gaGFzaChoYXNoKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoYXNoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoYXNoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGhhc2guYmxvY2tMZW4pO1xufVxuZXhwb3J0cy5oYXNoID0gaGFzaDtcbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0cy5vdXRwdXQgPSBvdXRwdXQ7XG5jb25zdCBhc3NlcnQgPSB7XG4gICAgbnVtYmVyLFxuICAgIGJvb2wsXG4gICAgYnl0ZXMsXG4gICAgaGFzaCxcbiAgICBleGlzdHMsXG4gICAgb3V0cHV0LFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGQgPSBleHBvcnRzLnRvQmlnID0gZXhwb3J0cy5zcGxpdCA9IGV4cG9ydHMuZnJvbUJpZyA9IHZvaWQgMDtcbmNvbnN0IFUzMl9NQVNLNjQgPSBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZXhwb3J0cy5mcm9tQmlnID0gZnJvbUJpZztcbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuZXhwb3J0cy5zcGxpdCA9IHNwbGl0O1xuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbmV4cG9ydHMudG9CaWcgPSB0b0JpZztcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBsLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChoLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBsKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuLy8gUmVtb3ZpbmcgXCJleHBvcnRcIiBoYXMgNSUgcGVyZiBwZW5hbHR5IC1fLVxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuZXhwb3J0cy5hZGQgPSBhZGQ7XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWc6IGV4cG9ydHMudG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdTY0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbmV4cG9ydHMuY3J5cHRvID0ge1xuICAgIG5vZGU6IHVuZGVmaW5lZCxcbiAgICB3ZWI6IHR5cGVvZiBzZWxmID09PSAnb2JqZWN0JyAmJiAnY3J5cHRvJyBpbiBzZWxmID8gc2VsZi5jcnlwdG8gOiB1bmRlZmluZWQsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNoYWtlMjU2ID0gZXhwb3J0cy5zaGFrZTEyOCA9IGV4cG9ydHMua2VjY2FrXzUxMiA9IGV4cG9ydHMua2VjY2FrXzM4NCA9IGV4cG9ydHMua2VjY2FrXzI1NiA9IGV4cG9ydHMua2VjY2FrXzIyNCA9IGV4cG9ydHMuc2hhM181MTIgPSBleHBvcnRzLnNoYTNfMzg0ID0gZXhwb3J0cy5zaGEzXzI1NiA9IGV4cG9ydHMuc2hhM18yMjQgPSBleHBvcnRzLktlY2NhayA9IGV4cG9ydHMua2VjY2FrUCA9IHZvaWQgMDtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCBfdTY0X2pzXzEgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgW1NIQTNfUEksIFNIQTNfUk9UTCwgX1NIQTNfSU9UQV0gPSBbW10sIFtdLCBbXV07XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfN24gPSBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gQmlnSW50KDB4NzEpO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IFtTSEEzX0lPVEFfSCwgU0hBM19JT1RBX0xdID0gX3U2NF9qc18xLmRlZmF1bHQuc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IF91NjRfanNfMS5kZWZhdWx0LnJvdGxCSChoLCBsLCBzKSA6IF91NjRfanNfMS5kZWZhdWx0LnJvdGxTSChoLCBsLCBzKTtcbmNvbnN0IHJvdGxMID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IF91NjRfanNfMS5kZWZhdWx0LnJvdGxCTChoLCBsLCBzKSA6IF91NjRfanNfMS5kZWZhdWx0LnJvdGxTTChoLCBsLCBzKTtcbi8vIFNhbWUgYXMga2VjY2FrZjE2MDAsIGJ1dCBhbGxvd3MgdG8gc2tpcCBzb21lIHJvdW5kc1xuZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgQi5maWxsKDApO1xufVxuZXhwb3J0cy5rZWNjYWtQID0ga2VjY2FrUDtcbmNsYXNzIEtlY2NhayBleHRlbmRzIHV0aWxzX2pzXzEuSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5udW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5leGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5ieXRlcyhvdXQpO1xuICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICBjb25zdCBidWZmZXJPdXQgPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBvdXQubGVuZ3RoOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3NPdXQgPj0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zT3V0LCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgb3V0LnNldChidWZmZXJPdXQuc3ViYXJyYXkodGhpcy5wb3NPdXQsIHRoaXMucG9zT3V0ICsgdGFrZSksIHBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvc091dCArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgeG9mSW50byhvdXQpIHtcbiAgICAgICAgLy8gU2hhMy9LZWNjYWsgdXNhZ2Ugd2l0aCBYT0YgaXMgcHJvYmFibHkgbWlzdGFrZSwgb25seSBTSEFLRSBpbnN0YW5jZXMgY2FuIGRvIFhPRlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlWE9GKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYT0YgaXMgbm90IHBvc3NpYmxlIGZvciB0aGlzIGluc3RhbmNlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgIH1cbiAgICB4b2YoYnl0ZXMpIHtcbiAgICAgICAgX2Fzc2VydF9qc18xLmRlZmF1bHQubnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBfYXNzZXJ0X2pzXzEuZGVmYXVsdC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGF0ZS5maWxsKDApO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCByb3VuZHMsIGVuYWJsZVhPRiB9ID0gdGhpcztcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiwgcm91bmRzKSk7XG4gICAgICAgIHRvLnN0YXRlMzIuc2V0KHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRvLnBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0by5wb3NPdXQgPSB0aGlzLnBvc091dDtcbiAgICAgICAgdG8uZmluaXNoZWQgPSB0aGlzLmZpbmlzaGVkO1xuICAgICAgICB0by5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIFN1ZmZpeCBjYW4gY2hhbmdlIGluIGNTSEFLRVxuICAgICAgICB0by5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8uZW5hYmxlWE9GID0gZW5hYmxlWE9GO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSB0aGlzLmRlc3Ryb3llZDtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbmV4cG9ydHMuS2VjY2FrID0gS2VjY2FrO1xuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbikpO1xuZXhwb3J0cy5zaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMuc2hhM18yNTYgPSBnZW4oMHgwNiwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydHMuc2hhM18zODQgPSBnZW4oMHgwNiwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydHMuc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMjI0ID0gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIGtlY2Nhay0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20gU0hBMy0yNTYuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydHMua2VjY2FrXzI1NiA9IGdlbigweDAxLCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0cy5rZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnRzLmtlY2Nha181MTIgPSBnZW4oMHgwMSwgNzIsIDUxMiAvIDgpO1xuY29uc3QgZ2VuU2hha2UgPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3JXaXRoT3B0cykoKG9wdHMgPSB7fSkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvcHRzLmRrTGVuID09PSB1bmRlZmluZWQgPyBvdXRwdXRMZW4gOiBvcHRzLmRrTGVuLCB0cnVlKSk7XG5leHBvcnRzLnNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydHMuc2hha2UyNTYgPSBnZW5TaGFrZSgweDFmLCAxMzYsIDI1NiAvIDgpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy53cmFwQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yID0gZXhwb3J0cy5jaGVja09wdHMgPSBleHBvcnRzLkhhc2ggPSBleHBvcnRzLmNvbmNhdEJ5dGVzID0gZXhwb3J0cy50b0J5dGVzID0gZXhwb3J0cy51dGY4VG9CeXRlcyA9IGV4cG9ydHMuYXN5bmNMb29wID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb0hleCA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMucm90ciA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51OCA9IHZvaWQgMDtcbi8vIFRoZSBpbXBvcnQgaGVyZSBpcyB2aWEgdGhlIHBhY2thZ2UgbmFtZS4gVGhpcyBpcyB0byBlbnN1cmVcbi8vIHRoYXQgZXhwb3J0cyBtYXBwaW5nL3Jlc29sdXRpb24gZG9lcyBmYWxsIGludG8gcGxhY2UuXG5jb25zdCBjcnlwdG9fMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2NyeXB0b1wiKTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbmV4cG9ydHMudTMyID0gdTMyO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5jb25zdCBjcmVhdGVWaWV3ID0gKGFycikgPT4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5jb25zdCByb3RyID0gKHdvcmQsIHNoaWZ0KSA9PiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbmV4cG9ydHMucm90ciA9IHJvdHI7XG5leHBvcnRzLmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuLy8gVGhlcmUgaXMgYWxtb3N0IG5vIGJpZyBlbmRpYW4gaGFyZHdhcmUsIGJ1dCBqcyB0eXBlZCBhcnJheXMgdXNlcyBwbGF0Zm9ybSBzcGVjaWZpYyBlbmRpYW5uZXNzLlxuLy8gU28sIGp1c3QgdG8gYmUgc3VyZSBub3QgdG8gY29ycnVwdCBhbnl0aGluZy5cbmlmICghZXhwb3J0cy5pc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhkZSwgMHhhZCwgMHhiZSwgMHhlZl0pKVxuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KHVpbnQ4YSkge1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGlmICghKHVpbnQ4YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW3VpbnQ4YVtpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnRzLmJ5dGVzVG9IZXggPSBieXRlc1RvSGV4O1xuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdkZWFkYmVlZicpXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2hleFRvQnl0ZXM6IGV4cGVjdGVkIHN0cmluZywgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICB9XG4gICAgaWYgKGhleC5sZW5ndGggJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleFRvQnl0ZXM6IHJlY2VpdmVkIGludmFsaWQgdW5wYWRkZWQgaGV4Jyk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuIEhvd2V2ZXIsIGNhbGwgdG8gYXN5bmMgZnVuY3Rpb24gd2lsbCByZXR1cm4gUHJvbWlzZVxuLy8gd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvbiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8vIFJldHVybnMgY29udHJvbCB0byB0aHJlYWQgZWFjaCAndGljaycgbXMgdG8gYXZvaWQgYmxvY2tpbmdcbmFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCAoMCwgZXhwb3J0cy5uZXh0VGljaykoKTtcbiAgICAgICAgdHMgKz0gZGlmZjtcbiAgICB9XG59XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKTtcbn1cbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbmZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGlucHV0IHR5cGUgaXMgVWludDhBcnJheSAoZ290ICR7dHlwZW9mIGRhdGF9KWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbi8qKlxuICogQ29uY2F0cyBVaW50OEFycmF5LXMgaW50byBvbmU7IGxpa2UgYEJ1ZmZlci5jb25jYXQoW2J1ZjEsIGJ1ZjJdKWBcbiAqIEBleGFtcGxlIGNvbmNhdEJ5dGVzKGJ1ZjEsIGJ1ZjIpXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGlmICghYXJyYXlzLmV2ZXJ5KChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBsaXN0IGV4cGVjdGVkJyk7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5jbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG4vLyBDaGVjayBpZiBvYmplY3QgZG9lbnMndCBoYXZlIGN1c3RvbSBjb25zdHJ1Y3RvciAobGlrZSBVaW50OEFycmF5L0FycmF5KVxuY29uc3QgaXNQbGFpbk9iamVjdCA9IChvYmopID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYgKHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCAhaXNQbGFpbk9iamVjdChvcHRzKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobWVzc2FnZSkgPT4gaGFzaENvbnN0cnVjdG9yKCkudXBkYXRlKHRvQnl0ZXMobWVzc2FnZSkpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zdHJ1Y3RvcigpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnN0cnVjdG9yKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy53cmFwQ29uc3RydWN0b3IgPSB3cmFwQ29uc3RydWN0b3I7XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cztcbi8qKlxuICogU2VjdXJlIFBSTkdcbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8ud2ViKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8ud2ViLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjcnlwdG9fMS5jcnlwdG8ubm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY3J5cHRvXzEuY3J5cHRvLm5vZGUucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpLmJ1ZmZlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZW52aXJvbm1lbnQgZG9lc24ndCBoYXZlIHJhbmRvbUJ5dGVzIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcnlwdG8gPSBleHBvcnRzLndyYXBIYXNoID0gZXhwb3J0cy5lcXVhbHNCeXRlcyA9IGV4cG9ydHMuaGV4VG9CeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBleHBvcnRzLnV0ZjhUb0J5dGVzID0gZXhwb3J0cy5jcmVhdGVWaWV3ID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMudG9IZXggPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmFzc2VydEJ5dGVzID0gZXhwb3J0cy5hc3NlcnRCb29sID0gdm9pZCAwO1xuLy8gYnVmLnRvU3RyaW5nKCdoZXgnKSAtPiB0b0hleChidWYpXG5jb25zdCBfYXNzZXJ0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBub2JsZS9oYXNoZXMvX2Fzc2VydFwiKSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBhc3NlcnRCb29sID0gX2Fzc2VydF8xLmRlZmF1bHQuYm9vbDtcbmV4cG9ydHMuYXNzZXJ0Qm9vbCA9IGFzc2VydEJvb2w7XG5jb25zdCBhc3NlcnRCeXRlcyA9IF9hc3NlcnRfMS5kZWZhdWx0LmJ5dGVzO1xuZXhwb3J0cy5hc3NlcnRCeXRlcyA9IGFzc2VydEJ5dGVzO1xudmFyIHV0aWxzXzIgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ5dGVzVG9IZXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuYnl0ZXNUb0hleDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRvSGV4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLmJ5dGVzVG9IZXg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25jYXRCeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMi5jb25jYXRCeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVZpZXdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzIuY3JlYXRlVmlldzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV0ZjhUb0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18yLnV0ZjhUb0J5dGVzOyB9IH0pO1xuLy8gYnVmLnRvU3RyaW5nKCd1dGY4JykgLT4gYnl0ZXNUb1V0ZjgoYnVmKVxuZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoZGF0YSkge1xuICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBieXRlc1RvVXRmOCBleHBlY3RlZCBVaW50OEFycmF5LCBnb3QgJHt0eXBlb2YgZGF0YX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShkYXRhKTtcbn1cbmV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBieXRlc1RvVXRmODtcbmZ1bmN0aW9uIGhleFRvQnl0ZXMoZGF0YSkge1xuICAgIGNvbnN0IHNsaWNlZCA9IGRhdGEuc3RhcnRzV2l0aChcIjB4XCIpID8gZGF0YS5zdWJzdHJpbmcoMikgOiBkYXRhO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKShzbGljZWQpO1xufVxuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbi8vIGJ1Zi5lcXVhbHMoYnVmMikgLT4gZXF1YWxzQnl0ZXMoYnVmLCBidWYyKVxuZnVuY3Rpb24gZXF1YWxzQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuZXF1YWxzQnl0ZXMgPSBlcXVhbHNCeXRlcztcbi8vIEludGVybmFsIHV0aWxzXG5mdW5jdGlvbiB3cmFwSGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIChtc2cpID0+IHtcbiAgICAgICAgX2Fzc2VydF8xLmRlZmF1bHQuYnl0ZXMobXNnKTtcbiAgICAgICAgcmV0dXJuIGhhc2gobXNnKTtcbiAgICB9O1xufVxuZXhwb3J0cy53cmFwSGFzaCA9IHdyYXBIYXNoO1xuZXhwb3J0cy5jcnlwdG8gPSAoKCkgPT4ge1xuICAgIGNvbnN0IHdlYkNyeXB0byA9IHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiICYmIFwiY3J5cHRvXCIgaW4gc2VsZiA/IHNlbGYuY3J5cHRvIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vZGVSZXF1aXJlID0gdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2YgbW9kdWxlLnJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBtb2R1bGUucmVxdWlyZS5iaW5kKG1vZHVsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogbm9kZVJlcXVpcmUgJiYgIXdlYkNyeXB0byA/IG5vZGVSZXF1aXJlKFwiY3J5cHRvXCIpIDogdW5kZWZpbmVkLFxuICAgICAgICB3ZWI6IHdlYkNyeXB0b1xuICAgIH07XG59KSgpO1xuIiwiY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3V0aWwnKTtcbmNvbnN0IEhES2V5ID0gcmVxdWlyZSgnaGRrZXknKTtcbmNvbnN0IFRyZXpvckNvbm5lY3QgPSByZXF1aXJlKCdAdHJlem9yL2Nvbm5lY3Qtd2ViJykuZGVmYXVsdDtcbmNvbnN0IHsgVHJhbnNhY3Rpb25GYWN0b3J5IH0gPSByZXF1aXJlKCdAZXRoZXJldW1qcy90eCcpO1xuY29uc3QgeyB0cmFuc2Zvcm1UeXBlZERhdGEgfSA9IHJlcXVpcmUoJ0B0cmV6b3IvY29ubmVjdC1wbHVnaW4tZXRoZXJldW0nKTtcblxuY29uc3QgaGRQYXRoU3RyaW5nID0gYG0vNDQnLzYwJy8wJy8wYDtcbmNvbnN0IFNMSVAwMDQ0VGVzdG5ldFBhdGggPSBgbS80NCcvMScvMCcvMGA7XG5cbmNvbnN0IEFMTE9XRURfSERfUEFUSFMgPSB7XG4gIFtoZFBhdGhTdHJpbmddOiB0cnVlLFxuICBbU0xJUDAwNDRUZXN0bmV0UGF0aF06IHRydWUsXG59O1xuXG5jb25zdCBrZXlyaW5nVHlwZSA9ICdUcmV6b3IgSGFyZHdhcmUnO1xuY29uc3QgcGF0aEJhc2UgPSAnbSc7XG5jb25zdCBNQVhfSU5ERVggPSAxMDAwO1xuY29uc3QgREVMQVlfQkVUV0VFTl9QT1BVUFMgPSAxMDAwO1xuY29uc3QgVFJFWk9SX0NPTk5FQ1RfTUFOSUZFU1QgPSB7XG4gIGVtYWlsOiAnc3VwcG9ydEBtZXRhbWFzay5pbycsXG4gIGFwcFVybDogJ2h0dHBzOi8vbWV0YW1hc2suaW8nLFxufTtcblxuZnVuY3Rpb24gd2FpdChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnQGV0aGVyZXVtanMvdHgnKS5UeXBlZFRyYW5zYWN0aW9ufSBUeXBlZFRyYW5zYWN0aW9uXG4gKiBAdHlwZWRlZiB7SW5zdGFuY2VUeXBlPF9faW1wb3J0X18oXCJldGhlcmV1bWpzLXR4XCIpPn0gT2xkRXRoSnNUcmFuc2FjdGlvblxuICovXG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHRyYW5zYWN0aW9uIGlzIG1hZGUgd2l0aCBldGhlcmV1bWpzLXR4IG9yIEBldGhlcmV1bWpzL3R4XG4gKlxuICogVHJhbnNhY3Rpb25zIGJ1aWx0IHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgZXRoZXJldW1qcy10eCBoYXZlIGFcbiAqIGdldENoYWluSWQgbWV0aG9kIHRoYXQgbmV3ZXIgdmVyc2lvbnMgZG8gbm90LlxuICogT2xkZXIgdmVyc2lvbnMgYXJlIG11dGFibGVcbiAqIHdoaWxlIG5ld2VyIHZlcnNpb25zIGRlZmF1bHQgdG8gYmVpbmcgaW1tdXRhYmxlLlxuICogRXhwZWN0ZWQgc2hhcGUgYW5kIHR5cGVcbiAqIG9mIGRhdGEgZm9yIHYsIHIgYW5kIHMgZGlmZmVyIChCdWZmZXIgKG9sZCkgdnMgQk4gKG5ldykpLlxuICpcbiAqIEBwYXJhbSB7VHlwZWRUcmFuc2FjdGlvbiB8IE9sZEV0aEpzVHJhbnNhY3Rpb259IHR4XG4gKiBAcmV0dXJucyB7dHggaXMgT2xkRXRoSnNUcmFuc2FjdGlvbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdHggaXMgYW4gb2xkLXN0eWxlIGV0aGVyZXVtanMtdHggdHJhbnNhY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGlzT2xkU3R5bGVFdGhlcmV1bWpzVHgodHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eC5nZXRDaGFpbklkID09PSAnZnVuY3Rpb24nO1xufVxuXG5jbGFzcyBUcmV6b3JLZXlyaW5nIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnR5cGUgPSBrZXlyaW5nVHlwZTtcbiAgICB0aGlzLmFjY291bnRzID0gW107XG4gICAgdGhpcy5oZGsgPSBuZXcgSERLZXkoKTtcbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHRoaXMucGVyUGFnZSA9IDU7XG4gICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSAwO1xuICAgIHRoaXMucGF0aHMgPSB7fTtcbiAgICB0aGlzLmRlc2VyaWFsaXplKG9wdHMpO1xuICAgIHRoaXMudHJlem9yQ29ubmVjdEluaXRpYXRlZCA9IGZhbHNlO1xuXG4gICAgVHJlem9yQ29ubmVjdC5vbignREVWSUNFX0VWRU5UJywgKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQgJiYgZXZlbnQucGF5bG9hZCAmJiBldmVudC5wYXlsb2FkLmZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMubW9kZWwgPSBldmVudC5wYXlsb2FkLmZlYXR1cmVzLm1vZGVsO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLnRyZXpvckNvbm5lY3RJbml0aWF0ZWQpIHtcbiAgICAgIFRyZXpvckNvbm5lY3QuaW5pdCh7IG1hbmlmZXN0OiBUUkVaT1JfQ09OTkVDVF9NQU5JRkVTVCwgbGF6eUxvYWQ6IHRydWUgfSk7XG4gICAgICB0aGlzLnRyZXpvckNvbm5lY3RJbml0aWF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtb2RlbCwgaWYga25vd24uXG4gICAqIFRoaXMgbWF5IGJlIGB1bmRlZmluZWRgIGlmIHRoZSBtb2RlbCBoYXNuJ3QgYmVlbiBsb2FkZWQgeWV0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7XCJUXCIgfCBcIjFcIiB8IHVuZGVmaW5lZH1cbiAgICovXG4gIGdldE1vZGVsKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGVsO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAvLyBUaGlzIHJlbW92ZXMgdGhlIFRyZXpvciBDb25uZWN0IGlmcmFtZSBmcm9tIHRoZSBET01cbiAgICAvLyBUaGlzIG1ldGhvZCBpcyBub3Qgd2VsbCBkb2N1bWVudGVkLCBidXQgdGhlIGNvZGUgaXQgY2FsbHMgY2FuIGJlIHNlZW5cbiAgICAvLyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vdHJlem9yL2Nvbm5lY3QvYmxvYi9kZWM0YTU2YWY4YTY1YTYwNTlmYjVmNjNmYTNjNjY5MGQyYzM3ZTAwL3NyYy9qcy9pZnJhbWUvYnVpbGRlci5qcyNMMTgxXG4gICAgVHJlem9yQ29ubmVjdC5kaXNwb3NlKCk7XG4gIH1cblxuICBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICBoZFBhdGg6IHRoaXMuaGRQYXRoLFxuICAgICAgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMsXG4gICAgICBwYWdlOiB0aGlzLnBhZ2UsXG4gICAgICBwYXRoczogdGhpcy5wYXRocyxcbiAgICAgIHBlclBhZ2U6IHRoaXMucGVyUGFnZSxcbiAgICAgIHVubG9ja2VkQWNjb3VudDogdGhpcy51bmxvY2tlZEFjY291bnQsXG4gICAgfSk7XG4gIH1cblxuICBkZXNlcmlhbGl6ZShvcHRzID0ge30pIHtcbiAgICB0aGlzLmhkUGF0aCA9IG9wdHMuaGRQYXRoIHx8IGhkUGF0aFN0cmluZztcbiAgICB0aGlzLmFjY291bnRzID0gb3B0cy5hY2NvdW50cyB8fCBbXTtcbiAgICB0aGlzLnBhZ2UgPSBvcHRzLnBhZ2UgfHwgMDtcbiAgICB0aGlzLnBlclBhZ2UgPSBvcHRzLnBlclBhZ2UgfHwgNTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICBpc1VubG9ja2VkKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuaGRrICYmIHRoaXMuaGRrLnB1YmxpY0tleSk7XG4gIH1cblxuICB1bmxvY2soKSB7XG4gICAgaWYgKHRoaXMuaXNVbmxvY2tlZCgpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdhbHJlYWR5IHVubG9ja2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBUcmV6b3JDb25uZWN0LmdldFB1YmxpY0tleSh7XG4gICAgICAgIHBhdGg6IHRoaXMuaGRQYXRoLFxuICAgICAgICBjb2luOiAnRVRIJyxcbiAgICAgIH0pXG4gICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgIGlmIChyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmhkay5wdWJsaWNLZXkgPSBCdWZmZXIuZnJvbShyZXNwb25zZS5wYXlsb2FkLnB1YmxpY0tleSwgJ2hleCcpO1xuICAgICAgICAgICAgdGhpcy5oZGsuY2hhaW5Db2RlID0gQnVmZmVyLmZyb20ocmVzcG9uc2UucGF5bG9hZC5jaGFpbkNvZGUsICdoZXgnKTtcbiAgICAgICAgICAgIHJlc29sdmUoJ2p1c3QgdW5sb2NrZWQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgKHJlc3BvbnNlLnBheWxvYWQgJiYgcmVzcG9uc2UucGF5bG9hZC5lcnJvcikgfHwgJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoKGUgJiYgZS50b1N0cmluZygpKSB8fCAnVW5rbm93biBlcnJvcicpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBzZXRBY2NvdW50VG9VbmxvY2soaW5kZXgpIHtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IHBhcnNlSW50KGluZGV4LCAxMCk7XG4gIH1cblxuICBhZGRBY2NvdW50cyhuID0gMSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnVubG9jaygpXG4gICAgICAgIC50aGVuKChfKSA9PiB7XG4gICAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMudW5sb2NrZWRBY2NvdW50O1xuICAgICAgICAgIGNvbnN0IHRvID0gZnJvbSArIG47XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLl9hZGRyZXNzRnJvbUluZGV4KHBhdGhCYXNlLCBpKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY2NvdW50cy5pbmNsdWRlcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgICB0aGlzLmFjY291bnRzLnB1c2goYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhZ2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKHRoaXMuYWNjb3VudHMpO1xuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Rmlyc3RQYWdlKCkge1xuICAgIHRoaXMucGFnZSA9IDA7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpO1xuICB9XG5cbiAgZ2V0TmV4dFBhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpO1xuICB9XG5cbiAgZ2V0UHJldmlvdXNQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgtMSk7XG4gIH1cblxuICBfX2dldFBhZ2UoaW5jcmVtZW50KSB7XG4gICAgdGhpcy5wYWdlICs9IGluY3JlbWVudDtcblxuICAgIGlmICh0aGlzLnBhZ2UgPD0gMCkge1xuICAgICAgdGhpcy5wYWdlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy51bmxvY2soKVxuICAgICAgICAudGhlbigoXykgPT4ge1xuICAgICAgICAgIGNvbnN0IGZyb20gPSAodGhpcy5wYWdlIC0gMSkgKiB0aGlzLnBlclBhZ2U7XG4gICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlO1xuXG4gICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBbXTtcblxuICAgICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpO1xuICAgICAgICAgICAgYWNjb3VudHMucHVzaCh7XG4gICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgIGJhbGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBhdGhzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShhY2NvdW50cyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRBY2NvdW50cygpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjb3VudHMuc2xpY2UoKSk7XG4gIH1cblxuICByZW1vdmVBY2NvdW50KGFkZHJlc3MpIHtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5hY2NvdW50cy5tYXAoKGEpID0+IGEudG9Mb3dlckNhc2UoKSkuaW5jbHVkZXMoYWRkcmVzcy50b0xvd2VyQ2FzZSgpKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBZGRyZXNzICR7YWRkcmVzc30gbm90IGZvdW5kIGluIHRoaXMga2V5cmluZ2ApO1xuICAgIH1cblxuICAgIHRoaXMuYWNjb3VudHMgPSB0aGlzLmFjY291bnRzLmZpbHRlcihcbiAgICAgIChhKSA9PiBhLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25zIGEgdHJhbnNhY3Rpb24gdXNpbmcgVHJlem9yLlxuICAgKlxuICAgKiBBY2NlcHRzIGVpdGhlciBhbiBldGhlcmV1bWpzLXR4IG9yIEBldGhlcmV1bWpzL3R4IHRyYW5zYWN0aW9uLCBhbmQgcmV0dXJuc1xuICAgKiB0aGUgc2FtZSB0eXBlLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge1R5cGVkVHJhbnNhY3Rpb24gfCBPbGRFdGhKc1RyYW5zYWN0aW9ufSBUcmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEhleCBzdHJpbmcgYWRkcmVzcy5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHggLSBJbnN0YW5jZSBvZiBlaXRoZXIgbmV3LXN0eWxlIG9yIG9sZC1zdHlsZSBldGhlcmV1bWpzIHRyYW5zYWN0aW9uLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmFuc2FjdGlvbj59IFRoZSBzaWduZWQgdHJhbnNhY3Rpb24sIGFuIGluc3RhbmNlIG9mIGVpdGhlciBuZXctc3R5bGUgb3Igb2xkLXN0eWxlXG4gICAqIGV0aGVyZXVtanMgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBzaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgdHgpIHtcbiAgICBpZiAoaXNPbGRTdHlsZUV0aGVyZXVtanNUeCh0eCkpIHtcbiAgICAgIC8vIEluIHRoaXMgdmVyc2lvbiBvZiBldGhlcmV1bWpzLXR4IHdlIG11c3QgYWRkIHRoZSBjaGFpbklkIGluIGhleCBmb3JtYXRcbiAgICAgIC8vIHRvIHRoZSBpbml0aWFsIHYgdmFsdWUuIFRoZSBjaGFpbklkIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIHNlcmlhbGl6ZWRcbiAgICAgIC8vIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG9ubHkgY29tbXVuaWNhdGVkIHRvIGV0aGVyZXVtanMtdHggaW4gdGhpc1xuICAgICAgLy8gdmFsdWUuIEluIG5ld2VyIHZlcnNpb25zIHRoZSBjaGFpbklkIGlzIGNvbW11bmljYXRlZCB2aWEgdGhlICdDb21tb24nXG4gICAgICAvLyBvYmplY3QuXG4gICAgICByZXR1cm4gdGhpcy5fc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHR4LmdldENoYWluSWQoKSwgdHgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHR4LnYgPSBCdWZmZXIuZnJvbShwYXlsb2FkLnYsICdoZXgnKTtcbiAgICAgICAgdHguciA9IEJ1ZmZlci5mcm9tKHBheWxvYWQuciwgJ2hleCcpO1xuICAgICAgICB0eC5zID0gQnVmZmVyLmZyb20ocGF5bG9hZC5zLCAnaGV4Jyk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2lnblRyYW5zYWN0aW9uKFxuICAgICAgYWRkcmVzcyxcbiAgICAgIE51bWJlcih0eC5jb21tb24uY2hhaW5JZCgpKSxcbiAgICAgIHR4LFxuICAgICAgKHBheWxvYWQpID0+IHtcbiAgICAgICAgLy8gQmVjYXVzZSB0eCB3aWxsIGJlIGltbXV0YWJsZSwgZmlyc3QgZ2V0IGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgdGhhdFxuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSB0cmFuc2FjdGlvbi4gVXNpbmcgdHhEYXRhIGhlcmUgYXMgaXQgYWxpZ25zIHdpdGggdGhlXG4gICAgICAgIC8vIG5vbWVuY2xhdHVyZSBvZiBldGhlcmV1bWpzL3R4LlxuICAgICAgICBjb25zdCB0eERhdGEgPSB0eC50b0pTT04oKTtcbiAgICAgICAgLy8gVGhlIGZyb21UeERhdGEgdXRpbGl0eSBleHBlY3RzIGEgdHlwZSB0byBzdXBwb3J0IHRyYW5zYWN0aW9ucyB3aXRoIGEgdHlwZSBvdGhlciB0aGFuIDBcbiAgICAgICAgdHhEYXRhLnR5cGUgPSB0eC50eXBlO1xuICAgICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgdixyIGFuZCBzIHRvIGJlIGhleCBwcmVmaXhlZFxuICAgICAgICB0eERhdGEudiA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHBheWxvYWQudik7XG4gICAgICAgIHR4RGF0YS5yID0gZXRoVXRpbC5hZGRIZXhQcmVmaXgocGF5bG9hZC5yKTtcbiAgICAgICAgdHhEYXRhLnMgPSBldGhVdGlsLmFkZEhleFByZWZpeChwYXlsb2FkLnMpO1xuICAgICAgICAvLyBBZG9wdCB0aGUgJ2NvbW1vbicgb3B0aW9uIGZyb20gdGhlIG9yaWdpbmFsIHRyYW5zYWN0aW9uIGFuZCBzZXQgdGhlXG4gICAgICAgIC8vIHJldHVybmVkIG9iamVjdCB0byBiZSBmcm96ZW4gaWYgdGhlIG9yaWdpbmFsIGlzIGZyb3plbi5cbiAgICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4RGF0YSwge1xuICAgICAgICAgIGNvbW1vbjogdHguY29tbW9uLFxuICAgICAgICAgIGZyZWV6ZTogT2JqZWN0LmlzRnJvemVuKHR4KSxcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHRlbXBsYXRlIHtUeXBlZFRyYW5zYWN0aW9uIHwgT2xkRXRoSnNUcmFuc2FjdGlvbn0gVHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBIZXggc3RyaW5nIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjaGFpbklkIC0gQ2hhaW4gSURcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHggLSBJbnN0YW5jZSBvZiBlaXRoZXIgbmV3LXN0eWxlIG9yIG9sZC1zdHlsZSBldGhlcmV1bWpzIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0geyhfX2ltcG9ydF9fKCd0cmV6b3ItY29ubmVjdCcpLkV0aGVyZXVtU2lnbmVkVHgpID0+IFRyYW5zYWN0aW9ufSBoYW5kbGVTaWduaW5nIC0gQ29udmVydHMgc2lnbmVkIHRyYW5zYWN0aW9uXG4gICAqIHRvIHRoZSBzYW1lIG5ldy1zdHlsZSBvciBvbGQtc3R5bGUgZXRoZXJldW1qcy10eC5cbiAgICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb24+fSBUaGUgc2lnbmVkIHRyYW5zYWN0aW9uLCBhbiBpbnN0YW5jZSBvZiBlaXRoZXIgbmV3LXN0eWxlIG9yIG9sZC1zdHlsZVxuICAgKiBldGhlcmV1bWpzIHRyYW5zYWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgX3NpZ25UcmFuc2FjdGlvbihhZGRyZXNzLCBjaGFpbklkLCB0eCwgaGFuZGxlU2lnbmluZykge1xuICAgIGxldCB0cmFuc2FjdGlvbjtcbiAgICBpZiAoaXNPbGRTdHlsZUV0aGVyZXVtanNUeCh0eCkpIHtcbiAgICAgIC8vIGxlZ2FjeSB0cmFuc2FjdGlvbiBmcm9tIGV0aGVyZXVtanMtdHggcGFja2FnZSBoYXMgbm8gLnRvSlNPTigpIGZ1bmN0aW9uLFxuICAgICAgLy8gc28gd2UgbmVlZCB0byBjb252ZXJ0IHRvIGhleC1zdHJpbmdzIG1hbnVhbGx5IG1hbnVhbGx5XG4gICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgdG86IHRoaXMuX25vcm1hbGl6ZSh0eC50byksXG4gICAgICAgIHZhbHVlOiB0aGlzLl9ub3JtYWxpemUodHgudmFsdWUpLFxuICAgICAgICBkYXRhOiB0aGlzLl9ub3JtYWxpemUodHguZGF0YSksXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIG5vbmNlOiB0aGlzLl9ub3JtYWxpemUodHgubm9uY2UpLFxuICAgICAgICBnYXNMaW1pdDogdGhpcy5fbm9ybWFsaXplKHR4Lmdhc0xpbWl0KSxcbiAgICAgICAgZ2FzUHJpY2U6IHRoaXMuX25vcm1hbGl6ZSh0eC5nYXNQcmljZSksXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBuZXctc3R5bGUgdHJhbnNhY3Rpb24gZnJvbSBAZXRoZXJldW1qcy90eCBwYWNrYWdlXG4gICAgICAvLyB3ZSBjYW4ganVzdCBjb3B5IHR4LnRvSlNPTigpIGZvciBldmVyeXRoaW5nIGV4Y2VwdCBjaGFpbklkLCB3aGljaCBtdXN0IGJlIGEgbnVtYmVyXG4gICAgICB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgLi4udHgudG9KU09OKCksXG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIHRvOiB0aGlzLl9ub3JtYWxpemUodHgudG8pLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdHVzID0gYXdhaXQgdGhpcy51bmxvY2soKTtcbiAgICAgIGF3YWl0IHdhaXQoc3RhdHVzID09PSAnanVzdCB1bmxvY2tlZCcgPyBERUxBWV9CRVRXRUVOX1BPUFVQUyA6IDApO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBUcmV6b3JDb25uZWN0LmV0aGVyZXVtU2lnblRyYW5zYWN0aW9uKHtcbiAgICAgICAgcGF0aDogdGhpcy5fcGF0aEZyb21BZGRyZXNzKGFkZHJlc3MpLFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgY29uc3QgbmV3T3JNdXRhdGVkVHggPSBoYW5kbGVTaWduaW5nKHJlc3BvbnNlLnBheWxvYWQpO1xuXG4gICAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhcbiAgICAgICAgICBldGhVdGlsLmFkZEhleFByZWZpeChcbiAgICAgICAgICAgIG5ld09yTXV0YXRlZFR4LmdldFNlbmRlckFkZHJlc3MoKS50b1N0cmluZygnaGV4JyksXG4gICAgICAgICAgKSxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgY29ycmVjdEFkZHJlc3MgPSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBpZiAoYWRkcmVzc1NpZ25lZFdpdGggIT09IGNvcnJlY3RBZGRyZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2lnbmF0dXJlIGRvZXNuJ3QgbWF0Y2ggdGhlIHJpZ2h0IGFkZHJlc3NcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3T3JNdXRhdGVkVHg7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIChyZXNwb25zZS5wYXlsb2FkICYmIHJlc3BvbnNlLnBheWxvYWQuZXJyb3IpIHx8ICdVbmtub3duIGVycm9yJyxcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKChlICYmIGUudG9TdHJpbmcoKSkgfHwgJ1Vua25vd24gZXJyb3InKTtcbiAgICB9XG4gIH1cblxuICBzaWduTWVzc2FnZSh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpO1xuICB9XG5cbiAgLy8gRm9yIHBlcnNvbmFsX3NpZ24sIHdlIG5lZWQgdG8gcHJlZml4IHRoZSBtZXNzYWdlOlxuICBzaWduUGVyc29uYWxNZXNzYWdlKHdpdGhBY2NvdW50LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oKHN0YXR1cykgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAoXykgPT4ge1xuICAgICAgICAgICAgICBUcmV6b3JDb25uZWN0LmV0aGVyZXVtU2lnbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyh3aXRoQWNjb3VudCksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXRoVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICBoZXg6IHRydWUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucGF5bG9hZC5hZGRyZXNzICE9PVxuICAgICAgICAgICAgICAgICAgICAgIGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcignc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpLFxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYDB4JHtyZXNwb25zZS5wYXlsb2FkLnNpZ25hdHVyZX1gO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlLnBheWxvYWQgJiYgcmVzcG9uc2UucGF5bG9hZC5lcnJvcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoKGUgJiYgZS50b1N0cmluZygpKSB8fCAnVW5rbm93biBlcnJvcicpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgdG8gYXZvaWQgcG9wdXAgY29sbGlzaW9uXG4gICAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlIHVubG9jayAmIHNpZ24gdHJlem9yIHBvcHVwc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0YXR1cyA9PT0gJ2p1c3QgdW5sb2NrZWQnID8gREVMQVlfQkVUV0VFTl9QT1BVUFMgOiAwLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoKGUgJiYgZS50b1N0cmluZygpKSB8fCAnVW5rbm93biBlcnJvcicpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRUlQLTcxMiBTaWduIFR5cGVkIERhdGFcbiAgICovXG4gIGFzeW5jIHNpZ25UeXBlZERhdGEoYWRkcmVzcywgZGF0YSwgeyB2ZXJzaW9uIH0pIHtcbiAgICBjb25zdCBkYXRhV2l0aEhhc2hlcyA9IHRyYW5zZm9ybVR5cGVkRGF0YShkYXRhLCB2ZXJzaW9uID09PSAnVjQnKTtcblxuICAgIC8vIHNldCBkZWZhdWx0IHZhbHVlcyBmb3Igc2lnblR5cGVkRGF0YVxuICAgIC8vIFRyZXpvciBpcyBzdHJpY3RlciB0aGFuIEBtZXRhbWFzay9ldGgtc2lnLXV0aWwgaW4gd2hhdCBpdCBhY2NlcHRzXG4gICAgY29uc3Qge1xuICAgICAgdHlwZXM6IHsgRUlQNzEyRG9tYWluID0gW10sIC4uLm90aGVyVHlwZXMgfSA9IHt9LFxuICAgICAgbWVzc2FnZSA9IHt9LFxuICAgICAgZG9tYWluID0ge30sXG4gICAgICBwcmltYXJ5VHlwZSxcbiAgICAgIC8vIHNuYWtlX2Nhc2Ugc2luY2UgVHJlem9yIHVzZXMgUHJvdG9idWYgbmFtaW5nIGNvbnZlbnRpb25zIGhlcmVcbiAgICAgIGRvbWFpbl9zZXBhcmF0b3JfaGFzaCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIG1lc3NhZ2VfaGFzaCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICB9ID0gZGF0YVdpdGhIYXNoZXM7XG5cbiAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCBwb3B1cCBjb2xsaXNpb25cbiAgICAvLyBiZXR3ZWVuIHRoZSB1bmxvY2sgJiBzaWduIHRyZXpvciBwb3B1cHNcbiAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCB0aGlzLnVubG9jaygpO1xuICAgIGF3YWl0IHdhaXQoc3RhdHVzID09PSAnanVzdCB1bmxvY2tlZCcgPyBERUxBWV9CRVRXRUVOX1BPUFVQUyA6IDApO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBUcmV6b3JDb25uZWN0LmV0aGVyZXVtU2lnblR5cGVkRGF0YSh7XG4gICAgICBwYXRoOiB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoYWRkcmVzcyksXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGVzOiB7IEVJUDcxMkRvbWFpbiwgLi4ub3RoZXJUeXBlcyB9LFxuICAgICAgICBtZXNzYWdlLFxuICAgICAgICBkb21haW4sXG4gICAgICAgIHByaW1hcnlUeXBlLFxuICAgICAgfSxcbiAgICAgIG1ldGFtYXNrX3Y0X2NvbXBhdDogdHJ1ZSxcbiAgICAgIC8vIFRyZXpvciAxIG9ubHkgc3VwcG9ydHMgYmxpbmRseSBzaWduaW5nIGhhc2hlc1xuICAgICAgZG9tYWluX3NlcGFyYXRvcl9oYXNoLFxuICAgICAgbWVzc2FnZV9oYXNoLFxuICAgIH0pO1xuXG4gICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgIGlmIChldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpICE9PSByZXNwb25zZS5wYXlsb2FkLmFkZHJlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduYXR1cmUgZG9lc250IG1hdGNoIHRoZSByaWdodCBhZGRyZXNzJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzcG9uc2UucGF5bG9hZC5zaWduYXR1cmU7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgKHJlc3BvbnNlLnBheWxvYWQgJiYgcmVzcG9uc2UucGF5bG9hZC5lcnJvcikgfHwgJ1Vua25vd24gZXJyb3InLFxuICAgICk7XG4gIH1cblxuICBleHBvcnRBY2NvdW50KCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ05vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKSk7XG4gIH1cblxuICBmb3JnZXREZXZpY2UoKSB7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuaGRrID0gbmV3IEhES2V5KCk7XG4gICAgdGhpcy5wYWdlID0gMDtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IDA7XG4gICAgdGhpcy5wYXRocyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgSEQgcGF0aCB0byBiZSB1c2VkIGJ5IHRoZSBrZXlyaW5nLiBPbmx5IGtub3duIHN1cHBvcnRlZCBIRCBwYXRocyBhcmUgYWxsb3dlZC5cbiAgICpcbiAgICogSWYgdGhlIGdpdmVuIEhEIHBhdGggaXMgYWxyZWFkeSB0aGUgY3VycmVudCBIRCBwYXRoLCBub3RoaW5nIGhhcHBlbnMuIE90aGVyd2lzZSB0aGUgbmV3IEhEXG4gICAqIHBhdGggaXMgc2V0LCBhbmQgdGhlIHdhbGxldCBzdGF0ZSBpcyBjb21wbGV0ZWx5IHJlc2V0LlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcl0gVGhyb3dzIGlmIHRoZSBIRCBwYXRoIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBoZFBhdGggLSBUaGUgSEQgcGF0aCB0byBzZXQuXG4gICAqL1xuICBzZXRIZFBhdGgoaGRQYXRoKSB7XG4gICAgaWYgKCFBTExPV0VEX0hEX1BBVEhTW2hkUGF0aF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZSBzZXRIZFBhdGggbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgc2V0dGluZyBIRCBQYXRoIHRvICR7aGRQYXRofWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IEhES2V5IGlmIHRoZSBwYXRoIGNoYW5nZXNcbiAgICBpZiAodGhpcy5oZFBhdGggIT09IGhkUGF0aCkge1xuICAgICAgdGhpcy5oZGsgPSBuZXcgSERLZXkoKTtcbiAgICAgIHRoaXMuYWNjb3VudHMgPSBbXTtcbiAgICAgIHRoaXMucGFnZSA9IDA7XG4gICAgICB0aGlzLnBlclBhZ2UgPSA1O1xuICAgICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSAwO1xuICAgICAgdGhpcy5wYXRocyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmhkUGF0aCA9IGhkUGF0aDtcbiAgfVxuXG4gIC8qIFBSSVZBVEUgTUVUSE9EUyAqL1xuXG4gIF9ub3JtYWxpemUoYnVmKSB7XG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoYnVmKS50b1N0cmluZygpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBfYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkge1xuICAgIGNvbnN0IGRrZXkgPSB0aGlzLmhkay5kZXJpdmUoYCR7cGF0aEJhc2V9LyR7aX1gKTtcbiAgICBjb25zdCBhZGRyZXNzID0gZXRoVXRpbFxuICAgICAgLnB1YmxpY1RvQWRkcmVzcyhka2V5LnB1YmxpY0tleSwgdHJ1ZSlcbiAgICAgIC50b1N0cmluZygnaGV4Jyk7XG4gICAgcmV0dXJuIGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYDB4JHthZGRyZXNzfWApO1xuICB9XG5cbiAgX3BhdGhGcm9tQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgY2hlY2tzdW1tZWRBZGRyZXNzID0gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBsZXQgaW5kZXggPSB0aGlzLnBhdGhzW2NoZWNrc3VtbWVkQWRkcmVzc107XG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lOREVYOyBpKyspIHtcbiAgICAgICAgaWYgKGNoZWNrc3VtbWVkQWRkcmVzcyA9PT0gdGhpcy5fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkpIHtcbiAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIGAke3RoaXMuaGRQYXRofS8ke2luZGV4fWA7XG4gIH1cbn1cblxuVHJlem9yS2V5cmluZy50eXBlID0ga2V5cmluZ1R5cGU7XG5tb2R1bGUuZXhwb3J0cyA9IFRyZXpvcktleXJpbmc7XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG52YXIgY3MgPSByZXF1aXJlKCdjb2luc3RyaW5nJylcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdzZWNwMjU2azEnKVxuXG52YXIgTUFTVEVSX1NFQ1JFVCA9IEJ1ZmZlci5mcm9tKCdCaXRjb2luIHNlZWQnLCAndXRmOCcpXG52YXIgSEFSREVORURfT0ZGU0VUID0gMHg4MDAwMDAwMFxudmFyIExFTiA9IDc4XG5cbi8vIEJpdGNvaW4gaGFyZGNvZGVkIGJ5IGRlZmF1bHQsIGNhbiB1c2UgcGFja2FnZSBgY29pbmluZm9gIGZvciBvdGhlcnNcbnZhciBCSVRDT0lOX1ZFUlNJT05TID0ge3ByaXZhdGU6IDB4MDQ4OEFERTQsIHB1YmxpYzogMHgwNDg4QjIxRX1cblxuZnVuY3Rpb24gSERLZXkgKHZlcnNpb25zKSB7XG4gIHRoaXMudmVyc2lvbnMgPSB2ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TXG4gIHRoaXMuZGVwdGggPSAwXG4gIHRoaXMuaW5kZXggPSAwXG4gIHRoaXMuX3ByaXZhdGVLZXkgPSBudWxsXG4gIHRoaXMuX3B1YmxpY0tleSA9IG51bGxcbiAgdGhpcy5jaGFpbkNvZGUgPSBudWxsXG4gIHRoaXMuX2ZpbmdlcnByaW50ID0gMFxuICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMFxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAnZmluZ2VycHJpbnQnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZmluZ2VycHJpbnQgfSB9KVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ2lkZW50aWZpZXInLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWRlbnRpZmllciB9IH0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHViS2V5SGFzaCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmlkZW50aWZpZXIgfSB9KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHJpdmF0ZUtleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVLZXlcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc3NlcnQuZXF1YWwodmFsdWUubGVuZ3RoLCAzMiwgJ1ByaXZhdGUga2V5IG11c3QgYmUgMzIgYnl0ZXMuJylcbiAgICBhc3NlcnQoc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkodmFsdWUpID09PSB0cnVlLCAnSW52YWxpZCBwcml2YXRlIGtleScpXG5cbiAgICB0aGlzLl9wcml2YXRlS2V5ID0gdmFsdWVcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHZhbHVlLCB0cnVlKVxuICAgIHRoaXMuX2lkZW50aWZpZXIgPSBoYXNoMTYwKHRoaXMucHVibGljS2V5KVxuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gdGhpcy5faWRlbnRpZmllci5zbGljZSgwLCA0KS5yZWFkVUludDMyQkUoMClcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3B1YmxpY0tleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggPT09IDMzIHx8IHZhbHVlLmxlbmd0aCA9PT0gNjUsICdQdWJsaWMga2V5IG11c3QgYmUgMzMgb3IgNjUgYnl0ZXMuJylcbiAgICBhc3NlcnQoc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeSh2YWx1ZSkgPT09IHRydWUsICdJbnZhbGlkIHB1YmxpYyBrZXknKVxuXG4gICAgdGhpcy5fcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQodmFsdWUsIHRydWUpIC8vIGZvcmNlIGNvbXByZXNzZWQgcG9pbnRcbiAgICB0aGlzLl9pZGVudGlmaWVyID0gaGFzaDE2MCh0aGlzLnB1YmxpY0tleSlcbiAgICB0aGlzLl9maW5nZXJwcmludCA9IHRoaXMuX2lkZW50aWZpZXIuc2xpY2UoMCwgNCkucmVhZFVJbnQzMkJFKDApXG4gICAgdGhpcy5fcHJpdmF0ZUtleSA9IG51bGxcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3ByaXZhdGVFeHRlbmRlZEtleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGVLZXkpIHJldHVybiBjcy5lbmNvZGUoc2VyaWFsaXplKHRoaXMsIHRoaXMudmVyc2lvbnMucHJpdmF0ZSwgQnVmZmVyLmNvbmNhdChbQnVmZmVyLmFsbG9jKDEsIDApLCB0aGlzLnByaXZhdGVLZXldKSkpXG4gICAgZWxzZSByZXR1cm4gbnVsbFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHVibGljRXh0ZW5kZWRLZXknLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcy5lbmNvZGUoc2VyaWFsaXplKHRoaXMsIHRoaXMudmVyc2lvbnMucHVibGljLCB0aGlzLnB1YmxpY0tleSkpXG4gIH1cbn0pXG5cbkhES2V5LnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAocGF0aCA9PT0gJ20nIHx8IHBhdGggPT09ICdNJyB8fCBwYXRoID09PSBcIm0nXCIgfHwgcGF0aCA9PT0gXCJNJ1wiKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBlbnRyaWVzID0gcGF0aC5zcGxpdCgnLycpXG4gIHZhciBoZGtleSA9IHRoaXNcbiAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGFzc2VydChjLCAnbScsICdJbnZhbGlkIHBhdGgnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGhhcmRlbmVkID0gKGMubGVuZ3RoID4gMSkgJiYgKGNbYy5sZW5ndGggLSAxXSA9PT0gXCInXCIpXG4gICAgdmFyIGNoaWxkSW5kZXggPSBwYXJzZUludChjLCAxMCkgLy8gJiAoSEFSREVORURfT0ZGU0VUIC0gMSlcbiAgICBhc3NlcnQoY2hpbGRJbmRleCA8IEhBUkRFTkVEX09GRlNFVCwgJ0ludmFsaWQgaW5kZXgnKVxuICAgIGlmIChoYXJkZW5lZCkgY2hpbGRJbmRleCArPSBIQVJERU5FRF9PRkZTRVRcblxuICAgIGhka2V5ID0gaGRrZXkuZGVyaXZlQ2hpbGQoY2hpbGRJbmRleClcbiAgfSlcblxuICByZXR1cm4gaGRrZXlcbn1cblxuSERLZXkucHJvdG90eXBlLmRlcml2ZUNoaWxkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHZhciBpc0hhcmRlbmVkID0gaW5kZXggPj0gSEFSREVORURfT0ZGU0VUXG4gIHZhciBpbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICBpbmRleEJ1ZmZlci53cml0ZVVJbnQzMkJFKGluZGV4LCAwKVxuXG4gIHZhciBkYXRhXG5cbiAgaWYgKGlzSGFyZGVuZWQpIHsgLy8gSGFyZGVuZWQgY2hpbGRcbiAgICBhc3NlcnQodGhpcy5wcml2YXRlS2V5LCAnQ291bGQgbm90IGRlcml2ZSBoYXJkZW5lZCBjaGlsZCBrZXknKVxuXG4gICAgdmFyIHBrID0gdGhpcy5wcml2YXRlS2V5XG4gICAgdmFyIHpiID0gQnVmZmVyLmFsbG9jKDEsIDApXG4gICAgcGsgPSBCdWZmZXIuY29uY2F0KFt6YiwgcGtdKVxuXG4gICAgLy8gZGF0YSA9IDB4MDAgfHwgc2VyMjU2KGtwYXIpIHx8IHNlcjMyKGluZGV4KVxuICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtwaywgaW5kZXhCdWZmZXJdKVxuICB9IGVsc2UgeyAvLyBOb3JtYWwgY2hpbGRcbiAgICAvLyBkYXRhID0gc2VyUChwb2ludChrcGFyKSkgfHwgc2VyMzIoaW5kZXgpXG4gICAgLy8gICAgICA9IHNlclAoS3BhcikgfHwgc2VyMzIoaW5kZXgpXG4gICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMucHVibGljS2V5LCBpbmRleEJ1ZmZlcl0pXG4gIH1cblxuICB2YXIgSSA9IGNyeXB0by5jcmVhdGVIbWFjKCdzaGE1MTInLCB0aGlzLmNoYWluQ29kZSkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gIHZhciBJTCA9IEkuc2xpY2UoMCwgMzIpXG4gIHZhciBJUiA9IEkuc2xpY2UoMzIpXG5cbiAgdmFyIGhkID0gbmV3IEhES2V5KHRoaXMudmVyc2lvbnMpXG5cbiAgLy8gUHJpdmF0ZSBwYXJlbnQga2V5IC0+IHByaXZhdGUgY2hpbGQga2V5XG4gIGlmICh0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAvLyBraSA9IHBhcnNlMjU2KElMKSArIGtwYXIgKG1vZCBuKVxuICAgIHRyeSB7XG4gICAgICBoZC5wcml2YXRlS2V5ID0gc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha0FkZCh0aGlzLnByaXZhdGVLZXksIElMKVxuICAgICAgLy8gdGhyb3cgaWYgSUwgPj0gbiB8fCAocHJpdmF0ZUtleSArIElMKSA9PT0gMFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSW4gY2FzZSBwYXJzZTI1NihJTCkgPj0gbiBvciBraSA9PSAwLCBvbmUgc2hvdWxkIHByb2NlZWQgd2l0aCB0aGUgbmV4dCB2YWx1ZSBmb3IgaVxuICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgMSlcbiAgICB9XG4gIC8vIFB1YmxpYyBwYXJlbnQga2V5IC0+IHB1YmxpYyBjaGlsZCBrZXlcbiAgfSBlbHNlIHtcbiAgICAvLyBLaSA9IHBvaW50KHBhcnNlMjU2KElMKSkgKyBLcGFyXG4gICAgLy8gICAgPSBHKklMICsgS3BhclxuICAgIHRyeSB7XG4gICAgICBoZC5wdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQodGhpcy5wdWJsaWNLZXksIElMLCB0cnVlKVxuICAgICAgLy8gdGhyb3cgaWYgSUwgPj0gbiB8fCAoZyoqSUwgKyBwdWJsaWNLZXkpIGlzIGluZmluaXR5XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJbiBjYXNlIHBhcnNlMjU2KElMKSA+PSBuIG9yIEtpIGlzIHRoZSBwb2ludCBhdCBpbmZpbml0eSwgb25lIHNob3VsZCBwcm9jZWVkIHdpdGggdGhlIG5leHQgdmFsdWUgZm9yIGlcbiAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIDEsIGlzSGFyZGVuZWQpXG4gICAgfVxuICB9XG5cbiAgaGQuY2hhaW5Db2RlID0gSVJcbiAgaGQuZGVwdGggPSB0aGlzLmRlcHRoICsgMVxuICBoZC5wYXJlbnRGaW5nZXJwcmludCA9IHRoaXMuZmluZ2VycHJpbnQvLyAucmVhZFVJbnQzMkJFKDApXG4gIGhkLmluZGV4ID0gaW5kZXhcblxuICByZXR1cm4gaGRcbn1cblxuSERLZXkucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoaGFzaCkge1xuICByZXR1cm4gc2VjcDI1NmsxLnNpZ24oaGFzaCwgdGhpcy5wcml2YXRlS2V5KS5zaWduYXR1cmVcbn1cblxuSERLZXkucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIChoYXNoLCBzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkoaGFzaCwgc2lnbmF0dXJlLCB0aGlzLnB1YmxpY0tleSlcbn1cblxuSERLZXkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB4cHJpdjogdGhpcy5wcml2YXRlRXh0ZW5kZWRLZXksXG4gICAgeHB1YjogdGhpcy5wdWJsaWNFeHRlbmRlZEtleVxuICB9XG59XG5cbkhES2V5LmZyb21NYXN0ZXJTZWVkID0gZnVuY3Rpb24gKHNlZWRCdWZmZXIsIHZlcnNpb25zKSB7XG4gIHZhciBJID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTUxMicsIE1BU1RFUl9TRUNSRVQpLnVwZGF0ZShzZWVkQnVmZmVyKS5kaWdlc3QoKVxuICB2YXIgSUwgPSBJLnNsaWNlKDAsIDMyKVxuICB2YXIgSVIgPSBJLnNsaWNlKDMyKVxuXG4gIHZhciBoZGtleSA9IG5ldyBIREtleSh2ZXJzaW9ucylcbiAgaGRrZXkuY2hhaW5Db2RlID0gSVJcbiAgaGRrZXkucHJpdmF0ZUtleSA9IElMXG5cbiAgcmV0dXJuIGhka2V5XG59XG5cbkhES2V5LmZyb21FeHRlbmRlZEtleSA9IGZ1bmN0aW9uIChiYXNlNThrZXksIHZlcnNpb25zKSB7XG4gIC8vID0+IHZlcnNpb24oNCkgfHwgZGVwdGgoMSkgfHwgZmluZ2VycHJpbnQoNCkgfHwgaW5kZXgoNCkgfHwgY2hhaW4oMzIpIHx8IGtleSgzMylcbiAgdmVyc2lvbnMgPSB2ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TXG4gIHZhciBoZGtleSA9IG5ldyBIREtleSh2ZXJzaW9ucylcblxuICB2YXIga2V5QnVmZmVyID0gY3MuZGVjb2RlKGJhc2U1OGtleSlcblxuICB2YXIgdmVyc2lvbiA9IGtleUJ1ZmZlci5yZWFkVUludDMyQkUoMClcbiAgYXNzZXJ0KHZlcnNpb24gPT09IHZlcnNpb25zLnByaXZhdGUgfHwgdmVyc2lvbiA9PT0gdmVyc2lvbnMucHVibGljLCAnVmVyc2lvbiBtaXNtYXRjaDogZG9lcyBub3QgbWF0Y2ggcHJpdmF0ZSBvciBwdWJsaWMnKVxuXG4gIGhka2V5LmRlcHRoID0ga2V5QnVmZmVyLnJlYWRVSW50OCg0KVxuICBoZGtleS5wYXJlbnRGaW5nZXJwcmludCA9IGtleUJ1ZmZlci5yZWFkVUludDMyQkUoNSlcbiAgaGRrZXkuaW5kZXggPSBrZXlCdWZmZXIucmVhZFVJbnQzMkJFKDkpXG4gIGhka2V5LmNoYWluQ29kZSA9IGtleUJ1ZmZlci5zbGljZSgxMywgNDUpXG5cbiAgdmFyIGtleSA9IGtleUJ1ZmZlci5zbGljZSg0NSlcbiAgaWYgKGtleS5yZWFkVUludDgoMCkgPT09IDApIHsgLy8gcHJpdmF0ZVxuICAgIGFzc2VydCh2ZXJzaW9uID09PSB2ZXJzaW9ucy5wcml2YXRlLCAnVmVyc2lvbiBtaXNtYXRjaDogdmVyc2lvbiBkb2VzIG5vdCBtYXRjaCBwcml2YXRlJylcbiAgICBoZGtleS5wcml2YXRlS2V5ID0ga2V5LnNsaWNlKDEpIC8vIGN1dCBvZmYgZmlyc3QgMHgwIGJ5dGVcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQodmVyc2lvbiA9PT0gdmVyc2lvbnMucHVibGljLCAnVmVyc2lvbiBtaXNtYXRjaDogdmVyc2lvbiBkb2VzIG5vdCBtYXRjaCBwdWJsaWMnKVxuICAgIGhka2V5LnB1YmxpY0tleSA9IGtleVxuICB9XG5cbiAgcmV0dXJuIGhka2V5XG59XG5cbkhES2V5LmZyb21KU09OID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gSERLZXkuZnJvbUV4dGVuZGVkS2V5KG9iai54cHJpdilcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplIChoZGtleSwgdmVyc2lvbiwga2V5KSB7XG4gIC8vID0+IHZlcnNpb24oNCkgfHwgZGVwdGgoMSkgfHwgZmluZ2VycHJpbnQoNCkgfHwgaW5kZXgoNCkgfHwgY2hhaW4oMzIpIHx8IGtleSgzMylcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShMRU4pXG5cbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmVyc2lvbiwgMClcbiAgYnVmZmVyLndyaXRlVUludDgoaGRrZXkuZGVwdGgsIDQpXG5cbiAgdmFyIGZpbmdlcnByaW50ID0gaGRrZXkuZGVwdGggPyBoZGtleS5wYXJlbnRGaW5nZXJwcmludCA6IDB4MDAwMDAwMDBcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoZmluZ2VycHJpbnQsIDUpXG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGhka2V5LmluZGV4LCA5KVxuXG4gIGhka2V5LmNoYWluQ29kZS5jb3B5KGJ1ZmZlciwgMTMpXG4gIGtleS5jb3B5KGJ1ZmZlciwgNDUpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBoYXNoMTYwIChidWYpIHtcbiAgdmFyIHNoYSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYnVmKS5kaWdlc3QoKVxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShzaGEpLmRpZ2VzdCgpXG59XG5cbkhES2V5LkhBUkRFTkVEX09GRlNFVCA9IEhBUkRFTkVEX09GRlNFVFxubW9kdWxlLmV4cG9ydHMgPSBIREtleVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJykocmVxdWlyZSgnLi9saWIvZWxsaXB0aWMnKSlcbiIsIid1c2Ugc3RyaWN0J1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4vLyBUeXBlRXJyb3JcbmV4cG9ydHMuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB0aHJvdyBUeXBlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBCb29sZWFuXScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG4vLyBSYW5nZUVycm9yXG5leHBvcnRzLmlzQnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gKGJ1ZmZlciwgbGVuZ3RoLCBtZXNzYWdlKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoICE9PSBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0J1ZmZlckxlbmd0aDIgPSBmdW5jdGlvbiAoYnVmZmVyLCBsZW5ndGgxLCBsZW5ndGgyLCBtZXNzYWdlKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoICE9PSBsZW5ndGgxICYmIGJ1ZmZlci5sZW5ndGggIT09IGxlbmd0aDIpIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0xlbmd0aEdUWmVybyA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB0aHJvdyBSYW5nZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNOdW1iZXJJbkludGVydmFsID0gZnVuY3Rpb24gKG51bWJlciwgeCwgeSwgbWVzc2FnZSkge1xuICBpZiAobnVtYmVyIDw9IHggfHwgbnVtYmVyID49IHkpIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgYmlwNjYgPSByZXF1aXJlKCdiaXA2NicpXG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbiAgLy8gYmVnaW5cbiAgMHgzMCwgMHg4MSwgMHhkMywgMHgwMiwgMHgwMSwgMHgwMSwgMHgwNCwgMHgyMCxcbiAgLy8gcHJpdmF0ZSBrZXlcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgLy8gbWlkZGxlXG4gIDB4YTAsIDB4ODEsIDB4ODUsIDB4MzAsIDB4ODEsIDB4ODIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsXG4gIDB4Y0UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZkUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsXG4gIDB4MjEsIDB4MDIsIDB4NzksIDB4YkUsIDB4NjYsIDB4N0UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y0UsIDB4ODcsXG4gIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y0UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsXG4gIDB4MTcsIDB4OTgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZkUsIDB4YmEsIDB4YUUsIDB4ZGMsIDB4RTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NUUsXG4gIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4MjQsIDB4MDMsIDB4MjIsIDB4MDAsXG4gIC8vIHB1YmxpYyBrZXlcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMFxuXSlcblxudmFyIEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQgPSBCdWZmZXIuZnJvbShbXG4gIC8vIGJlZ2luXG4gIDB4MzAsIDB4ODIsIDB4MDEsIDB4MTMsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDQsIDB4MjAsXG4gIC8vIHByaXZhdGUga2V5XG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIC8vIG1pZGRsZVxuICAweGEwLCAweDgxLCAweGE1LCAweDMwLCAweDgxLCAweGEyLCAweDAyLCAweDAxLCAweDAxLCAweDMwLCAweDJjLCAweDA2LCAweDA3LCAweDJhLCAweDg2LCAweDQ4LFxuICAweGNFLCAweDNkLCAweDAxLCAweDAxLCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAweGZmLCAweGZmLCAweGZFLCAweGZmLCAweGZmLCAweGZjLCAweDJmLCAweDMwLCAweDA2LCAweDA0LCAweDAxLCAweDAwLCAweDA0LCAweDAxLCAweDA3LCAweDA0LFxuICAweDQxLCAweDA0LCAweDc5LCAweGJFLCAweDY2LCAweDdFLCAweGY5LCAweGRjLCAweGJiLCAweGFjLCAweDU1LCAweGEwLCAweDYyLCAweDk1LCAweGNFLCAweDg3LFxuICAweDBiLCAweDA3LCAweDAyLCAweDliLCAweGZjLCAweGRiLCAweDJkLCAweGNFLCAweDI4LCAweGQ5LCAweDU5LCAweGYyLCAweDgxLCAweDViLCAweDE2LCAweGY4LFxuICAweDE3LCAweDk4LCAweDQ4LCAweDNhLCAweGRhLCAweDc3LCAweDI2LCAweGEzLCAweGM0LCAweDY1LCAweDVkLCAweGE0LCAweGZiLCAweGZjLCAweDBFLCAweDExLFxuICAweDA4LCAweGE4LCAweGZkLCAweDE3LCAweGI0LCAweDQ4LCAweGE2LCAweDg1LCAweDU0LCAweDE5LCAweDljLCAweDQ3LCAweGQwLCAweDhmLCAweGZiLCAweDEwLFxuICAweGQ0LCAweGI4LCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZFLCAweGJhLCAweGFFLCAweGRjLCAweEU2LCAweGFmLCAweDQ4LCAweGEwLCAweDNiLCAweGJmLCAweGQyLCAweDVFLFxuICAweDhjLCAweGQwLCAweDM2LCAweDQxLCAweDQxLCAweDAyLCAweDAxLCAweDAxLCAweGExLCAweDQ0LCAweDAzLCAweDQyLCAweDAwLFxuICAvLyBwdWJsaWMga2V5XG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDBcbl0pXG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKGNvbXByZXNzZWQgPyBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA6IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQpXG4gIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSlcbiAgcHVibGljS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gMTgxIDogMjE0KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBsZW5ndGggPSBwcml2YXRlS2V5Lmxlbmd0aFxuXG4gIC8vIHNlcXVlbmNlIGhlYWRlclxuICB2YXIgaW5kZXggPSAwXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MzApIHJldHVyblxuICBpbmRleCArPSAxXG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGNvbnN0cnVjdG9yXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgIShwcml2YXRlS2V5W2luZGV4XSAmIDB4ODApKSByZXR1cm5cblxuICB2YXIgbGVuYiA9IHByaXZhdGVLZXlbaW5kZXhdICYgMHg3ZlxuICBpbmRleCArPSAxXG4gIGlmIChsZW5iIDwgMSB8fCBsZW5iID4gMikgcmV0dXJuXG4gIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpIHJldHVyblxuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aFxuICB2YXIgbGVuID0gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAxXSB8IChsZW5iID4gMSA/IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMl0gPDwgOCA6IDApXG4gIGluZGV4ICs9IGxlbmJcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuKSByZXR1cm5cblxuICAvLyBzZXF1ZW5jZSBlbGVtZW50IDA6IHZlcnNpb24gbnVtYmVyICg9MSlcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMyB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MDIgfHxcbiAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAxXSAhPT0gMHgwMSB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDJdICE9PSAweDAxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaW5kZXggKz0gM1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMTogb2N0ZXQgc3RyaW5nLCB1cCB0byAzMiBieXRlc1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8XG4gICAgICBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwNCB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDFdID4gMHgyMCB8fFxuICAgICAgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSlcbn1cblxuZXhwb3J0cy5zaWduYXR1cmVFeHBvcnQgPSBmdW5jdGlvbiAoc2lnT2JqKSB7XG4gIHZhciByID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzBdKSwgc2lnT2JqLnJdKVxuICBmb3IgKHZhciBsZW5SID0gMzMsIHBvc1IgPSAwOyBsZW5SID4gMSAmJiByW3Bvc1JdID09PSAweDAwICYmICEocltwb3NSICsgMV0gJiAweDgwKTsgLS1sZW5SLCArK3Bvc1IpO1xuXG4gIHZhciBzID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzBdKSwgc2lnT2JqLnNdKVxuICBmb3IgKHZhciBsZW5TID0gMzMsIHBvc1MgPSAwOyBsZW5TID4gMSAmJiBzW3Bvc1NdID09PSAweDAwICYmICEoc1twb3NTICsgMV0gJiAweDgwKTsgLS1sZW5TLCArK3Bvc1MpO1xuXG4gIHJldHVybiBiaXA2Ni5lbmNvZGUoci5zbGljZShwb3NSKSwgcy5zbGljZShwb3NTKSlcbn1cblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHZhciByID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMClcblxuICB0cnkge1xuICAgIHZhciBzaWdPYmogPSBiaXA2Ni5kZWNvZGUoc2lnKVxuICAgIGlmIChzaWdPYmouci5sZW5ndGggPT09IDMzICYmIHNpZ09iai5yWzBdID09PSAweDAwKSBzaWdPYmouciA9IHNpZ09iai5yLnNsaWNlKDEpXG4gICAgaWYgKHNpZ09iai5yLmxlbmd0aCA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoJ1IgbGVuZ3RoIGlzIHRvbyBsb25nJylcbiAgICBpZiAoc2lnT2JqLnMubGVuZ3RoID09PSAzMyAmJiBzaWdPYmouc1swXSA9PT0gMHgwMCkgc2lnT2JqLnMgPSBzaWdPYmoucy5zbGljZSgxKVxuICAgIGlmIChzaWdPYmoucy5sZW5ndGggPiAzMikgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB0b28gbG9uZycpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVyblxuICB9XG5cbiAgc2lnT2JqLnIuY29weShyLCAzMiAtIHNpZ09iai5yLmxlbmd0aClcbiAgc2lnT2JqLnMuY29weShzLCAzMiAtIHNpZ09iai5zLmxlbmd0aClcblxuICByZXR1cm4geyByOiByLCBzOiBzIH1cbn1cblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHZhciByID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMClcblxuICB2YXIgbGVuZ3RoID0gc2lnLmxlbmd0aFxuICB2YXIgaW5kZXggPSAwXG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGVcbiAgaWYgKHNpZ1tpbmRleCsrXSAhPT0gMHgzMCkgcmV0dXJuXG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgdmFyIGxlbmJ5dGUgPSBzaWdbaW5kZXgrK11cbiAgaWYgKGxlbmJ5dGUgJiAweDgwKSB7XG4gICAgaW5kZXggKz0gbGVuYnl0ZSAtIDB4ODBcbiAgICBpZiAoaW5kZXggPiBsZW5ndGgpIHJldHVyblxuICB9XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgaWYgKHNpZ1tpbmRleCsrXSAhPT0gMHgwMikgcmV0dXJuXG5cbiAgLy8gbGVuZ3RoIGZvciByXG4gIHZhciBybGVuID0gc2lnW2luZGV4KytdXG4gIGlmIChybGVuICYgMHg4MCkge1xuICAgIGxlbmJ5dGUgPSBybGVuIC0gMHg4MFxuICAgIGlmIChpbmRleCArIGxlbmJ5dGUgPiBsZW5ndGgpIHJldHVyblxuICAgIGZvciAoOyBsZW5ieXRlID4gMCAmJiBzaWdbaW5kZXhdID09PSAweDAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpO1xuICAgIGZvciAocmxlbiA9IDA7IGxlbmJ5dGUgPiAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHJsZW4gPSAocmxlbiA8PCA4KSArIHNpZ1tpbmRleF1cbiAgfVxuICBpZiAocmxlbiA+IGxlbmd0aCAtIGluZGV4KSByZXR1cm5cbiAgdmFyIHJpbmRleCA9IGluZGV4XG4gIGluZGV4ICs9IHJsZW5cblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3Igc1xuICBpZiAoc2lnW2luZGV4KytdICE9PSAweDAyKSByZXR1cm5cblxuICAvLyBsZW5ndGggZm9yIHNcbiAgdmFyIHNsZW4gPSBzaWdbaW5kZXgrK11cbiAgaWYgKHNsZW4gJiAweDgwKSB7XG4gICAgbGVuYnl0ZSA9IHNsZW4gLSAweDgwXG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkgcmV0dXJuXG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ1tpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSk7XG4gICAgZm9yIChzbGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkgc2xlbiA9IChzbGVuIDw8IDgpICsgc2lnW2luZGV4XVxuICB9XG4gIGlmIChzbGVuID4gbGVuZ3RoIC0gaW5kZXgpIHJldHVyblxuICB2YXIgc2luZGV4ID0gaW5kZXhcbiAgaW5kZXggKz0gc2xlblxuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHJcbiAgZm9yICg7IHJsZW4gPiAwICYmIHNpZ1tyaW5kZXhdID09PSAweDAwOyBybGVuIC09IDEsIHJpbmRleCArPSAxKTtcbiAgLy8gY29weSByIHZhbHVlXG4gIGlmIChybGVuID4gMzIpIHJldHVyblxuICB2YXIgcnZhbHVlID0gc2lnLnNsaWNlKHJpbmRleCwgcmluZGV4ICsgcmxlbilcbiAgcnZhbHVlLmNvcHkociwgMzIgLSBydmFsdWUubGVuZ3RoKVxuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHNcbiAgZm9yICg7IHNsZW4gPiAwICYmIHNpZ1tzaW5kZXhdID09PSAweDAwOyBzbGVuIC09IDEsIHNpbmRleCArPSAxKTtcbiAgLy8gY29weSBzIHZhbHVlXG4gIGlmIChzbGVuID4gMzIpIHJldHVyblxuICB2YXIgc3ZhbHVlID0gc2lnLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbilcbiAgc3ZhbHVlLmNvcHkocywgMzIgLSBzdmFsdWUubGVuZ3RoKVxuXG4gIHJldHVybiB7IHI6IHIsIHM6IHMgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lY1xuXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKCcuLi9tZXNzYWdlcy5qc29uJylcblxudmFyIGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKVxudmFyIGVjcGFyYW1zID0gZWMuY3VydmVcblxuZnVuY3Rpb24gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkgKGZpcnN0LCB4QnVmZmVyKSB7XG4gIHZhciB4ID0gbmV3IEJOKHhCdWZmZXIpXG5cbiAgLy8gb3ZlcmZsb3dcbiAgaWYgKHguY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG4gIHggPSB4LnRvUmVkKGVjcGFyYW1zLnJlZClcblxuICAvLyBjb21wdXRlIGNvcnJlc3BvbmRpbmcgWVxuICB2YXIgeSA9IHgucmVkU3FyKCkucmVkSU11bCh4KS5yZWRJQWRkKGVjcGFyYW1zLmIpLnJlZFNxcnQoKVxuICBpZiAoKGZpcnN0ID09PSAweDAzKSAhPT0geS5pc09kZCgpKSB5ID0geS5yZWROZWcoKVxuXG4gIHJldHVybiBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHgsIHk6IHkgfSB9KVxufVxuXG5mdW5jdGlvbiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5IChmaXJzdCwgeEJ1ZmZlciwgeUJ1ZmZlcikge1xuICB2YXIgeCA9IG5ldyBCTih4QnVmZmVyKVxuICB2YXIgeSA9IG5ldyBCTih5QnVmZmVyKVxuXG4gIC8vIG92ZXJmbG93XG4gIGlmICh4LmNtcChlY3BhcmFtcy5wKSA+PSAwIHx8IHkuY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG5cbiAgeCA9IHgudG9SZWQoZWNwYXJhbXMucmVkKVxuICB5ID0geS50b1JlZChlY3BhcmFtcy5yZWQpXG5cbiAgLy8gaXMgb2RkIGZsYWdcbiAgaWYgKChmaXJzdCA9PT0gMHgwNiB8fCBmaXJzdCA9PT0gMHgwNykgJiYgeS5pc09kZCgpICE9PSAoZmlyc3QgPT09IDB4MDcpKSByZXR1cm4gbnVsbFxuXG4gIC8vIHgqeCp4ICsgYiA9IHkqeVxuICB2YXIgeDMgPSB4LnJlZFNxcigpLnJlZElNdWwoeClcbiAgaWYgKCF5LnJlZFNxcigpLnJlZElTdWIoeDMucmVkSUFkZChlY3BhcmFtcy5iKSkuaXNaZXJvKCkpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGVjLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pXG59XG5cbmZ1bmN0aW9uIGxvYWRQdWJsaWNLZXkgKHB1YmxpY0tleSkge1xuICB2YXIgZmlyc3QgPSBwdWJsaWNLZXlbMF1cbiAgc3dpdGNoIChmaXJzdCkge1xuICAgIGNhc2UgMHgwMjpcbiAgICBjYXNlIDB4MDM6XG4gICAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkoZmlyc3QsIHB1YmxpY0tleS5zbGljZSgxLCAzMykpXG4gICAgY2FzZSAweDA0OlxuICAgIGNhc2UgMHgwNjpcbiAgICBjYXNlIDB4MDc6XG4gICAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVibGljS2V5LnNsaWNlKDEsIDMzKSwgcHVibGljS2V5LnNsaWNlKDMzLCA2NSkpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIHJldHVybiBibi5jbXAoZWNwYXJhbXMubikgPCAwICYmICFibi5pc1plcm8oKVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgZCA9IG5ldyBCTihwcml2YXRlS2V5KVxuICBpZiAoZC5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBkLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfRVhQT1JUX0RFUl9GQUlMKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KS5nZXRQdWJsaWMoY29tcHJlc3NlZCwgdHJ1ZSkpXG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleU5lZ2F0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KVxuICByZXR1cm4gYm4uaXNaZXJvKCkgPyBCdWZmZXIuYWxsb2MoMzIpIDogZWNwYXJhbXMubi5zdWIoYm4pLnVtb2QoZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KVxuICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9SQU5HRV9JTlZBTElEKVxuXG4gIHJldHVybiBibi5pbnZtKGVjcGFyYW1zLm4pLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHZhciBibiA9IG5ldyBCTih0d2VhaylcbiAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFdFQUtfQUREX0ZBSUwpXG5cbiAgYm4uaWFkZChuZXcgQk4ocHJpdmF0ZUtleSkpXG4gIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgYm4uaXN1YihlY3BhcmFtcy5uKVxuICBpZiAoYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UV0VBS19BRERfRkFJTClcblxuICByZXR1cm4gYm4udG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgdmFyIGJuID0gbmV3IEJOKHR3ZWFrKVxuICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UV0VBS19NVUxfRkFJTClcblxuICBibi5pbXVsKG5ldyBCTihwcml2YXRlS2V5KSlcbiAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSkgYm4gPSBibi51bW9kKGVjcGFyYW1zLm4pXG5cbiAgcmV0dXJuIGJuLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXG59XG5cbmV4cG9ydHMucHVibGljS2V5Q3JlYXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIGQgPSBuZXcgQk4ocHJpdmF0ZUtleSlcbiAgaWYgKGQuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgZC5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfQ1JFQVRFX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXkpLmdldFB1YmxpYyhjb21wcmVzc2VkLCB0cnVlKSlcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVibGljS2V5KVxuICBpZiAocGFpciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocGFpci5nZXRQdWJsaWMoY29tcHJlc3NlZCwgdHJ1ZSkpXG59XG5cbmV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICByZXR1cm4gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpICE9PSBudWxsXG59XG5cbmV4cG9ydHMucHVibGljS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVibGljS2V5KVxuICBpZiAocGFpciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICB0d2VhayA9IG5ldyBCTih0d2VhaylcbiAgaWYgKHR3ZWFrLmNtcChlY3BhcmFtcy5uKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UV0VBS19BRERfRkFJTClcblxuICB2YXIgcG9pbnQgPSBlY3BhcmFtcy5nLm11bCh0d2VhaykuYWRkKHBhaXIucHViKVxuICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UV0VBS19BRERfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuXG5leHBvcnRzLnB1YmxpY0tleVR3ZWFrTXVsID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmxpY0tleSlcbiAgaWYgKHBhaXIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1BBUlNFX0ZBSUwpXG5cbiAgdHdlYWsgPSBuZXcgQk4odHdlYWspXG4gIGlmICh0d2Vhay5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCB0d2Vhay5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFdFQUtfTVVMX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhaXIucHViLm11bCh0d2VhaykuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuXG5leHBvcnRzLnB1YmxpY0tleUNvbWJpbmUgPSBmdW5jdGlvbiAocHVibGljS2V5cywgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpcnMgPSBuZXcgQXJyYXkocHVibGljS2V5cy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHVibGljS2V5cy5sZW5ndGg7ICsraSkge1xuICAgIHBhaXJzW2ldID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXlzW2ldKVxuICAgIGlmIChwYWlyc1tpXSA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcbiAgfVxuXG4gIHZhciBwb2ludCA9IHBhaXJzWzBdLnB1YlxuICBmb3IgKHZhciBqID0gMTsgaiA8IHBhaXJzLmxlbmd0aDsgKytqKSBwb2ludCA9IHBvaW50LmFkZChwYWlyc1tqXS5wdWIpXG4gIGlmIChwb2ludC5pc0luZmluaXR5KCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0NPTUJJTkVfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZU5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBuZXcgQk4oc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSlcbiAgdmFyIHMgPSBuZXcgQk4oc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpXG4gIGlmIChyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHMuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTClcblxuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKVxuICBpZiAocy5jbXAoZWMubmgpID09PSAxKSBlY3BhcmFtcy5uLnN1YihzKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHJlc3VsdCwgMzIpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBzaWduYXR1cmUuc2xpY2UoMCwgMzIpXG4gIHZhciBzID0gc2lnbmF0dXJlLnNsaWNlKDMyLCA2NClcbiAgaWYgKG5ldyBCTihyKS5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBuZXcgQk4ocykuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTClcblxuICByZXR1cm4geyByOiByLCBzOiBzIH1cbn1cblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnT2JqKSB7XG4gIHZhciByID0gbmV3IEJOKHNpZ09iai5yKVxuICBpZiAoci5jbXAoZWNwYXJhbXMubikgPj0gMCkgciA9IG5ldyBCTigwKVxuXG4gIHZhciBzID0gbmV3IEJOKHNpZ09iai5zKVxuICBpZiAocy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcyA9IG5ldyBCTigwKVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICByLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLFxuICAgIHMudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbiAgXSlcbn1cblxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHByaXZhdGVLZXksIG5vbmNlZm4sIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBub25jZWZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGdldE5vbmNlID0gbm9uY2VmblxuICAgIG5vbmNlZm4gPSBmdW5jdGlvbiAoY291bnRlcikge1xuICAgICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UobWVzc2FnZSwgcHJpdmF0ZUtleSwgbnVsbCwgZGF0YSwgY291bnRlcilcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG5vbmNlKSB8fCBub25jZS5sZW5ndGggIT09IDMyKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTl9GQUlMKVxuXG4gICAgICByZXR1cm4gbmV3IEJOKG5vbmNlKVxuICAgIH1cbiAgfVxuXG4gIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIGlmIChkLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGQuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOX0ZBSUwpXG5cbiAgdmFyIHJlc3VsdCA9IGVjLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgeyBjYW5vbmljYWw6IHRydWUsIGs6IG5vbmNlZm4sIHBlcnM6IGRhdGEgfSlcbiAgcmV0dXJuIHtcbiAgICBzaWduYXR1cmU6IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgcmVzdWx0LnIudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksXG4gICAgICByZXN1bHQucy50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxuICAgIF0pLFxuICAgIHJlY292ZXJ5OiByZXN1bHQucmVjb3ZlcnlQYXJhbVxuICB9XG59XG5cbmV4cG9ydHMudmVyaWZ5ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gIHZhciBzaWdPYmogPSB7IHI6IHNpZ25hdHVyZS5zbGljZSgwLCAzMiksIHM6IHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpIH1cblxuICB2YXIgc2lnciA9IG5ldyBCTihzaWdPYmoucilcbiAgdmFyIHNpZ3MgPSBuZXcgQk4oc2lnT2JqLnMpXG4gIGlmIChzaWdyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNpZ3MuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTClcbiAgaWYgKHNpZ3MuY21wKGVjLm5oKSA9PT0gMSB8fCBzaWdyLmlzWmVybygpIHx8IHNpZ3MuaXNaZXJvKCkpIHJldHVybiBmYWxzZVxuXG4gIHZhciBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwYWlyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHJldHVybiBlYy52ZXJpZnkobWVzc2FnZSwgc2lnT2JqLCB7IHg6IHBhaXIucHViLngsIHk6IHBhaXIucHViLnkgfSlcbn1cblxuZXhwb3J0cy5yZWNvdmVyID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHNpZ09iaiA9IHsgcjogc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSwgczogc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkgfVxuXG4gIHZhciBzaWdyID0gbmV3IEJOKHNpZ09iai5yKVxuICB2YXIgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgaWYgKHNpZ3IuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2lncy5jbXAoZWNwYXJhbXMubikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMKVxuXG4gIHRyeSB7XG4gICAgaWYgKHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKClcblxuICAgIHZhciBwb2ludCA9IGVjLnJlY292ZXJQdWJLZXkobWVzc2FnZSwgc2lnT2JqLCByZWNvdmVyeSlcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfUkVDT1ZFUl9GQUlMKVxuICB9XG59XG5cbmV4cG9ydHMuZWNkaCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgdmFyIHNoYXJlZCA9IGV4cG9ydHMuZWNkaFVuc2FmZShwdWJsaWNLZXksIHByaXZhdGVLZXksIHRydWUpXG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc2hhcmVkKS5kaWdlc3QoKVxufVxuXG5leHBvcnRzLmVjZGhVbnNhZmUgPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwYWlyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSlcbiAgaWYgKHNjYWxhci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzY2FsYXIuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RIX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhaXIucHViLm11bChzY2FsYXIpLmVuY29kZSh0cnVlLCBjb21wcmVzc2VkKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0JylcbnZhciBkZXIgPSByZXF1aXJlKCcuL2RlcicpXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzLmpzb24nKVxuXG5mdW5jdGlvbiBpbml0Q29tcHJlc3NlZFZhbHVlICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZGVmYXVsdFZhbHVlXG5cbiAgYXNzZXJ0LmlzQm9vbGVhbih2YWx1ZSwgbWVzc2FnZXMuQ09NUFJFU1NFRF9UWVBFX0lOVkFMSUQpXG4gIHJldHVybiB2YWx1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWNwMjU2azEpIHtcbiAgcmV0dXJuIHtcbiAgICBwcml2YXRlS2V5VmVyaWZ5OiBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIHJldHVybiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIgJiYgc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSlcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleUV4cG9ydDogZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuICAgICAgdmFyIHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIGNvbXByZXNzZWQpXG5cbiAgICAgIHJldHVybiBkZXIucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlJbXBvcnQ6IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuXG4gICAgICBwcml2YXRlS2V5ID0gZGVyLnByaXZhdGVLZXlJbXBvcnQocHJpdmF0ZUtleSlcbiAgICAgIGlmIChwcml2YXRlS2V5ICYmIHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiAmJiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KSkgcmV0dXJuIHByaXZhdGVLZXlcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0lNUE9SVF9ERVJfRkFJTClcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleU5lZ2F0ZTogZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlOZWdhdGUocHJpdmF0ZUtleSlcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleU1vZEludmVyc2U6IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHByaXZhdGVLZXksIDMyLCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5TW9kSW52ZXJzZShwcml2YXRlS2V5KVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VHdlYWtBZGQ6IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcih0d2VhaywgbWVzc2FnZXMuVFdFQUtfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHR3ZWFrLCAzMiwgbWVzc2FnZXMuVFdFQUtfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKHByaXZhdGVLZXksIHR3ZWFrKVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VHdlYWtNdWw6IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcih0d2VhaywgbWVzc2FnZXMuVFdFQUtfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHR3ZWFrLCAzMiwgbWVzc2FnZXMuVFdFQUtfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKHByaXZhdGVLZXksIHR3ZWFrKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDcmVhdGU6IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHByaXZhdGVLZXksIDMyLCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgY29tcHJlc3NlZClcbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29udmVydDogZnVuY3Rpb24gKHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleSwgMzMsIDY1LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlWZXJpZnk6IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVibGljS2V5KVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlUd2Vha0FkZDogZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHR3ZWFrLCBtZXNzYWdlcy5UV0VBS19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgodHdlYWssIDMyLCBtZXNzYWdlcy5UV0VBS19MRU5HVEhfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlUd2Vha011bDogZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHR3ZWFrLCBtZXNzYWdlcy5UV0VBS19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgodHdlYWssIDMyLCBtZXNzYWdlcy5UV0VBS19MRU5HVEhfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDb21iaW5lOiBmdW5jdGlvbiAocHVibGljS2V5cywgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQXJyYXkocHVibGljS2V5cywgbWVzc2FnZXMuRUNfUFVCTElDX0tFWVNfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTGVuZ3RoR1RaZXJvKHB1YmxpY0tleXMsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlTX0xFTkdUSF9JTlZBTElEKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdWJsaWNLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXlzW2ldLCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXlzW2ldLCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG4gICAgICB9XG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShwdWJsaWNLZXlzLCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBzaWduYXR1cmVOb3JtYWxpemU6IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihzaWduYXR1cmUsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgoc2lnbmF0dXJlLCA2NCwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShzaWduYXR1cmUpXG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUV4cG9ydDogZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHZhciBzaWdPYmogPSBzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KHNpZ25hdHVyZSlcbiAgICAgIHJldHVybiBkZXIuc2lnbmF0dXJlRXhwb3J0KHNpZ09iailcbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlSW1wb3J0OiBmdW5jdGlvbiAoc2lnKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTGVuZ3RoR1RaZXJvKHNpZywgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICB2YXIgc2lnT2JqID0gZGVyLnNpZ25hdHVyZUltcG9ydChzaWcpXG4gICAgICBpZiAoc2lnT2JqKSByZXR1cm4gc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChzaWdPYmopXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfREVSX0ZBSUwpXG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUltcG9ydExheDogZnVuY3Rpb24gKHNpZykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZywgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0xlbmd0aEdUWmVybyhzaWcsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgdmFyIHNpZ09iaiA9IGRlci5zaWduYXR1cmVJbXBvcnRMYXgoc2lnKVxuICAgICAgaWYgKHNpZ09iaikgcmV0dXJuIHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQoc2lnT2JqKVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0RFUl9GQUlMKVxuICAgIH0sXG5cbiAgICBzaWduOiBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKG1lc3NhZ2UsIG1lc3NhZ2VzLk1TRzMyX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChtZXNzYWdlLCAzMiwgbWVzc2FnZXMuTVNHMzJfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICB2YXIgZGF0YSA9IG51bGxcbiAgICAgIHZhciBub25jZWZuID0gbnVsbFxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnQuaXNPYmplY3Qob3B0aW9ucywgbWVzc2FnZXMuT1BUSU9OU19UWVBFX0lOVkFMSUQpXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXNzZXJ0LmlzQnVmZmVyKG9wdGlvbnMuZGF0YSwgbWVzc2FnZXMuT1BUSU9OU19EQVRBX1RZUEVfSU5WQUxJRClcbiAgICAgICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgob3B0aW9ucy5kYXRhLCAzMiwgbWVzc2FnZXMuT1BUSU9OU19EQVRBX0xFTkdUSF9JTlZBTElEKVxuICAgICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFzc2VydC5pc0Z1bmN0aW9uKG9wdGlvbnMubm9uY2VmbiwgbWVzc2FnZXMuT1BUSU9OU19OT05DRUZOX1RZUEVfSU5WQUxJRClcbiAgICAgICAgICBub25jZWZuID0gb3B0aW9ucy5ub25jZWZuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5zaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIG5vbmNlZm4sIGRhdGEpXG4gICAgfSxcblxuICAgIHZlcmlmeTogZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIobWVzc2FnZSwgbWVzc2FnZXMuTVNHMzJfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKG1lc3NhZ2UsIDMyLCBtZXNzYWdlcy5NU0czMl9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpXG4gICAgfSxcblxuICAgIHJlY292ZXI6IGZ1bmN0aW9uIChtZXNzYWdlLCBzaWduYXR1cmUsIHJlY292ZXJ5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIobWVzc2FnZSwgbWVzc2FnZXMuTVNHMzJfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKG1lc3NhZ2UsIDMyLCBtZXNzYWdlcy5NU0czMl9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc051bWJlcihyZWNvdmVyeSwgbWVzc2FnZXMuUkVDT1ZFUllfSURfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTnVtYmVySW5JbnRlcnZhbChyZWNvdmVyeSwgLTEsIDQsIG1lc3NhZ2VzLlJFQ09WRVJZX0lEX1ZBTFVFX0lOVkFMSUQpXG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucmVjb3ZlcihtZXNzYWdlLCBzaWduYXR1cmUsIHJlY292ZXJ5LCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBlY2RoOiBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHVibGljS2V5LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aDIocHVibGljS2V5LCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLmVjZGgocHVibGljS2V5LCBwcml2YXRlS2V5KVxuICAgIH0sXG5cbiAgICBlY2RoVW5zYWZlOiBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHVibGljS2V5LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aDIocHVibGljS2V5LCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLmVjZGhVbnNhZmUocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKVxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIkNPTVBSRVNTRURfVFlQRV9JTlZBTElEXCI6IFwiY29tcHJlc3NlZCBzaG91bGQgYmUgYSBib29sZWFuXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEXCI6IFwicHJpdmF0ZSBrZXkgc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSURcIjogXCJwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZFwiLFxuICBcIkVDX1BSSVZBVEVfS0VZX1JBTkdFX0lOVkFMSURcIjogXCJwcml2YXRlIGtleSByYW5nZSBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfVFdFQUtfQUREX0ZBSUxcIjogXCJ0d2VhayBvdXQgb2YgcmFuZ2Ugb3IgcmVzdWx0aW5nIHByaXZhdGUga2V5IGlzIGludmFsaWRcIixcbiAgXCJFQ19QUklWQVRFX0tFWV9UV0VBS19NVUxfRkFJTFwiOiBcInR3ZWFrIG91dCBvZiByYW5nZVwiLFxuICBcIkVDX1BSSVZBVEVfS0VZX0VYUE9SVF9ERVJfRkFJTFwiOiBcImNvdWxkbid0IGV4cG9ydCB0byBERVIgZm9ybWF0XCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfSU1QT1JUX0RFUl9GQUlMXCI6IFwiY291bGRuJ3QgaW1wb3J0IGZyb20gREVSIGZvcm1hdFwiLFxuICBcIkVDX1BVQkxJQ19LRVlTX1RZUEVfSU5WQUxJRFwiOiBcInB1YmxpYyBrZXlzIHNob3VsZCBiZSBhbiBBcnJheVwiLFxuICBcIkVDX1BVQkxJQ19LRVlTX0xFTkdUSF9JTlZBTElEXCI6IFwicHVibGljIGtleXMgQXJyYXkgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMSBlbGVtZW50XCIsXG4gIFwiRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSURcIjogXCJwdWJsaWMga2V5IHNob3VsZCBiZSBhIEJ1ZmZlclwiLFxuICBcIkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSURcIjogXCJwdWJsaWMga2V5IGxlbmd0aCBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMXCI6IFwidGhlIHB1YmxpYyBrZXkgY291bGQgbm90IGJlIHBhcnNlZCBvciBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9DUkVBVEVfRkFJTFwiOiBcInByaXZhdGUgd2FzIGludmFsaWQsIHRyeSBhZ2FpblwiLFxuICBcIkVDX1BVQkxJQ19LRVlfVFdFQUtfQUREX0ZBSUxcIjogXCJ0d2VhayBvdXQgb2YgcmFuZ2Ugb3IgcmVzdWx0aW5nIHB1YmxpYyBrZXkgaXMgaW52YWxpZFwiLFxuICBcIkVDX1BVQkxJQ19LRVlfVFdFQUtfTVVMX0ZBSUxcIjogXCJ0d2VhayBvdXQgb2YgcmFuZ2VcIixcbiAgXCJFQ19QVUJMSUNfS0VZX0NPTUJJTkVfRkFJTFwiOiBcInRoZSBzdW0gb2YgdGhlIHB1YmxpYyBrZXlzIGlzIG5vdCB2YWxpZFwiLFxuICBcIkVDREhfRkFJTFwiOiBcInNjYWxhciB3YXMgaW52YWxpZCAoemVybyBvciBvdmVyZmxvdylcIixcbiAgXCJFQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEXCI6IFwic2lnbmF0dXJlIHNob3VsZCBiZSBhIEJ1ZmZlclwiLFxuICBcIkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRFwiOiBcInNpZ25hdHVyZSBsZW5ndGggaXMgaW52YWxpZFwiLFxuICBcIkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMXCI6IFwiY291bGRuJ3QgcGFyc2Ugc2lnbmF0dXJlXCIsXG4gIFwiRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0RFUl9GQUlMXCI6IFwiY291bGRuJ3QgcGFyc2UgREVSIHNpZ25hdHVyZVwiLFxuICBcIkVDRFNBX1NJR05BVFVSRV9TRVJJQUxJWkVfREVSX0ZBSUxcIjogXCJjb3VsZG4ndCBzZXJpYWxpemUgc2lnbmF0dXJlIHRvIERFUiBmb3JtYXRcIixcbiAgXCJFQ0RTQV9TSUdOX0ZBSUxcIjogXCJub25jZSBnZW5lcmF0aW9uIGZ1bmN0aW9uIGZhaWxlZCBvciBwcml2YXRlIGtleSBpcyBpbnZhbGlkXCIsXG4gIFwiRUNEU0FfUkVDT1ZFUl9GQUlMXCI6IFwiY291bGRuJ3QgcmVjb3ZlciBwdWJsaWMga2V5IGZyb20gc2lnbmF0dXJlXCIsXG4gIFwiTVNHMzJfVFlQRV9JTlZBTElEXCI6IFwibWVzc2FnZSBzaG91bGQgYmUgYSBCdWZmZXJcIixcbiAgXCJNU0czMl9MRU5HVEhfSU5WQUxJRFwiOiBcIm1lc3NhZ2UgbGVuZ3RoIGlzIGludmFsaWRcIixcbiAgXCJPUFRJT05TX1RZUEVfSU5WQUxJRFwiOiBcIm9wdGlvbnMgc2hvdWxkIGJlIGFuIE9iamVjdFwiLFxuICBcIk9QVElPTlNfREFUQV9UWVBFX0lOVkFMSURcIjogXCJvcHRpb25zLmRhdGEgc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiT1BUSU9OU19EQVRBX0xFTkdUSF9JTlZBTElEXCI6IFwib3B0aW9ucy5kYXRhIGxlbmd0aCBpcyBpbnZhbGlkXCIsXG4gIFwiT1BUSU9OU19OT05DRUZOX1RZUEVfSU5WQUxJRFwiOiBcIm9wdGlvbnMubm9uY2VmbiBzaG91bGQgYmUgYSBGdW5jdGlvblwiLFxuICBcIlJFQ09WRVJZX0lEX1RZUEVfSU5WQUxJRFwiOiBcInJlY292ZXJ5IHNob3VsZCBiZSBhIE51bWJlclwiLFxuICBcIlJFQ09WRVJZX0lEX1ZBTFVFX0lOVkFMSURcIjogXCJyZWNvdmVyeSBzaG91bGQgaGF2ZSB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCA0XCIsXG4gIFwiVFdFQUtfVFlQRV9JTlZBTElEXCI6IFwidHdlYWsgc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiVFdFQUtfTEVOR1RIX0lOVkFMSURcIjogXCJ0d2VhayBsZW5ndGggaXMgaW52YWxpZFwiXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xudmFyIF9HYXNGZWVDb250cm9sbGVyX2luc3RhbmNlcywgX0dhc0ZlZUNvbnRyb2xsZXJfZ2V0UHJvdmlkZXIsIF9HYXNGZWVDb250cm9sbGVyX29uTmV0d29ya0NvbnRyb2xsZXJTdGF0ZUNoYW5nZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuR2FzRmVlQ29udHJvbGxlciA9IGV4cG9ydHMuR0FTX0VTVElNQVRFX1RZUEVTID0gZXhwb3J0cy5MRUdBQ1lfR0FTX1BSSUNFU19BUElfVVJMID0gdm9pZCAwO1xuY29uc3QgZXRoX3F1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1xdWVyeVwiKSk7XG5jb25zdCB1dWlkXzEgPSByZXF1aXJlKFwidXVpZFwiKTtcbmNvbnN0IGJhc2VfY29udHJvbGxlcl8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9iYXNlLWNvbnRyb2xsZXJcIik7XG5jb25zdCBjb250cm9sbGVyX3V0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2NvbnRyb2xsZXItdXRpbHNcIik7XG5jb25zdCBnYXNfdXRpbF8xID0gcmVxdWlyZShcIi4vZ2FzLXV0aWxcIik7XG5jb25zdCBkZXRlcm1pbmVHYXNGZWVDYWxjdWxhdGlvbnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9kZXRlcm1pbmVHYXNGZWVDYWxjdWxhdGlvbnNcIikpO1xuY29uc3QgZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5XCIpKTtcbmV4cG9ydHMuTEVHQUNZX0dBU19QUklDRVNfQVBJX1VSTCA9IGBodHRwczovL2FwaS5tZXRhc3dhcC5jb2RlZmkubmV0d29yay9nYXNQcmljZXNgO1xuLyoqXG4gKiBJbmRpY2F0ZXMgd2hpY2ggdHlwZSBvZiBnYXNFc3RpbWF0ZSB0aGUgY29udHJvbGxlciBpcyBjdXJyZW50bHkgcmV0dXJuaW5nLlxuICogVGhpcyBpcyB1c2VmdWwgYXMgYSB3YXkgb2YgYXNzZXJ0aW5nIHRoYXQgdGhlIHNoYXBlIG9mIGdhc0VzdGltYXRlcyBtYXRjaGVzXG4gKiBleHBlY3RhdGlvbnMuIE5PTkUgaXMgYSBzcGVjaWFsIGNhc2UgaW5kaWNhdGluZyB0aGF0IG5vIHByZXZpb3VzIGdhc0VzdGltYXRlXG4gKiBoYXMgYmVlbiBmZXRjaGVkLlxuICovXG5leHBvcnRzLkdBU19FU1RJTUFURV9UWVBFUyA9IHtcbiAgICBGRUVfTUFSS0VUOiAnZmVlLW1hcmtldCcsXG4gICAgTEVHQUNZOiAnbGVnYWN5JyxcbiAgICBFVEhfR0FTUFJJQ0U6ICdldGhfZ2FzUHJpY2UnLFxuICAgIE5PTkU6ICdub25lJyxcbn07XG5jb25zdCBtZXRhZGF0YSA9IHtcbiAgICBnYXNGZWVFc3RpbWF0ZXM6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxuICAgIGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHM6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxuICAgIGdhc0VzdGltYXRlVHlwZTogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IGZhbHNlIH0sXG59O1xuY29uc3QgbmFtZSA9ICdHYXNGZWVDb250cm9sbGVyJztcbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBnYXNGZWVFc3RpbWF0ZXM6IHt9LFxuICAgIGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHM6IHt9LFxuICAgIGdhc0VzdGltYXRlVHlwZTogZXhwb3J0cy5HQVNfRVNUSU1BVEVfVFlQRVMuTk9ORSxcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCByZXRyaWV2ZXMgZ2FzIGZlZSBlc3RpbWF0ZSBkYXRhIGFuZCBwb2xscyBmb3IgdXBkYXRlZCBkYXRhIG9uIGEgc2V0IGludGVydmFsXG4gKi9cbmNsYXNzIEdhc0ZlZUNvbnRyb2xsZXIgZXh0ZW5kcyBiYXNlX2NvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlclYyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgR2FzRmVlQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbCAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW4gcG9sbHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWVzc2VuZ2VyIC0gVGhlIGNvbnRyb2xsZXIgbWVzc2VuZ2VyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gVGhlIGluaXRpYWwgc3RhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eSAtIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnRcbiAgICAgKiBuZXR3b3JrIGlzIEVJUC0xNTU5IGNvbXBhdGlibGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICAgKiBjdXJyZW50IG5ldHdvcmsgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBsZWdhY3kgZ2FzIHByaWNlIEFQSS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudFxuICAgICAqIGFjY291bnQgaXMgRUlQLTE1NTkgY29tcGF0aWJsZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRDaGFpbklkIC0gUmV0dXJucyB0aGUgY3VycmVudCBjaGFpbiBJRC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRQcm92aWRlciAtIFJldHVybnMgYSBuZXR3b3JrIHByb3ZpZGVyIGZvciB0aGUgY3VycmVudCBuZXR3b3JrLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uTmV0d29ya1N0YXRlQ2hhbmdlIC0gQSBmdW5jdGlvbiBmb3IgcmVnaXN0ZXJpbmcgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlXG4gICAgICogbmV0d29yayBzdGF0ZSBjaGFuZ2UgZXZlbnQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGVnYWN5QVBJRW5kcG9pbnQgLSBUaGUgbGVnYWN5IGdhcyBwcmljZSBBUEkgVVJMLiBUaGlzIG9wdGlvbiBpcyBwcmltYXJpbHkgZm9yXG4gICAgICogdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5FSVAxNTU5QVBJRW5kcG9pbnQgLSBUaGUgRUlQLTE1NTkgZ2FzIHByaWNlIEFQSSBVUkwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2xpZW50SWQgLSBUaGUgY2xpZW50IElEIHVzZWQgdG8gaWRlbnRpZnkgdG8gdGhlIGdhcyBlc3RpbWF0aW9uIEFQSSB3aG8gaXNcbiAgICAgKiBhc2tpbmcgZm9yIGVzdGltYXRlcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGludGVydmFsID0gMTUwMDAsIG1lc3Nlbmdlciwgc3RhdGUsIGdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHksIGdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHksIGdldENoYWluSWQsIGdldEN1cnJlbnROZXR3b3JrTGVnYWN5R2FzQVBJQ29tcGF0aWJpbGl0eSwgZ2V0UHJvdmlkZXIsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBsZWdhY3lBUElFbmRwb2ludCA9IGV4cG9ydHMuTEVHQUNZX0dBU19QUklDRVNfQVBJX1VSTCwgRUlQMTU1OUFQSUVuZHBvaW50LCBjbGllbnRJZCwgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBtZXNzZW5nZXIsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3RhdGUpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICBfR2FzRmVlQ29udHJvbGxlcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICBfR2FzRmVlQ29udHJvbGxlcl9nZXRQcm92aWRlci5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbERlbGF5ID0gaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMucG9sbFRva2VucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5ID1cbiAgICAgICAgICAgIGdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHk7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5ID1cbiAgICAgICAgICAgIGdldEN1cnJlbnROZXR3b3JrTGVnYWN5R2FzQVBJQ29tcGF0aWJpbGl0eTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5ID1cbiAgICAgICAgICAgIGdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0dhc0ZlZUNvbnRyb2xsZXJfZ2V0UHJvdmlkZXIsIGdldFByb3ZpZGVyLCBcImZcIik7XG4gICAgICAgIHRoaXMuRUlQMTU1OUFQSUVuZHBvaW50ID0gRUlQMTU1OUFQSUVuZHBvaW50O1xuICAgICAgICB0aGlzLmxlZ2FjeUFQSUVuZHBvaW50ID0gbGVnYWN5QVBJRW5kcG9pbnQ7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBjbGllbnRJZDtcbiAgICAgICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBldGhfcXVlcnlfMS5kZWZhdWx0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0dhc0ZlZUNvbnRyb2xsZXJfZ2V0UHJvdmlkZXIsIFwiZlwiKS5jYWxsKHRoaXMpKTtcbiAgICAgICAgaWYgKG9uTmV0d29ya1N0YXRlQ2hhbmdlICYmIGdldENoYWluSWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoYWluSWQgPSBnZXRDaGFpbklkKCk7XG4gICAgICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgobmV0d29ya0NvbnRyb2xsZXJTdGF0ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0dhc0ZlZUNvbnRyb2xsZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0dhc0ZlZUNvbnRyb2xsZXJfb25OZXR3b3JrQ29udHJvbGxlclN0YXRlQ2hhbmdlKS5jYWxsKHRoaXMsIG5ldHdvcmtDb250cm9sbGVyU3RhdGUpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hhaW5JZCA9IHRoaXMubWVzc2FnaW5nU3lzdGVtLmNhbGwoJ05ldHdvcmtDb250cm9sbGVyOmdldFN0YXRlJykucHJvdmlkZXJDb25maWcuY2hhaW5JZDtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnN1YnNjcmliZSgnTmV0d29ya0NvbnRyb2xsZXI6c3RhdGVDaGFuZ2UnLCAobmV0d29ya0NvbnRyb2xsZXJTdGF0ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0dhc0ZlZUNvbnRyb2xsZXJfaW5zdGFuY2VzLCBcIm1cIiwgX0dhc0ZlZUNvbnRyb2xsZXJfb25OZXR3b3JrQ29udHJvbGxlclN0YXRlQ2hhbmdlKS5jYWxsKHRoaXMsIG5ldHdvcmtDb250cm9sbGVyU3RhdGUpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0UG9sbGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvbGxUb2tlbnMuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IEFycmF5LmZyb20odGhpcy5wb2xsVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5nZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmcodG9rZW5zWzBdKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMuc2xpY2UoMSkuZm9yRWFjaCgodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsVG9rZW5zLmFkZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaEdhc0ZlZUVzdGltYXRlcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5fZmV0Y2hHYXNGZWVFc3RpbWF0ZURhdGEob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmcocG9sbFRva2VuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBfcG9sbFRva2VuID0gcG9sbFRva2VuIHx8ICgwLCB1dWlkXzEudjEpKCk7XG4gICAgICAgICAgICB0aGlzLnBvbGxUb2tlbnMuYWRkKF9wb2xsVG9rZW4pO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9sbFRva2Vucy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5fZmV0Y2hHYXNGZWVFc3RpbWF0ZURhdGEoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3BvbGxUb2tlbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYW5kIHNldHMgZ2FzRmVlRXN0aW1hdGVzIGluIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZ2FzIGZlZSBlc3RpbWF0ZSBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNob3VsZFVwZGF0ZVN0YXRlIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzdGF0ZSBzaG91bGQgYmUgdXBkYXRlZCB3aXRoIHRoZVxuICAgICAqIHVwZGF0ZWQgZ2FzIGVzdGltYXRlcy5cbiAgICAgKiBAcmV0dXJucyBUaGUgZ2FzIGZlZSBlc3RpbWF0ZXMuXG4gICAgICovXG4gICAgX2ZldGNoR2FzRmVlRXN0aW1hdGVEYXRhKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBzaG91bGRVcGRhdGVTdGF0ZSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBsZXQgaXNFSVAxNTU5Q29tcGF0aWJsZTtcbiAgICAgICAgICAgIGNvbnN0IGlzTGVnYWN5R2FzQVBJQ29tcGF0aWJsZSA9IHRoaXMuZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5KCk7XG4gICAgICAgICAgICBjb25zdCBkZWNpbWFsQ2hhaW5JZCA9ICgwLCBjb250cm9sbGVyX3V0aWxzXzEuY29udmVydEhleFRvRGVjaW1hbCkodGhpcy5jdXJyZW50Q2hhaW5JZCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlzRUlQMTU1OUNvbXBhdGlibGUgPSB5aWVsZCB0aGlzLmdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgaXNFSVAxNTU5Q29tcGF0aWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZ2FzRmVlQ2FsY3VsYXRpb25zID0geWllbGQgKDAsIGRldGVybWluZUdhc0ZlZUNhbGN1bGF0aW9uc18xLmRlZmF1bHQpKHtcbiAgICAgICAgICAgICAgICBpc0VJUDE1NTlDb21wYXRpYmxlLFxuICAgICAgICAgICAgICAgIGlzTGVnYWN5R2FzQVBJQ29tcGF0aWJsZSxcbiAgICAgICAgICAgICAgICBmZXRjaEdhc0VzdGltYXRlczogZ2FzX3V0aWxfMS5mZXRjaEdhc0VzdGltYXRlcyxcbiAgICAgICAgICAgICAgICBmZXRjaEdhc0VzdGltYXRlc1VybDogdGhpcy5FSVAxNTU5QVBJRW5kcG9pbnQucmVwbGFjZSgnPGNoYWluX2lkPicsIGAke2RlY2ltYWxDaGFpbklkfWApLFxuICAgICAgICAgICAgICAgIGZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeTogZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5XzEuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBmZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzOiBnYXNfdXRpbF8xLmZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXMsXG4gICAgICAgICAgICAgICAgZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlc1VybDogdGhpcy5sZWdhY3lBUElFbmRwb2ludC5yZXBsYWNlKCc8Y2hhaW5faWQ+JywgYCR7ZGVjaW1hbENoYWluSWR9YCksXG4gICAgICAgICAgICAgICAgZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlOiBnYXNfdXRpbF8xLmZldGNoRXRoR2FzUHJpY2VFc3RpbWF0ZSxcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVUaW1lRXN0aW1hdGU6IGdhc191dGlsXzEuY2FsY3VsYXRlVGltZUVzdGltYXRlLFxuICAgICAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIGV0aFF1ZXJ5OiB0aGlzLmV0aFF1ZXJ5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ2FzRmVlRXN0aW1hdGVzID0gZ2FzRmVlQ2FsY3VsYXRpb25zLmdhc0ZlZUVzdGltYXRlcztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNGZWVDYWxjdWxhdGlvbnMuZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kcztcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ2FzRXN0aW1hdGVUeXBlID0gZ2FzRmVlQ2FsY3VsYXRpb25zLmdhc0VzdGltYXRlVHlwZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnYXNGZWVDYWxjdWxhdGlvbnM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHBvbGwgdG9rZW4sIGFuZCBzdG9wIHBvbGxpbmcgaWYgdGhlIHNldCBvZiBwb2xsIHRva2VucyBpcyBlbXB0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwb2xsVG9rZW4gLSBUaGUgcG9sbCB0b2tlbiB0byBkaXNjb25uZWN0LlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RQb2xsZXIocG9sbFRva2VuKSB7XG4gICAgICAgIHRoaXMucG9sbFRva2Vucy5kZWxldGUocG9sbFRva2VuKTtcbiAgICAgICAgaWYgKHRoaXMucG9sbFRva2Vucy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcFBvbGxpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvbGxUb2tlbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdG8gZGlzY2FyZCB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHN0b3BzIGFueSBhY3RpdmUgcG9sbGluZy5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gICAgX3BvbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCAoMCwgY29udHJvbGxlcl91dGlsc18xLnNhZmVseUV4ZWN1dGUpKCgpID0+IHRoaXMuX2ZldGNoR2FzRmVlRXN0aW1hdGVEYXRhKCkpO1xuICAgICAgICB9KSwgdGhpcy5pbnRlcnZhbERlbGF5KTtcbiAgICB9XG4gICAgcmVzZXRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEVJUDE1NTlDb21wYXRpYmlsaXR5KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE5ldHdvcmtJc0VJUDE1NTlDb21wYXRpYmxlID0geWllbGQgdGhpcy5nZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5KCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QWNjb3VudElzRUlQMTU1OUNvbXBhdGlibGUgPSAoX2IgPSAoX2EgPSB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIChjdXJyZW50TmV0d29ya0lzRUlQMTU1OUNvbXBhdGlibGUgJiYgY3VycmVudEFjY291bnRJc0VJUDE1NTlDb21wYXRpYmxlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFRpbWVFc3RpbWF0ZShtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5nYXNGZWVFc3RpbWF0ZXMgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuZ2FzRXN0aW1hdGVUeXBlICE9PSBleHBvcnRzLkdBU19FU1RJTUFURV9UWVBFUy5GRUVfTUFSS0VUKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBnYXNfdXRpbF8xLmNhbGN1bGF0ZVRpbWVFc3RpbWF0ZSkobWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgdGhpcy5zdGF0ZS5nYXNGZWVFc3RpbWF0ZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuR2FzRmVlQ29udHJvbGxlciA9IEdhc0ZlZUNvbnRyb2xsZXI7XG5fR2FzRmVlQ29udHJvbGxlcl9nZXRQcm92aWRlciA9IG5ldyBXZWFrTWFwKCksIF9HYXNGZWVDb250cm9sbGVyX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9HYXNGZWVDb250cm9sbGVyX29uTmV0d29ya0NvbnRyb2xsZXJTdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIF9HYXNGZWVDb250cm9sbGVyX29uTmV0d29ya0NvbnRyb2xsZXJTdGF0ZUNoYW5nZShuZXR3b3JrQ29udHJvbGxlclN0YXRlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgbmV3Q2hhaW5JZCA9IG5ldHdvcmtDb250cm9sbGVyU3RhdGUucHJvdmlkZXJDb25maWcuY2hhaW5JZDtcbiAgICAgICAgaWYgKG5ld0NoYWluSWQgIT09IHRoaXMuY3VycmVudENoYWluSWQpIHtcbiAgICAgICAgICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgZXRoX3F1ZXJ5XzEuZGVmYXVsdChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9HYXNGZWVDb250cm9sbGVyX2dldFByb3ZpZGVyLCBcImZcIikuY2FsbCh0aGlzKSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnJlc2V0UG9sbGluZygpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hhaW5JZCA9IG5ld0NoYWluSWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBHYXNGZWVDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R2FzRmVlQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgR2FzRmVlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4vR2FzRmVlQ29udHJvbGxlclwiKTtcbi8qKlxuICogT2J0YWlucyBhIHNldCBvZiBtYXggYmFzZSBhbmQgcHJpb3JpdHkgZmVlIGVzdGltYXRlcyBhbG9uZyB3aXRoIHRpbWUgZXN0aW1hdGVzIHNvIHRoYXQgd2VcbiAqIGNhbiBwcmVzZW50IHRoZW0gdG8gdXNlcnMgd2hlbiB0aGV5IGFyZSBzZW5kaW5nIHRyYW5zYWN0aW9ucyBvciBtYWtpbmcgc3dhcHMuXG4gKlxuICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzLlxuICogQHBhcmFtIGFyZ3MuaXNFSVAxNTU5Q29tcGF0aWJsZSAtIEdvdmVybnMgd2hldGhlciBvciBub3Qgd2UgY2FuIHVzZSBhbiBFSVAtMTU1OS1vbmx5IG1ldGhvZCB0b1xuICogcHJvZHVjZSBlc3RpbWF0ZXMuXG4gKiBAcGFyYW0gYXJncy5pc0xlZ2FjeUdhc0FQSUNvbXBhdGlibGUgLSBHb3Zlcm5zIHdoZXRoZXIgb3Igbm90IHdlIGNhbiB1c2UgYSBub24tRUlQLTE1NTkgbWV0aG9kIHRvXG4gKiBwcm9kdWNlIGVzdGltYXRlcyAoZm9yIGluc3RhbmNlLCB0ZXN0bmV0cyBkbyBub3Qgc3VwcG9ydCBlc3RpbWF0ZXMgYWx0b2dldGhlcikuXG4gKiBAcGFyYW0gYXJncy5mZXRjaEdhc0VzdGltYXRlcyAtIEEgZnVuY3Rpb24gdGhhdCBmZXRjaGVzIGdhcyBlc3RpbWF0ZXMgdXNpbmcgYW4gRUlQLTE1NTktc3BlY2lmaWNcbiAqIEFQSS5cbiAqIEBwYXJhbSBhcmdzLmZldGNoR2FzRXN0aW1hdGVzVXJsIC0gVGhlIFVSTCBmb3IgdGhlIEFQSSB3ZSBjYW4gdXNlIHRvIG9idGFpbiBFSVAtMTU1OS1zcGVjaWZpY1xuICogZXN0aW1hdGVzLlxuICogQHBhcmFtIGFyZ3MuZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5IC0gQSBmdW5jdGlvbiB0aGF0IGZldGNoZXMgZ2FzIGVzdGltYXRlcyB1c2luZ1xuICogYGV0aF9mZWVIaXN0b3J5YCAoYW4gRUlQLTE1NTkgZmVhdHVyZSkuXG4gKiBAcGFyYW0gYXJncy5mZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzIC0gQSBmdW5jdGlvbiB0aGF0IGZldGNoZXMgZ2FzIGVzdGltYXRlcyB1c2luZyBhblxuICogbm9uLUVJUC0xNTU5LXNwZWNpZmljIEFQSS5cbiAqIEBwYXJhbSBhcmdzLmZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXNVcmwgLSBUaGUgVVJMIGZvciB0aGUgQVBJIHdlIGNhbiB1c2UgdG8gb2J0YWluXG4gKiBub24tRUlQLTE1NTktc3BlY2lmaWMgZXN0aW1hdGVzLlxuICogQHBhcmFtIGFyZ3MuZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlIC0gQSBmdW5jdGlvbiB0aGF0IGZldGNoZXMgZ2FzIGVzdGltYXRlcyB1c2luZ1xuICogYGV0aF9nYXNQcmljZWAuXG4gKiBAcGFyYW0gYXJncy5jYWxjdWxhdGVUaW1lRXN0aW1hdGUgLSBBIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lIHRpbWUgZXN0aW1hdGUgYm91bmRzLlxuICogQHBhcmFtIGFyZ3MuY2xpZW50SWQgLSBBbiBpZGVudGlmaWVyIHRoYXQgYW4gQVBJIGNhbiB1c2UgdG8ga25vdyB3aG8gaXMgYXNraW5nIGZvciBlc3RpbWF0ZXMuXG4gKiBAcGFyYW0gYXJncy5ldGhRdWVyeSAtIEFuIEV0aFF1ZXJ5IGluc3RhbmNlIHdlIGNhbiB1c2UgdG8gdGFsayB0byBFdGhlcmV1bSBkaXJlY3RseS5cbiAqIEByZXR1cm5zIFRoZSBnYXMgZmVlIGNhbGN1bGF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lR2FzRmVlQ2FsY3VsYXRpb25zKHsgaXNFSVAxNTU5Q29tcGF0aWJsZSwgaXNMZWdhY3lHYXNBUElDb21wYXRpYmxlLCBmZXRjaEdhc0VzdGltYXRlcywgZmV0Y2hHYXNFc3RpbWF0ZXNVcmwsIGZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeSwgZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlcywgZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlc1VybCwgZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlLCBjYWxjdWxhdGVUaW1lRXN0aW1hdGUsIGNsaWVudElkLCBldGhRdWVyeSwgfSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoaXNFSVAxNTU5Q29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgIGxldCBlc3RpbWF0ZXM7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVzID0geWllbGQgZmV0Y2hHYXNFc3RpbWF0ZXMoZmV0Y2hHYXNFc3RpbWF0ZXNVcmwsIGNsaWVudElkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzdGltYXRlcyA9IHlpZWxkIGZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeShldGhRdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMsIHN1Z2dlc3RlZE1heEZlZVBlckdhcyB9ID0gZXN0aW1hdGVzLm1lZGl1bTtcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZWRHYXNGZWVUaW1lQm91bmRzID0gY2FsY3VsYXRlVGltZUVzdGltYXRlKHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzLCBzdWdnZXN0ZWRNYXhGZWVQZXJHYXMsIGVzdGltYXRlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZ2FzRmVlRXN0aW1hdGVzOiBlc3RpbWF0ZXMsXG4gICAgICAgICAgICAgICAgICAgIGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHMsXG4gICAgICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlVHlwZTogR2FzRmVlQ29udHJvbGxlcl8xLkdBU19FU1RJTUFURV9UWVBFUy5GRUVfTUFSS0VULFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0xlZ2FjeUdhc0FQSUNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZXMgPSB5aWVsZCBmZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzKGZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXNVcmwsIGNsaWVudElkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXM6IGVzdGltYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kczoge30sXG4gICAgICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlVHlwZTogR2FzRmVlQ29udHJvbGxlcl8xLkdBU19FU1RJTUFURV9UWVBFUy5MRUdBQ1ksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFpbiBnYXMgZmVlL3ByaWNlIGVzdGltYXRpb24gZmFpbGVkLiBVc2UgZmFsbGJhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVzID0geWllbGQgZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlKGV0aFF1ZXJ5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXM6IGVzdGltYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kczoge30sXG4gICAgICAgICAgICAgICAgICAgIGdhc0VzdGltYXRlVHlwZTogR2FzRmVlQ29udHJvbGxlcl8xLkdBU19FU1RJTUFURV9UWVBFUy5FVEhfR0FTUFJJQ0UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR2FzIGZlZS9wcmljZSBlc3RpbWF0aW9uIGZhaWxlZC4gTWVzc2FnZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZGV0ZXJtaW5lR2FzRmVlQ2FsY3VsYXRpb25zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGV0ZXJtaW5lR2FzRmVlQ2FsY3VsYXRpb25zLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5jb25zdCBjb250cm9sbGVyX3V0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2NvbnRyb2xsZXItdXRpbHNcIik7XG5jb25zdCBNQVhfTlVNQkVSX09GX0JMT0NLU19QRVJfRVRIX0ZFRV9ISVNUT1JZX0NBTEwgPSAxMDI0O1xuLyoqXG4gKiBVc2VzIGBldGhfZmVlSGlzdG9yeWAgKGFuIEVJUC0xNTU5IGZlYXR1cmUpIHRvIG9idGFpbiBpbmZvcm1hdGlvbiBhYm91dCBnYXMgZmVlcyBmcm9tIGEgcmFuZ2Ugb2ZcbiAqIGJsb2NrcyB0aGF0IGhhdmUgb2NjdXJyZWQgcmVjZW50bHkgb24gYSBuZXR3b3JrLlxuICpcbiAqIFRvIGxlYXJuIG1vcmUsIHNlZSB0aGVzZSByZXNvdXJjZXM6XG4gKlxuICogLSA8aHR0cHM6Ly9pbmZ1cmEuaW8vZG9jcy9ldGhlcmV1bSNvcGVyYXRpb24vZXRoX2ZlZUhpc3Rvcnk+XG4gKiAtIDxodHRwczovL2dpdGh1Yi5jb20venNmZWxmb2xkaS9mZWVoaXN0b3J5L2Jsb2IvbWFpbi9kb2NzL2ZlZUhpc3RvcnkubWQ+XG4gKiAtIDxodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vYmxvYi81N2EzZmFiOGE3NWVlYjljMmY0ZmFiNzcwYjczYjUxYjlmZTY3MmM1L2V0aC9nYXNwcmljZS9mZWVoaXN0b3J5LmdvI0wxODA+XG4gKiAtIDxodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vRUlQcy9ibG9iL21hc3Rlci9FSVBTL2VpcC0xNTU5Lm1kPlxuICogLSA8aHR0cHM6Ly9nYXMtYXBpLm1ldGFzd2FwLmNvZGVmaS5uZXR3b3JrL3Rlc3RGZWVIaXN0b3J5PlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIGFyZ3MuZXRoUXVlcnkgLSBBbiBFdGhRdWVyeSBpbnN0YW5jZSB0aGF0IHdyYXBzIGEgcHJvdmlkZXIgZm9yIHRoZSBuZXR3b3JrIGluIHF1ZXN0aW9uLlxuICogQHBhcmFtIGFyZ3MuZW5kQmxvY2sgLSBUaGUgZGVzaXJlZCBlbmQgb2YgdGhlIHJlcXVlc3RlZCBibG9jayByYW5nZS4gQ2FuIGJlIFwibGF0ZXN0XCIgaWYgeW91IHdhbnRcbiAqIHRvIHN0YXJ0IGZyb20gdGhlIGxhdGVzdCBzdWNjZXNzZnVsIGJsb2NrIG9yIHRoZSBudW1iZXIgb2YgYSBrbm93biBwYXN0IGJsb2NrLlxuICogQHBhcmFtIGFyZ3MubnVtYmVyT2ZCbG9ja3MgLSBIb3cgbWFueSB0b3RhbCBibG9ja3MgdG8gZmV0Y2guIE5vdGUgdGhhdCBpZiB0aGlzIGlzIG1vcmUgdGhhbiAxMDI0LFxuICogbXVsdGlwbGUgY2FsbHMgdG8gYGV0aF9mZWVIaXN0b3J5YCB3aWxsIGJlIG1hZGUuXG4gKiBAcGFyYW0gYXJncy5wZXJjZW50aWxlcyAtIEEgc2V0IG9mIG51bWJlcnMgYmV0d2VlbiAxIGFuZCAxMDAgd2hpY2ggd2lsbCBkaWN0YXRlIGhvd1xuICogYHByaW9yaXR5RmVlc0J5UGVyY2VudGlsZWAgaW4gZWFjaCByZXR1cm5lZCBibG9jayB3aWxsIGJlIGZvcm1lZC4gV2hlbiBFdGhlcmV1bSBydW5zIHRoZVxuICogYGV0aF9mZWVIaXN0b3J5YCBtZXRob2QsIGZvciBlYWNoIGJsb2NrIGl0IGlzIGNvbnNpZGVyaW5nLCBpdCB3aWxsIGZpcnN0IHNvcnQgYWxsIHRyYW5zYWN0aW9ucyBieVxuICogdGhlIHByaW9yaXR5IGZlZS4gSXQgd2lsbCB0aGVuIGdvIHRocm91Z2ggZWFjaCB0cmFuc2FjdGlvbiBhbmQgYWRkIHRoZSB0b3RhbCBhbW91bnQgb2YgZ2FzIHBhaWRcbiAqIGZvciB0aGF0IHRyYW5zYWN0aW9uIHRvIGEgYnVja2V0IHdoaWNoIG1heGVzIG91dCBhdCB0aGUgdG90YWwgZ2FzIHVzZWQgZm9yIHRoZSB3aG9sZSBibG9jay4gQXNcbiAqIHRoZSBidWNrZXQgZmlsbHMsIGl0IHdpbGwgY3Jvc3MgcGVyY2VudGFnZXMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgcGVyY2VudGlsZXMgc3BlY2lmaWVkIGhlcmUsXG4gKiBhbmQgdGhlIHByaW9yaXR5IGZlZXMgb2YgdGhlIGZpcnN0IHRyYW5zYWN0aW9ucyB3aGljaCBjYXVzZSBpdCB0byByZWFjaCB0aG9zZSBwZXJjZW50YWdlcyB3aWxsIGJlXG4gKiByZWNvcmRlZC4gSGVuY2UsIGBwcmlvcml0eUZlZXNCeVBlcmNlbnRpbGVgIHJlcHJlc2VudHMgdGhlIHByaW9yaXR5IGZlZXMgb2YgdHJhbnNhY3Rpb25zIGF0IGtleVxuICogZ2FzIHVzZWQgY29udHJpYnV0aW9uIGxldmVscywgd2hlcmUgZWFybGllciBsZXZlbHMgaGF2ZSBzbWFsbGVyIGNvbnRyaWJ1dGlvbnMgYW5kIGxhdGVyIGxldmVsc1xuICogaGF2ZSBoaWdoZXIgY29udHJpYnV0aW9ucy5cbiAqIEBwYXJhbSBhcmdzLmluY2x1ZGVOZXh0QmxvY2sgLSBXaGV0aGVyIHRvIGluY2x1ZGUgYW4gZXh0cmEgYmxvY2sgdGhhdCByZXByZXNlbnRzIHRoZSBuZXh0XG4gKiBibG9jayBhZnRlciB0aGUgbGF0ZXN0IG9uZS4gT25seSB0aGUgYGJhc2VGZWVQZXJHYXNgIHdpbGwgYmUgZmlsbGVkIGluIGZvciB0aGlzIGJsb2NrICh3aGljaCBpc1xuICogZXN0aW1hdGVkKS5cbiAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIGJsb2NrcyBhbmQgdGhlaXIgZmVlIGRhdGEsIHNvcnRlZCBmcm9tIG9sZGVzdCB0byBuZXdlc3QuXG4gKi9cbmZ1bmN0aW9uIGZldGNoQmxvY2tGZWVIaXN0b3J5KHsgZXRoUXVlcnksIG51bWJlck9mQmxvY2tzOiB0b3RhbE51bWJlck9mQmxvY2tzLCBlbmRCbG9jazogZ2l2ZW5FbmRCbG9jayA9ICdsYXRlc3QnLCBwZXJjZW50aWxlczogZ2l2ZW5QZXJjZW50aWxlcyA9IFtdLCBpbmNsdWRlTmV4dEJsb2NrID0gZmFsc2UsIH0pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwZXJjZW50aWxlcyA9IGdpdmVuUGVyY2VudGlsZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBBcnJheS5mcm9tKG5ldyBTZXQoZ2l2ZW5QZXJjZW50aWxlcykpLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3QgZmluYWxFbmRCbG9ja051bWJlciA9IGdpdmVuRW5kQmxvY2sgPT09ICdsYXRlc3QnXG4gICAgICAgICAgICA/ICgwLCBjb250cm9sbGVyX3V0aWxzXzEuZnJvbUhleCkoeWllbGQgKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS5xdWVyeSkoZXRoUXVlcnksICdibG9ja051bWJlcicpKVxuICAgICAgICAgICAgOiBnaXZlbkVuZEJsb2NrO1xuICAgICAgICBjb25zdCByZXF1ZXN0Q2h1bmtTcGVjaWZpZXJzID0gZGV0ZXJtaW5lUmVxdWVzdENodW5rU3BlY2lmaWVycyhmaW5hbEVuZEJsb2NrTnVtYmVyLCB0b3RhbE51bWJlck9mQmxvY2tzKTtcbiAgICAgICAgY29uc3QgYmxvY2tDaHVua3MgPSB5aWVsZCBQcm9taXNlLmFsbChyZXF1ZXN0Q2h1bmtTcGVjaWZpZXJzLm1hcCgoeyBudW1iZXJPZkJsb2NrcywgZW5kQmxvY2tOdW1iZXIgfSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGkgPT09IHJlcXVlc3RDaHVua1NwZWNpZmllcnMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgID8gbWFrZVJlcXVlc3RGb3JDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGV0aFF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkJsb2NrcyxcbiAgICAgICAgICAgICAgICAgICAgZW5kQmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnRpbGVzLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlTmV4dEJsb2NrLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgOiBtYWtlUmVxdWVzdEZvckNodW5rKHtcbiAgICAgICAgICAgICAgICAgICAgZXRoUXVlcnksXG4gICAgICAgICAgICAgICAgICAgIG51bWJlck9mQmxvY2tzLFxuICAgICAgICAgICAgICAgICAgICBlbmRCbG9ja051bWJlcixcbiAgICAgICAgICAgICAgICAgICAgcGVyY2VudGlsZXMsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1ZGVOZXh0QmxvY2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBibG9ja0NodW5rcy5yZWR1Y2UoKGFycmF5LCBibG9ja3MpID0+IFsuLi5hcnJheSwgLi4uYmxvY2tzXSwgW10pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZmV0Y2hCbG9ja0ZlZUhpc3Rvcnk7XG4vKipcbiAqIEJ1aWxkcyBhbiBFeGlzdGluZ0ZlZUhpc3RvcnlCbG9jay5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmdzIHRvIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0gYXJncy5udW1iZXIgLSBUaGUgbnVtYmVyIG9mIHRoZSBibG9jay5cbiAqIEBwYXJhbSBhcmdzLmJhc2VGZWVQZXJHYXMgLSBUaGUgYmFzZSBmZWUgcGVyIGdhcyBvZiB0aGUgYmxvY2suXG4gKiBAcGFyYW0gYXJncy5ibG9ja0luZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBibG9jayBpbiB0aGUgc291cmNlIGNodW5rLlxuICogQHBhcmFtIGFyZ3MuZ2FzVXNlZFJhdGlvcyAtIFRoZSBnYXMgdXNlZCByYXRpb3MgZm9yIHRoZSBibG9jay5cbiAqIEBwYXJhbSBhcmdzLnByaW9yaXR5RmVlUGVyY2VudGlsZUdyb3VwcyAtIFRoZSBwcmlvcml0eSBmZWUgcGVyY2VudGlsZSBncm91cHMgZm9yIHRoZSBibG9jay5cbiAqIEBwYXJhbSBhcmdzLnBlcmNlbnRpbGVzIC0gVGhlIHBlcmNlbnRpbGVzIHVzZWQgdG8gZmV0Y2ggdGhlIHNvdXJjZSBjaHVuay5cbiAqIEByZXR1cm5zIFRoZSBFeGlzdGluZ0ZlZUhpc3RvcnlCbG9jay5cbiAqL1xuZnVuY3Rpb24gYnVpbGRFeGlzdGluZ0ZlZUhpc3RvcnlCbG9jayh7IGJhc2VGZWVQZXJHYXMsIG51bWJlciwgYmxvY2tJbmRleCwgZ2FzVXNlZFJhdGlvcywgcHJpb3JpdHlGZWVQZXJjZW50aWxlR3JvdXBzLCBwZXJjZW50aWxlcywgfSkge1xuICAgIGNvbnN0IGdhc1VzZWRSYXRpbyA9IGdhc1VzZWRSYXRpb3NbYmxvY2tJbmRleF07XG4gICAgY29uc3QgcHJpb3JpdHlGZWVzRm9yRWFjaFBlcmNlbnRpbGUgPSBwcmlvcml0eUZlZVBlcmNlbnRpbGVHcm91cHNbYmxvY2tJbmRleF07XG4gICAgY29uc3QgcHJpb3JpdHlGZWVzQnlQZXJjZW50aWxlID0gcGVyY2VudGlsZXMucmVkdWNlKChvYmosIHBlcmNlbnRpbGUsIHBlcmNlbnRpbGVJbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwcmlvcml0eUZlZSA9IHByaW9yaXR5RmVlc0ZvckVhY2hQZXJjZW50aWxlW3BlcmNlbnRpbGVJbmRleF07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9iaiksIHsgW3BlcmNlbnRpbGVdOiAoMCwgY29udHJvbGxlcl91dGlsc18xLmZyb21IZXgpKHByaW9yaXR5RmVlKSB9KTtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbnVtYmVyLFxuICAgICAgICBiYXNlRmVlUGVyR2FzLFxuICAgICAgICBnYXNVc2VkUmF0aW8sXG4gICAgICAgIHByaW9yaXR5RmVlc0J5UGVyY2VudGlsZSxcbiAgICB9O1xufVxuLyoqXG4gKiBCdWlsZHMgYSBOZXh0RmVlSGlzdG9yeUJsb2NrLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3MgdG8gdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSBhcmdzLmJhc2VGZWVQZXJHYXMgLSBUaGUgYmFzZSBmZWUgcGVyIGdhcyBvZiB0aGUgYmxvY2suXG4gKiBAcGFyYW0gYXJncy5udW1iZXIgLSBUaGUgbnVtYmVyIG9mIHRoZSBibG9jay5cbiAqIEByZXR1cm5zIFRoZSBOZXh0RmVlSGlzdG9yeUJsb2NrLlxuICovXG5mdW5jdGlvbiBidWlsZE5leHRGZWVIaXN0b3J5QmxvY2soeyBiYXNlRmVlUGVyR2FzLCBudW1iZXIsIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBudW1iZXIsXG4gICAgICAgIGJhc2VGZWVQZXJHYXMsXG4gICAgICAgIGdhc1VzZWRSYXRpbzogbnVsbCxcbiAgICAgICAgcHJpb3JpdHlGZWVzQnlQZXJjZW50aWxlOiBudWxsLFxuICAgIH07XG59XG4vKipcbiAqIFVzZXMgZXRoX2ZlZUhpc3RvcnkgdG8gcmVxdWVzdCBoaXN0b3JpY2FsIGRhdGEgYWJvdXQgYSBncm91cCBvZiBibG9ja3MgKG1heCBzaXplIDEwMjQpLlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50c1xuICogQHBhcmFtIGFyZ3MuZXRoUXVlcnkgLSBBbiBFdGhRdWVyeSBpbnN0YW5jZS5cbiAqIEBwYXJhbSBhcmdzLm51bWJlck9mQmxvY2tzIC0gVGhlIG51bWJlciBvZiBibG9ja3MgaW4gdGhlIGNodW5rLiBNdXN0IGJlIGF0IG1vc3QgMTAyNCwgYXMgdGhpcyBpc1xuICogdGhlIG1heGltdW0gdGhhdCBgZXRoX2ZlZUhpc3RvcnlgIGNhbiByZXR1cm4gaW4gb25lIGNhbGwuXG4gKiBAcGFyYW0gYXJncy5lbmRCbG9ja051bWJlciAtIFRoZSBlbmQgb2YgdGhlIHJlcXVlc3RlZCBibG9jayByYW5nZS5cbiAqIEBwYXJhbSBhcmdzLnBlcmNlbnRpbGVzIC0gQSBzZXQgb2YgbnVtYmVycyBiZXR3ZWVuIDEgYW5kIDEwMCB0aGF0IHdpbGwgYmUgdXNlZCB0byBwdWxsIHByaW9yaXR5XG4gKiBmZWVzIGZvciBlYWNoIGJsb2NrLlxuICogQHBhcmFtIGFyZ3MuaW5jbHVkZU5leHRCbG9jayAtIFdoZXRoZXIgdG8gaW5jbHVkZSBhbiBleHRyYSBibG9jayB0aGF0IHJlcHJlc2VudHMgdGhlIG5leHRcbiAqIGJsb2NrIGFmdGVyIHRoZSBsYXRlc3Qgb25lLiBPbmx5IHRoZSBgYmFzZUZlZVBlckdhc2Agd2lsbCBiZSBmaWxsZWQgaW4gZm9yIHRoaXMgYmxvY2sgKHdoaWNoIGlzXG4gKiBlc3RpbWF0ZWQpLlxuICogQHJldHVybnMgQSBsaXN0IG9mIGJsb2NrIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Rm9yQ2h1bmsoeyBldGhRdWVyeSwgbnVtYmVyT2ZCbG9ja3MsIGVuZEJsb2NrTnVtYmVyLCBwZXJjZW50aWxlcywgaW5jbHVkZU5leHRCbG9jaywgfSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkICgwLCBjb250cm9sbGVyX3V0aWxzXzEucXVlcnkpKGV0aFF1ZXJ5LCAnZXRoX2ZlZUhpc3RvcnknLCBbKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS50b0hleCkobnVtYmVyT2ZCbG9ja3MpLCAoMCwgY29udHJvbGxlcl91dGlsc18xLnRvSGV4KShlbmRCbG9ja051bWJlciksIHBlcmNlbnRpbGVzXSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0QmxvY2tOdW1iZXIgPSAoMCwgY29udHJvbGxlcl91dGlsc18xLmZyb21IZXgpKHJlc3BvbnNlLm9sZGVzdEJsb2NrKTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmJhc2VGZWVQZXJHYXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcmVzcG9uc2UuYmFzZUZlZVBlckdhcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICByZXNwb25zZS5nYXNVc2VkUmF0aW8ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgKHJlc3BvbnNlLnJld2FyZCA9PT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLnJld2FyZC5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgLy8gUGVyXG4gICAgICAgICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2Jsb2IvNTdhM2ZhYjhhNzVlZWI5YzJmNGZhYjc3MGI3M2I1MWI5ZmU2NzJjNS9ldGgvZ2FzcHJpY2UvZmVlaGlzdG9yeS5nbyNMMTkxLUwxOTI+LFxuICAgICAgICAgICAgLy8gYmFzZUZlZVBlckdhcyB3aWxsIGFsd2F5cyBpbmNsdWRlIGFuIGV4dHJhIGl0ZW0gd2hpY2ggaXMgdGhlIGNhbGN1bGF0ZWQgYmFzZSBmZWUgZm9yIHRoZVxuICAgICAgICAgICAgLy8gbmV4dCAoZnV0dXJlKSBibG9jay4gV2UgbWF5IG9yIG1heSBub3QgY2FyZSBhYm91dCB0aGlzOyBpZiB3ZSBkb24ndCwgY2hvcCBpdCBvZmYuXG4gICAgICAgICAgICBjb25zdCBiYXNlRmVlc1Blckdhc0FzSGV4ID0gaW5jbHVkZU5leHRCbG9ja1xuICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuYmFzZUZlZVBlckdhc1xuICAgICAgICAgICAgICAgIDogcmVzcG9uc2UuYmFzZUZlZVBlckdhcy5zbGljZSgwLCBudW1iZXJPZkJsb2Nrcyk7XG4gICAgICAgICAgICBjb25zdCBnYXNVc2VkUmF0aW9zID0gcmVzcG9uc2UuZ2FzVXNlZFJhdGlvO1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlGZWVQZXJjZW50aWxlR3JvdXBzID0gKF9hID0gcmVzcG9uc2UucmV3YXJkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgICAgIC8vIENoYWluIGlzIGFsbG93ZWQgdG8gcmV0dXJuIGZld2VyIG51bWJlciBvZiBibG9jayByZXN1bHRzXG4gICAgICAgICAgICBjb25zdCBudW1iZXJPZkV4aXN0aW5nUmVzdWx0cyA9IGdhc1VzZWRSYXRpb3MubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VGZWVzUGVyR2FzQXNIZXgubWFwKChiYXNlRmVlUGVyR2FzQXNIZXgsIGJsb2NrSW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlRmVlUGVyR2FzID0gKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS5mcm9tSGV4KShiYXNlRmVlUGVyR2FzQXNIZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlciA9IHN0YXJ0QmxvY2tOdW1iZXIuYWRkbihibG9ja0luZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tJbmRleCA+PSBudW1iZXJPZkV4aXN0aW5nUmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICA/IGJ1aWxkTmV4dEZlZUhpc3RvcnlCbG9jayh7IGJhc2VGZWVQZXJHYXMsIG51bWJlciB9KVxuICAgICAgICAgICAgICAgICAgICA6IGJ1aWxkRXhpc3RpbmdGZWVIaXN0b3J5QmxvY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZUZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNVc2VkUmF0aW9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlGZWVQZXJjZW50aWxlR3JvdXBzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyY2VudGlsZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0pO1xufVxuLyoqXG4gKiBEaXZpZGVzIGEgYmxvY2sgcmFuZ2UgKHNwZWNpZmllZCBieSBhIHJhbmdlIHNpemUgYW5kIHRoZSBlbmQgb2YgdGhlIHJhbmdlKSBpbnRvIGNodW5rcyBiYXNlZCBvblxuICogdGhlIG1heGltdW0gbnVtYmVyIG9mIGJsb2NrcyB0aGF0IGBldGhfZmVlSGlzdG9yeWAgY2FuIHJldHVybiBpbiBhIHNpbmdsZSBjYWxsLlxuICpcbiAqIElmIHRoZSByZXF1ZXN0ZWQgdG90YWxOdW1iZXJPZkJsb2NrcyBleGNlZWQgZW5kQmxvY2tOdW1iZXIsIHRvdGFsTnVtYmVyT2ZCbG9ja3MgaXNcbiAqIHRydW5jYXRlZCB0byBhdm9pZCByZXF1ZXN0aW5nIGNodW5rcyB3aXRoIG5lZ2F0aXZlIGVuZEJsb2NrTnVtYmVyLlxuICpcbiAqIEBwYXJhbSBlbmRCbG9ja051bWJlciAtIFRoZSBmaW5hbCBibG9jayBpbiB0aGUgY29tcGxldGUgZGVzaXJlZCBibG9jayByYW5nZSBhZnRlciBhbGxcbiAqIGBldGhfZmVlSGlzdG9yeWAgcmVxdWVzdHMgaGF2ZSBiZWVuIG1hZGUuXG4gKiBAcGFyYW0gdG90YWxOdW1iZXJPZkJsb2NrcyAtIFRoZSB0b3RhbCBudW1iZXIgb2YgZGVzaXJlZCBibG9ja3MgYWZ0ZXIgYWxsIGBldGhfZmVlSGlzdG9yeWBcbiAqIHJlcXVlc3RzIGhhdmUgYmVlbiBtYWRlLlxuICogQHJldHVybnMgQSBzZXQgb2YgYXJndW1lbnRzIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSByZXF1ZXN0cyB0byBgZXRoX2ZlZUhpc3RvcnlgIGluIG9yZGVyIHRvXG4gKiByZXRyaWV2ZSBhbGwgb2YgdGhlIHJlcXVlc3RlZCBibG9ja3MsIHNvcnRlZCBmcm9tIG9sZGVzdCBibG9jayB0byBuZXdlc3QgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZVJlcXVlc3RDaHVua1NwZWNpZmllcnMoZW5kQmxvY2tOdW1iZXIsIHRvdGFsTnVtYmVyT2ZCbG9ja3MpIHtcbiAgICBpZiAoZW5kQmxvY2tOdW1iZXIubHQobmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHRvdGFsTnVtYmVyT2ZCbG9ja3MpKSkge1xuICAgICAgICB0b3RhbE51bWJlck9mQmxvY2tzID0gZW5kQmxvY2tOdW1iZXIudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWVycyA9IFtdO1xuICAgIGZvciAobGV0IGNodW5rU3RhcnRCbG9ja051bWJlciA9IGVuZEJsb2NrTnVtYmVyLnN1Ym4odG90YWxOdW1iZXJPZkJsb2Nrcyk7IGNodW5rU3RhcnRCbG9ja051bWJlci5sdChlbmRCbG9ja051bWJlcik7IGNodW5rU3RhcnRCbG9ja051bWJlciA9IGNodW5rU3RhcnRCbG9ja051bWJlci5hZGRuKE1BWF9OVU1CRVJfT0ZfQkxPQ0tTX1BFUl9FVEhfRkVFX0hJU1RPUllfQ0FMTCkpIHtcbiAgICAgICAgY29uc3QgZGlzdGFuY2VUb0VuZCA9IGVuZEJsb2NrTnVtYmVyLnN1YihjaHVua1N0YXJ0QmxvY2tOdW1iZXIpLnRvTnVtYmVyKCk7XG4gICAgICAgIGNvbnN0IG51bWJlck9mQmxvY2tzID0gZGlzdGFuY2VUb0VuZCA8IE1BWF9OVU1CRVJfT0ZfQkxPQ0tTX1BFUl9FVEhfRkVFX0hJU1RPUllfQ0FMTFxuICAgICAgICAgICAgPyBkaXN0YW5jZVRvRW5kXG4gICAgICAgICAgICA6IE1BWF9OVU1CRVJfT0ZfQkxPQ0tTX1BFUl9FVEhfRkVFX0hJU1RPUllfQ0FMTDtcbiAgICAgICAgY29uc3QgY2h1bmtFbmRCbG9ja051bWJlciA9IGNodW5rU3RhcnRCbG9ja051bWJlci5hZGRuKG51bWJlck9mQmxvY2tzKTtcbiAgICAgICAgc3BlY2lmaWVycy5wdXNoKHsgbnVtYmVyT2ZCbG9ja3MsIGVuZEJsb2NrTnVtYmVyOiBjaHVua0VuZEJsb2NrTnVtYmVyIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc3BlY2lmaWVycztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoQmxvY2tGZWVIaXN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBldGhqc191bml0XzEgPSByZXF1aXJlKFwiZXRoanMtdW5pdFwiKTtcbmNvbnN0IGNvbnRyb2xsZXJfdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svY29udHJvbGxlci11dGlsc1wiKTtcbmNvbnN0IGZldGNoQmxvY2tGZWVIaXN0b3J5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZmV0Y2hCbG9ja0ZlZUhpc3RvcnlcIikpO1xuY29uc3QgZmV0Y2hMYXRlc3RCbG9ja18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeS9mZXRjaExhdGVzdEJsb2NrXCIpKTtcbmNvbnN0IGNhbGN1bGF0ZUdhc0ZlZUVzdGltYXRlc0ZvclByaW9yaXR5TGV2ZWxzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5L2NhbGN1bGF0ZUdhc0ZlZUVzdGltYXRlc0ZvclByaW9yaXR5TGV2ZWxzXCIpKTtcbi8qKlxuICogR2VuZXJhdGVzIGdhcyBmZWUgZXN0aW1hdGVzIGJhc2VkIG9uIGdhcyBmZWVzIHRoYXQgaGF2ZSBiZWVuIHVzZWQgaW4gdGhlIHJlY2VudCBwYXN0IHNvIHRoYXRcbiAqIHRob3NlIGVzdGltYXRlcyBjYW4gYmUgZGlzcGxheWVkIHRvIHVzZXJzLlxuICpcbiAqIFRvIHByb2R1Y2UgdGhlIGVzdGltYXRlcywgdGhlIGxhc3QgNSBibG9ja3MgYXJlIHJlYWQgZnJvbSB0aGUgbmV0d29yaywgYW5kIGZvciBlYWNoIGJsb2NrLCB0aGVcbiAqIHByaW9yaXR5IGZlZXMgZm9yIHRyYW5zYWN0aW9ucyBhdCB0aGUgMTB0aCwgMjB0aCwgYW5kIDMwdGggcGVyY2VudGlsZXMgYXJlIGFsc28gcmVhZCAoaGVyZVxuICogXCJwZXJjZW50aWxlXCIgc2lnbmlmaWVzIHRoZSBsZXZlbCBhdCB3aGljaCB0aG9zZSB0cmFuc2FjdGlvbnMgY29udHJpYnV0ZSB0byB0aGUgb3ZlcmFsbCBnYXMgdXNlZFxuICogZm9yIHRoZSBibG9jaywgd2hlcmUgaGlnaGVyIHBlcmNlbnRpbGVzIGNvcnJlc3BvbmQgdG8gaGlnaGVyIGZlZXMpLiBUaGlzIGluZm9ybWF0aW9uIGlzIHVzZWQgdG9cbiAqIGNhbGN1bGF0ZSByZWFzb25hYmxlIG1heCBwcmlvcml0eSBhbmQgbWF4IGZlZXMgZm9yIHRocmVlIGRpZmZlcmVudCBwcmlvcml0eSBsZXZlbHMgKGhpZ2hlclxuICogcHJpb3JpdHkgPSBoaWdoZXIgZmVlKS5cbiAqXG4gKiBOb3RlIHRoYXQgcHJvcGVydGllcyBhcmUgcmV0dXJuZWQgZm9yIG90aGVyIGRhdGEgdGhhdCBhcmUgbm9ybWFsbHkgb2J0YWluZWQgdmlhIHRoZSBBUEk7IGhvd2V2ZXIsXG4gKiB0byBwcmV2ZW50IGV4dHJhIHJlcXVlc3RzIHRvIEluZnVyYSwgdGhlc2UgcHJvcGVydGllcyBhcmUgZW1wdHkuXG4gKlxuICogQHBhcmFtIGV0aFF1ZXJ5IC0gQW4gRXRoUXVlcnkgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyBCYXNlIGFuZCBwcmlvcml0eSBmZWUgZXN0aW1hdGVzLCBjYXRlZ29yaXplZCBieSBwcmlvcml0eSBsZXZlbCwgYXMgd2VsbCBhcyBhbiBlc3RpbWF0ZVxuICogZm9yIHRoZSBuZXh0IGJsb2NrJ3MgYmFzZSBmZWUuXG4gKi9cbmZ1bmN0aW9uIGZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeShldGhRdWVyeSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NrID0geWllbGQgKDAsIGZldGNoTGF0ZXN0QmxvY2tfMS5kZWZhdWx0KShldGhRdWVyeSk7XG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IHlpZWxkICgwLCBmZXRjaEJsb2NrRmVlSGlzdG9yeV8xLmRlZmF1bHQpKHtcbiAgICAgICAgICAgIGV0aFF1ZXJ5LFxuICAgICAgICAgICAgZW5kQmxvY2s6IGxhdGVzdEJsb2NrLm51bWJlcixcbiAgICAgICAgICAgIG51bWJlck9mQmxvY2tzOiA1LFxuICAgICAgICAgICAgcGVyY2VudGlsZXM6IFsxMCwgMjAsIDMwXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVzdGltYXRlZEJhc2VGZWUgPSAoMCwgZXRoanNfdW5pdF8xLmZyb21XZWkpKGxhdGVzdEJsb2NrLmJhc2VGZWVQZXJHYXMsIGNvbnRyb2xsZXJfdXRpbHNfMS5HV0VJKTtcbiAgICAgICAgY29uc3QgbGV2ZWxTcGVjaWZpY0VzdGltYXRlcyA9ICgwLCBjYWxjdWxhdGVHYXNGZWVFc3RpbWF0ZXNGb3JQcmlvcml0eUxldmVsc18xLmRlZmF1bHQpKGJsb2Nrcyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxldmVsU3BlY2lmaWNFc3RpbWF0ZXMpLCB7IGVzdGltYXRlZEJhc2VGZWUsIGhpc3RvcmljYWxCYXNlRmVlUmFuZ2U6IG51bGwsIGJhc2VGZWVUcmVuZDogbnVsbCwgbGF0ZXN0UHJpb3JpdHlGZWVSYW5nZTogbnVsbCwgaGlzdG9yaWNhbFByaW9yaXR5RmVlUmFuZ2U6IG51bGwsIHByaW9yaXR5RmVlVHJlbmQ6IG51bGwsIG5ldHdvcmtDb25nZXN0aW9uOiBudWxsIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuY29uc3QgZXRoanNfdW5pdF8xID0gcmVxdWlyZShcImV0aGpzLXVuaXRcIik7XG5jb25zdCBjb250cm9sbGVyX3V0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2NvbnRyb2xsZXItdXRpbHNcIik7XG5jb25zdCBtZWRpYW5PZl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21lZGlhbk9mXCIpKTtcbmNvbnN0IFBSSU9SSVRZX0xFVkVMUyA9IFsnbG93JywgJ21lZGl1bScsICdoaWdoJ107XG5jb25zdCBQUklPUklUWV9MRVZFTF9QRVJDRU5USUxFUyA9IFsxMCwgMjAsIDMwXTtcbmNvbnN0IFNFVFRJTkdTX0JZX1BSSU9SSVRZX0xFVkVMID0ge1xuICAgIGxvdzoge1xuICAgICAgICBwZXJjZW50aWxlOiAxMCxcbiAgICAgICAgYmFzZUZlZVBlcmNlbnRhZ2VNdWx0aXBsaWVyOiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oMTEwKSxcbiAgICAgICAgcHJpb3JpdHlGZWVQZXJjZW50YWdlTXVsdGlwbGllcjogbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKDk0KSxcbiAgICAgICAgbWluU3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXM6IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigxMDAwMDAwMDAwKSxcbiAgICAgICAgZXN0aW1hdGVkV2FpdFRpbWVzOiB7XG4gICAgICAgICAgICBtaW5XYWl0VGltZUVzdGltYXRlOiAxNTAwMCxcbiAgICAgICAgICAgIG1heFdhaXRUaW1lRXN0aW1hdGU6IDMwMDAwLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbWVkaXVtOiB7XG4gICAgICAgIHBlcmNlbnRpbGU6IDIwLFxuICAgICAgICBiYXNlRmVlUGVyY2VudGFnZU11bHRpcGxpZXI6IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigxMjApLFxuICAgICAgICBwcmlvcml0eUZlZVBlcmNlbnRhZ2VNdWx0aXBsaWVyOiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oOTcpLFxuICAgICAgICBtaW5TdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhczogbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKDE1MDAwMDAwMDApLFxuICAgICAgICBlc3RpbWF0ZWRXYWl0VGltZXM6IHtcbiAgICAgICAgICAgIG1pbldhaXRUaW1lRXN0aW1hdGU6IDE1MDAwLFxuICAgICAgICAgICAgbWF4V2FpdFRpbWVFc3RpbWF0ZTogNDUwMDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBoaWdoOiB7XG4gICAgICAgIHBlcmNlbnRpbGU6IDMwLFxuICAgICAgICBiYXNlRmVlUGVyY2VudGFnZU11bHRpcGxpZXI6IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigxMjUpLFxuICAgICAgICBwcmlvcml0eUZlZVBlcmNlbnRhZ2VNdWx0aXBsaWVyOiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oOTgpLFxuICAgICAgICBtaW5TdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhczogbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKDIwMDAwMDAwMDApLFxuICAgICAgICBlc3RpbWF0ZWRXYWl0VGltZXM6IHtcbiAgICAgICAgICAgIG1pbldhaXRUaW1lRXN0aW1hdGU6IDE1MDAwLFxuICAgICAgICAgICAgbWF4V2FpdFRpbWVFc3RpbWF0ZTogNjAwMDAsXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgYSBzZXQgb2YgZXN0aW1hdGVzIGFzc2lnbmVkIHRvIGEgcGFydGljdWxhciBwcmlvcml0eSBsZXZlbCBiYXNlZCBvbiB0aGUgZGF0YSByZXR1cm5lZFxuICogYnkgYGV0aF9mZWVIaXN0b3J5YC5cbiAqXG4gKiBAcGFyYW0gcHJpb3JpdHlMZXZlbCAtIFRoZSBsZXZlbCBvZiBmZWVzIHRoYXQgZGljdGF0ZXMgaG93IHNvb24gYSB0cmFuc2FjdGlvbiBtYXkgZ28gdGhyb3VnaFxuICogKFwibG93XCIsIFwibWVkaXVtXCIsIG9yIFwiaGlnaFwiKS5cbiAqIEBwYXJhbSBibG9ja3MgLSBBIHNldCBvZiBibG9ja3MgYXMgb2J0YWluZWQgZnJvbSB7QGxpbmsgZmV0Y2hCbG9ja0ZlZUhpc3Rvcnl9LlxuICogQHJldHVybnMgVGhlIGVzdGltYXRlcy5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlRXN0aW1hdGVzRm9yUHJpb3JpdHlMZXZlbChwcmlvcml0eUxldmVsLCBibG9ja3MpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IFNFVFRJTkdTX0JZX1BSSU9SSVRZX0xFVkVMW3ByaW9yaXR5TGV2ZWxdO1xuICAgIGNvbnN0IGxhdGVzdEJhc2VGZWVQZXJHYXMgPSBibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdLmJhc2VGZWVQZXJHYXM7XG4gICAgY29uc3QgYWRqdXN0ZWRCYXNlRmVlID0gbGF0ZXN0QmFzZUZlZVBlckdhc1xuICAgICAgICAubXVsKHNldHRpbmdzLmJhc2VGZWVQZXJjZW50YWdlTXVsdGlwbGllcilcbiAgICAgICAgLmRpdm4oMTAwKTtcbiAgICBjb25zdCBwcmlvcml0eUZlZXMgPSBibG9ja3NcbiAgICAgICAgLm1hcCgoYmxvY2spID0+IHtcbiAgICAgICAgcmV0dXJuICdwcmlvcml0eUZlZXNCeVBlcmNlbnRpbGUnIGluIGJsb2NrXG4gICAgICAgICAgICA/IGJsb2NrLnByaW9yaXR5RmVlc0J5UGVyY2VudGlsZVtzZXR0aW5ncy5wZXJjZW50aWxlXVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoZXRoZXJldW1qc191dGlsXzEuQk4uaXNCTik7XG4gICAgY29uc3QgbWVkaWFuUHJpb3JpdHlGZWUgPSAoMCwgbWVkaWFuT2ZfMS5kZWZhdWx0KShwcmlvcml0eUZlZXMpO1xuICAgIGNvbnN0IGFkanVzdGVkUHJpb3JpdHlGZWUgPSBtZWRpYW5Qcmlvcml0eUZlZVxuICAgICAgICAubXVsKHNldHRpbmdzLnByaW9yaXR5RmVlUGVyY2VudGFnZU11bHRpcGxpZXIpXG4gICAgICAgIC5kaXZuKDEwMCk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBldGhlcmV1bWpzX3V0aWxfMS5CTi5tYXgoYWRqdXN0ZWRQcmlvcml0eUZlZSwgc2V0dGluZ3MubWluU3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZVBlckdhcyA9IGFkanVzdGVkQmFzZUZlZS5hZGQoc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzLmVzdGltYXRlZFdhaXRUaW1lcyksIHsgc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXM6ICgwLCBldGhqc191bml0XzEuZnJvbVdlaSkoc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMsIGNvbnRyb2xsZXJfdXRpbHNfMS5HV0VJKSwgc3VnZ2VzdGVkTWF4RmVlUGVyR2FzOiAoMCwgZXRoanNfdW5pdF8xLmZyb21XZWkpKHN1Z2dlc3RlZE1heEZlZVBlckdhcywgY29udHJvbGxlcl91dGlsc18xLkdXRUkpIH0pO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgc2V0IG9mIGVzdGltYXRlcyBzdWl0YWJsZSBmb3IgZGlmZmVyZW50IHByaW9yaXR5IGxldmVscyBiYXNlZCBvbiB0aGUgZGF0YSByZXR1cm5lZFxuICogYnkgYGV0aF9mZWVIaXN0b3J5YC5cbiAqXG4gKiBAcGFyYW0gYmxvY2tzIC0gQSBzZXQgb2YgYmxvY2tzIHBvcHVsYXRlZCB3aXRoIGRhdGEgZm9yIHByaW9yaXR5IGZlZSBwZXJjZW50aWxlcyAxMCwgMjAsIGFuZCAzMCxcbiAqIG9idGFpbmVkIHZpYSB7QGxpbmsgQmxvY2tGZWVIaXN0b3J5RGF0YXNldEZldGNoZXJ9LlxuICogQHJldHVybnMgVGhlIGVzdGltYXRlcy5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlR2FzRmVlRXN0aW1hdGVzRm9yUHJpb3JpdHlMZXZlbHMoYmxvY2tzKSB7XG4gICAgcmV0dXJuIFBSSU9SSVRZX0xFVkVMUy5yZWR1Y2UoKG9iaiwgcHJpb3JpdHlMZXZlbCkgPT4ge1xuICAgICAgICBjb25zdCBnYXNFc3RpbWF0ZXNGb3JQcmlvcml0eUxldmVsID0gY2FsY3VsYXRlRXN0aW1hdGVzRm9yUHJpb3JpdHlMZXZlbChwcmlvcml0eUxldmVsLCBibG9ja3MpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvYmopLCB7IFtwcmlvcml0eUxldmVsXTogZ2FzRXN0aW1hdGVzRm9yUHJpb3JpdHlMZXZlbCB9KTtcbiAgICB9LCB7fSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjYWxjdWxhdGVHYXNGZWVFc3RpbWF0ZXNGb3JQcmlvcml0eUxldmVscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGN1bGF0ZUdhc0ZlZUVzdGltYXRlc0ZvclByaW9yaXR5TGV2ZWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb250cm9sbGVyX3V0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2NvbnRyb2xsZXItdXRpbHNcIik7XG4vKipcbiAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxhdGVzdCBjb21wbGV0ZWQgYmxvY2suXG4gKlxuICogQHBhcmFtIGV0aFF1ZXJ5IC0gQW4gRXRoUXVlcnkgaW5zdGFuY2VcbiAqIEBwYXJhbSBpbmNsdWRlRnVsbFRyYW5zYWN0aW9uRGF0YSAtIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgYWxsIGRhdGEgZm9yIHRyYW5zYWN0aW9ucyBhc1xuICogb3Bwb3NlZCB0byBtZXJlbHkgaGFzaGVzLiBGYWxzZSBieSBkZWZhdWx0LlxuICogQHJldHVybnMgVGhlIGJsb2NrLlxuICovXG5mdW5jdGlvbiBmZXRjaExhdGVzdEJsb2NrKGV0aFF1ZXJ5LCBpbmNsdWRlRnVsbFRyYW5zYWN0aW9uRGF0YSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCAoMCwgY29udHJvbGxlcl91dGlsc18xLnF1ZXJ5KShldGhRdWVyeSwgJ2Jsb2NrTnVtYmVyJyk7XG4gICAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS5xdWVyeSkoZXRoUXVlcnksICdnZXRCbG9ja0J5TnVtYmVyJywgW1xuICAgICAgICAgICAgYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICBpbmNsdWRlRnVsbFRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJsb2NrKSwgeyBudW1iZXI6ICgwLCBjb250cm9sbGVyX3V0aWxzXzEuZnJvbUhleCkoYmxvY2subnVtYmVyKSwgYmFzZUZlZVBlckdhczogKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS5mcm9tSGV4KShibG9jay5iYXNlRmVlUGVyR2FzKSB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoTGF0ZXN0QmxvY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaExhdGVzdEJsb2NrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBGaW5kcyB0aGUgbWVkaWFuIGFtb25nIGEgbGlzdCBvZiBudW1iZXJzLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIGluIHRoZSBNZXRhU3dhcCBBUEksIGFzIHdlIHdhbnQgdG8gaG9sZCB0byB1c2luZyBCTiBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuICpcbiAqIEBwYXJhbSBudW1iZXJzIC0gQSBsaXN0IG9mIG51bWJlcnMsIGFzIEJOcy4gV2lsbCBiZSBzb3J0ZWQgYXV0b21hdGljYWxseSBpZiB1bnNvcnRlZC5cbiAqIEByZXR1cm5zIFRoZSBtZWRpYW4gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBtZWRpYW5PZihudW1iZXJzKSB7XG4gICAgY29uc3Qgc29ydGVkTnVtYmVycyA9IG51bWJlcnMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLmNtcChiKSk7XG4gICAgY29uc3QgbGVuID0gc29ydGVkTnVtYmVycy5sZW5ndGg7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKChsZW4gLSAxKSAvIDIpO1xuICAgIHJldHVybiBzb3J0ZWROdW1iZXJzW2luZGV4XTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG1lZGlhbk9mO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWFuT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FsY3VsYXRlVGltZUVzdGltYXRlID0gZXhwb3J0cy5mZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGUgPSBleHBvcnRzLmZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXMgPSBleHBvcnRzLmZldGNoR2FzRXN0aW1hdGVzID0gZXhwb3J0cy5ub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMgPSB2b2lkIDA7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5jb25zdCBjb250cm9sbGVyX3V0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL2NvbnRyb2xsZXItdXRpbHNcIik7XG5jb25zdCBtYWtlQ2xpZW50SWRIZWFkZXIgPSAoY2xpZW50SWQpID0+ICh7ICdYLUNsaWVudC1JZCc6IGNsaWVudElkIH0pO1xuLyoqXG4gKiBDb252ZXJ0IGEgZGVjaW1hbCBHV0VJIHZhbHVlIHRvIGEgZGVjaW1hbCBzdHJpbmcgcm91bmRlZCB0byB0aGUgbmVhcmVzdCBXRUkuXG4gKlxuICogQHBhcmFtIG4gLSBUaGUgaW5wdXQgR1dFSSBhbW91bnQsIGFzIGEgZGVjaW1hbCBzdHJpbmcgb3IgYSBudW1iZXIuXG4gKiBAcmV0dXJucyBUaGUgZGVjaW1hbCBzdHJpbmcgR1dFSSBhbW91bnQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUdXRUlEZWNpbWFsTnVtYmVycyhuKSB7XG4gICAgY29uc3QgbnVtYmVyQXNXRUlIZXggPSAoMCwgY29udHJvbGxlcl91dGlsc18xLmd3ZWlEZWNUb1dFSUJOKShuKS50b1N0cmluZygxNik7XG4gICAgY29uc3QgbnVtYmVyQXNHV0VJID0gKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS53ZWlIZXhUb0d3ZWlEZWMpKG51bWJlckFzV0VJSGV4KS50b1N0cmluZygxMCk7XG4gICAgcmV0dXJuIG51bWJlckFzR1dFSTtcbn1cbmV4cG9ydHMubm9ybWFsaXplR1dFSURlY2ltYWxOdW1iZXJzID0gbm9ybWFsaXplR1dFSURlY2ltYWxOdW1iZXJzO1xuLyoqXG4gKiBGZXRjaCBnYXMgZXN0aW1hdGVzIGZyb20gdGhlIGdpdmVuIFVSTC5cbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIGdhcyBlc3RpbWF0ZSBVUkwuXG4gKiBAcGFyYW0gY2xpZW50SWQgLSBUaGUgY2xpZW50IElEIHVzZWQgdG8gaWRlbnRpZnkgdG8gdGhlIEFQSSB3aG8gaXMgYXNraW5nIGZvciBlc3RpbWF0ZXMuXG4gKiBAcmV0dXJucyBUaGUgZ2FzIGVzdGltYXRlcy5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hHYXNFc3RpbWF0ZXModXJsLCBjbGllbnRJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGVzdGltYXRlcyA9IHlpZWxkICgwLCBjb250cm9sbGVyX3V0aWxzXzEuaGFuZGxlRmV0Y2gpKHVybCwgY2xpZW50SWQgPyB7IGhlYWRlcnM6IG1ha2VDbGllbnRJZEhlYWRlcihjbGllbnRJZCkgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb3c6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXN0aW1hdGVzLmxvdyksIHsgc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXM6IG5vcm1hbGl6ZUdXRUlEZWNpbWFsTnVtYmVycyhlc3RpbWF0ZXMubG93LnN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzKSwgc3VnZ2VzdGVkTWF4RmVlUGVyR2FzOiBub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMoZXN0aW1hdGVzLmxvdy5zdWdnZXN0ZWRNYXhGZWVQZXJHYXMpIH0pLFxuICAgICAgICAgICAgbWVkaXVtOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVzdGltYXRlcy5tZWRpdW0pLCB7IHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzOiBub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMoZXN0aW1hdGVzLm1lZGl1bS5zdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyksIHN1Z2dlc3RlZE1heEZlZVBlckdhczogbm9ybWFsaXplR1dFSURlY2ltYWxOdW1iZXJzKGVzdGltYXRlcy5tZWRpdW0uc3VnZ2VzdGVkTWF4RmVlUGVyR2FzKSB9KSxcbiAgICAgICAgICAgIGhpZ2g6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXN0aW1hdGVzLmhpZ2gpLCB7IHN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzOiBub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMoZXN0aW1hdGVzLmhpZ2guc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMpLCBzdWdnZXN0ZWRNYXhGZWVQZXJHYXM6IG5vcm1hbGl6ZUdXRUlEZWNpbWFsTnVtYmVycyhlc3RpbWF0ZXMuaGlnaC5zdWdnZXN0ZWRNYXhGZWVQZXJHYXMpIH0pLFxuICAgICAgICAgICAgZXN0aW1hdGVkQmFzZUZlZTogbm9ybWFsaXplR1dFSURlY2ltYWxOdW1iZXJzKGVzdGltYXRlcy5lc3RpbWF0ZWRCYXNlRmVlKSxcbiAgICAgICAgICAgIGhpc3RvcmljYWxCYXNlRmVlUmFuZ2U6IGVzdGltYXRlcy5oaXN0b3JpY2FsQmFzZUZlZVJhbmdlLFxuICAgICAgICAgICAgYmFzZUZlZVRyZW5kOiBlc3RpbWF0ZXMuYmFzZUZlZVRyZW5kLFxuICAgICAgICAgICAgbGF0ZXN0UHJpb3JpdHlGZWVSYW5nZTogZXN0aW1hdGVzLmxhdGVzdFByaW9yaXR5RmVlUmFuZ2UsXG4gICAgICAgICAgICBoaXN0b3JpY2FsUHJpb3JpdHlGZWVSYW5nZTogZXN0aW1hdGVzLmhpc3RvcmljYWxQcmlvcml0eUZlZVJhbmdlLFxuICAgICAgICAgICAgcHJpb3JpdHlGZWVUcmVuZDogZXN0aW1hdGVzLnByaW9yaXR5RmVlVHJlbmQsXG4gICAgICAgICAgICBuZXR3b3JrQ29uZ2VzdGlvbjogZXN0aW1hdGVzLm5ldHdvcmtDb25nZXN0aW9uLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEdhc0VzdGltYXRlcyA9IGZldGNoR2FzRXN0aW1hdGVzO1xuLyoqXG4gKiBIaXQgdGhlIGxlZ2FjeSBNZXRhU3dhcHMgZ2FzUHJpY2VzIGVzdGltYXRlIGFwaSBhbmQgcmV0dXJuIHRoZSBsb3csIG1lZGl1bVxuICogaGlnaCB2YWx1ZXMgZnJvbSB0aGF0IEFQSS5cbiAqXG4gKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBmZXRjaCBnYXMgcHJpY2UgZXN0aW1hdGVzIGZyb20uXG4gKiBAcGFyYW0gY2xpZW50SWQgLSBUaGUgY2xpZW50IElEIHVzZWQgdG8gaWRlbnRpZnkgdG8gdGhlIEFQSSB3aG8gaXMgYXNraW5nIGZvciBlc3RpbWF0ZXMuXG4gKiBAcmV0dXJucyBUaGUgZ2FzIHByaWNlIGVzdGltYXRlcy5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlcyh1cmwsIGNsaWVudElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS5oYW5kbGVGZXRjaCkodXJsLCB7XG4gICAgICAgICAgICByZWZlcnJlcjogdXJsLFxuICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwgKGNsaWVudElkICYmIG1ha2VDbGllbnRJZEhlYWRlcihjbGllbnRJZCkpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb3c6IHJlc3VsdC5TYWZlR2FzUHJpY2UsXG4gICAgICAgICAgICBtZWRpdW06IHJlc3VsdC5Qcm9wb3NlR2FzUHJpY2UsXG4gICAgICAgICAgICBoaWdoOiByZXN1bHQuRmFzdEdhc1ByaWNlLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzID0gZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlcztcbi8qKlxuICogR2V0IGEgZ2FzIHByaWNlIGVzdGltYXRlIGZyb20gdGhlIG5ldHdvcmsgdXNpbmcgdGhlIGBldGhfZ2FzUHJpY2VgIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0gZXRoUXVlcnkgLSBUaGUgRXRoUXVlcnkgaW5zdGFuY2UgdG8gY2FsbCB0aGUgbmV0d29yayB3aXRoLlxuICogQHJldHVybnMgQSBnYXMgcHJpY2UgZXN0aW1hdGUuXG4gKi9cbmZ1bmN0aW9uIGZldGNoRXRoR2FzUHJpY2VFc3RpbWF0ZShldGhRdWVyeSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGdhc1ByaWNlID0geWllbGQgKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS5xdWVyeSkoZXRoUXVlcnksICdnYXNQcmljZScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2FzUHJpY2U6ICgwLCBjb250cm9sbGVyX3V0aWxzXzEud2VpSGV4VG9Hd2VpRGVjKShnYXNQcmljZSkudG9TdHJpbmcoKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlID0gZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlO1xuLyoqXG4gKiBFc3RpbWF0ZSB0aGUgdGltZSBpdCB3aWxsIHRha2UgZm9yIGEgdHJhbnNhY3Rpb24gdG8gYmUgY29uZmlybWVkLlxuICpcbiAqIEBwYXJhbSBtYXhQcmlvcml0eUZlZVBlckdhcyAtIFRoZSBtYXggcHJpb3JpdHkgZmVlIHBlciBnYXMuXG4gKiBAcGFyYW0gbWF4RmVlUGVyR2FzIC0gVGhlIG1heCBmZWUgcGVyIGdhcy5cbiAqIEBwYXJhbSBnYXNGZWVFc3RpbWF0ZXMgLSBUaGUgZ2FzIGZlZSBlc3RpbWF0ZXMuXG4gKiBAcmV0dXJucyBUaGUgZXN0aW1hdGVkIGxvd2VyIGFuZCB1cHBlciBib3VuZHMgZm9yIHdoZW4gdGhpcyB0cmFuc2FjdGlvbiB3aWxsIGJlIGNvbmZpcm1lZC5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlVGltZUVzdGltYXRlKG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMsIGdhc0ZlZUVzdGltYXRlcykge1xuICAgIGNvbnN0IHsgbG93LCBtZWRpdW0sIGhpZ2gsIGVzdGltYXRlZEJhc2VGZWUgfSA9IGdhc0ZlZUVzdGltYXRlcztcbiAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhc0luV0VJID0gKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS5nd2VpRGVjVG9XRUlCTikobWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGNvbnN0IG1heEZlZVBlckdhc0luV0VJID0gKDAsIGNvbnRyb2xsZXJfdXRpbHNfMS5nd2VpRGVjVG9XRUlCTikobWF4RmVlUGVyR2FzKTtcbiAgICBjb25zdCBlc3RpbWF0ZWRCYXNlRmVlSW5XRUkgPSAoMCwgY29udHJvbGxlcl91dGlsc18xLmd3ZWlEZWNUb1dFSUJOKShlc3RpbWF0ZWRCYXNlRmVlKTtcbiAgICBjb25zdCBlZmZlY3RpdmVNYXhQcmlvcml0eUZlZSA9IGV0aGVyZXVtanNfdXRpbF8xLkJOLm1pbihtYXhQcmlvcml0eUZlZVBlckdhc0luV0VJLCBtYXhGZWVQZXJHYXNJbldFSS5zdWIoZXN0aW1hdGVkQmFzZUZlZUluV0VJKSk7XG4gICAgY29uc3QgbG93TWF4UHJpb3JpdHlGZWVJbldFSSA9ICgwLCBjb250cm9sbGVyX3V0aWxzXzEuZ3dlaURlY1RvV0VJQk4pKGxvdy5zdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgY29uc3QgbWVkaXVtTWF4UHJpb3JpdHlGZWVJbldFSSA9ICgwLCBjb250cm9sbGVyX3V0aWxzXzEuZ3dlaURlY1RvV0VJQk4pKG1lZGl1bS5zdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgY29uc3QgaGlnaE1heFByaW9yaXR5RmVlSW5XRUkgPSAoMCwgY29udHJvbGxlcl91dGlsc18xLmd3ZWlEZWNUb1dFSUJOKShoaWdoLnN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBsZXQgbG93ZXJUaW1lQm91bmQ7XG4gICAgbGV0IHVwcGVyVGltZUJvdW5kO1xuICAgIGlmIChlZmZlY3RpdmVNYXhQcmlvcml0eUZlZS5sdChsb3dNYXhQcmlvcml0eUZlZUluV0VJKSkge1xuICAgICAgICBsb3dlclRpbWVCb3VuZCA9IG51bGw7XG4gICAgICAgIHVwcGVyVGltZUJvdW5kID0gJ3Vua25vd24nO1xuICAgIH1cbiAgICBlbHNlIGlmIChlZmZlY3RpdmVNYXhQcmlvcml0eUZlZS5ndGUobG93TWF4UHJpb3JpdHlGZWVJbldFSSkgJiZcbiAgICAgICAgZWZmZWN0aXZlTWF4UHJpb3JpdHlGZWUubHQobWVkaXVtTWF4UHJpb3JpdHlGZWVJbldFSSkpIHtcbiAgICAgICAgbG93ZXJUaW1lQm91bmQgPSBsb3cubWluV2FpdFRpbWVFc3RpbWF0ZTtcbiAgICAgICAgdXBwZXJUaW1lQm91bmQgPSBsb3cubWF4V2FpdFRpbWVFc3RpbWF0ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWZmZWN0aXZlTWF4UHJpb3JpdHlGZWUuZ3RlKG1lZGl1bU1heFByaW9yaXR5RmVlSW5XRUkpICYmXG4gICAgICAgIGVmZmVjdGl2ZU1heFByaW9yaXR5RmVlLmx0KGhpZ2hNYXhQcmlvcml0eUZlZUluV0VJKSkge1xuICAgICAgICBsb3dlclRpbWVCb3VuZCA9IG1lZGl1bS5taW5XYWl0VGltZUVzdGltYXRlO1xuICAgICAgICB1cHBlclRpbWVCb3VuZCA9IG1lZGl1bS5tYXhXYWl0VGltZUVzdGltYXRlO1xuICAgIH1cbiAgICBlbHNlIGlmIChlZmZlY3RpdmVNYXhQcmlvcml0eUZlZS5lcShoaWdoTWF4UHJpb3JpdHlGZWVJbldFSSkpIHtcbiAgICAgICAgbG93ZXJUaW1lQm91bmQgPSBoaWdoLm1pbldhaXRUaW1lRXN0aW1hdGU7XG4gICAgICAgIHVwcGVyVGltZUJvdW5kID0gaGlnaC5tYXhXYWl0VGltZUVzdGltYXRlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG93ZXJUaW1lQm91bmQgPSAwO1xuICAgICAgICB1cHBlclRpbWVCb3VuZCA9IGhpZ2gubWF4V2FpdFRpbWVFc3RpbWF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG93ZXJUaW1lQm91bmQsXG4gICAgICAgIHVwcGVyVGltZUJvdW5kLFxuICAgIH07XG59XG5leHBvcnRzLmNhbGN1bGF0ZVRpbWVFc3RpbWF0ZSA9IGNhbGN1bGF0ZVRpbWVFc3RpbWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdhcy11dGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vR2FzRmVlQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQklQNDRDb2luVHlwZU5vZGVfbm9kZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QklQNDRBZGRyZXNzS2V5RGVyaXZlciA9IGV4cG9ydHMuZGVyaXZlQklQNDRBZGRyZXNzS2V5ID0gZXhwb3J0cy5CSVA0NENvaW5UeXBlTm9kZSA9IGV4cG9ydHMuQklQXzQ0X0NPSU5fVFlQRV9ERVBUSCA9IHZvaWQgMDtcbmNvbnN0IEJJUDQ0Tm9kZV8xID0gcmVxdWlyZShcIi4vQklQNDROb2RlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBTTElQMTBOb2RlXzEgPSByZXF1aXJlKFwiLi9TTElQMTBOb2RlXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuZXhwb3J0cy5CSVBfNDRfQ09JTl9UWVBFX0RFUFRIID0gMjtcbi8qKlxuICogQSB3cmFwcGVyIG9iamVjdCBmb3IgQklQLTQ0IGBjb2luX3R5cGVgIGtleXMuIGBjb2luX3R5cGVgIGlzIHRoZSBpbmRleFxuICogc3BlY2lmeWluZyB0aGUgcHJvdG9jb2wgZm9yIHdoaWNoIGRlZXBlciBrZXlzIGFyZSBpbnRlbmRlZC4gRm9yIHRoZVxuICogYXV0aG9yaXRhdGl2ZSBsaXN0IG9mIGNvaW4gdHlwZXMsIHBsZWFzZSBzZWVcbiAqIFtTTElQLTQ0XShodHRwczovL2dpdGh1Yi5jb20vc2F0b3NoaWxhYnMvc2xpcHMvYmxvYi9tYXN0ZXIvc2xpcC0wMDQ0Lm1kKS5cbiAqXG4gKiBSZWNhbGwgdGhhdCBhIEJJUC00NCBIRCB0cmVlIHBhdGggY29uc2lzdHMgb2YgdGhlIGZvbGxvd2luZyBub2RlczpcbiAqXG4gKiBgbSAvIDQ0JyAvIGNvaW5fdHlwZScgLyBhY2NvdW50JyAvIGNoYW5nZSAvIGFkZHJlc3NfaW5kZXhgXG4gKlxuICogV2l0aCB0aGUgZm9sbG93aW5nIGRlcHRoczpcbiAqXG4gKiBgMCAvIDEgLyAyIC8gMyAvIDQgLyA1YFxuICpcbiAqL1xuY2xhc3MgQklQNDRDb2luVHlwZU5vZGUge1xuICAgIC8vIENvbnN0cnVjdG9ycyBjYW5ub3QgdXNlIGhhc2ggbmFtZXMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgY29uc3RydWN0b3Iobm9kZSwgY29pbl90eXBlKSB7XG4gICAgICAgIF9CSVA0NENvaW5UeXBlTm9kZV9ub2RlLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9CSVA0NENvaW5UeXBlTm9kZV9ub2RlLCBub2RlLCBcImZcIik7XG4gICAgICAgIHRoaXMuY29pbl90eXBlID0gY29pbl90eXBlO1xuICAgICAgICB0aGlzLnBhdGggPSAoMCwgdXRpbHNfMS5nZXRCSVA0NENvaW5UeXBlUGF0aFN0cmluZykoY29pbl90eXBlKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIEJJUC00NCBgY29pbl90eXBlYCBub2RlLiBgY29pbl90eXBlYCBpcyB0aGUgaW5kZXhcbiAgICAgKiBzcGVjaWZ5aW5nIHRoZSBwcm90b2NvbCBmb3Igd2hpY2ggZGVlcGVyIGtleXMgYXJlIGludGVuZGVkLiBGb3IgdGhlXG4gICAgICogYXV0aG9yaXRhdGl2ZSBsaXN0IG9mIGNvaW4gdHlwZXMsIHBsZWFzZSBzZWVcbiAgICAgKiBbU0xJUC00NF0oaHR0cHM6Ly9naXRodWIuY29tL3NhdG9zaGlsYWJzL3NsaXBzL2Jsb2IvbWFzdGVyL3NsaXAtMDA0NC5tZCkuXG4gICAgICpcbiAgICAgKiBSZWNhbGwgdGhhdCBhIEJJUC00NCBIRCB0cmVlIHBhdGggY29uc2lzdHMgb2YgdGhlIGZvbGxvd2luZyBub2RlczpcbiAgICAgKlxuICAgICAqIGBtIC8gNDQnIC8gY29pbl90eXBlJyAvIGFjY291bnQnIC8gY2hhbmdlIC8gYWRkcmVzc19pbmRleGBcbiAgICAgKlxuICAgICAqIFdpdGggdGhlIGZvbGxvd2luZyBkZXB0aHM6XG4gICAgICpcbiAgICAgKiBgMCAvIDEgLyAyIC8gMyAvIDQgLyA1YFxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb24gLSBUaGUge0BsaW5rIEpzb25CSVA0NE5vZGV9IGZvciB0aGUga2V5IG9mIHRoaXMgbm9kZS5cbiAgICAgKiBAcGFyYW0gY29pbl90eXBlIC0gVGhlIGNvaW5fdHlwZSBpbmRleCBvZiB0aGlzIG5vZGUuIE11c3QgYmUgYSBub24tbmVnYXRpdmVcbiAgICAgKiBpbnRlZ2VyLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tSlNPTihqc29uLCBjb2luX3R5cGUpIHtcbiAgICAgICAgdmFsaWRhdGVDb2luVHlwZShjb2luX3R5cGUpO1xuICAgICAgICB2YWxpZGF0ZUNvaW5UeXBlTm9kZURlcHRoKGpzb24uZGVwdGgpO1xuICAgICAgICBjb25zdCBub2RlID0gYXdhaXQgQklQNDROb2RlXzEuQklQNDROb2RlLmZyb21FeHRlbmRlZEtleSh7XG4gICAgICAgICAgICBkZXB0aDoganNvbi5kZXB0aCxcbiAgICAgICAgICAgIGluZGV4OiBqc29uLmluZGV4LFxuICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQ6IGpzb24ucGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICBjaGFpbkNvZGU6ICgwLCB1dGlsc18xLmhleFN0cmluZ1RvQnl0ZXMpKGpzb24uY2hhaW5Db2RlKSxcbiAgICAgICAgICAgIHByaXZhdGVLZXk6ICgwLCB1dGlsc18xLm51bGxhYmxlSGV4U3RyaW5nVG9CeXRlcykoanNvbi5wcml2YXRlS2V5KSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogKDAsIHV0aWxzXzEuaGV4U3RyaW5nVG9CeXRlcykoanNvbi5wdWJsaWNLZXkpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCSVA0NENvaW5UeXBlTm9kZShub2RlLCBjb2luX3R5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgQklQLTQ0IGBjb2luX3R5cGVgIG5vZGUuIGBjb2luX3R5cGVgIGlzIHRoZSBpbmRleFxuICAgICAqIHNwZWNpZnlpbmcgdGhlIHByb3RvY29sIGZvciB3aGljaCBkZWVwZXIga2V5cyBhcmUgaW50ZW5kZWQuIEZvciB0aGVcbiAgICAgKiBhdXRob3JpdGF0aXZlIGxpc3Qgb2YgY29pbiB0eXBlcywgcGxlYXNlIHNlZVxuICAgICAqIFtTTElQLTQ0XShodHRwczovL2dpdGh1Yi5jb20vc2F0b3NoaWxhYnMvc2xpcHMvYmxvYi9tYXN0ZXIvc2xpcC0wMDQ0Lm1kKS5cbiAgICAgKlxuICAgICAqIFJlY2FsbCB0aGF0IGEgQklQLTQ0IEhEIHRyZWUgcGF0aCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIG5vZGVzOlxuICAgICAqXG4gICAgICogYG0gLyA0NCcgLyBjb2luX3R5cGUnIC8gYWNjb3VudCcgLyBjaGFuZ2UgLyBhZGRyZXNzX2luZGV4YFxuICAgICAqXG4gICAgICogV2l0aCB0aGUgZm9sbG93aW5nIGRlcHRoczpcbiAgICAgKlxuICAgICAqIGAwIC8gMSAvIDIgLyAzIC8gNCAvIDVgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVyaXZhdGlvblBhdGggLSBUaGUgZGVyaXZhdGlvbiBwYXRoIGZvciB0aGUga2V5IG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbURlcml2YXRpb25QYXRoKGRlcml2YXRpb25QYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlQ29pblR5cGVOb2RlRGVwdGgoZGVyaXZhdGlvblBhdGgubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBhd2FpdCBCSVA0NE5vZGVfMS5CSVA0NE5vZGUuZnJvbURlcml2YXRpb25QYXRoKHtcbiAgICAgICAgICAgIGRlcml2YXRpb25QYXRoLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU3BsaXQgdGhlIGJpcDMyIHN0cmluZyB0b2tlbiBhbmQgZXh0cmFjdCB0aGUgY29pbl90eXBlIGluZGV4XG4gICAgICAgIGNvbnN0IGNvaW5UeXBlID0gTnVtYmVyLnBhcnNlSW50KGRlcml2YXRpb25QYXRoW2V4cG9ydHMuQklQXzQ0X0NPSU5fVFlQRV9ERVBUSF0uc3BsaXQoJzonKVsxXS5yZXBsYWNlKGAnYCwgJycpLCAxMCk7XG4gICAgICAgIHJldHVybiBuZXcgQklQNDRDb2luVHlwZU5vZGUobm9kZSwgY29pblR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgQklQLTQ0IGBjb2luX3R5cGVgIG5vZGUuIGBjb2luX3R5cGVgIGlzIHRoZSBpbmRleFxuICAgICAqIHNwZWNpZnlpbmcgdGhlIHByb3RvY29sIGZvciB3aGljaCBkZWVwZXIga2V5cyBhcmUgaW50ZW5kZWQuIEZvciB0aGVcbiAgICAgKiBhdXRob3JpdGF0aXZlIGxpc3Qgb2YgY29pbiB0eXBlcywgcGxlYXNlIHNlZVxuICAgICAqIFtTTElQLTQ0XShodHRwczovL2dpdGh1Yi5jb20vc2F0b3NoaWxhYnMvc2xpcHMvYmxvYi9tYXN0ZXIvc2xpcC0wMDQ0Lm1kKS5cbiAgICAgKlxuICAgICAqIFJlY2FsbCB0aGF0IGEgQklQLTQ0IEhEIHRyZWUgcGF0aCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIG5vZGVzOlxuICAgICAqXG4gICAgICogYG0gLyA0NCcgLyBjb2luX3R5cGUnIC8gYWNjb3VudCcgLyBjaGFuZ2UgLyBhZGRyZXNzX2luZGV4YFxuICAgICAqXG4gICAgICogV2l0aCB0aGUgZm9sbG93aW5nIGRlcHRoczpcbiAgICAgKlxuICAgICAqIGAwIC8gMSAvIDIgLyAzIC8gNCAvIDVgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbm9kZSAtIFRoZSB7QGxpbmsgQklQNDROb2RlfSBmb3IgdGhlIGtleSBvZiB0aGlzIG5vZGUuXG4gICAgICogQHBhcmFtIGNvaW5fdHlwZSAtIFRoZSBjb2luX3R5cGUgaW5kZXggb2YgdGhpcyBub2RlLiBNdXN0IGJlIGEgbm9uLW5lZ2F0aXZlXG4gICAgICogaW50ZWdlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbU5vZGUobm9kZSwgY29pbl90eXBlKSB7XG4gICAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBCSVA0NE5vZGVfMS5CSVA0NE5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbm9kZTogRXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgQklQNDROb2RlLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlQ29pblR5cGUoY29pbl90eXBlKTtcbiAgICAgICAgdmFsaWRhdGVDb2luVHlwZU5vZGVEZXB0aChub2RlLmRlcHRoKTtcbiAgICAgICAgLy8gVE9ETzogTWFrZSB0aGlzIGZ1bmN0aW9uIG5vdCBhc3luYyBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCSVA0NENvaW5UeXBlTm9kZShub2RlLCBjb2luX3R5cGUpKTtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDRDb2luVHlwZU5vZGVfbm9kZSwgXCJmXCIpLmRlcHRoO1xuICAgIH1cbiAgICBnZXQgcHJpdmF0ZUtleUJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDRDb2luVHlwZU5vZGVfbm9kZSwgXCJmXCIpLnByaXZhdGVLZXlCeXRlcztcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleUJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDRDb2luVHlwZU5vZGVfbm9kZSwgXCJmXCIpLnB1YmxpY0tleUJ5dGVzO1xuICAgIH1cbiAgICBnZXQgY2hhaW5Db2RlQnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CSVA0NENvaW5UeXBlTm9kZV9ub2RlLCBcImZcIikuY2hhaW5Db2RlQnl0ZXM7XG4gICAgfVxuICAgIGdldCBwcml2YXRlS2V5KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDRDb2luVHlwZU5vZGVfbm9kZSwgXCJmXCIpLnByaXZhdGVLZXk7XG4gICAgfVxuICAgIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CSVA0NENvaW5UeXBlTm9kZV9ub2RlLCBcImZcIikucHVibGljS2V5O1xuICAgIH1cbiAgICBnZXQgY29tcHJlc3NlZFB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JJUDQ0Q29pblR5cGVOb2RlX25vZGUsIFwiZlwiKS5jb21wcmVzc2VkUHVibGljS2V5O1xuICAgIH1cbiAgICBnZXQgY29tcHJlc3NlZFB1YmxpY0tleUJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDRDb2luVHlwZU5vZGVfbm9kZSwgXCJmXCIpLmNvbXByZXNzZWRQdWJsaWNLZXlCeXRlcztcbiAgICB9XG4gICAgZ2V0IGNoYWluQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JJUDQ0Q29pblR5cGVOb2RlX25vZGUsIFwiZlwiKS5jaGFpbkNvZGU7XG4gICAgfVxuICAgIGdldCBhZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDRDb2luVHlwZU5vZGVfbm9kZSwgXCJmXCIpLmFkZHJlc3M7XG4gICAgfVxuICAgIGdldCBtYXN0ZXJGaW5nZXJwcmludCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JJUDQ0Q29pblR5cGVOb2RlX25vZGUsIFwiZlwiKS5tYXN0ZXJGaW5nZXJwcmludDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudEZpbmdlcnByaW50KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDRDb2luVHlwZU5vZGVfbm9kZSwgXCJmXCIpLnBhcmVudEZpbmdlcnByaW50O1xuICAgIH1cbiAgICBnZXQgZmluZ2VycHJpbnQoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CSVA0NENvaW5UeXBlTm9kZV9ub2RlLCBcImZcIikuZmluZ2VycHJpbnQ7XG4gICAgfVxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JJUDQ0Q29pblR5cGVOb2RlX25vZGUsIFwiZlwiKS5pbmRleDtcbiAgICB9XG4gICAgZ2V0IGN1cnZlKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDRDb2luVHlwZU5vZGVfbm9kZSwgXCJmXCIpLmN1cnZlO1xuICAgIH1cbiAgICBnZXQgZXh0ZW5kZWRLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CSVA0NENvaW5UeXBlTm9kZV9ub2RlLCBcImZcIikuZXh0ZW5kZWRLZXk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcml2ZXMgYSBCSVAtNDQgYGFkZHJlc3NfaW5kZXhgIGtleSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXRoIG9mIHRoaXNcbiAgICAgKiBub2RlIGFuZCB0aGUgc3BlY2lmaWVkIGBhY2NvdW50YCwgYGNoYW5nZWAsIGFuZCBgYWRkcmVzc19pbmRleGAgdmFsdWVzLlxuICAgICAqIGBhZGRyZXNzX2luZGV4YCBrZXlzIGFyZSBub3JtYWxseSB0aGUga2V5cyB1c2VkIHRvIGdlbmVyYXRlIHVzZXIgYWNjb3VudFxuICAgICAqIGFkZHJlc3Nlcy5cbiAgICAgKlxuICAgICAqIFJlY2FsbCB0aGF0IGEgQklQLTQ0IEhEIHRyZWUgcGF0aCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIG5vZGVzOlxuICAgICAqXG4gICAgICogYG0gLyA0NCcgLyBjb2luX3R5cGUnIC8gYWNjb3VudCcgLyBjaGFuZ2UgLyBhZGRyZXNzX2luZGV4YFxuICAgICAqXG4gICAgICogV2l0aCB0aGUgZm9sbG93aW5nIGRlcHRoczpcbiAgICAgKlxuICAgICAqIGAwIC8gMSAvIDIgLyAzIC8gNCAvIDVgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kaWNlcyAtIFRoZSBCSVAtNDQgaW5kZXggdmFsdWVzIHRvIHVzZSBpbiBrZXkgZGVyaXZhdGlvbi5cbiAgICAgKiBAcGFyYW0gaW5kaWNlcy5hY2NvdW50IC0gVGhlIGBhY2NvdW50YCBpbmRleC4gRGVmYXVsdDogYDBgXG4gICAgICogQHBhcmFtIGluZGljZXMuY2hhbmdlIC0gVGhlIGBjaGFuZ2VgIGluZGV4LiBEZWZhdWx0OiBgMGBcbiAgICAgKiBAcGFyYW0gaW5kaWNlcy5hZGRyZXNzX2luZGV4IC0gVGhlIGBhZGRyZXNzX2luZGV4YCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyBUaGUgZGVyaXZlZCBCSVAtNDQgYGFkZHJlc3NfaW5kZXhgIG5vZGUuXG4gICAgICovXG4gICAgYXN5bmMgZGVyaXZlQklQNDRBZGRyZXNzS2V5KHsgYWNjb3VudCA9IDAsIGNoYW5nZSA9IDAsIGFkZHJlc3NfaW5kZXgsIH0pIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JJUDQ0Q29pblR5cGVOb2RlX25vZGUsIFwiZlwiKS5kZXJpdmUoKDAsIHV0aWxzXzEuZ2V0QklQNDRDb2luVHlwZVRvQWRkcmVzc1BhdGhUdXBsZSkoeyBhY2NvdW50LCBjaGFuZ2UsIGFkZHJlc3NfaW5kZXggfSkpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JJUDQ0Q29pblR5cGVOb2RlX25vZGUsIFwiZlwiKS50b0pTT04oKSksIHsgY29pbl90eXBlOiB0aGlzLmNvaW5fdHlwZSwgcGF0aDogdGhpcy5wYXRoIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQklQNDRDb2luVHlwZU5vZGUgPSBCSVA0NENvaW5UeXBlTm9kZTtcbl9CSVA0NENvaW5UeXBlTm9kZV9ub2RlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogVmFsaWRhdGVzIHRoZSBkZXB0aCBvZiBhIGBjb2luX3R5cGVgIG5vZGUuIFNpbXBseSwgZW5zdXJlcyB0aGF0IGl0IGlzIHRoZVxuICogbnVtYmVyIGAyYC4gQW4gZXJyb3IgaXMgdGhyb3duIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogQHBhcmFtIGRlcHRoIC0gVGhlIGRlcHRoIHRvIHZhbGlkYXRlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvaW5UeXBlTm9kZURlcHRoKGRlcHRoKSB7XG4gICAgaWYgKGRlcHRoICE9PSBleHBvcnRzLkJJUF80NF9DT0lOX1RZUEVfREVQVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRlcHRoOiBDb2luIHR5cGUgbm9kZXMgbXVzdCBiZSBvZiBkZXB0aCAke2V4cG9ydHMuQklQXzQ0X0NPSU5fVFlQRV9ERVBUSH0uIFJlY2VpdmVkOiBcIiR7ZGVwdGh9XCJgKTtcbiAgICB9XG59XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSBjb2luIHR5cGUgaXMgYSBub24tbmVnYXRpdmUgaW50ZWdlciBudW1iZXIuIEFuIGVycm9yIGlzXG4gKiB0aHJvd24gaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBAcGFyYW0gY29pbl90eXBlIC0gVGhlIGNvaW4gdHlwZSB0byB2YWxpZGF0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb2luVHlwZShjb2luX3R5cGUpIHtcbiAgICBpZiAodHlwZW9mIGNvaW5fdHlwZSAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgIU51bWJlci5pc0ludGVnZXIoY29pbl90eXBlKSB8fFxuICAgICAgICBjb2luX3R5cGUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2luIHR5cGU6IFRoZSBzcGVjaWZpZWQgY29pbiB0eXBlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBudW1iZXIuJyk7XG4gICAgfVxufVxuLyoqXG4gKiBEZXJpdmVzIGEgQklQLTQ0IGFkZHJlc3Mga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHNwZWNpZmllZCBkZXJpdmF0aW9uIHBhdGgsXG4gKiBnaXZlbiBlaXRoZXIgYnkgYSB7QGxpbmsgQklQNDRDb2luVHlwZU5vZGV9IG9yIGRlcml2YXRpb24gcGF0aCB0dXBsZS5cbiAqXG4gKiBSZWNhbGwgdGhhdCBhIEJJUC00NCBIRCB0cmVlIHBhdGggY29uc2lzdHMgb2YgdGhlIGZvbGxvd2luZyBub2RlczpcbiAqXG4gKiBgbSAvIDQ0JyAvIGNvaW5fdHlwZScgLyBhY2NvdW50JyAvIGNoYW5nZSAvIGFkZHJlc3NfaW5kZXhgXG4gKlxuICogV2l0aCB0aGUgZm9sbG93aW5nIGRlcHRoczpcbiAqXG4gKiBgMCAvIDEgLyAyIC8gMyAvIDQgLyA1YFxuICpcbiAqIEBwYXJhbSBwYXJlbnRLZXlPck5vZGUgLSBUaGUgYGNvaW5fdHlwZWAgcGFyZW50IGtleSB0byBkZXJpdmUgZnJvbS5cbiAqIEBwYXJhbSBpbmRpY2VzIC0gVGhlIEJJUC00NCBpbmRleCB2YWx1ZXMgdG8gdXNlIGluIGtleSBkZXJpdmF0aW9uLlxuICogQHBhcmFtIGluZGljZXMuYWNjb3VudCAtIFRoZSBgYWNjb3VudGAgaW5kZXguIERlZmF1bHQ6IGAwYC5cbiAqIEBwYXJhbSBpbmRpY2VzLmNoYW5nZSAtIFRoZSBgY2hhbmdlYCBpbmRleC4gRGVmYXVsdDogYDBgLlxuICogQHBhcmFtIGluZGljZXMuYWRkcmVzc19pbmRleCAtIFRoZSBgYWRkcmVzc19pbmRleGAgaW5kZXguXG4gKiBAcmV0dXJucyBUaGUgZGVyaXZlZCBgYWRkcmVzc19pbmRleGAga2V5IGZvciB0aGUgc3BlY2lmaWVkIGRlcml2YXRpb24gcGF0aC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVyaXZlQklQNDRBZGRyZXNzS2V5KHBhcmVudEtleU9yTm9kZSwgeyBhY2NvdW50ID0gMCwgY2hhbmdlID0gMCwgYWRkcmVzc19pbmRleCB9KSB7XG4gICAgY29uc3QgcGF0aCA9ICgwLCB1dGlsc18xLmdldEJJUDQ0Q29pblR5cGVUb0FkZHJlc3NQYXRoVHVwbGUpKHtcbiAgICAgICAgYWNjb3VudCxcbiAgICAgICAgY2hhbmdlLFxuICAgICAgICBhZGRyZXNzX2luZGV4LFxuICAgIH0pO1xuICAgIGNvbnN0IG5vZGUgPSBhd2FpdCBnZXROb2RlKHBhcmVudEtleU9yTm9kZSk7XG4gICAgY29uc3QgY2hpbGROb2RlID0gYXdhaXQgKDAsIFNMSVAxME5vZGVfMS5kZXJpdmVDaGlsZE5vZGUpKHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgbm9kZSxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IEJJUDQ0Tm9kZV8xLkJJUDQ0Tm9kZShjaGlsZE5vZGUpO1xufVxuZXhwb3J0cy5kZXJpdmVCSVA0NEFkZHJlc3NLZXkgPSBkZXJpdmVCSVA0NEFkZHJlc3NLZXk7XG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGRlcml2ZXMgQklQLTQ0IGFkZHJlc3Mga2V5cyBjb3JyZXNwb25kaW5nIHRvIHRoZVxuICogc3BlY2lmaWVkIGRlcml2YXRpb24gcGF0aCwgZ2l2ZW4gZWl0aGVyIGJ5IGEge0BsaW5rIEJJUDQ0Q29pblR5cGVOb2RlfSBvclxuICogZGVyaXZhdGlvbiBwYXRoIHR1cGxlLlxuICpcbiAqIFJlY2FsbCB0aGF0IGEgQklQLTQ0IEhEIHRyZWUgcGF0aCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIG5vZGVzOlxuICpcbiAqIGBtIC8gNDQnIC8gY29pbl90eXBlJyAvIGFjY291bnQnIC8gY2hhbmdlIC8gYWRkcmVzc19pbmRleGBcbiAqXG4gKiBXaXRoIHRoZSBmb2xsb3dpbmcgZGVwdGhzOlxuICpcbiAqIGAwIC8gMSAvIDIgLyAzIC8gNCAvIDVgXG4gKlxuICogQHBhcmFtIG5vZGUgLSBUaGUge0BsaW5rIEJJUDQ0Q29pblR5cGVOb2RlfSB0byBkZXJpdmUgYWRkcmVzcyBrZXlzIGZyb20uXG4gKiBUaGlzIG5vZGUgY29udGFpbnMgYSBCSVAtNDQga2V5IG9mIGRlcHRoIDIsIGBjb2luX3R5cGVgLlxuICogQHBhcmFtIGFjY291bnRBbmRDaGFuZ2VJbmRpY2VzIC0gVGhlIGBhY2NvdW50YCBhbmQgYGNoYW5nZWAgaW5kaWNlcyB0aGF0XG4gKiB3aWxsIGJlIHVzZWQgdG8gZGVyaXZlIGFkZHJlc3Nlcy5cbiAqIEByZXR1cm5zIFRoZSBkZXJpdmVyIGZ1bmN0aW9uIGZvciB0aGUgZGVyaXZhdGlvbiBwYXRoIHNwZWNpZmllZCBieSB0aGVcbiAqIGBjb2luX3R5cGVgIG5vZGUsIGBhY2NvdW50YCwgYW5kIGBjaGFuZ2VgIGluZGljZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEJJUDQ0QWRkcmVzc0tleURlcml2ZXIobm9kZSwgYWNjb3VudEFuZENoYW5nZUluZGljZXMpIHtcbiAgICBjb25zdCB7IGFjY291bnQgPSAwLCBjaGFuZ2UgPSAwIH0gPSBhY2NvdW50QW5kQ2hhbmdlSW5kaWNlcyAhPT0gbnVsbCAmJiBhY2NvdW50QW5kQ2hhbmdlSW5kaWNlcyAhPT0gdm9pZCAwID8gYWNjb3VudEFuZENoYW5nZUluZGljZXMgOiB7fTtcbiAgICBjb25zdCBhY3R1YWxOb2RlID0gYXdhaXQgZ2V0Tm9kZShub2RlKTtcbiAgICBjb25zdCBhY2NvdW50Tm9kZSA9ICgwLCB1dGlsc18xLmdldEhhcmRlbmVkQklQMzJOb2RlVG9rZW4pKGFjY291bnQpO1xuICAgIGNvbnN0IGNoYW5nZU5vZGUgPSAoMCwgdXRpbHNfMS5nZXRCSVAzMk5vZGVUb2tlbikoY2hhbmdlKTtcbiAgICBjb25zdCBiaXA0NEFkZHJlc3NLZXlEZXJpdmVyID0gYXN5bmMgKGFkZHJlc3NfaW5kZXgsIGlzSGFyZGVuZWQgPSBmYWxzZSkgPT4ge1xuICAgICAgICBjb25zdCBzbGlwMTBOb2RlID0gYXdhaXQgKDAsIFNMSVAxME5vZGVfMS5kZXJpdmVDaGlsZE5vZGUpKHtcbiAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAgICBhY2NvdW50Tm9kZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VOb2RlLFxuICAgICAgICAgICAgICAgIGlzSGFyZGVuZWRcbiAgICAgICAgICAgICAgICAgICAgPyAoMCwgdXRpbHNfMS5nZXRIYXJkZW5lZEJJUDMyTm9kZVRva2VuKShhZGRyZXNzX2luZGV4KVxuICAgICAgICAgICAgICAgICAgICA6ICgwLCB1dGlsc18xLmdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbikoYWRkcmVzc19pbmRleCksXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgbm9kZTogYWN0dWFsTm9kZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQklQNDROb2RlXzEuQklQNDROb2RlKHNsaXAxME5vZGUpO1xuICAgIH07XG4gICAgYmlwNDRBZGRyZXNzS2V5RGVyaXZlci5jb2luX3R5cGUgPSBhY3R1YWxOb2RlLmNvaW5fdHlwZTtcbiAgICBiaXA0NEFkZHJlc3NLZXlEZXJpdmVyLnBhdGggPSAoMCwgdXRpbHNfMS5nZXRCSVA0NENoYW5nZVBhdGhTdHJpbmcpKGFjdHVhbE5vZGUucGF0aCwge1xuICAgICAgICBhY2NvdW50LFxuICAgICAgICBjaGFuZ2UsXG4gICAgfSk7XG4gICAgT2JqZWN0LmZyZWV6ZShiaXA0NEFkZHJlc3NLZXlEZXJpdmVyKTtcbiAgICByZXR1cm4gYmlwNDRBZGRyZXNzS2V5RGVyaXZlcjtcbn1cbmV4cG9ydHMuZ2V0QklQNDRBZGRyZXNzS2V5RGVyaXZlciA9IGdldEJJUDQ0QWRkcmVzc0tleURlcml2ZXI7XG4vKipcbiAqIEdldCBhIEJJUC00NCBjb2luIHR5cGUgbm9kZSBmcm9tIGEgSlNPTiBub2RlIG9yIGV4dGVuZGVkIGtleSBzdHJpbmcuIElmIGFuIGV4aXN0aW5nIGNvaW4gdHlwZVxuICogbm9kZSBpcyBwcm92aWRlZCwgdGhlIHNhbWUgbm9kZSBpcyByZXR1cm5lZC5cbiAqXG4gKiBUaGUgZGVwdGggb2YgdGhlIG5vZGUgaXMgdmFsaWRhdGVkIHRvIGJlIGEgdmFsaWQgY29pbiB0eXBlIG5vZGUuXG4gKlxuICogQHBhcmFtIG5vZGUgLSBBIEJJUC00NCBjb2luIHR5cGUgbm9kZSwgSlNPTiBub2RlIG9yIGV4dGVuZGVkIGtleS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0Tm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBCSVA0NENvaW5UeXBlTm9kZSkge1xuICAgICAgICB2YWxpZGF0ZUNvaW5UeXBlTm9kZURlcHRoKG5vZGUuZGVwdGgpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBiaXA0NE5vZGUgPSBhd2FpdCBCSVA0NE5vZGVfMS5CSVA0NE5vZGUuZnJvbUV4dGVuZGVkS2V5KG5vZGUpO1xuICAgICAgICBjb25zdCBjb2luVHlwZU5vZGUgPSBhd2FpdCBCSVA0NENvaW5UeXBlTm9kZS5mcm9tTm9kZShiaXA0NE5vZGUsIGJpcDQ0Tm9kZS5pbmRleCAtIGNvbnN0YW50c18xLkJJUF8zMl9IQVJERU5FRF9PRkZTRVQpO1xuICAgICAgICB2YWxpZGF0ZUNvaW5UeXBlTm9kZURlcHRoKGNvaW5UeXBlTm9kZS5kZXB0aCk7XG4gICAgICAgIHJldHVybiBjb2luVHlwZU5vZGU7XG4gICAgfVxuICAgIHJldHVybiBCSVA0NENvaW5UeXBlTm9kZS5mcm9tSlNPTihub2RlLCBub2RlLmNvaW5fdHlwZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CSVA0NENvaW5UeXBlTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfQklQNDROb2RlX25vZGU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlQklQNDREZXB0aCA9IGV4cG9ydHMuQklQNDROb2RlID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGV4dGVuZGVkX2tleXNfMSA9IHJlcXVpcmUoXCIuL2V4dGVuZGVkLWtleXNcIik7XG5jb25zdCBTTElQMTBOb2RlXzEgPSByZXF1aXJlKFwiLi9TTElQMTBOb2RlXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBBIHdyYXBwZXIgZm9yIEJJUC00NCBIaWVyYXJjaGljYWwgRGV0ZXJtaW5pc3RpYyAoSEQpIHRyZWUgbm9kZXMsIGkuZS5cbiAqIGNyeXB0b2dyYXBoaWMga2V5cyB1c2VkIHRvIGdlbmVyYXRlIGtleXBhaXJzIGFuZCBhZGRyZXNzZXMgZm9yIGNyeXB0b2N1cnJlbmN5XG4gKiBwcm90b2NvbHMuXG4gKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBtZXRob2RzIGFuZCBmaWVsZHMgdGhhdCBtYXkgbm90IHNlcmlhbGl6ZSB3ZWxsLiBVc2VcbiAqIHtAbGluayBCSVA0NE5vZGUudG9KU09OfSB0byBnZXQgYSBKU09OLWNvbXBhdGlibGUgcmVwcmVzZW50YXRpb24uXG4gKi9cbmNsYXNzIEJJUDQ0Tm9kZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgICAgICBfQklQNDROb2RlX25vZGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0JJUDQ0Tm9kZV9ub2RlLCBub2RlLCBcImZcIik7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgb2YgdGhlIHtAbGluayBmcm9tRXh0ZW5kZWRLZXl9IGZ1bmN0aW9uLiBSZWZlciB0byB0aGF0IGZ1bmN0aW9uXG4gICAgICogZm9yIGRvY3VtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbiAtIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgU0xJUC0xMCBub2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tSlNPTihqc29uKSB7XG4gICAgICAgIHJldHVybiBCSVA0NE5vZGUuZnJvbUV4dGVuZGVkS2V5KGpzb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQklQLTQ0IG5vZGUgZnJvbSBhIGtleSBhbmQgY2hhaW4gY29kZS4gWW91IG11c3Qgc3BlY2lmeVxuICAgICAqIGVpdGhlciBhIHByaXZhdGUga2V5IG9yIGEgcHVibGljIGtleS4gV2hlbiBzcGVjaWZ5aW5nIGEgcHJpdmF0ZSBrZXksXG4gICAgICogdGhlIHB1YmxpYyBrZXkgd2lsbCBiZSBkZXJpdmVkIGZyb20gdGhlIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogQWxsIHBhcmFtZXRlcnMgYXJlIHN0cmluZ2VudGx5IHZhbGlkYXRlZCwgYW5kIGFuIGVycm9yIGlzIHRocm93biBpZlxuICAgICAqIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBleHRlbmRlZCBrZXksIG9yIGFuIGV4dGVuZGVkXG4gICAgICogcHVibGljICh4cHViKSBvciBwcml2YXRlICh4cHJ2KSBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVwdGggLSBUaGUgZGVwdGggb2YgdGhlIG5vZGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSBmb3IgdGhlIG5vZGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBub2RlLiBJZiBhIHByaXZhdGUga2V5IGlzXG4gICAgICogc3BlY2lmaWVkLCB0aGlzIHBhcmFtZXRlciBpcyBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNoYWluQ29kZSAtIFRoZSBjaGFpbiBjb2RlIGZvciB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUV4dGVuZGVkS2V5KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5kZWRLZXkgPSAoMCwgZXh0ZW5kZWRfa2V5c18xLmRlY29kZUV4dGVuZGVkS2V5KShvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5Db2RlLCBkZXB0aCwgcGFyZW50RmluZ2VycHJpbnQsIGluZGV4IH0gPSBleHRlbmRlZEtleTtcbiAgICAgICAgICAgIGlmIChleHRlbmRlZEtleS52ZXJzaW9uID09PSBleHRlbmRlZF9rZXlzXzEuUFJJVkFURV9LRVlfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJpdmF0ZUtleSB9ID0gZXh0ZW5kZWRLZXk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJJUDQ0Tm9kZS5mcm9tRXh0ZW5kZWRLZXkoe1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICAgICAgICAgICAgICBjaGFpbkNvZGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHB1YmxpY0tleSB9ID0gZXh0ZW5kZWRLZXk7XG4gICAgICAgICAgICByZXR1cm4gQklQNDROb2RlLmZyb21FeHRlbmRlZEtleSh7XG4gICAgICAgICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgcHVibGljS2V5LFxuICAgICAgICAgICAgICAgIGNoYWluQ29kZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcHJpdmF0ZUtleSwgcHVibGljS2V5LCBjaGFpbkNvZGUsIGRlcHRoLCBwYXJlbnRGaW5nZXJwcmludCwgaW5kZXgsIH0gPSBvcHRpb25zO1xuICAgICAgICB2YWxpZGF0ZUJJUDQ0RGVwdGgoZGVwdGgpO1xuICAgICAgICBjb25zdCBub2RlID0gYXdhaXQgU0xJUDEwTm9kZV8xLlNMSVAxME5vZGUuZnJvbUV4dGVuZGVkS2V5KHtcbiAgICAgICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgICBjaGFpbkNvZGUsXG4gICAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBjdXJ2ZTogJ3NlY3AyNTZrMScsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJJUDQ0Tm9kZShub2RlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEJJUC00NCBub2RlIGZyb20gYSBkZXJpdmF0aW9uIHBhdGguIFRoZSBkZXJpdmF0aW9uIHBhdGhcbiAgICAgKiBtdXN0IGJlIHJvb3RlZCwgaS5lLiBpdCBtdXN0IGJlZ2luIHdpdGggYSBCSVAtMzkgbm9kZSwgZ2l2ZW4gYXMgYSBzdHJpbmcgb2ZcbiAgICAgKiB0aGUgZm9ybSBgYmlwMzk6TU5FTU9OSUNgLCB3aGVyZSBgTU5FTU9OSUNgIGlzIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2ZcbiAgICAgKiBCSVAtMzkgc2VlZCBwaHJhc2Ugd29yZHMuXG4gICAgICpcbiAgICAgKiBBbGwgcGFyYW1ldGVycyBhcmUgc3RyaW5nZW50bHkgdmFsaWRhdGVkLCBhbmQgYW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gICAgICogdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIFJlY2FsbCB0aGF0IGEgQklQLTQ0IEhEIHRyZWUgcGF0aCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIG5vZGVzOlxuICAgICAqXG4gICAgICogYG0gLyA0NCcgLyBjb2luX3R5cGUnIC8gYWNjb3VudCcgLyBjaGFuZ2UgLyBhZGRyZXNzX2luZGV4YFxuICAgICAqXG4gICAgICogV2l0aCB0aGUgZm9sbG93aW5nIGRlcHRoczpcbiAgICAgKlxuICAgICAqIGAwIC8gMSAvIDIgLyAzIC8gNCAvIDVgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBkZXJpdmF0aW9uIHBhdGguXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVyaXZhdGlvblBhdGggLSBUaGUgcm9vdGVkIEhEIHRyZWUgcGF0aCB0aGF0IHdpbGwgYmUgdXNlZFxuICAgICAqIHRvIGRlcml2ZSB0aGUga2V5IG9mIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbURlcml2YXRpb25QYXRoKHsgZGVyaXZhdGlvblBhdGgsIH0pIHtcbiAgICAgICAgdmFsaWRhdGVCSVA0NERlcHRoKGRlcml2YXRpb25QYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgICB2YWxpZGF0ZUJJUDQ0RGVyaXZhdGlvblBhdGgoZGVyaXZhdGlvblBhdGgsIGNvbnN0YW50c18xLk1JTl9CSVBfNDRfREVQVEgpO1xuICAgICAgICBjb25zdCBub2RlID0gYXdhaXQgU0xJUDEwTm9kZV8xLlNMSVAxME5vZGUuZnJvbURlcml2YXRpb25QYXRoKHtcbiAgICAgICAgICAgIGRlcml2YXRpb25QYXRoLFxuICAgICAgICAgICAgY3VydmU6ICdzZWNwMjU2azEnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCSVA0NE5vZGUobm9kZSk7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JJUDQ0Tm9kZV9ub2RlLCBcImZcIikuZGVwdGg7XG4gICAgfVxuICAgIGdldCBwcml2YXRlS2V5Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CSVA0NE5vZGVfbm9kZSwgXCJmXCIpLnByaXZhdGVLZXlCeXRlcztcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleUJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDROb2RlX25vZGUsIFwiZlwiKS5wdWJsaWNLZXlCeXRlcztcbiAgICB9XG4gICAgZ2V0IGNoYWluQ29kZUJ5dGVzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDROb2RlX25vZGUsIFwiZlwiKS5jaGFpbkNvZGVCeXRlcztcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CSVA0NE5vZGVfbm9kZSwgXCJmXCIpLnByaXZhdGVLZXk7XG4gICAgfVxuICAgIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CSVA0NE5vZGVfbm9kZSwgXCJmXCIpLnB1YmxpY0tleTtcbiAgICB9XG4gICAgZ2V0IGNvbXByZXNzZWRQdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CSVA0NE5vZGVfbm9kZSwgXCJmXCIpLmNvbXByZXNzZWRQdWJsaWNLZXk7XG4gICAgfVxuICAgIGdldCBjb21wcmVzc2VkUHVibGljS2V5Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9CSVA0NE5vZGVfbm9kZSwgXCJmXCIpLmNvbXByZXNzZWRQdWJsaWNLZXlCeXRlcztcbiAgICB9XG4gICAgZ2V0IGNoYWluQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JJUDQ0Tm9kZV9ub2RlLCBcImZcIikuY2hhaW5Db2RlO1xuICAgIH1cbiAgICBnZXQgYWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0JJUDQ0Tm9kZV9ub2RlLCBcImZcIikuYWRkcmVzcztcbiAgICB9XG4gICAgZ2V0IG1hc3RlckZpbmdlcnByaW50KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDROb2RlX25vZGUsIFwiZlwiKS5tYXN0ZXJGaW5nZXJwcmludDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudEZpbmdlcnByaW50KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDROb2RlX25vZGUsIFwiZlwiKS5wYXJlbnRGaW5nZXJwcmludDtcbiAgICB9XG4gICAgZ2V0IGZpbmdlcnByaW50KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDROb2RlX25vZGUsIFwiZlwiKS5maW5nZXJwcmludDtcbiAgICB9XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDROb2RlX25vZGUsIFwiZlwiKS5pbmRleDtcbiAgICB9XG4gICAgZ2V0IGV4dGVuZGVkS2V5KCkge1xuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgZGVwdGg6IHRoaXMuZGVwdGgsXG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludDogdGhpcy5wYXJlbnRGaW5nZXJwcmludCxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgY2hhaW5Db2RlOiB0aGlzLmNoYWluQ29kZUJ5dGVzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcml2YXRlS2V5Qnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZXh0ZW5kZWRfa2V5c18xLmVuY29kZUV4dGVuZGVkS2V5KShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHZlcnNpb246IGV4dGVuZGVkX2tleXNfMS5QUklWQVRFX0tFWV9WRVJTSU9OLCBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXlCeXRlcyB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBleHRlbmRlZF9rZXlzXzEuZW5jb2RlRXh0ZW5kZWRLZXkpKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIHsgdmVyc2lvbjogZXh0ZW5kZWRfa2V5c18xLlBVQkxJQ19LRVlfVkVSU0lPTiwgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleUJ5dGVzIH0pKTtcbiAgICB9XG4gICAgZ2V0IGN1cnZlKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDROb2RlX25vZGUsIFwiZlwiKS5jdXJ2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgbmV1dGVyZWQgdmVyc2lvbiBvZiB0aGlzIG5vZGUsIGkuZS4gYSBub2RlIHdpdGhvdXQgYSBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV1dGVyZWQgdmVyc2lvbiBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgbmV1dGVyKCkge1xuICAgICAgICBjb25zdCBub2RlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDROb2RlX25vZGUsIFwiZlwiKS5uZXV0ZXIoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCSVA0NE5vZGUobm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcml2ZXMgYSBjaGlsZCBvZiB0aGUga2V5IGNvbnRhaW5zIGJlIHRoaXMgbm9kZSBhbmQgcmV0dXJucyBhIG5ld1xuICAgICAqIHtAbGluayBCSVA0NE5vZGV9IGNvbnRhaW5pbmcgdGhlIGNoaWxkIGtleS5cbiAgICAgKlxuICAgICAqIFRoZSBzcGVjaWZpZWQgcGF0aCBtdXN0IGJlIGEgdmFsaWQgSEQgcGF0aCBmcm9tIHRoaXMgbm9kZSwgcGVyIEJJUC00NC5cbiAgICAgKiBBdCBwcmVzZW50LCB0aGlzIG1lYW5zIHRoYXQgdGhlIHBhdGggbXVzdCBjb25zaXN0IG9mIG5vIG1vcmUgdGhhbiA1IEJJUC0zMlxuICAgICAqIG5vZGVzLCBkZXBlbmRpbmcgb24gdGhlIGRlcHRoIG9mIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIFJlY2FsbCB0aGF0IGEgQklQLTQ0IEhEIHRyZWUgcGF0aCBjb25zaXN0cyBvZiB0aGUgZm9sbG93aW5nIG5vZGVzOlxuICAgICAqXG4gICAgICogYG0gLyA0NCcgLyBjb2luX3R5cGUnIC8gYWNjb3VudCcgLyBjaGFuZ2UgLyBhZGRyZXNzX2luZGV4YFxuICAgICAqXG4gICAgICogV2l0aCB0aGUgZm9sbG93aW5nIGRlcHRoczpcbiAgICAgKlxuICAgICAqIGAwIC8gMSAvIDIgLyAzIC8gNCAvIDVgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXJ0aWFsIChub24tcm9vdGVkKSBCSVAtNDQgSEQgdHJlZSBwYXRoIHdpbGwgYmUgdXNlZFxuICAgICAqIHRvIGRlcml2ZSBhIGNoaWxkIGtleSBmcm9tIHRoZSBwYXJlbnQga2V5IGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBub2RlLlxuICAgICAqIEByZXR1cm5zIFRoZSB7QGxpbmsgQklQNDROb2RlfSBjb3JyZXNwb25kaW5nIHRvIHRoZSBkZXJpdmVkIGNoaWxkIGtleS5cbiAgICAgKi9cbiAgICBhc3luYyBkZXJpdmUocGF0aCkge1xuICAgICAgICBpZiAodGhpcy5kZXB0aCA9PT0gY29uc3RhbnRzXzEuTUFYX0JJUF80NF9ERVBUSCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIG9wZXJhdGlvbjogVGhpcyBIRCB0cmVlIG5vZGUgaXMgYWxyZWFkeSBhIGxlYWYgbm9kZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdEZXB0aCA9IHRoaXMuZGVwdGggKyBwYXRoLmxlbmd0aDtcbiAgICAgICAgdmFsaWRhdGVCSVA0NERlcHRoKG5ld0RlcHRoKTtcbiAgICAgICAgdmFsaWRhdGVCSVA0NERlcml2YXRpb25QYXRoKHBhdGgsICh0aGlzLmRlcHRoICsgMSkpO1xuICAgICAgICBjb25zdCBub2RlID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfQklQNDROb2RlX25vZGUsIFwiZlwiKS5kZXJpdmUocGF0aCk7XG4gICAgICAgIHJldHVybiBuZXcgQklQNDROb2RlKG5vZGUpO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIGRvY3VtZW50ZWQgaW4gdGhlIGludGVyZmFjZSBvZiB0aGlzIGNsYXNzLlxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlcHRoOiB0aGlzLmRlcHRoLFxuICAgICAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQ6IHRoaXMubWFzdGVyRmluZ2VycHJpbnQsXG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludDogdGhpcy5wYXJlbnRGaW5nZXJwcmludCxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgcHJpdmF0ZUtleTogdGhpcy5wcml2YXRlS2V5LFxuICAgICAgICAgICAgcHVibGljS2V5OiB0aGlzLnB1YmxpY0tleSxcbiAgICAgICAgICAgIGNoYWluQ29kZTogdGhpcy5jaGFpbkNvZGUsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5CSVA0NE5vZGUgPSBCSVA0NE5vZGU7XG5fQklQNDROb2RlX25vZGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBCSVAtNDQgcGF0aCBkZXB0aC4gRWZmZWN0aXZlbHksIGFzc2VydHMgdGhhdCB0aGUgZGVwdGggaXMgYW5cbiAqIGludGVnZXIgYG51bWJlcmAgTiBzdWNoIHRoYXQgMCA8PSBOIDw9IDUuIFRocm93cyBhbiBlcnJvciBpZiB2YWxpZGF0aW9uXG4gKiBmYWlscy5cbiAqXG4gKiBAcGFyYW0gZGVwdGggLSBUaGUgZGVwdGggdG8gdmFsaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQklQNDREZXB0aChkZXB0aCkge1xuICAgICgwLCBTTElQMTBOb2RlXzEudmFsaWRhdGVCSVAzMkRlcHRoKShkZXB0aCk7XG4gICAgaWYgKGRlcHRoIDwgY29uc3RhbnRzXzEuTUlOX0JJUF80NF9ERVBUSCB8fCBkZXB0aCA+IGNvbnN0YW50c18xLk1BWF9CSVBfNDRfREVQVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEhEIHRyZWUgcGF0aCBkZXB0aDogVGhlIGRlcHRoIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIE4gc3VjaCB0aGF0IDAgPD0gTiA8PSA1LiBSZWNlaXZlZDogXCIke2RlcHRofVwiYCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUJJUDQ0RGVwdGggPSB2YWxpZGF0ZUJJUDQ0RGVwdGg7XG4vKipcbiAqIEVuc3VyZXMgdGhhdCB0aGUgZ2l2ZW4gZGVyaXZhdGlvbiBpcyB2YWxpZCBieSBCSVAtNDQuXG4gKlxuICogUmVjYWxsIHRoYXQgYSBCSVAtNDQgSEQgdHJlZSBwYXRoIGNvbnNpc3RzIG9mIHRoZSBmb2xsb3dpbmcgbm9kZXM6XG4gKlxuICogYG0gLyA0NCcgLyBjb2luX3R5cGUnIC8gYWNjb3VudCcgLyBjaGFuZ2UgLyBhZGRyZXNzX2luZGV4YFxuICpcbiAqIFdpdGggdGhlIGZvbGxvd2luZyBkZXB0aHM6XG4gKlxuICogYDAgLyAxIC8gMiAvIDMgLyA0IC8gNWBcbiAqXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0YXJ0aW5nRGVwdGggLSBUaGUgZGVwdGggb2YgdGhlIGZpcnN0IG5vZGUgb2YgdGhlIGRlcml2YXRpb24gcGF0aC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCSVA0NERlcml2YXRpb25QYXRoKHBhdGgsIHN0YXJ0aW5nRGVwdGgpIHtcbiAgICBwYXRoLmZvckVhY2goKG5vZGVUb2tlbiwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudERlcHRoID0gc3RhcnRpbmdEZXB0aCArIGluZGV4O1xuICAgICAgICBpZiAoY3VycmVudERlcHRoID09PSBjb25zdGFudHNfMS5NSU5fQklQXzQ0X0RFUFRIKSB7XG4gICAgICAgICAgICBpZiAoIShub2RlVG9rZW4gaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJlxuICAgICAgICAgICAgICAgICFjb25zdGFudHNfMS5CSVBfMzlfUEFUSF9SRUdFWC50ZXN0KG5vZGVUb2tlbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGVyaXZhdGlvbiBwYXRoOiBUaGUgXCJtXCIgLyBzZWVkIG5vZGUgKGRlcHRoIDApIG11c3QgYmUgYSBCSVAtMzkgbm9kZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKHR5cGVvZiBub2RlVG9rZW4gPT09ICdzdHJpbmcnKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICBzd2l0Y2ggKGN1cnJlbnREZXB0aCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmIChub2RlVG9rZW4gIT09IGNvbnN0YW50c18xLkJJUDQ0UHVycG9zZU5vZGVUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGVyaXZhdGlvbiBwYXRoOiBUaGUgXCJwdXJwb3NlXCIgbm9kZSAoZGVwdGggMSkgbXVzdCBiZSB0aGUgc3RyaW5nIFwiJHtjb25zdGFudHNfMS5CSVA0NFB1cnBvc2VOb2RlVG9rZW59XCIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmICghY29uc3RhbnRzXzEuQklQXzMyX1BBVEhfUkVHRVgudGVzdChub2RlVG9rZW4pIHx8ICEoMCwgdXRpbHNfMi5pc0hhcmRlbmVkKShub2RlVG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXJpdmF0aW9uIHBhdGg6IFRoZSBcImNvaW5fdHlwZVwiIG5vZGUgKGRlcHRoIDIpIG11c3QgYmUgYSBoYXJkZW5lZCBCSVAtMzIgbm9kZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdGFudHNfMS5CSVBfMzJfUEFUSF9SRUdFWC50ZXN0KG5vZGVUb2tlbikgfHwgISgwLCB1dGlsc18yLmlzSGFyZGVuZWQpKG5vZGVUb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRlcml2YXRpb24gcGF0aDogVGhlIFwiYWNjb3VudFwiIG5vZGUgKGRlcHRoIDMpIG11c3QgYmUgYSBoYXJkZW5lZCBCSVAtMzIgbm9kZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaWYgKCFjb25zdGFudHNfMS5CSVBfMzJfUEFUSF9SRUdFWC50ZXN0KG5vZGVUb2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRlcml2YXRpb24gcGF0aDogVGhlIFwiY2hhbmdlXCIgbm9kZSAoZGVwdGggNCkgbXVzdCBiZSBhIEJJUC0zMiBub2RlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTUFYX0JJUF80NF9ERVBUSDogLy8gNVxuICAgICAgICAgICAgICAgIGlmICghY29uc3RhbnRzXzEuQklQXzMyX1BBVEhfUkVHRVgudGVzdChub2RlVG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXJpdmF0aW9uIHBhdGg6IFRoZSBcImFkZHJlc3NfaW5kZXhcIiBub2RlIChkZXB0aCA1KSBtdXN0IGJlIGEgQklQLTMyIG5vZGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CSVA0NE5vZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfYSwgX1NMSVAxME5vZGVfY29uc3RydWN0b3JHdWFyZDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVyaXZlQ2hpbGROb2RlID0gZXhwb3J0cy52YWxpZGF0ZVJvb3RJbmRleCA9IGV4cG9ydHMudmFsaWRhdGVNYXN0ZXJQYXJlbnRGaW5nZXJwcmludCA9IGV4cG9ydHMudmFsaWRhdGVQYXJlbnRGaW5nZXJwcmludCA9IGV4cG9ydHMudmFsaWRhdGVCSVAzMkRlcHRoID0gZXhwb3J0cy5TTElQMTBOb2RlID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGN1cnZlc18xID0gcmVxdWlyZShcIi4vY3VydmVzXCIpO1xuY29uc3QgZGVyaXZhdGlvbl8xID0gcmVxdWlyZShcIi4vZGVyaXZhdGlvblwiKTtcbmNvbnN0IGJpcDMyXzEgPSByZXF1aXJlKFwiLi9kZXJpdmVycy9iaXAzMlwiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNsYXNzIFNMSVAxME5vZGUge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgIGNvbnN0cnVjdG9yKHsgZGVwdGgsIG1hc3RlckZpbmdlcnByaW50LCBwYXJlbnRGaW5nZXJwcmludCwgaW5kZXgsIGNoYWluQ29kZSwgcHJpdmF0ZUtleSwgcHVibGljS2V5LCBjdXJ2ZSwgfSwgY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGNvbnN0cnVjdG9yR3VhcmQgPT09IF9fY2xhc3NQcml2YXRlRmllbGRHZXQoU0xJUDEwTm9kZSwgX2EsIFwiZlwiLCBfU0xJUDEwTm9kZV9jb25zdHJ1Y3Rvckd1YXJkKSwgJ1NMSVAxME5vZGUgY2FuIG9ubHkgYmUgY29uc3RydWN0ZWQgdXNpbmcgYFNMSVAxME5vZGUuZnJvbUpTT05gLCBgU0xJUDEwTm9kZS5mcm9tRXh0ZW5kZWRLZXlgLCBvciBgU0xJUDEwTm9kZS5mcm9tRGVyaXZhdGlvblBhdGhgLicpO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRoaXMubWFzdGVyRmluZ2VycHJpbnQgPSBtYXN0ZXJGaW5nZXJwcmludDtcbiAgICAgICAgdGhpcy5wYXJlbnRGaW5nZXJwcmludCA9IHBhcmVudEZpbmdlcnByaW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuY2hhaW5Db2RlQnl0ZXMgPSBjaGFpbkNvZGU7XG4gICAgICAgIHRoaXMucHJpdmF0ZUtleUJ5dGVzID0gcHJpdmF0ZUtleTtcbiAgICAgICAgdGhpcy5wdWJsaWNLZXlCeXRlcyA9IHB1YmxpY0tleTtcbiAgICAgICAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcmFwcGVyIG9mIHRoZSB7QGxpbmsgZnJvbUV4dGVuZGVkS2V5fSBmdW5jdGlvbi4gUmVmZXIgdG8gdGhhdCBmdW5jdGlvblxuICAgICAqIGZvciBkb2N1bWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb24gLSBUaGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIFNMSVAtMTAgbm9kZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgZnJvbUpTT04oanNvbikge1xuICAgICAgICByZXR1cm4gU0xJUDEwTm9kZS5mcm9tRXh0ZW5kZWRLZXkoanNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBTTElQLTEwIG5vZGUgZnJvbSBhIGtleSBhbmQgY2hhaW4gY29kZS4gWW91IG11c3Qgc3BlY2lmeVxuICAgICAqIGVpdGhlciBhIHByaXZhdGUga2V5IG9yIGEgcHVibGljIGtleS4gV2hlbiBzcGVjaWZ5aW5nIGEgcHJpdmF0ZSBrZXksXG4gICAgICogdGhlIHB1YmxpYyBrZXkgd2lsbCBiZSBkZXJpdmVkIGZyb20gdGhlIHByaXZhdGUga2V5LlxuICAgICAqXG4gICAgICogQWxsIHBhcmFtZXRlcnMgYXJlIHN0cmluZ2VudGx5IHZhbGlkYXRlZCwgYW5kIGFuIGVycm9yIGlzIHRocm93biBpZlxuICAgICAqIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgbmV3IG5vZGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVwdGggLSBUaGUgZGVwdGggb2YgdGhlIG5vZGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWFzdGVyRmluZ2VycHJpbnQgLSBUaGUgZmluZ2VycHJpbnQgb2YgdGhlIG1hc3RlciBub2RlLCBpLmUuLCB0aGVcbiAgICAgKiBub2RlIGF0IGRlcHRoIDAuIE1heSBiZSB1bmRlZmluZWQgaWYgdGhpcyBub2RlIHdhcyBjcmVhdGVkIGZyb20gYW4gZXh0ZW5kZWRcbiAgICAgKiBrZXkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFyZW50RmluZ2VycHJpbnQgLSBUaGUgZmluZ2VycHJpbnQgb2YgdGhlIHBhcmVudCBrZXksIG9yIDAgaWZcbiAgICAgKiB0aGUgbm9kZSBpcyBhIG1hc3RlciBub2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBub2RlLCBvciAwIGlmIHRoZSBub2RlIGlzIGEgbWFzdGVyIG5vZGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwcml2YXRlIGtleSBmb3IgdGhlIG5vZGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgZm9yIHRoZSBub2RlLiBJZiBhIHByaXZhdGUga2V5IGlzXG4gICAgICogc3BlY2lmaWVkLCB0aGlzIHBhcmFtZXRlciBpcyBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNoYWluQ29kZSAtIFRoZSBjaGFpbiBjb2RlIGZvciB0aGUgbm9kZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jdXJ2ZSAtIFRoZSBjdXJ2ZSB1c2VkIGJ5IHRoZSBub2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tRXh0ZW5kZWRLZXkoeyBkZXB0aCwgbWFzdGVyRmluZ2VycHJpbnQsIHBhcmVudEZpbmdlcnByaW50LCBpbmRleCwgcHJpdmF0ZUtleSwgcHVibGljS2V5LCBjaGFpbkNvZGUsIGN1cnZlLCB9KSB7XG4gICAgICAgIGNvbnN0IGNoYWluQ29kZUJ5dGVzID0gKDAsIHV0aWxzXzIuZ2V0Qnl0ZXMpKGNoYWluQ29kZSwgY29uc3RhbnRzXzEuQllURVNfS0VZX0xFTkdUSCk7XG4gICAgICAgICgwLCB1dGlsc18yLnZhbGlkYXRlQ3VydmUpKGN1cnZlKTtcbiAgICAgICAgdmFsaWRhdGVCSVAzMkRlcHRoKGRlcHRoKTtcbiAgICAgICAgKDAsIHV0aWxzXzIudmFsaWRhdGVCSVAzMkluZGV4KShpbmRleCk7XG4gICAgICAgIHZhbGlkYXRlUm9vdEluZGV4KGluZGV4LCBkZXB0aCk7XG4gICAgICAgIHZhbGlkYXRlUGFyZW50RmluZ2VycHJpbnQocGFyZW50RmluZ2VycHJpbnQsIGRlcHRoKTtcbiAgICAgICAgdmFsaWRhdGVNYXN0ZXJQYXJlbnRGaW5nZXJwcmludChtYXN0ZXJGaW5nZXJwcmludCwgcGFyZW50RmluZ2VycHJpbnQsIGRlcHRoKTtcbiAgICAgICAgY29uc3QgY3VydmVPYmplY3QgPSAoMCwgY3VydmVzXzEuZ2V0Q3VydmVCeU5hbWUpKGN1cnZlKTtcbiAgICAgICAgaWYgKHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByaXZhdGVLZXlCeXRlcyA9ICgwLCB1dGlsc18yLmdldEJ5dGVzVW5zYWZlKShwcml2YXRlS2V5LCBjb25zdGFudHNfMS5CWVRFU19LRVlfTEVOR1RIKTtcbiAgICAgICAgICAgICgwLCB1dGlsc18xLmFzc2VydCkoY3VydmVPYmplY3QuaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleUJ5dGVzKSwgYEludmFsaWQgcHJpdmF0ZSBrZXk6IFZhbHVlIGlzIG5vdCBhIHZhbGlkICR7Y3VydmV9IHByaXZhdGUga2V5LmApO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTTElQMTBOb2RlKHtcbiAgICAgICAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICAgICAgICBtYXN0ZXJGaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludCxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBjaGFpbkNvZGU6IGNoYWluQ29kZUJ5dGVzLFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlCeXRlcyxcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IGF3YWl0IGN1cnZlT2JqZWN0LmdldFB1YmxpY0tleShwcml2YXRlS2V5Qnl0ZXMpLFxuICAgICAgICAgICAgICAgIGN1cnZlLFxuICAgICAgICAgICAgfSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfYSwgXCJmXCIsIF9TTElQMTBOb2RlX2NvbnN0cnVjdG9yR3VhcmQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHVibGljS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9ICgwLCB1dGlsc18yLmdldEJ5dGVzKShwdWJsaWNLZXksIGN1cnZlT2JqZWN0LnB1YmxpY0tleUxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNMSVAxME5vZGUoe1xuICAgICAgICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgICAgICAgIG1hc3RlckZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGNoYWluQ29kZTogY2hhaW5Db2RlQnl0ZXMsXG4gICAgICAgICAgICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXlCeXRlcyxcbiAgICAgICAgICAgICAgICBjdXJ2ZSxcbiAgICAgICAgICAgIH0sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2EsIFwiZlwiLCBfU0xJUDEwTm9kZV9jb25zdHJ1Y3Rvckd1YXJkKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wdGlvbnM6IE11c3QgcHJvdmlkZSBlaXRoZXIgYSBwcml2YXRlIGtleSBvciBhIHB1YmxpYyBrZXkuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBTTElQLTEwIG5vZGUgZnJvbSBhIGRlcml2YXRpb24gcGF0aC4gVGhlIGRlcml2YXRpb24gcGF0aFxuICAgICAqIG11c3QgYmUgcm9vdGVkLCBpLmUuIGl0IG11c3QgYmVnaW4gd2l0aCBhIEJJUC0zOSBub2RlLCBnaXZlbiBhcyBhIHN0cmluZyBvZlxuICAgICAqIHRoZSBmb3JtIGBiaXAzOTpNTkVNT05JQ2AsIHdoZXJlIGBNTkVNT05JQ2AgaXMgYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZlxuICAgICAqIEJJUC0zOSBzZWVkIHBocmFzZSB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEFsbCBwYXJhbWV0ZXJzIGFyZSBzdHJpbmdlbnRseSB2YWxpZGF0ZWQsIGFuZCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAgICAgKiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogUmVjYWxsIHRoYXQgYSBCSVAtNDQgSEQgdHJlZSBwYXRoIGNvbnNpc3RzIG9mIHRoZSBmb2xsb3dpbmcgbm9kZXM6XG4gICAgICpcbiAgICAgKiBgbSAvIDQ0JyAvIGNvaW5fdHlwZScgLyBhY2NvdW50JyAvIGNoYW5nZSAvIGFkZHJlc3NfaW5kZXhgXG4gICAgICpcbiAgICAgKiBXaXRoIHRoZSBmb2xsb3dpbmcgZGVwdGhzOlxuICAgICAqXG4gICAgICogYDAgLyAxIC8gMiAvIDMgLyA0IC8gNWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBuZXcgbm9kZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kZXJpdmF0aW9uUGF0aCAtIFRoZSByb290ZWQgSEQgdHJlZSBwYXRoIHRoYXQgd2lsbCBiZSB1c2VkXG4gICAgICogdG8gZGVyaXZlIHRoZSBrZXkgb2YgdGhpcyBub2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmN1cnZlIC0gVGhlIGN1cnZlIHVzZWQgYnkgdGhlIG5vZGUuXG4gICAgICogQHJldHVybnMgQSBuZXcgU0xJUC0xMCBub2RlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBmcm9tRGVyaXZhdGlvblBhdGgoeyBkZXJpdmF0aW9uUGF0aCwgY3VydmUsIH0pIHtcbiAgICAgICAgKDAsIHV0aWxzXzIudmFsaWRhdGVDdXJ2ZSkoY3VydmUpO1xuICAgICAgICBpZiAoIWRlcml2YXRpb25QYXRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgb3B0aW9uczogTXVzdCBwcm92aWRlIGEgZGVyaXZhdGlvbiBwYXRoLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXJpdmF0aW9uUGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXJpdmF0aW9uIHBhdGg6IE1heSBub3Qgc3BlY2lmeSBhbiBlbXB0eSBkZXJpdmF0aW9uIHBhdGguJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCBkZXJpdmF0aW9uXzEuZGVyaXZlS2V5RnJvbVBhdGgpKHtcbiAgICAgICAgICAgIHBhdGg6IGRlcml2YXRpb25QYXRoLFxuICAgICAgICAgICAgZGVwdGg6IGRlcml2YXRpb25QYXRoLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBjdXJ2ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBjaGFpbkNvZGUoKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh0aGlzLmNoYWluQ29kZUJ5dGVzKTtcbiAgICB9XG4gICAgZ2V0IHByaXZhdGVLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnByaXZhdGVLZXlCeXRlcykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKHRoaXMucHJpdmF0ZUtleUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgcHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkodGhpcy5wdWJsaWNLZXlCeXRlcyk7XG4gICAgfVxuICAgIGdldCBjb21wcmVzc2VkUHVibGljS2V5Qnl0ZXMoKSB7XG4gICAgICAgIHJldHVybiAoMCwgY3VydmVzXzEuZ2V0Q3VydmVCeU5hbWUpKHRoaXMuY3VydmUpLmNvbXByZXNzUHVibGljS2V5KHRoaXMucHVibGljS2V5Qnl0ZXMpO1xuICAgIH1cbiAgICBnZXQgY29tcHJlc3NlZFB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmJ5dGVzVG9IZXgpKHRoaXMuY29tcHJlc3NlZFB1YmxpY0tleUJ5dGVzKTtcbiAgICB9XG4gICAgZ2V0IGFkZHJlc3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnZlICE9PSAnc2VjcDI1NmsxJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZ2V0IGFkZHJlc3MgZm9yIHRoaXMgbm9kZTogT25seSBzZWNwMjU2azEgaXMgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSgoMCwgYmlwMzJfMS5wdWJsaWNLZXlUb0V0aEFkZHJlc3MpKHRoaXMucHVibGljS2V5Qnl0ZXMpKTtcbiAgICB9XG4gICAgZ2V0IGZpbmdlcnByaW50KCkge1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIuZ2V0RmluZ2VycHJpbnQpKHRoaXMuY29tcHJlc3NlZFB1YmxpY0tleUJ5dGVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgbmV1dGVyZWQgdmVyc2lvbiBvZiB0aGlzIG5vZGUsIGkuZS4gYSBub2RlIHdpdGhvdXQgYSBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV1dGVyZWQgdmVyc2lvbiBvZiB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgbmV1dGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNMSVAxME5vZGUoe1xuICAgICAgICAgICAgZGVwdGg6IHRoaXMuZGVwdGgsXG4gICAgICAgICAgICBtYXN0ZXJGaW5nZXJwcmludDogdGhpcy5tYXN0ZXJGaW5nZXJwcmludCxcbiAgICAgICAgICAgIHBhcmVudEZpbmdlcnByaW50OiB0aGlzLnBhcmVudEZpbmdlcnByaW50LFxuICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICBjaGFpbkNvZGU6IHRoaXMuY2hhaW5Db2RlQnl0ZXMsXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHRoaXMucHVibGljS2V5Qnl0ZXMsXG4gICAgICAgICAgICBjdXJ2ZTogdGhpcy5jdXJ2ZSxcbiAgICAgICAgfSwgX19jbGFzc1ByaXZhdGVGaWVsZEdldChTTElQMTBOb2RlLCBfYSwgXCJmXCIsIF9TTElQMTBOb2RlX2NvbnN0cnVjdG9yR3VhcmQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVyaXZlcyBhIGNoaWxkIG9mIHRoZSBrZXkgY29udGFpbnMgYmUgdGhpcyBub2RlIGFuZCByZXR1cm5zIGEgbmV3XG4gICAgICoge0BsaW5rIFNMSVAxME5vZGV9IGNvbnRhaW5pbmcgdGhlIGNoaWxkIGtleS5cbiAgICAgKlxuICAgICAqIFRoZSBzcGVjaWZpZWQgcGF0aCBtdXN0IGJlIGEgdmFsaWQgSEQgcGF0aCBmcm9tIHRoaXMgbm9kZSwgcGVyIFNMSVAtMTAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXJ0aWFsIChub24tcm9vdGVkKSBTTElQLTEwIEhEIHRyZWUgcGF0aCB3aWxsIGJlIHVzZWRcbiAgICAgKiB0byBkZXJpdmUgYSBjaGlsZCBrZXkgZnJvbSB0aGUgcGFyZW50IGtleSBjb250YWluZWQgd2l0aGluIHRoaXMgbm9kZS5cbiAgICAgKiBAcmV0dXJucyBUaGUge0BsaW5rIFNMSVAxME5vZGV9IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGRlcml2ZWQgY2hpbGQga2V5LlxuICAgICAqL1xuICAgIGFzeW5jIGRlcml2ZShwYXRoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBkZXJpdmVDaGlsZE5vZGUoe1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIGRvY3VtZW50ZWQgaW4gdGhlIGludGVyZmFjZSBvZiB0aGlzIGNsYXNzLlxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlcHRoOiB0aGlzLmRlcHRoLFxuICAgICAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQ6IHRoaXMubWFzdGVyRmluZ2VycHJpbnQsXG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludDogdGhpcy5wYXJlbnRGaW5nZXJwcmludCxcbiAgICAgICAgICAgIGluZGV4OiB0aGlzLmluZGV4LFxuICAgICAgICAgICAgY3VydmU6IHRoaXMuY3VydmUsXG4gICAgICAgICAgICBwcml2YXRlS2V5OiB0aGlzLnByaXZhdGVLZXksXG4gICAgICAgICAgICBwdWJsaWNLZXk6IHRoaXMucHVibGljS2V5LFxuICAgICAgICAgICAgY2hhaW5Db2RlOiB0aGlzLmNoYWluQ29kZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlNMSVAxME5vZGUgPSBTTElQMTBOb2RlO1xuX2EgPSBTTElQMTBOb2RlO1xuX1NMSVAxME5vZGVfY29uc3RydWN0b3JHdWFyZCA9IHsgdmFsdWU6IFN5bWJvbCgnU0xJUDEwTm9kZS5jb25zdHJ1Y3RvcicpIH07XG4vKipcbiAqIFZhbGlkYXRlcyBhIEJJUC0zMiBwYXRoIGRlcHRoLiBFZmZlY3RpdmVseSwgYXNzZXJ0cyB0aGF0IHRoZSBkZXB0aCBpcyBhblxuICogaW50ZWdlciBgbnVtYmVyYC4gVGhyb3dzIGFuIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogQHBhcmFtIGRlcHRoIC0gVGhlIGRlcHRoIHRvIHZhbGlkYXRlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJJUDMyRGVwdGgoZGVwdGgpIHtcbiAgICBpZiAoISgwLCB1dGlsc18yLmlzVmFsaWRJbnRlZ2VyKShkZXB0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEhEIHRyZWUgcGF0aCBkZXB0aDogVGhlIGRlcHRoIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiBSZWNlaXZlZDogXCIke1N0cmluZyhkZXB0aCl9XCIuYCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUJJUDMyRGVwdGggPSB2YWxpZGF0ZUJJUDMyRGVwdGg7XG4vKipcbiAqIFZhbGlkYXRlcyBhIEJJUC0zMiBwYXJlbnQgZmluZ2VycHJpbnQuIEVmZmVjdGl2ZWx5LCBhc3NlcnRzIHRoYXQgdGhlIGZpbmdlcnByaW50IGlzIGFuXG4gKiBpbnRlZ2VyIGBudW1iZXJgLiBUaHJvd3MgYW4gZXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBAcGFyYW0gcGFyZW50RmluZ2VycHJpbnQgLSBUaGUgcGFyZW50IGZpbmdlcnByaW50IHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIGRlcHRoIC0gVGhlIGRlcHRoIG9mIHRoZSBub2RlIHRvIHZhbGlkYXRlLlxuICogQHRocm93cyBJZiB0aGUgcGFyZW50IGZpbmdlcnByaW50IGlzIG5vdCBhIHBvc2l0aXZlIGludGVnZXIsIG9yIGludmFsaWQgZm9yXG4gKiB0aGUgY3VycmVudCBkZXB0aC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQYXJlbnRGaW5nZXJwcmludChwYXJlbnRGaW5nZXJwcmludCwgZGVwdGgpIHtcbiAgICBpZiAoISgwLCB1dGlsc18yLmlzVmFsaWRJbnRlZ2VyKShwYXJlbnRGaW5nZXJwcmludCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmVudCBmaW5nZXJwcmludDogVGhlIGZpbmdlcnByaW50IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiBSZWNlaXZlZDogXCIke1N0cmluZyhwYXJlbnRGaW5nZXJwcmludCl9XCIuYCk7XG4gICAgfVxuICAgIGlmIChkZXB0aCA9PT0gMCAmJiBwYXJlbnRGaW5nZXJwcmludCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyZW50IGZpbmdlcnByaW50OiBUaGUgZmluZ2VycHJpbnQgb2YgdGhlIHJvb3Qgbm9kZSBtdXN0IGJlIDAuIFJlY2VpdmVkOiBcIiR7U3RyaW5nKHBhcmVudEZpbmdlcnByaW50KX1cIi5gKTtcbiAgICB9XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwYXJlbnRGaW5nZXJwcmludCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyZW50IGZpbmdlcnByaW50OiBUaGUgZmluZ2VycHJpbnQgb2YgYSBjaGlsZCBub2RlIG11c3Qgbm90IGJlIDAuIFJlY2VpdmVkOiBcIiR7U3RyaW5nKHBhcmVudEZpbmdlcnByaW50KX1cIi5gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUGFyZW50RmluZ2VycHJpbnQgPSB2YWxpZGF0ZVBhcmVudEZpbmdlcnByaW50O1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IGEgZ2l2ZW4gY29tYmluYXRpb24gb2YgbWFzdGVyIGZpbmdlcnByaW50IGFuZCBwYXJlbnRcbiAqIGZpbmdlcnByaW50IGlzIHZhbGlkIGZvciB0aGUgZ2l2ZW4gZGVwdGguXG4gKlxuICogQHBhcmFtIG1hc3RlckZpbmdlcnByaW50IC0gVGhlIG1hc3RlciBmaW5nZXJwcmludCB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBwYXJlbnRGaW5nZXJwcmludCAtIFRoZSBwYXJlbnQgZmluZ2VycHJpbnQgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gZGVwdGggLSBUaGUgZGVwdGggb2YgdGhlIG5vZGUgdG8gdmFsaWRhdGUuXG4gKiBAdGhyb3dzIElmIHRoZSBjb21iaW5hdGlvbiBvZiBtYXN0ZXIgZmluZ2VycHJpbnQgYW5kIHBhcmVudCBmaW5nZXJwcmludCBpc1xuICogaW52YWxpZCBmb3IgdGhlIGdpdmVuIGRlcHRoLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU1hc3RlclBhcmVudEZpbmdlcnByaW50KG1hc3RlckZpbmdlcnByaW50LCBwYXJlbnRGaW5nZXJwcmludCwgZGVwdGgpIHtcbiAgICAvLyBUaGUgbWFzdGVyIGZpbmdlcnByaW50IGlzIG9wdGlvbmFsLlxuICAgIGlmICghbWFzdGVyRmluZ2VycHJpbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVwdGggPj0gMiAmJiBtYXN0ZXJGaW5nZXJwcmludCA9PT0gcGFyZW50RmluZ2VycHJpbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhcmVudCBmaW5nZXJwcmludDogVGhlIGZpbmdlcnByaW50IG9mIGEgY2hpbGQgbm9kZSBjYW5ub3QgYmUgZXF1YWwgdG8gdGhlIG1hc3RlciBmaW5nZXJwcmludC4gUmVjZWl2ZWQ6IFwiJHtTdHJpbmcocGFyZW50RmluZ2VycHJpbnQpfVwiLmApO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVNYXN0ZXJQYXJlbnRGaW5nZXJwcmludCA9IHZhbGlkYXRlTWFzdGVyUGFyZW50RmluZ2VycHJpbnQ7XG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgdGhlIGluZGV4IGlzIHplcm8gZm9yIHRoZSByb290IG5vZGUuXG4gKlxuICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIGRlcHRoIC0gVGhlIGRlcHRoIG9mIHRoZSBub2RlIHRvIHZhbGlkYXRlLlxuICogQHRocm93cyBJZiB0aGUgaW5kZXggaXMgbm90IHplcm8gZm9yIHRoZSByb290IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUm9vdEluZGV4KGluZGV4LCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PT0gMCAmJiBpbmRleCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaW5kZXg6IFRoZSBpbmRleCBvZiB0aGUgcm9vdCBub2RlIG11c3QgYmUgMC4gUmVjZWl2ZWQ6IFwiJHtTdHJpbmcoaW5kZXgpfVwiLmApO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVSb290SW5kZXggPSB2YWxpZGF0ZVJvb3RJbmRleDtcbi8qKlxuICogRGVyaXZlcyBhIGNoaWxkIGtleSBmcm9tIHRoZSBnaXZlbiBwYXJlbnQga2V5LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gZGVyaXZpbmcgdGhlIGNoaWxkIGtleS5cbiAqIEBwYXJhbSBvcHRpb25zLm5vZGUgLSBUaGUgbm9kZSB0byBkZXJpdmUgZnJvbS5cbiAqIEBwYXJhbSBvcHRpb25zLnBhdGggLSBUaGUgcGF0aCB0byB0aGUgY2hpbGQgbm9kZSAvIGtleS5cbiAqIEByZXR1cm5zIFRoZSBkZXJpdmVkIGtleSBhbmQgZGVwdGguXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlcml2ZUNoaWxkTm9kZSh7IHBhdGgsIG5vZGUsIH0pIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEhEIHRyZWUgZGVyaXZhdGlvbiBwYXRoOiBEZXJpdmluZyBhIHBhdGggb2YgbGVuZ3RoIDAgaXMgbm90IGRlZmluZWQuJyk7XG4gICAgfVxuICAgIC8vIE5vdGUgdGhhdCB3ZSBkbyBub3Qgc3VidHJhY3QgMSBmcm9tIHRoZSBsZW5ndGggb2YgdGhlIHBhdGggdG8gdGhlIGNoaWxkLFxuICAgIC8vIHVubGlrZSB3aGVuIHdlIGNhbGN1bGF0ZSB0aGUgZGVwdGggb2YgYSByb290ZWQgcGF0aC5cbiAgICBjb25zdCBuZXdEZXB0aCA9IG5vZGUuZGVwdGggKyBwYXRoLmxlbmd0aDtcbiAgICB2YWxpZGF0ZUJJUDMyRGVwdGgobmV3RGVwdGgpO1xuICAgIHJldHVybiBhd2FpdCAoMCwgZGVyaXZhdGlvbl8xLmRlcml2ZUtleUZyb21QYXRoKSh7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGRlcHRoOiBuZXdEZXB0aCxcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVyaXZlQ2hpbGROb2RlID0gZGVyaXZlQ2hpbGROb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U0xJUDEwTm9kZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQklQXzMyX0hBUkRFTkVEX09GRlNFVCA9IGV4cG9ydHMuQklQXzM5X1BBVEhfUkVHRVggPSBleHBvcnRzLlNMSVBfMTBfUEFUSF9SRUdFWCA9IGV4cG9ydHMuQklQXzMyX1BBVEhfUkVHRVggPSBleHBvcnRzLlVOUFJFRklYRURfQklQXzMyX1BBVEhfUkVHRVggPSBleHBvcnRzLlVOUFJFRklYRURfUEFUSF9SRUdFWCA9IGV4cG9ydHMuQklQNDRQdXJwb3NlTm9kZVRva2VuID0gZXhwb3J0cy5NQVhfQklQXzMyX0lOREVYID0gZXhwb3J0cy5NQVhfVU5IQVJERU5FRF9CSVBfMzJfSU5ERVggPSBleHBvcnRzLk1BWF9CSVBfNDRfREVQVEggPSBleHBvcnRzLk1JTl9CSVBfNDRfREVQVEggPSBleHBvcnRzLkJZVEVTX0tFWV9MRU5HVEggPSB2b2lkIDA7XG5leHBvcnRzLkJZVEVTX0tFWV9MRU5HVEggPSAzMjtcbmV4cG9ydHMuTUlOX0JJUF80NF9ERVBUSCA9IDA7XG5leHBvcnRzLk1BWF9CSVBfNDRfREVQVEggPSA1O1xuZXhwb3J0cy5NQVhfVU5IQVJERU5FRF9CSVBfMzJfSU5ERVggPSAweDdmZmZmZmZmOyAvLyAyXjMxIC0gMVxuZXhwb3J0cy5NQVhfQklQXzMyX0lOREVYID0gMHhmZmZmZmZmZjsgLy8gMl4zMiAtIDFcbmV4cG9ydHMuQklQNDRQdXJwb3NlTm9kZVRva2VuID0gYGJpcDMyOjQ0J2A7XG5leHBvcnRzLlVOUFJFRklYRURfUEFUSF9SRUdFWCA9IC9eXFxkKyQvdTtcbi8qKlxuICogZS5nLlxuICogLSAgMFxuICogLSAgMCdcbiAqL1xuZXhwb3J0cy5VTlBSRUZJWEVEX0JJUF8zMl9QQVRIX1JFR0VYID0gL14oPzxpbmRleD5cXGQrKSc/JC91O1xuLyoqXG4gKiBlLmcuXG4gKiAtICBiaXAzMjowXG4gKiAtICBiaXAzMjowJ1xuICovXG5leHBvcnRzLkJJUF8zMl9QQVRIX1JFR0VYID0gL15iaXAzMjpcXGQrJz8kL3U7XG4vKipcbiAqIGUuZy5cbiAqIC0gIHNsaXAxMDowXG4gKiAtICBzbGlwMTA6MCdcbiAqL1xuZXhwb3J0cy5TTElQXzEwX1BBVEhfUkVHRVggPSAvXnNsaXAxMDpcXGQrJz8kL3U7XG4vKipcbiAqIGJpcDM5OjxTUEFDRV9ERUxNSVRFRF9TRUVEX1BIUkFTRT5cbiAqXG4gKiBUaGUgc2VlZCBwaHJhc2UgbXVzdCBjb25zaXN0IG9mIDEyIDw9IDI0IHdvcmRzLlxuICovXG5leHBvcnRzLkJJUF8zOV9QQVRIX1JFR0VYID0gL15iaXAzOTooW2Etel0rKXsxfSggW2Etel0rKXsxMSwyM30kL3U7XG5leHBvcnRzLkJJUF8zMl9IQVJERU5FRF9PRkZTRVQgPSAweDgwMDAwMDAwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1vZCA9IGV4cG9ydHMuZ2V0Q3VydmVCeU5hbWUgPSBleHBvcnRzLmN1cnZlcyA9IHZvaWQgMDtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIkBub2JsZS9zZWNwMjU2azFcIik7XG5jb25zdCBlZDI1NTE5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2VkMjU1MTlcIikpO1xuY29uc3Qgc2VjcDI1NmsxID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NlY3AyNTZrMVwiKSk7XG5leHBvcnRzLmN1cnZlcyA9IHtcbiAgICBzZWNwMjU2azEsXG4gICAgZWQyNTUxOSxcbn07XG4vKipcbiAqIEdldCBhIGN1cnZlIGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIGN1cnZlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjdXJ2ZSB0byBnZXQuXG4gKiBAcmV0dXJucyBUaGUgY3VydmUuXG4gKi9cbmZ1bmN0aW9uIGdldEN1cnZlQnlOYW1lKGN1cnZlTmFtZSkge1xuICAgIHJldHVybiBleHBvcnRzLmN1cnZlc1tjdXJ2ZU5hbWVdO1xufVxuZXhwb3J0cy5nZXRDdXJ2ZUJ5TmFtZSA9IGdldEN1cnZlQnlOYW1lO1xuLy8gQXMgbG9uZyBhcyBib3RoIHBhcmFtZXRlcnMgYXJlIHNwZWNpZmllZCwgdGhpcyBmdW5jdGlvbiBpcyB0aGUgc2FtZSBmb3IgYWxsIGN1cnZlcy5cbmV4cG9ydHMubW9kID0gc2VjcDI1NmsxXzEudXRpbHMubW9kO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29tcHJlc3NQdWJsaWNLZXkgPSBleHBvcnRzLmNvbXByZXNzUHVibGljS2V5ID0gZXhwb3J0cy5wdWJsaWNBZGQgPSBleHBvcnRzLmdldFB1YmxpY0tleSA9IGV4cG9ydHMucHVibGljS2V5TGVuZ3RoID0gZXhwb3J0cy5kZXJpdmVVbmhhcmRlbmVkS2V5cyA9IGV4cG9ydHMuaXNWYWxpZFByaXZhdGVLZXkgPSBleHBvcnRzLnNlY3JldCA9IGV4cG9ydHMubmFtZSA9IGV4cG9ydHMuY3VydmUgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IGVkMjU1MTlfMSA9IHJlcXVpcmUoXCJAbm9ibGUvZWQyNTUxOVwiKTtcbnZhciBlZDI1NTE5XzIgPSByZXF1aXJlKFwiQG5vYmxlL2VkMjU1MTlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjdXJ2ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZWQyNTUxOV8yLkNVUlZFOyB9IH0pO1xuZXhwb3J0cy5uYW1lID0gJ2VkMjU1MTknO1xuLy8gU2VjcmV0IGlzIGRlZmluZWQgaW4gU0xJUC0xMDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXRvc2hpbGFicy9zbGlwcy9ibG9iLzEzM2VhNTJhOGU0M2QzMzhiOThiZTIwODkwN2UxNDQyNzdlNDRjMGUvc2xpcC0wMDEwLm1kI21hc3Rlci1rZXktZ2VuZXJhdGlvblxuZXhwb3J0cy5zZWNyZXQgPSAoMCwgdXRpbHNfMS5zdHJpbmdUb0J5dGVzKSgnZWQyNTUxOSBzZWVkJyk7XG4vLyBBbGwgcHJpdmF0ZSBrZXlzIGFyZSB2YWxpZCBmb3IgZWQyNTUxOTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXRvc2hpbGFicy9zbGlwcy9ibG9iLzEzM2VhNTJhOGU0M2QzMzhiOThiZTIwODkwN2UxNDQyNzdlNDRjMGUvc2xpcC0wMDEwLm1kI21hc3Rlci1rZXktZ2VuZXJhdGlvblxuY29uc3QgaXNWYWxpZFByaXZhdGVLZXkgPSAoX3ByaXZhdGVLZXkpID0+IHRydWU7XG5leHBvcnRzLmlzVmFsaWRQcml2YXRlS2V5ID0gaXNWYWxpZFByaXZhdGVLZXk7XG5leHBvcnRzLmRlcml2ZVVuaGFyZGVuZWRLZXlzID0gZmFsc2U7XG5leHBvcnRzLnB1YmxpY0tleUxlbmd0aCA9IDMzO1xuY29uc3QgZ2V0UHVibGljS2V5ID0gYXN5bmMgKHByaXZhdGVLZXksIF9jb21wcmVzc2VkKSA9PiB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgKDAsIGVkMjU1MTlfMS5nZXRQdWJsaWNLZXkpKHByaXZhdGVLZXkpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW25ldyBVaW50OEFycmF5KFswXSksIHB1YmxpY0tleV0pO1xufTtcbmV4cG9ydHMuZ2V0UHVibGljS2V5ID0gZ2V0UHVibGljS2V5O1xuY29uc3QgcHVibGljQWRkID0gKF9wdWJsaWNLZXksIF90d2VhaykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignRWQyNTUxOSBkb2VzIG5vdCBzdXBwb3J0IHB1YmxpYyBrZXkgZGVyaXZhdGlvbi4nKTtcbn07XG5leHBvcnRzLnB1YmxpY0FkZCA9IHB1YmxpY0FkZDtcbmNvbnN0IGNvbXByZXNzUHVibGljS2V5ID0gKHB1YmxpY0tleSkgPT4ge1xuICAgIC8vIEVkMjU1MTkgcHVibGljIGtleXMgZG9uJ3QgaGF2ZSBhIGNvbXByZXNzZWQgZm9ybS5cbiAgICByZXR1cm4gcHVibGljS2V5O1xufTtcbmV4cG9ydHMuY29tcHJlc3NQdWJsaWNLZXkgPSBjb21wcmVzc1B1YmxpY0tleTtcbmNvbnN0IGRlY29tcHJlc3NQdWJsaWNLZXkgPSAocHVibGljS2V5KSA9PiB7XG4gICAgLy8gRWQyNTUxOSBwdWJsaWMga2V5cyBkb24ndCBoYXZlIGEgY29tcHJlc3NlZCBmb3JtLlxuICAgIHJldHVybiBwdWJsaWNLZXk7XG59O1xuZXhwb3J0cy5kZWNvbXByZXNzUHVibGljS2V5ID0gZGVjb21wcmVzc1B1YmxpY0tleTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkMjU1MTkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVkMjU1MTkgPSBleHBvcnRzLnNlY3AyNTZrMSA9IHZvaWQgMDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jdXJ2ZVwiKSwgZXhwb3J0cyk7XG5leHBvcnRzLnNlY3AyNTZrMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZWNwMjU2azFcIikpO1xuZXhwb3J0cy5lZDI1NTE5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2VkMjU1MTlcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29tcHJlc3NQdWJsaWNLZXkgPSBleHBvcnRzLmNvbXByZXNzUHVibGljS2V5ID0gZXhwb3J0cy5wdWJsaWNBZGQgPSBleHBvcnRzLmdldFB1YmxpY0tleSA9IGV4cG9ydHMuaXNWYWxpZFByaXZhdGVLZXkgPSBleHBvcnRzLnB1YmxpY0tleUxlbmd0aCA9IGV4cG9ydHMuZGVyaXZlVW5oYXJkZW5lZEtleXMgPSBleHBvcnRzLnNlY3JldCA9IGV4cG9ydHMubmFtZSA9IGV4cG9ydHMuY3VydmUgPSB2b2lkIDA7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay91dGlsc1wiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIkBub2JsZS9zZWNwMjU2azFcIik7XG5jb25zdCB1dGlsc18yID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIHNlY3AyNTZrMV8yID0gcmVxdWlyZShcIkBub2JsZS9zZWNwMjU2azFcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjdXJ2ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VjcDI1NmsxXzIuQ1VSVkU7IH0gfSk7XG5leHBvcnRzLm5hbWUgPSAnc2VjcDI1NmsxJztcbi8vIFNlY3JldCBpcyBkZWZpbmVkIGluIEJJUC0zMiBhbmQgU0xJUC0xMDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi8yNzRmYTQwMGQ2MzBiYTc1N2JlYzBjMDNiMzVlYmUyMzQ1MTk3MTA4L2JpcC0wMDMyLm1lZGlhd2lraSNtYXN0ZXIta2V5LWdlbmVyYXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXRvc2hpbGFicy9zbGlwcy9ibG9iLzEzM2VhNTJhOGU0M2QzMzhiOThiZTIwODkwN2UxNDQyNzdlNDRjMGUvc2xpcC0wMDEwLm1kI21hc3Rlci1rZXktZ2VuZXJhdGlvblxuZXhwb3J0cy5zZWNyZXQgPSAoMCwgdXRpbHNfMS5zdHJpbmdUb0J5dGVzKSgnQml0Y29pbiBzZWVkJyk7XG5leHBvcnRzLmRlcml2ZVVuaGFyZGVuZWRLZXlzID0gdHJ1ZTtcbmV4cG9ydHMucHVibGljS2V5TGVuZ3RoID0gNjU7XG5jb25zdCBpc1ZhbGlkUHJpdmF0ZUtleSA9IChwcml2YXRlS2V5KSA9PiB7XG4gICAgcmV0dXJuIHNlY3AyNTZrMV8xLnV0aWxzLmlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpO1xufTtcbmV4cG9ydHMuaXNWYWxpZFByaXZhdGVLZXkgPSBpc1ZhbGlkUHJpdmF0ZUtleTtcbmNvbnN0IGdldFB1YmxpY0tleSA9IChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSA9PiAoMCwgc2VjcDI1NmsxXzEuZ2V0UHVibGljS2V5KShwcml2YXRlS2V5LCBjb21wcmVzc2VkKTtcbmV4cG9ydHMuZ2V0UHVibGljS2V5ID0gZ2V0UHVibGljS2V5O1xuY29uc3QgcHVibGljQWRkID0gKHB1YmxpY0tleSwgdHdlYWspID0+IHtcbiAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCgwLCB1dGlsc18yLmlzVmFsaWRCeXRlc0tleSkodHdlYWssIDMyKSwgJ0ludmFsaWQgdHdlYWs6IFR3ZWFrIG11c3QgYmUgYSBub24temVybyAzMi1ieXRlIFVpbnQ4QXJyYXkuJyk7XG4gICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azFfMS5Qb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgLy8gVGhlIHJldHVybmVkIGNoaWxkIGtleSBLaSBpcyBwb2ludChwYXJzZTI1NihJTCkpICsgS3Bhci5cbiAgICAvLyBUaGlzIG11bHRpcGxpZXMgdGhlIHR3ZWFrIHdpdGggdGhlIGJhc2UgcG9pbnQgb2YgdGhlIGN1cnZlIChHeCwgR3kpLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi8yNzRmYTQwMGQ2MzBiYTc1N2JlYzBjMDNiMzVlYmUyMzQ1MTk3MTA4L2JpcC0wMDMyLm1lZGlhd2lraSNwdWJsaWMtcGFyZW50LWtleS0tcHVibGljLWNoaWxkLWtleVxuICAgIGNvbnN0IG5ld1BvaW50ID0gcG9pbnQuYWRkKHNlY3AyNTZrMV8xLlBvaW50LmZyb21Qcml2YXRlS2V5KHR3ZWFrKSk7XG4gICAgbmV3UG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gbmV3UG9pbnQudG9SYXdCeXRlcyhmYWxzZSk7XG59O1xuZXhwb3J0cy5wdWJsaWNBZGQgPSBwdWJsaWNBZGQ7XG5jb25zdCBjb21wcmVzc1B1YmxpY0tleSA9IChwdWJsaWNLZXkpID0+IHtcbiAgICBjb25zdCBwb2ludCA9IHNlY3AyNTZrMV8xLlBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICByZXR1cm4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKTtcbn07XG5leHBvcnRzLmNvbXByZXNzUHVibGljS2V5ID0gY29tcHJlc3NQdWJsaWNLZXk7XG5jb25zdCBkZWNvbXByZXNzUHVibGljS2V5ID0gKHB1YmxpY0tleSkgPT4ge1xuICAgIC8vIFRoaXMgY2FsY3VsYXRlcyBhIHBvaW50IG9uIHRoZSBlbGxpcHRpYyBjdXJ2ZSBmcm9tIGEgY29tcHJlc3NlZCBwdWJsaWMga2V5LiBXZSBjYW4gdGhlbiB1c2VcbiAgICAvLyB0aGlzIHRvIGdldCB0aGUgdW5jb21wcmVzc2VkIHZlcnNpb24gb2YgdGhlIHB1YmxpYyBrZXkuXG4gICAgY29uc3QgcG9pbnQgPSBzZWNwMjU2azFfMS5Qb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHBvaW50LnRvUmF3Qnl0ZXMoZmFsc2UpO1xufTtcbmV4cG9ydHMuZGVjb21wcmVzc1B1YmxpY0tleSA9IGRlY29tcHJlc3NQdWJsaWNLZXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlUGF0aFNlZ21lbnQgPSBleHBvcnRzLmRlcml2ZUtleUZyb21QYXRoID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBCSVA0NENvaW5UeXBlTm9kZV8xID0gcmVxdWlyZShcIi4vQklQNDRDb2luVHlwZU5vZGVcIik7XG5jb25zdCBCSVA0NE5vZGVfMSA9IHJlcXVpcmUoXCIuL0JJUDQ0Tm9kZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgY3VydmVzXzEgPSByZXF1aXJlKFwiLi9jdXJ2ZXNcIik7XG5jb25zdCBkZXJpdmVyc18xID0gcmVxdWlyZShcIi4vZGVyaXZlcnNcIik7XG5jb25zdCBTTElQMTBOb2RlXzEgPSByZXF1aXJlKFwiLi9TTElQMTBOb2RlXCIpO1xuLyoqXG4gKiBUYWtlcyBhIGZ1bGwgb3IgcGFydGlhbCBIRCBwYXRoIHN0cmluZyBhbmQgcmV0dXJucyB0aGUga2V5IGNvcnJlc3BvbmRpbmcgdG9cbiAqIHRoZSBnaXZlbiBwYXRoLCB3aXRoIHRoZSBmb2xsb3dpbmcgY29uc3RyYWludHM6XG4gKlxuICogLSBJZiB0aGUgcGF0aCBzdGFydHMgd2l0aCBhIEJJUC0zMiBub2RlLCBhIHBhcmVudCBrZXkgbXVzdCBiZSBwcm92aWRlZC5cbiAqIC0gSWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYSBCSVAtMzkgbm9kZSwgYSBwYXJlbnQga2V5IG11c3QgTk9UIGJlIHByb3ZpZGVkLlxuICogLSBUaGUgcGF0aCBjYW5ub3QgZXhjZWVkIDUgQklQLTMyIG5vZGVzIGluIGxlbmd0aCwgb3B0aW9uYWxseSBwcmVjZWRlZCBieVxuICogYSBzaW5nbGUgQklQLTM5IG5vZGUuXG4gKlxuICogV0FSTklORzogSXQgaXMgdGhlIGNvbnN1bWVyJ3MgcmVzcG9uc2liaWxpdHkgdG8gZW5zdXJlIHRoYXQgdGhlIHBhdGggaXMgdmFsaWRcbiAqIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQga2V5LlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgZGVyaXZpbmcgYSBrZXkgZnJvbSBhIHBhdGguXG4gKiBAcGFyYW0gYXJncy5wYXRoIC0gQSBmdWxsIG9yIHBhcnRpYWwgSEQgcGF0aCwgZS5nLjpcbiAqIGBiaXAzOTpTRUVEX1BIUkFTRS9iaXAzMjo0NCcvYmlwMzI6NjAnL2JpcDMyOjAnL2JpcDMyOjAvYmlwMzI6MGAuXG4gKiBCSVAtMzkgc2VlZCBwaHJhc2VzIG11c3QgYmUgbG93ZXJjYXNlLCBzcGFjZS1kZWxpbWl0ZWQsIGFuZCAxMi0yNCB3b3JkcyBsb25nLlxuICogQHBhcmFtIGFyZ3Mubm9kZSAtIFRoZSBub2RlIHRvIGRlcml2ZSBmcm9tLlxuICogQHBhcmFtIGFyZ3MuZGVwdGggLSBUaGUgZGVwdGggb2YgdGhlIHNlZ21lbnQuXG4gKiBAcmV0dXJucyBUaGUgZGVyaXZlZCBrZXkuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlcml2ZUtleUZyb21QYXRoKGFyZ3MpIHtcbiAgICBjb25zdCB7IHBhdGgsIGRlcHRoID0gcGF0aC5sZW5ndGggfSA9IGFyZ3M7XG4gICAgY29uc3Qgbm9kZSA9ICdub2RlJyBpbiBhcmdzID8gYXJncy5ub2RlIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGN1cnZlID0gJ2N1cnZlJyBpbiBhcmdzID8gYXJncy5jdXJ2ZSA6IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5jdXJ2ZTtcbiAgICBpZiAobm9kZSAmJlxuICAgICAgICAhKG5vZGUgaW5zdGFuY2VvZiBTTElQMTBOb2RlXzEuU0xJUDEwTm9kZSkgJiZcbiAgICAgICAgIShub2RlIGluc3RhbmNlb2YgQklQNDROb2RlXzEuQklQNDROb2RlKSAmJlxuICAgICAgICAhKG5vZGUgaW5zdGFuY2VvZiBCSVA0NENvaW5UeXBlTm9kZV8xLkJJUDQ0Q29pblR5cGVOb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzOiBOb2RlIG11c3QgYmUgYSBTTElQLTEwIG5vZGUgb3IgYSBCSVAtNDQgbm9kZSB3aGVuIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBpZiAoIWN1cnZlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHM6IE11c3Qgc3BlY2lmeSBlaXRoZXIgYSBwYXJlbnQgbm9kZSBvciBjdXJ2ZS4nKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQYXRoU2VnbWVudChwYXRoLCBCb29sZWFuKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5wcml2YXRlS2V5KSB8fCBCb29sZWFuKG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS5wdWJsaWNLZXkpLCBkZXB0aCk7XG4gICAgLy8gRGVyaXZlIHRocm91Z2ggZWFjaCBwYXJ0IG9mIHBhdGguIGBwYXRoU2VnbWVudGAgbmVlZHMgdG8gYmUgY2FzdCBiZWNhdXNlXG4gICAgLy8gYEhEUGF0aFR1cGxlLnJlZHVjZSgpYCBkb2Vzbid0IHdvcmsuIE5vdGUgdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGVcbiAgICAvLyBwYXRoIGNhbiBiZSBhIFVpbnQ4QXJyYXkuXG4gICAgcmV0dXJuIGF3YWl0IHBhdGgucmVkdWNlKGFzeW5jIChwcm9taXNlLCBwYXRoTm9kZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgZGVyaXZlZE5vZGUgPSBhd2FpdCBwcm9taXNlO1xuICAgICAgICBpZiAodHlwZW9mIHBhdGhOb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgW3BhdGhUeXBlLCBwYXRoUGFydF0gPSBwYXRoTm9kZS5zcGxpdCgnOicpO1xuICAgICAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShoYXNEZXJpdmVyKHBhdGhUeXBlKSwgYFVua25vd24gZGVyaXZhdGlvbiB0eXBlOiBcIiR7cGF0aFR5cGV9XCIuYCk7XG4gICAgICAgICAgICBjb25zdCBkZXJpdmVyID0gZGVyaXZlcnNfMS5kZXJpdmVyc1twYXRoVHlwZV07XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZGVyaXZlci5kZXJpdmVDaGlsZEtleSh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aFBhcnQsXG4gICAgICAgICAgICAgICAgbm9kZTogZGVyaXZlZE5vZGUsXG4gICAgICAgICAgICAgICAgY3VydmU6ICgwLCBjdXJ2ZXNfMS5nZXRDdXJ2ZUJ5TmFtZSkoY3VydmUpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSB0aGUgZmlyc3QgcGF0aCBzZWdtZW50IGNhbiBiZSBhIFVpbnQ4QXJyYXkuXG4gICAgICAgICgwLCB1dGlsc18xLmFzc2VydCkoaW5kZXggPT09IDAsIGdldE1hbGZvcm1lZEVycm9yKCkpO1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVyaXZlcnNfMS5kZXJpdmVycy5iaXAzOS5kZXJpdmVDaGlsZEtleSh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoTm9kZSxcbiAgICAgICAgICAgIG5vZGU6IGRlcml2ZWROb2RlLFxuICAgICAgICAgICAgY3VydmU6ICgwLCBjdXJ2ZXNfMS5nZXRDdXJ2ZUJ5TmFtZSkoY3VydmUpLFxuICAgICAgICB9KTtcbiAgICB9LCBQcm9taXNlLnJlc29sdmUobm9kZSkpO1xufVxuZXhwb3J0cy5kZXJpdmVLZXlGcm9tUGF0aCA9IGRlcml2ZUtleUZyb21QYXRoO1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gcGF0aCB0eXBlIGlzIGEgdmFsaWQgZGVyaXZlci5cbiAqXG4gKiBAcGFyYW0gcGF0aFR5cGUgLSBUaGUgcGF0aCB0eXBlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgcGF0aCB0eXBlIGlzIGEgdmFsaWQgZGVyaXZlci5cbiAqL1xuZnVuY3Rpb24gaGFzRGVyaXZlcihwYXRoVHlwZSkge1xuICAgIHJldHVybiBwYXRoVHlwZSBpbiBkZXJpdmVyc18xLmRlcml2ZXJzO1xufVxuLyoqXG4gKiBUaGUgcGF0aCBzZWdtZW50IG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gKiAtIEEgbG9uZSBCSVAtMzIgcGF0aCBub2RlLlxuICogLSBBIGxvbmUgQklQLTM5IHBhdGggbm9kZS5cbiAqIC0gQSBtdWx0aXBhdGguXG4gKlxuICogQHBhcmFtIHBhdGggLSBUaGUgcGF0aCBzZWdtZW50IHN0cmluZyB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBoYXNLZXkgLSBXaGV0aGVyIHRoZSBwYXRoIHNlZ21lbnQgaGFzIGEga2V5LlxuICogQHBhcmFtIGRlcHRoIC0gVGhlIGRlcHRoIG9mIHRoZSBzZWdtZW50LlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVBhdGhTZWdtZW50KHBhdGgsIGhhc0tleSwgZGVwdGgpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEhEIHBhdGggc2VnbWVudDogVGhlIHNlZ21lbnQgbXVzdCBub3QgYmUgZW1wdHkuYCk7XG4gICAgfVxuICAgIGxldCBzdGFydHNXaXRoQmlwMzkgPSBmYWxzZTtcbiAgICBwYXRoLmZvckVhY2goKG5vZGUsIGluZGV4KSA9PiB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgc3RhcnRzV2l0aEJpcDM5ID1cbiAgICAgICAgICAgICAgICBub2RlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBjb25zdGFudHNfMS5CSVBfMzlfUEFUSF9SRUdFWC50ZXN0KG5vZGUpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBpcyB1bmFibGUgdG8gaW5mZXIgdGhhdCBgbm9kZWAgaXMgYSBzdHJpbmcgaGVyZSwgc28gd2VcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gZXhwbGljaXRseSBjaGVjayBpdCBhZ2Fpbi5cbiAgICAgICAgICAgICEobm9kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICYmXG4gICAgICAgICAgICAgICAgIXN0YXJ0c1dpdGhCaXAzOSAmJlxuICAgICAgICAgICAgICAgICFjb25zdGFudHNfMS5CSVBfMzJfUEFUSF9SRUdFWC50ZXN0KG5vZGUpICYmXG4gICAgICAgICAgICAgICAgIWNvbnN0YW50c18xLlNMSVBfMTBfUEFUSF9SRUdFWC50ZXN0KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZ2V0TWFsZm9ybWVkRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAgICAgKCFjb25zdGFudHNfMS5CSVBfMzJfUEFUSF9SRUdFWC50ZXN0KG5vZGUpICYmICFjb25zdGFudHNfMS5TTElQXzEwX1BBVEhfUkVHRVgudGVzdChub2RlKSkpIHtcbiAgICAgICAgICAgIHRocm93IGdldE1hbGZvcm1lZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGVwdGggPT09IGNvbnN0YW50c18xLk1JTl9CSVBfNDRfREVQVEggJiYgKCFzdGFydHNXaXRoQmlwMzkgfHwgcGF0aC5sZW5ndGggIT09IDEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBIRCBwYXRoIHNlZ21lbnQ6IFRoZSBzZWdtZW50IG11c3QgY29uc2lzdCBvZiBhIHNpbmdsZSBCSVAtMzkgbm9kZSBmb3IgZGVwdGhzIG9mICR7Y29uc3RhbnRzXzEuTUlOX0JJUF80NF9ERVBUSH0uIFJlY2VpdmVkOiBcIiR7U3RyaW5nKHBhdGgpfVwiLmApO1xuICAgIH1cbiAgICBpZiAoIWhhc0tleSAmJiAhc3RhcnRzV2l0aEJpcDM5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXJpdmF0aW9uIHBhcmFtZXRlcnM6IE11c3Qgc3BlY2lmeSBwYXJlbnQga2V5IGlmIHRoZSBmaXJzdCBub2RlIG9mIHRoZSBwYXRoIHNlZ21lbnQgaXMgbm90IGEgQklQLTM5IG5vZGUuJyk7XG4gICAgfVxuICAgIGlmIChoYXNLZXkgJiYgc3RhcnRzV2l0aEJpcDM5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkZXJpdmF0aW9uIHBhcmFtZXRlcnM6IE1heSBub3Qgc3BlY2lmeSBwYXJlbnQga2V5IGlmIHRoZSBwYXRoIHNlZ21lbnQgc3RhcnRzIHdpdGggYSBCSVAtMzkgbm9kZS4nKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aFdpdGhvdXRLZXkgPSAoc3RhcnRzV2l0aEJpcDM5ID8gcGF0aC5zbGljZSgxKSA6IHBhdGgpO1xuICAgIGlmIChwYXRoV2l0aG91dEtleS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0U2VnbWVudFR5cGUgPSBwYXRoV2l0aG91dEtleVswXS5zcGxpdCgnOicpWzBdO1xuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKHBhdGhXaXRob3V0S2V5LmV2ZXJ5KChzZWdtZW50KSA9PiBzZWdtZW50LnN0YXJ0c1dpdGgoYCR7Zmlyc3RTZWdtZW50VHlwZX06YCkpLCBgSW52YWxpZCBIRCBwYXRoIHNlZ21lbnQ6IENhbm5vdCBtaXggJ2JpcDMyJyBhbmQgJ3NsaXAxMCcgcGF0aCBzZWdtZW50cy5gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUGF0aFNlZ21lbnQgPSB2YWxpZGF0ZVBhdGhTZWdtZW50O1xuLyoqXG4gKiBHZXQgdGhlIGVycm9yIGZvciBhIG1hbGZvcm1lZCBwYXRoIHNlZ21lbnQuXG4gKlxuICogQHJldHVybnMgVGhlIGVycm9yLlxuICovXG5mdW5jdGlvbiBnZXRNYWxmb3JtZWRFcnJvcigpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkIEhEIHBhdGggc2VnbWVudDogVGhlIHBhdGggc2VnbWVudCBpcyBtYWxmb3JtZWQuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXJpdmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXJpdmVDaGlsZEtleSA9IGV4cG9ydHMucHVibGljS2V5VG9FdGhBZGRyZXNzID0gZXhwb3J0cy5wcml2YXRlS2V5VG9FdGhBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBzaGEzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgY3VydmVzXzEgPSByZXF1aXJlKFwiLi4vY3VydmVzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IHNoYXJlZF8xID0gcmVxdWlyZShcIi4vc2hhcmVkXCIpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIEJJUC0zMiBwcml2YXRlIGtleSB0byBhbiBFdGhlcmV1bSBhZGRyZXNzLlxuICpcbiAqICoqV0FSTklORzoqKiBPbmx5IHZhbGlkYXRlcyB0aGF0IHRoZSBrZXkgaXMgbm9uLXplcm8gYW5kIG9mIHRoZSBjb3JyZWN0XG4gKiBsZW5ndGguIEl0IGlzIHRoZSBjb25zdW1lcidzIHJlc3BvbnNpYmlsaXR5IHRvIGVuc3VyZSB0aGF0IHRoZSBzcGVjaWZpZWRcbiAqIGtleSBpcyBhIHZhbGlkIEJJUC00NCBFdGhlcmV1bSBgYWRkcmVzc19pbmRleGAga2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUgYGFkZHJlc3NfaW5kZXhgIHByaXZhdGUga2V5IGJ5dGVzIHRvIGNvbnZlcnQgdG8gYW4gRXRoZXJldW1cbiAqIGFkZHJlc3MuXG4gKiBAcmV0dXJucyBUaGUgRXRoZXJldW0gYWRkcmVzcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBrZXkuXG4gKi9cbmZ1bmN0aW9uIHByaXZhdGVLZXlUb0V0aEFkZHJlc3Moa2V5KSB7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmICgwLCB1dGlsc18yLmlzVmFsaWRCeXRlc0tleSkoa2V5LCBjb25zdGFudHNfMS5CWVRFU19LRVlfTEVOR1RIKSwgJ0ludmFsaWQga2V5OiBUaGUga2V5IG11c3QgYmUgYSAzMi1ieXRlLCBub24temVybyBVaW50OEFycmF5LicpO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGN1cnZlc18xLnNlY3AyNTZrMS5nZXRQdWJsaWNLZXkoa2V5LCBmYWxzZSk7XG4gICAgcmV0dXJuIHB1YmxpY0tleVRvRXRoQWRkcmVzcyhwdWJsaWNLZXkpO1xufVxuZXhwb3J0cy5wcml2YXRlS2V5VG9FdGhBZGRyZXNzID0gcHJpdmF0ZUtleVRvRXRoQWRkcmVzcztcbi8qKlxuICogQ29udmVydHMgYSBCSVAtMzIgcHVibGljIGtleSB0byBhbiBFdGhlcmV1bSBhZGRyZXNzLlxuICpcbiAqICoqV0FSTklORzoqKiBPbmx5IHZhbGlkYXRlcyB0aGF0IHRoZSBrZXkgaXMgbm9uLXplcm8gYW5kIG9mIHRoZSBjb3JyZWN0XG4gKiBsZW5ndGguIEl0IGlzIHRoZSBjb25zdW1lcidzIHJlc3BvbnNpYmlsaXR5IHRvIGVuc3VyZSB0aGF0IHRoZSBzcGVjaWZpZWRcbiAqIGtleSBpcyBhIHZhbGlkIEJJUC00NCBFdGhlcmV1bSBgYWRkcmVzc19pbmRleGAga2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgLSBUaGUgYGFkZHJlc3NfaW5kZXhgIHB1YmxpYyBrZXkgYnl0ZXMgdG8gY29udmVydCB0byBhbiBFdGhlcmV1bVxuICogYWRkcmVzcy5cbiAqIEByZXR1cm5zIFRoZSBFdGhlcmV1bSBhZGRyZXNzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGtleS5cbiAqL1xuZnVuY3Rpb24gcHVibGljS2V5VG9FdGhBZGRyZXNzKGtleSkge1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkoa2V5IGluc3RhbmNlb2YgVWludDhBcnJheSAmJlxuICAgICAgICAoMCwgdXRpbHNfMi5pc1ZhbGlkQnl0ZXNLZXkpKGtleSwgY3VydmVzXzEuc2VjcDI1NmsxLnB1YmxpY0tleUxlbmd0aCksICdJbnZhbGlkIGtleTogVGhlIGtleSBtdXN0IGJlIGEgNjUtYnl0ZSwgbm9uLXplcm8gVWludDhBcnJheS4nKTtcbiAgICByZXR1cm4gKDAsIHNoYTNfMS5rZWNjYWtfMjU2KShrZXkuc2xpY2UoMSkpLnNsaWNlKC0yMCk7XG59XG5leHBvcnRzLnB1YmxpY0tleVRvRXRoQWRkcmVzcyA9IHB1YmxpY0tleVRvRXRoQWRkcmVzcztcbi8qKlxuICogRGVyaXZlIGEgQklQLTMyIGNoaWxkIGtleSB3aXRoIGEgZ2l2ZW4gcGF0aCBmcm9tIGEgcGFyZW50IGtleS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBkZXJpdmluZyBhIGNoaWxkIGtleS5cbiAqIEBwYXJhbSBvcHRpb25zLnBhdGggLSBUaGUgZGVyaXZhdGlvbiBwYXRoIHBhcnQgdG8gZGVyaXZlLlxuICogQHBhcmFtIG9wdGlvbnMubm9kZSAtIFRoZSBub2RlIHRvIGRlcml2ZSBmcm9tLlxuICogQHBhcmFtIG9wdGlvbnMuY3VydmUgLSBUaGUgY3VydmUgdG8gdXNlIGZvciBkZXJpdmF0aW9uLlxuICogQHJldHVybnMgVGhlIGRlcml2ZWQgY2hpbGQga2V5IGFzIGEge0BsaW5rIFNMSVAxME5vZGV9LlxuICovXG5hc3luYyBmdW5jdGlvbiBkZXJpdmVDaGlsZEtleShvcHRpb25zKSB7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShvcHRpb25zLmN1cnZlLm5hbWUgPT09ICdzZWNwMjU2azEnLCAnSW52YWxpZCBjdXJ2ZTogT25seSBzZWNwMjU2azEgaXMgc3VwcG9ydGVkIGJ5IEJJUC0zMi4nKTtcbiAgICByZXR1cm4gKDAsIHNoYXJlZF8xLmRlcml2ZUNoaWxkS2V5KShvcHRpb25zLCBoYW5kbGVFcnJvcik7XG59XG5leHBvcnRzLmRlcml2ZUNoaWxkS2V5ID0gZGVyaXZlQ2hpbGRLZXk7XG4vKipcbiAqIEhhbmRsZXMgYW4gZXJyb3IgdGhyb3duIGR1cmluZyBkZXJpdmF0aW9uIGJ5IGluY3JlbWVudGluZyB0aGUgY2hpbGQgaW5kZXhcbiAqIGFuZCByZXRyeWluZy5cbiAqXG4gKiBAcGFyYW0gXyAtIFRoZSBlcnJvciB0aGF0IHdhcyB0aHJvd24uXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBkZXJpdmluZyBhIGNoaWxkIGtleS5cbiAqIEByZXR1cm5zIFRoZSBvcHRpb25zIGZvciBkZXJpdmluZyBhIGNoaWxkIGtleSB3aXRoIHRoZSBjaGlsZCBpbmRleFxuICogaW5jcmVtZW50ZWQgYnkgb25lLlxuICovXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVFcnJvcihfLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGlsZEluZGV4LCBwcml2YXRlS2V5LCBwdWJsaWNLZXksIGlzSGFyZGVuZWQsIGN1cnZlLCBjaGFpbkNvZGUgfSA9IG9wdGlvbnM7XG4gICAgKDAsIHV0aWxzXzIudmFsaWRhdGVCSVAzMkluZGV4KShjaGlsZEluZGV4ICsgMSk7XG4gICAgaWYgKHByaXZhdGVLZXkpIHtcbiAgICAgICAgY29uc3Qgc2VjcmV0RXh0ZW5zaW9uID0gYXdhaXQgKDAsIHNoYXJlZF8xLmRlcml2ZVNlY3JldEV4dGVuc2lvbikoe1xuICAgICAgICAgICAgcHJpdmF0ZUtleSxcbiAgICAgICAgICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXggKyAxLFxuICAgICAgICAgICAgaXNIYXJkZW5lZCxcbiAgICAgICAgICAgIGN1cnZlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3RW50cm9weSA9ICgwLCBzaGFyZWRfMS5nZW5lcmF0ZUVudHJvcHkpKHtcbiAgICAgICAgICAgIGNoYWluQ29kZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbjogc2VjcmV0RXh0ZW5zaW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgY2hpbGRJbmRleDogY2hpbGRJbmRleCArIDEsIGVudHJvcHk6IG5ld0VudHJvcHkgfSk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0V4dGVuc2lvbiA9ICgwLCBzaGFyZWRfMS5kZXJpdmVQdWJsaWNFeHRlbnNpb24pKHtcbiAgICAgICAgcGFyZW50UHVibGljS2V5OiBwdWJsaWNLZXksXG4gICAgICAgIGNoaWxkSW5kZXg6IGNoaWxkSW5kZXggKyAxLFxuICAgIH0pO1xuICAgIGNvbnN0IG5ld0VudHJvcHkgPSAoMCwgc2hhcmVkXzEuZ2VuZXJhdGVFbnRyb3B5KSh7XG4gICAgICAgIGNoYWluQ29kZSxcbiAgICAgICAgZXh0ZW5zaW9uOiBwdWJsaWNFeHRlbnNpb24sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgY2hpbGRJbmRleDogY2hpbGRJbmRleCArIDEsIGVudHJvcHk6IG5ld0VudHJvcHkgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaXAzMi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmlwMzlLZXlGcm9tU2VlZCA9IGV4cG9ydHMuZGVyaXZlQ2hpbGRLZXkgPSBleHBvcnRzLmJpcDM5TW5lbW9uaWNUb011bHRpcGF0aCA9IHZvaWQgMDtcbmNvbnN0IHNjdXJlX2JpcDM5XzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3NjdXJlLWJpcDM5XCIpO1xuY29uc3QgZW5nbGlzaF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zY3VyZS1iaXAzOS9kaXN0L3dvcmRsaXN0cy9lbmdsaXNoXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBobWFjXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9obWFjXCIpO1xuY29uc3Qgc2hhNTEyXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGE1MTJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBTTElQMTBOb2RlXzEgPSByZXF1aXJlKFwiLi4vU0xJUDEwTm9kZVwiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG4vKipcbiAqIENvbnZlcnQgYSBCSVAtMzkgbW5lbW9uaWMgcGhyYXNlIHRvIGEgbXVsdGkgcGF0aC5cbiAqXG4gKiBAcGFyYW0gbW5lbW9uaWMgLSBUaGUgQklQLTM5IG1uZW1vbmljIHBocmFzZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIG11bHRpIHBhdGguXG4gKi9cbmZ1bmN0aW9uIGJpcDM5TW5lbW9uaWNUb011bHRpcGF0aChtbmVtb25pYykge1xuICAgIHJldHVybiBgYmlwMzk6JHttbmVtb25pYy50b0xvd2VyQ2FzZSgpLnRyaW0oKX1gO1xufVxuZXhwb3J0cy5iaXAzOU1uZW1vbmljVG9NdWx0aXBhdGggPSBiaXAzOU1uZW1vbmljVG9NdWx0aXBhdGg7XG4vKipcbiAqIENyZWF0ZSBhIHtAbGluayBTTElQMTBOb2RlfSBmcm9tIGEgQklQLTM5IG1uZW1vbmljIHBocmFzZS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgbm9kZS5cbiAqIEBwYXJhbSBvcHRpb25zLnBhdGggLSBUaGUgbXVsdGkgcGF0aC5cbiAqIEBwYXJhbSBvcHRpb25zLmN1cnZlIC0gVGhlIGN1cnZlIHRvIHVzZSBmb3IgZGVyaXZhdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBub2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBkZXJpdmVDaGlsZEtleSh7IHBhdGgsIGN1cnZlLCB9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJpcDM5S2V5RnJvbVNlZWQoYXdhaXQgKDAsIHNjdXJlX2JpcDM5XzEubW5lbW9uaWNUb1NlZWQpKHBhdGgsIGVuZ2xpc2hfMS53b3JkbGlzdCksIGN1cnZlKTtcbn1cbmV4cG9ydHMuZGVyaXZlQ2hpbGRLZXkgPSBkZXJpdmVDaGlsZEtleTtcbi8qKlxuICogQ3JlYXRlIGEge0BsaW5rIFNMSVAxME5vZGV9IGZyb20gYSBCSVAtMzkgc2VlZC5cbiAqXG4gKiBAcGFyYW0gc2VlZCAtIFRoZSBjcnlwdG9ncmFwaGljIHNlZWQgYnl0ZXMuXG4gKiBAcGFyYW0gY3VydmUgLSBUaGUgY3VydmUgdG8gdXNlLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvcnJlc3BvbmRpbmcgQklQLTM5IG1hc3RlciBrZXkgYW5kIGNoYWluXG4gKiBjb2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVCaXAzOUtleUZyb21TZWVkKHNlZWQsIGN1cnZlKSB7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KShzZWVkLmxlbmd0aCA+PSAxNiAmJiBzZWVkLmxlbmd0aCA8PSA2NCwgJ0ludmFsaWQgc2VlZDogVGhlIHNlZWQgbXVzdCBiZSBiZXR3ZWVuIDE2IGFuZCA2NCBieXRlcyBsb25nLicpO1xuICAgIGNvbnN0IGtleSA9ICgwLCBobWFjXzEuaG1hYykoc2hhNTEyXzEuc2hhNTEyLCBjdXJ2ZS5zZWNyZXQsIHNlZWQpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSBrZXkuc2xpY2UoMCwgY29uc3RhbnRzXzEuQllURVNfS0VZX0xFTkdUSCk7XG4gICAgY29uc3QgY2hhaW5Db2RlID0ga2V5LnNsaWNlKGNvbnN0YW50c18xLkJZVEVTX0tFWV9MRU5HVEgpO1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkoY3VydmUuaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSksICdJbnZhbGlkIHByaXZhdGUga2V5OiBUaGUgcHJpdmF0ZSBrZXkgbXVzdCBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIHRoZSBjdXJ2ZSBvcmRlci4nKTtcbiAgICBjb25zdCBtYXN0ZXJGaW5nZXJwcmludCA9ICgwLCB1dGlsc18yLmdldEZpbmdlcnByaW50KShhd2FpdCBjdXJ2ZS5nZXRQdWJsaWNLZXkocHJpdmF0ZUtleSwgdHJ1ZSkpO1xuICAgIHJldHVybiBTTElQMTBOb2RlXzEuU0xJUDEwTm9kZS5mcm9tRXh0ZW5kZWRLZXkoe1xuICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICBjaGFpbkNvZGUsXG4gICAgICAgIG1hc3RlckZpbmdlcnByaW50LFxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgcGFyZW50RmluZ2VycHJpbnQ6IDAsXG4gICAgICAgIGluZGV4OiAwLFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlQmlwMzlLZXlGcm9tU2VlZCA9IGNyZWF0ZUJpcDM5S2V5RnJvbVNlZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaXAzOS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXJpdmVycyA9IHZvaWQgMDtcbmNvbnN0IGJpcDMyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpcDMyXCIpKTtcbmNvbnN0IGJpcDM5ID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL2JpcDM5XCIpKTtcbmNvbnN0IHNsaXAxMCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zbGlwMTBcIikpO1xuZXhwb3J0cy5kZXJpdmVycyA9IHtcbiAgICBiaXAzMixcbiAgICBiaXAzOSxcbiAgICBzbGlwMTAsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZhbGlkYXRlTm9kZSA9IGV4cG9ydHMuZ2VuZXJhdGVFbnRyb3B5ID0gZXhwb3J0cy5wcml2YXRlQWRkID0gZXhwb3J0cy5kZXJpdmVQdWJsaWNDaGlsZEtleSA9IGV4cG9ydHMuZGVyaXZlUHVibGljRXh0ZW5zaW9uID0gZXhwb3J0cy5kZXJpdmVTZWNyZXRFeHRlbnNpb24gPSBleHBvcnRzLmRlcml2ZUNoaWxkS2V5ID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBobWFjXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9obWFjXCIpO1xuY29uc3Qgc2hhNTEyXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGE1MTJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBjdXJ2ZXNfMSA9IHJlcXVpcmUoXCIuLi9jdXJ2ZXNcIik7XG5jb25zdCBTTElQMTBOb2RlXzEgPSByZXF1aXJlKFwiLi4vU0xJUDEwTm9kZVwiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG4vKipcbiAqIERlcml2ZSBhIEJJUC0zMiBvciBTTElQLTEwIGNoaWxkIGtleSB3aXRoIGEgZ2l2ZW4gcGF0aCBmcm9tIGEgcGFyZW50IGtleS5cbiAqXG4gKiBTaW5jZSBCSVAtMzIgYW5kIFNMSVAtMTAgYXJlIHZlcnkgc2ltaWxhciwgdGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0b1xuICogZGVyaXZlIGJvdGggdHlwZXMgb2Yga2V5cy5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBkZXJpdmluZyBhIGNoaWxkIGtleS5cbiAqIEBwYXJhbSBvcHRpb25zLnBhdGggLSBUaGUgZGVyaXZhdGlvbiBwYXRoIHBhcnQgdG8gZGVyaXZlLlxuICogQHBhcmFtIG9wdGlvbnMubm9kZSAtIFRoZSBub2RlIHRvIGRlcml2ZSBmcm9tLlxuICogQHBhcmFtIG9wdGlvbnMuY3VydmUgLSBUaGUgY3VydmUgdG8gdXNlIGZvciBkZXJpdmF0aW9uLlxuICogQHBhcmFtIGhhbmRsZUVycm9yIC0gQSBmdW5jdGlvbiB0aGF0IGNhbiBoYW5kbGUgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nXG4gKiBkZXJpdmF0aW9uLlxuICogQHJldHVybnMgVGhlIGRlcml2ZWQgbm9kZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVyaXZlQ2hpbGRLZXkoeyBwYXRoLCBub2RlLCBjdXJ2ZSB9LCBoYW5kbGVFcnJvcikge1xuICAgIHZhbGlkYXRlTm9kZShub2RlKTtcbiAgICBjb25zdCB7IGNoaWxkSW5kZXgsIGlzSGFyZGVuZWQgfSA9IGdldFZhbGlkYXRlZFBhdGgocGF0aCwgbm9kZSwgY3VydmUpO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIGNoYWluQ29kZTogbm9kZS5jaGFpbkNvZGVCeXRlcyxcbiAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgaXNIYXJkZW5lZCxcbiAgICAgICAgZGVwdGg6IG5vZGUuZGVwdGgsXG4gICAgICAgIHBhcmVudEZpbmdlcnByaW50OiBub2RlLmZpbmdlcnByaW50LFxuICAgICAgICBtYXN0ZXJGaW5nZXJwcmludDogbm9kZS5tYXN0ZXJGaW5nZXJwcmludCxcbiAgICAgICAgY3VydmUsXG4gICAgfTtcbiAgICBpZiAobm9kZS5wcml2YXRlS2V5Qnl0ZXMpIHtcbiAgICAgICAgY29uc3Qgc2VjcmV0RXh0ZW5zaW9uID0gYXdhaXQgZGVyaXZlU2VjcmV0RXh0ZW5zaW9uKHtcbiAgICAgICAgICAgIHByaXZhdGVLZXk6IG5vZGUucHJpdmF0ZUtleUJ5dGVzLFxuICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgIGlzSGFyZGVuZWQsXG4gICAgICAgICAgICBjdXJ2ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGVudHJvcHkgPSBnZW5lcmF0ZUVudHJvcHkoe1xuICAgICAgICAgICAgY2hhaW5Db2RlOiBub2RlLmNoYWluQ29kZUJ5dGVzLFxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBzZWNyZXRFeHRlbnNpb24sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgZGVyaXZlTm9kZShPYmplY3QuYXNzaWduKHsgcHJpdmF0ZUtleTogbm9kZS5wcml2YXRlS2V5Qnl0ZXMsIGVudHJvcHkgfSwgYXJncyksIGhhbmRsZUVycm9yKTtcbiAgICB9XG4gICAgY29uc3QgcHVibGljRXh0ZW5zaW9uID0gZGVyaXZlUHVibGljRXh0ZW5zaW9uKHtcbiAgICAgICAgcGFyZW50UHVibGljS2V5OiBub2RlLmNvbXByZXNzZWRQdWJsaWNLZXlCeXRlcyxcbiAgICAgICAgY2hpbGRJbmRleCxcbiAgICB9KTtcbiAgICBjb25zdCBlbnRyb3B5ID0gZ2VuZXJhdGVFbnRyb3B5KHtcbiAgICAgICAgY2hhaW5Db2RlOiBub2RlLmNoYWluQ29kZUJ5dGVzLFxuICAgICAgICBleHRlbnNpb246IHB1YmxpY0V4dGVuc2lvbixcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgZGVyaXZlTm9kZShPYmplY3QuYXNzaWduKHsgcHVibGljS2V5OiBub2RlLmNvbXByZXNzZWRQdWJsaWNLZXlCeXRlcywgZW50cm9weSB9LCBhcmdzKSwgaGFuZGxlRXJyb3IpO1xufVxuZXhwb3J0cy5kZXJpdmVDaGlsZEtleSA9IGRlcml2ZUNoaWxkS2V5O1xuLyoqXG4gKiBEZXJpdmUgYSBTTElQLTEwIGNoaWxkIGtleSBmcm9tIGEgcGFyZW50IGtleS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBkZXJpdmluZyBhIGNoaWxkIGtleS5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUgcHJpdmF0ZSBrZXkgdG8gZGVyaXZlIGZyb20uXG4gKiBAcGFyYW0gb3B0aW9ucy5wdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSB0byBkZXJpdmUgZnJvbS5cbiAqIEBwYXJhbSBvcHRpb25zLmVudHJvcHkgLSBUaGUgZW50cm9weSB0byB1c2UgZm9yIGRlcml2aW5nIHRoZSBjaGlsZCBrZXkuXG4gKiBAcGFyYW0gb3B0aW9ucy5jaGFpbkNvZGUgLSBUaGUgY2hhaW4gY29kZSB0byB1c2UgZm9yIGRlcml2aW5nIHRoZSBjaGlsZCBrZXkuXG4gKiBAcGFyYW0gb3B0aW9ucy5jaGlsZEluZGV4IC0gVGhlIGNoaWxkIGluZGV4IHRvIHVzZSBmb3IgZGVyaXZpbmcgdGhlIGNoaWxkIGtleS5cbiAqIEBwYXJhbSBvcHRpb25zLmlzSGFyZGVuZWQgLSBXaGV0aGVyIHRoZSBjaGlsZCBrZXkgaXMgaGFyZGVuZWQuXG4gKiBAcGFyYW0gb3B0aW9ucy5kZXB0aCAtIFRoZSBkZXB0aCBvZiB0aGUgY2hpbGQga2V5LlxuICogQHBhcmFtIG9wdGlvbnMucGFyZW50RmluZ2VycHJpbnQgLSBUaGUgZmluZ2VycHJpbnQgb2YgdGhlIHBhcmVudCBrZXkuXG4gKiBAcGFyYW0gb3B0aW9ucy5tYXN0ZXJGaW5nZXJwcmludCAtIFRoZSBmaW5nZXJwcmludCBvZiB0aGUgbWFzdGVyIGtleS5cbiAqIEBwYXJhbSBvcHRpb25zLmN1cnZlIC0gVGhlIGN1cnZlIHRvIHVzZSBmb3IgZGVyaXZpbmcgdGhlIGNoaWxkIGtleS5cbiAqIEBwYXJhbSBoYW5kbGVFcnJvciAtIEEgZnVuY3Rpb24gdG8gaGFuZGxlIGVycm9ycyBkdXJpbmcgZGVyaXZhdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBkZXJpdmVkIGNoaWxkIGtleSBhcyB7QGxpbmsgU0xJUDEwTm9kZX0uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlcml2ZU5vZGUob3B0aW9ucywgaGFuZGxlRXJyb3IpIHtcbiAgICBjb25zdCB7IHByaXZhdGVLZXksIHB1YmxpY0tleSwgZW50cm9weSwgY2hpbGRJbmRleCwgaXNIYXJkZW5lZCwgZGVwdGgsIHBhcmVudEZpbmdlcnByaW50LCBtYXN0ZXJGaW5nZXJwcmludCwgY3VydmUsIH0gPSBvcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZGVyaXZlUHJpdmF0ZUNoaWxkS2V5KHtcbiAgICAgICAgICAgICAgICBlbnRyb3B5LFxuICAgICAgICAgICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgICAgICAgbWFzdGVyRmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgY2hpbGRJbmRleCxcbiAgICAgICAgICAgICAgICBpc0hhcmRlbmVkLFxuICAgICAgICAgICAgICAgIGN1cnZlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlcml2ZVB1YmxpY0NoaWxkS2V5KHtcbiAgICAgICAgICAgIGVudHJvcHksXG4gICAgICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICAgIG1hc3RlckZpbmdlcnByaW50LFxuICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICBjaGlsZEluZGV4LFxuICAgICAgICAgICAgY3VydmUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IGRlcml2ZU5vZGUoYXdhaXQgaGFuZGxlRXJyb3IoZXJyb3IsIG9wdGlvbnMpLCBoYW5kbGVFcnJvcik7XG4gICAgfVxufVxuLyoqXG4gKiBEZXJpdmUgYSBCSVAtMzIgc2VjcmV0IGV4dGVuc2lvbiBmcm9tIGEgcGFyZW50IGtleSBhbmQgY2hpbGQgaW5kZXguXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgZGVyaXZpbmcgYSBzZWNyZXQgZXh0ZW5zaW9uLlxuICogQHBhcmFtIG9wdGlvbnMucHJpdmF0ZUtleSAtIFRoZSBwYXJlbnQgcHJpdmF0ZSBrZXkgYnl0ZXMuXG4gKiBAcGFyYW0gb3B0aW9ucy5jaGlsZEluZGV4IC0gVGhlIGNoaWxkIGluZGV4IHRvIGRlcml2ZS5cbiAqIEBwYXJhbSBvcHRpb25zLmlzSGFyZGVuZWQgLSBXaGV0aGVyIHRoZSBjaGlsZCBpbmRleCBpcyBoYXJkZW5lZC5cbiAqIEBwYXJhbSBvcHRpb25zLmN1cnZlIC0gVGhlIGN1cnZlIHRvIHVzZSBmb3IgZGVyaXZhdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBzZWNyZXQgZXh0ZW5zaW9uIGJ5dGVzLlxuICovXG5hc3luYyBmdW5jdGlvbiBkZXJpdmVTZWNyZXRFeHRlbnNpb24oeyBwcml2YXRlS2V5LCBjaGlsZEluZGV4LCBpc0hhcmRlbmVkLCBjdXJ2ZSwgfSkge1xuICAgIGlmIChpc0hhcmRlbmVkKSB7XG4gICAgICAgIC8vIEhhcmRlbmVkIGNoaWxkXG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW1xuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkoWzBdKSxcbiAgICAgICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgICAgICAoMCwgdXRpbHNfMi5udW1iZXJUb1VpbnQzMikoY2hpbGRJbmRleCArIGNvbnN0YW50c18xLkJJUF8zMl9IQVJERU5FRF9PRkZTRVQpLFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgLy8gTm9ybWFsIGNoaWxkXG4gICAgY29uc3QgcGFyZW50UHVibGljS2V5ID0gYXdhaXQgY3VydmUuZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIHRydWUpO1xuICAgIHJldHVybiBkZXJpdmVQdWJsaWNFeHRlbnNpb24oeyBwYXJlbnRQdWJsaWNLZXksIGNoaWxkSW5kZXggfSk7XG59XG5leHBvcnRzLmRlcml2ZVNlY3JldEV4dGVuc2lvbiA9IGRlcml2ZVNlY3JldEV4dGVuc2lvbjtcbi8qKlxuICogRGVyaXZlIGEgQklQLTMyIHB1YmxpYyBleHRlbnNpb24gZnJvbSBhIHBhcmVudCBrZXkgYW5kIGNoaWxkIGluZGV4LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGRlcml2aW5nIGEgcHVibGljIGV4dGVuc2lvbi5cbiAqIEBwYXJhbSBvcHRpb25zLnBhcmVudFB1YmxpY0tleSAtIFRoZSBwYXJlbnQgcHVibGljIGtleSBieXRlcy5cbiAqIEBwYXJhbSBvcHRpb25zLmNoaWxkSW5kZXggLSBUaGUgY2hpbGQgaW5kZXggdG8gZGVyaXZlLlxuICogQHJldHVybnMgVGhlIHB1YmxpYyBleHRlbnNpb24gYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGRlcml2ZVB1YmxpY0V4dGVuc2lvbih7IHBhcmVudFB1YmxpY0tleSwgY2hpbGRJbmRleCwgfSkge1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoW3BhcmVudFB1YmxpY0tleSwgKDAsIHV0aWxzXzIubnVtYmVyVG9VaW50MzIpKGNoaWxkSW5kZXgpXSk7XG59XG5leHBvcnRzLmRlcml2ZVB1YmxpY0V4dGVuc2lvbiA9IGRlcml2ZVB1YmxpY0V4dGVuc2lvbjtcbi8qKlxuICogRGVyaXZlIGEgQklQLTMyIGtleSBmcm9tIGEgcGFyZW50IGtleSBhbmQgc2VjcmV0IGV4dGVuc2lvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBkZXJpdmluZyBhIGtleS5cbiAqIEBwYXJhbSBvcHRpb25zLnByaXZhdGVLZXkgLSBUaGUgcGFyZW50IHByaXZhdGUga2V5IGJ5dGVzLlxuICogQHBhcmFtIG9wdGlvbnMuZW50cm9weSAtIFRoZSBlbnRyb3B5IGJ5dGVzLlxuICogQHBhcmFtIG9wdGlvbnMuY3VydmUgLSBUaGUgY3VydmUgdG8gdXNlIGZvciBkZXJpdmF0aW9uLlxuICogQHJldHVybnMgVGhlIGRlcml2ZWQga2V5LlxuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUtleSh7IHByaXZhdGVLZXksIGVudHJvcHksIGN1cnZlLCB9KSB7XG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSBlbnRyb3B5LnNsaWNlKDAsIDMyKTtcbiAgICBjb25zdCBjaGlsZENoYWluQ29kZSA9IGVudHJvcHkuc2xpY2UoMzIpO1xuICAgIC8vIElmIGN1cnZlIGlzIGVkMjU1MTk6IFRoZSByZXR1cm5lZCBjaGlsZCBrZXkga2kgaXMgcGFyc2UyNTYoSUwpLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zYXRvc2hpbGFicy9zbGlwcy9ibG9iLzEzM2VhNTJhOGU0M2QzMzhiOThiZTIwODkwN2UxNDQyNzdlNDRjMGUvc2xpcC0wMDEwLm1kI3ByaXZhdGUtcGFyZW50LWtleS0tcHJpdmF0ZS1jaGlsZC1rZXlcbiAgICBpZiAoY3VydmUubmFtZSA9PT0gJ2VkMjU1MTknKSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IGN1cnZlLmdldFB1YmxpY0tleShrZXlNYXRlcmlhbCk7XG4gICAgICAgIHJldHVybiB7IHByaXZhdGVLZXk6IGtleU1hdGVyaWFsLCBwdWJsaWNLZXksIGNoYWluQ29kZTogY2hpbGRDaGFpbkNvZGUgfTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRQcml2YXRlS2V5ID0gcHJpdmF0ZUFkZChwcml2YXRlS2V5LCBrZXlNYXRlcmlhbCwgY3VydmUpO1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGF3YWl0IGN1cnZlLmdldFB1YmxpY0tleShjaGlsZFByaXZhdGVLZXkpO1xuICAgIHJldHVybiB7IHByaXZhdGVLZXk6IGNoaWxkUHJpdmF0ZUtleSwgcHVibGljS2V5LCBjaGFpbkNvZGU6IGNoaWxkQ2hhaW5Db2RlIH07XG59XG4vKipcbiAqIERlcml2ZSBhIEJJUC0zMiBwcml2YXRlIGNoaWxkIGtleSB3aXRoIGEgZ2l2ZW4gcGF0aCBmcm9tIGEgcGFyZW50IGtleS5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIGRlcml2aW5nIGEgcHJpdmF0ZSBjaGlsZCBrZXkuXG4gKiBAcGFyYW0gYXJncy5lbnRyb3B5IC0gVGhlIGVudHJvcHkgdG8gdXNlIGZvciBkZXJpdmF0aW9uLlxuICogQHBhcmFtIGFyZ3MucHJpdmF0ZUtleSAtIFRoZSBwYXJlbnQgcHJpdmF0ZSBrZXkgdG8gdXNlIGZvciBkZXJpdmF0aW9uLlxuICogQHBhcmFtIGFyZ3MuZGVwdGggLSBUaGUgZGVwdGggb2YgdGhlIHBhcmVudCBub2RlLlxuICogQHBhcmFtIGFyZ3MubWFzdGVyRmluZ2VycHJpbnQgLSBUaGUgZmluZ2VycHJpbnQgb2YgdGhlIG1hc3RlciBub2RlLlxuICogQHBhcmFtIGFyZ3MucGFyZW50RmluZ2VycHJpbnQgLSBUaGUgZmluZ2VycHJpbnQgb2YgdGhlIHBhcmVudCBub2RlLlxuICogQHBhcmFtIGFyZ3MuY2hpbGRJbmRleCAtIFRoZSBjaGlsZCBpbmRleCB0byBkZXJpdmUuXG4gKiBAcGFyYW0gYXJncy5pc0hhcmRlbmVkIC0gV2hldGhlciB0aGUgY2hpbGQgaW5kZXggaXMgaGFyZGVuZWQuXG4gKiBAcGFyYW0gYXJncy5jdXJ2ZSAtIFRoZSBjdXJ2ZSB0byB1c2UgZm9yIGRlcml2YXRpb24uXG4gKiBAcmV0dXJucyBUaGUgZGVyaXZlZCB7QGxpbmsgU0xJUDEwTm9kZX0uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlcml2ZVByaXZhdGVDaGlsZEtleSh7IGVudHJvcHksIHByaXZhdGVLZXksIGRlcHRoLCBtYXN0ZXJGaW5nZXJwcmludCwgcGFyZW50RmluZ2VycHJpbnQsIGNoaWxkSW5kZXgsIGlzSGFyZGVuZWQsIGN1cnZlLCB9KSB7XG4gICAgY29uc3QgYWN0dWFsQ2hpbGRJbmRleCA9IGNoaWxkSW5kZXggKyAoaXNIYXJkZW5lZCA/IGNvbnN0YW50c18xLkJJUF8zMl9IQVJERU5FRF9PRkZTRVQgOiAwKTtcbiAgICBjb25zdCB7IHByaXZhdGVLZXk6IGNoaWxkUHJpdmF0ZUtleSwgY2hhaW5Db2RlOiBjaGlsZENoYWluQ29kZSB9ID0gYXdhaXQgZ2VuZXJhdGVLZXkoe1xuICAgICAgICBwcml2YXRlS2V5LFxuICAgICAgICBlbnRyb3B5LFxuICAgICAgICBjdXJ2ZSxcbiAgICB9KTtcbiAgICByZXR1cm4gYXdhaXQgU0xJUDEwTm9kZV8xLlNMSVAxME5vZGUuZnJvbUV4dGVuZGVkS2V5KHtcbiAgICAgICAgcHJpdmF0ZUtleTogY2hpbGRQcml2YXRlS2V5LFxuICAgICAgICBjaGFpbkNvZGU6IGNoaWxkQ2hhaW5Db2RlLFxuICAgICAgICBkZXB0aDogZGVwdGggKyAxLFxuICAgICAgICBtYXN0ZXJGaW5nZXJwcmludCxcbiAgICAgICAgcGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgIGluZGV4OiBhY3R1YWxDaGlsZEluZGV4LFxuICAgICAgICBjdXJ2ZTogY3VydmUubmFtZSxcbiAgICB9KTtcbn1cbi8qKlxuICogRGVyaXZlIGEgQklQLTMyIHB1YmxpYyBrZXkgZnJvbSBhIHBhcmVudCBrZXkgYW5kIHB1YmxpYyBleHRlbnNpb24uXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgZGVyaXZpbmcgYSBwdWJsaWMga2V5LlxuICogQHBhcmFtIG9wdGlvbnMucHVibGljS2V5IC0gVGhlIHBhcmVudCBwdWJsaWMga2V5IGJ5dGVzLlxuICogQHBhcmFtIG9wdGlvbnMuZW50cm9weSAtIFRoZSBlbnRyb3B5IGJ5dGVzLlxuICogQHBhcmFtIG9wdGlvbnMuY3VydmUgLSBUaGUgY3VydmUgdG8gdXNlIGZvciBkZXJpdmF0aW9uLlxuICogQHJldHVybnMgVGhlIGRlcml2ZWQgcHVibGljIGtleS5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQdWJsaWNLZXkoeyBwdWJsaWNLZXksIGVudHJvcHksIGN1cnZlLCB9KSB7XG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSBlbnRyb3B5LnNsaWNlKDAsIDMyKTtcbiAgICBjb25zdCBjaGlsZENoYWluQ29kZSA9IGVudHJvcHkuc2xpY2UoMzIpO1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gbWF5IGZhaWwgaWYgdGhlIHJlc3VsdGluZyBrZXkgaXMgaW52YWxpZC5cbiAgICBjb25zdCBjaGlsZFB1YmxpY0tleSA9IGN1cnZlLnB1YmxpY0FkZChwdWJsaWNLZXksIGtleU1hdGVyaWFsKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwdWJsaWNLZXk6IGNoaWxkUHVibGljS2V5LFxuICAgICAgICBjaGFpbkNvZGU6IGNoaWxkQ2hhaW5Db2RlLFxuICAgIH07XG59XG4vKipcbiAqIERlcml2ZSBhIEJJUC0zMiBwdWJsaWMgY2hpbGQga2V5IHdpdGggYSBnaXZlbiBwYXRoIGZyb20gYSBwYXJlbnQga2V5LlxuICpcbiAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyBmb3IgZGVyaXZpbmcgYSBwdWJsaWMgY2hpbGQga2V5LlxuICogQHBhcmFtIGFyZ3MuZW50cm9weSAtIFRoZSBlbnRyb3B5IHRvIHVzZSBmb3IgZGVyaXZhdGlvbi5cbiAqIEBwYXJhbSBhcmdzLnB1YmxpY0tleSAtIFRoZSBwYXJlbnQgcHVibGljIGtleSB0byB1c2UgZm9yIGRlcml2YXRpb24uXG4gKiBAcGFyYW0gYXJncy5kZXB0aCAtIFRoZSBkZXB0aCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gKiBAcGFyYW0gYXJncy5tYXN0ZXJGaW5nZXJwcmludCAtIFRoZSBmaW5nZXJwcmludCBvZiB0aGUgbWFzdGVyIG5vZGUuXG4gKiBAcGFyYW0gYXJncy5wYXJlbnRGaW5nZXJwcmludCAtIFRoZSBmaW5nZXJwcmludCBvZiB0aGUgcGFyZW50IG5vZGUuXG4gKiBAcGFyYW0gYXJncy5jaGlsZEluZGV4IC0gVGhlIGNoaWxkIGluZGV4IHRvIGRlcml2ZS5cbiAqIEBwYXJhbSBhcmdzLmN1cnZlIC0gVGhlIGN1cnZlIHRvIHVzZSBmb3IgZGVyaXZhdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBkZXJpdmVkIHtAbGluayBTTElQMTBOb2RlfS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVyaXZlUHVibGljQ2hpbGRLZXkoeyBlbnRyb3B5LCBwdWJsaWNLZXksIGRlcHRoLCBtYXN0ZXJGaW5nZXJwcmludCwgcGFyZW50RmluZ2VycHJpbnQsIGNoaWxkSW5kZXgsIGN1cnZlLCB9KSB7XG4gICAgY29uc3QgeyBwdWJsaWNLZXk6IGNoaWxkUHVibGljS2V5LCBjaGFpbkNvZGU6IGNoaWxkQ2hhaW5Db2RlIH0gPSBnZW5lcmF0ZVB1YmxpY0tleSh7XG4gICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgZW50cm9weSxcbiAgICAgICAgY3VydmUsXG4gICAgfSk7XG4gICAgcmV0dXJuIGF3YWl0IFNMSVAxME5vZGVfMS5TTElQMTBOb2RlLmZyb21FeHRlbmRlZEtleSh7XG4gICAgICAgIHB1YmxpY0tleTogY2hpbGRQdWJsaWNLZXksXG4gICAgICAgIGNoYWluQ29kZTogY2hpbGRDaGFpbkNvZGUsXG4gICAgICAgIGRlcHRoOiBkZXB0aCArIDEsXG4gICAgICAgIG1hc3RlckZpbmdlcnByaW50LFxuICAgICAgICBwYXJlbnRGaW5nZXJwcmludCxcbiAgICAgICAgaW5kZXg6IGNoaWxkSW5kZXgsXG4gICAgICAgIGN1cnZlOiBjdXJ2ZS5uYW1lLFxuICAgIH0pO1xufVxuZXhwb3J0cy5kZXJpdmVQdWJsaWNDaGlsZEtleSA9IGRlcml2ZVB1YmxpY0NoaWxkS2V5O1xuLyoqXG4gKiBBZGQgYSB0d2VhayB0byB0aGUgcHJpdmF0ZSBrZXk6IGAocHJpdmF0ZUtleSArIHR3ZWFrKSAlIG5gLlxuICpcbiAqIEBwYXJhbSBwcml2YXRlS2V5Qnl0ZXMgLSBUaGUgcHJpdmF0ZSBrZXkgYXMgMzIgYnl0ZSBVaW50OEFycmF5LlxuICogQHBhcmFtIHR3ZWFrQnl0ZXMgLSBUaGUgdHdlYWsgYXMgMzIgYnl0ZSBVaW50OEFycmF5LlxuICogQHBhcmFtIGN1cnZlIC0gVGhlIGN1cnZlIHRvIHVzZS5cbiAqIEB0aHJvd3MgSWYgdGhlIHByaXZhdGUga2V5IG9yIHR3ZWFrIGlzIGludmFsaWQuXG4gKiBAcmV0dXJucyBUaGUgcHJpdmF0ZSBrZXkgd2l0aCB0aGUgdHdlYWsgYWRkZWQgdG8gaXQuXG4gKi9cbmZ1bmN0aW9uIHByaXZhdGVBZGQocHJpdmF0ZUtleUJ5dGVzLCB0d2Vha0J5dGVzLCBjdXJ2ZSkge1xuICAgICgwLCB1dGlsc18xLmFzc2VydCkoKDAsIHV0aWxzXzIuaXNWYWxpZEJ5dGVzS2V5KSh0d2Vha0J5dGVzLCAzMiksICdJbnZhbGlkIHR3ZWFrOiBUd2VhayBtdXN0IGJlIGEgbm9uLXplcm8gMzItYnl0ZSBVaW50OEFycmF5LicpO1xuICAgIGNvbnN0IHByaXZhdGVLZXkgPSAoMCwgdXRpbHNfMS5ieXRlc1RvQmlnSW50KShwcml2YXRlS2V5Qnl0ZXMpO1xuICAgIGNvbnN0IHR3ZWFrID0gKDAsIHV0aWxzXzEuYnl0ZXNUb0JpZ0ludCkodHdlYWtCeXRlcyk7XG4gICAgaWYgKHR3ZWFrID49IGN1cnZlLmN1cnZlLm4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHR3ZWFrOiBUd2VhayBpcyBsYXJnZXIgdGhhbiB0aGUgY3VydmUgb3JkZXIuJyk7XG4gICAgfVxuICAgIGNvbnN0IGFkZGVkID0gKDAsIGN1cnZlc18xLm1vZCkocHJpdmF0ZUtleSArIHR3ZWFrLCBjdXJ2ZS5jdXJ2ZS5uKTtcbiAgICBjb25zdCBieXRlcyA9ICgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKGFkZGVkLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgJzAnKSk7XG4gICAgaWYgKCFjdXJ2ZS5pc1ZhbGlkUHJpdmF0ZUtleShieXRlcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUga2V5IG9yIHR3ZWFrOiBUaGUgcmVzdWx0aW5nIHByaXZhdGUga2V5IGlzIGludmFsaWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydHMucHJpdmF0ZUFkZCA9IHByaXZhdGVBZGQ7XG4vKipcbiAqIEdlbmVyYXRlIDY0IGJ5dGVzIG9mIChkZXRlcm1pbmlzdGljKSBlbnRyb3B5IGZyb20gYSBjaGFpbiBjb2RlIGFuZCBzZWNyZXRcbiAqIGV4dGVuc2lvbi5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgZm9yIGdlbmVyYXRpbmcgZW50cm9weS5cbiAqIEBwYXJhbSBhcmdzLmNoYWluQ29kZSAtIFRoZSBwYXJlbnQgY2hhaW4gY29kZSBieXRlcy5cbiAqIEBwYXJhbSBhcmdzLmV4dGVuc2lvbiAtIFRoZSBleHRlbnNpb24gYnl0ZXMuXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIGVudHJvcHkgYnl0ZXMuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlRW50cm9weSh7IGNoYWluQ29kZSwgZXh0ZW5zaW9uIH0pIHtcbiAgICByZXR1cm4gKDAsIGhtYWNfMS5obWFjKShzaGE1MTJfMS5zaGE1MTIsIGNoYWluQ29kZSwgZXh0ZW5zaW9uKTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVFbnRyb3B5ID0gZ2VuZXJhdGVFbnRyb3B5O1xuLyoqXG4gKiBWYWxpZGF0ZSB0aGF0IGEgbm9kZSBpcyBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byB2YWxpZGF0ZS5cbiAqIEB0aHJvd3MgSWYgdGhlIG5vZGUgaXMgbm90IHNwZWNpZmllZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVOb2RlKG5vZGUpIHtcbiAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKG5vZGUsICdJbnZhbGlkIHBhcmFtZXRlcnM6IE11c3Qgc3BlY2lmeSBhIG5vZGUgdG8gZGVyaXZlIGZyb20uJyk7XG59XG5leHBvcnRzLnZhbGlkYXRlTm9kZSA9IHZhbGlkYXRlTm9kZTtcbi8qKlxuICogVmFsaWRhdGUgYSBwYXRoLlxuICpcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIHZhbGlkYXRlIHRoZSBwYXRoIGFnYWluc3QuXG4gKiBAcGFyYW0gY3VydmUgLSBUaGUgY3VydmUgdG8gdmFsaWRhdGUgdGhlIHBhdGggYWdhaW5zdC5cbiAqIEB0aHJvd3MgSWYgdGhlIHBhdGggaXMgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQYXRoKHBhdGgsIG5vZGUsIGN1cnZlKSB7XG4gICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycsICdJbnZhbGlkIHBhdGg6IE11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgY29uc3QgaXNIYXJkZW5lZCA9IHBhdGguZW5kc1dpdGgoYCdgKTtcbiAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKCFpc0hhcmRlbmVkIHx8IG5vZGUucHJpdmF0ZUtleSwgJ0ludmFsaWQgcGFyYW1ldGVyczogQ2Fubm90IGRlcml2ZSBoYXJkZW5lZCBjaGlsZCBrZXlzIHdpdGhvdXQgYSBwcml2YXRlIGtleS4nKTtcbiAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGlzSGFyZGVuZWQgfHwgY3VydmUuZGVyaXZlVW5oYXJkZW5lZEtleXMsIGBJbnZhbGlkIHBhdGg6IENhbm5vdCBkZXJpdmUgdW5oYXJkZW5lZCBjaGlsZCBrZXlzIHdpdGggJHtjdXJ2ZS5uYW1lfS5gKTtcbn1cbi8qKlxuICogVmFsaWRhdGUgYSBwYXRoIGFuZCByZXR1cm4gdGhlIGNoaWxkIGluZGV4IGFuZCB3aGV0aGVyIGl0IGlzIGhhcmRlbmVkLlxuICpcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIHZhbGlkYXRlIHRoZSBwYXRoIGFnYWluc3QuXG4gKiBAcGFyYW0gY3VydmUgLSBUaGUgY3VydmUgdG8gdmFsaWRhdGUgdGhlIHBhdGggYWdhaW5zdC5cbiAqIEByZXR1cm5zIFRoZSBjaGlsZCBpbmRleCBhbmQgd2hldGhlciBpdCBpcyBoYXJkZW5lZC5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGVkUGF0aChwYXRoLCBub2RlLCBjdXJ2ZSkge1xuICAgIHZhbGlkYXRlUGF0aChwYXRoLCBub2RlLCBjdXJ2ZSk7XG4gICAgY29uc3QgaW5kZXhQYXJ0ID0gcGF0aC5zcGxpdChgJ2ApWzBdO1xuICAgIGNvbnN0IGNoaWxkSW5kZXggPSBwYXJzZUludChpbmRleFBhcnQsIDEwKTtcbiAgICBpZiAoIWNvbnN0YW50c18xLlVOUFJFRklYRURfUEFUSF9SRUdFWC50ZXN0KGluZGV4UGFydCkgfHxcbiAgICAgICAgIU51bWJlci5pc0ludGVnZXIoY2hpbGRJbmRleCkgfHxcbiAgICAgICAgY2hpbGRJbmRleCA8IDAgfHxcbiAgICAgICAgY2hpbGRJbmRleCA+PSBjb25zdGFudHNfMS5CSVBfMzJfSEFSREVORURfT0ZGU0VUKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXRoOiBUaGUgaW5kZXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBkZWNpbWFsIGludGVnZXIgbGVzcyB0aGFuICR7Y29uc3RhbnRzXzEuQklQXzMyX0hBUkRFTkVEX09GRlNFVH0uYCk7XG4gICAgfVxuICAgIHJldHVybiB7IGNoaWxkSW5kZXgsIGlzSGFyZGVuZWQ6IHBhdGguaW5jbHVkZXMoYCdgKSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmVkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXJpdmVDaGlsZEtleSA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL3V0aWxzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IHNoYXJlZF8xID0gcmVxdWlyZShcIi4vc2hhcmVkXCIpO1xuLyoqXG4gKiBEZXJpdmUgYSBTTElQLTEwIGNoaWxkIGtleSB3aXRoIGEgZ2l2ZW4gcGF0aCBmcm9tIGEgcGFyZW50IGtleS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBkZXJpdmluZyBhIGNoaWxkIGtleS5cbiAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyB0aGUgZGVyaXZlZCBwcml2YXRlIGtleSwgcHVibGljIGtleSBhbmQgY2hhaW5cbiAqIGNvZGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlcml2ZUNoaWxkS2V5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXdhaXQgKDAsIHNoYXJlZF8xLmRlcml2ZUNoaWxkS2V5KShvcHRpb25zLCBoYW5kbGVFcnJvcik7XG59XG5leHBvcnRzLmRlcml2ZUNoaWxkS2V5ID0gZGVyaXZlQ2hpbGRLZXk7XG4vKipcbiAqIEhhbmRsZSBhbiBlcnJvciB0aGF0IG9jY3VycyBkdXJpbmcgU0xJUC0xMCBkZXJpdmF0aW9uLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0aGF0IG9jY3VycmVkLlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0aGF0IHdlcmUgdXNlZCBmb3IgZGVyaXZhdGlvbi5cbiAqIEByZXR1cm5zIFRoZSBuZXcgb3B0aW9ucyB0byB1c2UgZm9yIGRlcml2YXRpb24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjdXJ2ZSwgaXNIYXJkZW5lZCwgY2hpbGRJbmRleCwgZW50cm9weSwgY2hhaW5Db2RlIH0gPSBvcHRpb25zO1xuICAgIC8vIGBlZDI1NTE5YCBrZXlzIGFyZSBhbHdheXMgdmFsaWQsIHNvIHRoaXMgZXJyb3Igc2hvdWxkIG5ldmVyIGJlIHRocm93bi4gSWZcbiAgICAvLyBpdCBpcywgd2UgcmUtdGhyb3cgaXQuXG4gICAgaWYgKGN1cnZlLm5hbWUgPT09ICdlZDI1NTE5Jykge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgYWN0dWFsQ2hpbGRJbmRleCA9IGlzSGFyZGVuZWRcbiAgICAgICAgPyBjaGlsZEluZGV4ICsgY29uc3RhbnRzXzEuQklQXzMyX0hBUkRFTkVEX09GRlNFVFxuICAgICAgICA6IGNoaWxkSW5kZXg7XG4gICAgLy8gQXMgcGVyIFNMSVAtMTAsIGlmIHRoZSByZXN1bHRpbmcga2V5IGlzIGludmFsaWQsIHRoZSBuZXcgZW50cm9weSBpc1xuICAgIC8vIGdlbmVyYXRlZCBhcyBmb2xsb3dzOlxuICAgIC8vIEtleSBtYXRlcmlhbCAoMzIgYnl0ZXMpLCBjaGlsZCBjaGFpbiBjb2RlICgzMiBieXRlcykgPVxuICAgIC8vICAgSE1BQy1TSEE1MTIocGFyZW50IGNoYWluIGNvZGUsIDB4MDEgfHwgY2hhaW4gY29kZSBmcm9tIGludmFsaWQga2V5IHx8IGluZGV4KS5cbiAgICBjb25zdCBuZXdFbnRyb3B5ID0gKDAsIHNoYXJlZF8xLmdlbmVyYXRlRW50cm9weSkoe1xuICAgICAgICBjaGFpbkNvZGUsXG4gICAgICAgIGV4dGVuc2lvbjogKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKFtcbiAgICAgICAgICAgIDB4MDEsXG4gICAgICAgICAgICBlbnRyb3B5LnNsaWNlKDMyLCA2NCksXG4gICAgICAgICAgICAoMCwgdXRpbHNfMi5udW1iZXJUb1VpbnQzMikoYWN0dWFsQ2hpbGRJbmRleCksXG4gICAgICAgIF0pLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGVudHJvcHk6IG5ld0VudHJvcHkgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zbGlwMTAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVuY29kZUV4dGVuZGVkS2V5ID0gZXhwb3J0cy5kZWNvZGVFeHRlbmRlZEtleSA9IGV4cG9ydHMuUFJJVkFURV9LRVlfVkVSU0lPTiA9IGV4cG9ydHMuUFVCTElDX0tFWV9WRVJTSU9OID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCBCSVA0NE5vZGVfMSA9IHJlcXVpcmUoXCIuL0JJUDQ0Tm9kZVwiKTtcbmNvbnN0IHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIi4vY3VydmVzL3NlY3AyNTZrMVwiKTtcbmNvbnN0IHV0aWxzXzIgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi8yNzRmYTQwMGQ2MzBiYTc1N2JlYzBjMDNiMzVlYmUyMzQ1MTk3MTA4L2JpcC0wMDMyLm1lZGlhd2lraSNTZXJpYWxpemF0aW9uX2Zvcm1hdFxuZXhwb3J0cy5QVUJMSUNfS0VZX1ZFUlNJT04gPSAweDA0ODhiMjFlO1xuZXhwb3J0cy5QUklWQVRFX0tFWV9WRVJTSU9OID0gMHgwNDg4YWRlNDtcbi8qKlxuICogRGVjb2RlcyBhbiBleHRlbmRlZCBwdWJsaWMgb3IgcHJpdmF0ZSBrZXkuIEluIHRoZSBjYXNlIG9mIGFuIGV4dGVuZGVkIHB1YmxpYyBrZXksIHRoZSBwdWJsaWMga2V5XG4gKiBpcyByZXR1cm5lZCBpbiB0aGUgdW5jb21wcmVzc2VkIGZvcm0uXG4gKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBleHRlbmRlZCBrZXkgaXMgaW52YWxpZC5cbiAqXG4gKiBAcGFyYW0gZXh0ZW5kZWRLZXkgLSBUaGUgZXh0ZW5kZWQga2V5IHN0cmluZyB0byBhdHRlbXB0IHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGV4dGVuZGVkIGtleS5cbiAqL1xuY29uc3QgZGVjb2RlRXh0ZW5kZWRLZXkgPSAoZXh0ZW5kZWRLZXkpID0+IHtcbiAgICBjb25zdCBieXRlcyA9ICgwLCB1dGlsc18yLmRlY29kZUJhc2U1OGNoZWNrKShleHRlbmRlZEtleSk7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gNzgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGV4dGVuZGVkIGtleTogRXhwZWN0ZWQgYSBsZW5ndGggb2YgNzgsIGdvdCAke2J5dGVzLmxlbmd0aH0uYCk7XG4gICAgfVxuICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfMS5jcmVhdGVEYXRhVmlldykoYnl0ZXMpO1xuICAgIGNvbnN0IHZlcnNpb24gPSB2aWV3LmdldFVpbnQzMigwLCBmYWxzZSk7XG4gICAgY29uc3QgZGVwdGggPSB2aWV3LmdldFVpbnQ4KDQpO1xuICAgICgwLCBCSVA0NE5vZGVfMS52YWxpZGF0ZUJJUDQ0RGVwdGgpKGRlcHRoKTtcbiAgICBjb25zdCBwYXJlbnRGaW5nZXJwcmludCA9IHZpZXcuZ2V0VWludDMyKDUsIGZhbHNlKTtcbiAgICBjb25zdCBpbmRleCA9IHZpZXcuZ2V0VWludDMyKDksIGZhbHNlKTtcbiAgICBjb25zdCBjaGFpbkNvZGUgPSBieXRlcy5zbGljZSgxMywgNDUpO1xuICAgIGlmICghKDAsIHV0aWxzXzIuaXNWYWxpZEJ5dGVzS2V5KShjaGFpbkNvZGUsIDMyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXh0ZW5kZWQga2V5OiBDaGFpbiBjb2RlIG11c3QgYmUgYSAzMi1ieXRlIG5vbi16ZXJvIGJ5dGUgYXJyYXkuYCk7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGJ5dGVzLnNsaWNlKDQ1LCA3OCk7XG4gICAgaWYgKCEoMCwgdXRpbHNfMi5pc1ZhbGlkQnl0ZXNLZXkpKGtleSwgMzMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBleHRlbmRlZCBrZXk6IEtleSBtdXN0IGJlIGEgMzMtYnl0ZSBub24temVybyBieXRlIGFycmF5LmApO1xuICAgIH1cbiAgICBjb25zdCBrZXlWaWV3ID0gKDAsIHV0aWxzXzEuY3JlYXRlRGF0YVZpZXcpKGtleSk7XG4gICAgaWYgKHZlcnNpb24gPT09IGV4cG9ydHMuUFVCTElDX0tFWV9WRVJTSU9OKSB7XG4gICAgICAgIGlmIChrZXlWaWV3LmdldFVpbnQ4KDApICE9PSAweDAyICYmIGtleVZpZXcuZ2V0VWludDgoMCkgIT09IDB4MDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBleHRlbmRlZCBrZXk6IFB1YmxpYyBrZXkgbXVzdCBzdGFydCB3aXRoIDB4MDIgb3IgMHgwMy5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgICAgcGFyZW50RmluZ2VycHJpbnQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIGNoYWluQ29kZSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogKDAsIHNlY3AyNTZrMV8xLmRlY29tcHJlc3NQdWJsaWNLZXkpKGtleSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uID09PSBleHBvcnRzLlBSSVZBVEVfS0VZX1ZFUlNJT04pIHtcbiAgICAgICAgaWYgKGtleVZpZXcuZ2V0VWludDgoMCkgIT09IDB4MDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBleHRlbmRlZCBrZXk6IFByaXZhdGUga2V5IG11c3Qgc3RhcnQgd2l0aCAweDAwLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgICBwYXJlbnRGaW5nZXJwcmludCxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgY2hhaW5Db2RlLFxuICAgICAgICAgICAgcHJpdmF0ZUtleToga2V5LnNsaWNlKDEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXh0ZW5kZWQga2V5OiBFeHBlY3RlZCBhIHB1YmxpYyAoeHB1Yikgb3IgcHJpdmF0ZSBrZXkgKHhwcnYpIHZlcnNpb24uYCk7XG59O1xuZXhwb3J0cy5kZWNvZGVFeHRlbmRlZEtleSA9IGRlY29kZUV4dGVuZGVkS2V5O1xuLyoqXG4gKiBFbmNvZGVzIGFuIGV4dGVuZGVkIHB1YmxpYyBvciBwcml2YXRlIGtleS4gQXNzdW1lcyB0aGF0IGFsbCB0aGUgaW5wdXRzIGFyZSB2ZXJpZmllZCBiZWZvcmVoYW5kLlxuICpcbiAqIEBwYXJhbSBleHRlbmRlZEtleSAtIFRoZSBleHRlbmRlZCBrZXkgZGF0YSB0byBlbmNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBleHRlbmRlZCBrZXkuXG4gKi9cbmNvbnN0IGVuY29kZUV4dGVuZGVkS2V5ID0gKGV4dGVuZGVkS2V5KSA9PiB7XG4gICAgY29uc3QgeyB2ZXJzaW9uLCBkZXB0aCwgcGFyZW50RmluZ2VycHJpbnQsIGluZGV4LCBjaGFpbkNvZGUgfSA9IGV4dGVuZGVkS2V5O1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNzgpO1xuICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfMS5jcmVhdGVEYXRhVmlldykoYnl0ZXMpO1xuICAgIHZpZXcuc2V0VWludDMyKDAsIHZlcnNpb24sIGZhbHNlKTtcbiAgICB2aWV3LnNldFVpbnQ4KDQsIGRlcHRoKTtcbiAgICB2aWV3LnNldFVpbnQzMig1LCBwYXJlbnRGaW5nZXJwcmludCwgZmFsc2UpO1xuICAgIHZpZXcuc2V0VWludDMyKDksIGluZGV4LCBmYWxzZSk7XG4gICAgYnl0ZXMuc2V0KGNoYWluQ29kZSwgMTMpO1xuICAgIGlmIChleHRlbmRlZEtleS52ZXJzaW9uID09PSBleHBvcnRzLlBVQkxJQ19LRVlfVkVSU0lPTikge1xuICAgICAgICBjb25zdCB7IHB1YmxpY0tleSB9ID0gZXh0ZW5kZWRLZXk7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWRQdWJsaWNLZXkgPSAoMCwgc2VjcDI1NmsxXzEuY29tcHJlc3NQdWJsaWNLZXkpKHB1YmxpY0tleSk7XG4gICAgICAgIGJ5dGVzLnNldChjb21wcmVzc2VkUHVibGljS2V5LCA0NSk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZEtleS52ZXJzaW9uID09PSBleHBvcnRzLlBSSVZBVEVfS0VZX1ZFUlNJT04pIHtcbiAgICAgICAgY29uc3QgeyBwcml2YXRlS2V5IH0gPSBleHRlbmRlZEtleTtcbiAgICAgICAgYnl0ZXMuc2V0KHByaXZhdGVLZXksIDQ2KTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCB1dGlsc18yLmVuY29kZUJhc2U1OGNoZWNrKShieXRlcyk7XG59O1xuZXhwb3J0cy5lbmNvZGVFeHRlbmRlZEtleSA9IGVuY29kZUV4dGVuZGVkS2V5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXh0ZW5kZWQta2V5cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1ZhbGlkQklQMzJQYXRoU2VnbWVudCA9IGV4cG9ydHMuZ2V0QklQNDRBZGRyZXNzS2V5RGVyaXZlciA9IGV4cG9ydHMuZGVyaXZlQklQNDRBZGRyZXNzS2V5ID0gZXhwb3J0cy5CSVBfNDRfQ09JTl9UWVBFX0RFUFRIID0gZXhwb3J0cy5CSVA0NENvaW5UeXBlTm9kZSA9IGV4cG9ydHMuZWQyNTUxOSA9IGV4cG9ydHMuc2VjcDI1NmsxID0gZXhwb3J0cy5TTElQMTBOb2RlID0gZXhwb3J0cy5CSVA0NE5vZGUgPSB2b2lkIDA7XG52YXIgQklQNDROb2RlXzEgPSByZXF1aXJlKFwiLi9CSVA0NE5vZGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCSVA0NE5vZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJJUDQ0Tm9kZV8xLkJJUDQ0Tm9kZTsgfSB9KTtcbnZhciBTTElQMTBOb2RlXzEgPSByZXF1aXJlKFwiLi9TTElQMTBOb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU0xJUDEwTm9kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU0xJUDEwTm9kZV8xLlNMSVAxME5vZGU7IH0gfSk7XG52YXIgY3VydmVzXzEgPSByZXF1aXJlKFwiLi9jdXJ2ZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZWNwMjU2azFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGN1cnZlc18xLnNlY3AyNTZrMTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVkMjU1MTlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGN1cnZlc18xLmVkMjU1MTk7IH0gfSk7XG52YXIgQklQNDRDb2luVHlwZU5vZGVfMSA9IHJlcXVpcmUoXCIuL0JJUDQ0Q29pblR5cGVOb2RlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQklQNDRDb2luVHlwZU5vZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJJUDQ0Q29pblR5cGVOb2RlXzEuQklQNDRDb2luVHlwZU5vZGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCSVBfNDRfQ09JTl9UWVBFX0RFUFRIXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCSVA0NENvaW5UeXBlTm9kZV8xLkJJUF80NF9DT0lOX1RZUEVfREVQVEg7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZXJpdmVCSVA0NEFkZHJlc3NLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJJUDQ0Q29pblR5cGVOb2RlXzEuZGVyaXZlQklQNDRBZGRyZXNzS2V5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QklQNDRBZGRyZXNzS2V5RGVyaXZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQklQNDRDb2luVHlwZU5vZGVfMS5nZXRCSVA0NEFkZHJlc3NLZXlEZXJpdmVyOyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKSwgZXhwb3J0cyk7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNWYWxpZEJJUDMyUGF0aFNlZ21lbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuaXNWYWxpZEJJUDMyUGF0aFNlZ21lbnQ7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubnVtYmVyVG9VaW50MzIgPSBleHBvcnRzLnZhbGlkYXRlQ3VydmUgPSBleHBvcnRzLm1uZW1vbmljUGhyYXNlVG9CeXRlcyA9IGV4cG9ydHMuZ2V0RmluZ2VycHJpbnQgPSBleHBvcnRzLmVuY29kZUJhc2U1OGNoZWNrID0gZXhwb3J0cy5kZWNvZGVCYXNlNThjaGVjayA9IGV4cG9ydHMuZ2V0Qnl0ZXNVbnNhZmUgPSBleHBvcnRzLmdldEJ5dGVzID0gZXhwb3J0cy5pc1ZhbGlkSW50ZWdlciA9IGV4cG9ydHMuaXNWYWxpZEJ5dGVzS2V5ID0gZXhwb3J0cy5udWxsYWJsZUhleFN0cmluZ1RvQnl0ZXMgPSBleHBvcnRzLmhleFN0cmluZ1RvQnl0ZXMgPSBleHBvcnRzLmlzSGFyZGVuZWQgPSBleHBvcnRzLmlzVmFsaWRCSVAzMlBhdGhTZWdtZW50ID0gZXhwb3J0cy5pc1ZhbGlkQklQMzJJbmRleCA9IGV4cG9ydHMudmFsaWRhdGVCSVAzMkluZGV4ID0gZXhwb3J0cy5nZXRCSVAzMk5vZGVUb2tlbiA9IGV4cG9ydHMuZ2V0VW5oYXJkZW5lZEJJUDMyTm9kZVRva2VuID0gZXhwb3J0cy5nZXRIYXJkZW5lZEJJUDMyTm9kZVRva2VuID0gZXhwb3J0cy5nZXRCSVA0NENvaW5UeXBlVG9BZGRyZXNzUGF0aFR1cGxlID0gZXhwb3J0cy5nZXRCSVA0NENoYW5nZVBhdGhTdHJpbmcgPSBleHBvcnRzLmdldEJJUDQ0Q29pblR5cGVQYXRoU3RyaW5nID0gdm9pZCAwO1xuY29uc3QgZW5nbGlzaF8xID0gcmVxdWlyZShcIkBtZXRhbWFzay9zY3VyZS1iaXAzOS9kaXN0L3dvcmRsaXN0cy9lbmdsaXNoXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5jb25zdCByaXBlbWQxNjBfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3JpcGVtZDE2MFwiKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3QgYmFzZV8xID0gcmVxdWlyZShcIkBzY3VyZS9iYXNlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBjdXJ2ZXNfMSA9IHJlcXVpcmUoXCIuL2N1cnZlc1wiKTtcbi8qKlxuICogR2V0cyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIEJJUC00NCBwYXRoIG9mIGRlcHRoIDIsIGkuZS46XG4gKiBgbSAvIDQ0JyAvIGNvaW5fdHlwZSdgXG4gKlxuICogRm9yIGRpc3BsYXkgcHVycG9zZXMgb25seS5cbiAqXG4gKiBAcGFyYW0gY29pbl90eXBlIC0gVGhlIGBjb2luX3R5cGVgIGluZGV4IHRvIGNyZWF0ZSBhIHBhdGggdmlzdWFsaXphdGlvbiBmb3IuXG4gKiBAcmV0dXJucyBUaGUgdmlzdWFsaXphdGlvbiBvZiB0aGUgQklQLTQ0IHBhdGggZm9yIHRodGUgc3BlY2lmaWVkIGBjb2luX3R5cGVgLlxuICovXG5mdW5jdGlvbiBnZXRCSVA0NENvaW5UeXBlUGF0aFN0cmluZyhjb2luX3R5cGUpIHtcbiAgICByZXR1cm4gYG0gLyAke2NvbnN0YW50c18xLkJJUDQ0UHVycG9zZU5vZGVUb2tlbn0gLyAke2dldEhhcmRlbmVkQklQMzJOb2RlVG9rZW4oY29pbl90eXBlKX1gO1xufVxuZXhwb3J0cy5nZXRCSVA0NENvaW5UeXBlUGF0aFN0cmluZyA9IGdldEJJUDQ0Q29pblR5cGVQYXRoU3RyaW5nO1xuLyoqXG4gKiBHZXRzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgQklQLTQ0IHBhdGggb2YgZGVwdGggNCwgaS5lLjpcbiAqIGBtIC8gNDQnIC8gY29pbl90eXBlJyAvIGFjY291bnQnIC8gY2hhbmdlYFxuICpcbiAqIEZvciBkaXNwbGF5IHB1cnBvc2VzIG9ubHkuXG4gKlxuICogQHBhcmFtIGNvaW5UeXBlUGF0aCAtIFRoZSBwYXJlbnQgYGNvaW5fdHlwZWAgcGF0aC5cbiAqIEBwYXJhbSBpbmRpY2VzIC0gVGhlIGBhY2NvdW50YCBhbmQgYGNoYW5nZWAgaW5kZXggdG8gY3JlYXRlIGEgcGF0aCB2aXN1YWxpemF0aW9uIGZvci5cbiAqIEByZXR1cm5zIFRoZSB2aXN1YWxpemF0aW9uIG9mIHRoZSBCSVAtNDQgcGF0aCBmb3IgdGhlIHNwZWNpZmllZCBgY29pbl90eXBlYFxuICogYW5kIGBjaGFuZ2VgIGluZGljZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEJJUDQ0Q2hhbmdlUGF0aFN0cmluZyhjb2luVHlwZVBhdGgsIGluZGljZXMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBgJHtjb2luVHlwZVBhdGh9IC8gJHtnZXRIYXJkZW5lZEJJUDMyTm9kZVRva2VuKChfYSA9IGluZGljZXMuYWNjb3VudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCl9IC8gJHtnZXRCSVAzMk5vZGVUb2tlbigoX2IgPSBpbmRpY2VzLmNoYW5nZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCl9YDtcbn1cbmV4cG9ydHMuZ2V0QklQNDRDaGFuZ2VQYXRoU3RyaW5nID0gZ2V0QklQNDRDaGFuZ2VQYXRoU3RyaW5nO1xuLyoqXG4gKiBHZXRzIGEgQklQLTQ0IHBhdGggdHVwbGUgb2YgdGhlIGZvcm0gYGFjY291bnQnIC8gY2hhbmdlIC8gYWRkcmVzc19pbmRleGAsXG4gKiB3aGljaCBjYW4gYmUgdXNlZCB0byBkZXJpdmUgYWRkcmVzcyBrZXlzIHRvZ2V0aGVyIHdpdGggYSBgY29pbl90eXBlYCBrZXkuXG4gKlxuICogQHBhcmFtIGluZGljZXMgLSBUaGUgQklQLTQ0IGRlcml2YXRpb24gaW5kZXggdmFsdWVzLlxuICogQHBhcmFtIGluZGljZXMuYWNjb3VudCAtIFRoZSBgYWNjb3VudGAgaW5kZXggdmFsdWUuXG4gKiBAcGFyYW0gaW5kaWNlcy5jaGFuZ2UgLSBUaGUgYGNoYW5nZWAgaW5kZXggdmFsdWUuXG4gKiBAcGFyYW0gaW5kaWNlcy5hZGRyZXNzX2luZGV4IC0gVGhlIGBhZGRyZXNzX2luZGV4YCBpbmRleCB2YWx1ZS5cbiAqIEByZXR1cm5zIFRoZSBgYWNjb3VudCcgLyBjaGFuZ2UgLyBhZGRyZXNzX2luZGV4YCBwYXRoIGNvcnJlc3BvbmRpbmcgdG8gdGhlXG4gKiBzcGVjaWZpZWQgaW5kaWNlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0QklQNDRDb2luVHlwZVRvQWRkcmVzc1BhdGhUdXBsZSh7IGFjY291bnQgPSAwLCBjaGFuZ2UgPSAwLCBhZGRyZXNzX2luZGV4LCB9KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZ2V0SGFyZGVuZWRCSVAzMk5vZGVUb2tlbihhY2NvdW50KSxcbiAgICAgICAgZ2V0QklQMzJOb2RlVG9rZW4oY2hhbmdlKSxcbiAgICAgICAgZ2V0QklQMzJOb2RlVG9rZW4oYWRkcmVzc19pbmRleCksXG4gICAgXTtcbn1cbmV4cG9ydHMuZ2V0QklQNDRDb2luVHlwZVRvQWRkcmVzc1BhdGhUdXBsZSA9IGdldEJJUDQ0Q29pblR5cGVUb0FkZHJlc3NQYXRoVHVwbGU7XG4vKipcbiAqIEEgaGFyZGVuZWQgQklQLTMyIG5vZGUgdG9rZW4sIGUuZy4gYGJpcDMyOjAnYC5cbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSBpbmRleCBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG51bWJlciwgYW5kIHRocm93cyBhblxuICogZXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIG5vZGUuXG4gKiBAcmV0dXJucyBUaGUgaGFyZGVuZWQgQklQLTMyIG5vZGUgdG9rZW4uXG4gKi9cbmZ1bmN0aW9uIGdldEhhcmRlbmVkQklQMzJOb2RlVG9rZW4oaW5kZXgpIHtcbiAgICB2YWxpZGF0ZUJJUDMySW5kZXgoaW5kZXgpO1xuICAgIHJldHVybiBgJHtnZXRVbmhhcmRlbmVkQklQMzJOb2RlVG9rZW4oaW5kZXgpfSdgO1xufVxuZXhwb3J0cy5nZXRIYXJkZW5lZEJJUDMyTm9kZVRva2VuID0gZ2V0SGFyZGVuZWRCSVAzMk5vZGVUb2tlbjtcbi8qKlxuICogQW4gdW5oYXJkZW5lZCBCSVAtMzIgbm9kZSB0b2tlbiwgZS5nLiBgYmlwMzI6MGAuXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgaW5kZXggaXMgYSBub24tbmVnYXRpdmUgaW50ZWdlciBudW1iZXIsIGFuZCB0aHJvd3MgYW5cbiAqIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBub2RlLlxuICogQHJldHVybnMgVGhlIHVuaGFyZGVuZWQgQklQLTMyIG5vZGUgdG9rZW4uXG4gKi9cbmZ1bmN0aW9uIGdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbihpbmRleCkge1xuICAgIHZhbGlkYXRlQklQMzJJbmRleChpbmRleCk7XG4gICAgcmV0dXJuIGBiaXAzMjoke2luZGV4fWA7XG59XG5leHBvcnRzLmdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbiA9IGdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbjtcbi8qKlxuICogQSBoYXJkZW5lZCBvciB1bmhhcmRlbmVkIEJJUC0zMiBub2RlIHRva2VuLCBlLmcuIGBiaXAzMjowYCBvciBgYmlwMzI6MCdgLlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGluZGV4IGlzIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbnVtYmVyLCBhbmQgdGhyb3dzIGFuXG4gKiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICpcbiAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgbm9kZS5cbiAqIEByZXR1cm5zIFRoZSBoYXJkZW5lZCBvciB1bmhhcmRlbmVkIEJJUC0zMiBub2RlIHRva2VuLlxuICovXG5mdW5jdGlvbiBnZXRCSVAzMk5vZGVUb2tlbihpbmRleCkge1xuICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBnZXRVbmhhcmRlbmVkQklQMzJOb2RlVG9rZW4oaW5kZXgpO1xuICAgIH1cbiAgICBpZiAoIWluZGV4IHx8XG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKGluZGV4LmluZGV4KSB8fFxuICAgICAgICB0eXBlb2YgaW5kZXguaGFyZGVuZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQklQLTMyIGluZGV4OiBNdXN0IGJlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBpbmRleCBhbmQgd2hldGhlciBpdCBpcyBoYXJkZW5lZC4nKTtcbiAgICB9XG4gICAgaWYgKGluZGV4LmhhcmRlbmVkKSB7XG4gICAgICAgIHJldHVybiBnZXRIYXJkZW5lZEJJUDMyTm9kZVRva2VuKGluZGV4LmluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldFVuaGFyZGVuZWRCSVAzMk5vZGVUb2tlbihpbmRleC5pbmRleCk7XG59XG5leHBvcnRzLmdldEJJUDMyTm9kZVRva2VuID0gZ2V0QklQMzJOb2RlVG9rZW47XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSBpbmRleCBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIG51bWJlci4gVGhyb3dzIGFuXG4gKiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICpcbiAqIEBwYXJhbSBhZGRyZXNzSW5kZXggLSBUaGUgaW5kZXggdG8gdmFsaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQklQMzJJbmRleChhZGRyZXNzSW5kZXgpIHtcbiAgICBpZiAoIWlzVmFsaWRCSVAzMkluZGV4KGFkZHJlc3NJbmRleCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEJJUC0zMiBpbmRleDogTXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLmApO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVCSVAzMkluZGV4ID0gdmFsaWRhdGVCSVAzMkluZGV4O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgaW5kZXggaXMgYSB2YWxpZCBCSVAtMzIgaW5kZXguXG4gKlxuICogQHBhcmFtIGluZGV4IC0gVGhlIEJJUC0zMiBpbmRleCB0byB0ZXN0LlxuICogQHJldHVybnMgV2hldGhlciB0aGUgaW5kZXggaXMgYSBub24tbmVnYXRpdmUgaW50ZWdlciBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRCSVAzMkluZGV4KGluZGV4KSB7XG4gICAgcmV0dXJuIGlzVmFsaWRJbnRlZ2VyKGluZGV4KSAmJiBpbmRleCA8PSBjb25zdGFudHNfMS5NQVhfQklQXzMyX0lOREVYO1xufVxuZXhwb3J0cy5pc1ZhbGlkQklQMzJJbmRleCA9IGlzVmFsaWRCSVAzMkluZGV4O1xuLyoqXG4gKiBDaGVjayBpZiB0aGUgdmFsdWUgaXMgYSB2YWxpZCBCSVAtMzIgcGF0aCBzZWdtZW50LCBpLmUuLCBhIHN0cmluZyBvZiB0aGUgZm9ybVxuICogYDAnYC5cbiAqXG4gKiBAcGFyYW0gc2VnbWVudCAtIFRoZSBCSVAtMzIgcGF0aCBzZWdtZW50IHRvIHRlc3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwYXRoIHNlZ21lbnQgaXMgYSB2YWxpZCBCSVAtMzIgcGF0aCBzZWdtZW50LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQklQMzJQYXRoU2VnbWVudChzZWdtZW50KSB7XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gc2VnbWVudC5tYXRjaChjb25zdGFudHNfMS5VTlBSRUZJWEVEX0JJUF8zMl9QQVRIX1JFR0VYKTtcbiAgICBpZiAoIShtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2guZ3JvdXBzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQobWF0Y2guZ3JvdXBzLmluZGV4LCAxMCk7XG4gICAgcmV0dXJuIGlzVmFsaWRJbnRlZ2VyKGluZGV4KSAmJiBpbmRleCA8PSBjb25zdGFudHNfMS5NQVhfVU5IQVJERU5FRF9CSVBfMzJfSU5ERVg7XG59XG5leHBvcnRzLmlzVmFsaWRCSVAzMlBhdGhTZWdtZW50ID0gaXNWYWxpZEJJUDMyUGF0aFNlZ21lbnQ7XG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhIGhhcmRlbmVkIEJJUC0zMiBpbmRleC4gVGhpcyBvbmx5IGNoZWNrcyBpZiB0aGUgdmFsdWVcbiAqIGVuZHMgd2l0aCBhIGAnYCBjaGFyYWN0ZXIsIGFuZCBkb2VzIG5vdCB2YWxpZGF0ZSB0aGF0IHRoZSBpbmRleCBpcyBhIHZhbGlkXG4gKiBCSVAtMzIgaW5kZXguXG4gKlxuICogQHBhcmFtIGJpcDMyVG9rZW4gLSBUaGUgdG9rZW4gdG8gdGVzdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRva2VuIGlzIGhhcmRlbmVkLCBpLmUuIGVuZHMgd2l0aCBgJ2AuXG4gKi9cbmZ1bmN0aW9uIGlzSGFyZGVuZWQoYmlwMzJUb2tlbikge1xuICAgIHJldHVybiBiaXAzMlRva2VuLmVuZHNXaXRoKGAnYCk7XG59XG5leHBvcnRzLmlzSGFyZGVuZWQgPSBpc0hhcmRlbmVkO1xuLyoqXG4gKiBHZXQgYSBgVWludDhBcnJheWAgZnJvbSBhIGhleGFkZWNpbWFsIHN0cmluZyBvciBhIGBVaW50OEFycmF5YC4gSWYgdGhlIGlucHV0XG4gKiBpcyBhIGhleGFkZWNpbWFsIHN0cmluZywgaXQgaXMgY29udmVydGVkIHRvIGEgYFVpbnQ4QXJyYXlgLiBJZiB0aGUgaW5wdXQgaXNcbiAqIGEgYFVpbnQ4QXJyYXlgLCBpdCBpcyByZXR1cm5lZCBhcy1pcy5cbiAqXG4gKiBAcGFyYW0gaGV4U3RyaW5nIC0gVGhlIGhleGFkZWNpbWFsIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGBVaW50OEFycmF5YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBoZXhhZGVjaW1hbCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGhleFN0cmluZ1RvQnl0ZXMoaGV4U3RyaW5nKSB7XG4gICAgaWYgKGhleFN0cmluZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGhleFN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmhleFRvQnl0ZXMpKGhleFN0cmluZyk7XG59XG5leHBvcnRzLmhleFN0cmluZ1RvQnl0ZXMgPSBoZXhTdHJpbmdUb0J5dGVzO1xuLyoqXG4gKiBUaGUgc2FtZSBhcyB7QGxpbmsgaGV4U3RyaW5nVG9CeXRlc30sIGJ1dCByZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBpbnB1dFxuICogaXMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIGhleFN0cmluZyAtIFRoZSBoZXhhZGVjaW1hbCBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBgVWludDhBcnJheWAgY29ycmVzcG9uZGluZyB0byB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBudWxsYWJsZUhleFN0cmluZ1RvQnl0ZXMoaGV4U3RyaW5nKSB7XG4gICAgaWYgKGhleFN0cmluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBoZXhTdHJpbmdUb0J5dGVzKGhleFN0cmluZyk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLm51bGxhYmxlSGV4U3RyaW5nVG9CeXRlcyA9IG51bGxhYmxlSGV4U3RyaW5nVG9CeXRlcztcbi8qKlxuICogVGVzdHMgd2hldGhlciB0aGUgc3BlY2lmaWVkIGBVaW50OEFycmF5YCBpcyBhIHZhbGlkIEJJUC0zMiBrZXkuXG4gKiBBIHZhbGlkIGJ5dGVzIGtleSBpcyA2NCBieXRlcyBsb25nIGFuZCBoYXMgYXQgbGVhc3Qgb25lIG5vbi16ZXJvIGJ5dGUuXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIGBVaW50OEFycmF5YCB0byB0ZXN0LlxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIC0gVGhlIGV4cGVjdGVkIGxlbmd0aCBvZiB0aGUgVWludDhBcnJheS5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIFVpbnQ4QXJyYXkgcmVwcmVzZW50cyBhIHZhbGlkIEJJUC0zMiBrZXkuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRCeXRlc0tleShieXRlcywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYnl0ZSBvZiBieXRlcykge1xuICAgICAgICBpZiAoYnl0ZSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc1ZhbGlkQnl0ZXNLZXkgPSBpc1ZhbGlkQnl0ZXNLZXk7XG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBudW1iZXIgaXMgYSB2YWxpZCBpbnRlZ2VyIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgdG8gdGVzdC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG51bWJlciBpcyBhIHZhbGlkIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRJbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPj0gMDtcbn1cbmV4cG9ydHMuaXNWYWxpZEludGVnZXIgPSBpc1ZhbGlkSW50ZWdlcjtcbi8qKlxuICogR2V0IGEgYFVpbnQ4QXJyYXlgIGZyb20gYSBoZXhhZGVjaW1hbCBzdHJpbmcgb3IgYFVpbnQ4QXJyYXlgLiBWYWxpZGF0ZXMgdGhhdCB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgYFVpbnQ4QXJyYXlgIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBsZW5ndGgsIGFuZCB0aGF0IHRoZSBgVWludDhBcnJheWBcbiAqIGlzIG5vdCBlbXB0eS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhIGBVaW50OEFycmF5YC5cbiAqIEBwYXJhbSBsZW5ndGggLSBUaGUgbGVuZ3RoIHRvIHZhbGlkYXRlIHRoZSBgVWludDhBcnJheWAgYWdhaW5zdC5cbiAqIEByZXR1cm5zIFRoZSBgVWludDhBcnJheWAgY29ycmVzcG9uZGluZyB0byB0aGUgaGV4YWRlY2ltYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBnZXRCeXRlcyh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICB2YWxpZGF0ZUJ5dGVzKHZhbHVlLCBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gKDAsIHV0aWxzXzEuaGV4VG9CeXRlcykodmFsdWUpO1xuICAgICAgICB2YWxpZGF0ZUJ5dGVzKGJ5dGVzLCBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZTogRXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgVWludDhBcnJheSBvciBoZXhhZGVjaW1hbCBzdHJpbmcuYCk7XG59XG5leHBvcnRzLmdldEJ5dGVzID0gZ2V0Qnl0ZXM7XG4vKipcbiAqIEdldCBhIGBVaW50OEFycmF5YCBmcm9tIGEgaGV4YWRlY2ltYWwgc3RyaW5nIG9yIGBVaW50OEFycmF5YC4gVmFsaWRhdGVzIHRoYXRcbiAqIHRoZSBsZW5ndGggb2YgdGhlIGBVaW50OEFycmF5YCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgXCJ1bnNhZmUsXCIgaW4gdGhlIHNlbnNlIHRoYXQgaXQgZG9lcyBub3QgdmFsaWRhdGUgdGhhdCB0aGVcbiAqIGBVaW50OEFycmF5YCBpcyBub3QgZW1wdHkgKGkuZS4sIGFsbCBieXRlcyBhcmUgemVybykuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBgVWludDhBcnJheWAuXG4gKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIGxlbmd0aCB0byB2YWxpZGF0ZSB0aGUgYFVpbnQ4QXJyYXlgIGFnYWluc3QuXG4gKiBAcmV0dXJucyBUaGUgYFVpbnQ4QXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGhleGFkZWNpbWFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0Qnl0ZXNVbnNhZmUodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgKDAsIHV0aWxzXzEuYXNzZXJ0KSh2YWx1ZS5sZW5ndGggPT09IGxlbmd0aCwgYEludmFsaWQgdmFsdWU6IE11c3QgYmUgYSAke2xlbmd0aH0tYnl0ZSBieXRlIGFycmF5LmApO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBnZXRCeXRlc1Vuc2FmZSgoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKSh2YWx1ZSksIGxlbmd0aCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZTogRXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgVWludDhBcnJheSBvciBoZXhhZGVjaW1hbCBzdHJpbmcuYCk7XG59XG5leHBvcnRzLmdldEJ5dGVzVW5zYWZlID0gZ2V0Qnl0ZXNVbnNhZmU7XG4vKipcbiAqIFZhbGlkYXRlIHRoYXQgdGhlIHNwZWNpZmllZCBgVWludDhBcnJheWAgaXMgbm90IGVtcHR5IGFuZCBoYXMgdGhlIHNwZWNpZmllZFxuICogbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSBgVWludDhBcnJheWAgdG8gdmFsaWRhdGUuXG4gKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIGxlbmd0aCB0byB2YWxpZGF0ZSB0aGUgYFVpbnQ4QXJyYXlgIGFnYWluc3QuXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBgVWludDhBcnJheWAgaXMgZW1wdHkgb3IgaGFzIHRoZSB3cm9uZyBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQnl0ZXMoYnl0ZXMsIGxlbmd0aCkge1xuICAgIGlmICghaXNWYWxpZEJ5dGVzS2V5KGJ5dGVzLCBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZTogTXVzdCBiZSBhIG5vbi16ZXJvICR7bGVuZ3RofS1ieXRlIGJ5dGUgYXJyYXkuYCk7XG4gICAgfVxufVxuY29uc3QgZGVjb2RlQmFzZTU4Y2hlY2sgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBiYXNlNThDaGVjayA9ICgwLCBiYXNlXzEuYmFzZTU4Y2hlY2spKHNoYTI1Nl8xLnNoYTI1Nik7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGJhc2U1OENoZWNrLmRlY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXh0ZW5kZWQga2V5OiBWYWx1ZSBpcyBub3QgYmFzZTU4LWVuY29kZWQsIG9yIHRoZSBjaGVja3N1bSBpcyBpbnZhbGlkLmApO1xuICAgIH1cbn07XG5leHBvcnRzLmRlY29kZUJhc2U1OGNoZWNrID0gZGVjb2RlQmFzZTU4Y2hlY2s7XG5jb25zdCBlbmNvZGVCYXNlNThjaGVjayA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGJhc2U1OENoZWNrID0gKDAsIGJhc2VfMS5iYXNlNThjaGVjaykoc2hhMjU2XzEuc2hhMjU2KTtcbiAgICByZXR1cm4gYmFzZTU4Q2hlY2suZW5jb2RlKHZhbHVlKTtcbn07XG5leHBvcnRzLmVuY29kZUJhc2U1OGNoZWNrID0gZW5jb2RlQmFzZTU4Y2hlY2s7XG4vKipcbiAqIEdldCB0aGUgZmluZ2VycHJpbnQgb2YgYSBjb21wcmVzc2VkIHB1YmxpYyBrZXkgYXMgbnVtYmVyLlxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5IHRvIGdldCB0aGUgZmluZ2VycHJpbnQgZm9yLlxuICogQHJldHVybnMgVGhlIGZpbmdlcnByaW50IG9mIHRoZSBwdWJsaWMga2V5LlxuICovXG5jb25zdCBnZXRGaW5nZXJwcmludCA9IChwdWJsaWNLZXkpID0+IHtcbiAgICBpZiAoIWlzVmFsaWRCeXRlc0tleShwdWJsaWNLZXksIDMzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcHVibGljIGtleTogVGhlIGtleSBtdXN0IGJlIGEgMzMtYnl0ZSwgbm9uLXplcm8gYnl0ZSBhcnJheS5gKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgcmlwZW1kMTYwXzEucmlwZW1kMTYwKSgoMCwgc2hhMjU2XzEuc2hhMjU2KShwdWJsaWNLZXkpKTtcbiAgICBjb25zdCB2aWV3ID0gKDAsIHV0aWxzXzEuY3JlYXRlRGF0YVZpZXcpKGJ5dGVzKTtcbiAgICByZXR1cm4gdmlldy5nZXRVaW50MzIoMCwgZmFsc2UpO1xufTtcbmV4cG9ydHMuZ2V0RmluZ2VycHJpbnQgPSBnZXRGaW5nZXJwcmludDtcbi8qKlxuICogR2V0IGEgc2VjcmV0IHJlY292ZXJ5IHBocmFzZSAob3IgbW5lbW9uaWMgcGhyYXNlKSBpbiBzdHJpbmcgZm9ybSBhcyBhXG4gKiBgVWludDhBcnJheWAuIFRoZSBzZWNyZXQgcmVjb3ZlcnkgcGhyYXNlIGlzIHNwbGl0IGludG8gd29yZHMsIGFuZCBlYWNoIHdvcmRcbiAqIGlzIGNvbnZlcnRlZCB0byBhIG51bWJlciB1c2luZyB0aGUgQklQLTM5IHdvcmQgbGlzdC4gVGhlIG51bWJlcnMgYXJlIHRoZW5cbiAqIGNvbnZlcnRlZCB0byBieXRlcywgYW5kIHRoZSBieXRlcyBhcmUgY29uY2F0ZW5hdGVkIGludG8gYSBzaW5nbGVcbiAqIGBVaW50OEFycmF5YC5cbiAqXG4gKiBAcGFyYW0gbW5lbW9uaWNQaHJhc2UgLSBUaGUgc2VjcmV0IHJlY292ZXJ5IHBocmFzZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGBVaW50OEFycmF5YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBzZWNyZXQgcmVjb3ZlcnkgcGhyYXNlLlxuICovXG5mdW5jdGlvbiBtbmVtb25pY1BocmFzZVRvQnl0ZXMobW5lbW9uaWNQaHJhc2UpIHtcbiAgICBjb25zdCB3b3JkcyA9IG1uZW1vbmljUGhyYXNlLnNwbGl0KCcgJyk7XG4gICAgY29uc3QgaW5kaWNlcyA9IHdvcmRzLm1hcCgod29yZCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IGVuZ2xpc2hfMS53b3JkbGlzdC5pbmRleE9mKHdvcmQpO1xuICAgICAgICAoMCwgdXRpbHNfMS5hc3NlcnQpKGluZGV4ICE9PSAtMSwgYEludmFsaWQgbW5lbW9uaWMgcGhyYXNlOiBVbmtub3duIHdvcmQgXCIke3dvcmR9XCIuYCk7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQxNkFycmF5KGluZGljZXMpLmJ1ZmZlcik7XG59XG5leHBvcnRzLm1uZW1vbmljUGhyYXNlVG9CeXRlcyA9IG1uZW1vbmljUGhyYXNlVG9CeXRlcztcbi8qKlxuICogVmFsaWRhdGVzIHRoZSBjdXJ2ZSBuYW1lLlxuICpcbiAqIEBwYXJhbSBjdXJ2ZU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY3VydmUgdG8gdmFsaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ3VydmUoY3VydmVOYW1lKSB7XG4gICAgaWYgKCFjdXJ2ZU5hbWUgfHwgdHlwZW9mIGN1cnZlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGN1cnZlOiBNdXN0IHNwZWNpZnkgYSBjdXJ2ZS4nKTtcbiAgICB9XG4gICAgaWYgKCFPYmplY3Qua2V5cyhjdXJ2ZXNfMS5jdXJ2ZXMpLmluY2x1ZGVzKGN1cnZlTmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGN1cnZlOiBPbmx5IHRoZSBmb2xsb3dpbmcgY3VydmVzIGFyZSBzdXBwb3J0ZWQ6ICR7T2JqZWN0LmtleXMoY3VydmVzXzEuY3VydmVzKS5qb2luKCcsICcpfS5gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlQ3VydmUgPSB2YWxpZGF0ZUN1cnZlO1xuLyoqXG4gKiBHZXQgYSA0LWJ5dGUtbG9uZyBgVWludDhBcnJheWAgZnJvbSBhIG51bWVyaWMgdmFsdWUuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYSBgVWludDhBcnJheWAuXG4gKiBAcmV0dXJucyBUaGUgYFVpbnQ4QXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGBiaWdpbnRgIHZhbHVlLlxuICovXG5mdW5jdGlvbiBudW1iZXJUb1VpbnQzMih2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY29uc3QgdmlldyA9ICgwLCB1dGlsc18xLmNyZWF0ZURhdGFWaWV3KShieXRlcyk7XG4gICAgdmlldy5zZXRVaW50MzIoMCwgdmFsdWUsIGZhbHNlKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnRzLm51bWJlclRvVWludDMyID0gbnVtYmVyVG9VaW50MzI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXNzZXJ0RXhoYXVzdGl2ZSA9IGV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gZXhwb3J0cy5hc3NlcnQgPSBleHBvcnRzLkFzc2VydGlvbkVycm9yID0gdm9pZCAwO1xuY29uc3Qgc3VwZXJzdHJ1Y3RfMSA9IHJlcXVpcmUoXCJzdXBlcnN0cnVjdFwiKTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYW4gZXJyb3Igb2JqZWN0IHdpdGggYVxuICogYG1lc3NhZ2VgIHByb3BlcnR5LCBzdWNoIGFzIGFuIGluc3RhbmNlIG9mIEVycm9yLlxuICpcbiAqIEBwYXJhbSBlcnJvciAtIFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBUcnVlIG9yIGZhbHNlLCBkZXBlbmRpbmcgb24gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ21lc3NhZ2UnIGluIGVycm9yO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgY29uc3RydWN0b3IsIGkuZS4sIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgY2FsbGVkIHdpdGhcbiAqIHRoZSBgbmV3YCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSBmbiAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSBjb25zdHJ1Y3Rvciwgb3IgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzQ29uc3RydWN0YWJsZShmbikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZW9mIGZuPy5wcm90b3R5cGU/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnc3RyaW5nJyk7XG59XG4vKipcbiAqIEdldCB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIGFuIHVua25vd24gZXJyb3Igb2JqZWN0LiBJZiB0aGUgZXJyb3Igb2JqZWN0IGhhc1xuICogYSBgbWVzc2FnZWAgcHJvcGVydHksIHRoYXQgcHJvcGVydHkgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIHN0cmluZ2lmaWVkXG4gKiBlcnJvciBvYmplY3QgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIG9iamVjdCB0byBnZXQgdGhlIG1lc3NhZ2UgZnJvbS5cbiAqIEByZXR1cm5zIFRoZSBlcnJvciBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gaXNFcnJvcldpdGhNZXNzYWdlKGVycm9yKSA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgIC8vIElmIHRoZSBlcnJvciBlbmRzIHdpdGggYSBwZXJpb2QsIHJlbW92ZSBpdCwgYXMgd2UnbGwgYWRkIG91ciBvd24gcGVyaW9kLlxuICAgIGlmIChtZXNzYWdlLmVuZHNXaXRoKCcuJykpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2Uuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8qKlxuICogSW5pdGlhbGlzZSBhbiB7QGxpbmsgQXNzZXJ0aW9uRXJyb3JDb25zdHJ1Y3Rvcn0gZXJyb3IuXG4gKlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB1c2UuXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGVycm9yIG9iamVjdC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuZnVuY3Rpb24gZ2V0RXJyb3IoRXJyb3JXcmFwcGVyLCBtZXNzYWdlKSB7XG4gICAgaWYgKGlzQ29uc3RydWN0YWJsZShFcnJvcldyYXBwZXIpKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JXcmFwcGVyKHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gRXJyb3JXcmFwcGVyKHtcbiAgICAgICAgbWVzc2FnZSxcbiAgICB9KTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgZXJyb3IgY2xhc3MgdGhhdCBpcyB0aHJvd24gaWYgYW4gYXNzZXJ0aW9uIGZhaWxzLlxuICovXG5jbGFzcyBBc3NlcnRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfQVNTRVJUSU9OJztcbiAgICB9XG59XG5leHBvcnRzLkFzc2VydGlvbkVycm9yID0gQXNzZXJ0aW9uRXJyb3I7XG4vKipcbiAqIFNhbWUgYXMgTm9kZS5qcyBhc3NlcnQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgZmFsc3ksIHRocm93cyBhbiBlcnJvciwgZG9lcyBub3RoaW5nIG90aGVyd2lzZS5cbiAqXG4gKiBAdGhyb3dzIHtAbGluayBBc3NlcnRpb25FcnJvcn0gSWYgdmFsdWUgaXMgZmFsc3kuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdGVzdCB0aGF0IHNob3VsZCBiZSB0cnV0aHkgdG8gcGFzcy5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gTWVzc2FnZSB0byBiZSBwYXNzZWQgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfSBvciBhblxuICoge0BsaW5rIEVycm9yfSBpbnN0YW5jZSB0byB0aHJvdy5cbiAqIEBwYXJhbSBFcnJvcldyYXBwZXIgLSBUaGUgZXJyb3IgY2xhc3MgdG8gdGhyb3cgaWYgdGhlIGFzc2VydGlvbiBmYWlscy5cbiAqIERlZmF1bHRzIHRvIHtAbGluayBBc3NlcnRpb25FcnJvcn0uIElmIGEgY3VzdG9tIGVycm9yIGNsYXNzIGlzIHByb3ZpZGVkIGZvclxuICogdGhlIGBtZXNzYWdlYCBhcmd1bWVudCwgdGhpcyBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UgPSAnQXNzZXJ0aW9uIGZhaWxlZC4nLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4vKipcbiAqIEFzc2VydCBhIHZhbHVlIGFnYWluc3QgYSBTdXBlcnN0cnVjdCBzdHJ1Y3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHZhbGlkYXRlLlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJ1Y3QgdG8gdmFsaWRhdGUgYWdhaW5zdC5cbiAqIEBwYXJhbSBlcnJvclByZWZpeCAtIEEgcHJlZml4IHRvIGFkZCB0byB0aGUgZXJyb3IgbWVzc2FnZS4gRGVmYXVsdHMgdG9cbiAqIFwiQXNzZXJ0aW9uIGZhaWxlZFwiLlxuICogQHBhcmFtIEVycm9yV3JhcHBlciAtIFRoZSBlcnJvciBjbGFzcyB0byB0aHJvdyBpZiB0aGUgYXNzZXJ0aW9uIGZhaWxzLlxuICogRGVmYXVsdHMgdG8ge0BsaW5rIEFzc2VydGlvbkVycm9yfS5cbiAqIEB0aHJvd3MgSWYgdGhlIHZhbHVlIGlzIG5vdCB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U3RydWN0KHZhbHVlLCBzdHJ1Y3QsIGVycm9yUHJlZml4ID0gJ0Fzc2VydGlvbiBmYWlsZWQnLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbkVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgKDAsIHN1cGVyc3RydWN0XzEuYXNzZXJ0KSh2YWx1ZSwgc3RydWN0KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGdldEVycm9yKEVycm9yV3JhcHBlciwgYCR7ZXJyb3JQcmVmaXh9OiAke2dldEVycm9yTWVzc2FnZShlcnJvcil9LmApO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0U3RydWN0ID0gYXNzZXJ0U3RydWN0O1xuLyoqXG4gKiBVc2UgaW4gdGhlIGRlZmF1bHQgY2FzZSBvZiBhIHN3aXRjaCB0aGF0IHlvdSB3YW50IHRvIGJlIGZ1bGx5IGV4aGF1c3RpdmUuXG4gKiBVc2luZyB0aGlzIGZ1bmN0aW9uIGZvcmNlcyB0aGUgY29tcGlsZXIgdG8gZW5mb3JjZSBleGhhdXN0aXZpdHkgZHVyaW5nXG4gKiBjb21waWxlLXRpbWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogY29uc3QgbnVtYmVyID0gMTtcbiAqIHN3aXRjaCAobnVtYmVyKSB7XG4gKiAgIGNhc2UgMDpcbiAqICAgICAuLi5cbiAqICAgY2FzZSAxOlxuICogICAgIC4uLlxuICogICBkZWZhdWx0OlxuICogICAgIGFzc2VydEV4aGF1c3RpdmUoc25hcFByZWZpeCk7XG4gKiB9XG4gKiBgYGBcbiAqIEBwYXJhbSBfb2JqZWN0IC0gVGhlIG9iamVjdCBvbiB3aGljaCB0aGUgc3dpdGNoIGlzIGJlaW5nIG9wZXJhdGVkLlxuICovXG5mdW5jdGlvbiBhc3NlcnRFeGhhdXN0aXZlKF9vYmplY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnJhbmNoIHJlYWNoZWQuIFNob3VsZCBiZSBkZXRlY3RlZCBkdXJpbmcgY29tcGlsYXRpb24uJyk7XG59XG5leHBvcnRzLmFzc2VydEV4aGF1c3RpdmUgPSBhc3NlcnRFeGhhdXN0aXZlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXNlNjQgPSB2b2lkIDA7XG5jb25zdCBzdXBlcnN0cnVjdF8xID0gcmVxdWlyZShcInN1cGVyc3RydWN0XCIpO1xuY29uc3QgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgcHJvdmlkZWQgc3RyaW5nLWJhc2VkIHN0cnVjdCBpcyB2YWxpZCBiYXNlNjQuXG4gKlxuICogQHBhcmFtIHN0cnVjdCAtIFRoZSBzdHJpbmcgYmFzZWQgc3RydWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIHRvIHNwZWNpYWxpemUgYmFzZTY0IHZhbGlkYXRpb24uIFNlZSB7QGxpbmsgQmFzZTY0T3B0aW9uc30gZG9jdW1lbnRhdGlvbi5cbiAqIEByZXR1cm5zIEEgc3VwZXJzdHJ1Y3QgdmFsaWRhdGluZyBiYXNlNjQuXG4gKi9cbmNvbnN0IGJhc2U2NCA9IChzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IHBhZGRpbmdSZXF1aXJlZCA9IG9wdGlvbnMucGFkZGluZ1JlcXVpcmVkID8/IGZhbHNlO1xuICAgIGNvbnN0IGNoYXJhY3RlclNldCA9IG9wdGlvbnMuY2hhcmFjdGVyU2V0ID8/ICdiYXNlNjQnO1xuICAgIGxldCBsZXR0ZXJzO1xuICAgIGlmIChjaGFyYWN0ZXJTZXQgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbQS1aYS16MC05K1xcL11gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgKDAsIGFzc2VydF8xLmFzc2VydCkoY2hhcmFjdGVyU2V0ID09PSAnYmFzZTY0dXJsJyk7XG4gICAgICAgIGxldHRlcnMgPSBTdHJpbmcucmF3IGBbLV9BLVphLXowLTldYDtcbiAgICB9XG4gICAgbGV0IHJlO1xuICAgIGlmIChwYWRkaW5nUmVxdWlyZWQpIHtcbiAgICAgICAgcmUgPSBuZXcgUmVnRXhwKGBeKD86JHtsZXR0ZXJzfXs0fSkqKD86JHtsZXR0ZXJzfXszfT18JHtsZXR0ZXJzfXsyfT09KT8kYCwgJ3UnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlID0gbmV3IFJlZ0V4cChgXig/OiR7bGV0dGVyc317NH0pKig/OiR7bGV0dGVyc317MiwzfXwke2xldHRlcnN9ezN9PXwke2xldHRlcnN9ezJ9PT0pPyRgLCAndScpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHN1cGVyc3RydWN0XzEucGF0dGVybikoc3RydWN0LCByZSk7XG59O1xuZXhwb3J0cy5iYXNlNjQgPSBiYXNlNjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIl0sInByZUV4aXN0aW5nQ29tbWVudCI6Ii8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJ9
